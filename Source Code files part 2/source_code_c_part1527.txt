CKsProxy::GetPositions(
    LONGLONG* Current,
    LONGLONG* Stop
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetPositions method. Calls the
    separate GetCurrentPosition and GetStopPosition methods to
    retrieve these.

Arguments:

    Current -
        The place in which to put the current position.

    Stop -
        The place in which to put the current stop position.

Return Value:

    Returns S_OK if the positions where retrieved successfully, else
    some failure if this property is not supported.

--*/
{
    HRESULT hr;

    if (SUCCEEDED(hr = GetCurrentPosition(Current))) {
        hr = GetStopPosition(Stop);
    }
    return hr;
}


STDMETHODIMP
CKsProxy::GetAvailable(
    LONGLONG* Earliest,
    LONGLONG* Latest
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetAvailable method. Queries
    the currently available data from the filter. If the filter
    does not support the query, the first connected pin to respond
    to the query is the available data returned.

Arguments:

    Earliest -
        The place in which to put the earliest position available.

    Latest -
        The place in which to put the latest position available.

Return Value:

    Returns S_OK if the positions are returned, else some
    failure if this property is not supported.

--*/
{
    HRESULT                     hr;
    KSPROPERTY                  Property;
    KSPROPERTY_MEDIAAVAILABLE   Available;
    ULONG                       BytesReturned;
    CAutoLock                   AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_AVAILABLE;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &Available,
        sizeof(Available),
        &BytesReturned);
    if (SUCCEEDED(hr)) {
        *Earliest = Available.Earliest;
        *Latest = Available.Latest;
    } else if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // positions of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a current position.
                    //
                    hr = MediaSeeking->GetAvailable(Earliest, Latest);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::SetRate(
    double Rate
    )
/*++

Routine Description:

    Implement the IMediaSeeking::SetRate method. This is not
    actually implemented.

Arguments:

    Rate -
        Not used.

Return Value:

    Returns E_NOTIMPL.

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CKsProxy::GetRate(
    double* Rate
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetRate method. This is not
    actually implemented.

Arguments:

    Rate -
        Not used.

Return Value:

    Returns E_NOTIMPL.

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CKsProxy::GetPreroll(
    LONGLONG* Preroll
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetPreroll method. Queries
    the preroll from the filter. If the filter does not support the
    query, the first connected pin to respond to the query is the
    preroll returned.

Arguments:

    Preroll -
        The place in which to put the preroll time.

Return Value:

    Returns S_OK if the preroll time is returned, else some
    failure if this property is not supported.

--*/
{
    HRESULT         hr;
    KSPROPERTY      Property;
    ULONG           BytesReturned;
    CAutoLock       AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_PREROLL;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Preroll,
        sizeof(*Preroll),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // preroll of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a current position.
                    //
                    hr = MediaSeeking->GetPreroll(Preroll);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP 
CKsProxy::Load(
    LPPROPERTYBAG PropertyBag,
    LPERRORLOG ErrorLog
    )
/*++

Routine Description:

    Implement the IPersistPropertyBag::Load method. This is called by
    the ActiveMovie devenum in order to actually open the new filter
    instance. The function retrieves the symbolic link name from the
    property bag given.

Arguments:

    PropertyBag -
        The property bag to retrieve the symbolic link name from.

    ErrorLog -
        Error log passed to the property query.

Return Value:

    Returns NOERROR if the filter was opened, else some creation error.

--*/
{
    HRESULT hr;
    VARIANT Variant;
    TCHAR*  SymbolicLink;
    LONG    RetCode;
    HKEY    hKey;
    DWORD   ValueSize;
    DWORD   Value;


    Variant.vt = VT_BSTR;

#ifdef DEBUG
    // Check the registry and see if anyone thinks we can use the old way.
    // We can't, the old way died in Whistler (due to atrophy).

    RetCode = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\KsProxy"),
        0,
        KEY_READ,
        &hKey);

    if (RetCode == ERROR_SUCCESS) {
        ValueSize = sizeof(Value);
        RetCode = RegQueryValueEx(
            hKey,
            TEXT("UseNewAllocators"),
            0,
            NULL,
            (BYTE*) &Value,
            &ValueSize);

        if ((RetCode == ERROR_SUCCESS) && (ValueSize == sizeof(Value)) && (Value == 0)) {
            ASSERT(!TEXT("A proxied component is trying to use the old allocator code path.  Forcing new code path - execution may fail."));
        }

        RegCloseKey(hKey);
    }
#endif // DEBUG

    Global.DefaultNumberBuffers = 1;
    Global.DefaultBufferSize = 4096;
    Global.DefaultBufferAlignment = 1;

    //
    // Retrieve the symbolic link name from the property bag.
    //
    hr = PropertyBag->Read(L"DevicePath", &Variant, ErrorLog);
    if(SUCCEEDED(hr)) {
        HDEVINFO    DevInfo;
        ULONG   SymbolicLinkSize;

        //
        // Save this off in case it is needed on device removal in the
        // IAMDeviceRemoval interface. This will be deleted when the
        // filter object is deleted.
        //
        m_SymbolicLink = Variant.bstrVal;
#ifdef _UNICODE
        SymbolicLink = Variant.bstrVal;
        SymbolicLinkSize = _tcslen(Variant.bstrVal) + 1;
#else
        //
        // If not compiling for Unicode, then object names are Ansi, but
        // the pin names are still Unicode, so a MultiByte string needs to
        // be constructed.
        //
        BOOL    DefaultUsed;

        SymbolicLinkSize = wcslen(Variant.bstrVal) + 1;
        //
        // Hoping for a one to one replacement of characters.
        //
        SymbolicLink = new char[SymbolicLinkSize];
        if (!SymbolicLink) {
            return E_OUTOFMEMORY;
        }
        WideCharToMultiByte(0, 0, Variant.bstrVal, -1, SymbolicLink, SymbolicLinkSize, NULL, &DefaultUsed);
#endif
        DevInfo = SetupDiCreateDeviceInfoListEx(NULL, NULL, NULL, NULL);
        if (DevInfo != INVALID_HANDLE_VALUE) {
            SP_DEVICE_INTERFACE_DATA    DeviceData;

            DeviceData.cbSize = sizeof(DeviceData);
            if (SetupDiOpenDeviceInterface(DevInfo, SymbolicLink, 0, &DeviceData)) {
                //
                // This key is kept open while the filter instance exists so
                // that key contents can be queried in order to load static
                // aggregates. But before assuming this is the right key
                // to leave open, look for a link to the base class. I.e.,
                // all the interfaces but one should point to a single
                // interface class as the "base" where all the information
                // beyond FriendlyName and CLSID are kept.
                //
                m_DeviceRegKey = SetupDiOpenDeviceInterfaceRegKey(
                    DevInfo,
                    &DeviceData,
                    NULL,
                    KEY_READ);
                if (m_DeviceRegKey == INVALID_HANDLE_VALUE) {
                    m_DeviceRegKey = NULL;
                } else {
                    LONG    Result;
                    GUID    InterfaceLink;

                    ValueSize = sizeof(InterfaceLink);
                    Result = RegQueryValueEx(
                        m_DeviceRegKey,
                        TEXT("InterfaceLink"),
                        0,
                        NULL,
                        (BYTE*)&InterfaceLink,
                        &ValueSize);
                    if ((Result == ERROR_SUCCESS) && (ValueSize == sizeof(InterfaceLink))) {
                        //
                        // This interface registry key is just a link to the
                        // base, so follow the link.
                        //
                        RegCloseKey(m_DeviceRegKey);
                        m_DeviceRegKey = NULL;

                        if (SetupDiGetDeviceInterfaceAlias(
                            DevInfo,
                            &DeviceData,
                            &InterfaceLink,
                            &DeviceData)) {
                            //
                            // Found the alias, so get open this key instead.
                            //
                            m_DeviceRegKey = SetupDiOpenDeviceInterfaceRegKey(
                                DevInfo,
                                &DeviceData,
                                NULL,
                                KEY_READ);
                            if (m_DeviceRegKey == INVALID_HANDLE_VALUE) {
                                m_DeviceRegKey = NULL;
                            }
                        }
                    }
                    m_InterfaceClassGuid = DeviceData.InterfaceClassGuid;
                }
            }
            if (!m_DeviceRegKey) {
                DWORD   LastError;

                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
            SetupDiDestroyDeviceInfoList(DevInfo);
            if (SUCCEEDED(hr)) {
                m_FilterHandle = CreateFile(
                    SymbolicLink,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                    NULL);
            }
        } else {
            DWORD   LastError;

            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);
        }
#ifndef _UNICODE
        //
        // This is only a separate string when not compiling Unicode.
        //
        delete [] SymbolicLink;
#endif
        //
        // Check for failure to open the device key.
        //
        if (FAILED(hr)) {
            return hr;
        }
        //
        // Then check for failure to open the device.
        //
        if (m_FilterHandle == INVALID_HANDLE_VALUE) {
            DWORD   LastError;

            m_FilterHandle = NULL;
            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);
        }  else {
            LONG    Result;
            PKSMULTIPLE_ITEM MultipleItem;

            //
            // Determine if the filter data for the cache needs to be
            // generated. This happens the first time the filter interface
            // is opened.
            //
            Result = RegQueryValueEx(
                m_DeviceRegKey,
                TEXT("FilterData"),
                0,
                NULL,
                NULL,
                &ValueSize);
            //
            // If no key is present, or it is empty, then build the cache.
            // This is done by using the kernel service handler device.
            //
            if ((Result != ERROR_SUCCESS) || !ValueSize) {
                HANDLE  ServiceHandle;

                hr = KsOpenDefaultDevice(
                    KSNAME_Server,
                    GENERIC_READ | GENERIC_WRITE,
                    &ServiceHandle);
                if (SUCCEEDED(hr)) {
                    KSPROPERTY  Property;
                    ULONG       BytesReturned;

                    //
                    // This property builds the cache for the specified
                    // symbolic link using the access privaleges of the
                    // current user.
                    //
                    Property.Set = KSPROPSETID_Service;
                    Property.Id = KSPROPERTY_SERVICE_BUILDCACHE;
                    Property.Flags = KSPROPERTY_TYPE_SET;
                    hr = ::KsSynchronousDeviceControl(
                        ServiceHandle,
                        IOCTL_KS_PROPERTY,
                        &Property,
                        sizeof(Property),
                        Variant.bstrVal,
                        SymbolicLinkSize * sizeof(WCHAR),
                        &BytesReturned);
                    CloseHandle(ServiceHandle);
                }
            }
            //
            // Load any extra interfaces on the proxy that have been specified in
            // this filter entry.
            //
            ::AggregateMarshalers(
                m_DeviceRegKey,
                TEXT("Interfaces"),
                &m_MarshalerList,
                static_cast<IKsObject*>(this));
            //
            // Load any extra interfaces on the proxy that represent topology
            // nodes.
            //
            if (SUCCEEDED(QueryTopologyItems(KSPROPERTY_TOPOLOGY_NODES, &MultipleItem))) {
                ::AggregateTopology(
                    m_DeviceRegKey,
                    MultipleItem,
                    &m_MarshalerList,
                    static_cast<IKsObject*>(this));
                delete [] reinterpret_cast<BYTE*>(MultipleItem);
            }

            //
            // Load any extra interfaces based on the Property/Method/Event sets
            // supported by this object.
            //
            ::AggregateSets(m_FilterHandle, m_DeviceRegKey, &m_MarshalerList, static_cast<IKsObject*>(this));
            //
            // Save the moniker if possible in order to persist the filter.
            //
            PropertyBag->QueryInterface(IID_IPersistStream, reinterpret_cast<PVOID*>(&m_PersistStreamDevice));
            //
            // Make the initial list of pins, one each. Do this after loading
            // set handlers on the filter.
            //
            hr = GeneratePinInstances();
        }
    }
    return hr;
}


STDMETHODIMP 
CKsProxy::Save(
    LPPROPERTYBAG PropBag,
    BOOL ClearDirty,
    BOOL SaveAllProperties
    )
/*++

Routine Description:

    Implement the IPersistPropertyBag::Save method. This is not implemented,
    and should not be called.

Arguments:

    PropertyBag -
        The property bag to save properties to.

    ClearDirty -
        Not used.

    SaveAllProperties -
        Not used.

Return Value:

    Returns E_NOTIMPL.

--*/
{
    //
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    //
    return E_NOTIMPL;
}


STDMETHODIMP
CKsProxy::InitNew(
    )
/*++

Routine Description:

    Implement the IPersistPropertyBag::InitNew method. Initializes the
    new instance, but actually does nothing.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsProxy::GetClassID(
    CLSID* ClassId
    )
/*++

Routine Description:

    Implement the IPersist::GetClassID method. Returns the class identifier
    originally given to the object on creation. This is used to determine
    the property bag to use.

Arguments:

    ClassId -
        The place in which to put the class identifier of this object.

Return Value:

    Returns S_OK.

--*/
{
    return CBaseFilter::GetClassID(ClassId);
}

#define CURRENT_PERSIST_VERSION 1


DWORD
CKsProxy::GetSoftwareVersion(
    )
/*++

Routine Description:

    Implement the CPersistStream::GetSoftwareVersion method. Returns
    the new version number rather than the default of zero.

Arguments:

    None.

Return Value:

    Return CURRENT_PERSIST_VERSION.

--*/
{
    return CURRENT_PERSIST_VERSION;
}


HRESULT
CKsProxy::WriteToStream(
    IStream* Stream
    )
/*++

Routine Description:

    Implement the CPersistStream::WriteToStream method. Writes a version
    tag followed by the persist information.

Arguments:

    Stream -
        The stream object to write to.

Return Value:

    Return S_OK if the write succeeded, else, some write error.

--*/
{
    HRESULT hr;

    //
    // This is initialized in the Load method.
    //
    if (m_PersistStreamDevice) {
        //
        // CPersistStream already has written out the version acquired
        // from the CPersistStream::GetSoftwareVersion method.
        //
        // Save the rest of the data, and clear the dirty bit.
        //
        hr = m_PersistStreamDevice->Save(Stream, TRUE);

        LARGE_INTEGER Offset;

        if (SUCCEEDED(hr)) {
            ULARGE_INTEGER InitialPosition;

            Offset.QuadPart = 0;
            //
            // Save the current position so that the initial length
            // parameter can be updated at the end.
            //
            hr = Stream->Seek(Offset, STREAM_SEEK_CUR, &InitialPosition);
            if (SUCCEEDED(hr)) {
                ULONG DataSize = 0;

                //
                // This is the amount of subsequent data, and will be
                // calculated based on how much actually gets written,
                // then updated at the end if greater than zero.
                //
                hr = Stream->Write(&DataSize, sizeof(DataSize), NULL);
                //
                // For each connected Bridge pin, write out the Pin Factory
                // Identifier, followed by the media type.
                //
                for (POSITION Position = m_PinList.GetHeadPosition(); SUCCEEDED(hr) && Position;) {
                    CBasePin* Pin = m_PinList.Get(Position);
                    Position = m_PinList.Next(Position);
                    HANDLE PinHandle = GetPinHandle(Pin);
                    if (PinHandle) {

                        ULONG PinFactoryId = GetPinFactoryId(Pin);

                        KSPIN_COMMUNICATION Communication;
                        
                        if (FAILED(GetPinFactoryCommunication(PinFactoryId, &Communication)) ||
                           !(Communication & KSPIN_COMMUNICATION_BRIDGE)) {
                            continue;
                        }
                        hr = Stream->Write(&PinFactoryId, sizeof(PinFactoryId), NULL);
                        if (SUCCEEDED(hr)) {
                            AM_MEDIA_TYPE AmMediaType;

                            Pin->ConnectionMediaType(&AmMediaType);
                            //
                            // Do not attempt to serialize an IUnknown.
                            //
                            if (AmMediaType.pUnk) {
                                AmMediaType.pUnk->Release();
                                AmMediaType.pUnk = NULL;
                            }
                            hr = Stream->Write(&AmMediaType, sizeof(AmMediaType), NULL);
                            if (SUCCEEDED(hr)) {
                                if (AmMediaType.cbFormat) {
                                    hr = Stream->Write(AmMediaType.pbFormat, AmMediaType.cbFormat, NULL);
                                }
                            }
                            FreeMediaType(AmMediaType);
                        }
                    }
                }
            }
            if (SUCCEEDED(hr)) {
                ULARGE_INTEGER FinalPosition;

                //
                // Retrieve the current stream position so that the total
                // size written can be calculated. Then update the original
                // length, which had been set to zero.
                //
                hr = Stream->Seek(Offset, STREAM_SEEK_CUR, &FinalPosition);
                if (SUCCEEDED(hr)) {
                    ULONG DataSize = (ULONG)(FinalPosition.QuadPart - InitialPosition.QuadPart);
                    //
                    // The size is exclusive, so remove the size of the
                    // first ULONG, which contains the size. If there was
                    // anything written, update the size, then seek back
                    // to the final position.
                    //
                    DataSize -= sizeof(DataSize);
                    if (FinalPosition.QuadPart) {
                        hr = Stream->Seek(*reinterpret_cast<PLARGE_INTEGER>(&InitialPosition), STREAM_SEEK_SET, &InitialPosition);
                        if (SUCCEEDED(hr)) {
                            hr = Stream->Write(&DataSize, sizeof(DataSize), NULL);
                            if (SUCCEEDED(hr)) {
                                hr = Stream->Seek(*reinterpret_cast<PLARGE_INTEGER>(&FinalPosition), STREAM_SEEK_SET, &FinalPosition);
                            }
                        }
                    }
                }
            }
        }
    } else {
        hr = E_UNEXPECTED;
    }
    return hr;
}


HRESULT
CKsProxy::ReadFromStream(
    IStream* Stream
    )
/*++

Routine Description:

    Implement the CPersistStream::ReadFromStream method. Initializes a
    property bag from the stream, and loads the device with it.

Arguments:

    Stream -
        The stream object to read from.

Return Value:

    Return S_OK if the device was initialized, else some read or device
    initialization error.

--*/
{
    HRESULT hr;
    IPersistStream* MonPersistStream;

    //
    // If there is a device handle, then IPersistPropertyBag::Load has already
    // been called, and therefore this instance already has been initialized
    // with some particular state.
    //
    if (m_FilterHandle) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }
    //
    // The first element in the serialized data is the version stamp.
    // This was read by CPersistStream, and put into mPS_dwFileVersion.
    // The rest of the data is the property bag passed to
    // IPersistPropertyBag::Load.
    //
    if (mPS_dwFileVersion > GetSoftwareVersion()) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
    //
    // Normally this device moniker is created and handed to the Load method,
    // but in this case it is done here so that the correct property bag can
    // be passed in.
    //
    hr = CoCreateInstance(
        CLSID_CDeviceMoniker,
        NULL,
#ifdef WIN9X_KS
        CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
        IID_IPersistStream,
        reinterpret_cast<PVOID*>(&MonPersistStream));
    if (SUCCEEDED(hr)) {
        //
        // Initialize this moniker with the stream so that the property bag
        // can be acquired.
        //
        hr = MonPersistStream->Load(Stream);
        if (SUCCEEDED(hr)) {
            IPropertyBag* PropBag;

            hr = MonPersistStream->QueryInterface(
                IID_IPropertyBag,
                reinterpret_cast<PVOID*>(&PropBag));
            //
            // Then call the Load method on this instance with the interface
            // to the property bag created by this moniker.
            //
            if (SUCCEEDED(hr)) {
                hr = Load(PropBag, NULL);
                PropBag->Release();
            }
        }
        MonPersistStream->Release();
        if (SUCCEEDED(hr)) {
            switch (mPS_dwFileVersion) {
            case 0:
                //
                // Nothing to do for the original version.
                //
                break;
            case CURRENT_PERSIST_VERSION:
                ULONG ReadLength;
                ULONG DataSize;

                //
                // Connect Bridge pins which were stored. The only
                // problem may be that a particular pin might not
                // actually exist until some other connection has
                // been made. And of course some data formats contain
                // data which is not valid across sessions.
                //
                hr = Stream->Read(&DataSize, sizeof(DataSize), &ReadLength);
                if (SUCCEEDED(hr)) {
                    if (ReadLength != sizeof(DataSize)) {
                        hr = VFW_E_FILE_TOO_SHORT;
                        break;
                    }
                    for (; DataSize;) {
                        ULONG PinFactoryId;

                        hr = Stream->Read(&PinFactoryId, sizeof(PinFactoryId), &ReadLength);
                        if (FAILED(hr)) {
                            break;
                        }
                        DataSize -= ReadLength;

                        AM_MEDIA_TYPE AmMediaType;
                        hr = Stream->Read(&AmMediaType, sizeof(AmMediaType), &ReadLength);
                        if (FAILED(hr)) {
                            break;
                        }
                        DataSize -= ReadLength;
                        AmMediaType.pbFormat = reinterpret_cast<PBYTE>(CoTaskMemAlloc(AmMediaType.cbFormat));
                        if (!AmMediaType.pbFormat) {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        hr = Stream->Read(AmMediaType.pbFormat, AmMediaType.cbFormat, &ReadLength);
                        if (FAILED(hr)) {
                            FreeMediaType(AmMediaType);
                            break;
                        }
                        DataSize -= ReadLength;
                        //
                        // Find the Pin Factory to connect. If it is not
                        // found, then it just gets skipped.
                        //
                        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
                            CBasePin* Pin = m_PinList.Get(Position);
                            Position = m_PinList.Next(Position);
                            if (!GetPinHandle(Pin) && (PinFactoryId == GetPinFactoryId(Pin))) {
                                hr = Pin->Connect(NULL, &AmMediaType);
                                break;
                            }
                        }
                        FreeMediaType(AmMediaType);
                        if (FAILED(hr)) {
                            break;
                        }
                    }
                }
                break;
            }
        }
    }
    return hr;
}


int
CKsProxy::SizeMax(
    )
/*++

Routine Description:

    Implement the CPersistStream::SizeMax method. Returns the maximum size
    that the persist information will be. This is the maximum size of the
    stream containing the property bag information, plus the proxy's version
    stamp.

    This can only be called if the device has been initialized through a Load.

Arguments:

    None.
    
Return Value:
    
    Returns S_OK, else any error from the underlying call to the persist
    object.

--*/
{
    //
    // This is initialized in the Load method.
    //
    if (m_PersistStreamDevice) {
        //
        // Calculate any extra data for Bridge pin connections. This
        // includes the initial data size parameter.
        //
        ULONG DataSize = sizeof(DataSize);

        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin* Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            HANDLE PinHandle = GetPinHandle(Pin);
            if (PinHandle) {

                ULONG PinFactoryId = GetPinFactoryId(Pin);

                KSPIN_COMMUNICATION Communication;
                        
                if (FAILED(GetPinFactoryCommunication(PinFactoryId, &Communication)) ||
                    !(Communication & KSPIN_COMMUNICATION_BRIDGE)) {
                    continue;
                }
                //
                // Add in the size needed to store the Pin Factory Id for this
                // pin connection.
                //
                DataSize += sizeof(PinFactoryId);

                AM_MEDIA_TYPE AmMediaType;

                Pin->ConnectionMediaType(&AmMediaType);
                //
                // Add in the size for the particular format, plus any format-
                // specific data.
                //
                DataSize += sizeof(AmMediaType) + AmMediaType.cbFormat;
                FreeMediaType(AmMediaType);
            }
        }

        ULARGE_INTEGER  MaxLength;

        //
        // The size of the version stamp is already taken into account by
        // the CPersistStream code, so the size of the property bag just
        // needs to be added.
        //
        if (SUCCEEDED(m_PersistStreamDevice->GetSizeMax(&MaxLength))) {
            return (int)MaxLength.QuadPart + DataSize;
        }
    }
    return 0;
}


STDMETHODIMP
CKsProxy::QueryMediaSeekingFormats(
    PKSMULTIPLE_ITEM* MultipleItem
    )
/*++

Routine Description:

    Queries the underlying device for the list of seeking formats using
    KSPROPERTY_MEDIASEEKING_FORMATS.

Arguments:

    MultipleItem -
        The place in which to put the list of seeking formats.

Return Value:

    Returns S_OK.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;

    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_FORMATS;
    Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // Query for the size of the list, if the property is even supported.
    //
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        NULL,
        0,
        &BytesReturned);
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the list, returning any
        // unexpected memory error.
        //
        *MultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(new BYTE[BytesReturned]);
        if (!*MultipleItem) {
            return E_OUTOFMEMORY;
        }
        hr = ::KsSynchronousDeviceControl(
            m_FilterHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            *MultipleItem,
            BytesReturned,
            &BytesReturned);
        //
        // Any unexpected error retrieving the list is returned.
        //
        if (FAILED(hr)) {
            delete [] reinterpret_cast<BYTE*>(*MultipleItem);
        }
    }
    return hr;
}


STDMETHODIMP_(VOID)
CKsProxy::TerminateEndOfStreamNotification(
    HANDLE PinHandle
    )
/*++

Routine Description:

    Notifies the Wait Thread to search the list of EOS handles and to
    disable all events for this handle if found and remove this item.
    It is assumed that the pin handle is being closed anyway, so all
    events can be terminated. Terminates the Wait Thread if no more
    EOS handles are present.

Arguments:

    PinHandle -
        The handle of a pin which may have previously initiated EOS
        notification on a pin.

Return Value:

    Nothing.

--*/
{
    CAutoLock   AutoLock(m_pLock);

    if (m_WaitThreadHandle) {
        m_WaitMessage.Message = DISABLE_EOS;
        m_WaitMessage.Param = reinterpret_cast<PVOID>(PinHandle);
        SetEvent(m_WaitEvents[0]);
        WaitForSingleObjectEx(m_WaitReplyHandle, INFINITE, FALSE);
        //
        // Check if the waiter thread should just be shut down.
        //
        if (m_ActiveWaitEventCount == 1) {
            m_WaitMessage.Message = STOP_EOS;
            SetEvent(m_WaitEvents[0]);
            //
            // Wait for the thread to shutdown, then close the handle.
            //
            WaitForSingleObjectEx(m_WaitThreadHandle, INFINITE, FALSE);
            CloseHandle(m_WaitThreadHandle);
            m_WaitThreadHandle = NULL;
        }
    }
}


STDMETHODIMP
CKsProxy::InitiateEndOfStreamNotification(
    HANDLE PinHandle
    )
/*++

Routine Description:

    Determines if an EOS event exists on this pin, and if so, notifies
    the Wait Thread to enable it. Creates the Wait Thread if needed.

Arguments:

    PinHandle -
        The handle of a pin which may have EOS notification on it.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    KSEVENT     Event;
    ULONG       BytesReturned;
    HRESULT     hr;

    // Don't do anything if we've already setup EOS notification for
    // this pin.
    for ( ULONG pin = 1; pin < m_ActiveWaitEventCount; pin++ ) {
        if (m_WaitPins[pin] == PinHandle) {
            return S_OK;
            }
        }

    //
    // Only if the EOS event is supported should notification be set up.
    //
    Event.Set = KSEVENTSETID_Connection;
    Event.Id = KSEVENT_CONNECTION_ENDOFSTREAM;
    Event.Flags = KSEVENT_TYPE_BASICSUPPORT;
    hr = ::KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_ENABLE_EVENT,
        &Event,
        sizeof(Event),
        NULL,
        0,
        &BytesReturned);
    if (SUCCEEDED(hr)) {
        CAutoLock   AutoLock(m_pLock);

        if (!m_WaitThreadHandle) {
            DWORD   WaitThreadId;

            m_WaitThreadHandle = CreateThread( 
                NULL,
                0,
                reinterpret_cast<LPTHREAD_START_ROUTINE>(WaitThread),
                reinterpret_cast<LPVOID>(this),
                0,
                &WaitThreadId);
            if (!m_WaitThreadHandle) {
                DWORD   LastError;

                LastError = GetLastError();
                return HRESULT_FROM_WIN32(LastError);
            }
        }
        //
        // The return of this message is any error condition.
        //
        m_WaitMessage.Message = ENABLE_EOS;
        m_WaitMessage.Param = reinterpret_cast<PVOID>(PinHandle);
        SetEvent(m_WaitEvents[0]);
        WaitForSingleObjectEx(m_WaitReplyHandle, INFINITE, FALSE);
        hr = PtrToLong(m_WaitMessage.Param);
        if (FAILED(hr)) {
            //
            // Check if the waiter thread should just be shut down.
            //
            if (m_ActiveWaitEventCount == 1) {
                m_WaitMessage.Message = STOP_EOS;
                SetEvent(m_WaitEvents[0]);
                //
                // Wait for the thread to shutdown, then close the handle.
                //
                WaitForSingleObjectEx(m_WaitThreadHandle, INFINITE, FALSE);
                CloseHandle(m_WaitThreadHandle);
                m_WaitThreadHandle = NULL;
            }
        }
    } else {
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP_(ULONG)
CKsProxy::DetermineNecessaryInstances(
    ULONG PinFactoryId
    )
/*++

Routine Description:

    Determines how many additional instances are necessary of the
    specified pin factory. This is determined by both the support
    of the Necessary Instances property, and by how many current
    connected instances of the pin factory currently exist.

Arguments:

    PinFactoryId -
        The pin factory identifier to return additional necessary
        instances of.

Return Value:

    Returns the number of additional necessary instances needed for
    the specified pin factory.

--*/
{
    KSP_PIN     Pin;
    ULONG       NecessaryInstances;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_NECESSARYINSTANCES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    //
    // By default one instance is needed.
    //
    // This DeviceControl call was malformed. Therefore, we were always 
    // using the default value 1. That was compounded with the mishandling 
    // of the loop following to exhibit a funny result, that with Mstee, one could
    // auto render the 1st pin, but not the 2nd. But once 2nd pin was manually
    // connected, the 3rd and so on could auto render again. 
    // Now these are fixed. When we have 0 necessaryinstance,
    // we actually cause regression that they won't get automatically rendered.
    // We will use default 1 when there is 0 necessaryinstnace to be backward compatible
    // For anything other than 0, 1 or unsuccessful call, we use the real value.
    //
    NecessaryInstances = 1;
    ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        &NecessaryInstances,
        sizeof(NecessaryInstances),
        &BytesReturned);

	if ( 0 == NecessaryInstances ) {
		//
		// sucessful return of 0, use 1.
		// aftrer this patch, we have 1 for returned 0, 1 or unsucessful
		//
		NecessaryInstances = 1;
	}
	
    //
    // Count the currently connected instances of this pin factory,
    // subtracting from the necessary instances.
    //
    for (POSITION Position = m_PinList.GetHeadPosition(); 
         Position && NecessaryInstances;
         NULL ) {

        CBasePin*   Pin;

        //
        // Enumerate each pin, figuring if it is of the same pin
        // factory, and if it is currently connected.
        //
        Pin = m_PinList.Get(Position);
        Position = m_PinList.Next(Position);
        if ((GetPinFactoryId(Pin) == PinFactoryId) && Pin->IsConnected()) {
            ASSERT(NecessaryInstances);
            NecessaryInstances--;
        }
    }
    return NecessaryInstances;
}


STDMETHODIMP
CKsProxy::Set(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Set method. This sets a property on the
    underlying kernel filter.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the data to pass to the property.

    DataLength -
        Contains the length of the data passed.

Return Value:

    Returns NOERROR if the property was set.

--*/
{
    ULONG   BytesReturned;

    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_SET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            &BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_SET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            &BytesReturned);
    }
}


STDMETHODIMP
CKsProxy::Get(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength,
    ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Get method. This gets a property on the
    underlying kernel filter.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the place in which to return the data for the property.

    DataLength -
        Contains the length of the data buffer passed.

    BytesReturned -
        The place in which to put the number of bytes actually returned.

Return Value:

    Returns NOERROR if the property was retrieved.

--*/
{
    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_GET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_GET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            BytesReturned);
    }
}


STDMETHODIMP
CKsProxy::QuerySupported(
    REFGUID PropSet,
    ULONG Id,
    ULONG* TypeSupport
    )
/*++

Routine Description:

    Implement the IKsPropertySet::QuerySupported method. Return the type of
    support is provided for this property.

Arguments:

    PropSet -
        The GUID of the set to query.

    Id -
        The property identifier within the set.

    TypeSupport
        Optionally the place in which to put the type of support. If NULL, the
        query returns whether or not the property set as a whole is supported.
        In this case the Id parameter is not used and must be zero.

Return Value:

    Returns NOERROR if the property support was retrieved.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = PropSet;
    Property.Id = Id;
    Property.Flags = TypeSupport ? KSPROPERTY_TYPE_BASICSUPPORT : KSPROPERTY_TYPE_SETSUPPORT;
    return KsProperty(
        &Property,
        sizeof(Property),
        TypeSupport,
        TypeSupport ? sizeof(*TypeSupport) : 0,
        &BytesReturned);
}


STDMETHODIMP
CKsProxy::ClockPropertyIo(
    ULONG PropertyId,
    ULONG Flags,
    ULONG BufferSize,
    PVOID Buffer
    )
/*++

Routine Description:

    Implement the ClockPropertyIo method. Calls the specified property in
    the KSPROPSETID_Clock property set in order to set/get a property. This
    is used by the IKsClockPropertySet interface methods to manipulate the
    underlying property set. This checks for an optionally creates the clock
    object.

Arguments:

    PropertyId -
        The property within the KSPROPSETID_Clock property set to access.

    Flags -
        Contains the Get or Set flag.

    BufferSize -
        The size of the buffer following.

    Buffer -
        The buffer containing the data for a Set operation, or the place
        in which to put data for a Get operation.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    HRESULT     hr;
    CAutoLock   AutoLock(m_pLock);

    if (m_PinClockHandle || SUCCEEDED(hr = CreateClockHandle())) {
        KSPROPERTY  Property;
        ULONG       BytesReturned;

        Property.Set = KSPROPSETID_Clock;
        Property.Id = PropertyId;
        Property.Flags = Flags;
        hr = ::KsSynchronousDeviceControl(
            m_PinClockHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            Buffer,
            BufferSize,
            &BytesReturned);
    }
    return hr;
}


STDMETHODIMP
CKsProxy::KsGetTime(
    LONGLONG* Time
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsGetTime method. Retrieves the time from
    the underlying clock.

Arguments:

    Time -
        The place in which to put the current clock time.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_TIME, KSPROPERTY_TYPE_GET, sizeof(*Time), Time);
}


STDMETHODIMP
CKsProxy::KsSetTime(
    LONGLONG Time
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsSetTime method. Sets the current time
    on the underlying clock.

Arguments:

    Time -
        Contains the time to set on the clock.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_TIME, KSPROPERTY_TYPE_SET, sizeof(Time), &Time);
}


STDMETHODIMP
CKsProxy::KsGetPhysicalTime(
    LONGLONG* Time
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsGetPhysicalTime method. Retrieves
    the physical time from the underlying clock.

Arguments:

    Time -
        The place in which to put the current physical time.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_PHYSICALTIME, KSPROPERTY_TYPE_GET, sizeof(*Time), Time);
}


STDMETHODIMP
CKsProxy::KsSetPhysicalTime(
    LONGLONG Time
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsSetPhysicalTime method. Sets the
    current physical time on the underlying clock.

Arguments:

    Time -
        Contains the physical time to set on the clock.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_PHYSICALTIME, KSPROPERTY_TYPE_SET, sizeof(Time), &Time);
}


STDMETHODIMP
CKsProxy::KsGetCorrelatedTime(
    KSCORRELATED_TIME* CorrelatedTime
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsGetCorrelatedTime method. Retrieves
    the correlated time from the underlying clock.

Arguments:

    CorrelatedTime -
        The place in which to put the current correlated time.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_CORRELATEDTIME, KSPROPERTY_TYPE_GET, sizeof(*CorrelatedTime), CorrelatedTime);
}


STDMETHODIMP
CKsProxy::KsSetCorrelatedTime(
    KSCORRELATED_TIME* CorrelatedTime
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsSetCorrelatedTime method. Sets the
    current correlated time on the underlying clock.

Arguments:

    CorrelatedTime -
        Contains the correlated time to set on the clock.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_CORRELATEDTIME, KSPROPERTY_TYPE_SET, sizeof(CorrelatedTime), &CorrelatedTime);
}


STDMETHODIMP
CKsProxy::KsGetCorrelatedPhysicalTime(
    KSCORRELATED_TIME* CorrelatedTime
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsGetCorrelatedPhysicalTime method.
    Retrieves the correlated physical time from the underlying clock.

Arguments:

    CorrelatedTime -
        The place in which to put the current physical correlated time.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME, KSPROPERTY_TYPE_GET, sizeof(*CorrelatedTime), CorrelatedTime);
}


STDMETHODIMP
CKsProxy::KsSetCorrelatedPhysicalTime(
    KSCORRELATED_TIME* CorrelatedTime
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsSetCorrelatedPhysicalTime method.
    Sets the current correlated physical time on the underlying clock.

Arguments:

    CorrelatedTime -
        Contains the correlated physical time to set on the clock.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME, KSPROPERTY_TYPE_SET, sizeof(CorrelatedTime), &CorrelatedTime);
}


STDMETHODIMP
CKsProxy::KsGetResolution(
    KSRESOLUTION* Resolution
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsGetResolution method. Retrieves the
    clock resolution from the underlying clock.

Arguments:

    Resolution -
        The place in which to put the resolution.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_RESOLUTION, KSPROPERTY_TYPE_GET, sizeof(*Resolution), Resolution);
}


STDMETHODIMP
CKsProxy::KsGetState(
    KSSTATE* State
    )
/*++

Routine Description:

    Implement the IKsClockPropertySet::KsGetState method. Retrieves the
    clock state from the underlying clock.

Arguments:

    State -
        The place in which to put the state.

Return Value:

    Returns NOERROR if the property was accessed successfully.

--*/
{
    return ClockPropertyIo(KSPROPERTY_CLOCK_STATE, KSPROPERTY_TYPE_GET, sizeof(*State), State);
}


STDMETHODIMP_(ULONG)
CKsProxy::GetMiscFlags(
    )
/*++

Routine Description:

    Implement the IAMFilterMiscFlags::GetMiscFlags method. Retrieves the
    miscelaneous flags. This consists of whether or not the filter moves
    data out of the graph system through a Bridge or None pin.

Arguments:

    None.

Return Value:

    Returns
        AM_FILTER_MISC_FLAGS_IS_RENDERER if the filter renders any stream 
        AM_FILTER_MISC_FLAGS_IS_SOURCE   if the filter sources live data

--*/
{
    ULONG   Flags = 0;
    
    //
    // Search for a bridge or None input pin before calling ourself a source
    //
    for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
        CBasePin* Pin = m_PinList.Get(Position);
        Position = m_PinList.Next(Position);
        
        PIN_DIRECTION PinDirection;
        
        Pin->QueryDirection(&PinDirection);
        
        // skip over output pins
        if( PINDIR_OUTPUT == PinDirection )
            continue;
            
        ULONG PinFactoryId = GetPinFactoryId(Pin);
    
        KSPIN_COMMUNICATION Communication;
        if (SUCCEEDED(GetPinFactoryCommunication(PinFactoryId, &Communication)) &&
           ((Communication & KSPIN_COMMUNICATION_BRIDGE) || 
            (Communication == KSPIN_COMMUNICATION_NONE))){
             
            Flags |= AM_FILTER_MISC_FLAGS_IS_SOURCE ;
            break;
        }
    }
    
    if( m_ActiveWaitEventCount > 1 )
    {    
        Flags |= AM_FILTER_MISC_FLAGS_IS_RENDERER ;
    }
    
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s::GetMiscFlags = %s %s"),
        m_pName, 
        ( AM_FILTER_MISC_FLAGS_IS_SOURCE   & Flags ) ? TEXT("Source") : TEXT("0"),
        ( AM_FILTER_MISC_FLAGS_IS_RENDERER & Flags ) ? TEXT("Renderer") : TEXT("0") ));

    return Flags;
}


STDMETHODIMP
CKsProxy::KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsProperty method. This is used to query and
    manipulate property sets on an object. It can perform a Get, Set, and
    various Support queries.

Arguments:

    Property -
        Contains the property set identification for the query.

    PropertyLength -
        Contains the length of the Property parameter. Normally this is
        the size of the KSPROPERTY structure.

    PropertyData -
        Contains either the data to apply to a property on a Set, the
        place in which to return the current property data on a Get, or the
        place in which to return property set information on a Support
        query.

    DataLength -
        Contains the size of the PropertyData buffer.

    BytesReturned -
        On a Get or Support query, returns the number of bytes actually
        used in the PropertyData buffer. This is not used on a Set, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        Property,
        PropertyLength,
        PropertyData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsProxy::KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsMethod method. This is used to query and
    manipulate method sets on an object. It can perform an Execute and
    various Support queries.

Arguments:

    Method -
        Contains the method set identification for the query.

    MethodLength -
        Contains the length of the Method parameter. Normally this is
        the size of the KSMETHOD structure.

    MethodData -
        Contains either the IN and OUT parameters to the method, or the
        place in which to return method set information on a Support
        query.

    DataLength -
        Contains the size of the MethodData buffer.

    BytesReturned -
        Returns the number of bytes actually used in the MethodData buffer.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_METHOD,
        Method,
        MethodLength,
        MethodData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsProxy::KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsEvent method. This is used to set and
    query events sets on an object. It can perform an Enable, Disable and
    various Support queries.

Arguments:

    Event -
        Contains the event set identification for the enable, disable, or
        query. To disable an event, this parameter must be set to NULL, and
        EventLength set to zero. The EventData must be passed the original
        KSEVENTDATA pointer.

    EventLength -
        Contains the length of the Event parameter. Normally this is
        the size of the KSEVENT structure for an Enable. This would be set
        to zero for a Disable.

    EventData -
        Contains either the KSEVENTDATA to apply to a event on an Enable,
        or the place in which to return event set information on a Support
        query.

    DataLength -
        Contains the size of the EventData buffer. For an Enable or Disable
        this would normally be the size of a KSEVENTDATA, structure plus
        event specific data.

    BytesReturned -
        On a Support query, returns the number of bytes actually used in
        the EventData buffer. This is not used on an Enable or Disable, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.
    //
    if (EventLength) {
        return ::KsSynchronousDeviceControl(
            m_FilterHandle,
            IOCTL_KS_ENABLE_EVENT,
            Event,
            EventLength,
            EventData,
            DataLength,
            BytesReturned);
    }
    //
    // Otherwise this must be a Disable.
    //
    return ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_DISABLE_EVENT,
        EventData,
        DataLength,
        NULL,
        0,
        BytesReturned);
}


STDMETHODIMP
CKsProxy::KsAddAggregate(
    IN REFGUID AggregateClass
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsAddAggregate method. This is used to
    load a COM server with zero or more interfaces to aggregate on the object.

Arguments:

    AggregateClass -
        Contains the Aggregate reference to translate into a COM server which
        is to be aggregated on the object.

Return Value:

    Returns S_OK if the Aggregate was added.

--*/
{
    return ::AddAggregate(&m_MarshalerList, static_cast<IKsObject*>(this), AggregateClass);
}


STDMETHODIMP
CKsProxy::KsRemoveAggregate(
    IN REFGUID AggregateClass
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsRemoveAggregate method. This is used to
    unload a previously loaded COM server which is aggregating interfaces.

Arguments:

    AggregateClass -
        Contains the Aggregate reference to look up and unload.

Return Value:

    Returns S_OK if the Aggregate was removed.

--*/
{
    return ::RemoveAggregate(&m_MarshalerList, AggregateClass);
}

#ifdef DEVICE_REMOVAL

STDMETHODIMP
CKsProxy::DeviceInfo( 
    CLSID* InterfaceClass,
    WCHAR** SymbolicLink OPTIONAL
    )
/*++

Routine Description:

    Implement the IAMDeviceRemoval::DeviceInfo method. This is used to
    query the PnP interface class and the symbolic link used to open the
    device so that the graph control code can register for PnP
    notifications, and respond to device removal and insertion.

Arguments:

    InterfaceClass -
        The place in which to return the PnP interface class.

    SymbolicLink -
        Optionally the place in which to return a pointer to the symbolic
        link. This is allocated with CoTaskMemAlloc, and must be freed by
        the caller with CoTaskMemFree.

Return Value:

    Returns NOERROR if the items were returned, else a memory error, or
    other error if the proxy instance has not been initialized with the
    information yet.

--*/
{
    HRESULT hr;

    //
    // In case the filter was never initialized, ensure there is a symbolic
    // link present.
    //
    if (m_SymbolicLink) {
        *InterfaceClass = m_InterfaceClassGuid;
        hr = S_OK;
        if (SymbolicLink) {
            *SymbolicLink = reinterpret_cast<WCHAR*>(CoTaskMemAlloc(wcslen(m_SymbolicLink) * sizeof(WCHAR) + sizeof(UNICODE_NULL)));
            if (*SymbolicLink) {
                wcscpy(*SymbolicLink, m_SymbolicLink);
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    return hr;
}


STDMETHODIMP
CKsProxy::Reassociate(
    )
/*++

Routine Description:

    Implement the IAMDeviceRemoval::Reassociate method. This is used to
    reassociate the proxy with an underlying device, and is used when the
    graph control code has determined that an underlying device has
    returned after having been removed.

Arguments:

    None.

Return Value:

    Returns NOERROR if the underlying device was reopened, else a CreateFile
    error. If the proxy was never associated with a device, or is currently
    associated with a device, then an error is returned.

--*/
{
    HRESULT hr = NOERROR;

    //
    // In case the filter was never initialized, ensure there is a symbolic
    // link present. Also ensure that the filter is not already associated
    // with a device.
    //
    if (m_SymbolicLink && !m_FilterHandle) {
#ifndef _UNICODE
        //
        // If not compiling for Unicode, then object names are Ansi, but
        // the pin names are still Unicode, so a MultiByte string needs to
        // be constructed.
        //

        ULONG SymbolicLinkSize = wcslen(m_SymbolicLink) + 1;
        //
        // Hoping for a one to one replacement of characters.
        //
        char* SymbolicLink = new char[SymbolicLinkSize];
        if (!SymbolicLink) {
            return E_OUTOFMEMORY;
        }
        BOOL DefaultUsed;

        WideCharToMultiByte(0, 0, m_SymbolicLink, -1, SymbolicLink, SymbolicLinkSize, NULL, &DefaultUsed);
#endif
        m_FilterHandle = CreateFile(
#ifdef _UNICODE
            m_SymbolicLink,
#else
            SymbolicLink,
#endif
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL);
#ifndef _UNICODE
        delete [] SymbolicLink;
#endif
        if (m_FilterHandle == INVALID_HANDLE_VALUE) {
            DWORD LastError;

            m_FilterHandle = NULL;
            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    return hr;
}


STDMETHODIMP
CKsProxy::Disassociate(
    )
/*++

Routine Description:

    Implement the IAMDeviceRemoval::Disassociate method. This is used to
    disassociate the proxy from an underlying device by closing the handle,
    and is used when the graph control code has determined that an
    underlying device has been removed.

Arguments:

    None.

Return Value:

    Returns NOERROR if the proxy is currently associated with a device, in
    which case the handle is closed.

--*/
{
    HRESULT hr;

    //
    // In case the filter was never initialized, make sure the handle is
    // present.
    //
    if (m_FilterHandle){
        CloseHandle(m_FilterHandle);
        //
        // Set this to NULL in case the filter is closed before it is
        // associated with a device again.
        //
        m_FilterHandle = NULL;
        hr = NOERROR;
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }
    return hr;
}
#endif // DEVICE_REMOVAL


STDMETHODIMP
CKsProxy::CreateNodeInstance(
    IN ULONG NodeId,
    IN ULONG Flags,
    IN ACCESS_MASK DesiredAccess,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFGUID InterfaceId,
    OUT LPVOID* Interface
    )
/*++

Routine Description:

    Implement the IKsTopology::CreateNodeInstance method. This is used to
    open a topology node instance and return an interface to that object in
    order to manipulate properties, methods, and events.

Arguments:

    NodeId -
        The identifier for this topology node. This is retrieved from querying
        the filter for the list of topology nodes through KSPROPERTY_TOPOLOGY_NODES
        in the KSPROPSETID_Topology property set.

    Flags -
        Reserved and set to zero.

    DesiredAccess -
        Contains the desired access to the node. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    UnkOuter -
        Optionally contains a parent object to use in creating the returned
        COM object.

    InterfaceId -
        Specifies the interface to return on the object. If the interface is
        not supported, no object is created.

    Interface -
        The place in which to put the interface returned on the object. This
        contains NULL if the call fails.

Return Value:

    Returns any creation error.

--*/
{
    HRESULT         hr;
    CUnknown*       NewObject;
    KSNODE_CREATE   NodeCreate;

    //
    // Always return NULL on failure.
    //
    *Interface = NULL;
    //
    // Follow COM rules with regard to outer IUnknown ownership.
    //
    if (UnkOuter && (InterfaceId != __uuidof(IUnknown))) {
        return E_NOINTERFACE;
    }
    NodeCreate.CreateFlags = Flags;
    NodeCreate.Node = NodeId;
    //
    // Initialize this so that any subsequent error which happens
    // during the CreateInstance, but before the object is actually
    // created can be recognized.
    //
    hr = NOERROR;
    NewObject = CKsNode::CreateInstance(&NodeCreate, DesiredAccess, m_FilterHandle, UnkOuter, &hr);
    //
    // The object was created, but initialization may have failed.
    //
    if (NewObject) {
        if (SUCCEEDED(hr)) {
            //
            // Ensure there is always a refcount on the object
            // before the query in case querying adds and releases
            // a refcount, and destroys the object. The release will
            // destroy the object if the query fails.
            //
            NewObject->NonDelegatingAddRef();
            hr = NewObject->NonDelegatingQueryInterface(InterfaceId, Interface);
            NewObject->NonDelegatingRelease();
        } else {
            //
            // Destroy the object created.
            //
            delete NewObject;
        }
    } else {
        //
        // The object was not allocated, but the function may have
        // returned an error. Set one if one was not set.
        //
        if (SUCCEEDED(hr)) {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


CUnknown*
CALLBACK
CKsNode::CreateInstance(
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE ParentHandle,
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by the CreateNodeInstance method on the filter in order to
    create an instance of a topology node object.

Arguments:

    NodeCreate -
        The creation structure for the node, including the identifier for this
        topology node and the flags.

    DesiredAccess -
        Contains the desired access to the node. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    ParentHandle -
        The handle of the parent of the node.

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{   
    CUnknown*   Unknown;

    Unknown = new CKsNode(NodeCreate, DesiredAccess, ParentHandle, UnkOuter, hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


CKsNode::CKsNode(
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE ParentHandle,
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    ) :
    CUnknown(NAME("KsNode"), UnkOuter),
    m_NodeHandle(NULL)
/*++

Routine Description:

    The contructor for topology node objects. Does base class initialization.
    
Arguments:

    NodeCreate -
        The creation structure for the node, including the identifier for this
        topology node and the flags.

    DesiredAccess -
        Contains the desired access to the node. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    ParentHandle -
        The handle of the parent of the node.

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    DWORD   Error;

    Error = KsCreateTopologyNode(
        ParentHandle,
        NodeCreate,
        DesiredAccess,
        &m_NodeHandle);
    *hr = HRESULT_FROM_WIN32(Error);
    if (FAILED(*hr)) {
        m_NodeHandle = NULL;
    }
}


CKsNode::~CKsNode(
    )
/*++

Routine Description:

    The destructor for the proxy node instance. This protects the COM Release
    function from accidentally calling delete again on the object by incrementing
    the reference count. After that, all outstanding resources are cleaned up.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // Protect against a spurious delete because of aggregation. No need to
    // use an interlocking increment, as the object is being destroyed.
    //
    m_cRef++;
    //
    // Close the node handle if it was opened.
    //
    if (m_NodeHandle) {
        CloseHandle(m_NodeHandle);
        m_NodeHandle = NULL;
    }
    //
    // Avoid an ASSERT() in the base object destructor
    //
    m_cRef = 0;
}


STDMETHODIMP
CKsNode::NonDelegatingQueryInterface(
    IN REFIID riid,
    OUT PVOID* ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object, or by the underlying
    CUnknown class object.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
    if (riid == __uuidof(IKsControl)) {
        return GetInterface(static_cast<IKsControl*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


STDMETHODIMP
CKsNode::KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsProperty method. This is used to query and
    manipulate property sets on an object. It can perform a Get, Set, and
    various Support queries.

Arguments:

    Property -
        Contains the property set identification for the query.

    PropertyLength -
        Contains the length of the Property parameter. Normally this is
        the size of the KSPROPERTY structure.

    PropertyData -
        Contains either the data to apply to a property on a Set, the
        place in which to return the current property data on a Get, or the
        place in which to return property set information on a Support
        query.

    DataLength -
        Contains the size of the PropertyData buffer.

    BytesReturned -
        On a Get or Support query, returns the number of bytes actually
        used in the PropertyData buffer. This is not used on a Set, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_NodeHandle,
        IOCTL_KS_PROPERTY,
        Property,
        PropertyLength,
        PropertyData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsNode::KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsMethod method. This is used to query and
    manipulate method sets on an object. It can perform an Execute and
    various Support queries.

Arguments:

    Method -
        Contains the method set identification for the query.

    MethodLength -
        Contains the length of the Method parameter. Normally this is
        the size of the KSMETHOD structure.

    MethodData -
        Contains either the IN and OUT parameters to the method, or the
        place in which to return method set information on a Support
        query.

    DataLength -
        Contains the size of the MethodData buffer.

    BytesReturned -
        Returns the number of bytes actually used in the MethodData buffer.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_NodeHandle,
        IOCTL_KS_METHOD,
        Method,
        MethodLength,
        MethodData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsNode::KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsEvent method. This is used to set and
    query events sets on an object. It can perform an Enable, Disable and
    various Support queries.

Arguments:

    Event -
        Contains the event set identification for the enable, disable, or
        query. To disable an event, this parameter must be set to NULL, and
        EventLength set to zero. The EventData must be passed the original
        KSEVENTDATA pointer.

    EventLength -
        Contains the length of the Event parameter. Normally this is
        the size of the KSEVENT structure for an Enable. This would be set
        to zero for a Disable.

    EventData -
        Contains either the KSEVENTDATA to apply to a event on an Enable,
        or the place in which to return event set information on a Support
        query.

    DataLength -
        Contains the size of the EventData buffer. For an Enable or Disable
        this would normally be the size of a KSEVENTDATA, structure plus
        event specific data.

    BytesReturned -
        On a Support query, returns the number of bytes actually used in
        the EventData buffer. This is not used on an Enable or Disable, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.
    //
    if (EventLength) {
        return ::KsSynchronousDeviceControl(
            m_NodeHandle,
            IOCTL_KS_ENABLE_EVENT,
            Event,
            EventLength,
            EventData,
            DataLength,
            BytesReturned);
    }
    //
    // Otherwise this must be a Disable.
    //
    return ::KsSynchronousDeviceControl(
        m_NodeHandle,
        IOCTL_KS_DISABLE_EVENT,
        EventData,
        DataLength,
        NULL,
        0,
        BytesReturned);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksqmf\ksqmf.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksqmf.cpp

Abstract:

    Provides an object interface to query, and a method to forward KS quality management.

--*/

#include <windows.h>
#include <limits.h>
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksqmf.h"

EXTERN_C
DECLSPEC_IMPORT
ULONG
NTAPI
RtlNtStatusToDosError(
    IN ULONG Status
    );

#define WAIT_OBJECT_QUALITY 0
#define WAIT_OBJECT_ERROR   1
#define WAIT_OBJECT_FLUSH   2
#define WAIT_OBJECT_EXIT    3
#define TOTAL_WAIT_OBJECTS  4

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
struct DECLSPEC_UUID("E05592E4-C0B5-11D0-A439-00A0C9223196") CLSID_KsQualityF;

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] =
{
    {L"KS Quality Forwarder", &__uuidof(CLSID_KsQualityF), CKsQualityF::CreateInstance, NULL, NULL},
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CKsQualityF::CreateInstance(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a Quality
    Forwarder. It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown* Unknown;

    Unknown = new CKsQualityF(UnkOuter, NAME("KsQualityF Class"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


CKsQualityF::CKsQualityF(
    LPUNKNOWN UnkOuter,
    TCHAR* Name,
    HRESULT* hr
    ) :
    CUnknown(Name, UnkOuter),
    m_QualityManager(NULL),
    m_Thread(NULL),
    m_TerminateEvent(NULL),
    m_FlushEvent(NULL)
/*++

Routine Description:

    The constructor for the quality forwarder object. Just initializes
    everything to NULL and opens the kernel mode quality proxy.

Arguments:

    UnkOuter -
        Specifies the outer unknown, which must be set.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    //
    // Must have a parent, as this is always an aggregated object.
    //
    if (UnkOuter) {
        //
        // Try to open the default quality management device.
        //
        *hr = KsOpenDefaultDevice(
            KSCATEGORY_QUALITY,
            GENERIC_READ,
            &m_QualityManager);
        if (SUCCEEDED(*hr)) {
            DWORD ThreadId;
            DWORD LastError;

            //
            // This is used to synchronize a flush. A waiter is signalled
            // once the outstanding I/O has been cleared.
            //
            m_FlushEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_FlushEvent) {
                //
                // This is used to signal the I/O thread that it should be
                // flushing. Each client will set this and wait on the
                // m_FlushEvent to be signalled. The I/O thread will signal
                // the event for each waiter.
                //
                m_FlushSemaphore = CreateSemaphore(NULL, 0, LONG_MAX, NULL);
                if (m_FlushSemaphore) {
                    //
                    // This is the event used by the thread to wait on Irp's.
                    //
                    m_TerminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                    if (m_TerminateEvent) {
                        m_Thread = CreateThread(
                            NULL,
                            0,
                            reinterpret_cast<PTHREAD_START_ROUTINE>(CKsQualityF::QualityThread),
                            reinterpret_cast<PVOID>(this),
                            0,
                            &ThreadId);
                        if (m_Thread) {
                            SetThreadPriority(m_Thread, THREAD_PRIORITY_HIGHEST);
                            return;
                        }
                    }
                }
            }
            LastError = GetLastError();
            *hr = HRESULT_FROM_WIN32(LastError);
        }
    } else {
        *hr = VFW_E_NEED_OWNER;
    }
}


CKsQualityF::~CKsQualityF(
    )
/*++

Routine Description:

    The destructor for the quality forwarder instance.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // The kernel mode quality proxy may have failed to open.
    //
    if (m_QualityManager) {
        //
        // If there is a quality handle, the thread may have been started. If there
        // was not a handle, then it could not have been started. This will close
        // down everything, and wait for the thread to terminate.
        //
        if (m_TerminateEvent) {
            if (m_Thread) {
                //
                // Signal the thread of a change, and wait for the thread to terminate.
                //
                SetEvent(m_TerminateEvent);
                WaitForSingleObjectEx(m_Thread, INFINITE, FALSE);
                CloseHandle(m_Thread);
            }
            CloseHandle(m_TerminateEvent);
        }
        if (m_FlushSemaphore) {
            CloseHandle(m_FlushSemaphore);
        }
        if (m_FlushEvent) {
            CloseHandle(m_FlushEvent);
        }
        CloseHandle(m_QualityManager);
    }
}


STDMETHODIMP 
CKsQualityF::NonDelegatingQueryInterface(
    REFIID InterfaceId,
    PVOID* Interface
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsQualityForwarder.

Arguments:

    InterfaceId -
        The identifier of the interface to return.

    Interface -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (InterfaceId == __uuidof(IKsQualityForwarder)) {
        return GetInterface(static_cast<IKsQualityForwarder*>(this), Interface);
    }
    return CUnknown::NonDelegatingQueryInterface(InterfaceId, Interface);
}


STDMETHODIMP_(HANDLE) 
CKsQualityF::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsQualityForwarder::KsGetObjectHandle method.

Arguments:

    None.

Return Value:

    Returns the handle to the underlying kernel mode proxy quality manager. This
    is used by the ActiveMovie filter proxy to hand to kernel mode filters.

--*/
{
    return m_QualityManager;
}


STDMETHODIMP_(VOID)
CKsQualityF::KsFlushClient(
    IN IKsPin* Pin
    )
/*++

Routine Description:

    Implements the IKsQualityForwarder::KsFlushClient method. Ensures that any
    pending quality complaints from the kernel mode quality manager are flushed.
    This function synchronizes with the delivery thread so that when it returns,
    there are no outstanding messages to send to the pin. Flushed messages are
    not passed on to the pin.

Arguments:

    Pin -
        The pin of the client which is to be flushed.

Return Value:

    Nothing.

--*/
{
    HANDLE EventList[2];
    LONG PreviousCount;

    //
    // Synchronize with the quality thread. Also ensure it does not go away
    // because of an error. First notify the I/O thread that there is another
    // waiter. Then wait on both types of I/O to be flushed.
    //
    ReleaseSemaphore(m_FlushSemaphore, 1, &PreviousCount);
    EventList[0] = m_FlushEvent;
    EventList[1] = m_Thread;
    WaitForMultipleObjects(
        SIZEOF_ARRAY(EventList),
        EventList,
        FALSE,
        INFINITE);
}


HRESULT
CKsQualityF::QualityThread(
    CKsQualityF* KsQualityF
    )
/*++

Routine Description:

    The forwarder thread routine.

Arguments:

    KsQualityF -
        The instance.

Return Value:

    Returns an error if the event could not be created, else NOERROR.

--*/
{
    KSPROPERTY PropertyQuality;
    KSPROPERTY PropertyError;
    OVERLAPPED ovQuality;
    OVERLAPPED ovError;
    HANDLE EventList[TOTAL_WAIT_OBJECTS];
    HRESULT hr;
    DWORD LastError;
    BOOL NeedQualityIo;
    BOOL NeedErrorIo;
    BOOL Flushing;

    //
    // Initialize the property structures once.
    //
    PropertyQuality.Set = KSPROPSETID_Quality;
    PropertyQuality.Id = KSPROPERTY_QUALITY_REPORT;
    PropertyQuality.Flags = KSPROPERTY_TYPE_GET;
    RtlZeroMemory(&ovQuality, sizeof(ovQuality));
    ovQuality.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ovQuality.hEvent == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        return HRESULT_FROM_WIN32(LastError);
    }
    PropertyError.Set = KSPROPSETID_Quality;
    PropertyError.Id = KSPROPERTY_QUALITY_ERROR;
    PropertyError.Flags = KSPROPERTY_TYPE_GET;
    RtlZeroMemory(&ovError, sizeof(ovError));
    ovError.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ovError.hEvent == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        CloseHandle(ovQuality.hEvent);
        return HRESULT_FROM_WIN32(LastError);
    }
    //
    // The ordering is obviously significant.
    //
    EventList[WAIT_OBJECT_QUALITY] = ovQuality.hEvent;
    EventList[WAIT_OBJECT_ERROR] = ovError.hEvent;
    EventList[WAIT_OBJECT_FLUSH] = KsQualityF->m_FlushSemaphore;
    EventList[WAIT_OBJECT_EXIT] = KsQualityF->m_TerminateEvent;
    //
    // Initially the loop needs to queue up an outstanding I/O against
    // both of the properties.
    //
    NeedQualityIo = TRUE;
    NeedErrorIo = TRUE;
    //
    // Flushing is not turned on until a flushing request is made by a client.
    //
    Flushing = FALSE;
    //
    // The thread exits when the termination event is set, or an error occurs.
    //
    hr = NOERROR;
    do {
        ULONG BytesReturned;
        DWORD WaitObject;
        KSQUALITY Quality;
        KSERROR Error;

        if (NeedQualityIo) {
            if (DeviceIoControl(
                KsQualityF->m_QualityManager,
                IOCTL_KS_PROPERTY,
                &PropertyQuality,
                sizeof(PropertyQuality),
                &Quality,
                sizeof(Quality),
                &BytesReturned,
                &ovQuality)) {
                //
                // Signal the event so that the wait will exit immediately.
                //
                SetEvent(ovQuality.hEvent);
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
                    hr = NOERROR;
                    break;
                }
            }
            NeedQualityIo = FALSE;
        }
        if (NeedErrorIo) {
            if (DeviceIoControl(
                KsQualityF->m_QualityManager,
                IOCTL_KS_PROPERTY,
                &PropertyError,
                sizeof(PropertyError),
                &Error,
                sizeof(Error),
                &BytesReturned,
                &ovError)) {
                //
                // Signal the event so that the wait will exit immediately.
                //
                SetEvent(ovError.hEvent);
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
                    hr = NOERROR;
                    break;
                }
            }
            NeedErrorIo = FALSE;
        }
        //
        // If the thread is currently flushing I/O, then do not wait for
        // the next event. Instead just use the last value, which would have
        // been WAIT_OBJECT_FLUSH, to check for completed I/O.
        //
        if (!Flushing) {
            WaitObject = WaitForMultipleObjects(
                SIZEOF_ARRAY(EventList),
                EventList,
                FALSE,
                INFINITE);
        }
        switch (WaitObject - WAIT_OBJECT_0) {
        case WAIT_OBJECT_QUALITY:
            //
            // The I/O has been completed. On error just exit the thread.
            //
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovQuality, &BytesReturned, TRUE)) {
                reinterpret_cast<IKsPin*>(Quality.Context)->KsQualityNotify(
                    Quality.Proportion,
                    Quality.DeltaTime);
                NeedQualityIo = TRUE;
            } else {
                //
                // The I/O failed. Exit so that the thead does not
                // just spin.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
            break;
        case WAIT_OBJECT_ERROR:
            //
            // The I/O has been completed. On error just exit the thread.
            //
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovError, &BytesReturned, TRUE)) {
                IMediaEventSink* EventSink;
                HRESULT hrReturn;

                hrReturn = reinterpret_cast<IKsPin*>(Quality.Context)->QueryInterface(
                    __uuidof(IMediaEventSink),
                    reinterpret_cast<PVOID*>(&EventSink));
                //
                // Only notify the pin of the error if the event sink
                // is supported. Failure is ignored.
                //
                if (SUCCEEDED(hrReturn)) {
                    DWORD   DosError;

                    //
                    // The pin will not go away before this module,
                    // so release the reference immediately.
                    //
                    EventSink->Release();
                    DosError = RtlNtStatusToDosError(Error.Status);
                    hrReturn = HRESULT_FROM_WIN32(DosError);
                    EventSink->Notify(
                        EC_ERRORABORT,
                        hrReturn,
                        0);
                }
                NeedErrorIo = TRUE;
            } else {
                //
                // The I/O failed. Exit so that the thead does not
                // just spin.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
            break;
        case WAIT_OBJECT_FLUSH:
            //
            // A client wishes to synchronize with the thread to ensure
            // that all items have been flushed. Turn on the flushing
            // flag so that no more waits will occur until all data has
            // been flushed from the queues.
            //
            Flushing = TRUE;
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovQuality, &BytesReturned, FALSE)) {
                //
                // The current I/O had been completed, so keep trying
                // to perform I/O until a pending return occurs. Then
                // signal the waiter.
                //
                NeedQualityIo = TRUE;
            } else {
                //
                // On error, this will exit the outer loop and terminate
                // the thread. Else a wait on I/O will occur.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr == HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)) {
                    //
                    // No error, the I/O is just outstanding.
                    //
                    hr = NOERROR;
                } else {
                    //
                    // Exit the switch before flushing any Error I/O. This
                    // will then cause an exit of the thread.
                    //
                    break;
                }
            }
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovError, &BytesReturned, FALSE)) {
                //
                // The current I/O had been completed, so keep trying
                // to perform I/O until a pending return occurs. Then
                // signal the waiter.
                //
                NeedErrorIo = TRUE;
            } else {
                //
                // On error, this will exit the outer loop and terminate
                // the thread. Else a wait on I/O will occur.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr == HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)) {
                    //
                    // No error, the I/O is just outstanding.
                    //
                    hr = NOERROR;
                }
            }
            //
            // If no I/O request needs to be made, then everything has been
            // flushed, and flushing for this client has been completed. Signal
            // the semaphore which one or more clients is waiting on, and end
            // the flushing. This will allow the wait to occur again, which
            // might start flushing for another client.
            //
            if (!NeedQualityIo && !NeedErrorIo) {
                //
                // This may restart any random waiter, but it does not matter,
                // since they are all waiting on the same thing.
                //
                SetEvent(KsQualityF->m_FlushEvent);
                Flushing = FALSE;
            }
            break;
        case WAIT_OBJECT_EXIT:
            //
            // The object is being shut down. Set an innocuous
            // error to exit the outer loop.
            //
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            break;
        }
        //
        // Exit the outer loop on failure.
        //
    } while (SUCCEEDED(hr));
    CloseHandle(ovQuality.hEvent);
    CloseHandle(ovError.hEvent);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\kspipes.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    kspipes.h

Abstract:

    Internal header.
    
Author(s):

    Rafael Lisitsa (RafaelL) 22-July-1998

--*/

//
// Pipe connection table.
//
// First index - the upstream pipe logical memory type.
// Second index - the downstream pipe logical memory type. 
// Third index - the attempt count
//                       
// Table returns the number of resulting pipes and the direction from the connection point
// that determines the resulting pipe memory type.
//  
const CONNECTION_TABLE_ENTRY ConnectionTable[ConnectionTableDimension] [ConnectionTableDimension] [ConnectionTableMaxEntries] =
{
{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} } },

{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} }, 
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} } },

{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} }, 
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} } },
  
{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },  
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} }, 
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} } },

{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },    
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} }, 
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} } },

{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} } },

{ { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_UPSTREAM},   {2, KS_DIRECTION_DOWNSTREAM}, {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} },
  { {1, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_DOWNSTREAM}, {2, KS_DIRECTION_UPSTREAM},   {0, 0}, {0, 0}, {0, 0} } }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksuser\guids.c ===
#include <ksguid.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\ksutil.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksutil.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author(s):

    George Shaw (gshaw)

--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <setupapi.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <limits.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>

#define GLOBAL_KSIPROXY
#include "ksiproxy.h"
#include "kspipes.h"

const TCHAR MediaInterfacesKeyName[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaInterfaces");
const TCHAR IidNamedValue[] = TEXT("iid");

#if DBG || defined(DEBUG)
ULONG DataFlowVersion=274;
#endif


STDMETHODIMP
KsResolveRequiredAttributes(
    PKSDATARANGE DataRange,
    PKSMULTIPLE_ITEM Attributes OPTIONAL
    )
/*++

Routine Description:

    Attempts to find all attributes in the attribute list within the attributes
    attached to the data range, and ensure that all required attributes in the
    data range have been found.

Arguments:

    DataRange -
        The data range whose attribute list (if any) is to be searched. All
        required attributes in the attached list must be found. Any attribute
        list is assumed to follow the data range.

    Attributes -
        Optionally points to a list of attributes to find in the attribute
        list (if any) attached to the data range.

Return Value:

    Returns NOERROR if the lists were resolved, else ERROR_INVALID_DATA.

--*/
{
    if (Attributes) {
        //
        // If there are no attributes associated with this range, then the
        // function must fail.
        //
        if (!(DataRange->Flags & KSDATARANGE_ATTRIBUTES)) {
            return ERROR_INVALID_DATA;
        }

        PKSMULTIPLE_ITEM RangeAttributes;
        ULONG RequiredAttributes = 0;

        if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
            //
            // Count the required attributes in the range. Each time a required one
            // is encounted that resolves an attribute in the other list, the count
            // can be decremented. In the end, this count should be zero.
            //
            RangeAttributes = reinterpret_cast<PKSMULTIPLE_ITEM>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            PKSATTRIBUTE RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(RangeAttributes + 1);
            for (ULONG RangeCount = RangeAttributes->Count; RangeCount; RangeCount--) {
                if (RangeAttribute->Flags & KSATTRIBUTE_REQUIRED) {
                    RequiredAttributes++;
                }
                RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(reinterpret_cast<BYTE*>(RangeAttribute) + ((RangeAttribute->Size + 7) & ~7));
            }
        } else {
            //
            // There are no attributes in the range, so the required count will
            // be zero.
            //
            RangeAttributes = NULL;
        }

        PKSATTRIBUTE Attribute = reinterpret_cast<PKSATTRIBUTE>(Attributes + 1);

        for (ULONG AttributeCount = Attributes->Count; AttributeCount; AttributeCount--) {
            PKSATTRIBUTE RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(RangeAttributes + 1);
            for (ULONG RangeCount = RangeAttributes->Count; RangeCount; RangeCount--) {
                if (RangeAttribute->Attribute == Attribute->Attribute) {
                    //
                    // If the attribute found is required, adjust the count of
                    // outstanding required items. This should be zero at the
                    // end in order to succeed.
                    //
                    if (RangeAttribute->Flags & KSATTRIBUTE_REQUIRED) {
                        RequiredAttributes--;
                    }
                    break;
                }
                RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(reinterpret_cast<BYTE*>(RangeAttribute) + ((RangeAttribute->Size + 7) & ~7));
            }
            //
            // The attribute could not be found in the range list.
            //
            if (!RangeCount) {
                return ERROR_INVALID_DATA;
            }
            Attribute = reinterpret_cast<PKSATTRIBUTE>(reinterpret_cast<BYTE*>(Attribute) + ((RangeAttribute->Size + 7) & ~7));
        }
        //
        // If all the required attributes were found, then return success.
        // This could be fooled by having the same required attribute present
        // multiple times, and another missing, but this is not a parameter
        // validation check.
        //
        return RequiredAttributes ? ERROR_INVALID_DATA : NOERROR;
    }
    //
    // If no attribute list has been passed in, then the function can only
    // succeed if there are no required attributes to find.
    //
    return (DataRange->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES) ? ERROR_INVALID_DATA : NOERROR;
}


STDMETHODIMP
KsOpenDefaultDevice(
    REFGUID Category,
    ACCESS_MASK Access,
    PHANDLE DeviceHandle
    )
{
    HRESULT     hr;
    HDEVINFO    Set;
    DWORD       LastError;


    //
    // Retrieve the set of items. This may contain multiple items, but
    // only the first (default) item is used.
    //
    Set = SetupDiGetClassDevs(
        const_cast<GUID*>(&Category),
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (Set != INVALID_HANDLE_VALUE) {
        //
        // Reserve enough space for a large name, plus the details
        // structure.
        //
        PSP_DEVICE_INTERFACE_DETAIL_DATA    DeviceDetails;
        SP_DEVICE_INTERFACE_DATA            DeviceData;
        BYTE    Storage[sizeof(*DeviceDetails) + 256 * sizeof(TCHAR)];

        DeviceDetails = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(Storage);
        DeviceData.cbSize = sizeof(DeviceData);
        DeviceDetails->cbSize = sizeof(*DeviceDetails);
        //
        // Retrieve the first item in the set. If there are multiple items
        // in the set, the first item is always the "default" for the class.
        //
        if (SetupDiEnumDeviceInterfaces(Set, NULL, const_cast<GUID*>(&Category), 0, &DeviceData) &&
            SetupDiGetDeviceInterfaceDetail(Set, &DeviceData, DeviceDetails, sizeof(Storage), NULL, NULL)) {
            //
            // Open a handle on that item. There will be properties both
            // read and written, so open for read/write.
            //
            *DeviceHandle = CreateFile(
                DeviceDetails->DevicePath,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                NULL);
            if (*DeviceHandle == INVALID_HANDLE_VALUE) {
                //
                // Allow the caller to depend on the value being set to
                // NULL if the call fails.
                //
                *DeviceHandle = NULL;
                //
                // Retrieve creation error.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            } else {
                hr = S_OK;
            }
        } else {
            //
            // Retrieve enumeration or device details error.
            //
            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);
        }
        SetupDiDestroyDeviceInfoList(Set);
    } else {
        //
        // Retrieve class device list error.
        //
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
    }
    return hr;
}

#define STATUS_SOME_NOT_MAPPED      0x00000107
#define STATUS_MORE_ENTRIES         0x00000105
#define STATUS_ALERTED              0x00000101


STDMETHODIMP
KsSynchronousDeviceControl(
    HANDLE Handle,
    ULONG IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    )
/*++

Routine Description:

    Performs a synchronous Device I/O Control, waiting for the device to
    complete if the call returns a Pending status.

Arguments:

    Handle -
        The handle of the device to perform the I/O on.

    IoControl -
        The I/O control code to send.

    InBuffer -
        The first buffer.

    InLength -
        The size of the first buffer.

    OutBuffer -
        The second buffer.

    OutLength -
        The size of the second buffer.

    BytesReturned -
        The number of bytes returned by the I/O.

Return Value:

    Returns NOERROR if the I/O succeeded.

--*/
{
    OVERLAPPED  ov;
    HRESULT     hr;
    DWORD       LastError;
    DECLARE_KSDEBUG_NAME(EventName);

    RtlZeroMemory(&ov, sizeof(ov));
    BUILD_KSDEBUG_NAME(EventName, _T("EvKsSynchronousDeviceControl#%p"), &ov.hEvent);
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, KSDEBUG_NAME(EventName));
    ASSERT(KSDEBUG_UNIQUE_NAME());
    if ( !ov.hEvent ) {
        LastError = GetLastError();
        return HRESULT_FROM_WIN32(LastError);
    }
    if (!DeviceIoControl(
        Handle,
        IoControl,
        InBuffer,
        InLength,
        OutBuffer,
        OutLength,
        BytesReturned,
        &ov)) {
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            if (GetOverlappedResult(Handle, &ov, BytesReturned, TRUE)) {
                hr = NOERROR;
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
        }
    } else {
        //
        // DeviceIoControl returns TRUE on success, even if the success
        // was not STATUS_SUCCESS. It also does not set the last error
        // on any successful return. Therefore any of the successful
        // returns which standard properties can return are not returned.
        //
        switch (ov.Internal) {
        case STATUS_SOME_NOT_MAPPED:
            hr = HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED);
            break;
        case STATUS_MORE_ENTRIES:
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            break;
        case STATUS_ALERTED:
            hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
            break;
        default:
            hr = NOERROR;
            break;
        }
    }
    CloseHandle(ov.hEvent);
    return hr;
}


STDMETHODIMP
GetState(
    HANDLE Handle,
    PKSSTATE State
    )
/*++

Routine Description:

    Queries a pin handle as to it's current state.

Arguments:

    Handle -
        The handle of the device to query.

    State -
        The place in which to put the current state.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = KsSynchronousDeviceControl(
        Handle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        State,
        sizeof(*State),
        &BytesReturned);
    //
    // It is valid for a filter to not support the State property.
    // Returning a Run state makes pin Activation skip Acquire
    // order checking. If a pin does not keep track of state, then
    // it cannot indicate a need for acquire ordering, since not
    // keeping track of state would not allow it to know anything
    // about acquire ordering.
    //

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE GetState handle=%x %d rets %x"), Handle, *State, hr ));

    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        *State = KSSTATE_RUN;
        hr = NOERROR;

        DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE GetState SUBST handle=%x %d rets %x"), Handle, *State, hr ));
    }
    return hr;
}


STDMETHODIMP
SetState(
    HANDLE Handle,
    KSSTATE State
    )
/*++

Routine Description:

    Sets the state on a pin handle.

Arguments:

    Handle -
        The handle of the device to set.

    State -
        Contains the new state to set.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        Handle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &State,
        sizeof(State),
        &BytesReturned);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE SetState handle=%x %d rets %x"), Handle, State, hr ));

    //
    // It is valid for a filter to not support the State property.
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        hr = NOERROR;
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE SetState SUBST handle=%x %d rets %x"), Handle, State, hr ));
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_READY)) {
        hr = S_FALSE;
    }

    return hr;
}


STDMETHODIMP
InitializeDataFormat(
    IN const CMediaType* MediaType,
    IN ULONG InitialOffset,
    OUT PVOID* Format,
    OUT ULONG* FormatLength
    )
/*++

Routine Description:

    Given a media type, allocates and initializes a DataFormat structure.

Arguments:

    MediaType -
        The media type to extract the information from.

    InitialOffset -
        Contains the offset into the buffer at which the data format is to
        be placed. This allows a connection structure to be inserted into
        the buffer returned.

    Format -
        The place in which to return the pointer to the buffer allocated
        that contains the data format at the indicated offset. This must
        be freed with CoTaskMemFree.

    FormatLength -
        The place in which to return the length of the buffer allocated,
        not including any initial offset passed.

Return Value:

    Returns NOERROR on success, else E_OUTOFMEMORY.

--*/
{
    //
    // The media type may have associated attributes. Get a pointer to these
    // first, so that any allocation can take into account the extra space
    // needed.
    //
    PKSMULTIPLE_ITEM Attributes = NULL;
    if (MediaType->pUnk) {
        IMediaTypeAttributes* MediaAttributes;

        //
        // This is the specific interface which must be supported by the
        // attached object. Something else may have attached an object
        // instead, so no assumptions as to what is attached are made.
        //
        if (SUCCEEDED(MediaType->pUnk->QueryInterface(__uuidof(MediaAttributes), reinterpret_cast<PVOID*>(&MediaAttributes)))) {
            MediaAttributes->GetMediaAttributes(&Attributes);
            MediaAttributes->Release();
        }
    }
    //
    // If there are associated attributes, ensure that the data format allocation
    // takes into account the space needed for them.
    //
    *FormatLength = sizeof(KSDATAFORMAT) + MediaType->FormatLength();
    if (Attributes) {
        //
        // Align the data format, then add the attributes length.
        //
        *FormatLength = ((*FormatLength + 7) & ~7) + Attributes->Size;
    }
    *Format = CoTaskMemAlloc(InitialOffset + *FormatLength);
    if (!*Format) {
        return E_OUTOFMEMORY;
    }
    PKSDATAFORMAT DataFormat = reinterpret_cast<PKSDATAFORMAT>(reinterpret_cast<PBYTE>(*Format) + InitialOffset);
    DataFormat->FormatSize = sizeof(*DataFormat) + MediaType->FormatLength();
    DataFormat->Flags = MediaType->IsTemporalCompressed() ? KSDATAFORMAT_TEMPORAL_COMPRESSION : 0;
    DataFormat->SampleSize = MediaType->GetSampleSize();
    DataFormat->Reserved = 0;
    DataFormat->MajorFormat = *MediaType->Type();
    DataFormat->SubFormat = *MediaType->Subtype();
    DataFormat->Specifier = *MediaType->FormatType();
    CopyMemory(DataFormat + 1, MediaType->Format(), MediaType->FormatLength());
    //
    // If there are attributes, then they need to be appended.
    //
    if (Attributes) {
        DataFormat->Flags |= KSDATAFORMAT_ATTRIBUTES;
        CopyMemory(
            reinterpret_cast<PBYTE>(DataFormat) + ((DataFormat->FormatSize + 7) & ~7),
            Attributes,
            Attributes->Size);
    }
    return NOERROR;
}


STDMETHODIMP
SetMediaType(
    HANDLE Handle,
    const CMediaType* MediaType
    )
/*++

Routine Description:

    Given a media type, attempts to set the current data format of a pin.

Arguments:

    Handle -
        Handle of the pin.

    MediaType -
        The media type to extract the information from.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    PKSDATAFORMAT   DataFormat;
    KSPROPERTY      Property;
    HRESULT         hr;
    ULONG           BytesReturned;
    ULONG           FormatSize;

    hr = InitializeDataFormat(MediaType, 0, reinterpret_cast<void**>(&DataFormat), &FormatSize);
    if (FAILED(hr)) {
        return hr;
    }
    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_DATAFORMAT;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        Handle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        DataFormat,
        FormatSize,
        &BytesReturned);
    CoTaskMemFree(DataFormat);
    return hr;
}


STDMETHODIMP
Active(
    IKsPin* KsPin,
    ULONG PinType,
    HANDLE PinHandle,
    KSPIN_COMMUNICATION Communication,
    IPin* ConnectedPin,
    CMarshalerList* MarshalerList,
    CKsProxy* KsProxy
    )
/*++

Routine Description:

    Sets the state to Pause on the specified pin. If the pin is not
    actually connected, then the function silently succeeds. If the
    pin is a Communication Source, and the pin it is connected to is
    also a proxy, then the state of that filter is set to Acquire
    first. If it is connected to a Communication Source, then the
    connected filter is set to Acquire afterwards. The pins which call
    this function first check for recursion in case there is a loop
    in the graph.

Arguments:

    KsPin -
        The pin.

    PinType -
        Type of KsPin.

    PinHandle -
        Handle of the pin.

    Communication -
        Contains the Communication type for this pin.

    ConnectedPin -
        Contains the interface of any connected pin, or NULL if the
        pin is not actually connected.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is notified of state changes.

    KsProxy -
        This proxy instance object.


Return Value:

    Returns NOERROR, else some failure.

--*/
{
    HRESULT hr;

    //
    // An unconnected pin is fine.
    //
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Active entry KsPin=%x Handle=%x"), KsPin, PinHandle ));

    if (PinHandle) {
        KSSTATE State;

        if (FAILED(hr = GetState(PinHandle, &State))) {
            //
            // In case the pin was already activated for some reason,
            // ignore the expected warning case.
            //
            if ((hr != HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED)) ||
                (State != KSSTATE_PAUSE)) {
                return hr;
            }
        }
        //
        // Only if the state is currently stopped should the transition
        // through Acquire be forced. Although it is valid to go specifically
        // to an Acquire state, ActiveMovie does not currently support
        // such a state.
        //
        if (State == KSSTATE_STOP) {
            //
            // This will propagate acquire through all the connected kernel-mode
            // pins graph-wide.
            //
            hr = KsProxy->PropagateAcquire(KsPin, TRUE);

            ::FixupPipe(KsPin, PinType);

            if (FAILED(hr) ) {
                return hr;
            }
        }
        //
        // Only bother changing the state if the pin is not already at the
        // correct state. Since a pipe has a single state, this pin may
        // already be in a Pause state.
        //
        if ((State != KSSTATE_PAUSE) && FAILED(hr = SetState(PinHandle, KSSTATE_PAUSE))) {
            //
            // If the state was Stop, then try to get back to that state on
            // an error, so as to partially clean up. Any other filter which
            // was affected was only put into an Acquire state, and they would
            // have been on the Communication sink side, so this should be
            // fine.
            //
            if (State == KSSTATE_STOP) {
                SetState(PinHandle, KSSTATE_STOP);
                DistributeStop(MarshalerList);
            }
        } else {
            DistributePause(MarshalerList);
        }
    } else {
        hr = NOERROR;
    }
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Active exit KsPin=%x Handle=%x rets %x"), KsPin, PinHandle, hr ));

    return hr;
}


STDMETHODIMP
Run(
    HANDLE PinHandle,
    REFERENCE_TIME tStart,
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Sets the state to Run on the specified pin. The base classes make
    sure that filters transition through all the states, so check should
    not be necessary.

Arguments:

    PinHandle -
        Handle of the pin.

    tStart -
        The offset to the actual starting time. This is ignored for now.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is notified of state changes.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT hr;

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Run handle=%x"), PinHandle ));

    //
    // An unconnected pin is fine.
    //
    if (PinHandle) {
        hr = SetState(PinHandle, KSSTATE_RUN);
    } else {
        hr = NOERROR;
    }
    if (SUCCEEDED(hr)) {
        DistributeRun(MarshalerList, tStart);
    }
    return hr;
}


STDMETHODIMP
Inactive(
    HANDLE PinHandle,
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Sets the state to Stop on the specified pin.

Arguments:

    PinHandle -
        Handle of the pin.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is notified of state changes.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT hr;

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Inactive handle=%x"), PinHandle ));

    //
    // An unconnected pin is fine.
    //
    if (PinHandle) {
        hr = SetState(PinHandle, KSSTATE_STOP);
    } else {
        hr = NOERROR;
    }
    DistributeStop(MarshalerList);
    return hr;
}


STDMETHODIMP
CheckConnect(
    IPin* Pin,
    KSPIN_COMMUNICATION CurrentCommunication
    )
/*++

Routine Description:

    Attempts to determine if the specified connection is even possible. This
    is in addition to the basic checking performed by the base classes. Checks
    the Communication type to see if the pin can even be connected to, and if
    it is compatible with the receiving pin.

Arguments:

    Pin -
        The receving pin whose Communication compatibility is to be checked.

    CurrentCommunication -
        The Communication type of the calling pin.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT     hr;
    IKsPin*     KsPin;

    DbgLog((LOG_TRACE, 2, TEXT("::CheckConnect")));

    //
    // Ensure that this pin can even connect to another pin at all.
    //
    if (!(CurrentCommunication & KSPIN_COMMUNICATION_BOTH)) {
        DbgLog((LOG_TRACE, 2, TEXT("failed CurrentCommunication check")));

        hr = E_FAIL;
    } else if (SUCCEEDED(hr = Pin->QueryInterface(__uuidof(IKsPin), reinterpret_cast<PVOID*>(&KsPin)))) {
        DbgLog((LOG_TRACE, 2, TEXT("retrieved peer IKsPin interface")));

        KSPIN_COMMUNICATION PeerCommunication;

        KsPin->KsGetCurrentCommunication(&PeerCommunication, NULL, NULL);
        //
        // Ensure the pin being checked is supports Source and/or Sink,
        // and that the combination of this pin and the peer pin covers
        // both Source and Sink so that one will be able to be Source,
        // and the other Sink.
        //
        if (!(PeerCommunication & KSPIN_COMMUNICATION_BOTH) ||
            (PeerCommunication | CurrentCommunication) != KSPIN_COMMUNICATION_BOTH) {
            hr = E_FAIL;
        }
        KsPin->Release();
    } else if (!(CurrentCommunication & KSPIN_COMMUNICATION_SINK)) {
        //
        // If the pin being checked in not a proxied pin, then this pin
        // must be a Sink.
        //
        DbgLog((LOG_TRACE, 2, TEXT("pin communication != Sink")));
        hr = E_FAIL;
    } else {
        hr = S_OK;
    }
    return hr;
}


STDMETHODIMP
KsGetMultiplePinFactoryItems(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG PropertyId,
    PVOID* Items
    )
/*++

Routine Description:

    Retrieves variable length data from Pin property items. Queries for the
    data size, allocates a buffer, and retrieves the data.

Arguments:

    FilterHandle -
        The handle of the filter to query.

    PinFactoryId -
        The Pin Factory Id to query.

    PropertyId -
        The property in the Pin property set to query.

    Items -
        The place in which to put the buffer containing the data items. This
        must be deleted with CoTaskMemFree if the function succeeds.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    HRESULT     hr;
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    //
    // Query for the size of the data.
    //
    hr = KsSynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        NULL,
        0,
        &BytesReturned);
#if 1
//!! This goes away post-Beta!!
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ULONG       ItemSize;

        DbgLog((LOG_TRACE, 2, TEXT("Filter does not support zero length property query!")));
        hr = KsSynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            &Pin,
            sizeof(Pin),
            &ItemSize,
            sizeof(ItemSize),
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            BytesReturned = ItemSize;
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        }
    }
#endif
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the data.
        //
        *Items = CoTaskMemAlloc(BytesReturned);
        if (!*Items) {
            return E_OUTOFMEMORY;
        }
        hr = KsSynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            &Pin,
            sizeof(Pin),
            *Items,
            BytesReturned,
            &BytesReturned);
        if (FAILED(hr)) {
            CoTaskMemFree(*Items);
        }
    }
    return hr;
}


STDMETHODIMP
FindIdentifier(
    PKSIDENTIFIER TargetIdentifier,
    PKSIDENTIFIER IdentifierList,
    ULONG IdentifierCount
    )
/*++

Routine Description:

    A helper function for FindCompatiblePinFactoryIdentifier. This function
    compares a target to the given list of identifiers, and returns whether
    the target was found in the list.

Arguments:

    TargetIdentifer -
        The target to search for in the list.

    IdentifierList -
        Points to a list of identifiers to compare the target against.

    IdentifierCount -
        Contains the number of items in the identifier list.

Return Value:

    Returns NOERROR if the target was found, else E_FAIL.

--*/
{
    for (; IdentifierCount; IdentifierCount--, IdentifierList++) {
        if (!memcmp(TargetIdentifier, IdentifierList, sizeof(*TargetIdentifier))) {
            return NOERROR;
        }
    }
    return E_FAIL;
}


STDMETHODIMP
FindCompatiblePinFactoryIdentifier(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    ULONG PropertyId,
    PKSIDENTIFIER Identifier
    )
/*++

Routine Description:

    Look for a matching identifier from the property given. This is essentially
    either an Interface or Medium identifier. Enumerate both lists and return
    the first match, if any. The destination may be NULL if just the first item
    is to be returned.

Arguments:

    SourcePin -
        The source pin to enumerate.

    DestPin -
        The destination pin to enumerate. This can be NULL if the first
        identifier only is to be returned.

    PropertyId -
        The property in the Pin property set to query.

    Identifier -
        The place in which to put the matching identifier, if any.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    SourceItems;
    PKSIDENTIFIER       SourceIdentifier;

    //
    // Retrieve both lists of identifiers. Only retrieve the destination list
    // if a destination has been specified.
    //
    if (PropertyId == KSPROPERTY_PIN_MEDIUMS) {
        hr = SourcePin->KsQueryMediums(&SourceItems);
    } else {
        hr = SourcePin->KsQueryInterfaces(&SourceItems);
    }
    if (FAILED(hr)) {
        return hr;
    }
    SourceIdentifier = reinterpret_cast<PKSIDENTIFIER>(SourceItems + 1);
    if (DestPin) {
        PKSMULTIPLE_ITEM    DestItems;
        PKSIDENTIFIER       DestIdentifier;

        if (PropertyId == KSPROPERTY_PIN_MEDIUMS) {
            hr = DestPin->KsQueryMediums(&DestItems);
        } else {
            hr = DestPin->KsQueryInterfaces(&DestItems);
        }
        if (FAILED(hr)) {
            CoTaskMemFree(SourceItems);
            return hr;
        }
        DestIdentifier = (PKSIDENTIFIER)(DestItems + 1);
        hr = E_FAIL;
        //
        // Find the highest identifier in either the source or destination
        // which matches an identifier in the opposing list. This means that
        // instead of just running through each of the identifiers on one
        // list, comparing to all on the opposing list, the loop must look
        // from the top of each list in an alternating style. This produces
        // the exact same number of comparisons as a straight search through
        // one list. The source list is looked at first during each iteration,
        // so it arbitrarily may find a match first.
        //
        for (; SourceItems->Count && DestItems->Count; DestItems->Count--, DestIdentifier++) {
            //
            // For each item in the source, try to find it in the destination.
            //
            hr = FindIdentifier(SourceIdentifier, DestIdentifier, DestItems->Count);
            if (SUCCEEDED(hr)) {
                *Identifier = *SourceIdentifier;
                break;
            }
            //
            // This comparison was already done in the above search, so increment
            // to the next item in the list before doing the next search.
            //
            SourceItems->Count--;
            SourceIdentifier++;
            //
            // For each item in the destination, try to find it in the source.
            //
            hr = FindIdentifier(DestIdentifier, SourceIdentifier, SourceItems->Count);
            if (SUCCEEDED(hr)) {
                *Identifier = *DestIdentifier;
                break;
            }
        }
        CoTaskMemFree(DestItems);
    } else {
        KSPIN_INTERFACE Standard;

        //
        // If there is no destination, just return the first item. This is
        // for the case of a Bridge or UserMode to KernelMode connection.
        // If this is an Interface query, then given preference to the
        // standard interface first, else choose the first item if not
        // present in the list.
        //
        if (PropertyId == KSPROPERTY_PIN_INTERFACES) {
            Standard.Set = KSINTERFACESETID_Standard;
            Standard.Id = KSINTERFACE_STANDARD_STREAMING;
            Standard.Flags = 0;
            if (SUCCEEDED(FindIdentifier(&Standard, SourceIdentifier, SourceItems->Count))) {
                SourceIdentifier = &Standard;
            }
        }
        *Identifier = *SourceIdentifier;
    }
    CoTaskMemFree(SourceItems);
    return hr;
}


STDMETHODIMP
FindCompatibleInterface(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_INTERFACE Interface
    )
/*++

Routine Description:

    Look for a matching Interface given a pair of pins. The destination
    may be NULL if just the first Interface is to be returned.

Arguments:

    SourcePin -
        The source pin to enumerate.

    DestPin -
        The destination pin to enumerate. This can be NULL if the first
        Interface only is to be returned.

    Interface -
        The place in which to put the matching Interface, if any.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    if (DestPin && SUCCEEDED(DestPin->KsGetCurrentCommunication(NULL, Interface, NULL))) {
        return NOERROR;
    }
    return FindCompatiblePinFactoryIdentifier(SourcePin, DestPin, KSPROPERTY_PIN_INTERFACES, Interface);
}


STDMETHODIMP
FindCompatibleMedium(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_MEDIUM Medium
    )
/*++

Routine Description:

    Look for a matching Medium given a pair of pins. The destination
    may be NULL if just the first Interface is to be returned.

Arguments:

    SourcePin -
        The source pin to enumerate.

    DestPin -
        The destination pin to enumerate. This can be NULL if the first
        Medium only is to be returned.

    Interface -
        The place in which to put the matching Medium, if any.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT hr;

    if (DestPin && SUCCEEDED(hr = DestPin->KsGetCurrentCommunication(NULL, NULL, Medium))) {
        return hr;
    }
    return FindCompatiblePinFactoryIdentifier(SourcePin, DestPin, KSPROPERTY_PIN_MEDIUMS, Medium);
}


STDMETHODIMP
SetDevIoMedium(
    IKsPin* Pin,
    PKSPIN_MEDIUM Medium
    )
/*++

Routine Description:

    Set the Medium type to be that used for DevIo communication compatible with
    a Communication Sink or Bridge which the proxy can talk to.

Arguments:

    Pin -
        The pin which will be communicated with.

    Medium
        The Medium structure to initialize.

Return Value:

    Returns NOERROR.

--*/
{
    Medium->Set = KSMEDIUMSETID_Standard;
    Medium->Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Medium->Flags = 0;
    return NOERROR;
}


STDMETHODIMP
KsGetMediaTypeCount(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG* MediaTypeCount
    )
/*++

Routine Description:

    The the count of media types, which is the same as the count of data
    ranges on a Pin Factory Id.

Arguments:

    FilterHandle -
        The filter containing the Pin Factory to query.

    PinFactoryId -
        The Pin Factory Id whose data range count is to be queries.

    MediaTypeCount -
        The place in which to put the count of media types supported.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

    //
    // Retrieve the list of data ranges supported by the Pin Factory Id.
    //
    HRESULT hr = KsGetMultiplePinFactoryItems(
        FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        reinterpret_cast<PVOID*>(&MultipleItem));
    if (FAILED(hr)) {
        hr = KsGetMultiplePinFactoryItems(
            FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem));
    }
    if (SUCCEEDED(hr)) {

        /* NULL == MultipleItem is a pathological case where a driver returns
           a success code in KsGetMultiplePinFactoryItems() when passed a size 0
           buffer.  We'll just do with an assert since we're in ring 3. */
        ASSERT( NULL != MultipleItem );

        //
        // Enumerate the list, subtracting from the count returned the
        // number of attribute lists found. This means the count returned
        // is the actual number of data ranges, not the count returned by
        // the driver.
        //
        *MediaTypeCount = MultipleItem->Count;
        PKSDATARANGE DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
        for (; MultipleItem->Count--;) {
            //
            // If a data range has attributes, advance twice, reducing the
            // current count, and the count returned to the caller.
            //
            if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
                MultipleItem->Count--;
                (*MediaTypeCount)--;
                //
                // This must be incremented here so that overlapping attribute
                // flags do not confuse the count.
                //
                DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            }
            DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
        }
        CoTaskMemFree(MultipleItem);
    }
    return hr;
}


STDMETHODIMP
KsGetMediaType(
    int Position,
    AM_MEDIA_TYPE* AmMediaType,
    HANDLE FilterHandle,
    ULONG PinFactoryId
    )
/*++

Routine Description:

    Returns the specified media type on the Pin Factory Id. This is done
    by querying the list of data ranges, and performing a data intersection
    on the specified data range, producing a data format. Then converting
    that data format to a media type.

Arguments:

    Position -
        The zero-based position to return. This corresponds to the data range
        item.

    AmMediaType -
        The media type to initialize.

    FilterHandle -
        The filter containing the Pin Factory to query.

    PinFactoryId -
        The Pin Factory Id whose nth media type is to be returned.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

    if (Position < 0) {
        return E_INVALIDARG;
    }
    //
    // Retrieve the list of data ranges supported by the Pin Factory Id.
    //
    hr = KsGetMultiplePinFactoryItems(
        FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        reinterpret_cast<PVOID*>(&MultipleItem));
    if (FAILED(hr)) {
        hr = KsGetMultiplePinFactoryItems(
            FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem));
        if (FAILED(hr)) {
            return hr;
        }
    }

    /* NULL == MultipleItem is a pathological case where a driver returns
       a success code in KsGetMultiplePinFactoryItems() when passed a size 0
       buffer.  We'll just do with an assert since we're in ring 3. */
    ASSERT( NULL != MultipleItem );

    //
    // Ensure that this is in range.
    //
    if ((ULONG)Position < MultipleItem->Count) {
        PKSDATARANGE        DataRange;
        PKSP_PIN            Pin;
        PKSMULTIPLE_ITEM    RangeMultipleItem;
        PKSMULTIPLE_ITEM    Attributes;
        ULONG               BytesReturned;

        DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
        //
        // Increment to the correct data range element.
        //
        for (; Position; Position--) {
            //
            // If this data range has associated attributes, skip past the
            // range so that the normal advancement will skip past the attributes.
            // Note that the attributes also have a size parameter as the first
            // structure element.
            //
            if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
                //
                // The count returned includes attribute lists, so check again
                // that the position is within range of the actual list of ranges.
                // The Position has not been decremented yet.
                //
                MultipleItem->Count--;
                if ((ULONG)Position >= MultipleItem->Count) {
                    CoTaskMemFree(MultipleItem);
                    return VFW_S_NO_MORE_ITEMS;
                }
                DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            }
            DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            MultipleItem->Count--;
        }
        //
        // Calculate the query size once, adding in any attributes, which are
        // LONGLONG aligned.
        //
        ULONG QueryBufferSize = sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize;
        if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
            Attributes = reinterpret_cast<PKSMULTIPLE_ITEM>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            QueryBufferSize = ((QueryBufferSize + 7) & ~7) + Attributes->Size;
        } else {
            Attributes = NULL;
        }
        Pin = reinterpret_cast<PKSP_PIN>(new BYTE[QueryBufferSize]);
        if (!Pin) {
            CoTaskMemFree(MultipleItem);
            return E_OUTOFMEMORY;
        }
        Pin->Property.Set = KSPROPSETID_Pin;
        Pin->Property.Id = KSPROPERTY_PIN_DATAINTERSECTION;
        Pin->Property.Flags = KSPROPERTY_TYPE_GET;
        Pin->PinId = PinFactoryId;
        Pin->Reserved = 0;
        //
        // Copy the data range into the query.
        //
        RangeMultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(Pin + 1);
        RangeMultipleItem->Size = sizeof(*RangeMultipleItem) + DataRange->FormatSize;
        RangeMultipleItem->Count = 1;
        CopyMemory(RangeMultipleItem + 1, DataRange, DataRange->FormatSize);
        //
        // If there are associated attributes, then add them as the next item
        // on the list. Space has already been made available for them.
        //
        if (Attributes) {
            RangeMultipleItem->Size = ((RangeMultipleItem->Size + 7) & ~7) + Attributes->Size;
            RangeMultipleItem->Count++;
            CopyMemory(
                reinterpret_cast<BYTE*>(RangeMultipleItem) + RangeMultipleItem->Size - Attributes->Size,
                Attributes,
                Attributes->Size);
        }
        //
        // Perform the data intersection with the data range, first to obtain
        // the size of the resultant data format structure, then to retrieve
        // the actual data format.
        //
        hr = KsSynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            Pin,
            QueryBufferSize,
            NULL,
            0,
            &BytesReturned);
#if 1
//!! This goes away post-Beta!!
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            ULONG       ItemSize;

            DbgLog((LOG_TRACE, 2, TEXT("Filter does not support zero length property query!")));
            hr = KsSynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                QueryBufferSize,
                &ItemSize,
                sizeof(ItemSize),
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                BytesReturned = ItemSize;
                hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            }
        }
#endif
        if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
            PKSDATAFORMAT       DataFormat;

            ASSERT(BytesReturned >= sizeof(*DataFormat));
            DataFormat = reinterpret_cast<PKSDATAFORMAT>(new BYTE[BytesReturned]);
            if (!DataFormat) {
                delete [] (PBYTE)Pin;
                CoTaskMemFree(MultipleItem);
                return E_OUTOFMEMORY;
            }
            hr = KsSynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                QueryBufferSize,
                DataFormat,
                BytesReturned,
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                ASSERT(DataFormat->FormatSize == BytesReturned);
                CMediaType* MediaType = static_cast<CMediaType*>(AmMediaType);
                //
                // Initialize the media type based on the returned data format.
                //
                MediaType->SetType(&DataFormat->MajorFormat);
                MediaType->SetSubtype(&DataFormat->SubFormat);
                MediaType->SetTemporalCompression(DataFormat->Flags & KSDATAFORMAT_TEMPORAL_COMPRESSION);
                MediaType->SetSampleSize(DataFormat->SampleSize);
                if (DataFormat->FormatSize > sizeof(*DataFormat)) {
                    if (!MediaType->SetFormat(reinterpret_cast<BYTE*>(DataFormat + 1), DataFormat->FormatSize - sizeof(*DataFormat))) {
                        hr = E_OUTOFMEMORY;
                    }
                }
                MediaType->SetFormatType(&DataFormat->Specifier);
                //
                // If the returned format has associated attributes, then attach
                // them to the media type via the IUnknown interface available.
                // This attached object caches the attributes for later retrieval.
                //
                if (DataFormat->Flags & KSDATAFORMAT_ATTRIBUTES) {
                    CMediaTypeAttributes* MediaTypeAttributes = new CMediaTypeAttributes();
                    if (MediaTypeAttributes) {
                        MediaType->pUnk = static_cast<IUnknown*>(MediaTypeAttributes);
                        hr = MediaTypeAttributes->SetMediaAttributes(Attributes);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            delete [] reinterpret_cast<BYTE*>(DataFormat);
        }
        delete [] reinterpret_cast<BYTE*>(Pin);
    } else {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    CoTaskMemFree(MultipleItem);
    return hr;
}


STDMETHODIMP_(KSPIN_COMMUNICATION)
ChooseCommunicationMethod(
    CBasePin* SourcePin,
    IKsPin* DestPin
    )
/*++

Routine Description:

    Returns the correct Communication method to use based on the source's
    Communication, and the destination. Note that in the case of a tie, where
    Both is supported, the Data Flow is used so that two proxies will not
    keep choosing the same Communication type.

Arguments:

    SourcePin -
        The source pin from this proxy instance.

    DestPin -
        The standard interface of a pin from some other proxy.

Return Value:

    Returns the Communication type chosen for this pin.

--*/
{
    KSPIN_COMMUNICATION PeerCommunication;
    PIN_DIRECTION       PinDirection;

    DestPin->KsGetCurrentCommunication(&PeerCommunication, NULL, NULL);
    switch (PeerCommunication) {
    case KSPIN_COMMUNICATION_SINK:
        return KSPIN_COMMUNICATION_SOURCE;
    case KSPIN_COMMUNICATION_SOURCE:
        return KSPIN_COMMUNICATION_SINK;
    case KSPIN_COMMUNICATION_BOTH:
        //
        // A tie is broken by using the Data Flow.
        //
        SourcePin->QueryDirection(&PinDirection);
        switch (PinDirection) {
        case PINDIR_INPUT:
            return KSPIN_COMMUNICATION_SINK;
        case PINDIR_OUTPUT:
            return KSPIN_COMMUNICATION_SOURCE;
        }
    }
    //
    // The compiler really wants a return here, even though the
    // parameter is an enumeration, and all items in the enumeration
    // are covered.
    //
    return KSPIN_COMMUNICATION_NONE;
}


STDMETHODIMP
CreatePinHandle(
    KSPIN_INTERFACE& Interface,
    KSPIN_MEDIUM& Medium,
    HANDLE PeerPinHandle,
    CMediaType* MediaType,
    CKsProxy* KsProxy,
    ULONG PinFactoryId,
    ACCESS_MASK DesiredAccess,
    HANDLE* PinHandle
    )
/*++

Routine Description:

    Create a pin handle given all the information to initialize the structures
    with.

Arguments:

    Interface -
        The compatible Interface to use.

    Medium -
        The compatible Medium to use.

    PeerPinHandle -
        The Pin handle to connect to, if any.

    MediaType -
        The compatible media type, which is converted to a data format.

    KsProxy -
        This proxy instance object.

    PinFactoryId -
        The Pin Factory Id to create the pin handle on.

    DesiredAccess -
        The desired access to the created handle.

    PinHandle -
        The place in which to put the handle created.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT         hr;
    PKSPIN_CONNECT  Connect;
    DWORD           Error;
    ULONG           FormatSize;

    hr = InitializeDataFormat(
        MediaType,
        sizeof(*Connect),
        reinterpret_cast<void**>(&Connect),
        &FormatSize);
    if (FAILED(hr)) {
        return hr;
    }
    Connect->Interface = Interface;
    Connect->Medium = Medium;
    Connect->PinId = PinFactoryId;
    Connect->PinToHandle = PeerPinHandle;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = KSPRIORITY_NORMAL;
    Error = KsCreatePin(
        KsProxy->KsGetObjectHandle(),
        Connect,
        DesiredAccess,
        PinHandle );
    hr = HRESULT_FROM_WIN32(Error);
    if (SUCCEEDED( hr )) {
        hr = KsProxy->SetPinSyncSource(*PinHandle);
    } else {
        *PinHandle = NULL;
    }
    CoTaskMemFree(Connect);
    return hr;
}

#ifdef DEBUG_PROPERTY_PAGES

STDMETHODIMP_(VOID)
AppendDebugPropertyPages (
    CAUUID* Pages,
    TCHAR *GuidRoot
    )

/*++

Routine Description:

    Search HKLM\*GuidRoot\DebugPages for any globally defined
    property pages used for debugging.  If such are defined, append them
    to the list of property pages specified in Pages. 

    Note: This routine is only defined when DEBUG_PROPERTY_PAGES is defined.
    I do this such that it can be enabled when needed and disabled when
    shipping.

Arguments:

    Pages -
        The list of property pages

    GuidRoot -
        The HKLM based location where to find the DebugPages key.

--*/

{

    TCHAR       RegistryPath[256];
    HKEY        RegistryKey;
    LONG        Result;

    //
    // The PropertyPages subkey can contain a list of subkeys
    // whose names correspond to COM servers of property pages.
    //
    _stprintf(
        RegistryPath,
        TEXT("%s\\DebugPages"),
        GuidRoot
        );
    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegistryPath,
        0,
        KEY_READ,
        &RegistryKey);

    if (Result == ERROR_SUCCESS) {

        //
        // Enumerate all subkeys for CLSID's of debug property page COM
        // servers.
        //
        for (ULONG PropExtension = 0;; PropExtension++) {
            TCHAR   PageGuidString[40];
            CLSID*  PageList;
            GUID    PageGuid;
            ULONG   Element;
            GUID*   CurElement;

            Result = RegEnumKey(
                RegistryKey,
                PropExtension,
                PageGuidString,
                sizeof(PageGuidString)/sizeof(TCHAR));

            if (Result != ERROR_SUCCESS) {
                break;
            }

#ifdef _UNICODE
            IIDFromString(PageGuidString, &PageGuid);
#else
            WCHAR   UnicodeGuid[64];

            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, PageGuidString, -1, 
                UnicodeGuid, sizeof(UnicodeGuid));
            IIDFromString(UnicodeGuid, &PageGuid);
#endif

            //
            // Look through the list of items to determine
            // if this proppage is already on the list.
            //
            for (CurElement = Pages->pElems, Element = Pages->cElems; Element; Element--, CurElement++) {
                if (PageGuid == *CurElement) {
                    break;
                }
            }
            //
            // If the page id for the proppage was found, then
            // skip it, since it is already on the list.
            //
            if (Element) {
                continue;
            }
                    //
            // Allocate a new list to include the extra Guid, and
            // move the guids to the new memory, then add on the
            // new guid and increment the total count of pages.
            //
            PageList = reinterpret_cast<CLSID*>(CoTaskMemAlloc(sizeof(*Pages->pElems) * (Pages->cElems + 1)));
            if (!PageList) {
                break;
            }
            //
            // This function can be called with no original property
            // pages present.
            //
            if (Pages->cElems) {
                CopyMemory(PageList, Pages->pElems, sizeof(*Pages->pElems) * Pages->cElems);
                CoTaskMemFree(Pages->pElems);
            }
            Pages->pElems = PageList;
            Pages->pElems[Pages->cElems++] = PageGuid;
        }
        RegCloseKey(RegistryKey);
    }
}

#endif // DEBUG_PROPERTY_PAGES


STDMETHODIMP_(VOID)
AppendSpecificPropertyPages(
    CAUUID* Pages,
    ULONG Guids,
    GUID* GuidList,
    TCHAR* GuidRoot,
    HKEY DeviceRegKey
    )
/*++

Routine Description:

    This appends any additional property pages that are specific to each category
    or interface class guid passed. Skips duplicate pages.

Arguments:

    Pages -
        The structure to fill in with the page added list.

    Guids -
        Contains the number of guids present in GuidList.

    GuidList -
        The list of guids to use to look up under media categories for additional
        pages to append to the page list.

    GuidRoot -
        The root in HKLM that may contain the guid as a subkey. This is opened
        to locate the guid subkey and any property pages present.

    DeviceRegKey -
        The handle to the device registry storage location.

Return Value:

    Nothing.

--*/
{
    HKEY        AliasKey;

    //
    // Open the Page Aliases key if it exists in order to translate any
    // guids to private ones in case an alternate COM server is to be
    // used for a particular Property Page.
    //
    if (RegOpenKeyEx(DeviceRegKey, TEXT("PageAliases"), 0, KEY_READ, &AliasKey) != ERROR_SUCCESS) {
        AliasKey = NULL;
    }
    for (; Guids--;) {
        WCHAR      GuidString[CHARS_IN_GUID];

        StringFromGUID2(GuidList[Guids], GuidString, CHARS_IN_GUID);
        {
            TCHAR       RegistryPath[256];
            HKEY        RegistryKey;
            LONG        Result;

            //
            // The PropertyPages subkey can contain a list of subkeys
            // whose names correspond to COM servers of property pages.
            //
            _stprintf(
                RegistryPath,
                TEXT("%s\\") GUID_FORMAT TEXT("\\PropertyPages"),
                GuidRoot,
                GuidString);
            Result = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegistryPath,
                0,
                KEY_READ,
                &RegistryKey);
            if (Result == ERROR_SUCCESS) {
                //
                // Enumerate the subkeys as Guids which are COM classes. Each
                // one found is added to the list of property pages after
                // expanding the property page list.
                //
                for (ULONG PropExtension = 0;; PropExtension++) {
                    TCHAR   PageGuidString[40];
                    CLSID*  PageList;
                    GUID    PageGuid;
                    ULONG   Element;
                    GUID*   CurElement;

                    Result = RegEnumKey(
                        RegistryKey,
                        PropExtension,
                        PageGuidString,
                        NUMELMS(PageGuidString));
                    if (Result != ERROR_SUCCESS) {
                        break;
                    }
                    if (AliasKey) {
                        ULONG       ValueSize;

                        //
                        // Check in the device registry key if there is an alias for
                        // this Page guid that should be used with any object on this
                        // filter. This allows a filter to override standard Page
                        // COM servers, in order to provide their own Page.
                        //
                        ValueSize = sizeof(PageGuid);
                        //
                        // If this succeeds, then IIDFromString is skipped below,
                        // since the IID is already acquired. Else the translation
                        // with the original GUID happens.
                        //
                        Result = RegQueryValueEx(
                            AliasKey,
                            PageGuidString,
                            NULL,
                            NULL,
                            (PBYTE)&PageGuid,
                            &ValueSize);
                    } else {
                        //
                        // Set the Result value to something other than
                        // ERROR_SUCCESS so that the string translation
                        // is done.
                        //
                        Result = ERROR_INVALID_FUNCTION;
                    }
                    if (Result != ERROR_SUCCESS) {
                        //
                        // No alias was found, so translate the original
                        // string. Else the alias will be in PageGuid.
                        //
#ifdef _UNICODE
                        IIDFromString(PageGuidString, &PageGuid);
#else
                        WCHAR   UnicodeGuid[64];

                        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, PageGuidString, -1, UnicodeGuid, sizeof(UnicodeGuid));
                        IIDFromString(UnicodeGuid, &PageGuid);
#endif
                    }
                    //
                    // Look through the list of items to determine
                    // if this proppage is already on the list.
                    //
                    for (CurElement = Pages->pElems, Element = Pages->cElems; Element; Element--, CurElement++) {
                        if (PageGuid == *CurElement) {
                            break;
                        }
                    }
                    //
                    // If the page id for the proppage was found, then
                    // skip it, since it is already on the list.
                    //
                    if (Element) {
                        continue;
                    }
                    //
                    // Allocate a new list to include the extra Guid, and
                    // move the guids to the new memory, then add on the
                    // new guid and increment the total count of pages.
                    //
                    PageList = reinterpret_cast<CLSID*>(CoTaskMemAlloc(sizeof(*Pages->pElems) * (Pages->cElems + 1)));
                    if (!PageList) {
                        break;
                    }
                    //
                    // This function can be called with no original property
                    // pages present.
                    //
                    if (Pages->cElems) {
                        CopyMemory(PageList, Pages->pElems, sizeof(*Pages->pElems) * Pages->cElems);
                        CoTaskMemFree(Pages->pElems);
                    }
                    Pages->pElems = PageList;
                    Pages->pElems[Pages->cElems++] = PageGuid;
                }
                RegCloseKey(RegistryKey);
            }
        }
    }
    if (AliasKey) {
        RegCloseKey(AliasKey);
    }
}


STDMETHODIMP
GetPages(
    IKsObject* Pin,
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    KSPIN_COMMUNICATION Communication,
    HKEY DeviceRegKey,
    CAUUID* Pages
    )
/*++

Routine Description:

    This adds any Specifier handlers to the property pages if the pin instance
    is still unconnected and it is a Bridge pin. Else it adds none.

Arguments:

    Pin -
        The pin on this filter which the property pages are to be created.

    FilterHandle -
        The handle to this filter.

    PinFactoryId -
        The Pin Factory Id that the pin represents.

    Communication -
        The Communications type of this pin.

    DeviceRegKey -
        The handle to the device registry storage location.

    Pages -
        The structure to fill in with the page list.

Return Value:

    Returns NOERROR, else a memory allocation error. Fills in the list of pages
    and page count.

--*/
{
    ULONG   MediaTypeCount;
    GUID    PinCategory;
    KSP_PIN PinProp;
    ULONG   BytesReturned;

    MediaTypeCount = 0;
    Pages->cElems = 0;
    Pages->pElems = NULL;
    //
    // Only add pages if the pin is a Bridge and it is not already connected.
    // The pages are a method to connect a Bridge using UI.
    //
    if ((Communication == KSPIN_COMMUNICATION_BRIDGE) && !Pin->KsGetObjectHandle()) {
        KsGetMediaTypeCount(FilterHandle, PinFactoryId, &MediaTypeCount);
    }
    //
    // This is zero if the pin is not a bridge, or if it already connected, or
    // a media type count query failed.
    //
    if (MediaTypeCount) {
        Pages->pElems = reinterpret_cast<CLSID*>(CoTaskMemAlloc(sizeof(*Pages->pElems) * MediaTypeCount));
        if (!Pages->pElems) {
            return E_OUTOFMEMORY;
        }
        //
        // Each Specifier can be represented in a page.
        //
        for (CLSID* Elements = Pages->pElems; MediaTypeCount--;) {
            AM_MEDIA_TYPE AmMediaType;

            ZeroMemory(reinterpret_cast<PVOID>(&AmMediaType), sizeof(AmMediaType));
            if (SUCCEEDED(KsGetMediaType(MediaTypeCount, &AmMediaType, FilterHandle, PinFactoryId))) {
                WCHAR       ClassString[CHARS_IN_GUID];
                TCHAR       ClassRegistryPath[256];
                HKEY        ClassRegistryKey;
                LONG        Result;
                ULONG       ValueSize;
                ULONG       Element;
                GUID        ClassId;
                GUID*       CurElement;

                //
                // Since there can be data format handlers based on
                // Specifiers that are used by the proxy, and may
                // be registered under the guid of the Specifier,
                // these handlers are indirected through another
                // registry key, so that they can be registered with
                // an alternate GUID.
                //
                StringFromGUID2(AmMediaType.formattype, ClassString, CHARS_IN_GUID);
                _stprintf(
                    ClassRegistryPath,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaSpecifiers\\") GUID_FORMAT,
                    ClassString);
                Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ClassRegistryPath, 0, KEY_READ, &ClassRegistryKey);
                //
                // If the key does not exist, this is OK, as there may be
                // no property page to load.
                //
                if (Result != ERROR_SUCCESS) {
                    continue;
                }
                ValueSize = sizeof(ClassId);
                Result = RegQueryValueEx(
                    ClassRegistryKey,
                    TEXT("clsid"),
                    NULL,
                    NULL,
                    reinterpret_cast<BYTE*>(&ClassId),
                    &ValueSize);
                RegCloseKey(ClassRegistryKey);
                if (Result != ERROR_SUCCESS) {
                    continue;
                }
                //
                // Look through the list of items to determine
                // if this Specifier is already on the list.
                //
                for (CurElement = Pages->pElems, Element = Pages->cElems; Element; Element--, CurElement++) {
                    if (ClassId == *CurElement) {
                        break;
                    }
                }
                //
                // If the class id for the Specifier was found, then
                // skip it, since it is already on the list.
                //
                if (Element) {
                    continue;
                }
                //
                // Add the new specifier.
                //
                Pages->cElems++;
                *(Elements++) = ClassId;
            }
        }
    }

    //
    // If DEBUG_PROPERTY_PAGES is defined, append any property pages used
    // for debugging.  Note that this does not have to be a debug build of
    // KsProxy in order to use this.  These are property pages useful for
    // debugging issues internal to KsProxy, AVStream, etc...  They will be
    // placed on **ALL** proxied pins.  To turn off this feature, do not
    // define DEBUG_PROPERTY_PAGES
    //
    #ifdef DEBUG_PROPERTY_PAGES
        AppendDebugPropertyPages (
            Pages,
            TEXT("Software\\Microsoft\\KsProxy")
            );
    #endif // DEBUG_PROPERTY_PAGES
    //
    // Look for a category guid in order to check for additional property pages
    // which may be based on the category of the pin.
    //
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_CATEGORY;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = PinFactoryId;
    PinProp.Reserved = 0;
    if (SUCCEEDED(KsSynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &PinCategory,
        sizeof(PinCategory),
        &BytesReturned))) {
        //
        // Both categories and interface classes are all placed in the same
        // registry location.
        //
        AppendSpecificPropertyPages(
            Pages,
            1,
            &PinCategory,
            TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaCategories"),
            DeviceRegKey);
    }
    return NOERROR;
}


STDMETHODIMP
GetPinFactoryInstances(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    PKSPIN_CINSTANCES Instances
    )
/*++

Routine Description:

    Retrieves the pin instance count of the specified Pin Factory Id.

Arguments:

    FilterHandle -
        The handle to this filter.

    PinFactoryId -
        The Pin Factory Id to query.

    Instance -
        The place in which to put the instance information.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_CINSTANCES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    return KsSynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        Instances,
        sizeof(*Instances),
        &BytesReturned);
}


STDMETHODIMP
SetSyncSource(
    HANDLE PinHandle,
    HANDLE ClockHandle
    )
/*++

Routine Description:

    Sets the master clock on the specified pin handle, if that pin handle
    cares about clocks.

Arguments:

    PinHandle -
        The handle to the pin to set the clock on.

    ClockHandle -
        The handle of the clock to use.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    HRESULT     hr;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &ClockHandle,
        sizeof(ClockHandle),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        return NOERROR;
    }
    return hr;
}


STDMETHODIMP_(CAggregateMarshaler*)
FindInterface(
    CMarshalerList* MarshalerList,
    CAggregateMarshaler* FindAggregate
    )
/*++

Routine Description:

    Looks for the specified aggregate on the list.

Arguments:

    MarshalerList -
        Points to the list of interfaces to search.

    FindAggregate -
        Contains the aggregate to look for.

Return Value:

    Returns the aggregate entry if found, else NULL.

--*/
{
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler*Aggregate;

        Aggregate = MarshalerList->GetNext(Position);
        //
        // Don't skip static aggregates, since they can override
        // dynamic ones.
        //
        if ((FindAggregate->m_iid == Aggregate->m_iid) &&
            (FindAggregate->m_ClassId == Aggregate->m_ClassId)) {
            return Aggregate;
        }
    }
    return NULL;
}


STDMETHODIMP
AddAggregateObject(
    CMarshalerList* MarshalerList,
    CAggregateMarshaler* Aggregate,
    IUnknown* UnkOuter,
    BOOL Volatile
    )
/*++

Routine Description:

    Looks for the specified aggregate on the list, and if it is not already
    present, adds the object passed, else deletes the object passed.

Arguments:

    MarshalerList -
        Points to the list of interfaces to search, and which to add the
        new item.

    Aggregate -
        Contains the aggregate to look for, and which to add to the list if
        it is unique. This is destroyed if it is not unique.

    UnkOuter -
        The outer IUnknown which is used in the CoCreateInstance if a new
        aggregate is being added.

    Volatile -
        Indicates whether or not this is a volatile interface. This is used
        to initialize the volatile setting of the aggregate object.

Return Value:

    Returns the aggregate entry if found, in which case the
    Reconnected flag is set, else NULL.

--*/
{
    CAggregateMarshaler*    OldAggregate;
    HRESULT                 hr;

    //
    // If the interface is already on the marshaler list, then
    // just set the entry. Else try to make a new instance to
    // place on the list.
    //
    if (OldAggregate = FindInterface(MarshalerList, Aggregate)) {
        //
        // Since the Static interfaces are loaded at the start,
        // a Static interface cannot be a duplicate of a Volatile
        // interface.
        //
        ASSERT(Volatile || (Volatile == OldAggregate->m_Volatile));
        //
        // Any old error code to make the object passed in be deleted.
        //
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        //
        // Since the aggregate is being re-used, then notify it
        // that a reconnection is being performed. This can only
        // be done if IDistributorNotify is supported. If not, then
        // it is assumed that the aggregate does not care about
        // reconnections. Static aggregates are notified during set
        // aggregation. Also, only do the notification once per
        // connection.
        //
        if (OldAggregate->m_Volatile && !OldAggregate->m_Reconnected) {
            //
            // A matching aggregate has been found. Mark it as being
            // in use, so that cleanup will leave this intact. This
            // also means that it has been notified on reconnection.
            //
            OldAggregate->m_Reconnected = TRUE;
            if (OldAggregate->m_DistributorNotify) {
                OldAggregate->m_DistributorNotify->NotifyGraphChange();
            }
        }
    } else {
        hr = CoCreateInstance(Aggregate->m_ClassId,
            UnkOuter,
#ifdef WIN9X_KS
            CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
            __uuidof(IUnknown),
            reinterpret_cast<PVOID*>(&Aggregate->m_Unknown));
    }
    if (SUCCEEDED(hr)) {
        //
        // Query for the generic interface which is used to notify extensions
        // of changes. This does not have to be supported. If not supported,
        // then it just will not be notified.
        //
        if (SUCCEEDED(Aggregate->m_Unknown->QueryInterface(
            __uuidof(IDistributorNotify),
            reinterpret_cast<PVOID*>(&Aggregate->m_DistributorNotify)))) {
            //
            // If the distributor interface was supported, meaning that the
            // interface handler does cares about change notification, the
            // reference count on the object is adjusted so that it is still
            // one.
            //
            Aggregate->m_DistributorNotify->Release();
        }
        //
        // Volatile interfaces are created on pins during a connection,
        // and may go away when the next connection is made.
        //
        Aggregate->m_Volatile = Volatile;
        //
        // Set this if it is a Volatile, else set it to FALSE for a
        // Static interface so that it will be notified on connection.
        //
        Aggregate->m_Reconnected = Volatile;
        MarshalerList->AddTail(Aggregate);
    } else {
        //
        // Either a failure occured, or a duplicate was found and used.
        //
        delete Aggregate;
    }
    return hr;
}


STDMETHODIMP_(VOID)
NotifyStaticAggregates(
    CMarshalerList* MarshalerList
    )
{
    //
    // Notify all Static aggregated interfaces on the list which have
    // not already been notified.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;

        Aggregate = MarshalerList->GetNext(Position);
        if (!Aggregate->m_Volatile && !Aggregate->m_Reconnected && Aggregate->m_DistributorNotify) {
            //
            // Now this item will have been notified, so mark it.
            // This save a little time on disconnect, since the
            // items which have not been marked either did not
            // get notified, or can't be notified. The unload
            // code for Volatiles checks for the Volatile bit, not
            // just the Reconnect bit.
            //
            Aggregate->m_Reconnected = TRUE;
            Aggregate->m_DistributorNotify->NotifyGraphChange();
        }
    }
}


STDMETHODIMP
AggregateMarshalers(
    HKEY RootKey,
    TCHAR* SubKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    )
/*++

Routine Description:

    Enumerates the specified key under the class and aggregates any
    modules which represent an interface. These can be retrieved through
    a normal QueryInterface on the calling object, and can add to the
    normal interfaces provided by that object.

Arguments:

    RootKey -
        Contains the root key on which to append the SubKey. This is normally
        the interface device key.

    SubKey -
        Contains the subkey to query under the root containing the list of
        aggregates.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is appended to with each entry found.

    UnkOuter -
        Contains the outer IUnknown to be passed to the object whose interface
        is to be aggregated.

Return Value:

    Returns NOERROR, else a memory error. Ignores error trying to load
    interfaces.

--*/
{
    LONG        Result;
    HKEY        ClassRegistryKey;
    HKEY        InterfacesRegistryKey;

    Result = RegOpenKeyEx(RootKey, SubKey, 0, KEY_READ, &ClassRegistryKey);
    //
    // If the key does not exist, this is OK, as there may be no interfaces
    // to load.
    //
    if (Result != ERROR_SUCCESS) {
        return NOERROR;
    }
    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    //
    // If there is no list of registered media interfaces, then there are
    // no extensions to load, even if an Interfaces subkey exists in the
    // PnP registry subkey.
    //
    if (Result != ERROR_SUCCESS) {
        RegCloseKey(ClassRegistryKey);
        return NOERROR;
    }
    //
    // Enumerate each key as a textual Guid to look up in the MediaInterfaces
    // subkey.
    //
    for (LONG KeyEntry = 0;; KeyEntry++) {
        TCHAR                   GuidString[64];
        ULONG                   ValueSize;
        GUID                    Interface;
        CAggregateMarshaler*    Aggregate;
        HKEY                    ItemRegistryKey;

        Result = RegEnumKey(
            ClassRegistryKey,
            KeyEntry,
            GuidString,
            sizeof(GuidString)/sizeof(TCHAR));
        if (Result != ERROR_SUCCESS) {
            break;
        }
        //
        // Retrieve the Guid representing the COM interface which will
        // represent this entry.
        //
        Result = RegOpenKeyEx(
            InterfacesRegistryKey,
            GuidString,
            0,
            KEY_READ,
            &ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // This guid is not registered.
            //
            continue;
        }
        ValueSize = sizeof(Interface);
        Result = RegQueryValueEx(
            ItemRegistryKey,
            IidNamedValue,
            NULL,
            NULL,
            (PBYTE)&Interface,
            &ValueSize);
        RegCloseKey(ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // Allow the module to expose multiple interfaces.
            //
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (!Aggregate) {
            //
            // Probably ran out of memory.
            //
            break;
        }
        //
        // The class is whatever the original guid is, and the interface
        // presented is whatever the registry specifies, which may be
        // GUID_NULL, meaning that multiple interfaces are exposed.
        //
        Aggregate->m_iid = Interface;
#ifdef _UNICODE
        IIDFromString(GuidString, &Aggregate->m_ClassId);
#else
        WCHAR   UnicodeGuid[64];

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, GuidString, -1, UnicodeGuid, sizeof(UnicodeGuid));
        IIDFromString(UnicodeGuid, &Aggregate->m_ClassId);
#endif
        AddAggregateObject(MarshalerList, Aggregate, UnkOuter, FALSE);
    }
    RegCloseKey(InterfacesRegistryKey);
    RegCloseKey(ClassRegistryKey);
    return NOERROR;
}


STDMETHODIMP
AggregateTopology(
    HKEY RootKey,
    PKSMULTIPLE_ITEM MultipleItem,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    )
/*++

Routine Description:

    Enumerates the topology of the filter, looking up each topology guid as
    an interface to be added to the filter. These can be retrieved through
    a normal QueryInterface on the calling object, and can add to the
    normal interfaces provided by that object.

Arguments:

    RootKey -
        This is not currently used, but may be if indirection is useful.
        Contains the root key on which to append the SubKey. This is normally
        the interface device key.

    MultipleItem -
        Contains the list of topology nodes to aggregate.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is appended to with each entry found.

    UnkOuter -
        Contains the outer IUnknown to be passed to the object whose interface
        is to be aggregated.

Return Value:

    Returns NOERROR, else a memory error. Ignores error trying to load
    interfaces.

--*/
{
    LONG        Result;
    HKEY        InterfacesRegistryKey;

    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    //
    // If there is no list of registered media interfaces, then there are
    // no extensions to load.
    //
    if (Result != ERROR_SUCCESS) {
        return NOERROR;
    }
    //
    // Enumerate each node as a Guid to look up in the MediaInterfaces subkey.
    //
    for (ULONG Node = MultipleItem->Count; Node; Node--) {
        WCHAR                   GuidString[CHARS_IN_GUID];
        ULONG                   ValueSize;
        GUID                    Interface;
        CAggregateMarshaler*    Aggregate;
        HKEY                    ItemRegistryKey;

        StringFromGUID2(
            *(reinterpret_cast<GUID*>(MultipleItem + 1) + Node - 1),
            GuidString,
            CHARS_IN_GUID);
#ifndef _UNICODE
        char    AnsiGuid[64];
        BOOL    DefaultUsed;

        WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif

        //
        // Retrieve the Guid representing the COM interface which will
        // represent this entry.
        //
        Result = RegOpenKeyEx(
            InterfacesRegistryKey,
#ifdef _UNICODE
            GuidString,
#else
            AnsiGuid,
#endif
            0,
            KEY_READ,
            &ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // This guid is not registered.
            //
            continue;
        }
        ValueSize = sizeof(Interface);
        Result = RegQueryValueEx(
            ItemRegistryKey,
            IidNamedValue,
            NULL,
            NULL,
            (PBYTE)&Interface,
            &ValueSize);
        RegCloseKey(ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // Allow the module to expose multiple interfaces.
            //
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (!Aggregate) {
            //
            // Probably ran out of memory.
            //
            break;
        }
        //
        // The class is whatever the original guid is, and the interface
        // presented is whatever the registry specifies, which may be
        // GUID_NULL, meaning that multiple interfaces are exposed.
        //
        Aggregate->m_iid = Interface;
        IIDFromString(GuidString, &Aggregate->m_ClassId);
        AddAggregateObject(MarshalerList, Aggregate, UnkOuter, FALSE);
    }
    RegCloseKey(InterfacesRegistryKey);
    return NOERROR;
}


STDMETHODIMP
CollectAllSets(
    HANDLE ObjectHandle,
    GUID** GuidList,
    ULONG* SetDataSize
    )
/*++

Routine Description:

    Enumerate the Property/Method/Event sets supported by the object, and
    return a list of them.

Arguments:

    ObjectHandle -
        Handle of the object to enumerate the sets on. This would normally
        be a filter or pin.

    GuidList -
        Points to the place in which to place a pointer to a list of guids.
        This only will contain a pointer if SetDataSize is non-zero, else
        it will be set to NULL. This must be freed by the caller.

    SetDataSize -
        Indicates the number of items returned in the GuidList. If this is
        non-zero, GuidList is returned with a pointer to a list which must
        be freed, else no list is returned.

Return Value:

    Returns NOERROR, else a memory error or ERROR_SET_NOT_FOUND.

--*/
{
    HRESULT         hr;
    KSIDENTIFIER    Identifier;
    ULONG           PropertyDataSize;
    ULONG           MethodDataSize;
    ULONG           EventDataSize;
    ULONG           BytesReturned;

    //
    // Always initialize this so that the caller can just use it to determine
    // if the guid list is present.
    //
    *SetDataSize = 0;
    //
    // Query for the list of sets.
    //
    Identifier.Set = GUID_NULL;
    Identifier.Id = 0;
    //
    // This flag is actually the same for property/method/event sets.
    //
#if KSPROPERTY_TYPE_SETSUPPORT != KSMETHOD_TYPE_SETSUPPORT
#error KSPROPERTY_TYPE_SETSUPPORT != KSMETHOD_TYPE_SETSUPPORT
#endif
#if KSPROPERTY_TYPE_SETSUPPORT != KSEVENT_TYPE_SETSUPPORT
#error KSPROPERTY_TYPE_SETSUPPORT != KSEVENT_TYPE_SETSUPPORT
#endif
    Identifier.Flags = KSPROPERTY_TYPE_SETSUPPORT;
    //
    // Query for the size of the data for each set.
    //
    PropertyDataSize = 0;
    KsSynchronousDeviceControl(
        ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Identifier,
        sizeof(Identifier),
        NULL,
        0,
        &PropertyDataSize);
    MethodDataSize = 0;
    KsSynchronousDeviceControl(
        ObjectHandle,
        IOCTL_KS_METHOD,
        &Identifier,
        sizeof(Identifier),
        NULL,
        0,
        &MethodDataSize);
    EventDataSize = 0;
    KsSynchronousDeviceControl(
        ObjectHandle,
        IOCTL_KS_ENABLE_EVENT,
        &Identifier,
        sizeof(Identifier),
        NULL,
        0,
        &EventDataSize);
    if (!(PropertyDataSize + MethodDataSize + EventDataSize)) {
        //
        // There are no property/method/event sets on this object.
        //
        *GuidList = NULL;
        return ERROR_SET_NOT_FOUND;
    }
    //
    // Allocate a buffer and query for the data.
    //
    *GuidList = new GUID[(PropertyDataSize + MethodDataSize + EventDataSize)/sizeof(**GuidList)];
    if (!*GuidList) {
        return E_OUTOFMEMORY;
    }
    if (PropertyDataSize) {
        hr = KsSynchronousDeviceControl(
            ObjectHandle,
            IOCTL_KS_PROPERTY,
            &Identifier,
            sizeof(Identifier),
            *GuidList,
            PropertyDataSize,
            &BytesReturned);
        if (FAILED(hr)) {
            //
            // Just remove the properties part of the list.
            //
            PropertyDataSize = 0;
        }
    }
    if (MethodDataSize) {
        hr = KsSynchronousDeviceControl(
            ObjectHandle,
            IOCTL_KS_METHOD,
            &Identifier,
            sizeof(Identifier),
            *GuidList + PropertyDataSize / sizeof(**GuidList),
            MethodDataSize,
            &BytesReturned);
        if (FAILED(hr)) {
            //
            // Just remove the methods part of the list.
            //
            MethodDataSize = 0;
        }
    }
    if (EventDataSize) {
        hr = KsSynchronousDeviceControl(
            ObjectHandle,
            IOCTL_KS_ENABLE_EVENT,
            &Identifier,
            sizeof(Identifier),
            *GuidList + (PropertyDataSize + MethodDataSize) / sizeof(**GuidList),
            EventDataSize,
            &BytesReturned);
        if (FAILED(hr)) {
            //
            // Just remove the events part of the list.
            //
            EventDataSize = 0;
        }
    }
    PropertyDataSize += (MethodDataSize + EventDataSize);
    if (!PropertyDataSize) {
        //
        // All of the queries done failed. This must be freed here, since a
        // zero length return indicates that there is no list to free.
        //
        delete [] *GuidList;
        *GuidList = NULL;
        return ERROR_SET_NOT_FOUND;
    }
    //
    // This was already initialize to zero, so it only needs to be
    // updated if the result is non-zero. Return the number of items,
    // no the byte size.
    //
    *SetDataSize = PropertyDataSize / sizeof(**GuidList);
    return NOERROR;
}


STDMETHODIMP_(VOID)
ResetInterfaces(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Resets the Reconnected flag in all entries, and notifies all the
    interface. This allows a Reconnect on a pin to keep volatile
    interfaces present while doing the reconnect, and only remove such
    interfaces which are no longer represented by a Set on the
    underlying object.

Arguments:

    MarshalerList -
        Points to the list of interfaces which are to be reset.

Return Value:

    Nothing.

--*/
{
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;

        Aggregate = MarshalerList->GetNext(Position);
        //
        // If this interface has been reconnected, let it know
        // that the pin is now disconnected. This is always set
        // for Static interfaces. This might not be set if a
        // connection failed.
        //
        if (Aggregate->m_Reconnected) {
            //
            // Volatile interfaces will be unloaded if they are not
            // reconnected. Static interfaces will stay loaded, and
            // be notified in the cleanup.
            //
            Aggregate->m_Reconnected = FALSE;
            //
            // If the item has a distributor interface, let it know
            // that the pin is disconnected.
            //
            if (Aggregate->m_DistributorNotify) {
                Aggregate->m_DistributorNotify->NotifyGraphChange();
            }
        }
    }
}


STDMETHODIMP
AggregateSets(
    HANDLE ObjectHandle,
    HKEY DeviceRegKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    )
/*++

Routine Description:

    Enumerate the Property/Method/Event sets supported by the object and
    add an interface for each which is actually registered to have an
    interface representation. These can be retrieved through a normal
    QueryInterface on the calling object, and can add to the normal
    interfaces provided by that object.

Arguments:

    ObjectHandle -
        Handle of the object to enumerate the sets on. This would normally
        be a filter or pin.

    DeviceRegKey -
        The handle to the device registry storage location.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is appended to with each entry found.

    UnkOuter -
        Contains the outer IUnknown to be passed to the object whose interface
        is to be aggregated.

Return Value:

    Returns NOERROR.

--*/
{
    ULONG       SetDataSize;
    GUID*       GuidList;
    LONG        Result;
    HKEY        InterfacesRegistryKey;
    HKEY        AliasKey;

    //
    // Notify static aggregates of the connection.
    //
    NotifyStaticAggregates(MarshalerList);
    CollectAllSets(ObjectHandle, &GuidList, &SetDataSize);
    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    if ((Result != ERROR_SUCCESS) || !GuidList) {
        //
        // There are no interface handlers registered, therefore none
        // will be aggregated.
        //
        if (GuidList) {
            delete [] GuidList;
        }
        if (Result == ERROR_SUCCESS) {
            RegCloseKey(InterfacesRegistryKey);
        }
        //
        // Remove any volatile interfaces which have been reset.
        // They were reset on the previous BreakConnect.
        //
        UnloadVolatileInterfaces(MarshalerList, FALSE);
        return NOERROR;
    }
    //
    // Open the Set Aliases key if it exists in order to translate any
    // guids to private ones in case an alternate COM server is to be
    // used for a particular Set being aggregated.
    //
    if (RegOpenKeyEx(DeviceRegKey, TEXT("SetAliases"), 0, KEY_READ, &AliasKey) != ERROR_SUCCESS) {
        AliasKey = NULL;
    }
    for (; SetDataSize--;) {
        WCHAR                   GuidString[CHARS_IN_GUID];
        ULONG                   ValueSize;
        GUID                    Interface;
        CAggregateMarshaler*    Aggregate;
        HKEY                    ItemRegistryKey;

        StringFromGUID2(GuidList[SetDataSize], GuidString, CHARS_IN_GUID);
#ifndef _UNICODE
        char    AnsiGuid[64];
        BOOL    DefaultUsed;

        WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif
        if (AliasKey) {
            //
            // Check in the device registry key if there is an alias for
            // this Set guid that should be used with any object on this
            // filter. This allows a filter to override standard Set
            // COM servers, in order to provide their own interfaces.
            //
            ValueSize = sizeof(Interface);
            Result = RegQueryValueEx(
                AliasKey,
#ifdef _UNICODE
                GuidString,
#else
                AnsiGuid,
#endif
                NULL,
                NULL,
                (PBYTE)&Interface,
                &ValueSize);
            //
            // If this named value exists, use it. Release the old guid
            // and update the guid list, since this new guid will be
            // treated just like the guid for the Set.
            //
            if (Result == ERROR_SUCCESS) {
                GuidList[SetDataSize] = Interface;
                StringFromGUID2(GuidList[SetDataSize], GuidString, CHARS_IN_GUID);
#ifndef _UNICODE
                WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif
            }
        }
        //
        // Retrieve the Guid representing the COM interface which will
        // represent this set.
        //
        Result = RegOpenKeyEx(
            InterfacesRegistryKey,
#ifdef _UNICODE
            GuidString,
#else
            AnsiGuid,
#endif
            0,
            KEY_READ,
            &ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // This interface is not supposed to be aggregated.
            //
            continue;
        }
        ValueSize = sizeof(Interface);
        Result = RegQueryValueEx(
            ItemRegistryKey,
            IidNamedValue,
            NULL,
            NULL,
            (PBYTE)&Interface,
            &ValueSize);
        RegCloseKey(ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // Allow the module to expose multiple interfaces.
            //
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (!Aggregate) {
            //
            // Probably ran out of memory.
            //
            break;
        }
        //
        // The class is whatever the Set guid is, and the interface presented
        // is whatever the registry specifies, which may be different than the
        // guid for the Set, or may be GUID_NULL, meaning that multiple
        // interfaces are exposed.
        //
        Aggregate->m_iid = Interface;
        Aggregate->m_ClassId = GuidList[SetDataSize];
        AddAggregateObject(MarshalerList, Aggregate, UnkOuter, TRUE);
    }
    RegCloseKey(InterfacesRegistryKey);
    //
    // If this exists, then close it.
    //
    if (AliasKey) {
        RegCloseKey(AliasKey);
    }
    delete [] GuidList;
    //
    // Remove any volatile interfaces which have been reset.
    // They were reset on the previous BreakConnect.
    //
    UnloadVolatileInterfaces(MarshalerList, FALSE);
    return NOERROR;
}


STDMETHODIMP_(VOID)
FreeMarshalers(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Frees a previously Marshaled list of aggregated interfaces. Assumes that the
    calling object has protected itself against re-entrancy when the Marshaled
    interfaces release their reference count on the parent.

Arguments:

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is freed.

Return Value:

    Nothing.

--*/
{
    //
    // Release and destroy all the aggregations on the object.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler*Aggregate;
        POSITION            PrevPosition;

        PrevPosition = Position;
        Aggregate = MarshalerList->GetNext(Position);
        MarshalerList->Remove(PrevPosition);
        Aggregate->m_Unknown->Release();
        delete Aggregate;
    }
}


STDMETHODIMP_(VOID)
UnloadVolatileInterfaces(
    CMarshalerList* MarshalerList,
    BOOL ForceUnload
    )
/*++

Routine Description:

    Frees the volatile entries on the previously Marshaled list of aggregated
    interfaces. Since aggregated interfaces should never keep any reference
    count on a parent, the reference count is not protected.

Arguments:

    MarshalerList -
        Points to the list of interfaces which the calling object has aggregated.
        This list from which volatile members are removed.

    ForceUnload -
        Forces the interface to be unloaded even if the Reconnected flag is set.

Return Value:

    Nothing.

--*/
{
    //
    // Release and destroy the volatile aggregations on the object.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;
        POSITION PrevPosition;

        PrevPosition = Position;
        Aggregate = MarshalerList->GetNext(Position);
        //
        // Only unload volatile interfaces which have been reset. During
        // a Reconnect in SetFormat, the interfaces will not be reloaded.
        //
        if (Aggregate->m_Volatile && (ForceUnload || !Aggregate->m_Reconnected)) {
            MarshalerList->Remove(PrevPosition);
            Aggregate->m_Unknown->Release();
            delete Aggregate;
        }
    }
}


STDMETHODIMP_(VOID)
FollowFromTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    )
/*++

Routine Description:

    Follows a ToNode of a given connection to another FromNode, going with the
    data flow of the connections. If an actual Pin Factory is encountered as
    the destination of a connection, and it is not the originating Pin Factory,
    the related Pin Factory reference array element is incremented to show that
    a specific Pin Factory is actually related through connections to the
    original Pin Factory.

Arguments:

    Connection -
        Contains the list of topology connections.

    Count -
        Contains the count of Connection elements.

    PinFactoryId -
        The originaing Pin Factory Identifier. This is used to ensure that a
        connection ending at the original Pin Factory is not counted, and
        thus returned in the internal connections array.

    ConnectionBranch -
        The current connection being traced. If this is an end point (ToNode
        contains KSFILTER_NODE rather than a node identifier), then the
        PinFactoryIdList is updated. Else the connection path is followed by
        recursively calling this function with each connection that contains
        the new node identifier.

    PinFactoryIdList -
        Contains the list of slots, one for each Pin Factory Identifier, which
        is incremented on finding a related Pin Factory. This can then be
        used to locate all pin instances of related Pin Factories.

Return Value:

    Nothing.

--*/
{
    //
    // If this is an end point in a connection path, then determine if it
    // ended up at the starting point. If not, then count this as a new
    // Pin Factory whose instances are to be added to the related pins.
    //
    if (ConnectionBranch->ToNode == KSFILTER_NODE) {
        if (ConnectionBranch->ToNodePin != PinFactoryId) {
            //
            // This just needs to be non-zero to count.
            //
            PinFactoryIdList[ConnectionBranch->ToNodePin]++;
        }
    } else {
        //
        // This is not an end point, so the path must be followed to the
        // next connection point. To ensure that a circular connection
        // path does not recurse forever, make sure that the FromNode and
        // FromNodePin are modified. Changing the FromNode to KSFILTER_NODE
        // ensures that the comparison below will never succeed, since the
        // ToNode compared to will never be KSFILTER_NODE. Changing the
        // FromNodePin to -1 ensures that the comparison in
        // CKsProxy::QueryInternalConnections never succeeds, and it does
        // not call this function with connection paths which have already
        // been traced.
        //
        ConnectionBranch->FromNode = KSFILTER_NODE;
        ConnectionBranch->FromNodePin = static_cast<ULONG>(-1);
        for (ULONG ConnectionItem = 0; ConnectionItem < Count; ConnectionItem++) {
            //
            // Only new connection points not already recursed into will be
            // found by this comparison.
            //
            if (ConnectionBranch->ToNode == Connection[ConnectionItem].FromNode) {
                FollowFromTopology(Connection, Count, PinFactoryId, &Connection[ConnectionItem], PinFactoryIdList);
            }
        }
    }
}


STDMETHODIMP_(VOID)
FollowToTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    )
/*++

Routine Description:

    Follows a ToNode of a given connection to another FromNode, going against the
    data flow of the connections. If an actual Pin Factory is encountered as
    the destination of a connection, and it is not the originating Pin Factory,
    the related Pin Factory reference array element is incremented to show that
    a specific Pin Factory is actually related through connections to the
    original Pin Factory.

Arguments:

    Connection -
        Contains the list of topology connections.

    Count -
        Contains the count of Connection elements.

    PinFactoryId -
        The originaing Pin Factory Identifier. This is used to ensure that a
        connection ending at the original Pin Factory is not counted, and
        thus returned in the internal connections array.

    ConnectionBranch -
        The current connection being traced. If this is an end point (ToNode
        contains KSFILTER_NODE rather than a node identifier), then the
        PinFactoryIdList is updated. Else the connection path is followed by
        recursively calling this function with each connection that contains
        the new node identifier.

    PinFactoryIdList -
        Contains the list of slots, one for each Pin Factory Identifier, which
        is incremented on finding a related Pin Factory. This can then be
        used to locate all pin instances of related Pin Factories.

Return Value:

    Nothing.

--*/
{
    //
    // If this is an end point in a connection path, then determine if it
    // ended up at the starting point. If not, then count this as a new
    // Pin Factory whose instances are to be added to the related pins.
    //
    if (ConnectionBranch->FromNode == KSFILTER_NODE) {
        if (ConnectionBranch->FromNodePin != PinFactoryId) {
            //
            // This just needs to be non-zero to count.
            //
            PinFactoryIdList[ConnectionBranch->FromNodePin]++;
        }
    } else {
        //
        // This is not an end point, so the path must be followed to the
        // next connection point. To ensure that a circular connection
        // path does not recurse forever, make sure that the ToNode and
        // ToNodePin are modified. Changing the ToNode to KSFILTER_NODE
        // ensures that the comparison below will never succeed, since the
        // FromNode compared to will never be KSFILTER_NODE. Changing the
        // ToNodePin to -1 ensures that the comparison in
        // CKsProxy::QueryInternalConnections never succeeds, and it does
        // not call this function with connection paths which have already
        // been traced.
        //
        ConnectionBranch->ToNode = KSFILTER_NODE;
        ConnectionBranch->ToNodePin = static_cast<ULONG>(-1);
        for (ULONG ConnectionItem = 0; ConnectionItem < Count; ConnectionItem++) {
            //
            // Only new connection points not already recursed into will be
            // found by this comparison.
            //
            if (ConnectionBranch->FromNode == Connection[ConnectionItem].ToNode) {
                FollowToTopology(Connection, Count, PinFactoryId, &Connection[ConnectionItem], PinFactoryIdList);
            }
        }
    }
}


STDMETHODIMP_(BOOL)
IsAcquireOrderingSignificant(
    HANDLE PinHandle
    )
/*++

Routine Description:

    Queries the pin handle to determine if transition from Stop to Acquire
    state ordering is significant. If the property is not supported, or if
    the value returned is FALSE, the the ordering is not significant. Only
    a return of TRUE in the AcquireOrdering buffer implies significance.

Arguments:

    PinHandle -
        Contains the handle of the pin to query.

Return Value:

    Returns TRUE if Acquire state change ordering is significant to this
    pin, and therefore must be propagated to the connected filter first.

--*/
{
    KSPROPERTY  Property;
    HRESULT     hr;
    BOOL        AcquireOrdering;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ACQUIREORDERING;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &AcquireOrdering,
        sizeof(AcquireOrdering),
        &BytesReturned);
    if (SUCCEEDED(hr) && AcquireOrdering) {
        return TRUE;
    }
    return FALSE;
}


STDMETHODIMP
QueryAccept(
    IN HANDLE PinHandle,
    IN const AM_MEDIA_TYPE* ConfigAmMediaType OPTIONAL,
    IN const AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Implement the CBasePin::QueryAccept method. Determines if the proposed
    media type is currently acceptable to the pin. If currently streaming,
    this implies that a change of media types will occur in the stream.
    Note that this function does not lock the object, as it is expected
    to be called asynchronously by a knowledgeable client at a point in
    which the connection will not be broken. If IAMStreamConfig::SetFormat
    has been used to set a specific media type, then QueryAccept will only
    accept the type set.

Arguments:

    PinHandle -
        Contains the handle of the pin to query.

    ConfigAmMediaType -
        Optionally contains a media type set using IAMStreamConfig::SetFormat.
        If this is set, the filter is not even queried, and a direct comparison
        is performed instead.

    AmMediaType -
        The media type to check.

Return Value:

    Returns S_OK if the media type can currently be accepted, else S_FALSE.

--*/
{
    PKSDATAFORMAT   DataFormat;
    KSPROPERTY      Property;
    HRESULT         hr;
    ULONG           BytesReturned;
    ULONG           FormatSize;

    //
    // If a media type has been set via IAMStreamConfig::SetFormat, then only
    // that type is acceptable.
    //
    if (ConfigAmMediaType) {
        return (reinterpret_cast<const CMediaType*>(AmMediaType) == reinterpret_cast<const CMediaType*>(ConfigAmMediaType)) ? S_OK : S_FALSE;
    }
    hr = InitializeDataFormat(
        reinterpret_cast<const CMediaType*>(AmMediaType),
        0,
        reinterpret_cast<void**>(&DataFormat),
        &FormatSize);
    if (FAILED(hr)) {
        //
        // The function is only supposed to return either S_OK or S_FALSE,
        // no matter what the error really is.
        //
        return S_FALSE;
    }
    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        DataFormat,
        FormatSize,
        &BytesReturned);
    CoTaskMemFree(DataFormat);
    if (FAILED(hr)) {
        return S_FALSE;
    }
    return S_OK;
}


STDMETHODIMP_(VOID)
DistributeSetSyncSource(
    CMarshalerList* MarshalerList,
    IReferenceClock* RefClock
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new sync source. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

    RefClock -
        The new reference clock.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->SetSyncSource(RefClock);
        }
    }
}


STDMETHODIMP_(VOID)
DistributeStop(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new state. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->Stop();
        }
    }
}


STDMETHODIMP_(VOID)
DistributePause(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new state. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->Pause();
        }
    }
}


STDMETHODIMP_(VOID)
DistributeRun(
    CMarshalerList* MarshalerList,
    REFERENCE_TIME Start
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new state. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->Run(Start);
        }
    }
}


STDMETHODIMP_(VOID)
DistributeNotifyGraphChange(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    graph change. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->NotifyGraphChange();
        }
    }
}


STDMETHODIMP
AddAggregate(
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter,
    IN REFGUID AggregateClass
    )
/*++

Routine Description:

    This is used to load a COM server with zero or more interfaces to aggregate
    on the object.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to add to.

    UnkOuter -
        The outer IUnknown which is used in the CoCreateInstance if a new
        aggregate is being added.

    AggregateClass -
        Contains the Aggregate reference to translate into a COM server which
        is to be aggregated on the object.

Return Value:

    Returns S_OK if the interface was added.

--*/
{
    LONG Result;
    HRESULT hr;
    HKEY InterfacesRegistryKey;
    WCHAR GuidString[CHARS_IN_GUID];

    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    //
    // If the location of the registered interfaces cannot be opened, it is
    // still OK to try and load the interface, as it just may not be
    // registered.
    //
    if (Result != ERROR_SUCCESS) {
        InterfacesRegistryKey = NULL;
    }
    //
    // Make the aggregate class a string so that it can be used as part of
    // a key name.
    //
    StringFromGUID2(AggregateClass, GuidString, CHARS_IN_GUID);
    {
        HKEY ItemRegistryKey;
        GUID    Interface;
        CAggregateMarshaler* Aggregate;

#ifndef _UNICODE
        char    AnsiGuid[64];
        BOOL    DefaultUsed;

        WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif
        //
        // If the parent key was opened, try this child key.
        //
        if (Result == ERROR_SUCCESS) {
            //
            // Retrieve the Guid representing the COM interface which will
            // represent this entry.
            //
            Result = RegOpenKeyEx(
                InterfacesRegistryKey,
#ifdef _UNICODE
                GuidString,
#else
                AnsiGuid,
#endif
                0,
                KEY_READ,
                &ItemRegistryKey);
            //
            // This does not really have to succeed, since the client is explicitly
            // loading the handler. It does allow the client to indicate specific
            // interface support though.
            //
            if (Result == ERROR_SUCCESS) {
                ULONG ValueSize;

                ValueSize = sizeof(Interface);
                Result = RegQueryValueEx(
                    ItemRegistryKey,
                    IidNamedValue,
                    NULL,
                    NULL,
                    (PBYTE)&Interface,
                    &ValueSize);
                RegCloseKey(ItemRegistryKey);
            }
        }
        //
        // If there is no MediaInterfaces entry, or no named value under
        // the key, then allow the module to expose multiple interfaces.
        //
        if (Result != ERROR_SUCCESS) {
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (Aggregate) {
            //
            // The class is whatever the original guid is, and the interface
            // presented is whatever the registry specifies, which may be
            // GUID_NULL, meaning that multiple interfaces are exposed.
            //
            Aggregate->m_iid = Interface;
            Aggregate->m_ClassId = AggregateClass;
            hr = AddAggregateObject(MarshalerList, Aggregate, UnkOuter, FALSE);
        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    //
    // This key may not exist, and so was not opened.
    //
    if (InterfacesRegistryKey) {
        RegCloseKey(InterfacesRegistryKey);
    }
    return hr;
}


STDMETHODIMP
RemoveAggregate(
    CMarshalerList* MarshalerList,
    IN REFGUID AggregateClass
    )
/*++

Routine Description:

    This is used to unload a previously loaded COM server which is aggregating
    interfaces.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to search.

    AggregateClass -
        Contains the Aggregate reference to look up and unload.

Return Value:

    Returns S_OK if the interface was removed.

--*/
{
    //
    // Find the aggregate specified.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;
        POSITION PrevPosition;

        PrevPosition = Position;
        Aggregate = MarshalerList->GetNext(Position);

        //
        // If the class identifier matches, unload the interface.
        //
        if (Aggregate->m_ClassId == AggregateClass) {
            MarshalerList->Remove(PrevPosition);
            Aggregate->m_Unknown->Release();
            delete Aggregate;
            return S_OK;
        }
    }
    return HRESULT_FROM_WIN32(ERROR_NO_MATCH);
}


STDMETHODIMP
GetDegradationStrategies(
    HANDLE PinHandle,
    PVOID* Items
    )
/*++

Routine Description:

    Retrieves the variable length degradation strategies data from a pin.
    Queries for the data size, allocates a buffer, and retrieves the data.

Arguments:

    PinHandle -
        The handle of the pin to query.

    Items -
        The place in which to put the buffer containing the data items. This
        must be deleted as an array.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_DEGRADATION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // Query for the size of the degradation strategies.
    //
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        NULL,
        0,
        &BytesReturned);
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the degradation strategies.
        //
        *Items = reinterpret_cast<PVOID>(new BYTE[BytesReturned]);
        if (!*Items) {
            return E_OUTOFMEMORY;
        }
        hr = KsSynchronousDeviceControl(
            PinHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            *Items,
            BytesReturned,
            &BytesReturned);
        if (FAILED(hr)) {
            delete [] reinterpret_cast<BYTE*>(*Items);
        }
    }
    return hr;
}


STDMETHODIMP_(BOOL)
VerifyQualitySupport(
    HANDLE PinHandle
    )
/*++

Routine Description:

    This is used by output pins to verify that relevant degradation
    strategies are supported by this pin.

Arguments:

    PinHandle -
        The handle of the pin to query.

Return Value:

    Returns TRUE if any relevant degradation strategy is supported, else
    FALSE.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem = NULL;
    PKSDEGRADE          DegradeList;
    BOOL                SupportsQuality;

    //
    // Retrieve the list of degradation strategies.
    //
    if (FAILED(GetDegradationStrategies(PinHandle, reinterpret_cast<PVOID*>(&MultipleItem)))) {
        return FALSE;
    }

    /* NULL == MultipleItem is a pathological case where a driver returns
       a success code in KsSynchronousDeviceControl() (in GetDegradationStrategies())
       when passed a size 0 buffer.  We'll just do with an assert since we're in ring 3. */
    ASSERT( NULL != MultipleItem );

    //
    // Enumerate the list of degradation strategies supported, looking for
    // any standard method.
    //
    DegradeList = reinterpret_cast<PKSDEGRADE>(MultipleItem + 1);
    for (SupportsQuality = FALSE; MultipleItem->Count--; DegradeList++) {
        if (DegradeList->Set == KSDEGRADESETID_Standard) {
            SupportsQuality = TRUE;
            break;
        }
    }
    delete [] reinterpret_cast<BYTE*>(MultipleItem);
    return SupportsQuality;
}


STDMETHODIMP_(BOOL)
EstablishQualitySupport(
    IKsPin* Pin,
    HANDLE PinHandle,
    CKsProxy* Filter
    )
/*++

Routine Description:

    This is used by input pins to establish the quality management sink
    for the kernel mode pin via the user mode quality manager forwarder.
    If the filter has been able to locate the user mode forwarder, then
    the handle to the kernel mode quality manager proxy is retrieved and
    passed to the pin.

    This is also used to remove any previously set Quality Manager on a
    pin. Passing a NULL Filter parameter removes any previous setting.

Arguments:

    Pin -
        The user mode pin which represents the kernel mode pin. This is
        used as context for quality management reports generated by the
        kernel mode pin. This can then be used to send such reports
        back to this originating pin, or used in centralized quality
        management. This should be NULL if Filter is NULL.

    PinHandle -
        The handle of the pin to set the quality manager to.

    Filter -
        The filter on which this pin resides. The filter is queried for
        the user mode quality manager forwarder. This may be set to NULL
        in order to remove any previously established quality support.

Return Value:

    Returns TRUE if the handle to the kernel mode quality manager proxy
    was set on the pin, else FALSE if there is not quality manager, or
    the kernel mode pin does not care about quality management notification.

--*/
{
    IKsQualityForwarder*QualityForwarder;
    KSPROPERTY          Property;
    KSQUALITY_MANAGER   QualityManager;
    ULONG               BytesReturned;
    HRESULT             hr;

    //
    // Determine if a user mode quality forwarder was found. If there is
    // not one present, then quality management cannot be performed on
    // the kernel filters. If this parameter is NULL, then any previous
    // quality manager is being removed.
    //
    if (Filter) {
        QualityForwarder = Filter->QueryQualityForwarder();
        if (!QualityForwarder) {
            return FALSE;
        }
    }
    //
    // Set the quality manager sink on the pin, which comes from the
    // user mode version previously opened. The context for the
    // complaints is the IKsPin interface, which the user mode quality
    // manager uses to forward complaints back to the pin, or to a
    // central quality manager.
    //
    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_QUALITY;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // If the Filter paramter is NULL, then any previous quality manager
    // is being removed. Else the handle to the kernel mode proxy is to
    // be sent.
    //
    if (Filter) {
        QualityManager.QualityManager = QualityForwarder->KsGetObjectHandle();
    } else {
        QualityManager.QualityManager = NULL;
    }
    QualityManager.Context = reinterpret_cast<PVOID>(Pin);
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &QualityManager,
        sizeof(QualityManager),
        &BytesReturned);
    return SUCCEEDED(hr);
}


STDMETHODIMP_(PKSDEGRADE)
FindDegradeItem(
    PKSMULTIPLE_ITEM MultipleItem,
    ULONG DegradeItem
    )
/*++

Routine Description:

    Given a list of degradation items, locates the specified item belonging
    to the standard degradation set.

Arguments:

    MultipleItem -
        Points to the head of a multiple item list, which contains the
        list of degradation strategies to search.

    DegradeItem -
        The item within the standard degradation set to search for.

Return Value:

    Returns a pointer to the degradation item, or NULL if not found.

--*/
{
    PKSDEGRADE  DegradeList;
    ULONG       Count;

    DegradeList = reinterpret_cast<PKSDEGRADE>(MultipleItem + 1);
    for (Count = MultipleItem->Count; Count--; DegradeList++) {
        if ((DegradeList->Set == KSDEGRADESETID_Standard) && (DegradeList->Id == DegradeItem)) {
            return DegradeList;
        }
    }
    return NULL;
}


STDMETHODIMP
GetAllocatorFraming(
    IN  HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING Framing
    )

/*++

Routine Description:
    Retrieves the allocator framing structure from the given pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    PKSALLOCATOR_FRAMING Framing -
        pointer to allocator framing structure

Return:
    converted WIN32 error or S_OK

--*/

{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Framing,
        sizeof(*Framing),
        &BytesReturned );

    return hr;
}


STDMETHODIMP
GetAllocatorFramingEx(
    IN HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx
    )

/*++

Routine Description:
    Queries the driver, allocates and retrieves the new
    allocator framing structure from the given pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    PKSALLOCATOR_FRAMING_EX FramingEx -
        pointer to pointer to allocator framing structure

Return:
    converted WIN32 error or S_OK

--*/

{
    HRESULT                  hr;
    KSPROPERTY               Property;
    ULONG                    BytesReturned;


    if ( ! ( (*FramingEx) = new (KSALLOCATOR_FRAMING_EX) ) ) {
        return E_OUTOFMEMORY;
    }

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX;
    Property.Flags = KSPROPERTY_TYPE_GET;

    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        *FramingEx,
        sizeof(KSALLOCATOR_FRAMING_EX),
        &BytesReturned );

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        delete (*FramingEx);
        (*FramingEx) = reinterpret_cast<PKSALLOCATOR_FRAMING_EX>(new BYTE[ BytesReturned ]);
        if (! (*FramingEx) ) {
            return E_OUTOFMEMORY;
        }

        hr = KsSynchronousDeviceControl(
            PinHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            *FramingEx,
            BytesReturned,
            &BytesReturned );
    }

    if (! SUCCEEDED( hr )) {
        delete (*FramingEx);
        *FramingEx = NULL;
    }

    return hr;
}


STDMETHODIMP_(HANDLE)
GetObjectHandle(
    IUnknown *Object
    )
/*++

Routine Description:
    Using the IKsObject interface, this function returns the object
    handle of the given object or NULL if the interface is not supported.

Arguments:
    PUNKNOWN *Object -
        Pointer to interface w/ IUnknown.

Return:
    Handle of object or NULL.

--*/
{
    IKsObject   *KsObject;
    HANDLE      ObjectHandle;
    HRESULT     hr;

    hr = Object->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&KsObject));
    if (SUCCEEDED(hr)) {
        ObjectHandle = KsObject->KsGetObjectHandle();
        KsObject->Release();
        return ObjectHandle;
    }

    return NULL;
}


STDMETHODIMP
IsAllocatorCompatible(
    HANDLE PinHandle,
    HANDLE DownstreamInputHandle,
    IMemAllocator *MemAllocator
    )

/*++

Routine Description:

    Determines if the current allocator is compatible with this pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    HANDLE DownstreamInputHandle -
        handle of connected input pin

    IMemAllocator *MemAllocator -
        pointer to current allocator interface

Return:
    S_OK or an appropriate failure code

--*/

{
    IKsAllocatorEx      *KsAllocator;
    BOOL                Requirements;
    HRESULT             hr;
    KSALLOCATOR_FRAMING RequiredFraming;

    if (NULL != PinHandle) {
        hr =
            GetAllocatorFraming( PinHandle, &RequiredFraming );
    } else {
        hr = E_FAIL;
    }

    Requirements =
         SUCCEEDED( hr ) &&
         (0 == (RequiredFraming.RequirementsFlags &
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY));

    //
    // Query current allocator for the IKsAllocatorEx interface
    //

    hr =
        MemAllocator->QueryInterface(
            __uuidof(IKsAllocatorEx),
            reinterpret_cast<PVOID*>(&KsAllocator) );

    if (FAILED( hr )) {

        DbgLog((
            LOG_TRACE,
            2,
            TEXT("::IsAllocatorCompatible, user-mode allocator")));


        //
        // Assuming that this allocator is a user-mode allocator.
        //

        //
        // If the pin doesn't care about memory requirements, then the
        // current allocator is OK but we'll still reflect our preferences
        // for allocation sizes in DecideBufferSize().
        //

        if (Requirements) {

            //
            // If the pin does not accept host memory or if it specifies
            // that it must be an allocator, then fail immediately.
            //
            if ((0 == (RequiredFraming.RequirementsFlags &
                    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY)) ||
                (RequiredFraming.RequirementsFlags &
                     KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE)) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, must allocate || !system_memory")));

                return E_FAIL;
            }

            //
            // Remaining issues for UM allocator hook up...
            //
            // KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER
            //    e.g. ReadOnly must == TRUE, but only ReadOnly for an
            //     allocator is set on NotifyAllocator
            // KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY
            //    passed on as ReadOnly=FALSE during NotifyAllocator
            //

        }

        return S_OK;

    } else {

        //
        // Allocator is either pure kernel-mode or is a user-mode
        // implementation for compatibility.
        //

        KSALLOCATOR_FRAMING InputFraming;

        DbgLog((
            LOG_TRACE,
            2,
            TEXT("::IsAllocatorCompatible, IKsAllocatorEx found: mode = %s"),
            (KsAllocator->KsGetAllocatorMode() == KsAllocatorMode_User) ?
                TEXT("user") : TEXT("kernel") ));

        //
        // Assume that the allocator is acceptable
        //

        hr = S_OK;

        //
        // If there is nothing specified for the input connection
        // or if there are no allocator preferences specified, assume
        // that the pin is an in-place modifier.
        //

        RtlZeroMemory( &InputFraming, sizeof( InputFraming ) );
        if (!DownstreamInputHandle ||
             FAILED( GetAllocatorFraming(
                        DownstreamInputHandle,
                        &InputFraming ) )) {

            InputFraming.RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER;
        }

        //
        // If the connection is to a user-mode filter and if this
        // allocator is kernel-mode, then we must reject this allocator.
        //

        if (!DownstreamInputHandle &&
            (KsAllocator->KsGetAllocatorMode() == KsAllocatorMode_Kernel)) {

            DbgLog((
                LOG_TRACE,
                2,
                TEXT("::IsAllocatorCompatible, no input handle and allocator is kernel-mode")));

            hr = E_FAIL;
        }

        if (Requirements) {

            //
            // If this pin must be an allocator, so be it.
            //

            if (RequiredFraming.RequirementsFlags &
                    KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, must be allocator")));

                hr = E_FAIL;
            }

            //
            // If this pin requires the frame to remain in tact
            // and if the downstream allocator modifies data in place
            // then reject the allocator.
            //

            if ((RequiredFraming.RequirementsFlags &
                 KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY) &&
                 (InputFraming.RequirementsFlags &
                 KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER)) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, req. frame integrity but modifier")));

                hr = E_FAIL;
            }

            //
            // If the kernel mode allocator requires device memory
            // and this allocator is set up to be a user-mode
            // implementation, then reject the allocator.
            //

            if ((0 ==
                    (RequiredFraming.RequirementsFlags &
                     KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY)) &&
                (KsAllocator->KsGetAllocatorMode() ==
                    KsAllocatorMode_User)) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, req. !system_memory and alloctor is user-mode")));

                hr = E_FAIL;
            }

            //
            // For all other conditions, the allocator is acceptable.
            //
        }
        KsAllocator->Release();

        return hr;
    }
}


STDMETHODIMP_(VOID)
OpenDataHandler(
    IN const CMediaType* MediaType,
    IN IUnknown* UnkOuter,
    OUT IKsDataTypeHandler** DataTypeHandler,
    OUT IUnknown** UnkInner
    )
/*++

Routine Description:

    Attempts to open a data type handler based on the media type passed.
    Returns both the unreferenced data type handler interface, and the
    inner IUnknown of the object.

Arguments:

    MediaType -
        The media type to use in loading the data type handler.

    UnkOuter -
        Contains the outer IUnknown to pass to the CoCreateInstance.

    DataTypeHandler -
        The place in which to return the data type handler interface.
        This has no reference count on it. This must not be dereferenced.
        This will be set to NULL on failure.

    UnkInner -
        The place in which to return the referenced inner IUnknown of
        the object. This is the interface which must be dereferenced in
        order to discard the object. This will be set to NULL on failure.

Return:

    Nothing.

--*/
{
    *DataTypeHandler = NULL;
    *UnkInner = NULL;
    //
    // First try the FormatType of the media type.
    //
    CoCreateInstance(
        *MediaType->FormatType(),
        UnkOuter,
#ifdef WIN9X_KS
        CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
        __uuidof(IUnknown),
        reinterpret_cast<PVOID*>(UnkInner));
    if (!*UnkInner) {
        //
        // Fallback to the sub type.
        //
        CoCreateInstance(
            *MediaType->Subtype(),
            UnkOuter,
#ifdef WIN9X_KS
            CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
            __uuidof(IUnknown),
            reinterpret_cast<PVOID*>(UnkInner));
    }
    if (!*UnkInner) {
        //
        // Fallback to the major type.
        //
        CoCreateInstance(
            *MediaType->Type(),
            UnkOuter,
#ifdef WIN9X_KS
            CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
            __uuidof(IUnknown),
            reinterpret_cast<PVOID*>(UnkInner));
    }
    //
    // If the inner IUnknown has been retrieved, get the interface
    // of interest.
    //
    if (*UnkInner) {
        (*UnkInner)->QueryInterface(
            __uuidof(IKsDataTypeHandler),
            reinterpret_cast<PVOID*>(DataTypeHandler));
        if (*DataTypeHandler) {
            //
            // Do not keep a reference count on this interface so that
            // it will not block unloading of the owner object. Only
            // the inner IUnknown will have a reference count.
            //
            (*DataTypeHandler)->Release();
            //
            // Set the media type on the handler.
            //
            (*DataTypeHandler)->KsSetMediaType(MediaType);
        } else {
            //
            // Could not get the data type handler interface, so fail
            // everything.
            //
            (*UnkInner)->Release();
            *UnkInner = NULL;
        }
    }
}

//
// Micro Media Sample class functions
//


CMicroMediaSample::CMicroMediaSample(
    DWORD Flags
    ) :
    m_Flags(Flags),
    m_cRef(1)
{
}


STDMETHODIMP
CMicroMediaSample::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if ((riid == __uuidof(IMediaSample)) ||
        (riid == __uuidof(IMediaSample2)) ||
        (riid == __uuidof(IUnknown))) {
        return GetInterface(static_cast<IMediaSample2*>(this), ppv);
    }
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)
CMicroMediaSample::AddRef(
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CMicroMediaSample::Release(
    )
{
    LONG    Ref;

    Ref = InterlockedDecrement(&m_cRef);
    if (!Ref) {
        delete this;
    }
    return (ULONG)Ref;
}


STDMETHODIMP
CMicroMediaSample::GetPointer(
    BYTE** Buffer
    )
{
    *Buffer = NULL;
    return NOERROR;
}


STDMETHODIMP_(LONG)
CMicroMediaSample::GetSize(
    )
{
    return 0;
}


STDMETHODIMP
CMicroMediaSample::GetTime(
    REFERENCE_TIME* TimeStart,
    REFERENCE_TIME* TimeEnd
    )
{
    return VFW_E_SAMPLE_TIME_NOT_SET;
}


STDMETHODIMP
CMicroMediaSample::SetTime(
    REFERENCE_TIME* TimeStart,
    REFERENCE_TIME* TimeEnd
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::IsSyncPoint(
    )
{
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetSyncPoint(
    BOOL IsSyncPoint
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::IsPreroll(
    )
{
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetPreroll(
    BOOL IsPreroll
    )
{
    return NOERROR;
}


STDMETHODIMP_(LONG)
CMicroMediaSample::GetActualDataLength(
    )
{
    return 0;
}


STDMETHODIMP
CMicroMediaSample::SetActualDataLength(
    LONG Actual
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::GetMediaType(
AM_MEDIA_TYPE** MediaType
    )
{
    *MediaType = NULL;
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetMediaType(
    AM_MEDIA_TYPE* MediaType
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::IsDiscontinuity(
    )
{
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetDiscontinuity(
    BOOL Discontinuity
    )
{
    return S_OK;
}


STDMETHODIMP
CMicroMediaSample::GetMediaTime(
    LONGLONG* TimeStart,
    LONGLONG* TimeEnd
    )
{
    return VFW_E_MEDIA_TIME_NOT_SET;
}


STDMETHODIMP
CMicroMediaSample::SetMediaTime(
    LONGLONG* TimeStart,
    LONGLONG* TimeEnd
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::GetProperties(
    DWORD PropertiesSize,
    BYTE* Properties
    )
{
    AM_SAMPLE2_PROPERTIES   Props;

    Props.cbData = min(PropertiesSize, sizeof(Props));
    Props.dwSampleFlags = m_Flags;
    Props.dwTypeSpecificFlags = 0;
    Props.pbBuffer = NULL;
    Props.cbBuffer = 0;
    Props.lActual = 0;
    Props.tStart = 0;
    Props.tStop = 0;
    Props.dwStreamId = AM_STREAM_MEDIA;
    Props.pMediaType = NULL;
    CopyMemory(Properties, &Props, Props.cbData);
    return S_OK;
}


STDMETHODIMP
CMicroMediaSample::SetProperties(
    DWORD PropertiesSize,
    const BYTE* Properties
    )
{
    return S_OK;
}

//
// Media Attributes class functions
//


CMediaTypeAttributes::CMediaTypeAttributes(
    ) :
    m_Attributes(NULL),
    m_cRef(1)
{
}


STDMETHODIMP
CMediaTypeAttributes::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if (riid == __uuidof(IMediaTypeAttributes) ||
        riid == __uuidof(IUnknown)) {
        return GetInterface(static_cast<IMediaTypeAttributes*>(this), ppv);
    }
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)
CMediaTypeAttributes::AddRef(
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CMediaTypeAttributes::Release(
    )
{
    LONG    Ref;

    Ref = InterlockedDecrement(&m_cRef);
    if (!Ref) {
        if (m_Attributes) {
            CoTaskMemFree(m_Attributes);
        }
        delete this;
    }
    return (ULONG)Ref;
}


STDMETHODIMP
CMediaTypeAttributes::GetMediaAttributes(
    OUT PKSMULTIPLE_ITEM* Attributes
    )
{
    //
    // Return a pointer directly to the cached data, assuming that
    // the caller understands the lifespan of the pointer returned.
    //
    *Attributes = m_Attributes;
    return NOERROR;
}


STDMETHODIMP
CMediaTypeAttributes::SetMediaAttributes(
    IN PKSMULTIPLE_ITEM Attributes OPTIONAL
    )
{
    //
    // Remove any currently cached data, then cache the data passed
    // in, if any.
    //
    if (m_Attributes) {
        CoTaskMemFree(m_Attributes);
        m_Attributes = NULL;
    }
    if (Attributes) {
        m_Attributes = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(Attributes->Size));
        if (m_Attributes) {
            CopyMemory(m_Attributes, Attributes, Attributes->Size);
        } else {
            return E_OUTOFMEMORY;
        }
    }
    return NOERROR;
}

//
// major pipe functions
//


STDMETHODIMP
MakePipesBasedOnFilter(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Whenever the pin that doesn't have a pipe gets connected, we are calling
    this function to build the pipe[-s] on a filter containing connecting pin.

    It is possible that the connecting pin has been created after other pin[-s]
    on the same filter had been connected. Therefore, some other pins on this filter
    may have caused creation of pipes on this filter.

    To not break existing clients, we have to solve the general case with splitters
    (one pipe for multiple read-only inputs).


Arguments:

    KsPin -
        connecting pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IPin*         Pin;
    ULONG*        OutPinCount;
    ULONG*        InPinCount;
    IPin***       InPinList;
    IPin***       OutPinList;
    ULONG         i;
    ULONG         PinCountFrwd = 0;
    ULONG         PinCountBkwd = 0;
    IPin**        PinListFrwd;
    IPin**        PinListBkwd;
    IKsPin*       InKsPin;
    IKsPin*       OutKsPin;
    HRESULT       hr;



    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter entry KsPin=%x"), KsPin ));

    //
    // Find out this filter's topology
    //
    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

    //
    // to simplify the logic: frwd/bkwd - are relative to KsPin,
    // but out/in - are actually relative to the filter.
    //
    if (PinType == Pin_Input) {
        OutPinCount = &PinCountFrwd;
        OutPinList  = &PinListFrwd;
        InPinCount  = &PinCountBkwd;
        InPinList   = &PinListBkwd;
    }
    else {
        InPinCount  = &PinCountFrwd;
        InPinList   = &PinListFrwd;
        OutPinCount = &PinCountBkwd;
        OutPinList  = &PinListBkwd;
    }

    //
    // go forward (could be upstream - for the Pin_Output)
    //
    hr = Pin->QueryInternalConnections(
        NULL,
        &PinCountFrwd );

    if ( ! (SUCCEEDED( hr ) )) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections rets=%x"), hr));
    }
    else {
        if (PinCountFrwd == 0) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter PinCount forward=0 ") ));
            hr = MakePipeBasedOnOnePin(KsPin, PinType, NULL);
        }
        else {
            if (NULL == (PinListFrwd = new IPin*[ PinCountFrwd ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipesBasedOnFilter E_OUTOFMEMORY on new IPin, %d pins"),
                        PinCountFrwd ));
            }
            else {
                hr = Pin->QueryInternalConnections(
                    PinListFrwd,
                    &PinCountFrwd );

                if ( ! (SUCCEEDED( hr ) )) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections frwd rets=%x"), hr));
                }
                else {
                    hr = PinListFrwd[ 0 ]->QueryInternalConnections(
                            NULL,
                            &PinCountBkwd );

                    //
                    // going backward after gone forward - we should always have at least one pin=KsPin.
                    //
                    if ( ! ( (SUCCEEDED( hr ) && PinCountBkwd) )) {

                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections bkwd rets=%x count=%d"),
                                hr, PinCountBkwd));

                        hr = E_FAIL;
                    }
                    else {
                        if (NULL == (PinListBkwd = new IPin*[ PinCountBkwd ])) {
                            hr = E_OUTOFMEMORY;

                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipesBasedOnFilter E_OUTOFMEMORY on new IPin back, %d pins"),
                                    PinCountBkwd ));

                        }
                        else {
                            hr = PinListFrwd[ 0 ]->QueryInternalConnections(
                                PinListBkwd,
                                &PinCountBkwd );

                            if ( ! (SUCCEEDED( hr ) )) {
                                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections bkwd rets=%x"), hr));
                                ASSERT( 0 );
                            }
                            else {
                                DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter: input pins=%d, output pins=%d"), *InPinCount, *OutPinCount ));

                                //
                                // here we know how many input pins and output pins on this filter are connected internally,
                                // so we can decide on how many pipes are needed.
                                //
                                if ( *InPinCount > 1) {
                                    //
                                    // this is a mixer; we need separate pipe for each input and output.
                                    // there is no properties yet to expose pin-to-pin framing relationship matrix.
                                    // NOTE: it doesn't matter whether it is M->1 mixer or M->N mixer, N>1 - we
                                    // need separate independent pipe for each pin anyway.
                                    //
                                    IKsPin*       TempKsPin;
                                    IKsPinPipe*   TempKsPinPipe;


                                    for (i = 0; i < *InPinCount; i++) {
                                        GetInterfacePointerNoLockWithAssert((*InPinList)[ i ], __uuidof(IKsPin), TempKsPin, hr);

                                        GetInterfacePointerNoLockWithAssert(TempKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

                                        if (! TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                                            hr = MakePipeBasedOnOnePin(TempKsPin, Pin_Input, NULL);
                                        }
                                    }

                                    for (i = 0; i < *OutPinCount; i++) {
                                        GetInterfacePointerNoLockWithAssert((*OutPinList)[ i ], __uuidof(IKsPin), TempKsPin, hr);

                                        GetInterfacePointerNoLockWithAssert(TempKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

                                        if (! TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                                            hr = MakePipeBasedOnOnePin(TempKsPin, Pin_Output, NULL);
                                        }
                                    }
                                }
                                else {
                                    //
                                    // this filter is either 1->N (N>1) splitter or 1->1 transform.
                                    //
                                    GetInterfacePointerNoLockWithAssert((*InPinList)[ 0 ], __uuidof(IKsPin), InKsPin, hr);

                                    if ( *OutPinCount > 1) {
                                        //
                                        // 1->N splitter, N>1
                                        //
                                        if ( (PinType != Pin_Input) && ( *OutPinCount > 1) ) {
                                            //
                                            // Make the connecting pin (KsPin) the first item in the OutPinList array,
                                            // by the convention with MakePipeBasedOnSplitter().
                                            //
                                            IPin*         TempPin;

                                            TempPin = (*OutPinList)[0];

                                            for (i=0; i < *OutPinCount; i++) {
                                                GetInterfacePointerNoLockWithAssert((*OutPinList)[ i ], __uuidof(IKsPin), OutKsPin, hr);

                                                if (OutKsPin == KsPin) {
                                                    (*OutPinList)[0] = (*OutPinList)[i];
                                                    (*OutPinList)[i] = TempPin;

                                                    break;
                                                }
                                            }
                                        }
                                        hr = MakePipeBasedOnSplitter(InKsPin, *OutPinList, *OutPinCount, PinType);
                                    }
                                    else {
                                        //
                                        // 1->1 transform
                                        //
                                        GetInterfacePointerNoLockWithAssert((*OutPinList)[ 0 ], __uuidof(IKsPin), OutKsPin, hr);

                                        hr = MakePipeBasedOnTwoPins(InKsPin, OutKsPin, Pin_Output, PinType);
                                    }
                                }
                                for (i=0; i<PinCountBkwd; i++) {
                                    PinListBkwd[i]->Release();
                                }
                            }
                            delete [] PinListBkwd;
                        }
                    }
                    for (i=0; i<PinCountFrwd; i++) {
                        PinListFrwd[i]->Release();
                    }
                }
                delete [] PinListFrwd;
            }
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter rets=%x"), hr ));

    return hr;
}


STDMETHODIMP
MakePipeBasedOnOnePin(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN IKsPin* OppositeKsPin
    )
/*++

Routine Description:

    Only one pin will decide on the pipe properties.
    There is no framing dependency on any other pin.

Arguments:

    KsPin -
        pin that determines the framing.

    PinType -
        KsPin type.

    OppositeKsPin -
        if NULL, then ignore the opposite pin,
        otherwise - OppositeKsPin pin doesn't have framing properties.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    HRESULT                    hr;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    IKsAllocatorEx*            KsAllocator;
    IKsAllocatorEx*            OppositeKsAllocator;
    IMemAllocator*             MemAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    PIPE_TERMINATION*          TerminPtr;
    PIPE_TERMINATION*          OppositeTerminPtr;
    KS_FRAMING_FIXED           FramingExFixed;
    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                OppositeKsPinPipe;
    GUID                       Bus;
    BOOL                       FlagDone = 0;


    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnOnePin entry KsPin=%x, OppositeKsPin=%x"),
            KsPin, OppositeKsPin ));

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! OppositeKsPin ) {

        KSPIN_COMMUNICATION        Communication;

        KsPin->KsGetCurrentCommunication(&Communication, NULL, NULL);

        //
        // no pipe for bridge pins
        //
        if ( Communication == KSPIN_COMMUNICATION_BRIDGE ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnOnePin Single pin is a bridge.") ));

            FlagDone = 1;
        }
    }
    else {
        GetInterfacePointerNoLockWithAssert(OppositeKsPin, __uuidof(IKsPinPipe), OppositeKsPinPipe, hr);

        OppositeKsAllocator = OppositeKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
        if (OppositeKsAllocator) {
            //
            // OppositeKsPin has a pipe already.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnOnePin OppositePin has a pipe already.") ));
            OppositeKsPinPipe->KsSetPipe(NULL);
            OppositeKsPin->KsReceiveAllocator( NULL );
        }
    }

    if (! FlagDone) {
        //
        // create and initialize the pipe (set the pipe in don't care state)
        //
        hr = CreatePipe(KsPin, &KsAllocator);

        if ( SUCCEEDED( hr )) {
            hr = InitializePipe(KsAllocator, 0);

            if ( SUCCEEDED( hr )) {
                GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

                if ( ! KsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
                    KsPin->KsReceiveAllocator(MemAllocator);
                }
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnOnePin KsPin has a MemAlloc already.") ));
                }
                KsPinPipe->KsSetPipe(KsAllocator);

                AllocEx = KsAllocator->KsGetProperties();
                //
                // Set the BusType and LogicalMemoryType for non-host-system buses.
                //
                GetBusForKsPin(KsPin, &Bus);
                AllocEx->BusType = Bus;

                if (! IsHostSystemBus(Bus) ) {
                    //
                    // Set the LogicalMemoryType for non-host-system buses.
                    //
                    AllocEx->LogicalMemoryType = KS_MemoryTypeDeviceSpecific;
                }

                if (OppositeKsPin) {
                    if ( ! OppositeKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) )  {
                        OppositeKsPin->KsReceiveAllocator(MemAllocator);
                    }
                    else {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipeBasedOnOnePin OppositeKsPin has a MemAlloc already.") ));
                        ASSERT(0);
                    }
                    OppositeKsPinPipe->KsSetPipe(KsAllocator);
                }

                //
                // Get the pin framing from pin cache
                //
                GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);
                if (FramingProp != FramingProp_None) {
                    //
                    // Get the fixed memory\bus framing (first memory, fixed bus) from the FramingEx.
                    //
                    GetFramingFixedFromFramingByBus(FramingEx, Bus, TRUE, &FramingExFixed);

                    //
                    // since the pipe was initialized to defaults, we only need to update non-default pipe settings.
                    //
                    AllocEx->cBuffers = FramingExFixed.Frames;
                    AllocEx->cbBuffer = FramingExFixed.OptimalRange.Range.MaxFrameSize;
                    AllocEx->cbAlign  = (long) (FramingExFixed.FileAlignment + 1);
                    AllocEx->cbPrefix = ALLOC_DEFAULT_PREFIX;

                    //
                    // Set pipe's LogicalMemoryType and MemoryType based on Framing and Bus.
                    //
                    if (AllocEx->LogicalMemoryType != KS_MemoryTypeDeviceSpecific) {
                        //
                        // For standard system bus - everything is defined from framing.
                        //
                        GetLogicalMemoryTypeFromMemoryType(FramingExFixed.MemoryType, FramingExFixed.MemoryFlags, &AllocEx->LogicalMemoryType);
                        AllocEx->MemoryType = FramingExFixed.MemoryType;
                    }
                    else {
                        //
                        // Handle Device Specific Buses here.
                        //
                        if ( (FramingExFixed.MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) ||
                             (FramingExFixed.MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) ||
                             (FramingExFixed.MemoryType == KSMEMORY_TYPE_USER) ) {
                            //
                            // These are illegal memory types for non-host-system-buses, must be the legacy filters.
                            //
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTER MakePipeBasedOnOnePin: KsPin=%x HostSystemMemory over NonHost Bus."), KsPin ));

                            if (FramingProp == FramingProp_Old) {
                                //
                                // We don't want to break existing filters, so we correct their erroneous settings.
                                //
                                AllocEx->MemoryType = KSMEMORY_TYPE_DONT_CARE;
                            }
                            else {
                                //
                                // We refuse to connect new filters with wrong FRAMING_EX properties.
                                //
                                hr = E_FAIL;
                            }
                        }
                    }

                    if ( SUCCEEDED (hr) ) {
                        //
                        // to minimize code - use an indirection to cover both sides of a pipe.
                        //
                        if (PinType == Pin_Input) {
                            OppositeTerminPtr = &AllocEx->Output;
                            TerminPtr = &AllocEx->Input;
                        }
                        else if ( (PinType == Pin_Output) || (PinType == Pin_MultipleOutput) ) {
                            OppositeTerminPtr =  &AllocEx->Input;
                            TerminPtr = &AllocEx->Output;
                        }
                        else {
                            ASSERT (0);
                        }

                        if (! OppositeKsPin) {
                            OppositeTerminPtr->OutsideFactors |= PipeFactor_LogicalEnd;
                        }

                        if (PinType == Pin_MultipleOutput) {
                            AllocEx->Flags |= KSALLOCATOR_FLAG_MULTIPLE_OUTPUT;
                        }

                        AllocEx->Flags = FramingExFixed.Flags;

                        //
                        // set appropriate flags depending on pin's framing.
                        //
                        if (! IsFramingRangeDontCare(FramingExFixed.PhysicalRange) ) {
                            AllocEx->InsideFactors |= PipeFactor_PhysicalRanges;
                        }

                        if (! IsFramingRangeDontCare(FramingExFixed.OptimalRange.Range) ) {
                            AllocEx->InsideFactors |= PipeFactor_OptimalRanges;
                        }

                        //
                        // Set the pipe allocator handling pin.
                        //
                        AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

                        //
                        // Resolve the pipe.
                        //
                        hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT);
                    }
                }
            }

            KsAllocator->Release();
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnOnePin rets %x"), hr ));

    return hr;
}


STDMETHODIMP
MakePipeBasedOnFixedFraming(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_FRAMING_FIXED FramingExFixed
    )
/*++

Routine Description:

    A fixed framing will define the new pipe properties.

Arguments:

    KsPin -
        pin that creates a pipe

    PinType -
        KsPin type.

    FramingExFixed -
        Fixed framing defining pipe properties.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    HRESULT                    hr;
    IKsAllocatorEx*            KsAllocator;
    IMemAllocator*             MemAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPinPipe*                KsPinPipe;


    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnFixedFraming entry KsPin=%x"), KsPin ));

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    //
    // create and initialize the pipe (set the pipe in don't care state)
    //
    hr = CreatePipe(KsPin, &KsAllocator);

    if (SUCCEEDED( hr )) {

        hr = InitializePipe(KsAllocator, 0);

        if (SUCCEEDED( hr )) {

            GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

            if ( ! KsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {

                KsPin->KsReceiveAllocator(MemAllocator);
                KsPinPipe->KsSetPipe(KsAllocator);
                AllocEx = KsAllocator->KsGetProperties();

                //
                // since the pipe was initialized to defaults, we only need to update non-default pipe settings.
                //
                AllocEx->cBuffers = FramingExFixed.Frames;
                AllocEx->cbBuffer = FramingExFixed.OptimalRange.Range.MaxFrameSize;
                AllocEx->cbAlign  = (long) (FramingExFixed.FileAlignment + 1);
                AllocEx->cbPrefix = ALLOC_DEFAULT_PREFIX;

                GetLogicalMemoryTypeFromMemoryType(FramingExFixed.MemoryType, FramingExFixed.MemoryFlags, &AllocEx->LogicalMemoryType);
                AllocEx->MemoryType = FramingExFixed.MemoryType;

                if (PinType == Pin_MultipleOutput) {
                    AllocEx->Flags |= KSALLOCATOR_FLAG_MULTIPLE_OUTPUT;
                }

                AllocEx->Flags = FramingExFixed.Flags;

                //
                // set appropriate flags depending on pin's framing.
                //
                if (! IsFramingRangeDontCare(FramingExFixed.PhysicalRange) ) {
                    AllocEx->InsideFactors |= PipeFactor_PhysicalRanges;
                }

                if (! IsFramingRangeDontCare(FramingExFixed.OptimalRange.Range) ) {
                    AllocEx->InsideFactors |= PipeFactor_OptimalRanges;
                }

                //
                // Set the pipe allocator handling pin.
                //
                AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

                //
                // Resolve the pipe.
                //
                hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT);

            }
            else {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnFixedFraming KsPin has a MemAlloc already.") ));
                ASSERT(0);
            }
        }

        KsAllocator->Release();
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnFixedFraming rets %x"), hr ));

    return hr;
}


STDMETHODIMP
MakePipeBasedOnTwoPins(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN ULONG OutPinType,
    IN ULONG ConnectPinType
    )
/*++

Routine Description:

    Both input and output pins on the same filter will determine the pipe settings.

Arguments:

    InKsPin -
        Input pin.

    OutKsPin -
        Output pin.

    OutPinType -
        Output pin type (Output or MultipleOutput).

    ConnectPinType -
        Connected pin type (Input or Output).


Return Value:

    S_OK or an appropriate error code.

--*/
{
    HRESULT                    hr;
    KSPIN_COMMUNICATION        InCommunication, OutCommunication;
    PKSALLOCATOR_FRAMING_EX    InFramingEx, OutFramingEx;
    FRAMING_PROP               InFramingProp, OutFramingProp;
    IKsAllocatorEx*            KsAllocator;
    IMemAllocator*             MemAllocator;
    KS_FRAMING_FIXED           InFramingExFixed, OutFramingExFixed;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    GUID                       InBus, OutBus, ConnectBus;
    BOOL                       FlagBusesCompatible;
    ULONG                      ExistingPipePinType;
    ULONG                      CommonMemoryTypesCount;
    GUID                       CommonMemoryType;



    ASSERT(InKsPin && OutKsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins entry In=%x, Out=%x"), InKsPin, OutKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    //
    // check for the bridge pins.
    //
    InKsPin->KsGetCurrentCommunication(&InCommunication, NULL, NULL);
    OutKsPin->KsGetCurrentCommunication(&OutCommunication, NULL, NULL);

    if ( ( InCommunication == KSPIN_COMMUNICATION_BRIDGE ) &&
         ( OutCommunication == KSPIN_COMMUNICATION_BRIDGE ) ) {
        //
        // error in a filter - it can't have 2 pins and both pins are bridges.
        //
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR IN FILTER: both pins are bridge pins.") ));
        hr = E_FAIL;
    }
    else if ( InCommunication == KSPIN_COMMUNICATION_BRIDGE ) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - Input pin is a bridge.") ));

        if (! (OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) )) {
            hr = MakePipeBasedOnOnePin(OutKsPin, OutPinType, NULL);
        }
    }
    else if ( OutCommunication == KSPIN_COMMUNICATION_BRIDGE ) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - Output pin is a bridge.") ));

        if (! (InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) )) {
            hr = MakePipeBasedOnOnePin(InKsPin, Pin_Input, NULL);
        }
    }
    else {
        //
        // One of the pins should not have the pipe assigned, because one of the the pins is the connecting pin.
        // We should not have called this function if the connecting pin had a pipe.
        //
        if ( InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) && OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipeBasedOnTwoPins - both pins have pipes already.") ));
            ASSERT(0);
            hr = E_FAIL;
        }
        else {
            //
            // Get the pins framing from pins cache.
            //
            GetPinFramingFromCache(InKsPin, &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);
            GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins - Framing Prop In=%d, Out=%d"), InFramingProp, OutFramingProp ));

            //
            // Get buses for pins and see if they are compatible.
            //
            GetBusForKsPin(InKsPin, &InBus);
            GetBusForKsPin(OutKsPin, &OutBus);

            if (ConnectPinType == Pin_Input) {
                ConnectBus = InBus;
            }
            else {
                ConnectBus = OutBus;
            }

            FlagBusesCompatible = AreBusesCompatible(InBus, OutBus);
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins - FlagBusesCompatible=%d"), FlagBusesCompatible ));

            //
            // See if one pipe was created.
            //
            KsAllocator = InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
            if (KsAllocator) {
                ExistingPipePinType = Pin_Input;
            }
            else {
                KsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
                if (KsAllocator) {
                    ExistingPipePinType = Pin_Output;
                }
            }

            if (KsAllocator) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - %d pin had a pipe already."), ExistingPipePinType ));
                //
                // Connecting pin should not have any pipe association yet.
                //
                if (ExistingPipePinType == ConnectPinType) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipeBasedOnTwoPins - connecting %d pin had a pipe already."), ExistingPipePinType ));
                    ASSERT(0);
                    hr = E_FAIL;
                }
                else {
                    GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);
                }
            }

            if ( SUCCEEDED (hr) ) {
                if ( (InFramingProp == FramingProp_None) && (OutFramingProp == FramingProp_None) ) {
                    //
                    // if both pins don't care then we assume that the filter supports in-place transform
                    // and we will create one pipe for both pins if Input and Output buses are compatible.
                    //
                    // NOTE: for splitters we always have an output framing, so we won't execute the following code.
                    //
                    if (FlagBusesCompatible) {
                        ResultSinglePipe(InKsPin, OutKsPin, ConnectBus, KSMEMORY_TYPE_DONT_CARE, InKsPinPipe, OutKsPinPipe,
                            MemAllocator, KsAllocator, ExistingPipePinType);
                    }
                    else {
                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                    }
                }
                else if ( OutFramingProp != FramingProp_None ) {
                    //
                    // The first memory type per fixed bus in the pin's framing
                    // will determine the KS choice.
                    // If OutKsPin is not connected yet, then OutBus=GUID_NULL, so the first
                    // framing item is returned.
                    //
                    GetFramingFixedFromFramingByBus(OutFramingEx, OutBus, TRUE, &OutFramingExFixed);

                    if (OutFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER) {

                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins - in place modifier") ));
                        //
                        // Check to see if Input and Output Buses allow a single pipe throughout this filter.
                        //
                        if (! FlagBusesCompatible) {
                            //
                            // The only way to build a single pipe across multiple buses -
                            // is to explicitly agree on a fixed common memory type for all the pipe's pins.
                            // Both pins must support extended framing and both pins must agree on a common fixed memory type.
                            //
                            if ( (OutFramingProp != FramingProp_Ex) || (InFramingProp != FramingProp_Ex) ) {
                                ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                            }
                            else {
                                if (! KsAllocator) {
                                    //
                                    // There is no pipes on this filter yet.
                                    // Get the first common memory type for the filter pins per the known ConnectBus.
                                    //
                                    CommonMemoryTypesCount = 1;

                                    if (FindCommonMemoryTypesBasedOnBuses(InFramingEx, OutFramingEx, ConnectBus, GUID_NULL,
                                            &CommonMemoryTypesCount, &CommonMemoryType) ) {

                                        CreatePipeForTwoPins(InKsPin, OutKsPin, ConnectBus, CommonMemoryType);
                                    }
                                    else {
                                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                                    }
                                }
                                else {
                                    //
                                    // A pipe on one of the filter's pins already exists.
                                    //
                                    IKsPin*      PipeKsPin;
                                    ULONG        PipePinType;
                                    IKsPin*      ConnectKsPin;

                                    if (ConnectPinType == Pin_Input) {
                                        PipeKsPin = OutKsPin;
                                        PipePinType = Pin_Output;
                                        ConnectKsPin = InKsPin;
                                    }
                                    else {
                                        PipeKsPin = InKsPin;
                                        PipePinType = Pin_Input;
                                        ConnectKsPin = OutKsPin;
                                    }

                                    if (! FindCommonMemoryTypeBasedOnPipeAndPin(PipeKsPin, PipePinType, ConnectKsPin, ConnectPinType, TRUE, NULL) ) {
                                        //
                                        // If a single pipe thru this filter was possible, then it has been built by
                                        // FindCommonMemoryTypeBasedOnPipeAndPin function above, and we are done.
                                        //
                                        // We are here ONLY if a single pipe solution thru this filter is not possible,
                                        // so we will have separate pipes on this filter.
                                        //
                                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                                    }
                                }
                            }
                        }
                        else {
                            //
                            // We won't consider possible input pin's framing.
                            //
                            if (! KsAllocator) {
                                hr = MakePipeBasedOnOnePin(OutKsPin, OutPinType, InKsPin);
                            }
                            else {
                                //
                                // add one pin to existing pipe
                                //
                                ResultSinglePipe(InKsPin, OutKsPin, ConnectBus, OutFramingExFixed.MemoryType, InKsPinPipe, OutKsPinPipe,
                                    MemAllocator, KsAllocator, ExistingPipePinType);
                            }
                        }
                    }
                    else {
                        //
                        // make two pipes on this filter.
                        //
                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                        //
                        // there can be framing size dependancies between two pins (or pipes)
                        //
                        if (OutFramingExFixed.OutputCompression.RatioConstantMargin == 0)  {
                            //
                            // make the two pipes dependant
                            //
                            hr = MakeTwoPipesDependent(InKsPin, OutKsPin);
                            if (! SUCCEEDED( hr )) {
                                ASSERT(0);
                            }
                        }
                    }
                }
                else if ( InFramingProp != FramingProp_None ) {

                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - Input pin sets framing") ));

                    GetFramingFixedFromFramingByBus(InFramingEx, InBus, TRUE, &InFramingExFixed);

                    if (! FlagBusesCompatible) {
                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                    }
                    else {
                        //
                        // since there is no Output pin framing, we do in place. It is consistent with an old allocators scheme.
                        //
                        ResultSinglePipe(InKsPin, OutKsPin, ConnectBus, InFramingExFixed.MemoryType, InKsPinPipe, OutKsPinPipe,
                            MemAllocator, KsAllocator, ExistingPipePinType);
                    }
                }
            }
        }
    }
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins rets %x"), hr ));

    return hr;

}


STDMETHODIMP
MakePipeBasedOnSplitter(
    IN IKsPin* InKsPin,
    IN IPin** OutPinList,
    IN ULONG OutPinCount,
    IN ULONG ConnectPinType
    )
/*++

Routine Description:

    One input and all output pins on the same filter will determine the filter pipe[-s] settings.
    In case the connecting pin is an output pin, it should be listed first in the OutPinList.

Arguments:

    InKsPin -
        Input pin.

    OutPinList -
        Output pins list.

    OutPinCount -
        Count of the Output pin list above.

    ConnectPinType -
        Connecting pin type (Input or Output).

Return Value:

    S_OK or an appropriate error code.

--*/
{

    HRESULT                    hr;
    PKSALLOCATOR_FRAMING_EX    OutFramingEx;
    KS_FRAMING_FIXED           OutFramingExFixed;
    FRAMING_PROP               OutFramingProp;
    IKsAllocatorEx*            TempKsAllocator;
    ULONG                      i, j;
    IKsPin*                    OutKsPin;
    IKsPinPipe*                TempKsPinPipe;
    BOOL                       IsInputPinPipeCreated = 0;
    ULONG                      FlagReadOnly;
    KEY_PIPE_DATA*             KeyPipeData = NULL;
    ULONG                      KeyPipeDataCount = 0;
    ULONG                      FoundPipe;
    GUID                       Bus;



    ASSERT(InKsPin && OutPinList && (OutPinCount > 1) );

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnSplitter entry InKsPin=%x, OutPinCount=%d"), InKsPin, OutPinCount ));

    //
    // To do: Currently filters don't set KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY on input pins.
    // Splitters (MsTee) don't indicate KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY or
    // KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER on output pins,
    // so there is no way to decide on a single (read-only) output pipe.
    // Current allocators  don't consider flags at all, assuming that single
    // output pipe is possible by default.
    //
    // Assign FlagReadOnly=KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER | KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY
    // when all filters are updated to use correct read-only flags.
    // Strictly speaking, only KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY flag means read-only, but in case
    // of splitters, KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER on output pin means using one allocator for
    // input and output pins, so if there are multiple output pins on a splitter - then such setting makes
    // sense only for read-only connections.
    //
    // For now:
    //
    FlagReadOnly = 0xffffffff;

    //
    // See if the input pin has a pipe already.
    //
    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

    if ( TempKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) ) {
        IsInputPinPipeCreated = 1;
    }

    //
    // It is possible that some pins on this splitter are already connected, and some pipes
    // are built (e.g. the new output pin was created after some pins had been connected).
    // There are 3 types of output pins: pins already connected (they must have corresponding pipes);
    // pins that are not yet connected; and one connecting pin (if ConnectPinType==Pin_Output)
    //

    //
    // In order to quickly look-up possible pipes connections, we maintain the table of the existing pipes.
    //
    if (OutPinCount > 0) {
        if (NULL == (KeyPipeData = new KEY_PIPE_DATA[ OutPinCount ]))  {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR E_OUTOFMEMORY MakePipeBasedOnSplitter. OutPinCount=%d"), OutPinCount ));
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) ) {
        //
        // First pass - build the table of the existing pipes on this filter: KeyPipeData.
        //
        for (i=0; i<OutPinCount; i++) {

            GetInterfacePointerNoLockWithAssert(OutPinList[ i ], __uuidof(IKsPin), OutKsPin, hr);

            GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

            //
            // See if there is any pipe built on this pin; and if there is a kernel mode pipe - see if it is already
            // listed in KeyPipeData[].
            //
            TempKsAllocator = TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
            if (TempKsAllocator && IsKernelModeConnection(OutKsPin) ) {
                FoundPipe = 0;
                for (j=0; j<KeyPipeDataCount; j++) {
                    if (TempKsAllocator == KeyPipeData[j].KsAllocator) {
                        FoundPipe = 1;
                        break;
                    }
                }

                if (! FoundPipe) {
                    KeyPipeData[KeyPipeDataCount].KsPin = OutKsPin;
                    KeyPipeData[KeyPipeDataCount].PinType = Pin_Output;
                    KeyPipeData[KeyPipeDataCount].KsAllocator = TempKsAllocator;
                    KeyPipeDataCount++;
                }
            }
        }

        DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnSplitter KeyPipeDataCount=%d, IsInputPinPipeCreated=%d"),
                KeyPipeDataCount, IsInputPinPipeCreated ));

        //
        // Build the pipe for the Input pin (if it has not been built yet).
        // We do it now, because we want to try to put the Input pin on one of the
        // pipes that had been already built for the CONNECTED output pins on the same filter.
        //
        if (! IsInputPinPipeCreated) {
            if (SplitterCanAddPinToPipes(InKsPin, Pin_Input, KeyPipeData, KeyPipeDataCount) ) {
                IsInputPinPipeCreated = 1;
            }
        }

        //
        // Second pass: build the pipes for the output pins that don't have pipes yet.
        // In case ConnectPinPipe==Pin_Output, the OutPinList[0] is the connecting pin,
        // so the connecting pin is always handled first.
        //
        for (i=0; i<OutPinCount; i++) {

            GetInterfacePointerNoLockWithAssert(OutPinList[ i ], __uuidof(IKsPin), OutKsPin, hr);

            GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

            if (TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                continue;
            }

            GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);
            if (OutFramingProp == FramingProp_None) {
                //
                // Output pin must have the framing properties to qualify for "in-place" transform.
                //
                hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
            }
            else {
                GetBusForKsPin(OutKsPin, &Bus);
                GetFramingFixedFromFramingByBus(OutFramingEx, Bus, TRUE, &OutFramingExFixed);
                if (OutFramingExFixed.Flags & FlagReadOnly) {
                    if (SplitterCanAddPinToPipes(OutKsPin, Pin_Output, KeyPipeData, KeyPipeDataCount) ) {
                        //
                        // Done with this output pin.
                        //
                        continue;
                    }

                    //
                    // None of the existing pipes is compatible with this output pin,
                    // so we have to build a new pipe for this output pin.
                    // Also, for the first new pipe we build here (we start with the connecting pin),
                    // consider the input pin on this filter (if the input pin does not have a pipe yet).
                    //
                    if (! IsInputPinPipeCreated) {
                        hr = MakePipeBasedOnTwoPins(InKsPin, OutKsPin, Pin_Output, ConnectPinType);
                        IsInputPinPipeCreated = 1;
                    }
                    else {
                        hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
                    }
                }
                else {
                    hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
                }
            }

            //
            // Add new output pipe to the KeyPipeData
            //
            TempKsAllocator = TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
            ASSERT(TempKsAllocator);

            KeyPipeData[KeyPipeDataCount].KsPin = OutKsPin;
            KeyPipeData[KeyPipeDataCount].PinType = Pin_Output;
            KeyPipeData[KeyPipeDataCount].KsAllocator = TempKsAllocator;
            KeyPipeDataCount++;
        }
    }


    //
    // If we haven't yet created the pipe for the input pin, we must
    // create it now.
    //
    if (! IsInputPinPipeCreated) {
        hr = MakePipeBasedOnOnePin (InKsPin, Pin_Input, NULL);
        IsInputPinPipeCreated = 1;
    }

    if (KeyPipeData) {
        delete [] KeyPipeData;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnSplitter rets %x, KeyPipeDataCount=%d"), hr, KeyPipeDataCount ));

    return hr;

}


STDMETHODIMP
MakeTwoPipesDependent(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
   )
/*++

Routine Description:

    Both input and output pins reside on the same filter,
    but they belong to different pipes.

    Two pipes are dependent if their frame sizes are dependent.
    There are the following reasons for creating dependend pipes:

    - output pin does have framing properties and it doesn't specify "in-place" transform.
    - memory types do not allow a single pipe solution.
    - we have a downstream expansion, and the very first filter doesn't support partial frame read operation.

Arguments:

    InKsPin -
        input pin.

    OutKsPin -
        output pin.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    //
    // Don't need this for an intermediate version.
    //
    return S_OK;

}


STDMETHODIMP
ConnectPipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
    )
/*++

Routine Description:

    Connecting pipes.

    Merging pipes into one pipe is not possible if: incompatible memory types,
    or incompatible physical framing, or there are pins on both sides that require their own allocators.

    There are two extreme cases:

    OPTIMAL CASE - trying to find the optimal solution by optimizing some formal goal-function.
    NO OPTIMIZATION CASE - ignoring most of the framing info, just getting connected.

    OPTIMAL CASE - each of the two connecting pipes has optimal solution. In case that memory types,
    and optimal ranges do intersect - this intersection yields the optimal solution for the entire graph.
    (The total MAX can't be greater than sum of the upstream and downstream independent MAX-es.)

    In case either memory types or optimal ranges do not intersect - we will need to search for optimal
    solution trying out a lot of possible pipes-systems in both upstream and downstream directions from
    the connection point.

    INTERMEDIATE MODEL - in case that memory types and physical ranges do intersect - the connection is
    possible by merging the connecting pipes. We will also consider the optimal ranges of the pipe system
    with the greater weight.

    In case either memory types or physical ranges do not intersect - we will have to modify existing
    pipes systems to make the connection possible.
    For each combination of upstream and downstream memory types and buses we have non-exhaustive list
    of preferred connection types in priority order.

    If all connection types fail - then the connection is not possible and we will return the corresponding
    error code.

    We also must cover the case when the connecting pin's framing or medium changes dynamically.
    In the intermediate model we do the following:

    If any of the connecting pin's medium or framing changed:
    - Try to use one pipe through the connecting pin.
    - Split the pipe at the connecting pin.


Arguments:

    InKsPin -
        input pin on downstream filter

    OutKsPin -
        output pin on upstream filter

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx*            InKsAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx, OutAllocEx;
    HRESULT                    hr;
    ULONG                      Attempt, NumPipes, FlagChange;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;

    ASSERT (InKsPin && OutKsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipes entry Out=%x In=%x"), OutKsPin, InKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    //
    // 1. Process any changes on the output pin.
    //
    hr = ResolvePipeOnConnection(OutKsPin, Pin_Output, FALSE, &FlagChange);
    if ( SUCCEEDED( hr ) ) {
        //
        // 2. Process any changes on the input pin.
        //
        hr = ResolvePipeOnConnection(InKsPin, Pin_Input, FALSE, &FlagChange);
    }

    if ( SUCCEEDED( hr ) ) {
        //
        // 3. Based on the logical memory types for the connecting pipes
        //    manage the connection.
        //
        OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        OutAllocEx = OutKsAllocator->KsGetProperties();

        InKsAllocator = InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        InAllocEx = InKsAllocator->KsGetProperties();

        for (Attempt = 0; Attempt < ConnectionTableMaxEntries; Attempt++) {
            NumPipes = ConnectionTable[OutAllocEx->LogicalMemoryType] [InAllocEx->LogicalMemoryType] [Attempt].NumPipes;

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipes, Out=%x %d, In=%x %d, Attempt=%d, Pipes=%d"),
                    OutKsAllocator, OutAllocEx->LogicalMemoryType,
                    InKsAllocator, InAllocEx->LogicalMemoryType,
                    Attempt, NumPipes ));

            if (NumPipes == 0) {
                //
                // means that we used all the possible attempts for this combination.
                //
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipes Pipes=3 (0)") ));

                if (! CanConnectPins(OutKsPin, InKsPin, Pin_Move) ) {
                    hr = E_FAIL;
                }

                break;
            }

            if (NumPipes == 1) {
                //
                // try to merge pipes using predetermined memory type.
                //
                if (ConnectionTable[OutAllocEx->LogicalMemoryType] [InAllocEx->LogicalMemoryType] [Attempt].Code == KS_DIRECTION_DOWNSTREAM) {
                    if ( CanPipeUseMemoryType(OutKsPin, Pin_Output, InAllocEx->MemoryType, InAllocEx->LogicalMemoryType, FALSE, TRUE) ) {
                        if (CanMergePipes(InKsPin, OutKsPin, InAllocEx->MemoryType, TRUE) ) {
                            break;
                        }
                    }
                }
                else {
                    if ( CanPipeUseMemoryType(InKsPin, Pin_Input, OutAllocEx->MemoryType, OutAllocEx->LogicalMemoryType, FALSE, TRUE) ) {
                        if (CanMergePipes(InKsPin, OutKsPin, OutAllocEx->MemoryType, TRUE) ) {
                            break;
                        }
                    }
                }
            }
            else if (NumPipes == 2) {
                //
                // try to have 2 pipes with predetermined breaking pins and memory types.
                //
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipes Pipes=2") ));

                if (ConnectionTable[OutAllocEx->LogicalMemoryType] [InAllocEx->LogicalMemoryType] [Attempt].Code == KS_DIRECTION_DOWNSTREAM) {
                    if (CanAddPinToPipeOnAnotherFilter(InKsPin, OutKsPin, Pin_Output, Pin_Move) ) {
                        break;
                    }
                }
                else {
                    if (CanAddPinToPipeOnAnotherFilter(OutKsPin, InKsPin, Pin_Input, Pin_Move) ) {
                        break;
                    }
                }
            }
            else if (NumPipes == 3) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR ConnectPipes Pipes=3") ));

                if (CanConnectPins(OutKsPin, InKsPin, Pin_Move) ) {
                    break;
                }
            }
        }

        //
        // We have successfully connected the pins.
        // Lets optimize the dependent pipes system.
        //
        if ( SUCCEEDED( hr ) ) {
            OptimizePipesSystem(OutKsPin, InKsPin);
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipes rets %x"), hr ));

    return hr;

}


STDMETHODIMP
ResolvePipeOnConnection(
    IN  IKsPin* KsPin,
    IN  ULONG PinType,
    IN  ULONG FlagDisconnect,
    OUT ULONG* FlagChange
    )
/*++

Routine Description:

    When pin is connecting/disconnecting, its framing properties
    and medium may change. This routine returns the FlagChange
    indicating the framing properties that have changed (if any).

Arguments:

    KsPin -
        connecting/disconnecting pin.

    PinType -
        KsPin type.

    FlagDisconnect -
        1 if KsPin is disconnecting,
        0 if KsPin is connecting.

    FlagChange -
        resulting change in a pipe system.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    KS_FRAMING_FIXED           FramingExFixed;
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    ULONG                      FramingDelta;
    HRESULT                    hr;
    KS_LogicalMemoryType       LogicalMemoryType;
    IKsPinPipe*                KsPinPipe;
    GUID                       BusLast, BusOrig;
    BOOL                       FlagDone = 0;



    ASSERT (KsPin);

    *FlagChange = 0;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (!SUCCEEDED(hr)) {
        return hr;
    }

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    //
    // See if KsPin's medium has changed.
    // Note: we are keeping the most recent value of the pin's connection bus in pin's cache.
    // We are interested in the pin's bus delta at the particular time, when we are computing
    // the graph data flow solution.
    //
    GetBusForKsPin(KsPin, &BusLast);
    BusOrig = KsPinPipe->KsGetPinBusCache();

    if ( BusOrig != BusLast ) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection KsPin=%x Bus Changed"), KsPin ));

        if (! AreBusesCompatible(AllocEx->BusType, BusLast) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection KsPin=%x Buses incompatible"), KsPin ));

            KsPinPipe->KsSetPinBusCache(BusLast);
            //
            // Pipe has to be changed - different memory type must be used.
            //
            if (! FindCommonMemoryTypeBasedOnPipeAndPin(KsPin, PinType, KsPin, PinType, TRUE, NULL) ) {
                CreateSeparatePipe(KsPin, PinType);
            }
            *FlagChange = 1;
            FlagDone = 1;
        }
    }

    if (! FlagDone) {
        KsPinPipe->KsSetPinBusCache(BusLast);

        //
        // See if KsPin framing has changed.
        //
        ComputeChangeInFraming(KsPin, PinType, AllocEx->MemoryType, &FramingDelta);
        if (! FramingDelta) {
            FlagDone = 1;
        }
    }

    if (! FlagDone) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection KsPin=%x, FramingDelta=%x"),
                KsPin, FramingDelta));

        //
        // input pipe should not have an upstream dependent pipe.
        //
        if (PinType == Pin_Input) {
            if (AllocEx->PrevSegment) {
                ASSERT(0);
           }
        }

        //
        // handle the situation when this pin has no framing now.
        //
        GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

        if (FramingProp != FramingProp_None) {
            //
            // If this pin's framing changed - we will try to use a single pipe.
            // If using a single pipe is not possible - then we will split the pipe at this pin.
            //
            // Pipe can have one assigned allocator handler only.
            // In case there has been a "MUST ALLOCATE" pin assigned on a pipe already .AND.
            // the connecting pin's framing changed and it now requires "MUST ALLOCATE" - then
            // we have to split the pipe.
            //
            if ((AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) &&
                (FramingDelta & KS_FramingChangeAllocator) ) {

                if (GetFramingFixedFromFramingByMemoryType(FramingEx, AllocEx->MemoryType, &FramingExFixed) ) {
                    if (FramingExFixed.MemoryFlags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {

                        CreateSeparatePipe(KsPin, PinType);
                        *FlagChange = 1;

                        FlagDone = 1;
                    }
                }
            }

            if (! FlagDone) {
                //
                // Handle memory type change in this pin.
                //
                if (FramingDelta & KS_FramingChangeMemoryType) {

                    if (AllocEx->LogicalMemoryType == KS_MemoryTypeDontCare) {

                        if (GetFramingFixedFromFramingByLogicalMemoryType(FramingEx, KS_MemoryTypeAnyHost, &FramingExFixed) ) {

                            GetLogicalMemoryTypeFromMemoryType(FramingExFixed.MemoryType, FramingExFixed.MemoryFlags, &LogicalMemoryType);
                            if (LogicalMemoryType != KS_MemoryTypeDontCare) {
                                //
                                // Try to change 'dont care' pipe into this pin memory type
                                // if pipe dimensions allow.
                                //
                                if ( CanPipeUseMemoryType(KsPin, PinType, FramingExFixed.MemoryType, LogicalMemoryType, TRUE, FALSE) ) {
                                    *FlagChange = 1;
                                }
                                else {
                                    CreateSeparatePipe(KsPin, PinType);
                                    *FlagChange = 1;

                                    FlagDone = 1;
                                }
                            }
                        }
                        else {
                            //
                            // pin doesn't explicitly support host memory types.
                            //
                            if (IsHostSystemBus(BusLast) ) {
                                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTER: ConnectPipes - Framing doesn't specify host memory, but medium does.") ));
                                hr = E_FAIL;
                            }
                            else {
                                //
                                // The put pin is connected via non-host bus. Its current pipe uses host memory.
                                // So this pipe can't go thru put pin.
                                //
                                CreateSeparatePipe(KsPin, PinType);
                                *FlagChange = 1;

                                FlagDone = 1;
                            }
                        }
                    }
                    else {
                        //
                        // Pipe has fixed memory type.
                        // We will try to have KsPin to reside on its original pipe.
                        //
                        if (GetFramingFixedFromFramingByMemoryType(FramingEx, AllocEx->MemoryType, &FramingExFixed) ) {
                            if ( ! CanPipeUseMemoryType(KsPin, PinType, AllocEx->MemoryType, AllocEx->LogicalMemoryType, TRUE, FALSE) ) {
                                CreateSeparatePipe(KsPin, PinType);
                                *FlagChange = 1;

                                FlagDone = 1;
                            }
                        }
                        else {
                            //
                            // this pin doesn't support this pipe's memory.
                            //
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection: Pin doesn't support its old pipe memory") ));

                            // RSL CreateSeparatePipe(KsPin, PinType);
                            // *FlagChange = 1;

                            FlagDone = 1;
                        }
                    }
                }

                if ( SUCCEEDED(hr) && (! FlagDone) ) {
                    //
                    // Handle dimensions change in KsPin framing (ranges, compression).
                    //
                    if ( (FramingDelta & KS_FramingChangeCompression ) ||
                        (FramingDelta & KS_FramingChangePhysicalRange) ||
                        (FramingDelta & KS_FramingChangeOptimalRange ) ) {

                        *FlagChange = 1;

                        if ( ! SUCCEEDED (ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT) )) {
                            CreateSeparatePipe(KsPin, PinType);
                        }
                    }
                }
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection rets %x FlagChange=%d"), hr, *FlagChange));

    return hr;

}


STDMETHODIMP
ConnectPipeToUserModePin(
    IN IKsPin* OutKsPin,
    IN IMemInputPin* InMemPin
    )
/*++

Routine Description:

    Connecting kernel pipe to user-mode pin.

    User-mode pins do not currently support framing, they only support simple allocators.
    If user-mode input pin has its own allocator handler, then we will use this allocator handler for kernel pin.
    Otherwise, there is no way to know about user-mode pin allocator preferences anyway,
    (except, of course, that it must be a user-mode memory), so we will change our
    system of pipes to satisfy just one condition - to have a user-mode memory termination.


Arguments:

    OutKsPin -
        kernel mode output pin.

    InMemPin -
        user mode input pin.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IMemAllocator*             UserMemAllocator;
    IMemAllocator*             OutMemAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    PKSALLOCATOR_FRAMING_EX    OutFramingEx;
    FRAMING_PROP               OutFramingProp;
    ALLOCATOR_PROPERTIES       Properties, ActualProperties;
    HRESULT                    hr;
    BOOL                       UserAllocProperties = FALSE;
    ULONG                      NumPinsInPipe;
    IKsPinPipe*                OutKsPinPipe;
    ULONG                      PropertyPinType;
    GUID                       Bus;
    ULONG                      FlagChange;
    BOOL                       IsSpecialOutputRequest = FALSE;
    IKsPin*                    InKsPin;
    ULONG                      OutSize, InSize;

    ASSERT (InMemPin && OutKsPin);


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipeToUserModePin. OutKsPin=%x"), OutKsPin));

    //
    // Process any changes on output pin.
    //
    hr = ResolvePipeOnConnection(OutKsPin, Pin_Output, FALSE, &FlagChange);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    RtlZeroMemory( &Properties, sizeof( Properties ) );

    //
    // sanity check - the only possible connection to user mode is via HOST_BUS
    //
    GetBusForKsPin(OutKsPin, &Bus);

    if (! IsHostSystemBus(Bus) ) {
        //
        // Don't fail, as there are some weird video port filters that connect via non-host-bus with the user-mode filters.
        //
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN FILTERS: ConnectPipeToUserModePin. BUS is not HOST_BUS.") ));
    }

    if (SUCCEEDED(hr) ) {
        //
        // see if output kernel pin can connect to user mode.
        //
        GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_Update);

        //
        // Don't enforce this yet.
        //
#if 0
        if (OutFramingProp == FramingProp_Ex) {

            KS_FRAMING_FIXED           OutFramingExFixed;

            if (! GetFramingFixedFromFramingByLogicalMemoryType(OutFramingEx, KS_MemoryTypeUser, &OutFramingExFixed) ) {
                if (! GetFramingFixedFromFramingByLogicalMemoryType(OutFramingEx, KS_MemoryTypeDontCare, &OutFramingExFixed) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTERS: ConnectPipeToUserModePin. Out framing doesn't support USER mode memory. Connection impossible.") ));
                    hr = E_FAIL;
                }
            }
        }
#endif

        //
        // Connection is possible.
        //
        ComputeNumPinsInPipe(OutKsPin, Pin_Output, &NumPinsInPipe);

        OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );

        if (NumPinsInPipe > 1) {
            //
            // In intermediate version we split the pipe: so the pipe leading to(from) user mode pin
            // will always have just 1 kernel pin.
            //
            // Note: decrementing of RefCount for the original pipe happens inside CreateSeparatePipe.
            //
            CreateSeparatePipe(OutKsPin, Pin_Output);
            OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        }

        //
        // get downstream allocator properties
        //
        hr = InMemPin->GetAllocatorRequirements( &Properties);
        if ( SUCCEEDED( hr )) {
            UserAllocProperties = TRUE;
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. UserAllocProperties exist: Prop=%d, %d, %d"),
                    Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));
        }

        UserMemAllocator = NULL;
        InMemPin->GetAllocator( &UserMemAllocator );

        //
        // decide which pin will determine base allocator properties.
        //
        if (UserAllocProperties) {
            if (OutFramingProp != FramingProp_None) {
                PropertyPinType = Pin_All;
            }
            else {
                PropertyPinType = Pin_User;
            }
        }
        else {
            PropertyPinType = Pin_Output;
        }

        //
        // See if connecting kernel-mode filter requires KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO (e.g. MsTee)
        //
        if ( ! (IsSpecialOutputRequest = IsSpecialOutputReqs(OutKsPin, Pin_Output, &InKsPin, &OutSize, &InSize ) )) {
            InSize = 0;
        }

        //
        // Try to use an existing user-mode input pin's allocator first.
        //
        SetUserModePipe(OutKsPin, Pin_Output, &Properties, PropertyPinType, InSize);

        //
        // decide which pin will be an allocator handler.
        //
        if (UserMemAllocator) {

            if ((FramingProp_None == OutFramingProp) ||
                !(KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE & OutFramingEx->FramingItem[0].MemoryFlags)) {
                // Either the pin has no particular framing requirements or
                // it is not requiring a kernel allocator, so we'll try use mode first.

                DbgLog(( LOG_MEMORY, 2, TEXT("PIPES UserAlloc. ConnectPipeToUserModePin. PinType=%d. Wanted Prop=%d, %d, %d"),
                         PropertyPinType, Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));

                hr = UserMemAllocator->SetProperties(&Properties, &ActualProperties);

                DbgLog(( LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. ActualProperties=%d, %d, %d hr=%x"),
                         ActualProperties.cBuffers, ActualProperties.cbBuffer, ActualProperties.cbAlign, hr));

                //
                // Make sure that actual properties are usable.
                //
                if (SUCCEEDED(hr) && ActualProperties.cbBuffer) {

                    hr = InMemPin->NotifyAllocator( UserMemAllocator, FALSE );
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. NotifyAllocator rets %x"), hr ));
                    
                    if (SUCCEEDED(hr)) {
                        
                        IMemAllocatorCallbackTemp* AllocatorNotify;

                        //
                        // If this allocator supports the new notification interface, then
                        // use it. This may force this own filter's allocator to be used.
                        // Don't set up notification until Commit time.
                        //
                        if (SUCCEEDED(UserMemAllocator->QueryInterface(__uuidof(IMemAllocatorCallbackTemp), reinterpret_cast<PVOID*>(&AllocatorNotify)))) {
                            AllocatorNotify->Release();
                            hr = OutKsPin->KsReceiveAllocator(UserMemAllocator);
                            }
                        else {
                            DbgLog((LOG_MEMORY, 0, TEXT("PIPES ConnectPipeToUserModePin. Allocator does not support IMemAllocator2")));
                            hr = E_NOINTERFACE;
                            } // if ... else
                        } // if (SUCCEEDED(hr))
                    } // if (SUCCEEDED(hr) && ActualProperties.cbBuffer)
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN ConnectPipeToUserModePin. ActualProperties are not satisfactory") ));
                    } // else
                if (FAILED(hr)) {
                    SAFERELEASE( UserMemAllocator );
                    }
            } // if ((FramingProp_None == OutFramingProp) || ...
        else {
            // Kernel mode allocator required and framing requirements are present
            SAFERELEASE( UserMemAllocator );
            } // else
        } // if (UserMemAllocator)

        if (!UserMemAllocator) {
            //
            // We are here only if the user-mode allocator is not useful and we will create our own.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipeToUserModePin. KsProxy user-mode allocator. PinType=%d"),
                    PropertyPinType ));
            //
            // communicate new allocator handler and new properties (part of new allocator) to user mode pin.
            //
            OutKsAllocator->KsSetAllocatorMode(KsAllocatorMode_User);

            GetInterfacePointerNoLockWithAssert(OutKsAllocator, __uuidof(IMemAllocator), OutMemAllocator, hr);

            hr = OutMemAllocator->SetProperties(&Properties, &ActualProperties);

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. ActualProperties=%d, %d, %d hr=%x"),
                    ActualProperties.cBuffers, ActualProperties.cbBuffer, ActualProperties.cbAlign, hr));

            if ( SUCCEEDED( hr ) ) {
                hr = InMemPin->NotifyAllocator( OutMemAllocator, FALSE );
                if (SUCCEEDED(hr)) {
                    OutKsPin->KsReceiveAllocator(OutMemAllocator);
                }
            }
        }
        else {
            SAFERELEASE( UserMemAllocator );
        }
    }

    if ( SUCCEEDED( hr ) && IsSpecialOutputRequest && (ActualProperties.cbBuffer < (long) InSize) ) {
        //
        // We haven't succeeded sizing the output user-mode pipe. Lets try to resize the input pipe (WRT this k.m. filter).
        //
        if (! CanResizePipe(InKsPin, Pin_Input, ActualProperties.cbBuffer) ) {
            //
            // Don't fail. Just log.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR ConnectPipeToUserModePin. Couldn't resize pipes InKsPin=%x"), InKsPin));
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. Rets %x"), hr));

    return hr;

}


STDMETHODIMP
DisconnectPins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT BOOL* FlagBypassBaseAllocators
    )
/*++

Routine Description:

    Handling disconnecting pins allocators.

Arguments:

    KsPin -
        kernel mode pin at the pipe break point.

    PinType -
        KsPin type.

    FlagBypassBaseAllocators -
        indicates whether or not the base allocators handlers should be bypassed.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    IPin*                      ConnectedPin;
    IKsPin*                    ConnectedKsPin;
    HRESULT                    hr;
    IKsAllocatorEx*            KsAllocator;
    IKsAllocatorEx*            ConnectedKsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    KS_LogicalMemoryType       OrigLogicalMemoryType;
    GUID                       OrigMemoryType;
    ULONG                      AllocatorHandlerLocation;
    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                ConnectedKsPinPipe;



    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DisconnectPins entry KsPin=%x, PinType=%d"), KsPin, PinType ));

    *FlagBypassBaseAllocators = TRUE;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    //
    // Retrieve the original pipe properties before destroying access to it.
    //
    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    AllocEx = KsAllocator->KsGetProperties();

    OrigLogicalMemoryType = AllocEx->LogicalMemoryType;
    OrigMemoryType = AllocEx->MemoryType;

    ConnectedPin = KsPinPipe->KsGetConnectedPin();
    if (ConnectedPin) {
        if (! IsKernelPin(ConnectedPin) ) {
            //
            // Connected pin is a user-mode pin.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DisconnectPins - from User Mode") ));

            //
            // Well, m_Connected may be set, but it does not mean that the pins had completed their connection.
            // We need to look at our internal pipes state to see if the reported connection is in fact real.
            //
            if ( (PinType == Pin_Output) && (! HadKernelPinBeenConnectedToUserPin(KsPin, KsAllocator) ) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DisconnectPins: never been connected !") ));
            }
            else {
                //
                // Currently, one-pin-pipe is the only pipe available for user-mode pins connections.
                //
                *FlagBypassBaseAllocators = FALSE;

                //
                // Don't delete the pipe that hosts a user-mode KsProxy allocator.
                //
                if (KsAllocator->KsGetAllocatorMode() != KsAllocatorMode_User) {
                    ULONG   numPins = 0;
                    ComputeNumPinsInPipe( KsPin, PinType, &numPins );
                    if (numPins > 1) {
                        RemovePinFromPipe( KsPin, PinType );
                    }
                    else {
                        KsPinPipe->KsSetPipe( NULL );
                        KsPin->KsReceiveAllocator( NULL );
                    }
                }
            }
        }
        else {
            GetInterfacePointerNoLockWithAssert(ConnectedPin, __uuidof(IKsPin), ConnectedKsPin, hr);

            //
            // Connected pin is a kernel-mode pin.
            //
            if (PinType == Pin_Output) {
                //
                // Otherwise: the pipe has been already split when we processed the disconnect
                // on the output pin.
                // So, we need to only take care of possible framing change on input.
                //
                //
                // Sometimes we get the disconnect when pins have not been connected yet.
                // Handle this situation gracefully for pipes by testing the pipe pointers
                // on both pins.
                //
                GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                if (KsAllocator == ConnectedKsAllocator) {
                    //
                    // Output pins disconnect operation handles the pipe splitting.
                    //
                    // Also, remember the location of the allocator handler (if exists) relative to breaking point.
                    //
                    GetAllocatorHandlerLocation(ConnectedKsPin, Pin_Input, KS_DIRECTION_ALL, NULL, NULL, &AllocatorHandlerLocation);
                    //
                    // If allocator handler pin is found, then AllocatorHandlerLocation can be either Pin_Inside_Pipe
                    // (upstream from KsPin, including KsPin)  or Pin_Outside_Pipe (downstream from KsPin).
                    //

                    //
                    // Split the pipe - creates two pipes out of the original one and destroys the original one.
                    //
                    if (!SplitPipes (KsPin, ConnectedKsPin)) {
                        hr = E_FAIL;
                    }

                    if (SUCCEEDED (hr)) {
                        //
                        // Resolve both new pipes taking into consideration original pipe's properties.
                        //
                        hr = ResolveNewPipeOnDisconnect(KsPin, Pin_Output, OrigLogicalMemoryType, OrigMemoryType, AllocatorHandlerLocation);
                    }

                    if (SUCCEEDED( hr )) {
                        //
                        // AllocatorHandlerLocation was computed relative to KsPin, so we need to reverse it
                        // for the ConnectedKsPin-based pipe.
                        //
                        if (AllocatorHandlerLocation == Pin_Outside_Pipe) {
                            AllocatorHandlerLocation = Pin_Inside_Pipe;
                        }
                        else if (AllocatorHandlerLocation == Pin_Inside_Pipe) {
                            AllocatorHandlerLocation = Pin_Outside_Pipe;
                        }

                        hr = ResolveNewPipeOnDisconnect(ConnectedKsPin, Pin_Input, OrigLogicalMemoryType, OrigMemoryType, AllocatorHandlerLocation);
                    }
                }
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES DisconnectPins rets %x, FlagBypass=%d"), hr, *FlagBypassBaseAllocators ));

    return  hr;
}


STDMETHODIMP
ResolveNewPipeOnDisconnect(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_LogicalMemoryType OldLogicalMemoryType,
    IN GUID OldMemoryType,
    IN ULONG AllocatorHandlerLocation
    )
/*++

Routine Description:

    Resolves the pipe defined by KsPin, considering original pipe memory type.

Arguments:

    KsPin -
        pin

    PinType -
        KsPin type

    OldLogicalMemoryType -
        original pipe's LogicalMemoryType

    OldMemoryType -
        original pipe's MemoryType

    AllocatorHandlerLocation -
        location of the original allocator handler relative to KsPin.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    ULONG                      FlagChange;
    HRESULT                    hr;
    IKsPinPipe*                KsPinPipe;
    BOOL                       IsNeedResolvePipe = 1;
    BOOL                       FlagDone = 0;


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolveNewPipeOnDisconnect entry KsPin=%x"), KsPin));

    ASSERT(KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    //
    // By default set the memory type from the original pipe.
    // It may get updated below.
    //
    AllocEx->MemoryType = OldMemoryType;
    AllocEx->LogicalMemoryType = OldLogicalMemoryType;

    //
    // Process any changes on this pin.
    //
    hr = ResolvePipeOnConnection(KsPin, PinType, TRUE, &FlagChange);

    if ( SUCCEEDED( hr ) ) {

        if (FlagChange) {
            //
            // We have solved the pipe in the function above.
            // No need to solve it again here.
            //
            IsNeedResolvePipe = 0;
        }
        else {
            //
            // Lets see if we can relax the new pipe.
            //
            if (OldLogicalMemoryType != KS_MemoryTypeDontCare) {

                if ( DoesPipePreferMemoryType(KsPin, PinType, KSMEMORY_TYPE_DONT_CARE, OldMemoryType, TRUE) ) {
                    // IsNeedResolvePipe = 0;
                    FlagDone = 1;
                }
            }

            if (! FlagDone) {
                //
                // In case we had a specific memory type in the original pipe, and
                // a physical memory range, and an allocator handler pin, then only one of the two
                // new pipes will have such allocator pin.
                //
                // Handle the case when the original allocator handler resides on different pipe now.
                //
                if (AllocatorHandlerLocation != Pin_Inside_Pipe) {

                    if (OldLogicalMemoryType == KS_MemoryTypeDeviceHostMapped) {
                        //
                        // KS_MemoryTypeDeviceHostMapped means that pin knows how to allocate device memory.
                        // Since the allocator handler pin from the original pipe is not on this pipe,
                        // we try to resolve the allocator (and to relax the pipe).
                        //
                        if ( (! DoesPipePreferMemoryType(KsPin, PinType, KSMEMORY_TYPE_KERNEL_PAGED, OldMemoryType, TRUE) ) &&
                             (! DoesPipePreferMemoryType(KsPin, PinType, KSMEMORY_TYPE_KERNEL_NONPAGED, OldMemoryType, TRUE) ) ) {

                            if ( OldLogicalMemoryType != KS_MemoryTypeDontCare) {
                                AssignPipeAllocatorHandler(KsPin, PinType, OldMemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
                            }
                        }
                    }
                }
            }
        }
    }


    if (SUCCEEDED (hr) && IsNeedResolvePipe) {
        hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT);
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolveNewPipeOnDisconnect rets %x"), hr));

    return  hr;
}


STDMETHODIMP_(BOOL)
WalkPipeAndProcess(
    IN IKsPin* RootKsPin,
    IN ULONG RootPinType,
    IN IKsPin* BreakKsPin,
    IN PWALK_PIPE_CALLBACK CallerCallback,
    IN PVOID* Param1,
    IN PVOID* Param2
    )
/*++

Routine Description:

    Walks the pipe defined by its root pin downstream.

    Because of possible multiple read-only downstream connections, the pipe can be
    generally represented as a tree.

    This routine walks the pipe layer by layer downstream starting with RootKsPin.
    For each new pin found, the supplied CallerCallback is called passing thru the
    supplied Param1 and Param2.

    CallerCallback may return IsDone=1, indicating that the walking process should
    immediately stop.

    If CallerCallback never sets IsDone=1, then the tree walking process is continued
    until all the pins on this pipe are processed.

    If BreakKsPin is not NULL, then BreakKsPin and all the downstream pins starting at
    BreakKsPin are not enumerated.
    This is used when we want to split RootKsPin-tree at BreakKsPin point.

    NOTE: It is possible to change the algorithm to use the search handles, and do something
    like FindFirstPin/FindNextPin - but it is more complex and less efficient. On the other hand,
    it is more generic.

Arguments:

    RootKsPin -
        root pin for the pipe.

    RootPinType -
        root pin type.

    BreakKsPin -
        break pin for the pipe.

    CallerCallback -
        defined above.

    Param1 -
        first parameter for CallerCallback

    Param2 -
        last parameter for CallerCallback


Return Value:

    TRUE on success.

--*/
{


#define INCREMENT_PINS  25

    IKsPin**            InputList;
    IKsPin**            OutputList = NULL;
    IKsPin**            TempList;
    IKsPin*             InputKsPin;
    ULONG               CountInputList = 0;
    ULONG               AllocInputList = INCREMENT_PINS;
    ULONG               CountOutputList = 0;
    ULONG               AllocOutputList = INCREMENT_PINS;
    ULONG               CurrentPinType;
    ULONG               i, j, Count;
    BOOL                RetCode = TRUE;
    BOOL                IsDone = FALSE;
    HRESULT             hr;
    IKsAllocatorEx*     KsAllocator;
    IKsPinPipe*         KsPinPipe;
    BOOL                IsBreakKsPinHandled;



    if (BreakKsPin) {
        IsBreakKsPinHandled = 0;
    }
    else {
        IsBreakKsPinHandled = 1;
    }

    //
    // allocate minimum memory for both input and output lists.
    //

    InputList = new IKsPin*[ INCREMENT_PINS ];
    if (! InputList) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new InputList") ));
        RetCode = FALSE;
    }
    else {
        OutputList = new IKsPin*[ INCREMENT_PINS ];
        if (! OutputList) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList") ));
            RetCode = FALSE;
        }
    }

    if (RetCode) {
        //
        // get the pipe pointer from RootKsPin as a search key for all downstream pins.
        //
        GetInterfacePointerNoLockWithAssert(RootKsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

        //
        // depending on the root pin type, prepare the lists and counts to enter the main tree walking loop.
        //
        if (RootPinType == Pin_Input) {
            InputList[0] = RootKsPin;
            CountInputList = 1;
        }
        else {
            //
            // there could be multiple output pins at the same level with this root pin.
            //
            if (! FindConnectedPinOnPipe(RootKsPin, KsAllocator, TRUE, &InputKsPin) ) {
                OutputList[0] = RootKsPin;
                CountOutputList = 1;
            }
            else {
                //
                // first - get the count of connected output pins.
                //
                if (! (RetCode = FindAllConnectedPinsOnPipe(InputKsPin, KsAllocator, NULL, &Count) ) ) {
                    ASSERT(0);
                }
                else {
                    if (Count > AllocOutputList) {
                        AllocOutputList = ( (Count/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                        delete [] OutputList;

                        OutputList = new IKsPin*[ AllocOutputList ];
                        if (! OutputList) {
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList %d"),
                                    AllocOutputList ));

                            RetCode = FALSE;
                        }
                    }

                    if (RetCode) {
                        //
                        // fill the pins.
                        //
                        if (! FindAllConnectedPinsOnPipe(InputKsPin, KsAllocator, &OutputList[0], &Count) ) {
                            ASSERT(0);
                            RetCode = FALSE;
                        }

                        CountOutputList = Count;
                    }
                }
            }
        }

        if (RetCode) {
            CurrentPinType = RootPinType;

            //
            // main tree walking loop.
            //
            do {
                if (CurrentPinType == Pin_Input) {
                    //
                    // remove the BreakKsPin from the InputList if found.
                    //
                    if (! IsBreakKsPinHandled) {
                        for (i=0; i<CountInputList; i++) {
                            if (InputList[i] == BreakKsPin) {
                                for (j=i; j<CountInputList-1; j++) {
                                    InputList[j] = InputList[j+1];
                                }
                                CountInputList--;
                                IsBreakKsPinHandled = 1;
                                break;
                            }
                        }
                    }

                    //
                    // process current layer.
                    //
                    if (CountInputList) {
                        for (i=0; i<CountInputList; i++) {
                            RetCode = CallerCallback( InputList[i], Pin_Input, Param1, Param2, &IsDone);
                            if (IsDone) {
                                break;
                            }
                        }

                        if (IsDone) {
                            break;
                        }

                        //
                        // Build next layer
                        //
                        CountOutputList = 0;

                        for (i=0; i<CountInputList; i++) {

                            if (FindAllConnectedPinsOnPipe(InputList[i], KsAllocator, NULL, &Count) ) {

                                Count += CountOutputList;

                                if (Count > AllocOutputList) {
                                    AllocOutputList = ( (Count/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                                    TempList = OutputList;

                                    OutputList = new IKsPin*[ AllocOutputList ];
                                    if (! OutputList) {
                                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList %d"),
                                                AllocOutputList ));

                                        RetCode = FALSE;
                                        break;
                                    }

                                    if (TempList) {
                                        if (CountOutputList) {
                                            MoveMemory(OutputList, TempList, CountOutputList * sizeof(OutputList[0]));
                                        }
                                        delete [] TempList;
                                    }
                                }

                                if (! (RetCode = FindAllConnectedPinsOnPipe(InputList[i], KsAllocator, &OutputList[CountOutputList], &Count) ) ) {
                                    ASSERT(0);
                                    break;
                                }

                                CountOutputList += Count;
                            }
                        }

                        CurrentPinType = Pin_Output;
                    }
                    else {
                        break;
                    }

                }
                else { // Output
                    //
                    // remove the BreakKsPin from the OutputList if found.
                    //
                    if (! IsBreakKsPinHandled) {
                        for (i=0; i<CountOutputList; i++) {
                            if (OutputList[i] == BreakKsPin) {
                                for (j=i; j<CountOutputList-1; j++) {
                                    OutputList[j] = OutputList[j+1];
                                }
                                CountOutputList--;
                                IsBreakKsPinHandled = 1;
                                break;
                            }
                        }
                    }

                    if (CountOutputList) {
                        for (i=0; i<CountOutputList; i++) {
                            RetCode = CallerCallback( OutputList[i], Pin_Output, Param1, Param2, &IsDone);
                            if (IsDone) {
                                break;
                            }
                        }

                        if (IsDone) {
                            break;
                        }

                        //
                        // Build next layer
                        //
                        CountInputList = 0;

                        for (i=0; i<CountOutputList; i++) {

                            if (FindNextPinOnPipe(OutputList[i], Pin_Output, KS_DIRECTION_DOWNSTREAM, KsAllocator, FALSE, &InputKsPin) ) {

                                InputList[CountInputList] = InputKsPin;

                                CountInputList++;
                                if (CountInputList >= AllocInputList) {
                                    AllocInputList = ( (CountInputList/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                                    TempList = InputList;

                                    InputList = new IKsPin*[ AllocInputList ];
                                    if (! InputList) {
                                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new InputList %d"),
                                                AllocInputList ));

                                        RetCode = FALSE;
                                        break;
                                    }

                                    if (TempList) {
                                        if (CountInputList) {
                                            MoveMemory(InputList, TempList,  CountInputList * sizeof(InputList[0]));
                                        }
                                        delete [] TempList;
                                    }
                                }
                            }
                        }

                        CurrentPinType = Pin_Input;
                    }
                    else {
                        break;
                    }
                }

            } while (RetCode);
        }
    }


    //
    // Possible to use IsDone in future.
    //

    if (InputList) {
        delete [] InputList;
    }

    if (OutputList) {
        delete [] OutputList;
    }


    return RetCode;

}

//
// common pipe utilities
//

STDMETHODIMP
CreatePipe(
    IN  IKsPin* KsPin,
    OUT IKsAllocatorEx** KsAllocator
    )
/*++

Routine Description:

    Creates the pipe (CKsAllocator object).

Arguments:

    KsPin -
        pin, to create a pipe on.

    KsAllocator -
        returns interface pointer to new pipe.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    CKsAllocator*    pKsAllocator;
    IPin*            Pin;
    HRESULT          hr;



    ASSERT (KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

    //
    // Create the allocator proxy
    //
    if (NULL ==
            (pKsAllocator =
                new CKsAllocator(
                    NAME("CKsAllocator"),
                    NULL,
                    Pin,
                    NULL,
                    &hr ))) {

        hr = E_OUTOFMEMORY;
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR CreatePipe E_OUTOFMEMORY on new CKsAllocator ") ));
    }
    else if (FAILED( hr )) {
        delete pKsAllocator;
    }
    else {
        //
        // Get a referenced IKsAllocatorEx
        //
        hr = pKsAllocator->QueryInterface( __uuidof(IKsAllocatorEx), reinterpret_cast<PVOID*>(KsAllocator) );
    }


    if (FAILED( hr )) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR CreatePipe rets hr=%x"), hr ));
    }
    else {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreatePipe rets KsAllocator=%x, hr=%x"), *KsAllocator, hr ));
    }

    return hr;
}


STDMETHODIMP
InitializePipeTermination(
    IN PIPE_TERMINATION* Termin,
    IN BOOL Reset
    )
/*++

Routine Description:

    Initializes termination point of the pipe.

Arguments:

    Termin -
        pipe termination

    Reset -
        1 - if pipe termination has been initialized already.
        0 - else.


Return Value:

    S_OK or an appropriate error code.

--*/
{


    Termin->PhysicalRange.MinFrameSize = 0;
    Termin->PhysicalRange.MaxFrameSize = ULONG_MAX;
    Termin->PhysicalRange.Stepping = DEFAULT_STEPPING;

    Termin->OptimalRange.Range.MinFrameSize = 0;
    Termin->OptimalRange.Range.MaxFrameSize = ULONG_MAX;
    Termin->OptimalRange.Range.Stepping = DEFAULT_STEPPING;



    Termin->Compression.RatioNumerator = 1;
    Termin->Compression.RatioDenominator = 1;
    Termin->Compression.RatioConstantMargin = 0;

    Termin->OutsideFactors = PipeFactor_None;

    Termin->Flags = 0;

    return S_OK;
}


STDMETHODIMP
InitializePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN BOOL Reset
    )
/*++

Routine Description:

    Initializes the pipe.

Arguments:

    KsAllocator -
        pipe

    Reset -
        1 - if this pipe has been initialized already.
        0 - else.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    HRESULT                    hr;



    ASSERT (KsAllocator);

    //
    // in place properties modification.
    //
    AllocEx = KsAllocator->KsGetProperties();

    AllocEx->cBuffers = 0;
    AllocEx->cbBuffer = 0;
    AllocEx->cbAlign  = 0;
    AllocEx->cbPrefix = 0;

    AllocEx->State = PipeState_DontCare;

    if ( SUCCEEDED(hr = InitializePipeTermination( &AllocEx->Input, Reset) ) &&
         SUCCEEDED(hr = InitializePipeTermination( &AllocEx->Output, Reset) ) ) {

        AllocEx->Strategy = 0;

        AllocEx->Flags = KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
        AllocEx->Weight = 0;

        AllocEx->MemoryType = KSMEMORY_TYPE_DONT_CARE;
        AllocEx->BusType = GUID_NULL;
        AllocEx->LogicalMemoryType = KS_MemoryTypeDontCare;
        AllocEx->AllocatorPlace = Pipe_Allocator_None;

        SetDefaultDimensions(&AllocEx->Dimensions);

        AllocEx->PhysicalRange.MinFrameSize = 0;
        AllocEx->PhysicalRange.MaxFrameSize = ULONG_MAX;
        AllocEx->PhysicalRange.Stepping = DEFAULT_STEPPING;


        AllocEx->PrevSegment = NULL;
        AllocEx->CountNextSegments = 0;
        AllocEx->NextSegments = NULL;


        AllocEx->InsideFactors = PipeFactor_None;

        AllocEx->NumberPins = 1;

    }

    return hr;
}


STDMETHODIMP_(BOOL)
CreatePipeForTwoPins(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType
    )
/*++

Routine Description:

    Creates a pipe connecting two pins.
    The bus and memory type for the new pipe have been decided by the caller.

Arguments:

    InKsPin -
        input pin.

    OutKsPin -
        output pin.

    ConnectBus -
        bus that connects the pins above.

    MemoryType -
        memory type that the pipe will use.

Return Value:

    TRUE

--*/
{
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    IKsAllocatorEx*            KsAllocator;
    IMemAllocator*             MemAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    HRESULT                    hr;



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreatePipeForTwoPins entry InKsPin=%x, OutKsPin=%x"),
            InKsPin, OutKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    if ( SUCCEEDED( hr = CreatePipe(OutKsPin, &KsAllocator) ) &&
         SUCCEEDED( hr = InitializePipe(KsAllocator, 0) ) ) {

        GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

        if (! OutKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
            OutKsPin->KsReceiveAllocator(MemAllocator);
        }
        else {
            ASSERT(0);
        }

        OutKsPinPipe->KsSetPipe(KsAllocator);

        if (! InKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
            InKsPin->KsReceiveAllocator(MemAllocator);
        }
        else {
            ASSERT(0);
        }

        InKsPinPipe->KsSetPipe(KsAllocator);

        AllocEx = KsAllocator->KsGetProperties();

        AllocEx->BusType = ConnectBus;
        AllocEx->MemoryType = MemoryType;

        if (! IsHostSystemBus(ConnectBus) ) {
            //
            // Set the LogicalMemoryType for non-host-system buses.
            //
            AllocEx->LogicalMemoryType = KS_MemoryTypeDeviceSpecific;
        }
        else {
            GetLogicalMemoryTypeFromMemoryType(MemoryType, KSALLOCATOR_FLAG_DEVICE_SPECIFIC, &AllocEx->LogicalMemoryType);
        }

        AllocEx->NumberPins = 2;

        //
        // Set the pipe allocator handling pin.
        //
        AssignPipeAllocatorHandler(InKsPin, Pin_Input, MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

        //
        // Resolve the pipe.
        //
        hr = ResolvePipeDimensions(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT);

        KsAllocator->Release();
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreatePipeForTwoPins rets. %x"), hr ));

    if ( SUCCEEDED(hr) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
GetPinFramingFromCache(
    IN IKsPin* KsPin,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx,
    OUT PFRAMING_PROP FramingProp,
    IN FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Reads pin framing from pin cache.

    If framing has not been read yet, or if Option = Framing_Cache_Update,
    then this routine will update the pin framing cache.

Arguments:

    KsPin -
        pin.

    FramingEx -
        pin framing pointer returned

    FramingProp -
        pin framing type returned

    Option -
        one of the FRAMING_CACHE_OPS.

Return Value:

    TRUE on success.

--*/
{
    HANDLE                   PinHandle;
    HRESULT                  hr;
    IKsObject*               KsObject;
    KSALLOCATOR_FRAMING      Framing;
    IKsPinPipe*              KsPinPipe;
    BOOL                     RetCode = TRUE;


    ASSERT (KsPin);
    ASSERT( Option >= Framing_Cache_Update );
    ASSERT( Option <= Framing_Cache_Write );

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (Option != Framing_Cache_Update) {
        //
        // forward request to the pin cache directly
        //
        /* Could check return value here, but Option check above currently guarantees this will succeed. */
        KsPinPipe->KsGetPinFramingCache(FramingEx, FramingProp, Option);
    }

    if ( (Option == Framing_Cache_Update) ||
         ( (*FramingProp == FramingProp_Uninitialized) && (Option != Framing_Cache_Write) ) )  {
        //
        // need to query the driver (pin)
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

        PinHandle = KsObject->KsGetObjectHandle();

        //
        // try to get FramingEx first
        //
        hr = GetAllocatorFramingEx(PinHandle, FramingEx);
        if (! SUCCEEDED( hr )) {
            //
            // pin doesn't support FramingEx. Lets try getting simple Framing.
            //
            hr = GetAllocatorFraming(PinHandle, &Framing);
            if (! SUCCEEDED( hr )) {
                //
                // pin doesn't support any framing properties.
                //
                *FramingProp = FramingProp_None;

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES GetPinFramingFromCache %s(%s) - FramingProp_None"),
                    KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName() ));
            }
            else {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES GetPinFramingFromCache %s(%s) FramingProp_Old %d %d %d %x %d"),
                    KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName(),
                    Framing.Frames, Framing.FrameSize, Framing.FileAlignment, Framing.OptionsFlags, Framing.PoolType));

                *FramingProp = FramingProp_Old;

                if ( ! ( (*FramingEx) = new (KSALLOCATOR_FRAMING_EX) ) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR GetPinFramingFromCache %s(%s) out of memory."),
                        KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName() ));

                    RetCode = FALSE;
                }
                else {
                    GetFramingExFromFraming(*FramingEx, &Framing);
                }
            }
        }
        else {
            *FramingProp = FramingProp_Ex;

            SetDefaultFramingExItems(*FramingEx);

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES GetPinFramingFromCache %s(%s) - FramingProp_Ex %d %d %d %x, %d"),
                KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName(),
                (*FramingEx)->FramingItem[0].Frames,  (*FramingEx)->FramingItem[0].FramingRange.Range.MaxFrameSize,
                (*FramingEx)->FramingItem[0].FileAlignment, (*FramingEx)->FramingItem[0].Flags, (*FramingEx)->CountItems));
        }

        if (RetCode) {
            if ( *FramingProp != FramingProp_None ) {
                ::ValidateFramingEx(*FramingEx);
            }

            if (Option != Framing_Cache_Update) {
                //
                // in case FramingProp was Uninitialized - we need to update both _ReadOrig and _ReadLast cache fields.
                //
                KsPinPipe->KsSetPinFramingCache(*FramingEx, FramingProp, Framing_Cache_ReadOrig);
                KsPinPipe->KsSetPinFramingCache(*FramingEx, FramingProp, Framing_Cache_ReadLast);
            }
            else {
                //
                // update the _ReadLast cache field on Update request
                //
                KsPinPipe->KsSetPinFramingCache(*FramingEx, FramingProp, Framing_Cache_ReadLast);
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetFramingExFromFraming(
    OUT KSALLOCATOR_FRAMING_EX* FramingEx,
    IN KSALLOCATOR_FRAMING* Framing
    )
/*++

Routine Description:

    Converts from KSALLOCATOR_FRAMING to KSALLOCATOR_FRAMING_EX.

Arguments:

    FramingEx -
        resulting KSALLOCATOR_FRAMING_EX.

    Framing -
        original KSALLOCATOR_FRAMING.


Return Value:

    TRUE on success.

--*/
{

    FramingEx->PinFlags = 0;
    FramingEx->PinWeight = KS_PINWEIGHT_DEFAULT;
    FramingEx->CountItems = 1;

    if (Framing->RequirementsFlags & KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY) {
        if (Framing->PoolType == PagedPool) {
            FramingEx->FramingItem[0].MemoryType = KSMEMORY_TYPE_KERNEL_PAGED;
        }
        else {
            FramingEx->FramingItem[0].MemoryType = KSMEMORY_TYPE_KERNEL_NONPAGED;
        }
    }
    else {
        //
        // device memory
        //
        // don't set KSALLOCATOR_FLAG_DEVICE_SPECIFIC flag
        //
        FramingEx->FramingItem[0].MemoryType = KSMEMORY_TYPE_DEVICE_UNKNOWN;
    }

    FramingEx->FramingItem[0].MemoryFlags = Framing->OptionsFlags;

    FramingEx->FramingItem[0].BusType = GUID_NULL;
    FramingEx->FramingItem[0].BusFlags = 0;

    FramingEx->FramingItem[0].Flags = Framing->OptionsFlags | KSALLOCATOR_FLAG_CAN_ALLOCATE | KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

    FramingEx->FramingItem[0].Frames = Framing->Frames;
    FramingEx->FramingItem[0].FileAlignment = Framing->FileAlignment;

    SetDefaultRange(&FramingEx->FramingItem[0].PhysicalRange);
    SetDefaultCompression(&FramingEx->OutputCompression);

    FramingEx->FramingItem[0].MemoryTypeWeight = KS_MEMORYWEIGHT_DEFAULT;

    FramingEx->FramingItem[0].FramingRange.Range.MinFrameSize  = Framing->FrameSize;
    FramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize  = Framing->FrameSize;
    FramingEx->FramingItem[0].FramingRange.Range.Stepping  = DEFAULT_STEPPING;
    FramingEx->FramingItem[0].FramingRange.InPlaceWeight = 0;
    FramingEx->FramingItem[0].FramingRange.NotInPlaceWeight = 0;

    return TRUE;
}


STDMETHODIMP_(VOID)
GetFramingFromFramingEx(
    IN KSALLOCATOR_FRAMING_EX* FramingEx,
    OUT KSALLOCATOR_FRAMING* Framing
    )
/*++

Routine Description:

    Converts from KSALLOCATOR_FRAMING_EX to KSALLOCATOR_FRAMING


Arguments:

    FramingEx -
        original KSALLOCATOR_FRAMING_EX.

    Framing -
        resulting KSALLOCATOR_FRAMING.


Return Value:

    NONE.

--*/
{
    //
    // This should not be called in the intermediate model.
    //
    ASSERT(0);

}


STDMETHODIMP_(VOID)
ValidateFramingRange(
    IN OUT PKS_FRAMING_RANGE    Range
    )
{
    if ( ( Range->MinFrameSize == ULONG_MAX ) || ( Range->MinFrameSize > Range->MaxFrameSize ) ) {
        Range->MinFrameSize = 0;
    }

    if ( Range->MinFrameSize == 0 ) {
        if ( Range->MaxFrameSize == 0 ) {
            Range->MaxFrameSize = ULONG_MAX;
        }
    }
    else if ( ( Range->MaxFrameSize == 0 ) || ( Range->MaxFrameSize == ULONG_MAX ) ) {
        Range->MaxFrameSize = Range->MinFrameSize;
    }
}


STDMETHODIMP_(VOID)
ValidateFramingEx(
    IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
    )
{
    ULONG   i;

    for (i=0; i<FramingEx->CountItems; i++) {
        ValidateFramingRange(&FramingEx->FramingItem[i].FramingRange.Range);
        ValidateFramingRange(&FramingEx->FramingItem[i].PhysicalRange);

        if (! IsFramingRangeDontCare(FramingEx->FramingItem[i].PhysicalRange) ) {
            FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize =
                max( FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize,
                     FramingEx->FramingItem[i].PhysicalRange.MinFrameSize );

            FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize =
                min( FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize,
                     FramingEx->FramingItem[i].PhysicalRange.MaxFrameSize );

            if ( FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize >
                 FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize ) {

                FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize =
                    FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize;
            }

            if (FramingEx->FramingItem[i].FramingRange.InPlaceWeight == 0) {
                FramingEx->FramingItem[i].FramingRange.InPlaceWeight = 1;
            }
        }
    }
}


STDMETHODIMP_(VOID)
SetDefaultFramingExItems(
    IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
    )
{
    ULONG   i;

    for (i=0; i<FramingEx->CountItems; i++) {
        if (CanAllocateMemoryType (FramingEx->FramingItem[i].MemoryType) ) {
            FramingEx->FramingItem[i].Flags |= KSALLOCATOR_FLAG_CAN_ALLOCATE;
        }
    }
}


STDMETHODIMP_(BOOL)
SetDefaultRange(
    OUT PKS_FRAMING_RANGE  Range
)
{
    Range->MinFrameSize = 0;
    Range->MaxFrameSize = ULONG_MAX;
    Range->Stepping = DEFAULT_STEPPING;

    return TRUE;
}


STDMETHODIMP_(BOOL)
SetDefaultRangeWeighted(
    OUT PKS_FRAMING_RANGE_WEIGHTED  RangeWeighted
)
{
    SetDefaultRange(&RangeWeighted->Range);
    RangeWeighted->InPlaceWeight = 0;
    RangeWeighted->NotInPlaceWeight = 0;

    return TRUE;
}


STDMETHODIMP_(BOOL)
SetDefaultCompression(
    OUT PKS_COMPRESSION Compression
)
{
    Compression->RatioNumerator = 1;
    Compression->RatioDenominator = 1;
    Compression->RatioConstantMargin = 0;

    return TRUE;
}


STDMETHODIMP_(BOOL)
IsFramingRangeDontCare(
    IN KS_FRAMING_RANGE Range
)

{
    if ( (Range.MinFrameSize == 0) &&
         (Range.MaxFrameSize == ULONG_MAX) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsFramingRangeEqual(
    IN KS_FRAMING_RANGE* Range1,
    IN KS_FRAMING_RANGE* Range2
)

{
    if ( (Range1->MinFrameSize == Range2->MinFrameSize) &&
         (Range1->MaxFrameSize == Range2->MaxFrameSize) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsCompressionDontCare(
    IN KS_COMPRESSION Compression
)

{
    if ( (Compression.RatioNumerator == 1) && (Compression.RatioDenominator == 1) && (Compression.RatioConstantMargin == 0) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsCompressionEqual(
    IN KS_COMPRESSION* Compression1,
    IN KS_COMPRESSION* Compression2
)

{
    if ( (Compression1->RatioNumerator == Compression2->RatioNumerator) &&
         (Compression1->RatioDenominator == Compression2->RatioDenominator) &&
         (Compression1->RatioConstantMargin == Compression2->RatioConstantMargin) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
ComputeRangeBasedOnCompression(
    IN KS_FRAMING_RANGE From,
    IN KS_COMPRESSION Compression,
    OUT KS_FRAMING_RANGE* To
)

{
    ComputeUlongBasedOnCompression(From.MinFrameSize, Compression, &To->MinFrameSize);
    ComputeUlongBasedOnCompression(From.MaxFrameSize, Compression, &To->MaxFrameSize);
    To->Stepping = From.Stepping;

    return TRUE;
}


STDMETHODIMP_(BOOL)
ComputeUlongBasedOnCompression(
    IN  ULONG From,
    IN  KS_COMPRESSION Compression,
    OUT ULONG* To
    )
{


    if ( (Compression.RatioNumerator == ULONG_MAX) || (From == ULONG_MAX) ) {
        *To = ULONG_MAX;
    }
    else {
        if (Compression.RatioDenominator == 0) {
            ASSERT(0);
            return FALSE;
        }

        *To = (ULONG) (From * Compression.RatioNumerator / Compression.RatioDenominator);
    }

    return TRUE;

}


STDMETHODIMP_(BOOL)
ReverseCompression(
    IN  KS_COMPRESSION* From,
    OUT KS_COMPRESSION* To
    )

{

    To->RatioNumerator = From->RatioDenominator;
    To->RatioDenominator = From->RatioNumerator;
    To->RatioConstantMargin = From->RatioConstantMargin;

    return TRUE;


}


STDMETHODIMP_(BOOL)
MultiplyKsCompression(
    IN  KS_COMPRESSION C1,
    IN  KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
)

{

    Res->RatioNumerator = (ULONG) (C1.RatioNumerator * C2.RatioNumerator);
    Res->RatioDenominator = (ULONG) (C1.RatioDenominator * C2.RatioDenominator);
    Res->RatioConstantMargin = 0;

    return TRUE;

}


STDMETHODIMP_(BOOL)
DivideKsCompression(
    IN  KS_COMPRESSION C1,
    IN  KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
)

{

    Res->RatioNumerator = (ULONG) (C1.RatioNumerator * C2.RatioDenominator);
    Res->RatioDenominator = (ULONG) (C1.RatioDenominator * C2.RatioNumerator);
    Res->RatioConstantMargin = 0;

    return TRUE;

}


STDMETHODIMP_(BOOL)
IsGreaterKsExpansion(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2
)

{
    ASSERT(C1.RatioDenominator && C2.RatioDenominator);

    if (! (C1.RatioDenominator && C2.RatioDenominator) ) {
        return FALSE;
    }

    if ( (C1.RatioNumerator / C1.RatioDenominator) >= (C2.RatioNumerator / C2.RatioDenominator) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsKsExpansion(
    IN KS_COMPRESSION C
)

{
    if (C.RatioNumerator > C.RatioDenominator) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IntersectFrameAlignment(
    IN ULONG In,
    IN ULONG Out,
    OUT LONG* Result
)

{


    return TRUE;

}


STDMETHODIMP_(BOOL)
FrameRangeIntersection(
    IN KS_FRAMING_RANGE In,
    IN KS_FRAMING_RANGE Out,
    OUT PKS_FRAMING_RANGE Result,
    OUT PKS_OBJECTS_INTERSECTION Intersect
    )

{

    Result->MinFrameSize = max(In.MinFrameSize, Out.MinFrameSize);
    Result->MaxFrameSize = min(In.MaxFrameSize, Out.MaxFrameSize);
    Result->Stepping = max(In.Stepping, Out.Stepping);

    if (Result->MinFrameSize > Result->MaxFrameSize) {
        *Intersect = NO_INTERSECTION;
        return FALSE;
    }

    if ( (Result->MinFrameSize == In.MinFrameSize) && (Result->MaxFrameSize == In.MaxFrameSize) ) {
        if ( (Result->MinFrameSize == Out.MinFrameSize) && (Result->MaxFrameSize == Out.MaxFrameSize) ) {
            *Intersect = NONE_OBJECT_DIFFERENT;
        }
        else {
            *Intersect = OUT_OBJECT_DIFFERENT;
        }
    }
    else {
        if ( (Result->MinFrameSize == Out.MinFrameSize) && (Result->MaxFrameSize == Out.MaxFrameSize) ) {
            *Intersect = IN_OBJECT_DIFFERENT;
        }
        else {
            *Intersect = BOTH_OBJECT_DIFFERENT;
        }
    }



    return TRUE;

}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingEx(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    OUT PKS_FRAMING_FIXED FramingExFixed
    )
{

    FramingExFixed->CountItems = FramingEx->CountItems;
    FramingExFixed->PinFlags = FramingEx->PinFlags;
    FramingExFixed->OutputCompression = FramingEx->OutputCompression;
    FramingExFixed->PinWeight = FramingEx->PinWeight;

    FramingExFixed->MemoryType = FramingEx->FramingItem[0].MemoryType;
    FramingExFixed->MemoryFlags = FramingEx->FramingItem[0].MemoryFlags;

    GetLogicalMemoryTypeFromMemoryType(
        FramingExFixed->MemoryType,
        FramingExFixed->MemoryFlags,
        &FramingExFixed->LogicalMemoryType
        );

    FramingExFixed->BusType = FramingEx->FramingItem[0].BusType;
    FramingExFixed->BusFlags = FramingEx->FramingItem[0].BusFlags;
    FramingExFixed->Flags = FramingEx->FramingItem[0].Flags;
    FramingExFixed->Frames = FramingEx->FramingItem[0].Frames;
    FramingExFixed->FileAlignment = FramingEx->FramingItem[0].FileAlignment;
    FramingExFixed->PhysicalRange = FramingEx->FramingItem[0].PhysicalRange;
    FramingExFixed->MemoryTypeWeight = FramingEx->FramingItem[0].MemoryTypeWeight;
    FramingExFixed->OptimalRange = FramingEx->FramingItem[0].FramingRange;

    return TRUE;
}


STDMETHODIMP_(BOOL)
ComputeChangeInFraming(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    OUT ULONG* FramingDelta
    )
/*++

Routine Description:

    This routine checks to see if pin's framing properties, corresponding
    to MemoryType, have changed. If so, this routine returns the bitmap,
    indicating which framing properties have changed.


Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

    MemoryType -
        memory type.

    FramingDelta -
        bitmap indicating which framing properties have changed.

Return Value:

    TRUE on SUCCESS

--*/

{
    PKSALLOCATOR_FRAMING_EX  OrigFramingEx = NULL, LastFramingEx = NULL;
    FRAMING_PROP             OrigFramingProp, LastFramingProp;
    KS_FRAMING_FIXED         OrigFramingExFixed, LastFramingExFixed;
    IKsPinPipe*              KsPinPipe;
    HRESULT                  hr;
    BOOL                     retCode;


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    *FramingDelta = 0;

    //
    // Get the pin framing from Cache.
    //
    retCode = GetPinFramingFromCache(KsPin, &OrigFramingEx, &OrigFramingProp, Framing_Cache_ReadOrig);
    if (!retCode) {
        return FALSE;
    }

    //
    // Get the pin framing from driver, bypassing and updating Cache.
    //
    retCode = GetPinFramingFromCache(KsPin, &LastFramingEx, &LastFramingProp, Framing_Cache_Update);
    if (!retCode) {
        return FALSE;
    }

    if (OrigFramingProp == FramingProp_None) {
        if  (LastFramingProp != FramingProp_None) {
            //
            // First we try to get the pin framing entry that corresponds to pipe MemoryType.
            //
            if (! GetFramingFixedFromFramingByMemoryType(LastFramingEx, MemoryType, &LastFramingExFixed) ) {
                //
                // There is no MemoryType corresponding entry, so we get the first entry.
                //
                (*FramingDelta) |= KS_FramingChangeMemoryType;

                GetFramingFixedFromFramingByIndex(LastFramingEx, 0, &LastFramingExFixed);
            }

            if (LastFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {
                (*FramingDelta) |= KS_FramingChangeAllocator;
            }

            if ( (PinType != Pin_Input) && (! IsCompressionDontCare(LastFramingExFixed.OutputCompression)) ) {
                (*FramingDelta) |= KS_FramingChangeCompression;
            }

            if (! IsFramingRangeDontCare(LastFramingExFixed.PhysicalRange) ) {
                (*FramingDelta) |= KS_FramingChangePhysicalRange;
            }

            if (! IsFramingRangeDontCare(LastFramingExFixed.OptimalRange.Range) ) {
                (*FramingDelta) |= KS_FramingChangeOptimalRange;
            }
        }
    }
    else {
        if  (LastFramingProp == FramingProp_None) {
            //
            // First we try to get the pin framing entry that corresponds to pipe MemoryType.
            //
            ASSERT( NULL != OrigFramingEx );
            if (! GetFramingFixedFromFramingByMemoryType(OrigFramingEx, MemoryType, &OrigFramingExFixed) ) {
                //
                // There is no MemoryType corresponding entry, so we get the first entry.
                //
                (*FramingDelta) |= KS_FramingChangeMemoryType;

                GetFramingFixedFromFramingByIndex(OrigFramingEx, 0, &OrigFramingExFixed);
            }

            if (OrigFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {
                (*FramingDelta) |= KS_FramingChangeAllocator;
            }

            if ( (PinType != Pin_Input) && (! IsCompressionDontCare(OrigFramingExFixed.OutputCompression)) ) {
                (*FramingDelta) |= KS_FramingChangeCompression;
            }

            if (! IsFramingRangeDontCare(OrigFramingExFixed.PhysicalRange) ) {
                (*FramingDelta) |= KS_FramingChangePhysicalRange;
            }

            if (! IsFramingRangeDontCare(OrigFramingExFixed.OptimalRange.Range) ) {
                (*FramingDelta) |= KS_FramingChangeOptimalRange;
            }
        }
        else {
            //
            // Framing always existed on this pin.
            // See if it had changed.
            //
            ASSERT( NULL != OrigFramingEx );
            if (! GetFramingFixedFromFramingByMemoryType(OrigFramingEx, MemoryType, &OrigFramingExFixed) ) {
                GetFramingFixedFromFramingByIndex(OrigFramingEx, 0, &OrigFramingExFixed);
            }

            if (! GetFramingFixedFromFramingByMemoryType(LastFramingEx, MemoryType, &LastFramingExFixed) ) {
                GetFramingFixedFromFramingByIndex(LastFramingEx, 0, &LastFramingExFixed);
            }

            if (OrigFramingExFixed.MemoryType != LastFramingExFixed.MemoryType) {
                (*FramingDelta) |= KS_FramingChangeMemoryType;
            }

            if ( (OrigFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) !=
                 (LastFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {

                (*FramingDelta) |= KS_FramingChangeAllocator;
            }

            if ( (PinType != Pin_Input) &&
                 (! IsCompressionEqual(&OrigFramingExFixed.OutputCompression, &LastFramingExFixed.OutputCompression) ) ) {

                (*FramingDelta) |= KS_FramingChangeCompression;
            }

            if (! IsFramingRangeEqual(&OrigFramingExFixed.PhysicalRange, &LastFramingExFixed.PhysicalRange) ) {
                (*FramingDelta) |= KS_FramingChangePhysicalRange;
            }

            if (! IsFramingRangeEqual(&OrigFramingExFixed.OptimalRange.Range, &LastFramingExFixed.OptimalRange.Range) ) {
                (*FramingDelta) |= KS_FramingChangeOptimalRange;
            }
        }
    }

    KsPinPipe->KsSetPinFramingCache(LastFramingEx, &LastFramingProp, Framing_Cache_ReadOrig);

    return TRUE;

}


STDMETHODIMP_(BOOL)
SetDefaultDimensions(
    OUT PPIPE_DIMENSIONS Dimensions
)

{

    SetDefaultCompression(&Dimensions->AllocatorPin);
    SetDefaultCompression(&Dimensions->MaxExpansionPin);
    SetDefaultCompression(&Dimensions->EndPin);

    return TRUE;
}


STDMETHODIMP_(BOOL)
NumPinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )

{

    ULONG  NumPins = PtrToUlong(*Param1);

    NumPins++;
    (*Param1) = (PVOID) UIntToPtr(NumPins);

    return TRUE;

}


STDMETHODIMP_(BOOL)
ComputeNumPinsInPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT ULONG* NumPins
)

{

    IKsPin*   FirstKsPin;
    ULONG     FirstPinType;
    BOOL      RetCode = TRUE;

    *NumPins = 0;

    RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
    if (RetCode) {
        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, NumPinsCallback, (PVOID*) NumPins, NULL);
    }
    else {
        ASSERT(RetCode);
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
CanPinUseMemoryType(
    IN IKsPin* KsPin,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType
    )

{
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    BOOL                       RetCode = TRUE;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        if (LogicalMemoryType == KS_MemoryTypeDeviceSpecific) {
            RetCode = FALSE;
        }
    }
    else if (LogicalMemoryType == KS_MemoryTypeDeviceSpecific) {
        RetCode = GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, NULL);
    }
    else {
        if (! ( GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, NULL) ||
              (MemoryType == KSMEMORY_TYPE_DONT_CARE) ||
              (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) ) ) {

            RetCode = FALSE;
        }
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
MemoryTypeCallback(
    IN  IKsPin* KsPin,
    IN  ULONG PinType,
    IN  PVOID* Param1,
    IN  PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    GUID                    MemoryType;
    KS_LogicalMemoryType    LogicalMemoryType;
    BOOL                    RetCode;


    memcpy(&MemoryType, Param1, sizeof(GUID) );
    memcpy(&LogicalMemoryType, Param2, sizeof(KS_LogicalMemoryType) );

    RetCode = CanPinUseMemoryType(KsPin, MemoryType, LogicalMemoryType);

    if (! RetCode ) {
        *IsDone = 1;
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
CanPipeUseMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType,
    IN ULONG FlagModify,
    IN ULONG QuickTest
    )
/*++

Routine Description:

    Assumed that there is a pin capable of allocating MemoryType somewhere,
    (true for all current callers), so in case of device memory (either
    bus-specific or host-mapped) we don't test whether KsPin-pipe knows how
    to allocate device memory.

    Also, none of the current callers tries to force any "host-accessible"
    memory on the device-specific pipe.

    Was BUG-BUG: Later - to generalize this function by handling cases above.
    Not important for the intermediate model.

    SOLUTION:

    If MemoryType is "device specific" memory type, then we require that
    each pin in KsPin-pipe should explicitly support this device memory
    type GUID in its framing properties.

    For any other memory types (host-accessible):
    If there is a pin in KsPin-pipe with framing properties that do not list
    either MemoryType GUID or "wildcard" - then such a pipe doesn't support
    MemoryType.

    In any other case - KsPin-pipe can support MemoryType.


Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    MemoryType -
        memory type to test.

    LogicalMemoryType -
        logical memory type, corresponding to MemoryType above.

    FlagModify -
        if 1 - then modify KsPin's pipe properties to use the MemoryType.
        if 0 - don't change the pipe.

    QuickTest -
        if 1 - then KsPin points to resolved pipe, so quick pipe-wide test is possible.

Return Value:

    TRUE - if pipe can use given memory type.

--*/
{

    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    BOOL                       RetCode = FALSE;
    HRESULT                    hr;
    IKsPinPipe*                KsPinPipe;
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;


    //
    // Handle QuickTest case first.
    //
    if (QuickTest) {
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
        AllocEx = KsAllocator->KsGetProperties();

        if ( (AllocEx->LogicalMemoryType == LogicalMemoryType) ||
             ( (AllocEx->LogicalMemoryType == KS_MemoryTypeKernelPaged) && (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) ) ) {

            RetCode = TRUE;
        }
    }

    if (! RetCode) {
        //
        // A pipe can use MemoryType if every pin can use this MemoryType.
        //
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);

        if (RetCode) {
            RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, MemoryTypeCallback, (PVOID*) &MemoryType, (PVOID*) &LogicalMemoryType);
        }
        else {
            ASSERT(RetCode);
        }
    }

    //
    // Change pipe's memory type if requested.
    //
    if (RetCode && FlagModify) {
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
        AllocEx = KsAllocator->KsGetProperties();

        AllocEx->MemoryType = MemoryType;
        AllocEx->LogicalMemoryType = LogicalMemoryType;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanPipeUseMemoryType rets %d"), RetCode ));

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetBusForKsPin(
    IN IKsPin* KsPin,
    OUT GUID* Bus
    )
{

    KSPIN_MEDIUM    Medium;
    HRESULT         hr;


    ASSERT(KsPin);

    hr = KsPin->KsGetCurrentCommunication(NULL, NULL, &Medium);
    if (! SUCCEEDED(hr) ) {
        if (hr == VFW_E_NOT_CONNECTED) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN GetBusForKsPin: KsPin=%x not connected"), KsPin ));
        }
        else {
            ASSERT(0);
        }

        *Bus = GUID_NULL;
    }
    else {
        *Bus = Medium.Set;
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
IsHostSystemBus(
    IN GUID Bus
    )

{
    if ( (Bus == KSMEDIUMSETID_Standard) || (Bus == GUID_NULL) ) {
        return TRUE;
    }

    return FALSE;

}


STDMETHODIMP_(BOOL)
AreBusesCompatible(
    IN GUID Bus1,
    IN GUID Bus2
    )

{
    if ( (Bus1 == Bus2) ||
         ( IsHostSystemBus(Bus1) && IsHostSystemBus(Bus2) ) ) {

        return TRUE;
    }

    return FALSE;

}


STDMETHODIMP_(BOOL)
IsKernelPin(
    IN IPin* Pin
    )

{

    IKsPinPipe*  KsPinPipe;
    HRESULT      hr;



    hr = Pin->QueryInterface( __uuidof(IKsPinPipe), reinterpret_cast<PVOID*>(&KsPinPipe) );
    if (! SUCCEEDED( hr )) {
        return FALSE;
    }
    else {
        if (KsPinPipe) {
            KsPinPipe->Release();
        }
        return TRUE;
    }
}


STDMETHODIMP_(BOOL)
HadKernelPinBeenConnectedToUserPin(
    IN IKsPin* OutKsPin,
    IN IKsAllocatorEx* KsAllocator
)
/*++

Routine Description:

    Test to see if an output kernel-mode pin had been connected to a user-mode input pin.

Arguments:

    OutKsPin -
        kernel mode output pin.

    KsAllocator -
        OutKsPin's allocator.


Return Value:

    TRUE if pins had been connected.

--*/
{
    IMemAllocator*   PipeMemAllocator;
    IMemAllocator*   PinMemAllocator;
    HRESULT          hr;

    if (KsAllocator) {
        PinMemAllocator = OutKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly);
        GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), PipeMemAllocator, hr);

        if ( (KsAllocator->KsGetAllocatorMode() == KsAllocatorMode_User) && (PipeMemAllocator == PinMemAllocator) ) {
            //
            // OutKsPin's pipe hosts KsProxy user-mode base allocator.
            //
            return TRUE;
        }
        else if ( (KsAllocator->KsGetAllocatorMode() != KsAllocatorMode_User) && (PipeMemAllocator != PinMemAllocator) &&
                   PinMemAllocator ) {

            return TRUE;
        }
        else {
            return FALSE;
        }
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByMemoryType(
    IN  IKsPin* KsPin,
    IN  GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        return FALSE;
    }
    else {
        return (GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, FramingExFixed) );
    }
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    ULONG                      i;
    BOOL                       RetCode = FALSE;


    for (i=0; i<FramingEx->CountItems; i++) {
        if (FramingEx->FramingItem[i].MemoryType == MemoryType) {
            if (FramingExFixed) {
                RetCode = GetFramingFixedFromFramingByIndex(FramingEx, i, FramingExFixed);
                break;
            }
            else {
                RetCode = TRUE;
                break;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByLogicalMemoryType(
    IN IKsPin* KsPin,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        return FALSE;
    }
    else {
        return ( GetFramingFixedFromFramingByLogicalMemoryType(FramingEx, LogicalMemoryType,FramingExFixed) );
    }
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByLogicalMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    ULONG                      i;
    GUID                       MemoryType;
    BOOL                       RetCode = TRUE;


    if ( (LogicalMemoryType == KS_MemoryTypeDontCare) ||
         (LogicalMemoryType == KS_MemoryTypeKernelPaged) ||
         (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) ||
         (LogicalMemoryType == KS_MemoryTypeUser) ) {

        RetCode = GetMemoryTypeFromLogicalMemoryType(LogicalMemoryType, &MemoryType);
        ASSERT(RetCode);

        return ( GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, FramingExFixed) );
    }

    if (LogicalMemoryType != KS_MemoryTypeAnyHost) {
        ASSERT(0);
        return FALSE;
    }

    //
    // Handle KS_MemoryTypeAnyHost.
    //
    for (i=0; i<FramingEx->CountItems; i++) {
        if ( (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_DONT_CARE) ||
            (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) ||
            (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) ||
            (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_USER) ) {

            if (FramingExFixed) {
                return ( GetFramingFixedFromFramingByIndex(FramingEx, i, FramingExFixed) );
            }
            else {
                return TRUE;
            }
        }
    }

    return FALSE;

}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN BOOL FlagMustReturnFraming,
    OUT PKS_FRAMING_FIXED FramingExFixed
    )
{

    ULONG   i;


    for (i=0; i<FramingEx->CountItems; i++) {
        if (FramingEx->FramingItem[i].BusType == Bus) {
            if (FramingExFixed) {
                return ( GetFramingFixedFromFramingByIndex(FramingEx, i, FramingExFixed) );
            }
            else {
                return TRUE;
            }
        }
    }

    //
    // Special case GUID_NULL for old filters.
    //
    if (Bus == GUID_NULL) {
        if (FramingExFixed) {
            GetFramingFixedFromFramingByIndex(FramingEx, 0, FramingExFixed);
        }
        return TRUE;
    }

    //
    // In case there is no framing items corresponding to given Bus, and
    // FlagMustReturnFraming is set - return first framing.
    //
    if (FlagMustReturnFraming) {
        ASSERT(FramingExFixed);
        return ( GetFramingFixedFromFramingByIndex(FramingEx, 0, FramingExFixed) );
    }

    return FALSE;
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByIndex(
     IN PKSALLOCATOR_FRAMING_EX FramingEx,
     IN ULONG FramingIndex,
     OUT PKS_FRAMING_FIXED FramingExFixed
)

{

    if (FramingEx->CountItems < FramingIndex) {
        FramingExFixed = NULL;
        return FALSE;
    }

    FramingExFixed->CountItems = FramingEx->CountItems;
    FramingExFixed->PinFlags = FramingEx->PinFlags;
    FramingExFixed->OutputCompression = FramingEx->OutputCompression;
    FramingExFixed->PinWeight = FramingEx->PinWeight;

    FramingExFixed->MemoryType = FramingEx->FramingItem[FramingIndex].MemoryType;
    FramingExFixed->MemoryFlags = FramingEx->FramingItem[FramingIndex].MemoryFlags;

    GetLogicalMemoryTypeFromMemoryType(
        FramingExFixed->MemoryType,
        FramingExFixed->MemoryFlags,
        &FramingExFixed->LogicalMemoryType
        );

    FramingExFixed->BusType = FramingEx->FramingItem[FramingIndex].BusType;
    FramingExFixed->BusFlags = FramingEx->FramingItem[FramingIndex].BusFlags;
    FramingExFixed->Flags = FramingEx->FramingItem[FramingIndex].Flags;
    FramingExFixed->Frames = FramingEx->FramingItem[FramingIndex].Frames;
    FramingExFixed->FileAlignment = FramingEx->FramingItem[FramingIndex].FileAlignment;
    FramingExFixed->PhysicalRange = FramingEx->FramingItem[FramingIndex].PhysicalRange;
    FramingExFixed->MemoryTypeWeight = FramingEx->FramingItem[FramingIndex].MemoryTypeWeight;
    FramingExFixed->OptimalRange = FramingEx->FramingItem[FramingIndex].FramingRange;

    return TRUE;

}


STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByIndex(
    IN IKsPin* KsPin,
    IN ULONG FramingIndex,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{

    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        FramingExFixed = NULL;
        return FALSE;
    }

    if (FramingEx->CountItems < FramingIndex) {
        FramingExFixed = NULL;
        return FALSE;
    }

    return ( GetFramingFixedFromFramingByIndex(FramingEx, FramingIndex, FramingExFixed) );

}


STDMETHODIMP_(BOOL)
GetLogicalMemoryTypeFromMemoryType(
    IN GUID MemoryType,
    IN ULONG Flag,
    OUT KS_LogicalMemoryType* LogicalMemoryType
)

{
    if (MemoryType == KSMEMORY_TYPE_DONT_CARE) {
        *LogicalMemoryType = KS_MemoryTypeDontCare;
    }
    else if (MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) {
        *LogicalMemoryType = KS_MemoryTypeKernelPaged;
    }
    else if (MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) {
        *LogicalMemoryType = KS_MemoryTypeKernelNonPaged;
    }
    else if (MemoryType == KSMEMORY_TYPE_USER) {
        *LogicalMemoryType = KS_MemoryTypeUser;
    }
    else {
        //
        // device memory GUID
        //
        if (Flag & KSALLOCATOR_FLAG_DEVICE_SPECIFIC) {
            *LogicalMemoryType = KS_MemoryTypeDeviceSpecific;
        }
        else {
            *LogicalMemoryType = KS_MemoryTypeDeviceHostMapped;
        }
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
GetMemoryTypeFromLogicalMemoryType(
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT GUID* MemoryType
    )

{
    if (LogicalMemoryType == KS_MemoryTypeDontCare) {
        *MemoryType = KSMEMORY_TYPE_DONT_CARE;
    }
    else if (LogicalMemoryType == KS_MemoryTypeKernelPaged) {
        *MemoryType = KSMEMORY_TYPE_KERNEL_PAGED;
    }
    else if (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) {
        *MemoryType = KSMEMORY_TYPE_KERNEL_NONPAGED;
    }
    else if (LogicalMemoryType == KS_MemoryTypeUser) {
        *MemoryType = KSMEMORY_TYPE_USER;
    }
    else {
        return FALSE;
    }

    return TRUE;
}




STDMETHODIMP_(BOOL)
CanAllocateMemoryType(
    IN GUID MemoryType
    )
{
    if ( (MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) ||
         (MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) ||
         (MemoryType == KSMEMORY_TYPE_USER) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}



STDMETHODIMP_(BOOL)
DoesPinPreferMemoryTypeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )

{
    GUID                       FromMemoryType;
    GUID                       ToMemoryType;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    ULONG                      i;
    BOOL                       RetCode = TRUE;



    memcpy(&FromMemoryType, Param1, sizeof(GUID) );
    memcpy(&ToMemoryType, Param2, sizeof(GUID) );

    if (FromMemoryType != ToMemoryType) {
        GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

        if (FramingProp == FramingProp_None) {
            if (FromMemoryType == KSMEMORY_TYPE_DONT_CARE) {
                *IsDone = 1;
                RetCode = FALSE;
            }
        }
        else {
            for (i=0; i<FramingEx->CountItems; i++) {
                if (FramingEx->FramingItem[i].MemoryType == FromMemoryType) {
                    //
                    // FromMemoryType is listed above ToMemoryType in KsPin framing properties.
                    //
                    *IsDone = 1;
                    RetCode =FALSE;
                    break;
                }
                if (FramingEx->FramingItem[i].MemoryType == ToMemoryType) {
                    //
                    // ToMemoryType is listed above FromMemoryType in KsPin framing properties.
                    //
                    break;
                }
            }
        }

    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
DoesPipePreferMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID ToMemoryType,
    IN GUID FromMemoryType,
    IN ULONG Flag
    )
/*++

Routine Description:

    If every pin on a KsPin-pipe, that has framing properties, lists the "ToMemoryType"
    above "FromMemoryType" in its framing properties - then we say that the entire pipe prefers
    "ToMemoryType" over "FromMemoryType".

    NOTE:
    In future - consider the weights as well.


Arguments:

    KsPin -
        pin that determines a pipe.

    PinType -
        KsPin type

    ToMemoryType -
        see above

    FromMemoryType -
        see above

    Flag -
        if 1 - then modify KsPin-pipe to use "ToMemoryType", if KsPin-pipe actually prefers it.
        0 - don't modify KsPin-pipe.


Return Value:

    TRUE - if KsPin-pipe prefers "ToMemoryType" over "FromMemoryType".
    FALSE - else.

--*/
{

    IKsPin*   FirstKsPin;
    ULONG     FirstPinType;
    ULONG     RetCode = TRUE;



    if (ToMemoryType != FromMemoryType) {

        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        if (! RetCode) {
            ASSERT(RetCode);
        }
        else {
            RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, DoesPinPreferMemoryTypeCallback,
                                        (PVOID*) &FromMemoryType, (PVOID*) &ToMemoryType);

            if (RetCode && Flag) {

                IKsAllocatorEx*            KsAllocator;
                PALLOCATOR_PROPERTIES_EX   AllocEx;
                IKsPinPipe*                KsPinPipe = NULL;
                HRESULT                    hr;

                GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

                KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
                AllocEx = KsAllocator->KsGetProperties();

                AllocEx->MemoryType = ToMemoryType;
                GetLogicalMemoryTypeFromMemoryType(AllocEx->MemoryType, 0, &AllocEx->LogicalMemoryType);
            }
        }
    }

    return RetCode;
}


STDMETHODIMP
SetUserModePipe(
    IN IKsPin* KsPin,
    IN ULONG KernelPinType,
    IN OUT ALLOCATOR_PROPERTIES* Properties,
    IN ULONG PropertyPinType,
    IN ULONG BufferLimit
    )
/*++

Routine Description:

    Set the properties on the base allocator that connects kernel and user mode pins.


Arguments:

    KsPin -
        kernel pin

    KernelPinType -
        KsPin type

    Properties -
        base allocator properties

    PropertyPinType -
        type of the pin that determines the allocator properties.

    BufferLimit -
        the buffer size limit, derived from the related filter.
        If zero, then no limits are in effect.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    HRESULT                    hr;
    IKsPinPipe*                KsPinPipe;


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if (PropertyPinType == Pin_User) {
        //
        // only user pin decides on the final settings
        //
        AllocEx->cBuffers = Properties->cBuffers;
        AllocEx->cbBuffer = Properties->cbBuffer;
        AllocEx->cbAlign  = Properties->cbAlign;
        AllocEx->cbPrefix = ALLOC_DEFAULT_PREFIX;
    }
    else if (PropertyPinType == Pin_All) {
        //
        // both kernel and user pins decide on the final settings.
        //
        Properties->cBuffers = max(AllocEx->cBuffers, Properties->cBuffers);

        if (AllocEx->Flags & KSALLOCATOR_FLAG_ATTENTION_STEPPING) {
            if (! AdjustBufferSizeWithStepping(AllocEx) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR SetUserModePipe Couldn't AdjustBufferSizeWithStepping") ));
            }
        }

        if (AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) {
            Properties->cbBuffer = max(AllocEx->cbBuffer, Properties->cbBuffer);
        }
        else {
            Properties->cbBuffer = AllocEx->cbBuffer;
        }

        if (BufferLimit) {
            if (KernelPinType == Pin_Output) {
                if (AllocEx->cbBuffer < (long) BufferLimit) {
                    Properties->cbBuffer = (long) BufferLimit;
                }
            }
            else { // Pin_Input
                if (AllocEx->cbBuffer > (long) BufferLimit) {
                    Properties->cbBuffer = (long) BufferLimit;
                }
            }
        }

        Properties->cbAlign = max(AllocEx->cbAlign, Properties->cbAlign);

        AllocEx->cBuffers = Properties->cBuffers;
        AllocEx->cbBuffer = Properties->cbBuffer;
        AllocEx->cbAlign  = Properties->cbAlign;
        AllocEx->cbPrefix = Properties->cbPrefix;
    }
    else {
        //
        // only kernel pin decides on the final settings
        //
        Properties->cBuffers = AllocEx->cBuffers;

        if (BufferLimit) {
            if (KernelPinType == Pin_Output) {
                if (AllocEx->cbBuffer < (long) BufferLimit) {
                    AllocEx->cbBuffer = (long) BufferLimit;
                }
            }
            else {
                if (AllocEx->cbBuffer > (long) BufferLimit) {
                    AllocEx->cbBuffer = (long) BufferLimit;
                }
            }
        }

        if (AllocEx->Flags & KSALLOCATOR_FLAG_ATTENTION_STEPPING) {
            if (! AdjustBufferSizeWithStepping(AllocEx) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR SetUserModePipe Couldn't AdjustBufferSizeWithStepping") ));
            }
        }

        Properties->cbBuffer = AllocEx->cbBuffer;
        Properties->cbAlign =  AllocEx->cbAlign;
    }

    //
    // Consistent with current allocator scheme.
    //
    if (Properties->cBuffers == 0) {
        Properties->cBuffers = 1;
    }

    if (Properties->cbBuffer == 0) {
        Properties->cbBuffer = 1;
    }

    if (Properties->cbAlign == 0) {
        Properties->cbAlign = 1;
    }

    AllocEx->MemoryType = KSMEMORY_TYPE_USER;
    AllocEx->LogicalMemoryType = KS_MemoryTypeUser;

    return hr;

}


STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocationCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    ALLOCATOR_SEARCH           *AllocSearch;
    IKsPinPipe*                KsPinPipe;
    HRESULT                    hr;
    BOOL                       RetCode = FALSE;


    AllocSearch = (ALLOCATOR_SEARCH *) Param1;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (KsPinPipe->KsGetPipeAllocatorFlag() & 1) {
        AllocSearch->KsPin = KsPin;
        AllocSearch->PinType = PinType;
        *IsDone = 1;

        RetCode = TRUE;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocation(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorHandlerPinType,
    OUT ULONG* AllocatorHandlerLocation
    )
/*++

Routine Description:

    Finds the allocator handler pin on a given pipe.

    Also, finds the AllocatorHandlerLocation = Pin_Inside_Pipe/Pin_Outside_Pipe - relative to KsPin.
    When caller is interested in AllocatorHandlerLocation, KsPin should be the input pin that is
    the first downstream pin located outside of a pipe.

    Walk the pins on a pipe defined by KsPin. Find the pin that has the pipe allocator handler flag set.
    If no such pin found - return FALSE.

Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    Direction -
        direction relative to KsPin to look for the allocator handler.

    KsAllocatorHandlerPin -
        returned pin that will be an allocator handler.

    AllocatorHandlerPinType -
        type of the KsAllocatorHandlerPin.

    AllocatorHandlerLocation -
        see above.


Return Value:

    TRUE on success.

--*/
{

    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    IKsPin*                    BreakKsPin;
    IKsPinPipe*                KsPinPipe;
    BOOL                       RetCode = TRUE;
    HRESULT                    hr;
    ALLOCATOR_SEARCH           AllocSearch;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsAllocatorEx*            KsAllocator;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if ( (Direction == KS_DIRECTION_UPSTREAM) || (Direction == KS_DIRECTION_ALL) ) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);

        if (! RetCode) {
            ASSERT(RetCode);
        }
        else {
            //
            // even for KS_DIRECTION_ALL - we want to stop at KsPin.
            //
            BreakKsPin = KsPin;
        }
    }
    else { // KS_DIRECTION_DOWNSTREAM
        FirstKsPin = KsPin;
        FirstPinType = PinType;
        BreakKsPin = NULL;
    }

    if (RetCode) {

        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, GetAllocatorHandlerLocationCallback, (PVOID*) &AllocSearch, NULL);

        if (RetCode) {
            if (KsAllocatorHandlerPin) {
                *KsAllocatorHandlerPin = AllocSearch.KsPin;
            }

            if (AllocatorHandlerPinType) {
                *AllocatorHandlerPinType = AllocSearch.PinType;
            }

            if (AllocatorHandlerLocation) {
                *AllocatorHandlerLocation = Pin_Inside_Pipe;
            }
        }
        else if (Direction != KS_DIRECTION_ALL) {
            if (AllocatorHandlerLocation) {
                *AllocatorHandlerLocation = Pin_Outside_Pipe;
            }

            RetCode = FALSE;
        }
        else {
            //
            // Search downstream if Direction=KS_DIRECTION_ALL only.
            //
            FirstKsPin = KsPin;
            FirstPinType = PinType;
            BreakKsPin = NULL;

            RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, GetAllocatorHandlerLocationCallback, (PVOID*) &AllocSearch, NULL);

            if (RetCode) {
                if (KsAllocatorHandlerPin) {
                    *KsAllocatorHandlerPin = AllocSearch.KsPin;
                }

                if (AllocatorHandlerPinType) {
                    *AllocatorHandlerPinType = AllocSearch.PinType;
                }

                if (AllocatorHandlerLocation) {
                    *AllocatorHandlerLocation = Pin_Outside_Pipe;
                }
            }
            else {
                if (AllocatorHandlerLocation) {
                    *AllocatorHandlerLocation = Pin_None;
                }

                RetCode = FALSE;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
SplitPipes(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    )
/*++

Routine Description:

    Create two pipes out of one pipe.
    The pipe break point is determined by the parameters.

Arguments:

    OutKsPin -
        output pin on upstream filter.

    InKsPin -
        input pin on downstream filter.


Return Value:

    TRUE on success.

--*/
{
    IKsAllocatorEx*   NewKsAllocator;
    IKsPinPipe*       KsPinPipe;
    IKsAllocatorEx*   OldKsAllocator;
    HRESULT           hr;
    ULONG             RetCode = TRUE;


    //
    // First - see how many pins were on the original pipe -
    // as we will destroy it at the end of this
    //
    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    OldKsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );

    //
    // Start with input pipe - its input pin is the terminator for new pipe.
    //

    if ( SUCCEEDED( hr = CreatePipe(InKsPin, &NewKsAllocator) ) &&
         SUCCEEDED( hr = InitializePipe(NewKsAllocator, 0) ) ) {

        MovePinsToNewPipe(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT, NewKsAllocator, FALSE);

        NewKsAllocator->Release();
    }
    else {
        ASSERT(0);
        RetCode = FALSE;
    }

    //
    // output pipe
    //
    if ( SUCCEEDED( hr ) &&
         SUCCEEDED( hr = CreatePipe(OutKsPin, &NewKsAllocator) ) &&
         SUCCEEDED( hr = InitializePipe(NewKsAllocator, 0) ) ) {

        MovePinsToNewPipe(OutKsPin, Pin_Output, KS_DIRECTION_DEFAULT, NewKsAllocator, TRUE);

        NewKsAllocator->Release();
    }
    else {
        ASSERT(0);
        RetCode = FALSE;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindFirstPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** FirstKsPin,
    OUT ULONG* FirstPinType
    )
{

    IKsPin*      CurrentKsPin;
    IKsPin*      StoreKsPin;
    ULONG        CurrentPinType;
    ULONG        RetCode;


    CurrentKsPin = KsPin;
    CurrentPinType = PinType;

    do {
        StoreKsPin = CurrentKsPin;

        RetCode = FindNextPinOnPipe(StoreKsPin, CurrentPinType, KS_DIRECTION_UPSTREAM, NULL, FALSE, &CurrentKsPin);

        if (! RetCode) {
            *FirstKsPin = StoreKsPin;
            *FirstPinType = CurrentPinType;
            return (TRUE);
        }

        if (CurrentPinType == Pin_Input) {
            CurrentPinType = Pin_Output;
        }
        else {
            CurrentPinType = Pin_Input;
        }

    } while ( 1 );

}


STDMETHODIMP_(BOOL)
FindNextPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* KsAllocator,        // NULL - if same pipe.
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** NextKsPin
)

{
    IPin*             Pin;
    IKsPinPipe*       KsPinPipe;
    IKsAllocatorEx*   NextKsAllocator;
    IKsPinPipe*       NextKsPinPipe;
    HRESULT           hr;
    ULONG             RetCode = FALSE;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        if  ( ((PinType == Pin_Input) && (Direction == KS_DIRECTION_UPSTREAM)) ||
              ((PinType == Pin_Output) && (Direction == KS_DIRECTION_DOWNSTREAM))    )  {

            Pin = KsPinPipe->KsGetConnectedPin();

            if (Pin && IsKernelPin(Pin) ) {

                hr = Pin->QueryInterface( __uuidof(IKsPin), reinterpret_cast<PVOID*>(NextKsPin) );
                if ( SUCCEEDED( hr ) && (*NextKsPin) )  {
                    //
                    // Otherwise: user pin -> end of pipe
                    //
                    (*NextKsPin)->Release();

                    GetInterfacePointerNoLockWithAssert((*NextKsPin), __uuidof(IKsPinPipe), NextKsPinPipe, hr);

                    NextKsAllocator = NextKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                    if (FlagIgnoreKey || (KsAllocator == NextKsAllocator) ) {
                        RetCode = TRUE;
                    }
                }
            }
        }
        else {
            RetCode = FindConnectedPinOnPipe(KsPin, KsAllocator, FlagIgnoreKey, NextKsPin);
        }
    }

    return  RetCode;
}


STDMETHODIMP_(BOOL)
FindConnectedPinOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,        // NULL - if same pipe.
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** ConnectedKsPin
)

{
    BOOL             RetCode = FALSE;
    IKsAllocatorEx*  ConnectedKsAllocator;
    IPin*            Pin;
    ULONG            PinCount = 0;
    IPin**           PinList;
    ULONG            i;
    HRESULT          hr;
    IKsPinPipe*      KsPinPipe;
    IKsPinPipe*      ConnectedKsPinPipe;



    ASSERT(KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        //
        // find connected Pins
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

        hr = Pin->QueryInternalConnections(NULL, &PinCount);
        if ( ! (SUCCEEDED( hr ) )) {
            ASSERT( 0 );
        }
        else if (PinCount) {
            if (NULL == (PinList = new IPin*[ PinCount ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindConnectedPinOnPipe E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
            }
            else {
                hr = Pin->QueryInternalConnections(PinList, &PinCount);
                if ( ! (SUCCEEDED( hr ) )) {
                    ASSERT( 0 );
                }
                else {
                    //
                    // Find first ConnectedKsPin in the PinList array that resides on the same KsPin-pipe.
                    //
                    for (i = 0; i < PinCount; i++) {
                        GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), (*ConnectedKsPin), hr);

                        GetInterfacePointerNoLockWithAssert((*ConnectedKsPin), __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                        if (FlagIgnoreKey || (ConnectedKsAllocator == KsAllocator) ) {
                            RetCode = TRUE;
                            break;
                        }
                    }
                    for (i=0; i<PinCount; i++) {
                        PinList[i]->Release();
                    }
                }
                delete [] PinList;
            }
        }
    }

    if (! RetCode) {
        (*ConnectedKsPin) = NULL;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindAllConnectedPinsOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,
    OUT IKsPin** ListConnectedKsPins,
    OUT ULONG* CountConnectedKsPins
)

{
    BOOL             RetCode = FALSE;
    IKsAllocatorEx*  ConnectedKsAllocator;
    IPin*            Pin;
    ULONG            PinCount = 0;
    IPin**           PinList;
    ULONG            i;
    HRESULT          hr;
    IKsPinPipe*      KsPinPipe;
    IKsPin*          ConnectedKsPin;
    IKsPinPipe*      ConnectedKsPinPipe;




    ASSERT(KsPin);

    *CountConnectedKsPins = 0;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        //
        // find connected Pins
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

        hr = Pin->QueryInternalConnections(NULL, &PinCount);
        ASSERT( SUCCEEDED( hr ) );

        if ( SUCCEEDED( hr ) && (PinCount != 0) ) {

            if (NULL == (PinList = new IPin*[ PinCount ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindAllConnectedPinsOnPipe E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
            }
            else {
                hr = Pin->QueryInternalConnections(PinList, &PinCount);

                ASSERT( SUCCEEDED( hr ) );

                if ( SUCCEEDED( hr ) ) {
                    //
                    // Find all  ConnectedKsPin-s in the PinList array that resides on the same KsPin-pipe.
                    //
                    for (i = 0; i < PinCount; i++) {

                        GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), ConnectedKsPin, hr);

                        GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                        if (ConnectedKsAllocator == KsAllocator) {
                            if (ListConnectedKsPins) {
                                ListConnectedKsPins[*CountConnectedKsPins] = ConnectedKsPin;
                            }

                            (*CountConnectedKsPins)++;

                            RetCode = TRUE;
                        }
                    }
                    for (i=0; i<PinCount; i++) {
                        PinList[i]->Release();
                    }
                }
                delete [] PinList;
            }
        }
    }
    return RetCode;

}


STDMETHODIMP_(BOOL)
ResolvePhysicalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    )
/*++

Routine Description:

    Compute pipe terminal physical ranges, based on known pipe dimensions and framing physical range
    set on the MaxExpansionPin.

Arguments:

    AllocEx -
        pipe properties.

Return Value:

    TRUE on SUCCESS.

--*/
{
    KS_COMPRESSION             TempCompression;

    //
    // if pipe doesn't have real physical limits - do nothing.
    //
    if ( (AllocEx->PhysicalRange.MaxFrameSize != ULONG_MAX) && (AllocEx->PhysicalRange.MaxFrameSize != 0) ) {
        //
        // Input pipe termination.
        //
        ReverseCompression(&AllocEx->Dimensions.MaxExpansionPin, &TempCompression);
        ComputeRangeBasedOnCompression(AllocEx->PhysicalRange, TempCompression, &AllocEx->Input.PhysicalRange);

        //
        // Output pipe termination.
        //
        DivideKsCompression(AllocEx->Dimensions.EndPin, AllocEx->Dimensions.MaxExpansionPin, &TempCompression);
        ComputeRangeBasedOnCompression(AllocEx->PhysicalRange, TempCompression, &AllocEx->Output.PhysicalRange);
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
ResolveOptimalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx,
    IN KS_FRAMING_RANGE Range,
    IN ULONG PinType
    )

/*++

Routine Description:

    Compute pipe terminal optimal ranges, based on known pipe dimensions
    and known framing optimal range at the specified pipe termination.


Arguments:

    AllocEx -
        pipe properties.

    Range -
        optimal framing range at the pipe termination, specified by PinType argument.

    PinType -
        defines the pipe termination side (input vs. output).

Return Value:

    TRUE on SUCCESS.

--*/
{

    KS_COMPRESSION             TempCompression;

    if (PinType == Pin_Input) {
        ComputeRangeBasedOnCompression(Range, AllocEx->Dimensions.EndPin, &AllocEx->Output.OptimalRange.Range);
    }
    else {
        ReverseCompression ( &AllocEx->Dimensions.EndPin, &TempCompression);
        ComputeRangeBasedOnCompression(Range, TempCompression, &AllocEx->Output.OptimalRange.Range);
    }

    return TRUE;

}


STDMETHODIMP_(BOOL)
ReassignPipeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    IKsAllocatorEx*  KsAllocator = (IKsAllocatorEx*) Param1;
    IKsPinPipe*      KsPinPipe;
    IMemAllocator*   MemAllocator;
    HRESULT          hr;



    GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

    KsPin->KsReceiveAllocator(MemAllocator);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsPinPipe->KsSetPipe(KsAllocator);


    return TRUE;
}


STDMETHODIMP_(BOOL)
MovePinsToNewPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* NewKsAllocator,
    IN BOOL MoveAllPins
    )
/*++

Routine Description:
    Walk the pipe determined by KsPin.
    All pin on this pipe should join new pipe specified by NewKsAllocator.
    The old pipe should be deleted.

    NOTE:
    KsPin is a terminal pin on a pipe for current callers.
    Generalize this routine if needed.


Arguments:


    KsPin -
        pin

    PinType -
        KsPin type

    Direction -
        not currently used.

    NewKsAllocator -
        new pipe.

    MoveAllPins -
        if 1 - then move all pins on the KsPin-pipe, including the pins upstream from KsPin,
        else - move pins downstream from KsPin only, including KsPin.


Return Value:

    TRUE on success.

--*/
{

    IKsPin*         FirstKsPin;
    ULONG           FirstPinType;
    ULONG           RetCode = TRUE;




    if (MoveAllPins) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);
    }
    else {
        if (PinType != Pin_Input) {
            ASSERT(0);
            RetCode = FALSE;
        }
        else {
            FirstKsPin = KsPin;
            FirstPinType = PinType;
        }
    }

    if (RetCode) {
        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, ReassignPipeCallback, (PVOID*) NewKsAllocator, NULL);
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
CreateAllocatorCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    IKsAllocatorEx*  KsAllocator;
    HANDLE           AllocatorHandle;
    IKsPinPipe*      KsPinPipe;
    HRESULT          hr;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );

    AllocatorHandle = KsAllocator->KsCreateAllocatorAndGetHandle(KsPin);
    if (AllocatorHandle) {
        (*Param1) = (PVOID) AllocatorHandle;
        *IsDone = 1;
    }

    return TRUE;
}


STDMETHODIMP
FixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Fixes up the kernel mode pipe defined by KsPin.
    Creates a single allocator handler on every pipe.
    Creates one or more allocator pin[-s] on one selected filter on every pipe.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPin*                    FirstKsPin;
    IKsPin*                    AllocKsHandlerPin;
    IKsPin*                    AllocKsPin;
    IKsPinPipe*                KsPinPipe;
    HANDLE                     AllocatorHandle = INVALID_HANDLE_VALUE;
    BOOL                       RetCode;
    ULONG                      FirstPinType;
    HRESULT                    hr;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe entry KsPin=%x, KsAllocator=%x"), KsPin, KsAllocator ));

    //
    // check if pipe has been finalized.
    //
    if ( (AllocEx->State == PipeState_Finalized) || (AllocEx->MemoryType == KSMEMORY_TYPE_USER) ) {
        RetCode = TRUE;
    }
    else {
        //
        // In case this pipe has "don't care" properties, set default pipe values.
        //
        if (AllocEx->cBuffers == 0) {
            AllocEx->cBuffers = Global.DefaultNumberBuffers;
        }

        if (AllocEx->cbBuffer == 0) {
            AllocEx->cbBuffer = Global.DefaultBufferSize;
        }

        if (AllocEx->cbAlign == 0) {
            AllocEx->cbAlign = Global.DefaultBufferAlignment;
        }

        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);

        if (RetCode) {
            //
            // Make sure that KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO reqs are satisfied at the pipes junction points.
            //
            if (FirstPinType == Pin_Output) {
                IKsPin* InKsPin;
                ULONG OutSize, InSize;
                BOOL IsDone = FALSE;

                if ( IsSpecialOutputReqs(FirstKsPin, Pin_Output, &InKsPin, &OutSize, &InSize) )  {
                    if ( IsKernelModeConnection(FirstKsPin) ) {
                        if ( CanResizePipe(FirstKsPin, Pin_Output, InSize) ) {
                            IsDone =TRUE;
                        }
                    }

                    if (! IsDone) {
                        if ( IsKernelModeConnection(InKsPin) ) {
                            if ( CanResizePipe(InKsPin, Pin_Input, OutSize) ) {
                                IsDone =TRUE;
                            }
                        }
                    }

                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN FixupPipe CanResizePipe ret %d."), IsDone ));
                }
            }

            //
            // First, try to use assigned allocator handler.
            // There could be a problem since the old framing did not indicate KSALLOCATOR_FLAG_CAN_ALLOCATE
            //
            if ( AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL,
                                            &AllocKsHandlerPin, NULL, TRUE) ) {

                AllocatorHandle = KsAllocator->KsCreateAllocatorAndGetHandle(AllocKsHandlerPin);

                if (! AllocatorHandle) {
                    AllocatorHandle = INVALID_HANDLE_VALUE;
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe assigned allocator handler doesn't work.") ));
                }
            }
            else {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe AssignPipeAllocatorHandler failed.") ));
            }

            if (AllocatorHandle == INVALID_HANDLE_VALUE) {
                //
                // Assigned allocator handler doesn't work.
                // Try every pin from the beginning of the pipe.
                //
                RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, CreateAllocatorCallback,
                                             (PVOID*) &AllocatorHandle, NULL);
            }

            if ( (! RetCode) || (AllocatorHandle == INVALID_HANDLE_VALUE) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FixupPipe: could not assign an allocator handler.") ));
            }
            else {
                //
                // Unlike old KsProxy that was assigning an allocator to the multiple pins without choice,
                // we decided to make an allocator assignment more informative.
                //
                // In most cases, there will be a single "allocator implementer pin" on a pipe.
                // "Allocator implementer pin" (pin that handles physical frames allocation) can be different from
                // an "allocator requestor pin" (pin that manages the data flow using the services of the "allocator implementer pin").
                // Every pipe has exactly one allocator-implementer-pin and one or more allocator-requestor-pins.
                // In case there are multiple allocator-requestor-pins on one pipe, they always belong to one filter.
                //
                // To enable the new filter shell to make the intelligent optimized graph control decisions, we are
                // providing the "pipe ID" information for every pin. The pipe ID is the allocator file handle that
                // is unique for each pipe. The filter uses this handle to access the allocator file object.
                //
                RetCode = AssignAllocatorsAndPipeIdForPipePins(KsPin, PinType, AllocatorHandle, KS_DIRECTION_ALL, &AllocKsPin, NULL);

                if (! RetCode) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FixupPipe: could not find an allocator pin.") ));
                }
                else {
                    AllocEx->State = PipeState_Finalized;
                }
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe rets RetCode=%d"), RetCode ));

    if (RetCode) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }

}


STDMETHODIMP
UnfixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Unfixes up the pipe, defined by KsPin.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPinPipe*                KsPinPipe;
    HRESULT                    hr;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if (AllocEx->State == PipeState_Finalized)  {
        AllocEx->State = PipeState_RangeFixed;
    }

    return S_OK;
}


STDMETHODIMP_(BOOL)
DimensionsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{
    IKsPinPipe*                KsPinPipe;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    KS_FRAMING_FIXED           FramingExFixed;
    HRESULT                    hr;
    DIMENSIONS_DATA            *DimData;
    BOOL                       IsAllocator;
    ULONG                      Type;
    KS_COMPRESSION             TempCompression;
    KS_FRAMING_RANGE           TempRange;
    KS_FRAMING_RANGE           ResultRange;
    KS_OBJECTS_INTERSECTION    Intersect;
    BOOL                       RetCode = TRUE;


    DimData = (DIMENSIONS_DATA *) Param1;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    IsAllocator = KsPinPipe->KsGetPipeAllocatorFlag() & 1;

    //
    // Get current pin framing
    //
    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp != FramingProp_None) {
        GetFramingFixedFromFramingByIndex(FramingEx, 0, &FramingExFixed);

        //
        // handle pin compression.
        //
        if (! IsCompressionDontCare(FramingExFixed.OutputCompression) ) {
            if (PinType != Pin_Output) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES DimensionsCallback - ERROR IN FILTER: compression is set on input pin") ));
            }
            else {
                MultiplyKsCompression(DimData->Dimensions.EndPin, FramingExFixed.OutputCompression, &TempCompression);

                DimData->Dimensions.EndPin = TempCompression;

                if ( IsGreaterKsExpansion(DimData->Dimensions.EndPin, DimData->Dimensions.MaxExpansionPin) ) {
                    DimData->Dimensions.MaxExpansionPin = DimData->Dimensions.EndPin;
                }
            }
        }

        if (IsAllocator) {
            DimData->Dimensions.AllocatorPin = DimData->Dimensions.EndPin;
        }

        //
        // Handle phys. range and required optimal range framing properties.
        //
        Type = 0;
        if ( ! IsFramingRangeDontCare(FramingExFixed.PhysicalRange) ) {
            Type = 1;
        }
        else if ( (FramingProp == FramingProp_Ex) && (! (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
            DimData->Flags &= ~KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Type = 2;
        }

        if ( Type != 0 ) {
            ReverseCompression(&DimData->Dimensions.EndPin, &TempCompression);

            if (Type == 1) {
                ComputeRangeBasedOnCompression(FramingExFixed.PhysicalRange, TempCompression, &TempRange);
            }
            else {
                ComputeRangeBasedOnCompression(FramingExFixed.OptimalRange.Range, TempCompression, &TempRange);
            }

            if (! FrameRangeIntersection(TempRange, DimData->PhysicalRange, &ResultRange, &Intersect) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES DimensionsCallback - ERROR - No Phys. Range intersection") ));
                RetCode = FALSE;
                *IsDone = TRUE;
            }
            else {
                DimData->PhysicalRange = ResultRange;
            }

            //
            // since the physical range changed, update the optimal range.
            //
            if (! FrameRangeIntersection(DimData->OptimalRange.Range, DimData->PhysicalRange, &ResultRange, &Intersect) ) {
                DimData->OptimalRange.Range = DimData->PhysicalRange;
            }
            else {
                DimData->OptimalRange.Range = ResultRange;
            }

        }

        if (RetCode) {
            //
            // handle optimal range.
            //
            if (! IsFramingRangeDontCare(FramingExFixed.OptimalRange.Range) ) {

                if ( (FramingExFixed.OptimalRange.InPlaceWeight > DimData->OptimalRange.InPlaceWeight) ||
                     IsFramingRangeDontCare(DimData->OptimalRange.Range) ) {

                    ReverseCompression(&DimData->Dimensions.EndPin, &TempCompression);
                    ComputeRangeBasedOnCompression(FramingExFixed.OptimalRange.Range, TempCompression, &TempRange);

                    if (! FrameRangeIntersection(TempRange, DimData->PhysicalRange, &ResultRange, &Intersect) ) {
                        DimData->OptimalRange.Range = DimData->PhysicalRange;
                    }
                    else {
                        DimData->OptimalRange.Range = ResultRange;
                    }

                    DimData->OptimalRange.InPlaceWeight = FramingExFixed.OptimalRange.InPlaceWeight;
                }
            }

            //
            // handle number of frames for the pipe.
            //
            if (FramingExFixed.Frames > DimData->Frames) {
                DimData->Frames = FramingExFixed.Frames;
            }

            //
            // handle alignment for the pipe.
            //
            if ( (long) (FramingExFixed.FileAlignment + 1) > DimData->cbAlign) {
                DimData->cbAlign = (long) (FramingExFixed.FileAlignment + 1);
            }

            //
            // Handle stepping for the pipe.
            //
            if ( (FramingExFixed.PhysicalRange.Stepping > 1) &&
                 (DimData->PhysicalRange.Stepping < FramingExFixed.PhysicalRange.Stepping) ) {

                DimData->PhysicalRange.Stepping = FramingExFixed.PhysicalRange.Stepping;
                DimData->Flags |= KSALLOCATOR_FLAG_ATTENTION_STEPPING;
            }
            else if ( (FramingExFixed.OptimalRange.Range.Stepping > 1) &&
                      (DimData->OptimalRange.Range.Stepping < FramingExFixed.OptimalRange.Range.Stepping) ) {

                DimData->OptimalRange.Range.Stepping = FramingExFixed.OptimalRange.Range.Stepping;
                DimData->Flags |= KSALLOCATOR_FLAG_ATTENTION_STEPPING;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP
ResolvePipeDimensions(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction
    )
/*++

Routine Description:

    Resolve dimensions and framing ranges on the pipe defined by KsPin.
    Assumes that the memory type and allocator handler pin are already set on the pipe.

Arguments:

    KsPin -
        pin that defines a pipe.

    PinType -
        KsPin type.

    Direction -
        not currently used.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPin*                    FirstKsPin;
    IKsPinPipe*                KsPinPipe;
    ULONG                      FirstPinType;
    ULONG                      RetCode;
    DIMENSIONS_DATA            DimData;
    HRESULT                    hr;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           ResultRange;
    ULONG                      Scaled;
    TCHAR                      LogicalMemoryName[13], BusName[13];


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    AllocEx = KsAllocator->KsGetProperties();

    //
    // Set dimension data.
    //
    DimData.MemoryType = AllocEx->MemoryType;
    SetDefaultDimensions(&DimData.Dimensions);
    SetDefaultRange(&DimData.PhysicalRange); // resolved on first pin on pipe
    SetDefaultRangeWeighted(&DimData.OptimalRange); // resolved on first pin on pipe
    DimData.Frames = 0;
    DimData.cbAlign = 0;
    DimData.Flags = KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

    //
    // Walk the pipe and process the dimension data in DimensionsCallback.
    //
    RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
    ASSERT(RetCode);

    if (RetCode) {
        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, DimensionsCallback, (PVOID*) &DimData, NULL);

        if (RetCode) {
            //
            // Retrieve the pipe dimension data and resolve the pipe.
            //
            AllocEx->Dimensions = DimData.Dimensions;
            AllocEx->cBuffers = DimData.Frames;
            AllocEx->cbAlign = DimData.cbAlign;
            AllocEx->Flags = DimData.Flags;
            AllocEx->Input.OptimalRange.Range = DimData.OptimalRange.Range;
            AllocEx->PhysicalRange.Stepping = DimData.PhysicalRange.Stepping;

            //
            // Resolve pipe physical range.
            //
            ComputeRangeBasedOnCompression(DimData.PhysicalRange, AllocEx->Dimensions.MaxExpansionPin, &AllocEx->PhysicalRange);
            ResolvePhysicalRangesBasedOnDimensions(AllocEx);

            //
            // optimal range is always a subset of the physical range.
            //
            if (! FrameRangeIntersection(AllocEx->Input.OptimalRange.Range, AllocEx->Input.PhysicalRange, &ResultRange, &Intersect) ) {
                AllocEx->Input.OptimalRange.Range = AllocEx->Input.PhysicalRange;
            }
            else {
                AllocEx->Input.OptimalRange.Range = ResultRange;
            }

            //
            // Compute optimal range at the Output pipe termination, based on the optimal range at the Input pipe termination.
            //
            ResolveOptimalRangesBasedOnDimensions(AllocEx, AllocEx->Input.OptimalRange.Range, Pin_Input);

            //
            // Compute pipe frame size.
            //
            if (AllocEx->Input.OptimalRange.Range.MaxFrameSize != ULONG_MAX) {
                ComputeUlongBasedOnCompression(
                    AllocEx->Input.OptimalRange.Range.MaxFrameSize,
                    AllocEx->Dimensions.MaxExpansionPin,
                    &Scaled);

                AllocEx->cbBuffer = (long) Scaled;
            }
            else {
                AllocEx->cbBuffer = 0;
            }


            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolvePipeDimensions KsAlloc=%x Dim=%d/%d, %d/%d, %d/%d, Res=%d, %d, %d"),
                KsAllocator,
                AllocEx->Dimensions.AllocatorPin.RatioNumerator, AllocEx->Dimensions.AllocatorPin.RatioDenominator,
                AllocEx->Dimensions.MaxExpansionPin.RatioNumerator, AllocEx->Dimensions.MaxExpansionPin.RatioDenominator,
                AllocEx->Dimensions.EndPin.RatioNumerator, AllocEx->Dimensions.EndPin.RatioDenominator,
                AllocEx->cBuffers, AllocEx->cbBuffer, AllocEx->cbAlign));

            GetFriendlyLogicalMemoryTypeNameFromId(AllocEx->LogicalMemoryType, LogicalMemoryName);
            GetFriendlyBusNameFromBusId(AllocEx->BusType, BusName);
        }
    }

    if (RetCode) {
        hr = S_OK;
    }
    else {
        hr = E_FAIL;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolvePipeDimensions hr=%x, LMT=%s, Bus=%s, Step=%d/%d, Flags=%x"),
            hr, LogicalMemoryName, BusName,  AllocEx->Input.PhysicalRange.Stepping, AllocEx->Input.OptimalRange.Range.Stepping, AllocEx->Flags));

    return hr;

}


STDMETHODIMP
CreateSeparatePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Remove the KsPin from its current pipe and decrement RefCount on that pipe.

    Create new pipe on KsPin based on its last framing.
    Resolve the original pipe (it doesn't have the KsPin any more).

Arguments:

    KsPin -
        terminal pin on a pipe.

    PinType -
        KsPin type

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx* KsAllocator;
    IKsPin*         ConnectedKsPin;
    IKsPinPipe*     KsPinPipe;
    HRESULT         hr;


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreateSeparatePipe KsPin=%x"), KsPin));

    //
    // first - get connected pin on same filter on same pipe (if any).
    //
    FindConnectedPinOnPipe(KsPin, NULL, FALSE, &ConnectedKsPin);

    //
    // Decrement RefCount on KsPin's current pipe.
    //
    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    ASSERT(KsAllocator);

    KsPinPipe->KsSetPipe(NULL);
    KsPin->KsReceiveAllocator(NULL);

    //
    // create separate pipe on KsPin
    //
    hr = MakePipeBasedOnOnePin(KsPin, PinType, NULL);

    //
    // resolve the original pipe if exist
    //
    if (ConnectedKsPin) {
        ULONG                      ConnectedPinType;
        PALLOCATOR_PROPERTIES_EX   ConnectedAllocEx;
        IKsAllocatorEx*            ConnectedKsAllocator;
        IKsPinPipe*                ConnectedKsPinPipe;
        ULONG                      Direction;



        GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        ConnectedAllocEx = ConnectedKsAllocator->KsGetProperties();

        if (PinType == Pin_Input) {
            ConnectedPinType = Pin_Output;
            Direction = KS_DIRECTION_DOWNSTREAM;
        }
        else {
            ConnectedPinType = Pin_Input;
            Direction = KS_DIRECTION_UPSTREAM;
        }

        //
        // Update original pipe's allocator handler and resolve original pipe's dimensions.
        //
        AssignPipeAllocatorHandler(ConnectedKsPin, ConnectedPinType, ConnectedAllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
        hr = ResolvePipeDimensions(ConnectedKsPin, ConnectedPinType, Direction);
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreateSeparatePipe rets %x"), hr));

    return hr;
}


STDMETHODIMP_(BOOL)
CanAddPinToPipeOnAnotherFilter(
    IN IKsPin* PipeKsPin,
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Flag
    )
/*++

Routine Description:

    Checks to see if KsPin can be added to the pipe defined by PipeKsPin.
    This pipe exist on the connecting filter.
    If KsPin can be added - then change the pipe system according to the Flag passed (see below).

Arguments:

    PipeKsPin -
        pin defining a pipe.

    KsPin -
        pin we want to add to the pipe above.

    PinType -
        KsPin's type.

    Flag -
        0 -> don't change the pipe system.
        Pin_Move -> move KsPin from its current pipe to the PipeKsPin-pipe.
        Pin_Add -> add KsPin to the PipeKsPin-pipe.

Return Value:

    TRUE - if KsPin can be added to the pipe above.


--*/
{

    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    KS_FRAMING_FIXED           FramingExFixed;
    HRESULT                    hr;
    BOOL                       RetCode = FALSE;
    IKsPinPipe*                PipeKsPinPipe;
    IKsPinPipe*                KsPinPipe;
    IMemAllocator*             MemAllocator;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           FinalRange;
    BOOL                       FlagDone = 0;



    ASSERT(KsPin && PipeKsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanAddPinToPipeOnAnotherFilter entry PipeKsPin=%x, KsPin=%x"),
                PipeKsPin, KsPin ));


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(PipeKsPin, __uuidof(IKsPinPipe), PipeKsPinPipe, hr);

    KsAllocator = PipeKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    //
    // To not break existing graphs, we assume that if two connecting pins agree on a medium,
    // then the connection is possible.
    // We will enforce the rule to expose correct memories in the pin framing properties only
    // for the new filters that support extended framing.
    //
    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if (FramingProp == FramingProp_Ex) {
        if (! GetFramingFixedFromFramingByMemoryType(FramingEx, AllocEx->MemoryType, &FramingExFixed) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter: no MemoryType KsPin=%x"), KsPin));
            FlagDone = 1;
        }
        else {
            //
            // Check to see if both the pipe and KsPin must allocate.
            //
            if ( (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) &&
                 (AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanAddPinToPipeOnAnotherFilter - both MUST_ALLOCATE KsPin=%x"), KsPin));
                FlagDone = 1;
            }
        }
    }

    //
    // Check the physical limits intersection.
    //
    if ( (! FlagDone) && (FramingProp != FramingProp_None) ) {
        GetFramingFixedFromFramingByIndex(FramingEx, 0, &FramingExFixed);

        if (PinType == Pin_Output) {
            if (! FrameRangeIntersection(AllocEx->Input.PhysicalRange, FramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                FlagDone = 1;
            }
            else if ( (FramingProp == FramingProp_Ex) && (! (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                if (! FrameRangeIntersection(AllocEx->Input.PhysicalRange, FramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                    FlagDone = 1;
                }
            }
        }
        else {
            if (! FrameRangeIntersection(AllocEx->Output.PhysicalRange, FramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                FlagDone = 1;
            }
            else if ( (FramingProp == FramingProp_Ex) && (! (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                if (! FrameRangeIntersection(AllocEx->Output.PhysicalRange, FramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                    FlagDone = 1;
                }
            }
        }
    }

    if (! FlagDone) {
        //
        // Adding KsPin to the specified pipe is possible.
        // Perform the Move/Add/None operation as requested by Flag.
        //
        RetCode = TRUE;

        if (Flag == Pin_Move) {
            RemovePinFromPipe(KsPin, PinType);
        }

        if ( (Flag == Pin_Move) || (Flag == Pin_Add) ) {
            GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

            KsPin->KsReceiveAllocator(MemAllocator);

            KsPinPipe->KsSetPipe(KsAllocator);
            //
            // Set the pipe allocator handling pin and resolve the pipe.
            //
            AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
            hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_ALL);
            if (FAILED (hr) ) {
                RetCode = FALSE;
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanAddPinToPipeOnAnotherFilter rets. %d"), RetCode));

    return RetCode;
}


STDMETHODIMP_(BOOL)
CanMergePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID MemoryType,
    IN ULONG FlagMerge
    )
/*++

Routine Description:

    KS has already checked that MemoryType satisfies both pipes
    before calling this function.

    The only responsibility of this function is to make sure that it is
    possible to satisfy pipe physical limits and 'must allocate' requests.

Arguments:

    InKsPin -
        input pin on downstream pipe.

    OutKsPin -
        output pin on upstream pipe.

    MemoryType -
        memory type of the merged (resulting) pipe.

    FlagMerge -
        if 1 - then actually merge the pipes if possible.

Return Value:

    TRUE if pipe merge is possible.

--*/
{
    IKsPin*                    AllocInKsPin = NULL;
    IKsPin*                    AllocOutKsPin = NULL;
    KS_FRAMING_FIXED           AllocInFramingExFixed, AllocOutFramingExFixed;
    IKsAllocatorEx*            InKsAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    IKsAllocatorEx*            NewKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx, OutAllocEx, NewAllocEx;
    KS_COMPRESSION             TempCompression;
    HRESULT                    hr;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           FinalRange;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    BOOL                       RetCode = TRUE;
    TCHAR                      LogicalMemoryName[13], BusName[13];



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanMergePipes entry In=%x Out=%x"), InKsPin, OutKsPin ));

    //
    // Find the allocator handler pin for the resulting pipe.
    //
    if ( AssignPipeAllocatorHandler(InKsPin, Pin_Input, MemoryType, KS_DIRECTION_UPSTREAM, &AllocOutKsPin, NULL, FALSE) ) {
        RetCode = GetFramingFixedFromPinByMemoryType( AllocOutKsPin, MemoryType, &AllocOutFramingExFixed);
        ASSERT(RetCode);
    }

    if (RetCode &&
        AssignPipeAllocatorHandler(InKsPin, Pin_Input, MemoryType, KS_DIRECTION_DOWNSTREAM, &AllocInKsPin, NULL, FALSE) ) {

        RetCode = GetFramingFixedFromPinByMemoryType( AllocInKsPin, MemoryType, &AllocInFramingExFixed);
        ASSERT(RetCode);
    }

    if (RetCode && AllocOutKsPin && AllocInKsPin) {
        if ( (AllocOutFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) &&
            (AllocInFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {
            //
            // Pipes merge is not possible when both pins require to be the allocator handlers.
            //
            RetCode = FALSE;
        }
    }

    if (RetCode) {
        //
        // Get pipes properties
        //
        GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

        GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

        InKsAllocator = InKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
        InAllocEx = InKsAllocator->KsGetProperties();

        OutKsAllocator = OutKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
        OutAllocEx = OutKsAllocator->KsGetProperties();

        //
        // We need to resolve the pipe geometry now. See if we can satisfy the physical range.
        // Since the phys. range is reflected in both pipes termination points, we can just intersect
        // the phys. ranges of the connecting pins to see if there is a solution.
        //
        if (! FrameRangeIntersection(OutAllocEx->Output.PhysicalRange, InAllocEx->Input.PhysicalRange, &FinalRange, &Intersect) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanMergePipes Phys. intersection empty. ") ));
            RetCode = FALSE;
        }

        if (RetCode) {
            //
            // The last test: if the resulting pipe expands, then the single pipe solution
            // is possible only if the first pin on a pipe supports partial filling of a frame.
            //
            MultiplyKsCompression(OutAllocEx->Dimensions.EndPin, InAllocEx->Dimensions.EndPin, &TempCompression);

            if ( IsKsExpansion(TempCompression) ) {
                if ( IsPipeSupportPartialFrame(OutKsPin, Pin_Output, NULL) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanMergePipes Partial Frame Fill requested, hr=%x, Expansion=%d/%d"),
                                                hr, TempCompression.RatioNumerator, TempCompression.RatioDenominator ));
                }
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanMergePipes - Partial Frame Fill REFUSED Expansion=%d/%d"),
                                                TempCompression.RatioNumerator, TempCompression.RatioDenominator ));

                    RetCode = FALSE;
                }
            }
        }

        if (RetCode && FlagMerge) {
            //
            // We are done with our new pipe feasibility study. Create resulting pipe
            //
            hr = CreatePipe(OutKsPin, &NewKsAllocator);
            if (! SUCCEEDED( hr )) {
                ASSERT(0);
                RetCode = FALSE;
            }

            if (RetCode) {
                hr = InitializePipe(NewKsAllocator, 0);
                if (! SUCCEEDED( hr )) {
                    ASSERT(0);
                    RetCode = FALSE;
                }
            }

            if (RetCode) {
                NewAllocEx = NewKsAllocator->KsGetProperties();

                //
                // Copy the properties from Upstream side.
                //
                *NewAllocEx = *OutAllocEx;

                //
                // Fill necessary info.
                //
                NewAllocEx->MemoryType = MemoryType;
                GetLogicalMemoryTypeFromMemoryType(MemoryType, NewAllocEx->Flags, &NewAllocEx->LogicalMemoryType);

                //
                // All pins from both connecting pipes should join new pipe now.
                // Both connecting pipes should be deleted.
                //
                MovePinsToNewPipe(OutKsPin, Pin_Output, KS_DIRECTION_DEFAULT, NewKsAllocator, TRUE);

                MovePinsToNewPipe(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT, NewKsAllocator, TRUE);

                //
                // Assign allocator handler on NewKsAllocator
                //
                AssignPipeAllocatorHandler(OutKsPin, Pin_Output, MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

                //
                // Compute dimensions for new pipe.
                //
                hr = ResolvePipeDimensions(OutKsPin, Pin_Output, KS_DIRECTION_DEFAULT);

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanMergePipes KsAlloc=%x, Dim=%d/%d, %d/%d, %d/%d, Res=%d, %d, %d"),
                    NewKsAllocator,
                    NewAllocEx->Dimensions.AllocatorPin.RatioNumerator, NewAllocEx->Dimensions.AllocatorPin.RatioDenominator,
                    NewAllocEx->Dimensions.MaxExpansionPin.RatioNumerator, NewAllocEx->Dimensions.MaxExpansionPin.RatioDenominator,
                    NewAllocEx->Dimensions.EndPin.RatioNumerator, NewAllocEx->Dimensions.EndPin.RatioDenominator,
                    NewAllocEx->cBuffers, NewAllocEx->cbBuffer, NewAllocEx->cbAlign));

                GetFriendlyLogicalMemoryTypeNameFromId(NewAllocEx->LogicalMemoryType, LogicalMemoryName);
                GetFriendlyBusNameFromBusId(NewAllocEx->BusType, BusName);

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES LMT=%s, Bus=%s"), LogicalMemoryName, BusName ));

                NewKsAllocator->Release();
            }
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanMergePipes rets %d"), RetCode ));

    return RetCode;

}


STDMETHODIMP_(BOOL)
CanConnectPins(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin,
    IN ULONG FlagConnect
    )
/*++

Routine Description:

    Attempt to create a separate pipe for just 2 pins.

Arguments:

    OutKsPin -
        output pin on upstream pipe.

    InKsPin -
        input pin on downstream pipe.

    FlagConnect -
        if 1 - then actually connect pins into one pipe, if possible.

Return Value:

    TRUE - if connecting pins into one pipe is possible.

--*/
{

    PKSALLOCATOR_FRAMING_EX    InFramingEx, OutFramingEx;
    FRAMING_PROP               InFramingProp, OutFramingProp;
    HRESULT                    hr;
    BOOL                       RetCode = TRUE;
    KS_FRAMING_FIXED           InFramingExFixed, OutFramingExFixed;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    GUID                       Bus;
    BOOL                       IsHostBus;
    ULONG                      CommonMemoryTypesCount;
    GUID                       CommonMemoryType;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           FinalRange;



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanConnectPins entry InKsPin=%x OutKsPin=%x"),
                InKsPin, OutKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    //
    // Get framing from KsPins
    //
    GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);

    GetPinFramingFromCache(InKsPin, &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);

    //
    // Get connecting bus ID.
    //
    GetBusForKsPin(InKsPin, &Bus);
    IsHostBus = IsHostSystemBus(Bus);

    if ( (OutFramingProp == FramingProp_None) && (InFramingProp == FramingProp_None) ) {
        if (FlagConnect) {
            RemovePinFromPipe(InKsPin, Pin_Input);
            RemovePinFromPipe(OutKsPin, Pin_Output);
            CreatePipeForTwoPins(InKsPin, OutKsPin, Bus, GUID_NULL);
        }
    }
    else if (OutFramingProp == FramingProp_None) {
        //
        // Input pin will define the pipe.
        //
        if (FlagConnect) {
            RemovePinFromPipe(InKsPin, Pin_Input);

            hr = MakePipeBasedOnOnePin(InKsPin, Pin_Input, NULL);
            ASSERT( SUCCEEDED( hr ) );

            if ( SUCCEEDED( hr ) ) {
                if (! CanAddPinToPipeOnAnotherFilter(InKsPin, OutKsPin, Pin_Output, Pin_Move) ) {
                    //
                    // must be able to succeed since OutKsPin doesn't care
                    //
                    ASSERT(0);
                }
            }
        }
    }
    else if (InFramingProp == FramingProp_None) {
        //
        // Output pin will define the pipe.
        //
        if (FlagConnect) {
            hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
            ASSERT( SUCCEEDED( hr ) );

            if ( SUCCEEDED( hr ) ) {
                if (! CanAddPinToPipeOnAnotherFilter(OutKsPin, InKsPin, Pin_Input, Pin_Move) ) {
                    //
                    // must be able to succeed since OutKsPin doesn't care
                    //
                    ASSERT(0);
                }
            }
        }
    }
    else {
        //
        // Both pins have the framing.
        // Find the MemoryType to connect the pins.
        //
        CommonMemoryTypesCount = 1;

        if (! FindCommonMemoryTypesBasedOnBuses(InFramingEx, OutFramingEx, Bus, GUID_NULL,
                &CommonMemoryTypesCount, &CommonMemoryType) ) {
            //
            // Filters that support new FRAMING_EX properties must agree on the memory type.
            //
            if ( (! IsHostBus) && (InFramingProp == FramingProp_Ex) && (OutFramingProp == FramingProp_Ex) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTERS CanConnectPins - new filters don't agree on MemoryType") ));

                RetCode = FALSE;
            }
            else {
                //
                // Since we can't find the common MemoryType, get any MemoryType per Bus.
                //
                GetFramingFixedFromFramingByBus(InFramingEx, Bus, TRUE, &InFramingExFixed);
                GetFramingFixedFromFramingByBus(OutFramingEx, Bus, TRUE, &OutFramingExFixed);
            }
        }
        else {
            RetCode = GetFramingFixedFromFramingByMemoryType(InFramingEx,
                                                             CommonMemoryType,
                                                             &InFramingExFixed);
            ASSERT( RetCode && "PrefixBug 5463 would be hit" );
            if ( RetCode ) {
                RetCode = GetFramingFixedFromFramingByMemoryType(OutFramingEx,
                                                                 CommonMemoryType,
                                                                 &OutFramingExFixed);
                ASSERT( RetCode && "PrefixBug 5450 would be hit" );
            }
        }

        if (RetCode) {
            //
            // check the pins physical framing intersection.
            //
            if ( (OutFramingProp == FramingProp_Ex) && (! (OutFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                if ( (InFramingProp == FramingProp_Ex) && (! (InFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                    if (! FrameRangeIntersection(OutFramingExFixed.OptimalRange.Range, InFramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
                else {
                    if (! FrameRangeIntersection(OutFramingExFixed.OptimalRange.Range, InFramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
            }
            else { // Out pin doesn't insist.
                if ( (InFramingProp == FramingProp_Ex) && (! (InFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                    if (! FrameRangeIntersection(OutFramingExFixed.PhysicalRange, InFramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
                else {
                    if (! FrameRangeIntersection(OutFramingExFixed.PhysicalRange, InFramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
            }
        }

        if (RetCode && FlagConnect) {
            //
            // Select the pin with the highest weight.
            //
            RemovePinFromPipe(InKsPin, Pin_Input);
            RemovePinFromPipe(OutKsPin, Pin_Output);

            if (InFramingExFixed.MemoryTypeWeight > OutFramingExFixed.MemoryTypeWeight) {
                hr = MakePipeBasedOnFixedFraming(InKsPin, Pin_Input, InFramingExFixed);
                AddPinToPipeUnconditional(InKsPin, Pin_Input, OutKsPin, Pin_Output);
            }
            else {
                hr = MakePipeBasedOnFixedFraming(OutKsPin, Pin_Output, OutFramingExFixed);
                AddPinToPipeUnconditional(OutKsPin, Pin_Output, InKsPin, Pin_Input);
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanConnectPins rets. RetCode=%d"), RetCode ));

    return RetCode;
}


STDMETHODIMP_(BOOL)
RemovePinFromPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Just remove the KsPin from the pipe it points to.
    If there are any pins left on this pipe - then resolve ranges.
    No dependancies and relaxation, since the caller has already done it.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type

Return Value:

    TRUE on SUCCESS.

--*/
{
    BOOL             RetCode = TRUE;
    ULONG            NumPinsInPipe;
    IKsPin*          ConnectedKsPin;
    ULONG            ConnectedPinType;
    IKsPinPipe*      KsPinPipe;
    HRESULT          hr;
    ULONG            Direction;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    ComputeNumPinsInPipe(KsPin, PinType, &NumPinsInPipe);

    if (NumPinsInPipe == 1) {
        //
        // We can delete the pipe.
        //
        KsPinPipe->KsSetPipe(NULL);
        KsPin->KsReceiveAllocator( NULL );
    }
    else {
        //
        // Find first connected pin residing on this pipe.
        //
        if (! FindConnectedPinOnPipe(KsPin, NULL, FALSE, &ConnectedKsPin) ) {
            //
            // Should not happen - since NumPinsInPipe > 1
            // Delete the pipe.
            //
            ASSERT(0);
            KsPinPipe->KsSetPipe(NULL);
            KsPin->KsReceiveAllocator( NULL );
        }
        else {
            //
            // Remove the KsPin and resolve the rest of the pipe.
            //
            KsPinPipe->KsSetPipe(NULL);
            KsPin->KsReceiveAllocator( NULL );

            if (PinType == Pin_Input) {
                ConnectedPinType = Pin_Output;
                Direction = KS_DIRECTION_DOWNSTREAM;
            }
            else {
                ConnectedPinType = Pin_Input;
                Direction = KS_DIRECTION_UPSTREAM;
            }

            hr = ResolvePipeDimensions(ConnectedKsPin, ConnectedPinType, Direction);

            if (FAILED (hr) ) {
                RetCode = FALSE;
            }
        }
    }

    return  RetCode;

}


STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandlerCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    ALLOCATOR_SEARCH           *AllocSearch;
    KS_FRAMING_FIXED           FramingExFixed;
    IKsPinPipe*                KsPinPipe = NULL;
    HRESULT                    hr;
    BOOL                       RetCode = TRUE;


    AllocSearch = (ALLOCATOR_SEARCH *) Param1;


    if (AllocSearch->FlagAssign) {
        //
        // Clear the allocator handler flag on all pins, this flag will be later set on one special pin.
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsPinPipe->KsSetPipeAllocatorFlag(0);
    }


    if ( GetFramingFixedFromPinByMemoryType( KsPin, AllocSearch->MemoryType, &FramingExFixed) ) {
        if (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {
            AllocSearch->NumberMustAllocators++;

            if (AllocSearch->NumberMustAllocators > 1) {
                //
                // There should not be more than 1 'MUST ALLOCATE' pin on a pipe.
                //
                *IsDone = 1;
                RetCode = FALSE;
            }
            else {
                AllocSearch->KsPin = KsPin;
                AllocSearch->PinType = PinType;
            }
        }
        else {
            if ( (! AllocSearch->NumberMustAllocators) && (FramingExFixed.Flags & KSALLOCATOR_FLAG_CAN_ALLOCATE) ) {
                AllocSearch->KsPin = KsPin;
                AllocSearch->PinType = PinType;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandler(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorHandlerPinType,
    IN BOOL FlagAssign
    )
/*++

Routine Description:

    Finds the allocator handling pin on a given pipe corresponding to the specified MemoryType.
    If FlagAssign=1, then this routine assigns the allocator handling pin on a given pipe and
    marks the pipe as 'MUST ALLOCATE' if requested by any pin's framing.

    Walks the pins on KsPin-pipe, in the specified Direction.

    IF KsPin-pipe has 'MUST_ALLOCATE' pin
        Return the 'MUST ALLOCATE'pin
    ELSE
        Find the very first pin that explicitly supports MemoryType in its framing.
        Mark such pin as KsPin-pipe allocator handler and return TRUE.
        If no such pin found - return FALSE.
    ENDIF


Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    MemoryType -
        memory type for the allocator to use.

    Direction -
        direction relative to KsPin to look for the allocator handler.

    KsAllocatorHandlerPin -
        returned pin that will be an allocator handler.

    AllocatorHandlerPinType -
        type of the KsAllocatorHandlerPin.

    FlagAssign -
        1 - do allocator handler assignment and set pipe flags - "assign allocator handler" operation.
        0 - don't set any pin/pipe allocators handler flags - just "find allocator handler" operation.


Return Value:

    TRUE on success.

--*/
{


    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    IKsPin*                    BreakKsPin;
    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                AllocKsPinPipe;
    BOOL                       RetCode;
    HRESULT                    hr;
    ALLOCATOR_SEARCH           AllocSearch;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsAllocatorEx*            KsAllocator;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if ( (Direction == KS_DIRECTION_UPSTREAM) || (Direction == KS_DIRECTION_ALL) ) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);
    }
    else { // KS_DIRECTION_DOWNSTREAM
        FirstKsPin = KsPin;
        FirstPinType = PinType;
        RetCode = TRUE;
    }

    if (RetCode) {
        if ( Direction == KS_DIRECTION_UPSTREAM ) {
            BreakKsPin = KsPin;
        }
        else { // KS_DIRECTION_DOWNSTREAM or KS_DIRECTION_ALL
            BreakKsPin = NULL;
        }

        AllocSearch.MemoryType = MemoryType;
        AllocSearch.FlagAssign = FlagAssign;
        AllocSearch.KsPin = NULL;

        if ( (AllocEx->MemoryType == MemoryType) && (AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {
            AllocSearch.IsMustAllocator = 1;
        }
        else {
            AllocSearch.IsMustAllocator = 0;
        }
        AllocSearch.NumberMustAllocators = 0;

        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, AssignPipeAllocatorHandlerCallback, (PVOID*) &AllocSearch, NULL);

        if (! AllocSearch.KsPin) {
            RetCode = FALSE;
        }

        if (RetCode) {
            if (KsAllocatorHandlerPin) {
                *KsAllocatorHandlerPin = AllocSearch.KsPin;
            }

            if (AllocatorHandlerPinType) {
                *AllocatorHandlerPinType = AllocSearch.PinType;
            }

            if (FlagAssign) {

                if (AllocSearch.NumberMustAllocators) {
                    AllocEx->Flags |= KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE;
                }
                else {
                    AllocEx->Flags &= ~KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE;
                }

                GetInterfacePointerNoLockWithAssert(AllocSearch.KsPin, __uuidof(IKsPinPipe), AllocKsPinPipe, hr);

                AllocKsPinPipe->KsSetPipeAllocatorFlag(1);
            }
        }
        else {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AssignPipeAllocatorHandler returns FALSE, KsPin=%x, NumMustAlloc=%d"),
                    KsPin, AllocSearch.NumberMustAllocators));
        }
    }


    return (RetCode);

}


STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    ALLOCATOR_SEARCH           *AllocSearch;
    HANDLE                     AllocatorHandle;
    KSPIN_COMMUNICATION        Communication;
    IKsObject*                 KsObject;
    KSPROPERTY                 PropertySetAlloc;
    KSPROPERTY                 PropertySetPipeId;
    ULONG                      BytesReturned;
    HRESULT                    hr;
    IPin*                      InPin = NULL;
    ULONG                      InPinCount = 0;
    IPin*                      OutPin;
    IKsPin**                   OutKsPinList = NULL;
    ULONG                      OutPinCount = 0;
    IKsAllocatorEx*            KsAllocator;
    IKsPinPipe*                KsPinPipe;
    IKsPin*                    Temp1KsPin;
    IKsPin*                    Temp2KsPin;
    ULONG                      i;
    BOOL                       IsAllocator;
    BOOL                       RetCode = TRUE;



    AllocSearch = (ALLOCATOR_SEARCH *) Param1;
    AllocatorHandle = (HANDLE) (*Param2);

    //
    // Unconditionally assign the Pipe Id to every pin on a pipe.
    //
    PropertySetPipeId.Set = KSPROPSETID_Stream;
    PropertySetPipeId.Id = KSPROPERTY_STREAM_PIPE_ID;
    PropertySetPipeId.Flags = KSPROPERTY_TYPE_SET;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

    hr = KsSynchronousDeviceControl(
        KsObject->KsGetObjectHandle(),
        IOCTL_KS_PROPERTY,
        &PropertySetPipeId,
        sizeof( PropertySetPipeId ),
        &AllocatorHandle,
        sizeof( HANDLE ),
        &BytesReturned );

    if ( SUCCEEDED( hr )) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES PIPE_ID (AllocatorHandle=%x) assigned to Pin=%x"),
             AllocatorHandle, KsPin));
    }
    else {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN PIPE_ID (AllocatorHandle=%x) assigned to Pin=%x hr=%x"),
             AllocatorHandle, KsPin, hr));
    }

    //
    // The only candidates for Allocators-requestors are KSPIN_COMMUNICATION_SOURCE pins.
    // KSPIN_COMMUNICATION_BRIDGE pins do not communicate to outside filters.
    //
    KsPin->KsGetCurrentCommunication(&Communication, NULL, NULL);

    if ( (Communication & KSPIN_COMMUNICATION_SOURCE) && (! AllocSearch->FlagAssign) ) {
        //
        // We need to get a KsAllocator from this KsPin to use for
        // the following search of all the output pins on the same filter and
        // on the same pipe.
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        if ( ! (KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) ) ) {
            ASSERT(0);
            RetCode = FALSE;
        }
        else {
            PropertySetAlloc.Set = KSPROPSETID_Stream;
            PropertySetAlloc.Id = KSPROPERTY_STREAM_ALLOCATOR;
            PropertySetAlloc.Flags = KSPROPERTY_TYPE_SET;

            //
            // If this _SOURCE pin is an output pin then it must be an allocator,
            // since we are walking the pipe from upstream in this function.
            //
            // If this _SOURCE pin is an input pin then we check to see if there is any output _SOURCE
            // pin on the same pipe on the same filter.
            // If so, then this input pin is the allocator.
            // Otherwise - we should check to see whether this pin's filter is the last downstream
            // filter on this pipe.
            // If it is the last filter - then this _SOURCE pin must be an allocator,
            // otherwise - the allocator must be located further downstream.
            //
            if (PinType == Pin_Input) {

                if (! FindAllConnectedPinsOnPipe(KsPin, KsAllocator, NULL, &OutPinCount) ) {
                    //
                    // downstream pin belongs to different pipe (if not-in-place OR user-mode connection).
                    //
                    IsAllocator = 1;
                    OutPinCount = 0;
                }
                else {
                    IsAllocator = 0;

                    if (OutPinCount) {

                        OutKsPinList = new IKsPin* [ OutPinCount ];
                        if (! OutKsPinList) {
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR OUTOFMEMORY AssignAllocatorsAndPipeIdForPipePinsCallback OutPinCount=%d"), OutPinCount));
                            RetCode = FALSE;
                        }
                        else {
                            //
                            // fill the pins.
                            //
                            if (! FindAllConnectedPinsOnPipe(KsPin, KsAllocator, &OutKsPinList[0], &OutPinCount) ) {
                                ASSERT(0);
                                RetCode = FALSE;
                            }
                            else {
                                //
                                // check to see if there is at least one output _SOURCE pin.
                                //
                                for (i=0; i<OutPinCount; i++) {
                                    OutKsPinList[i]->KsGetCurrentCommunication(&Communication, NULL, NULL);
                                    if (Communication & KSPIN_COMMUNICATION_SOURCE) {
                                        IsAllocator = 1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                if ( RetCode &&
                     (IsAllocator ||
                     (! FindNextPinOnPipe(KsPin, Pin_Input, KS_DIRECTION_DOWNSTREAM, NULL, FALSE, &Temp1KsPin) ) ||
                     (! FindNextPinOnPipe(Temp1KsPin, Pin_Output, KS_DIRECTION_DOWNSTREAM, NULL, FALSE, &Temp2KsPin) ) ) ) {


                    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

                    hr = KsSynchronousDeviceControl(
                        KsObject->KsGetObjectHandle(),
                        IOCTL_KS_PROPERTY,
                        &PropertySetAlloc,
                        sizeof( PropertySetAlloc ),
                        &AllocatorHandle,
                        sizeof( HANDLE ),
                        &BytesReturned );

                    if ( SUCCEEDED( hr )) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AllocatorHandle=%x assigned to Pin=%x"),
                             AllocatorHandle, KsPin));
                    }
                    else {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR AllocatorHandle=%x assigned to Pin=%x hr=%x"),
                             AllocatorHandle, KsPin, hr));
                    }

                    AllocSearch->FlagAssign = 1;
                }

            }
            else {
                //
                // This pin is the output pin and it is on a filter that provides the allocator.
                //
                // Also, since each pipe is walked separately, we only need to handle one pipe
                // at a time. There is no inter-dependencies between different pipes.
                //
                GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), OutPin, hr);

                //
                // Assign allocator handle on this KsPin output _SOURCE pin and done.
                //
                GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

                hr = KsSynchronousDeviceControl(
                    KsObject->KsGetObjectHandle(),
                    IOCTL_KS_PROPERTY,
                    &PropertySetAlloc,
                    sizeof( PropertySetAlloc ),
                    &AllocatorHandle,
                    sizeof( HANDLE ),
                    &BytesReturned );

                if ( SUCCEEDED( hr )) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AllocatorHandle=%x assigned to Pin=%x"),
                         AllocatorHandle, KsPin));
                }
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR AllocatorHandle=%x assigned to Pin=%x hr=%x"),
                         AllocatorHandle, KsPin, hr));
                }

                AllocSearch->FlagAssign = 1;
            }
        }


        if ( AllocSearch->FlagAssign ) {
            AllocSearch->KsPin = KsPin;
            AllocSearch->PinType = PinType;
        }

        if (InPin) {
            InPin->Release();
        }

        if (OutKsPinList) {
            delete [] OutKsPinList;
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN HANDLE AllocatorHandle,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorPin,
    OUT ULONG* AllocatorPinType
    )
/*++

Routine Description:

    Finds one or more allocator pin[-s] on a given pipe, based on the
    pins communication properties and assigns provided
    AllocatorHandle to the pipe allocator pin[-s].

    Walks the pins on KsPin-pipe in the specified Direction.


Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    AllocatorHandle -
        handle of allocator object to be assigned

    Direction -
        direction relative to KsPin to look for the allocator.

    KsAllocatorPin -
        Returned allocator pin.
        In case there are multiple allocator pins - returns one of them.

    AllocatorPinType -
        type of the KsAllocatorPin.



Return Value:

    TRUE on success.

--*/
{


    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    IKsPin*                    BreakKsPin;
    BOOL                       RetCode = TRUE;
    ALLOCATOR_SEARCH           AllocSearch;



    if ( (Direction == KS_DIRECTION_UPSTREAM) || (Direction == KS_DIRECTION_ALL) ) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);
    }
    else { // KS_DIRECTION_DOWNSTREAM
        FirstKsPin = KsPin;
        FirstPinType = PinType;
    }

    if (RetCode) {
        if ( Direction == KS_DIRECTION_UPSTREAM ) {
            BreakKsPin = KsPin;
        }
        else { // KS_DIRECTION_DOWNSTREAM or KS_DIRECTION_ALL
            BreakKsPin = NULL;
        }

        AllocSearch.KsPin = NULL;

        //
        // To assign the Pipe_ID for each pin on a pipe, we must walk an entire pipe.
        // To assign the pipe allocator-requestor-pins, we must stop at the first filter
        // that contains such pins.
        // So, we are using the FlagAssign below to indicate whether the allocator-requestor pins
        // assignment had been done. We are doing all the work in a single pipe walk.
        //
        AllocSearch.FlagAssign = 0;

        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, AssignAllocatorsAndPipeIdForPipePinsCallback,
                                    (PVOID*) &AllocSearch, (PVOID*) &AllocatorHandle);

        if (! AllocSearch.KsPin) {
            RetCode = FALSE;
        }

        if (RetCode) {
            if (KsAllocatorPin) {
                *KsAllocatorPin = AllocSearch.KsPin;
            }

            if (AllocatorPinType) {
                *AllocatorPinType = AllocSearch.PinType;
            }
        }
        else {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AssignAllocatorsAndPipeIdForPipePins returns FALSE, KsPin=%x"), KsPin));
        }
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
IsPipeSupportPartialFrame(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT HANDLE* FirstPinHandle
    )
/*++

Routine Description:

    A pipe supports partial frame when the very first (upstream) pin
    on a pipe (defined by KsPin) supports partial fill of a frame.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

    FirstPinHandle -
        handle to the first pin on a pipe (if requested).

Return Value:

    TRUE if pipe supports partial fill of a frame.

--*/
{

    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    IKsObject*                 FirstKsObject;
    BOOL                       RetCode = TRUE;
    HRESULT                    hr;



    RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
    ASSERT(RetCode);

    if (RetCode) {
        GetPinFramingFromCache(FirstKsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

        if ( FramingProp == FramingProp_None) {
            RetCode = FALSE;
        }
        else if ( (FramingProp == FramingProp_Ex) || (FramingEx->FramingItem[0].Flags & KSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT) ) {
            if (FirstPinHandle) {
                GetInterfacePointerNoLockWithAssert(FirstKsPin, __uuidof(IKsObject), FirstKsObject, hr);
                *FirstPinHandle = FirstKsObject->KsGetObjectHandle();
            }
        }
        else {
            RetCode = FALSE;
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
OptimizePipesSystem(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    )
/*++

Routine Description:

    Optimizes the system of connected pipes.

Arguments:

    OutKsPin -
        output pin on upstream pipe.

    InKsPin -
        input stream on downstream pipe.

Return Value:

    TRUE on success.

--*/
{

    //
    // Can complete this later.
    //

    return TRUE;

}


__inline
STDMETHODIMP_(BOOL)
ResultSinglePipe(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType,
    IN IKsPinPipe* InKsPinPipe,
    IN IKsPinPipe* OutKsPinPipe,
    IN IMemAllocator* MemAllocator,
    IN IKsAllocatorEx* KsAllocator,
    IN ULONG ExistingPipePinType
    )
{
    BOOL RetCode = TRUE;

    if (! KsAllocator) {
        //
        // create single pipe with 2 pins.
        //
        CreatePipeForTwoPins(InKsPin, OutKsPin, ConnectBus, MemoryType);
    }
    else {
        //
        // add one pin to existing pipe.
        //
        PALLOCATOR_PROPERTIES_EX   AllocEx;
        HRESULT                    hr;

        if (ExistingPipePinType == Pin_Input) {
            if (! OutKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
                OutKsPin->KsReceiveAllocator(MemAllocator);
            }
            else {
                ASSERT(0);
            }
            OutKsPinPipe->KsSetPipe(KsAllocator);
        }
        else {
            if (! InKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
                InKsPin->KsReceiveAllocator(MemAllocator);
            }
            else {
                ASSERT(0);
            }
            InKsPinPipe->KsSetPipe(KsAllocator);
        }

        AllocEx = KsAllocator->KsGetProperties();

        //
        // Set the pipe allocator handling pin.
        //
        AssignPipeAllocatorHandler(InKsPin, Pin_Input, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

        //
        // Resolve the pipe.
        //
        hr = ResolvePipeDimensions(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT);
        if (FAILED (hr) ) {
            RetCode = FALSE;
        }
    }

    return RetCode;
}


__inline
STDMETHODIMP_(BOOL)
ResultSeparatePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN ULONG OutPinType,
    IN ULONG ExistingPipePinType,
    IN IKsAllocatorEx* KsAllocator
    )
{

    HRESULT     hr;
    BOOL        RetCode = TRUE;


    if (! KsAllocator) {
        //
        // create 2 separate pipes.
        //
        hr = MakePipeBasedOnOnePin(OutKsPin, OutPinType, NULL);
        if (! SUCCEEDED( hr )) {
            ASSERT(0);
            RetCode = FALSE;
        }
        else {
            hr = MakePipeBasedOnOnePin(InKsPin, Pin_Input, NULL);
            if (! SUCCEEDED( hr )) {
                ASSERT(0);
                RetCode = FALSE;
            }
        }
    }
    else {
        //
        // create one separate pipe
        //
        if (ExistingPipePinType == Pin_Input) {
            hr = MakePipeBasedOnOnePin(OutKsPin, OutPinType, NULL);
        }
        else {
            hr = MakePipeBasedOnOnePin(InKsPin, Pin_Input, NULL);
        }
        if (! SUCCEEDED( hr )) {
            ASSERT(0);
            RetCode = FALSE;
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindCommonMemoryTypeBasedOnPipeAndPin(
    IN IKsPin* PipeKsPin,
    IN ULONG PipePinType,
    IN IKsPin* ConnectKsPin,
    IN ULONG ConnectPinType,
    IN BOOL FlagConnect,
    OUT GUID* MemoryType
    )
/*++

Routine Description:

    Searches for the MemoryType that can be used to include a pin in a pipe.
    PipeKsPin == ConnectKsPin means that ConnectKsPin medium has changed.

Arguments:

    PipeKsPin -
        pin that defines a pipe.

    PipePinType -
        PipeKsPin pin type.

    ConnectKsPin -
        connecting KsPin.

    ConnectPinType -
        ConnectKsPin pin type.

    FlagConnect -
        if set to 1 - means to change the pipe system to include a pin in a
        pipe, if such an inclusion is possible (e.g. there is a common MemoryType).

    MemoryType -
        pointer to the returned common memory type (if it exists).

Return Value:

    TRUE - if common MemoryType exists.

--*/
{
    PKSALLOCATOR_FRAMING_EX    ConnectFramingEx, PipeFramingEx;
    FRAMING_PROP               ConnectFramingProp, PipeFramingProp;
    KS_FRAMING_FIXED           ConnectFramingExFixed;
    IKsPinPipe*                ConnectKsPinPipe;
    IKsPinPipe*                PipeKsPinPipe;
    IKsAllocatorEx*            PipeKsAllocator;
    PALLOCATOR_PROPERTIES_EX   PipeAllocEx;
    GUID                       ConnectBus, PipeBus;
    ULONG                      CommonMemoryTypesCount;
    GUID*                      CommonMemoryTypesList = NULL;
    ULONG                      RetCode = TRUE;
    HRESULT                    hr;
    ULONG                      i;



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FindCommonMemoryTypeBasedOnPipeAndPin entry PipeKsPin=%x, KsPin=%x"),
          PipeKsPin, ConnectKsPin ));

    GetPinFramingFromCache(ConnectKsPin, &ConnectFramingEx, &ConnectFramingProp, Framing_Cache_ReadLast);
    if (ConnectFramingProp == FramingProp_None) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindCommonMemoryTypeBasedOnPipeAndPin - no framing ConnectKsPin=%x"),
                ConnectKsPin ));

    }
    else {
        GetInterfacePointerNoLockWithAssert(PipeKsPin, __uuidof(IKsPinPipe), PipeKsPinPipe, hr);

        GetInterfacePointerNoLockWithAssert(ConnectKsPin, __uuidof(IKsPinPipe), ConnectKsPinPipe, hr);

        PipeKsAllocator = PipeKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
        ASSERT(PipeKsAllocator);

        PipeAllocEx = PipeKsAllocator->KsGetProperties();

        //
        // First attempt: try to adjust the pin to use the existing pipe.
        //
        if (GetFramingFixedFromFramingByMemoryType(ConnectFramingEx, PipeAllocEx->MemoryType, &ConnectFramingExFixed) ) {
            if (FlagConnect && (PipeKsPin != ConnectKsPin) ) {
                AddPinToPipeUnconditional(PipeKsPin, PipePinType, ConnectKsPin, ConnectPinType);
            }

            if (MemoryType) {
                *MemoryType = PipeAllocEx->MemoryType;
            }
        }
        else {
            //
            // Existing pipe has to be adjusted to accommodate the connecting pin.
            //
            GetBusForKsPin(ConnectKsPin, &ConnectBus);

            CommonMemoryTypesCount = 0;

            if (PipeKsPin == ConnectKsPin) {
                if ( ! FindAllPinMemoryTypesBasedOnBus(ConnectFramingEx, ConnectBus, &CommonMemoryTypesCount, CommonMemoryTypesList) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FindCommonMemoryTypeBasedOnPipeAndPin - no Pin Memory Types ConnectKsPin=%x"),
                            ConnectKsPin ));

                    RetCode = FALSE;
                }
            }
            else {
                GetPinFramingFromCache(PipeKsPin, &PipeFramingEx, &PipeFramingProp, Framing_Cache_ReadLast);
                if (PipeFramingProp == FramingProp_None) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FindCommonMemoryTypeBasedOnPipeAndPin - no framing PipeKsPin=%x"),
                            PipeKsPin ));

                    RetCode = FALSE;
                }

                GetBusForKsPin(PipeKsPin, &PipeBus);

                if ( ! FindCommonMemoryTypesBasedOnBuses(ConnectFramingEx, PipeFramingEx, ConnectBus, PipeBus,
                           &CommonMemoryTypesCount, CommonMemoryTypesList) ) {

                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FindCommonMemoryTypeBasedOnPipeAndPin - no Common Memory Types ConnectKsPin=%x"),
                            ConnectKsPin ));

                    RetCode = FALSE;
                }
            }

            if (RetCode) {
                //
                // Allocate the memory for CommonMemoryTypesList.
                //
                if (NULL == (CommonMemoryTypesList = new GUID[ CommonMemoryTypesCount ]))  {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindCommonMemoryTypeBasedOnPipeAndPin E_OUTOFMEMORY CommonMemoryTypesCount=%d"),
                            CommonMemoryTypesCount ));

                    RetCode = FALSE;
                }
                else {
                    //
                    // Fill the CommonMemoryTypesList
                    //
                    if (PipeKsPin == ConnectKsPin) {
                        if ( ! FindAllPinMemoryTypesBasedOnBus(ConnectFramingEx, ConnectBus, &CommonMemoryTypesCount, CommonMemoryTypesList) ) {
                            ASSERT(0);
                            RetCode = FALSE;
                        }
                    }
                    else {
                        if ( ! FindCommonMemoryTypesBasedOnBuses(ConnectFramingEx, PipeFramingEx, ConnectBus, PipeBus,
                                   &CommonMemoryTypesCount, CommonMemoryTypesList) ) {
                            ASSERT(0);
                            RetCode = FALSE;
                        }
                    }

                    if (RetCode) {
                        //
                        // Process all the common memory types found.
                        //
                        RetCode = FALSE;

                        for (i=0; i<CommonMemoryTypesCount; i++) {
                            if ( CanPipeUseMemoryType(PipeKsPin, PipePinType, CommonMemoryTypesList[i], KS_MemoryTypeDeviceSpecific, TRUE, FALSE) ) {

                                if (FlagConnect) {
                                    if (PipeKsPin == ConnectKsPin) {
                                        AssignPipeAllocatorHandler(ConnectKsPin, ConnectPinType, CommonMemoryTypesList[i], KS_DIRECTION_ALL, NULL, NULL, TRUE);
                                        hr = ResolvePipeDimensions(ConnectKsPin, ConnectPinType, KS_DIRECTION_ALL);
                                    }
                                    else {
                                        AddPinToPipeUnconditional(PipeKsPin, PipePinType, ConnectKsPin, ConnectPinType);
                                    }
                                }

                                if (MemoryType) {
                                    *MemoryType = CommonMemoryTypesList[i];
                                }

                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    if (CommonMemoryTypesList) {
        delete [] CommonMemoryTypesList;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FindCommonMemoryTypeBasedOnPipeAndPin rets. %d"), RetCode ));

    return RetCode;

}


STDMETHODIMP_(BOOL)
SplitterCanAddPinToPipes(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KEY_PIPE_DATA* KeyPipeData,
    IN ULONG KeyPipeDataCount
    )
/*++

Routine Description:

    Splitter's helper handling function.
    Attempts to add the pin KsPin to one of the pipes listed in KeyPipeData[].
    These pipes exist on the splitter's output pins.

Arguments:

    KsPin -
        pin we want to build a pipe for.

    PinType -
        KsPin pin type.

    KeyPipeData -
        an array describing the existing pipes built for some output pins.

    KeyPipeDataCount -
        count of valid items in KeyPipeData array above.

Return Value:

    TRUE - if KsPin has been added to one of the pipes listed in KeyPipeData[].

--*/
{

    ULONG                      i;
    GUID                       Bus;
    PALLOCATOR_PROPERTIES_EX   TempAllocEx;
    BOOL                       RetCode = FALSE;


    if (KeyPipeDataCount) {
        //
        // First pass: try to use the pipe that uses the same primary bus.
        //
        GetBusForKsPin(KsPin, &Bus);

        for (i=0; i<KeyPipeDataCount; i++) {
            TempAllocEx = (KeyPipeData[i].KsAllocator)->KsGetProperties();
            if ( AreBusesCompatible(TempAllocEx->BusType, Bus) ) {
                //
                // Add this pin to the compatible pipe.
                //
                AddPinToPipeUnconditional(KeyPipeData[i].KsPin, KeyPipeData[i].PinType, KsPin, PinType);

                RetCode = TRUE;
                break;
            }
        }

        if (! RetCode) {
            //
            // Try to pick a common memory type to go across the buses.
            //
            for (i=0; i<KeyPipeDataCount; i++) {
                if ( FindCommonMemoryTypeBasedOnPipeAndPin(KeyPipeData[i].KsPin, KeyPipeData[i].PinType, KsPin, PinType, TRUE, NULL) ) {
                    RetCode = TRUE;
                    break;
                }
            }
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES SplitterCanAddPinToPipes rets. %d"), RetCode ));
    return RetCode;
}


STDMETHODIMP_(BOOL)
FindCommonMemoryTypesBasedOnBuses(
    IN PKSALLOCATOR_FRAMING_EX FramingEx1,
    IN PKSALLOCATOR_FRAMING_EX FramingEx2,
    IN GUID Bus1,
    IN GUID Bus2,
    IN OUT ULONG* CommonMemoryTypesCount,
    OUT GUID* CommonMemoryTypesList
    )
/*++

Routine Description:

    Searches for the memory types that can be used to connect the pins across
    different hardware buses.

Arguments:

    FramingEx1 -
        Framing for the first pin.

    FramingEx2 -
        Framing for the second pin.

    Bus1 -
        Bus connecting first pin.

    Bus2 -
        Bus connecting second pin.

    CommonMemoryTypesCount -
        Requested count of the resulting common memory types found.
        When set to 0 - means that the caller wants to get back the count
        of all possible common memory types (to allocate an appropriate list).

    CommonMemoryTypesList -
        resulting list of common memory types allocated by the caller.

Return Value:

    TRUE - if at least one common memory type exist.

--*/
{

    ULONG                      i, j;
    GUID*                      ResultList;
    ULONG                      AllocResultList;
    ULONG                      ResultListCount;
    GUID                       MemoryType;
    ULONG                      RetCode = TRUE;
    BOOL                       FlagDone = 0;
    BOOL                       FlagFound;


    if (*CommonMemoryTypesCount == 0) {
        //
        // We need to compute CommonMemoryTypesCount.
        //
        ResultList = NULL;
        AllocResultList = 0;
    }
    else {
        ResultList = CommonMemoryTypesList;
    }

    ResultListCount = 0;

    //
    // All the framing lists are not sorted, so we walk them sequentially.
    //
    for (i=0; (i<FramingEx1->CountItems) && (! FlagDone); i++) {

        if (FramingEx1->FramingItem[i].BusType == Bus1) {
            //
            // Get the suspect Memory type.
            //
            MemoryType = FramingEx1->FramingItem[i].MemoryType;

            //
            // See if it is listed in ResultList already (MemoryTypes may repeat in Framing).
            //
            FlagFound = 0;

            for (j=0; j<ResultListCount; j++) {
                if (MemoryType == ResultList[j]) {
                    FlagFound = 1;
                    break;
                }
            }

            if (FlagFound) {
                continue;
            }

            //
            // See if MemoryType is listed in FramingEx2 per Bus2
            //
            for (j=0; (j<FramingEx2->CountItems) && (! FlagDone); j++) {
                if ( (FramingEx2->FramingItem[j].MemoryType == MemoryType) && (FramingEx2->FramingItem[j].BusType == Bus2) ) {
                    //
                    // MemoryType satisfies both Buses.
                    // Add it to the ResultList.
                    //
                    if ( (*CommonMemoryTypesCount == 0) && (ResultListCount == AllocResultList) ) {
                        //
                        // We need to allocate more room for ResultList.
                        // Store the existing ResultList in TempList.
                        //
                        GUID*   TempList;

                        TempList = ResultList;
                        AllocResultList += INCREMENT_PINS;

                        ResultList = new GUID [ AllocResultList ];
                        if (! ResultList) {
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindCommonMemoryTypesBasedOnBuses E_OUTOFMEMORY on new ResultList %d"),
                                                         AllocResultList ));
                            RetCode = FALSE;
                            FlagDone = 1;
                            break;
                        }

                        if (TempList && ResultListCount) {
                            MoveMemory(ResultList, TempList, ResultListCount * sizeof(ResultList[0]));
                            delete [] TempList;
                        }
                    }

                    ResultList[ResultListCount] = MemoryType;
                    ResultListCount++;

                    if (*CommonMemoryTypesCount == ResultListCount) {
                        //
                        // We have satisfied the requested count of MemoryTypes.
                        //
                        FlagDone = 1;
                    }

                    break;
                }
            }
        }
    }


    if ( *CommonMemoryTypesCount == 0) {
        *CommonMemoryTypesCount = ResultListCount;

        if (ResultList) {
            delete [] ResultList;
        }
    }

    if (! ResultListCount) {
        RetCode = FALSE;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindAllPinMemoryTypesBasedOnBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN OUT ULONG* MemoryTypesCount,
    OUT GUID* MemoryTypesList
    )
/*++

Routine Description:

    Searches for the memory types that are listed in pin's framing
    per fixed hardware bus.

Arguments:

    FramingEx -
        Pin's framing.

    Bus -
        Hardware bus.

    MemoryTypesCount -
        Requested count of the resulting memory types found.
        When set to 0 - means that the caller wants to get back the count
        of all satisfying memory types (to allocate an appropriate list).

    MemoryTypesList -
        resulting list of memory types allocated by the caller.

Return Value:

    TRUE - if at least one satisfying memory type exist.

--*/
{

    ULONG                      i, j;
    GUID*                      ResultList;
    ULONG                      AllocResultList;
    ULONG                      ResultListCount;
    ULONG                      RetCode = TRUE;
    GUID                       MemoryType;
    BOOL                       FlagFound;



    if (*MemoryTypesCount == 0) {
        //
        // We need to compute MemoryTypesCount.
        //
        ResultList = NULL;
        AllocResultList = 0;
    }
    else {
        ResultList = MemoryTypesList;
    }

    ResultListCount = 0;

    //
    // All the framing lists are not sorted, so we walk them sequentially.
    //
    for (i=0; i<FramingEx->CountItems; i++) {

        if (FramingEx->FramingItem[i].BusType == Bus) {
            //
            // Get the suspect Memory type.
            //
            MemoryType = FramingEx->FramingItem[i].MemoryType;

            //
            // See if it is listed in ResultList already (MemoryTypes may repeat in Framing).
            //
            FlagFound = 0;

            for (j=0; j<ResultListCount; j++) {
                if (MemoryType == ResultList[j]) {
                    FlagFound = 1;
                    break;
                }
            }

            if (FlagFound) {
                continue;
            }

            if ( (*MemoryTypesCount == 0) && (ResultListCount == AllocResultList) ) {
                //
                // We need to allocate more room for ResultList.
                // Store the existing ResultList in TempList.
                //
                GUID*   TempList;

                TempList = ResultList;
                AllocResultList += INCREMENT_PINS;

                ResultList = new GUID [ AllocResultList ];
                if (! ResultList) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindAllPinMemoryTypesBasedOnBus E_OUTOFMEMORY on new ResultList %d"),
                            AllocResultList ));

                    RetCode = FALSE;
                    break;
                }

                if (TempList && ResultListCount) {
                    MoveMemory(ResultList, TempList, ResultListCount * sizeof(ResultList[0]));
                    delete [] TempList;
                }
            }

            ResultList[ResultListCount] = MemoryType;
            ResultListCount++;

            if (*MemoryTypesCount == ResultListCount) {
                //
                // We have satisfied the requested count of MemoryTypes.
                //
                break;
            }
        }
    }

    if ( *MemoryTypesCount == 0) {
        *MemoryTypesCount = ResultListCount;

        if (ResultList) {
            delete [] ResultList;
        }
    }

    if (! ResultListCount) {
        RetCode = FALSE;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
AddPinToPipeUnconditional(
    IN IKsPin* PipeKsPin,
    IN ULONG PipePinType,
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Adds pin to existing pipe. No tests performed.

Arguments:

    PipeKsPin -
        Pin defining a pipe.

    PipePinType -
        PipeKsPin pin type.

    KsPin -
        Pin we want to add to a pipe above.

    PinType -
         KsPin pin type.

Return Value:

    TRUE.

--*/
{

    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                PipeKsPinPipe;
    IKsAllocatorEx*            PipeKsAllocator;
    IMemAllocator*             PipeMemAllocator;
    PALLOCATOR_PROPERTIES_EX   PipeAllocEx;
    HRESULT                    hr;


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AddPinToPipeUnconditional PipeKsPIn=%x, KsPin=%x"), PipeKsPin, KsPin ));

    GetInterfacePointerNoLockWithAssert(PipeKsPin, __uuidof(IKsPinPipe), PipeKsPinPipe, hr);

    PipeKsAllocator = PipeKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    PipeAllocEx = PipeKsAllocator->KsGetProperties();

    GetInterfacePointerNoLockWithAssert(PipeKsAllocator, __uuidof(IMemAllocator), PipeMemAllocator, hr);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    //
    // Add KsPin to the pipe.
    //
    KsPin->KsReceiveAllocator(PipeMemAllocator);
    KsPinPipe->KsSetPipe(PipeKsAllocator);

    //
    // Recompute the pipe properties.
    //
    AssignPipeAllocatorHandler(KsPin, PinType, PipeAllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
    hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_ALL);


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AddPinToPipeUnconditional rets. TRUE") ));

    return TRUE;
}


STDMETHODIMP_(BOOL)
GetFriendlyBusNameFromBusId(
    IN GUID BusId,
    OUT PTCHAR BusName
    )
{

    if (BusId == KSMEDIUMSETID_Standard) {
        _stprintf(BusName, TEXT("BUS_Standard") );
    }
    else if (BusId == GUID_NULL) {
        _stprintf(BusName, TEXT("BUS_NULL    ") );
    }
    else if (BusId == KSMEDIUMSETID_VPBus) {
        _stprintf(BusName, TEXT("BUS_VpBus   ") );
    }
    else if (BusId == KSMEDIUMSETID_MidiBus) {
        _stprintf(BusName, TEXT("BUS_MidiBus ") );
    }
    else {
        _stprintf(BusName, TEXT("BUS_Unknown ") );
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
GetFriendlyLogicalMemoryTypeNameFromId(
    IN ULONG LogicalMemoryType,
    OUT PTCHAR LogicalMemoryName
    )
{

    switch (LogicalMemoryType) {
    case 0:
        _stprintf(LogicalMemoryName, TEXT("DONT_CARE   ") );
        break;
    case 1:
        _stprintf(LogicalMemoryName, TEXT("KERNEL_PAGED") );
        break;
    case 2:
        _stprintf(LogicalMemoryName, TEXT("KRNL_NONPAGD") );
        break;
    case 3:
        _stprintf(LogicalMemoryName, TEXT("HOST_MAPPED ") );
        break;
    case 4:
        _stprintf(LogicalMemoryName, TEXT("DEVICE_SPEC.") );
        break;
    case 5:
        _stprintf(LogicalMemoryName, TEXT("USER_MODE   ") );
        break;
    case 6:
        _stprintf(LogicalMemoryName, TEXT("HOST_ANYTYPE") );
        break;
    default:
        _stprintf(LogicalMemoryName, TEXT("UNKNOWN_MEM.") );
        break;
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
DerefPipeFromPin(
    IN IPin* Pin
    )
{
    IKsPin*         KsPin;
    IKsPinPipe*     KsPinPipe;
    IKsAllocatorEx* KsAllocator = NULL;
    IMemAllocator*  MemAllocator = NULL;
    HRESULT         hr;

    GetInterfacePointerNoLockWithAssert(Pin, __uuidof(IKsPin), KsPin, hr);
    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DerefPipeFromPin KsPin=%x, KsAlloc=%x MemAlloc=%x"), KsPin, KsAllocator, MemAllocator ));

    KsPinPipe->KsSetPipe(NULL);
    KsPin->KsReceiveAllocator(NULL);

    return TRUE;
}


STDMETHODIMP_(BOOL)
IsSpecialOutputReqs(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** OppositeKsPin,
    OUT ULONG* KsPinBufferSize,
    OUT ULONG* OppositeKsPinBufferSize
    )
/*++

Routine Description:

  This routine checks to see whether the filter identified by KsPin has special
  KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO requirements.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsPin*                    InKsPin;
    IKsPin*                    OutKsPin;
    IPin*                      Pin;
    ULONG                      PinCount = 0;
    IPin**                     PinList= NULL;
    IKsPin*                    ConnectedKsPin;
    IKsPinPipe*                ConnectedKsPinPipe;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    IKsAllocatorEx*            ConnectedKsAllocator;
    IKsAllocatorEx*            InKsAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx;
    PALLOCATOR_PROPERTIES_EX   OutAllocEx;
    BOOL                       SpecialFlagSet;
    HRESULT                    hr;
    ULONG                      i;
    PKSALLOCATOR_FRAMING_EX    InFramingEx, OutFramingEx;
    FRAMING_PROP               InFramingProp, OutFramingProp;
    KS_FRAMING_FIXED           InFramingExFixed, OutFramingExFixed;

    //
    // See if KsPin has the related pin with a pipe.
    //
    ConnectedKsAllocator = NULL;
    SpecialFlagSet = FALSE;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

    hr = Pin->QueryInternalConnections(NULL, &PinCount);
    if ( ! (SUCCEEDED( hr ) )) {
        ASSERT( 0 );
    }
    else if (PinCount) {
        if (NULL == (PinList = new IPin*[ PinCount ])) {
            hr = E_OUTOFMEMORY;
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR IsSpecialOutputReqs E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
        }
        else {
            hr = Pin->QueryInternalConnections(PinList, &PinCount);
            if ( ! (SUCCEEDED( hr ) )) {
                ASSERT( 0 );
            }
            else {
                //
                // Find first ConnectedKsPin in the PinList array that resides on different existing pipe,
                // that has non-zero buffer requirements.
                //
                for (i = 0; i < PinCount; i++) {
                    GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), ConnectedKsPin, hr);

                    GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                    ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                    if ( ConnectedKsAllocator ) {
                        PALLOCATOR_PROPERTIES_EX AllocEx = ConnectedKsAllocator->KsGetProperties();

                        if (AllocEx->cbBuffer) {
                            break;
                        }
                        else {
                            ConnectedKsAllocator = NULL;
                        }
                    }
                }
            }

            for (i=0; i<PinCount; i++) {
                PinList[i]->Release();
            }

            delete [] PinList;
        }
    }

    if ( ConnectedKsAllocator ) {
        //
        // This filter has another pin on different pipe. Lets see if any of these pins have
        // KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO in their framing.
        //
        // Lets order our pins WRT the data flow to simplify the function logic.
        //
        if (PinType == Pin_Output) {
            InKsPin = ConnectedKsPin;
            OutKsPin = KsPin;
        }
        else {
            InKsPin = KsPin;
            OutKsPin = ConnectedKsPin;
        }

        GetPinFramingFromCache(InKsPin, &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);
        GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);

        if (InFramingProp != FramingProp_None) {
            GetFramingFixedFromFramingByIndex(InFramingEx, 0, &InFramingExFixed);
            if (InFramingExFixed.Flags & KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO) {
                SpecialFlagSet = TRUE;
            }
        }

        if ( (! SpecialFlagSet) && (OutFramingProp != FramingProp_None) ) {
            GetFramingFixedFromFramingByIndex(OutFramingEx, 0, &OutFramingExFixed);
            if (OutFramingExFixed.Flags & KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO) {
                SpecialFlagSet = TRUE;
            }
        }

        if (SpecialFlagSet) {
            //
            // Lets see if the current pipes system is satisfactory.
            //
            GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);
            GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

            InKsAllocator = InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
            OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

            InAllocEx = InKsAllocator->KsGetProperties();
            OutAllocEx = OutKsAllocator->KsGetProperties();

            if (InAllocEx->cbBuffer > OutAllocEx->cbBuffer) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN  IsSpecialOutputReqs InKsPin=%x %d, OutKsPin=%x %d"),
                    InKsPin, InAllocEx->cbBuffer, OutKsPin, OutAllocEx->cbBuffer ));

                *OppositeKsPin = ConnectedKsPin;
                if (PinType == Pin_Output) {
                    *KsPinBufferSize = OutAllocEx->cbBuffer;
                    *OppositeKsPinBufferSize = InAllocEx->cbBuffer;
                }
                else {
                    *KsPinBufferSize = InAllocEx->cbBuffer;
                    *OppositeKsPinBufferSize = OutAllocEx->cbBuffer;
                }
            }
            else {
                SpecialFlagSet = FALSE;
            }
        }
    }

    return SpecialFlagSet;
}


STDMETHODIMP_(BOOL)
AdjustBufferSizeWithStepping(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    )
/*++

Routine Description:

  This routine tries to adjust the buffer size with stepping.

Arguments:

    AllocEx -
        properties of the pipe, being adjusted.

Return Value:

    TRUE / FALSE to reflect the success of this function.

--*/
{
    ULONG   ResBuffer;
    ULONG   Stepping = 0; // PrefixBug 4867
    BOOL    RetCode = TRUE;


    //
    // See what stepping needs to be used.
    //
    if (AllocEx->PhysicalRange.Stepping > 1) {
        Stepping = AllocEx->PhysicalRange.Stepping;
    }
    else if (AllocEx->Input.OptimalRange.Range.Stepping > 1) {
        Stepping = AllocEx->Input.OptimalRange.Range.Stepping;
    }

    if (Stepping > 1) {
        if (! AllocEx->cbBuffer) {
            AllocEx->cbBuffer = Stepping;
        }
        else {
            ResBuffer = (AllocEx->cbBuffer / Stepping) * Stepping;
            //
            // see if ResBuffer is inside the phys. range
            //
            if (! IsFramingRangeDontCare(AllocEx->PhysicalRange) ) {
                if ( ResBuffer < AllocEx->PhysicalRange.MinFrameSize) {
                    ResBuffer += Stepping;
                    if ( (ResBuffer < AllocEx->PhysicalRange.MinFrameSize) || (ResBuffer > AllocEx->PhysicalRange.MaxFrameSize) ) {
                        RetCode = FALSE;
                    }
                    else {
                        AllocEx->cbBuffer = ResBuffer;
                    }
                }
            }
            else if (! IsFramingRangeDontCare(AllocEx->Input.OptimalRange.Range) ) {
                if ( ResBuffer < AllocEx->Input.OptimalRange.Range.MinFrameSize) {
                    ResBuffer += Stepping;
                    if ( (ResBuffer < AllocEx->Input.OptimalRange.Range.MinFrameSize) ||
                         (ResBuffer > AllocEx->Input.OptimalRange.Range.MaxFrameSize) ) {

                        RetCode = FALSE;
                    }
                    else {
                        AllocEx->cbBuffer = ResBuffer;
                    }
                }
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
CanResizePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG RequestedSize
    )
/*++

Routine Description:

  This routine tries to resize the pipe.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

    RequestedSize -
        requested size of a resulting pipe.

Return Value:

    TRUE / FALSE

--*/
{

    IKsPinPipe*                KsPinPipe;
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    ULONG                      Scaled;
    KS_COMPRESSION             TempCompression;
    HRESULT                    hr;
    BOOL                       RetCode = TRUE;


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    AllocEx = KsAllocator->KsGetProperties();


    if (PinType == Pin_Input) {
        //
        // This is the end pin of a pipe being resized.
        //
        if ( (AllocEx->Output.PhysicalRange.MinFrameSize <= RequestedSize) &&
             (AllocEx->Output.PhysicalRange.MaxFrameSize >= RequestedSize) ) {
            //
            // It is possible to resize this pipe. Lets do it.
            //
            DivideKsCompression(AllocEx->Dimensions.EndPin, AllocEx->Dimensions.MaxExpansionPin, &TempCompression);
            ComputeUlongBasedOnCompression(RequestedSize, TempCompression, &Scaled);
            AllocEx->cbBuffer = (long) Scaled;
        }
        else {
            RetCode = FALSE;
        }
    }
    else { // PIn_Output
        //
        // This is the beginning pin of a pipe being resized.
        //
        if ( (AllocEx->Input.PhysicalRange.MinFrameSize <= RequestedSize) &&
             (AllocEx->Input.PhysicalRange.MaxFrameSize >= RequestedSize) ) {
            //
            // It is possible to resize this pipe. Lets do it.
            //
            ComputeUlongBasedOnCompression(RequestedSize, AllocEx->Dimensions.MaxExpansionPin, &Scaled);
            AllocEx->cbBuffer = (long) Scaled;
        }
        else {
            RetCode = FALSE;
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanResizePipe rets %d"), RetCode ));
    return RetCode;

}


STDMETHODIMP_(BOOL)
IsKernelModeConnection(
    IN IKsPin* KsPin
    )
{
    IKsPinPipe*  KsPinPipe;
    IPin*        ConnectedPin;
    HRESULT      hr;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    ConnectedPin = KsPinPipe->KsGetConnectedPin();
    if (ConnectedPin && IsKernelPin(ConnectedPin) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

CAsyncItemHandler::CAsyncItemHandler( DWORD *pResult ) :
    m_arrayCount( 0 ),
    m_wakeupReason( WAKEUP_EXIT ),
    m_hWakeupEvent( NULL ),
    m_hSlotSemaphore( NULL ),
    m_hItemMutex( NULL ),
    m_hThread( NULL ),
    m_threadId( 0 )
{
    DWORD status = 0;

    if (0 != (status = ItemListInitialize( &m_eventList ))) {
        DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler() couldn't initialize event list (0x%08X)."), status ));
    }

    if (0 == status) {
        if (!(m_hWakeupEvent = CreateEvent( NULL, FALSE, FALSE, NULL ))) {
            status = GetLastError();
            DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler() couldn't create wakeup event (0x%08X)."), status ));
        }
    }

    m_hEvents[ m_arrayCount++ ] = m_hWakeupEvent;

    if (0 == status) {
        if (!(m_hSlotSemaphore = CreateSemaphore( NULL, MAXIMUM_WAIT_OBJECTS - 1, MAXIMUM_WAIT_OBJECTS - 1, NULL ))) {
            status = GetLastError();
            DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler() couldn't create slot semaphore (0x%08X)."), status ));
        }
    }

    if (0 == status) {
        if (!(m_hItemMutex = CreateMutex( NULL, FALSE, NULL ))) {
            status = GetLastError();
            DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler() couldn't create item mutex (0x%08X)."), status ));
        }
    }

    if (0 == status) {
        if (!(m_AsyncEvent = CreateEvent( NULL, FALSE, TRUE, NULL ))) {
            status = GetLastError();
            DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler() couldn't create async event (0x%08X)."), status));
        }
    }

    if (0 == status) {
        if (!(m_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) AsyncItemProc, (LPVOID) this, 0, &m_threadId ))) {
            status = GetLastError();
            DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler() couldn't create event thread (0x%08X)."), status ));
        }
    }

    if (0 != status) {
        ItemListCleanup( &m_eventList ); // This is safe even if ItemListInitialize failed.
        m_arrayCount = 0;
        if (NULL != m_hWakeupEvent) {
            CloseHandle( m_hWakeupEvent );
            m_hWakeupEvent = NULL;
        }
        if (NULL != m_hSlotSemaphore) {
            CloseHandle( m_hSlotSemaphore );
            m_hSlotSemaphore = NULL;
        }
        if (NULL != m_hItemMutex) {
            CloseHandle( m_hItemMutex );
            m_hItemMutex = NULL;
        }
        if (NULL != m_AsyncEvent) {
            CloseHandle( m_AsyncEvent );
            m_AsyncEvent = NULL;
        }
        // Shouldn't be possible for 0 != status AND NULL != m_hThread...
    }

    if (NULL != pResult) {
        *pResult = status;
    }
}

CAsyncItemHandler::~CAsyncItemHandler( void )
{
    if (m_hThread) {
        //
        // Take the event to prevent any races on m_wakeupReason.  Only one 
        // operation happens on the thread at once.
        //
        WaitForSingleObjectEx( m_AsyncEvent, INFINITE, FALSE );

        m_wakeupReason = WAKEUP_EXIT;
        SetEvent( m_hWakeupEvent );
        WaitForSingleObjectEx( m_hThread, INFINITE, FALSE );
        EXECUTE_ASSERT(::CloseHandle( m_hThread ));
    }
    else {
        DbgLog(( LOG_TRACE, 0, TEXT("~CAsyncItemHandler() didn't find an active thread.") ));
    }

    ItemListCleanup( &m_eventList );

    m_hThread  = NULL;
    m_threadId = 0;
}

STDMETHODIMP_(DWORD)
CAsyncItemHandler::QueueAsyncItem( PASYNC_ITEM pItem )
{
    //
    // Take the event to prevent any races on m_wakeupReason.  Only one 
    // operation happens on the thread at once.
    //
    WaitForSingleObjectEx( m_AsyncEvent, INFINITE, FALSE );
    WaitForSingleObjectEx( m_hItemMutex, INFINITE, FALSE );

    DWORD status = WaitForSingleObjectEx( m_hSlotSemaphore, 0, FALSE );

    if (WAIT_OBJECT_0 == status) {
        m_hEvents[ m_arrayCount ]  = pItem->event;
        m_pItems[ m_arrayCount++ ] = pItem;
        m_wakeupReason = WAKEUP_NEWEVENT;
        SetEvent( m_hWakeupEvent );
    }
    else {
        // No slots currently open, add this event to the event list
        ItemListAppendItem( &m_eventList, (PITEM_LIST_ITEM) pItem );
    }

    ReleaseMutex( m_hItemMutex );

    return status;
}

STDMETHODIMP_(VOID)
CAsyncItemHandler::RemoveAsyncItem( HANDLE itemHandle )
{
    //
    // Take the event to prevent any races on m_wakeupReason.  Only one 
    // operation happens on the thread at once.
    //
    WaitForSingleObjectEx( m_AsyncEvent, INFINITE, FALSE);

    m_hRemove = itemHandle;
    m_wakeupReason = WAKEUP_REMOVEEVENT;
    SetEvent( m_hWakeupEvent );
}

DWORD WINAPI
CAsyncItemHandler::AsyncItemProc( CAsyncItemHandler *pThis )
{
    DWORD dwEventCount;

    do {
        DWORD status = WaitForMultipleObjectsEx( dwEventCount = pThis->m_arrayCount, pThis->m_hEvents, FALSE, INFINITE, FALSE );
        DWORD index;
        DWORD freeSlots;

        // Look for events going away...
        if (WAIT_FAILED == status) {
            DWORD flags;
            if (!GetHandleInformation( pThis->m_hEvents[ 0 ], &flags )) {
                // Our wakeup event went away, better bail
                break;
            }
            // BUGBUG: WAIT_FAILED may mean that one of our handles was closed on us...
            continue;
        }
        
        if (status < (WAIT_OBJECT_0 + dwEventCount)) {
            index  = status - WAIT_OBJECT_0;
        }
        else {
            DbgLog(( LOG_TRACE, 0, TEXT("AsyncItemProc() got 0x%08X from WaitForMultipleObjectsEx(), GetLastError() == 0x%08X."), status, GetLastError() ));
            continue;
        }

        if (0 == index) {
            // Wakeup event was signalled
            switch (pThis->m_wakeupReason) {
            case WAKEUP_REMOVEEVENT:
                {
                    DWORD   ndx;
                    WaitForSingleObjectEx( pThis->m_hItemMutex, INFINITE, FALSE );
                    freeSlots = 0;
                    for ( ndx = 1; ndx < pThis->m_arrayCount; ndx++) {
                        if (pThis->m_hEvents[ ndx ] == pThis->m_hRemove) {
                            pThis->m_pItems[ ndx ]->itemRoutine( EVENT_CANCELLED, pThis->m_pItems[ ndx ] );
                            // CloseHandle( pThis->m_hEvents[ ndx ] );
                            // delete pThis->m_pItems[ ndx ];
#ifdef DEBUG
                            pThis->m_pItems[ index ] = NULL;
#endif // DEBUG
                            pThis->m_arrayCount--;
                            if (ndx < pThis->m_arrayCount) {
                                MoveMemory( (void *) (pThis->m_hEvents + index),
                                         (void *) (pThis->m_hEvents + index + 1),
                                         (size_t) (pThis->m_arrayCount - index) * sizeof(pThis->m_hEvents[ 0 ]) );
                                MoveMemory( (void *) (pThis->m_pItems + index),
                                         (void *) (pThis->m_pItems + index + 1),
                                         (size_t) (pThis->m_arrayCount - index) * sizeof(pThis->m_pItems[ 0 ]) );
                            } // if (ndx < pThis->m_arrayCount)

                            PASYNC_ITEM pItem;
                            if (NULL != (pItem = (PASYNC_ITEM) ItemListGetFirstItem( &(pThis->m_eventList) ))) {
                                ItemListRemoveItem( &(pThis->m_eventList), (PITEM_LIST_ITEM) pItem );
                                pThis->m_hEvents[ pThis->m_arrayCount ]  = pItem->event;
                                pThis->m_pItems[ pThis->m_arrayCount++ ] = pItem;
                            }
                            else {
                                freeSlots++;
                            }
                        } // if (pThis->m_hArrayMutex[ ndx ] == pThis->m_hRemove)
                    } // for ( ndx = 1; ndx < pThis->m_arrayCount; ndx++)

                    // BUGBUG: Look through queued events for the given event

                    ReleaseMutex( pThis->m_hItemMutex );
                    // Take your pick: possibly fail the test and kill the pipeline, or possibly
                    // call ReleaseSemaphore with freeSlots == 0, incur a ring transition, and
                    // get back STATUS_INVALID_PARAMETER (which we're ignoring).
                    if (0 < freeSlots) {
                        ReleaseSemaphore( pThis->m_hSlotSemaphore, freeSlots, NULL );
                    }
                }

                //
                // Let this fall through....
                //
            case WAKEUP_EXIT: // handled at bottom of the loop
            case WAKEUP_NEWEVENT: // handled by updated pThis->m_arrayCount value
                //
                // For any control message to the async thread, signal back
                // the event to allow another control message to happen.
                //
                SetEvent (pThis->m_AsyncEvent);

                break;

            default:
                DbgLog(( LOG_TRACE, 0, TEXT("AsyncItemProc() found unknown wakeup reason (%d)."), pThis->m_wakeupReason ));
                break;
            }
        }
        else { // if (0 < index)
            ASSERT( NULL != pThis->m_pItems[ index ] );
            ASSERT( NULL != pThis->m_pItems[ index ]->itemRoutine );

            BOOLEAN remove = pThis->m_pItems[ index ]->remove;

            pThis->m_pItems[ index ]->itemRoutine( EVENT_SIGNALLED, pThis->m_pItems[ index ] );

            if (remove) {

#ifdef DEBUG
                pThis->m_pItems[ index ] = NULL;
#endif // DEBUG

                WaitForSingleObjectEx( pThis->m_hItemMutex, INFINITE, FALSE );
                pThis->m_arrayCount--;
                if (index < pThis->m_arrayCount) {
                    // Slide items down
                    MoveMemory( (void *) (pThis->m_hEvents + index),
                             (void *) (pThis->m_hEvents + index + 1),
                             (size_t) (pThis->m_arrayCount - index) * sizeof(pThis->m_hEvents[ 0 ]) );
                    MoveMemory( (void *) (pThis->m_pItems + index),
                             (void *) (pThis->m_pItems + index + 1),
                             (size_t) (pThis->m_arrayCount - index) * sizeof(pThis->m_pItems[ 0 ]) );
                }
    
                PASYNC_ITEM pItem;
                if (NULL != (pItem = (PASYNC_ITEM) ItemListGetFirstItem( &(pThis->m_eventList) ))) {
                    ItemListRemoveItem( &(pThis->m_eventList), (PITEM_LIST_ITEM) pItem );
                    pThis->m_hEvents[ pThis->m_arrayCount ]  = pItem->event;
                    pThis->m_pItems[ pThis->m_arrayCount++ ] = pItem;
                    freeSlots = 0;
                }
                else {
                    freeSlots = 1;
                }
            } else {
                freeSlots = 0;
            }

            ReleaseMutex( pThis->m_hItemMutex );
            // Take your pick: possibly fail the test and kill the pipeline, or possibly
            // call ReleaseSemaphore with freeSlots == 0, incur a ring transition, and
            // get back STATUS_INVALID_PARAMETER (which we're ignoring).
            if (0 < freeSlots) {
                ReleaseSemaphore( pThis->m_hSlotSemaphore, freeSlots, NULL );
            } // if (0 < freeSlots)
        }
    } while (WAKEUP_EXIT != pThis->m_wakeupReason);

    //
    // Cleanup
    //

    //
    // First, cleanup any permanent items.  (marked remove==FALSE)
    //
    DWORD origCount = pThis->m_arrayCount;
    for (DWORD ndx = 1; ndx < origCount; ndx++) {
        PASYNC_ITEM pItem = pThis->m_pItems [ndx];
        
        if (pItem && !pItem->remove) {
            pItem->itemRoutine (EVENT_CANCELLED, pItem);
            pThis->m_arrayCount--;
        }
    }

    CloseHandle( pThis->m_hItemMutex );
    pThis->m_hItemMutex = NULL;
    CloseHandle( pThis->m_hSlotSemaphore );
    pThis->m_hSlotSemaphore = NULL;
    CloseHandle( pThis->m_hWakeupEvent  );
    pThis->m_hWakeupEvent = NULL;
    CloseHandle( pThis->m_AsyncEvent );
    pThis->m_AsyncEvent = NULL;
    pThis->m_arrayCount--;

    if ((0 < pThis->m_arrayCount) || (0 < ItemListGetCount( &(pThis->m_eventList ) ))) {
        DbgLog(( LOG_TRACE, 0, TEXT("CAsyncItemHandler::AsyncItemProc( 0x%p ) exiting with %d events outstanding and %d events queued."), pThis, pThis->m_arrayCount, ItemListGetCount( &(pThis->m_eventList ) ) ));
    }

    return pThis->m_arrayCount;
}

DWORD
ItemListInitialize( PITEM_LIST_HEAD pHead )
{
    pHead->head.fLink = pHead->head.bLink = &(pHead->tail);
    pHead->tail.fLink = pHead->tail.bLink = &(pHead->head);
    pHead->count = 0;
    pHead->mutex = CreateMutex( NULL, FALSE, NULL );

    if (NULL == pHead->mutex) {
        return GetLastError();
    }

    return 0;
} // ItemListInitialize

VOID
ItemListCleanup( PITEM_LIST_HEAD pHead )
{
    ASSERT( 0 == pHead->count );

    if (NULL != pHead->mutex) {
        CloseHandle( pHead->mutex );
        pHead->mutex = NULL;
    }
}

__inline VOID
ItemListAppendItem( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pNewItem )
{
    ItemListInsertItemBefore( pHead, &(pHead->tail), pNewItem );
}

__inline DWORD
ItemListGetCount( PITEM_LIST_HEAD pHead )
{
    return (pHead->count);
}

__inline VOID
ItemListInsertItemAfter( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pOldItem, PITEM_LIST_ITEM pNewItem )
{
    ItemListInsertItemBefore( pHead, pOldItem->fLink, pNewItem );
}

VOID
ItemListInsertItemBefore( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pOldItem, PITEM_LIST_ITEM pNewItem )
{
    WaitForSingleObjectEx( pHead->mutex, INFINITE, FALSE );
    pNewItem->fLink = pOldItem;
    pNewItem->bLink = pOldItem->bLink;
    pNewItem->bLink->fLink = pNewItem;
    pNewItem->fLink->bLink = pNewItem;
    pHead->count++;
    ReleaseMutex( pHead->mutex );
}

PITEM_LIST_ITEM
ItemListRemoveItem( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pItem )
{
    if ((0 < pHead->count) && (NULL != pItem)) {
        WaitForSingleObjectEx( pHead->mutex, INFINITE, FALSE );
        pItem->bLink->fLink = pItem->fLink;
        pItem->fLink->bLink = pItem->bLink;
        pItem->fLink = pItem->bLink = NULL;
        pHead->count--;
        ReleaseMutex( pHead->mutex );
        return pItem;
    }
    
    return NULL;
}

PITEM_LIST_ITEM
ItemListGetFirstItem( PITEM_LIST_HEAD pHead )
{
    if (0 < pHead->count) {
        return pHead->head.fLink;
    }

    return NULL;
}

PITEM_LIST_ITEM
ItemListGetLastItem( PITEM_LIST_HEAD pHead )
{
    if (0 < pHead->count) {
        return pHead->tail.bLink;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksqmf\ksqmf.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksqmf.h

Abstract:

    Internal header.

--*/

class CKsQualityF :
    public CUnknown,
    public IKsQualityForwarder {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CKsQualityF(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);
    ~CKsQualityF();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID InterfaceId,
        PVOID* Interface);

    // Implement IKsQualityForwarder
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();
    STDMETHODIMP_(VOID) KsFlushClient(
        IKsPin* Pin);

private:
    static HRESULT QualityThread(
        CKsQualityF* KsQualityF);

    HANDLE m_QualityManager;
    HANDLE m_Thread;
    HANDLE m_TerminateEvent;
    HANDLE m_FlushEvent;
    HANDLE m_FlushSemaphore;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksuser\ksuser.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksuser.c

Abstract:

    This module contains the user-mode helper functions for streaming.

--*/

#include "ksuser.h"

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE (HANDLE)-1
#endif // INVALID_HANDLE_VALUE

static const WCHAR AllocatorString[] = KSSTRING_Allocator;
static const WCHAR ClockString[] = KSSTRING_Clock;
static const WCHAR PinString[] = KSSTRING_Pin;
static const WCHAR NodeString[] = KSSTRING_TopologyNode;


DWORD
KsiCreateObjectType(
    IN HANDLE ParentHandle,
    IN PWCHAR RequestType,
    IN PVOID CreateParameter,
    IN ULONG CreateParameterLength,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ObjectHandle
    )
/*++

Routine Description:

    Uses NtCreateFile to create a handle relative to the ParentHandle specified.
    This is a handle to a sub-object such as a Pin, Clock, or Allocator.
    Passes the parameters as the file system-specific data.

Arguments:

    ParentHandle -
        Contains the handle of the parent used in initializing the object
        attributes passed to NtCreateFile. This is normally a handle to a
        filter or pin.

    RequestType -
        Contains the type of sub-object to create. This is the standard string
        representing the various object types.
        
    CreateParameter -
        Contains the request-specific data to pass to NtCreateFile.

    CreateParameterLength -
        Contains the length of the create parameter passed.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    ObjectHandle -
        The place in which to put the resultant handle for the request.

Return Value:

    Returns any NtCreateFile error.

--*/
{
    ULONG NameLength;
    PWCHAR FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    //
    // Build a structure consisting of:
    //     "<request type>\<params>"
    // The <params> is a binary structure which is extracted on the other end.
    //
    NameLength = wcslen(RequestType);
    FileName = (PWCHAR)HeapAlloc(
        GetProcessHeap(),
        0,
        NameLength * sizeof(*FileName) + sizeof(OBJ_NAME_PATH_SEPARATOR) + CreateParameterLength);
    if (!FileName) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(FileName, RequestType);
    FileName[NameLength] = OBJ_NAME_PATH_SEPARATOR;
    RtlCopyMemory(&FileName[NameLength + 1], CreateParameter, CreateParameterLength);
    FileNameString.Buffer = FileName;
    FileNameString.Length = (USHORT)(NameLength * sizeof(*FileName) + sizeof(OBJ_NAME_PATH_SEPARATOR) + CreateParameterLength);
    FileNameString.MaximumLength = FileNameString.Length;
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileNameString,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL);
    Status = NtCreateFile(
        ObjectHandle,
        DesiredAccess,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OPEN,
        0,
        NULL,
        0);
    HeapFree(GetProcessHeap(), 0, FileName);
    if (NT_SUCCESS(Status)) {
        return ERROR_SUCCESS;
    } else {
        *ObjectHandle = INVALID_HANDLE_VALUE;
    }
    return RtlNtStatusToDosError(Status);
}


KSDDKAPI
DWORD
WINAPI
KsCreateAllocator(
    IN HANDLE ConnectionHandle,
    IN PKSALLOCATOR_FRAMING AllocatorFraming,
    OUT PHANDLE AllocatorHandle
    )

/*++

Routine Description:

    Creates a handle to a allocator instance.

Arguments:

    ConnectionHandle -
        Contains the handle to the connection on which to create the allocator.

    AllocatorCreate -
        Contains the allocator create request information.

    AllocatorHandle -
        Place in which to put the allocator handle.

Return Value:

    Returns any NtCreateFile error.

--*/

{
    return KsiCreateObjectType(
        ConnectionHandle,
        (PWCHAR)AllocatorString,
        AllocatorFraming,
        sizeof(*AllocatorFraming),
        GENERIC_READ,
        AllocatorHandle);
}


KSDDKAPI
DWORD
WINAPI
KsCreateClock(
    IN HANDLE ConnectionHandle,
    IN PKSCLOCK_CREATE ClockCreate,
    OUT PHANDLE ClockHandle
    )
/*++

Routine Description:

    Creates a handle to a clock instance.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    ConnectionHandle -
        Contains the handle to the connection on which to create the clock.

    ClockCreate -
        Contains the clock create request information.

    ClockHandle -
        Place in which to put the clock handle.

Return Value:

    Returns any NtCreateFile error.

--*/
{
    return KsiCreateObjectType(
        ConnectionHandle,
        (PWCHAR)ClockString,
        ClockCreate,
        sizeof(*ClockCreate),
        GENERIC_READ,
        ClockHandle);
}


KSDDKAPI
DWORD
WINAPI
KsCreatePin(
    IN HANDLE FilterHandle,
    IN PKSPIN_CONNECT Connect,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ConnectionHandle
    )
/*++

Routine Description:

    Creates a handle to a pin instance.

Arguments:

    FilterHandle -
        Contains the handle to the filter on which to create the pin.

    Connect -
        Contains the connection request information.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    ConnectionHandle -
        Place in which to put the pin handle.

Return Value:

    Returns any NtCreateFile error.

--*/
{
    ULONG ConnectSize;
    PKSDATAFORMAT DataFormat;

    DataFormat = (PKSDATAFORMAT)(Connect + 1);
    ConnectSize = DataFormat->FormatSize;
    if (DataFormat->Flags & KSDATAFORMAT_ATTRIBUTES) {
        ConnectSize = (ConnectSize + 7) & ~7;
        ConnectSize += ((PKSMULTIPLE_ITEM)((PUCHAR)DataFormat + ConnectSize))->Size;
    }
    ConnectSize += sizeof(*Connect);
    return KsiCreateObjectType(
        FilterHandle,
        (PWCHAR)PinString,
        Connect,
        ConnectSize,
        DesiredAccess,
        ConnectionHandle);
}


KSDDKAPI
DWORD
WINAPI
KsCreateTopologyNode(
    IN HANDLE ParentHandle,
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE NodeHandle
    )
/*++

Routine Description:

    Creates a handle to a topology node instance. This may only be called at
    PASSIVE_LEVEL.

Arguments:

    ParentHandle -
        Contains the handle to the parent on which the node is created.

    NodeCreate -
        Specifies topology node create parameters.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    NodeHandle -
        Place in which to put the topology node handle.

Return Value:

    Returns any NtCreateFile error.

--*/
{
    return KsiCreateObjectType(
        ParentHandle,
        (PWCHAR)NodeString,
        NodeCreate,
        sizeof(*NodeCreate),
        DesiredAccess,
        NodeHandle);
}


BOOL
DllInstanceInit(
    HANDLE InstanceHandle,
    DWORD Reason,
    LPVOID Reserved
    )
/*++

Routine Description:

    The initialization function for the DLL.

Arguments:

    InstanceHandle - 
        Not used.

    Reason - 
        Not used.

    Reserved - 
        Not used.

Return Value:

    TRUE.

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksuser\ksuser.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    private.h

Abstract:

    Internal header.

--*/

#include <wdm.h>
#include <windef.h>
#include <winerror.h>
#undef _NTDDK_
typedef ULONGLONG DWORDLONG;
#include <ks.h>

NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    IN NTSTATUS Status
    );

#define WINBASEAPI DECLSPEC_IMPORT

WINBASEAPI
LPVOID
WINAPI
HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    );

WINBASEAPI
BOOL
WINAPI
HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );

WINBASEAPI
HANDLE
WINAPI
GetProcessHeap(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\bytestrm.h ===
#ifndef __BYTE_STREAM__H
#define __BYTE_STREAM__H

class Byte_Stream {
public:
    void Initialize( LPBYTE lpByte, UINT len ) {
        lpByteBufferStart = lpByteBuffer = lpByte;
        lpByteBufferEnd = lpByte + len;
    }
	operator BOOL(){return !EndOfStream();};
    UINT GetPosition() {
        return lpByteBuffer - lpByteBufferStart;
    }
    UINT GetPositionFromEnd() {
        return lpByteBufferEnd - lpByteBuffer;
    }

    BYTE GetByte() {
        return *(lpByteBuffer++);
    }
    BYTE PeekBYTE() {
        return *lpByteBuffer;
    }
    UINT GetNextByte(UINT x) {
        return (x << 8) + GetByte();
    }
    UINT GetWORD() {
        return GetNextByte(GetByte());
    }

    BOOL EndOfStream() {
        return lpByteBuffer >= lpByteBufferEnd;
    }

    UINT PeekUINT() {
        return ByteSwap(Peek4BYTES());
    }

    DWORD GetUINT() {
        DWORD dwx = ByteSwap(Peek4BYTES());
        Advance(sizeof(DWORD));
        return dwx;
    }

    UINT Peek4BYTES() {
        return *(UNALIGNED UINT *)lpByteBuffer;
    }

    void Advance(UINT Delta) {
        lpByteBuffer += Delta;
    }

    LPBYTE GetBytePointer() {
        return lpByteBuffer;
    }

    LPBYTE GetByteStartPointer() {
        return lpByteBufferStart;
    }

    LPBYTE GetByteEndPointer() {
        return lpByteBufferEnd;
    }

    UINT ByteSwap(UINT dw) {
        return _lrotl(((dw & 0xFF00FF00) >> 8) | ((dw & 0x00FF00FF) << 8), 16);
    }
private:
    LPBYTE  lpByteBuffer;
    LPBYTE  lpByteBufferEnd;
    LPBYTE  lpByteBufferStart;
};

class Output_File{
public:
	Output_File(TCHAR * filename=NULL):m_hFile(INVALID_HANDLE_VALUE){
		if (filename)
			lstrcpy(szFileName,filename);
	}

	~Output_File(){
		if (m_hFile != INVALID_HANDLE_VALUE){
			CloseHandle(m_hFile);
		}
	}

	void SetFileName(TCHAR * filename){
		if (filename)
			lstrcpy(szFileName,filename);
	};

	// method for reading data from packet
	void WriteData(BYTE *lpData, UINT cbCount){
	   if (szFileName[0] == '\0')
		   return;

   	// a file han't been created so create one
	   if (m_hFile == INVALID_HANDLE_VALUE){
		   // set our filename
	      m_hFile = CreateFile(szFileName,
							 GENERIC_WRITE,          // Access mode
							 FILE_SHARE_WRITE,       // Share mode
							 0,                  // Security descriptor
							 CREATE_NEW,         // Creation flags
							 FILE_ATTRIBUTE_NORMAL, // Attributes
							 0);                 // Copy attributes
		   // error
		   if (m_hFile == INVALID_HANDLE_VALUE) {
			   return;
		   }
	   }
	
	   DWORD dw;

	   // write the data to the file
	   WriteFile(m_hFile,lpData,cbCount,&dw,(LPOVERLAPPED)NULL);
   };

private:
	HANDLE m_hFile;
	TCHAR szFileName[MAX_PATH];

};

#endif //__BYTE_STREAM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\list.h ===
#ifndef __LIST_UTIL__H__
#define __LIST_UTIL__H__

class TListIterator{
public:
	// constructor
    TListIterator():
	  m_pNext(NULL),
      m_pPrev(NULL),
      m_pData(NULL){};
	~TListIterator(){};


    TListIterator *Prev(){ return m_pPrev; };
    TListIterator *Next(){ return m_pNext; };

    void SetPrev(TListIterator *p){ m_pPrev = p; };
    void SetNext(TListIterator *p){ m_pNext = p; };
    void * GetData(){ return m_pData; };
    void SetData(void * p){ m_pData = p; };
private:
    TListIterator *m_pPrev;
    TListIterator *m_pNext;
    void  *m_pData;
};




template <class OBJECT> class TList
{
public:
	// constructior
    TList():m_pFirst(NULL),m_pLast(NULL),m_Count(0){};
	// destructor
    ~TList(){ Flush();};
	// useful methods
    TListIterator * GetHead(){return m_pFirst;};
	TListIterator * GetTail(){return m_pLast;};
	int GetCount(){return m_Count;};

    TListIterator * Next(TListIterator * pos){
        if (pos == NULL)
           return m_pFirst;
        return pos->Next();
    };

    TListIterator * Prev(TListIterator * pos){
        if (pos == NULL)
            return m_pLast;
        return pos->Prev();
    };

	OBJECT *GetData(TListIterator *pos){
		return (OBJECT *)pos->GetData();
	};

	TListIterator* AddTail(OBJECT * pObj){
		TListIterator *pNode = new TListIterator();
		if (pNode == NULL) return NULL;

		pNode->SetData((void *)pObj);
		pNode->SetNext(NULL);
		pNode->SetPrev(m_pLast);

		if (m_pLast)
			m_pLast->SetNext(pNode);
		else
			m_pFirst = pNode;

	    m_pLast = pNode;
		m_Count++;

		return pNode;
	};

    TListIterator* AddHead(OBJECT * pObj){
		TListIterator *pNode = new TListIterator();
		if (pNode == NULL) return NULL;

		pNode->SetData((void *)pObj);
		pNode->SetNext(NULL);
		pNode->SetPrev(m_pLast);

		if (m_pFirst)
			m_pFirst->SetPrev(pNode);
		else
			m_pLast = pNode;

		m_pFirst = pNode;
		m_Count++;

		return pNode;
	};

    TListIterator* Insert(TListIterator * pAfter, OBJECT * pObj){
		if (pAfter==NULL)
			return AddHead(pObj);

		if (pAfter==m_pLast)
			return AddTail(pObj);

		TListIterator *pNode = new TListIterator();
		if (pNode == NULL) return NULL;

		pNode->SetData((void *)pObj);
		TListIterator* pBefore = pAfter->Next();
		pNode->SetPrev(pAfter);
		pNode->SetNext(pBefore);
		pBefore->SetPrev(pNode);
		pAfter->SetNext(pNode);
		m_Count++;
		return pNode;
	};


    TListIterator* Find( OBJECT * pObj){
		for(TListIterator* pNode = GetHead(); pNode != NULL; pNode=pNode->Next()){
			if (GetData(pNode)==pObj) {
				return pNode;
			}
		}
		return NULL;
	};

    OBJECT * Remove(TListIterator * pCurrent){
	    if (pCurrent==NULL) return NULL;

	    TListIterator *pNode = pCurrent->Prev();
	    if (pNode)
			pNode->SetNext(pCurrent->Next());
		else
		    m_pFirst = pCurrent->Next();

	    pNode = pCurrent->Next();

		if (pNode)
			pNode->SetPrev(pCurrent->Prev());
		else
			m_pLast = pCurrent->Prev();

		m_Count--;
	    return (OBJECT *)GetData(pCurrent);
	};

	void Flush(){
		for(TListIterator* pNode = GetHead(); pNode != NULL; pNode=pNode->Next()){
			Remove(pNode);
		}
		m_pFirst = m_pLast = NULL;
	};

private:
    TListIterator* m_pFirst;
    TListIterator* m_pLast;
    LONG m_Count;
};
#endif //__LIST_UTIL__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksvpintf\ksvpintf.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation.

Module Name:

    ksvpintf.h

Abstract:

    Internal header.

--*/

class CVPInterfaceHandler :
    public CUnknown,
    public IDistributorNotify {

public:
    CVPInterfaceHandler(
        LPUNKNOWN pUnk,
        TCHAR* Name,
        HRESULT* phr,
        const GUID* pPropSetID,
        const GUID* pEventSetID);
    virtual ~CVPInterfaceHandler();

    HRESULT CreateThread();
    void ExitThread();
    static DWORD WINAPI InitialThreadProc(CVPInterfaceHandler *pThread);
    virtual DWORD NotifyThreadProc() = 0;

    HRESULT GetConnectInfo(
        LPDWORD NumConnectInfo,
        LPDDVIDEOPORTCONNECT ConnectInfo);
    HRESULT SetConnectInfo(
        DWORD ConnectInfoIndex);
    HRESULT GetVPDataInfo(
        LPAMVPDATAINFO VPDataInfo);
    HRESULT GetMaxPixelRate(
        LPAMVPSIZE Size,
        LPDWORD MaxPixelsPerSecond);
    HRESULT InformVPInputFormats(
        DWORD NumFormats,
        LPDDPIXELFORMAT PixelFormats);
    HRESULT GetVideoFormats(
        LPDWORD NumFormats,
        LPDDPIXELFORMAT PixelFormats);
    HRESULT SetVideoFormat(
        DWORD PixelFormatIndex);
    HRESULT SetInvertPolarity();
    HRESULT GetOverlaySurface(
        LPDIRECTDRAWSURFACE* OverlaySurface);
    HRESULT IsVPDecimationAllowed(
        LPBOOL IsDecimationAllowed);
    HRESULT SetScalingFactors(
        LPAMVPSIZE Size);
    HRESULT SetDirectDrawKernelHandle(
        ULONG_PTR DDKernelHandle);
    HRESULT SetVideoPortID(
        DWORD VideoPortID);
    HRESULT SetDDSurfaceKernelHandles(
        DWORD cHandles,
        ULONG_PTR* rgHandles);
    HRESULT SetSurfaceParameters(
        DWORD dwPitch,
        DWORD dwXOrigin,
        DWORD dwYOrigin);

    // Implement IDistributorNotify
    STDMETHODIMP Stop() {return S_OK;};
    STDMETHODIMP Pause() {return S_OK;};
    STDMETHODIMP Run(REFERENCE_TIME Start)  {return S_OK;};
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock)  {return S_OK;};
    STDMETHODIMP NotifyGraphChange();


protected:
    HANDLE m_ObjectHandle;
    HANDLE m_EndEventHandle;
    IPin* m_Pin;
    KSEVENTDATA m_EventData;
    HANDLE m_NotifyEventHandle;

private:
    HANDLE m_ThreadHandle;
    const GUID* m_pPropSetID;
    const GUID* m_pEventSetID;
};

class CVPVideoInterfaceHandler :
    private CVPInterfaceHandler,
    public IVPConfig {

public:
    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN pUnk,
        HRESULT* phr);

    ~CVPVideoInterfaceHandler();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    DWORD NotifyThreadProc();

    // Implement IVPConfig
    STDMETHODIMP GetConnectInfo(
        LPDWORD NumConnectInfo,
        LPDDVIDEOPORTCONNECT ConnectInfo)
    {
        return CVPInterfaceHandler::GetConnectInfo(NumConnectInfo, ConnectInfo);
    }
    STDMETHODIMP SetConnectInfo(
        DWORD ConnectInfoIndex)
    {
        return CVPInterfaceHandler::SetConnectInfo(ConnectInfoIndex);
    }
    STDMETHODIMP GetVPDataInfo(
        LPAMVPDATAINFO VPDataInfo)
    {
        return CVPInterfaceHandler::GetVPDataInfo(VPDataInfo);
    }
    STDMETHODIMP GetMaxPixelRate(
        LPAMVPSIZE Size,
        LPDWORD MaxPixelsPerSecond)
    {
        return CVPInterfaceHandler::GetMaxPixelRate(Size, MaxPixelsPerSecond);
    }
    STDMETHODIMP InformVPInputFormats(
        DWORD NumFormats,
        LPDDPIXELFORMAT PixelFormats)
    {
        return CVPInterfaceHandler::InformVPInputFormats(NumFormats, PixelFormats);
    }
    STDMETHODIMP GetVideoFormats(
        LPDWORD NumFormats,
        LPDDPIXELFORMAT PixelFormats)
    {
        return CVPInterfaceHandler::GetVideoFormats(NumFormats, PixelFormats);
    }
    STDMETHODIMP SetVideoFormat(
        DWORD PixelFormatIndex)
    {
        return CVPInterfaceHandler::SetVideoFormat(PixelFormatIndex);
    }
    STDMETHODIMP SetInvertPolarity()
    {
        return CVPInterfaceHandler::SetInvertPolarity();
    }
    STDMETHODIMP GetOverlaySurface(
        LPDIRECTDRAWSURFACE* OverlaySurface)
    {
        return CVPInterfaceHandler::GetOverlaySurface(OverlaySurface);
    }
    STDMETHODIMP IsVPDecimationAllowed(
        LPBOOL IsDecimationAllowed)
    {
        return CVPInterfaceHandler::IsVPDecimationAllowed(IsDecimationAllowed);
    }
    STDMETHODIMP SetScalingFactors(
        LPAMVPSIZE Size)
    {
        return CVPInterfaceHandler::SetScalingFactors(Size);
    }
    STDMETHODIMP SetDirectDrawKernelHandle(
        ULONG_PTR DDKernelHandle)
    {
        return CVPInterfaceHandler::SetDirectDrawKernelHandle(DDKernelHandle);
    }
    STDMETHODIMP SetVideoPortID(
        DWORD VideoPortID)
    {
        return CVPInterfaceHandler::SetVideoPortID(VideoPortID);
    }
    STDMETHODIMP SetDDSurfaceKernelHandles(
        DWORD cHandles,
        ULONG_PTR* rgHandles)
    {
        return CVPInterfaceHandler::SetDDSurfaceKernelHandles(cHandles, rgHandles);
    }
    STDMETHODIMP SetSurfaceParameters(
        DWORD dwPitch,
        DWORD dwXOrigin,
        DWORD dwYOrigin) {
        return CVPInterfaceHandler::SetSurfaceParameters(dwPitch, dwXOrigin, dwYOrigin);
    }

private:
    CVPVideoInterfaceHandler(
        LPUNKNOWN pUnk,
        TCHAR* Name,
        HRESULT* phr);

};

class CVPVBIInterfaceHandler :
    private CVPInterfaceHandler,
    public IVPVBIConfig {

public:
    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN pUnk,
        HRESULT* phr);

    ~CVPVBIInterfaceHandler();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    DWORD NotifyThreadProc();

    // Implement IVPVBIConfig
    STDMETHODIMP GetConnectInfo(
        LPDWORD NumConnectInfo,
        LPDDVIDEOPORTCONNECT ConnectInfo)
    {
        return CVPInterfaceHandler::GetConnectInfo(NumConnectInfo, ConnectInfo);
    }
    STDMETHODIMP SetConnectInfo(
        DWORD ConnectInfoIndex)
    {
        return CVPInterfaceHandler::SetConnectInfo(ConnectInfoIndex);
    }
    STDMETHODIMP GetVPDataInfo(
        LPAMVPDATAINFO VPDataInfo)
    {
        return CVPInterfaceHandler::GetVPDataInfo(VPDataInfo);
    }
    STDMETHODIMP GetMaxPixelRate(
        LPAMVPSIZE Size,
        LPDWORD MaxPixelsPerSecond)
    {
        return CVPInterfaceHandler::GetMaxPixelRate(Size, MaxPixelsPerSecond);
    }
    STDMETHODIMP InformVPInputFormats(
        DWORD NumFormats,
        LPDDPIXELFORMAT PixelFormats)
    {
        return CVPInterfaceHandler::InformVPInputFormats(NumFormats, PixelFormats);
    }
    STDMETHODIMP GetVideoFormats(
        LPDWORD NumFormats,
        LPDDPIXELFORMAT PixelFormats)
    {
        return CVPInterfaceHandler::GetVideoFormats(NumFormats, PixelFormats);
    }
    STDMETHODIMP SetVideoFormat(
        DWORD PixelFormatIndex)
    {
        return CVPInterfaceHandler::SetVideoFormat(PixelFormatIndex);
    }
    STDMETHODIMP SetInvertPolarity()
    {
        return CVPInterfaceHandler::SetInvertPolarity();
    }
    STDMETHODIMP GetOverlaySurface(
        LPDIRECTDRAWSURFACE* OverlaySurface)
    {
        return CVPInterfaceHandler::GetOverlaySurface(OverlaySurface);
    }
    STDMETHODIMP SetDirectDrawKernelHandle(
        ULONG_PTR DDKernelHandle)
    {
        return CVPInterfaceHandler::SetDirectDrawKernelHandle(DDKernelHandle);
    }
    STDMETHODIMP SetVideoPortID(
        DWORD VideoPortID)
    {
        return CVPInterfaceHandler::SetVideoPortID(VideoPortID);
    }
    STDMETHODIMP SetDDSurfaceKernelHandles(
        DWORD cHandles,
        ULONG_PTR* rgHandles)
    {
        return CVPInterfaceHandler::SetDDSurfaceKernelHandles(cHandles, rgHandles);
    }
    STDMETHODIMP SetSurfaceParameters(
        DWORD dwPitch,
        DWORD dwXOrigin,
        DWORD dwYOrigin) {
        return CVPInterfaceHandler::SetSurfaceParameters(dwPitch, dwXOrigin, dwYOrigin);
    }

private:
    CVPVBIInterfaceHandler(
        LPUNKNOWN pUnk,
        TCHAR* Name,
        HRESULT* phr);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksvpintf\ksvpintf.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ksvpintf.cpp

Abstract:

    Provides a Property set interface handler for VPE.

--*/

#include <windows.h>
#include <streams.h>
#include "devioctl.h"
#include "ddraw.h"
#include "dvp.h"
#include "vptype.h"
#include "vpconfig.h"
#include "vpnotify.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksvpintf.h"

interface DECLSPEC_UUID("bc29a660-30e3-11d0-9e69-00c04fd7c15b") IVPConfig;
interface DECLSPEC_UUID("c76794a1-d6c5-11d0-9e69-00c04fd7c15b") IVPNotify;

interface DECLSPEC_UUID("ec529b00-1a1f-11d1-bad9-00609744111a") IVPVBIConfig;
interface DECLSPEC_UUID("ec529b01-1a1f-11d1-bad9-00609744111a") IVPVBINotify;

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {L"VPConfigPropSet", &KSPROPSETID_VPConfig, CVPVideoInterfaceHandler::CreateInstance},
    {L"VPVBIConfigPropSet", &KSPROPSETID_VPVBIConfig, CVPVBIInterfaceHandler::CreateInstance}
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CVPInterfaceHandler::CVPInterfaceHandler(
    LPUNKNOWN UnkOuter,
    TCHAR* Name,
    HRESULT* hr,
    const GUID* PropSetID,
    const GUID* EventSetID) :
    CUnknown(Name, UnkOuter),
    m_ObjectHandle(NULL),
    m_EndEventHandle(NULL),
    m_Pin(NULL),
    m_ThreadHandle(NULL),
    m_pPropSetID(PropSetID),
    m_pEventSetID(EventSetID),
    m_NotifyEventHandle(NULL)
/*++

Routine Description:

    The constructor for the VPE Config Property Set objects. Does base class
    initialization for the VP config interface objects.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

    PropSetID -
        Specifies which property set is being used. This could be
        KSPROPSETID_VPConfig, or KSPROPSETID_VPVBIConfig.

Return Value:

    Nothing.

--*/
{
    if (UnkOuter) {
        IKsObject *pKsObject;

        //
        // The parent must support the IKsObject interface in order to obtain
        // the handle to communicate to
        //
        *hr = UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
        if (!FAILED(*hr)) {
            m_ObjectHandle = pKsObject->KsGetObjectHandle();
            ASSERT(m_ObjectHandle != NULL);

            *hr = UnkOuter->QueryInterface(IID_IPin, reinterpret_cast<PVOID*>(&m_Pin));
            if (!FAILED(*hr)) {
                DbgLog((LOG_TRACE, 0, TEXT("IPin interface of pOuter is 0x%lx"), m_Pin));
                //
                // Holding this ref count will prevent the proxy ever being destroyed
                //
                m_Pin->Release();
            }
            pKsObject->Release();
        }
    } else {
        *hr = VFW_E_NEED_OWNER;
    }
}


CVPInterfaceHandler::~CVPInterfaceHandler(
    )
/*++

Routine Description:

    The destructor for the VPE Config Property Set object. Randomly performs
    an ExitThread to try and cover up any bugs.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    DbgLog((LOG_TRACE, 0, TEXT("Destroying CVPInterfaceHandler...")));
    //
    // Make sure there is no dangling thread
    //
    ExitThread();
}


STDMETHODIMP 
CVPInterfaceHandler::NotifyGraphChange(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::NotifyGraphChange method. Since this potentially changes
    the pin handle, it must be refetched.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    HRESULT hr;
    IKsObject *pKsObject;

    ASSERT(m_Pin != NULL);

    hr = m_Pin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
    if (SUCCEEDED(hr)) {
        m_ObjectHandle = pKsObject->KsGetObjectHandle();

        pKsObject->Release();
        //
        // Re-enable the event on a reconnect, else ignore on a disconnect.
        //
        if (m_ObjectHandle) {
            KSEVENT Event;
            DWORD BytesReturned;

            m_EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
            m_EventData.EventHandle.Event = m_NotifyEventHandle;
            m_EventData.EventHandle.Reserved[0] = 0;
            m_EventData.EventHandle.Reserved[1] = 0;
            Event.Set = *m_pEventSetID;
            Event.Id = KSEVENT_VPNOTIFY_FORMATCHANGE;
            Event.Flags = KSEVENT_TYPE_ENABLE;
            hr = ::KsSynchronousDeviceControl
                ( m_ObjectHandle
                , IOCTL_KS_ENABLE_EVENT
                , &Event
                , sizeof(Event)
                , &m_EventData
                , sizeof(m_EventData)
                , &BytesReturned
                );
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 0, TEXT("Event notification set up failed (hr = 0x%lx)"), hr));
            } else {
                DbgLog((LOG_TRACE, 0, TEXT("Event notification set up right")));
            }
        }
    }

    return S_OK;
}

HRESULT
CVPInterfaceHandler::CreateThread(void)
{
    HRESULT hr = NOERROR;

    if (m_ThreadHandle == NULL)
    {
        m_EndEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (m_EndEventHandle != NULL)
        {
            DWORD  ThreadId;

            m_ThreadHandle = ::CreateThread
                ( NULL
                , 0
                , reinterpret_cast<LPTHREAD_START_ROUTINE>(InitialThreadProc)
                , reinterpret_cast<LPVOID>(this)
                , 0
                , &ThreadId
                );
            if (m_ThreadHandle == NULL)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DbgLog((LOG_ERROR, 0, TEXT("Couldn't create a thread")));

                CloseHandle(m_EndEventHandle), m_EndEventHandle = NULL;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DbgLog((LOG_ERROR, 0, TEXT("Couldn't create an event")));
        }
    }

    return hr;
}


void
CVPInterfaceHandler::ExitThread(
    )
{
    //
    // Check if a thread was created
    //
    if (m_ThreadHandle)
    {
        ASSERT(m_EndEventHandle != NULL);

        /*  Tell the thread to exit
         */
        if (SetEvent(m_EndEventHandle))
        {
            //
            // Synchronize with thread termination.
            //
            DbgLog((LOG_TRACE, 0, TEXT("Wait for thread to terminate")));

            WaitForSingleObjectEx(m_ThreadHandle, INFINITE, FALSE);
        }
        else
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: Couldn't even signal the closing event!! [%x]"), GetLastError()));

        CloseHandle(m_EndEventHandle), m_EndEventHandle = NULL;
        CloseHandle(m_ThreadHandle), m_ThreadHandle = NULL;
    }
}


DWORD
WINAPI
CVPInterfaceHandler::InitialThreadProc(
    CVPInterfaceHandler *pThread
    )
{
    return pThread->NotifyThreadProc();
}


HRESULT
CVPInterfaceHandler::GetConnectInfo(
    LPDWORD NumConnectInfo,
    LPDDVIDEOPORTCONNECT ConnectInfo
    )
/*++

Routine Description:

    Implement the IVPConfig::GetConnectInfo method. This queries for either the
    number of DDVIDEOPORTCONNECT structures supported by the driver, or returns
    as many structures as can fit into the provided buffer space.

Arguments:

    NumConnectInfo -
        Points to a buffer which optionally contains the number of DDVIDEOPORTCONNECT
        structure provided by ConnectInfo. In this case it is updated with the actual
        number of structures returned. If ConnectInfo is NULL, this is merely updated
        with the number of structures supported by the driver.

    ConnectInfo -
        Points to an array of DDVIDEOPORTCONNECT structures which are filled in by
        the driver, or NULL when the count only of the structures is to be returned.

Return Value:

    Returns NOERROR if the count and/or structures were returned, else a driver error.

--*/
{
    HRESULT                 hr;
    KSMULTIPLE_DATA_PROP    MultiProperty;
    ULONG                   BytesReturned;

    MultiProperty.Property.Set = *m_pPropSetID;
    MultiProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // A null ConnectInfo implies a query for just the number of data items.
    // The device knows this is a count query because the size of the buffer
    // passed is a DWORD.
    //
    if (!ConnectInfo) {
        MultiProperty.Property.Id = KSPROPERTY_VPCONFIG_NUMCONNECTINFO;
        return ::KsSynchronousDeviceControl(
            m_ObjectHandle,
            IOCTL_KS_PROPERTY,
            &MultiProperty.Property,
            sizeof(MultiProperty.Property),
            NumConnectInfo,
            sizeof(*NumConnectInfo),
            &BytesReturned);
    }
    //
    // Else query for all the items which will fit in the provided buffer space.
    //
    if (!*NumConnectInfo) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    //
    // Assume that each structure is of the same size as indicated in the
    // initial structure.
    //
    MultiProperty.Property.Id = KSPROPERTY_VPCONFIG_GETCONNECTINFO;
    MultiProperty.MultipleItem.Count = *NumConnectInfo;
    MultiProperty.MultipleItem.Size = ConnectInfo->dwSize;
    //
    // The drivers implemented to this property specification have decided
    // not to fill in the dwSize parameter of this structure. Therefore this
    // must be saved before the call is made.
    //
    DWORD  dwSize = ConnectInfo->dwSize;
    hr = ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &MultiProperty,
        sizeof(MultiProperty),
        ConnectInfo,
        MultiProperty.MultipleItem.Size * *NumConnectInfo,
        &BytesReturned);
    //
    // Restore the original size as set.
    // This should not be restored.
    //
    for (UINT u = 0; u < MultiProperty.MultipleItem.Count; u++) {
        ConnectInfo[u].dwSize = dwSize;
    }
    if (SUCCEEDED(hr)) {
        //
        // Calculate the actual number of items returned, which may be less than
        // the number asked for.
        //
        *NumConnectInfo = BytesReturned / ConnectInfo->dwSize;
    }
    return hr;
}


HRESULT
CVPInterfaceHandler::SetConnectInfo(
    DWORD ConnectInfoIndex
    )
/*++

Routine Description:

    Implement the IVPConfig::SetConnectInfo method. Sets the current video port
    connection information.

Arguments:

    ConnectInfo -
        Contains the new video port connect information to pass to the driver.

Return Value:

    Returns NOERROR if the video port connect information was set.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Set the property with the video port connect information passed. Use
    // the size specified in the structure.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_SETCONNECTINFO;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &ConnectInfoIndex,
        sizeof(ConnectInfoIndex),
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::GetVPDataInfo(
    LPAMVPDATAINFO VPDataInfo
    )
/*++

Routine Description:

    Implement the IVPConfig::GetVPDataInfo method. Gets the current video port
    data information.

Arguments:

    VPDataInfo -
        The place in which to put the video port data information.

Return Value:

    Returns NOERROR if the video port data information was retrieved.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Get the property with the video port data information passed. Use
    // the size specified in the structure.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_VPDATAINFO;
    Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // The drivers implemented to this property specification have decided
    // not to fill in the dwSize parameter of this structure. Therefore this
    // must be saved before the call is made.
    //
    DWORD  dwSize = VPDataInfo->dwSize;
    HRESULT hr = ::KsSynchronousDeviceControl(
                        m_ObjectHandle,
                        IOCTL_KS_PROPERTY,
                        &Property,
                        sizeof(Property),
                        VPDataInfo,
                        VPDataInfo->dwSize,
                        &BytesReturned);
    VPDataInfo->dwSize = dwSize;  // restore value after call
    return hr;
}


HRESULT
CVPInterfaceHandler::GetMaxPixelRate(
    LPAMVPSIZE Size,
    LPDWORD MaxPixelsPerSecond
    )
/*++

Routine Description:

    Implement the IVPConfig::GetMaxPixelRate method. Gets the maximum pixel
    rate given a specified width and height. Also updates that width and
    height to conform to device restrictions.

Arguments:

    Size -
        Points to a buffer containing the proposed width and height, and is
        the place in which to put the final dimensions.

    MaxPixelsPerSecond -
        Point to the place in which to put the maximum pixel rate.

Return Value:

    Returns NOERROR if the maximum pixel rate was retrieved.

--*/
{
    KSVPSIZE_PROP       SizeProperty;
    KSVPMAXPIXELRATE    MaxPixelRate;
    ULONG               BytesReturned;
    HRESULT             hr;

    //
    // Pass in the proposed width and height as context information, then
    // update that width and height with numbers returned by the property.
    //
    SizeProperty.Property.Set = *m_pPropSetID;
    SizeProperty.Property.Id = KSPROPERTY_VPCONFIG_MAXPIXELRATE;
    SizeProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    SizeProperty.Size = *Size;
    hr = ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &SizeProperty,
        sizeof(SizeProperty),
        &MaxPixelRate,
        sizeof(MaxPixelRate),
        &BytesReturned);
    if (SUCCEEDED(hr)) {
        *Size = MaxPixelRate.Size;
        *MaxPixelsPerSecond = MaxPixelRate.MaxPixelsPerSecond;
    }
    return hr;
}


HRESULT
CVPInterfaceHandler::InformVPInputFormats(
    DWORD NumFormats,
    LPDDPIXELFORMAT PixelFormats
    )
/*++

Routine Description:

    Implement the IVPConfig::InformVPInputFormats method. Tells the device
    what formats are available, which may determine what formats are then
    proposed by the device.

Arguments:

    NumFormats -
        The number of formats contains in the PixelFormats array.

    PixelFormats -
        An array of formats to send to the device.

Return Value:

    Returns NOERROR or S_FALSE.

--*/
{
    KSMULTIPLE_DATA_PROP    MultiProperty;
    ULONG                   BytesReturned;
    HRESULT                 hr;

    //
    // Set the property to the pixel formats passed. Make the assumption that all
    // the formats are of the same length.
    //
    MultiProperty.Property.Set = *m_pPropSetID;
    MultiProperty.Property.Id = KSPROPERTY_VPCONFIG_INFORMVPINPUT;
    MultiProperty.Property.Flags = KSPROPERTY_TYPE_SET;
    MultiProperty.MultipleItem.Count = NumFormats;
    MultiProperty.MultipleItem.Size = sizeof(DDPIXELFORMAT);

    //
    // The drivers implemented to this property specification have decided
    // not to fill in the dwSize parameter of this structure. Therefore this
    // must be saved before the call is made.
    //
    DWORD  dwSize = PixelFormats->dwSize;
    hr = ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &MultiProperty,
        sizeof(MultiProperty),
        PixelFormats,
        PixelFormats->dwSize * NumFormats,
        &BytesReturned);
    //
    // Restore size value after call.
    // This should not be restored.
    //
    for (UINT u = 0; u < MultiProperty.MultipleItem.Count; u++) {
        PixelFormats[u].dwSize = dwSize;
    }
    //
    // If the driver fails, return S_FALSE, indicating that does not pay
    // attention to being told about formats.
    //
    if (FAILED(hr))
        return S_FALSE;
    else
        return S_OK;
}


HRESULT
CVPInterfaceHandler::GetVideoFormats(
    LPDWORD NumFormats,
    LPDDPIXELFORMAT PixelFormats
    )
/*++

Routine Description:

    Implement the IVPConfig::GetVideoFormats method. This queries for either the
    number of DDPIXELFORMAT structures supported by the driver, or returns
    as many structures as can fit into the provided buffer space.

Arguments:

    NumFormats -
        Points to a buffer which optionally contains the number of DDPIXELFORMAT
        structure provided by PixelFormats. In this case it is updated with the actual
        number of structures returned. If PixelFormats is NULL, this is merely updated
        with the number of structures supported by the driver.

    PixelFormats -
        Points to an array of DDPIXELFORMAT structures which are filled in by
        the driver, or NULL when the count only of the structures is to be returned.

Return Value:

    Returns NOERROR if the count and/or structures were returned, else a driver error.

--*/
{
    HRESULT                 hr;
    KSMULTIPLE_DATA_PROP    MultiProperty;
    ULONG                   BytesReturned;

    MultiProperty.Property.Set = *m_pPropSetID;
    MultiProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // A null PixelFormats implies a query for just the number of data items.
    // The device knows this is a count query because the size of the buffer
    // passed is a DWORD.
    //
    MultiProperty.Property.Id = KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT;
    if (!PixelFormats) {
        return ::KsSynchronousDeviceControl(
            m_ObjectHandle,
            IOCTL_KS_PROPERTY,
            &MultiProperty.Property,
            sizeof(MultiProperty.Property),
            NumFormats,
            sizeof(*NumFormats),
            &BytesReturned);
    }
    //
    // Else query for all the items which will fit in the provided buffer space.
    //
    if (!*NumFormats) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    MultiProperty.Property.Id = KSPROPERTY_VPCONFIG_GETVIDEOFORMAT;
    MultiProperty.MultipleItem.Count = *NumFormats;
    MultiProperty.MultipleItem.Size = PixelFormats->dwSize;
    //
    // The drivers implemented to this property specification have decided
    // not to fill in the dwSize parameter of this structure. Therefore this
    // must be saved before the call is made.
    //
    DWORD  dwSize = PixelFormats->dwSize;
    hr = ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &MultiProperty,
        sizeof(MultiProperty),
        PixelFormats,
        MultiProperty.MultipleItem.Size * *NumFormats,
        &BytesReturned);
    //
    // Restore size value after call.
    // This should not be restored.
    //
    for (UINT u = 0; u < MultiProperty.MultipleItem.Count; u++) {
        PixelFormats[u].dwSize = dwSize;
    }
    if (SUCCEEDED(hr)) {
        //
        // Return the actual number of items returned, which may be less than
        // the number asked for.
        //
        *NumFormats = BytesReturned / PixelFormats->dwSize;
    }
    return hr;
}


HRESULT
CVPInterfaceHandler::SetVideoFormat(
    DWORD PixelFormatIndex
    )
/*++

Routine Description:

    Implement the IVPConfig::SetVideoFormat method. Changes the pixel format.

Arguments:

    PixelFormat -
        Specifies the new video pixel format to use.

Return Value:

    Returns NOERROR if the new video format was set.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Get the video format property using the size specified in the structure.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_SETVIDEOFORMAT;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &PixelFormatIndex,
        sizeof(PixelFormatIndex),
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::SetInvertPolarity(
    )
/*++

Routine Description:

    Implement the IVPConfig::SetInvertPolarity method. Reverses the current
    polarity.

Arguments:

    None.

Return Value:

    Returns NOERROR if the polarity was reversed.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Set the invert polarity property.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_INVERTPOLARITY;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        NULL,
        0,
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::GetOverlaySurface(
    LPDIRECTDRAWSURFACE* OverlaySurface
    )
/*++

Routine Description:

    Implement the IVPConfig::GetOverlaySurface method. Given the context and
    surface information from the device, attempt to create an overlay surface
    object to be used as an allocator.

Arguments:

    OverlaySurface -
        The place in which to put the interface to the overlay surface object.

Return Value:

    Returns NOERROR if the overlay surface object was returned.

--*/
{
    //
    // This was not done.
    //
    *OverlaySurface = NULL;
    return NOERROR;   // E_NOTIMPL;
}


HRESULT
CVPInterfaceHandler::IsVPDecimationAllowed(
    LPBOOL IsDecimationAllowed
    )
/*++

Routine Description:

    Implement the IVPConfig::IsVPDecimationAllowed method. Given the context,
    return whether VP decimation is allowed.

Arguments:

    OverlaySurface -
        The place in which to put the VP decimation capability.

Return Value:

    Returns NOERROR if the decimation capability was returned.

--*/
{
    KSPROPERTY    Property;
    ULONG         BytesReturned;

    //
    // Get the decimation flag. Use the context enumeration as the
    // context data to the property, and return the boolean.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &IsDecimationAllowed,
        sizeof(*IsDecimationAllowed),
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::SetScalingFactors(
    LPAMVPSIZE Size
    )
/*++

Routine Description:

    Implement the IVPConfig::SetScalingFactors method. Set the scaling factors
    of the device to those provided. The actual scaling used can then be
    queried through GetConnectInfo.

Arguments:

    Size -
        Contains the new scaling size (W x H) to use.

Return Value:

    Returns NOERROR if the new scaling factors were set.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Set the scaling factors given the specified width and height.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_SCALEFACTOR;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Size,
        sizeof(*Size),
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::SetDirectDrawKernelHandle(
    ULONG_PTR DDKernelHandle)
/*++

Routine Description:

    Implement the IVPConfig::SetDirectDrawKernelHandle method. Set the 
    DirectDraw kernel level handle on the mini driver to let it talk to 
    DirectDraw directly.

Arguments:

    DDKernelHandle -
        DirectDraw kernel level handle passed as a DWORD.

Return Value:

    Returns NOERROR if the specified handle is set successfully.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Set the DirectDraw handle on the mini driver.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_DDRAWHANDLE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &DDKernelHandle,
        sizeof(DDKernelHandle),
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::SetVideoPortID(
    DWORD VideoPortID)
/*++

Routine Description:

    Implement the IVPConfig::SetVideoPortID method. Set the DirectDraw Video
    Port Id on the mini driver to let it talk to the video port directly.

Arguments:

    VideoPortID -
        DirectDraw Video Port Id.

Return Value:

    Returns NOERROR if the specified handle is set successfully.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    //
    // Set the DirectDraw handle on the mini driver.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_VIDEOPORTID;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &VideoPortID,
        sizeof(VideoPortID),
        &BytesReturned);
}


HRESULT
CVPInterfaceHandler::SetDDSurfaceKernelHandles(
    DWORD cHandles,
    ULONG_PTR *rgHandles)
/*++

Routine Description:

    Implement the IVPConfig::SetDDSurfaceKernelHandle method. Set the DirectDraw Video
    Port Id on the mini driver to let it talk to the video port directly.

Arguments:

    DDKernelHandle -
        DirectDraw Surface handle (kernel mode) passed as DWORD.

Return Value:

    Returns NOERROR if the specified handle is set successfully.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    ULONG_PTR *pdwSafeArray;
    ULONG BufSize = (cHandles + 1) * sizeof(*pdwSafeArray);
    HRESULT hr = E_OUTOFMEMORY;

    pdwSafeArray = (ULONG_PTR *)CoTaskMemAlloc(BufSize);
    if (pdwSafeArray) {
        //
        // Fill the buffer with handles
        //
        for (DWORD idx = 0; idx < cHandles; idx++) {
            pdwSafeArray[idx+1] = rgHandles[idx];
        }
        pdwSafeArray[0] = cHandles;
        //
        // Set the DirectDraw handle on the mini driver.
        //
        Property.Set = *m_pPropSetID;
        Property.Id = KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE;
        Property.Flags = KSPROPERTY_TYPE_SET;
        hr = ::KsSynchronousDeviceControl(
            m_ObjectHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            pdwSafeArray,
            BufSize,
            &BytesReturned);

        CoTaskMemFree(pdwSafeArray);
    }

    return hr;
}



HRESULT
CVPInterfaceHandler::SetSurfaceParameters(
    DWORD dwPitch,
    DWORD dwXOrigin,
    DWORD dwYOrigin)
/*++

Routine Description:

    Implement the IVPConfig::SetSurfaceParameters method. Give the mini driver
    the attributes of the surface allocated by ovmixer/vbisurf so it can find the
    data it wants.

Arguments:

    dwSurfaceWidth -
        Width of the surface created by ovmixer/vbisurf and returned by DirectDraw
        Video Port.

    dwSurfaceHeight -
        Height of the surface created by ovmixer/vbisurf and returned by DirectDraw
        Video Port.

    rcValidRegion -
        The region of the surface that contains the data the mini driver is
        interested in, as specified to ovmixer/vbisurf in
        AMVPDATAINFO.amvpDimInfo.rcValidRegion in GetVPDataInfo.

Return Value:

    Returns NOERROR if the specified handle is set successfully.

--*/
{
    KSPROPERTY          Property;
    KSVPSURFACEPARAMS   SurfaceParams;
    ULONG               BytesReturned;

    //
    // Set the surface properties on the mini driver.
    //
    Property.Set = *m_pPropSetID;
    Property.Id = KSPROPERTY_VPCONFIG_SURFACEPARAMS;
    Property.Flags = KSPROPERTY_TYPE_SET;
    SurfaceParams.dwPitch = dwPitch;
    SurfaceParams.dwXOrigin = dwXOrigin;
    SurfaceParams.dwYOrigin = dwYOrigin;
    return ::KsSynchronousDeviceControl(
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &SurfaceParams,
        sizeof(SurfaceParams),
        &BytesReturned);
}



CUnknown*
CALLBACK
CVPVideoInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a VPE Config
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CVPVideoInterfaceHandler(UnkOuter, NAME("VPConfigPropSet"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVPVideoInterfaceHandler::CVPVideoInterfaceHandler
    ( LPUNKNOWN UnkOuter
    , TCHAR *Name
    , HRESULT *phr
    )
    : CVPInterfaceHandler(UnkOuter, Name, phr, &KSPROPSETID_VPConfig, &KSEVENTSETID_VPNotify)
/*++

Routine Description:

    The constructor for the VPE Config Property Set object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (m_ObjectHandle) {
        //
        // For passing format change notification to the VPMixer
        //
        m_NotifyEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (m_NotifyEventHandle) {
            DbgLog((LOG_TRACE, 0, TEXT("Got notify event handle (%ld)"), 
                m_NotifyEventHandle));
            //
            // Tell the base class to create the notification thread
            //
            HRESULT hr = CreateThread();
            if (!FAILED(hr)) {
                KSEVENT Event;
                DWORD BytesReturned;

                m_EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
                m_EventData.EventHandle.Event = m_NotifyEventHandle;
                m_EventData.EventHandle.Reserved[0] = 0;
                m_EventData.EventHandle.Reserved[1] = 0;
                Event.Set = KSEVENTSETID_VPNotify;
                Event.Id = KSEVENT_VPNOTIFY_FORMATCHANGE;
                Event.Flags = KSEVENT_TYPE_ENABLE;
                hr = ::KsSynchronousDeviceControl
                    ( m_ObjectHandle
                    , IOCTL_KS_ENABLE_EVENT
                    , &Event
                    , sizeof(Event)
                    , &m_EventData
                    , sizeof(m_EventData)
                    , &BytesReturned
                    );
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, 0, TEXT("Event notification set up failed (hr = 0x%lx)"), hr));
                    *phr = hr;
                } else {
                    DbgLog((LOG_TRACE, 0, TEXT("Event notification set up right")));
                }
            } else {
                *phr = hr;
            }
        } else {
            *phr = HRESULT_FROM_WIN32(GetLastError());
            DbgLog((LOG_ERROR, 0, TEXT("Couldn't create an event")));
        }
    } else {
        ASSERT(FAILED(*phr));
    }
}


CVPVideoInterfaceHandler::~CVPVideoInterfaceHandler(
    )
/*++

Routine Description:

    The desstructor for the VPE Config Property Set object. Just releases
    a couple of interface pointers created in the constructor, closes an 
    event handle and sends a disable event event set down to mini drviver.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    DbgLog((LOG_TRACE, 0, TEXT("Destructing CVPVideoInterfaceHandler...")));

    if (m_NotifyEventHandle) {
        // First send a disable event notification to mini driver
        //
        DWORD           BytesReturned;

        if (m_ObjectHandle) {
            // No point trying to catch the failure of the following call.  The
            // Stream class will do the clean up anyway; we are just being nice!!
            //
            ::KsSynchronousDeviceControl
                ( m_ObjectHandle
                , IOCTL_KS_DISABLE_EVENT
                , &m_EventData
                , sizeof(m_EventData)
                , NULL
                , 0
                , &BytesReturned
                );
        }

        ExitThread();

        CloseHandle(m_NotifyEventHandle);
    }
}


STDMETHODIMP
CVPVideoInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IVPConfig.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IVPConfig)) {
        return GetInterface(static_cast<IVPConfig*>(this), ppv);
    } else if (riid == __uuidof(IDistributorNotify)) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


DWORD
CVPVideoInterfaceHandler::NotifyThreadProc(
    )
{
    IVPNotify *pNotify = NULL;
    IPin *pConnected = NULL;
    HANDLE EventHandles[2];
    HRESULT hr;

    DbgLog((LOG_TRACE, 0, TEXT("VPNotify thread proc has been called")));

    EventHandles[0] = m_NotifyEventHandle;
    EventHandles[1] = m_EndEventHandle;
    while (TRUE)
    {
        DbgLog((LOG_TRACE, 0, TEXT("Waiting for VPNotify event to be signalled")));

        DWORD dw = WaitForMultipleObjects(2, EventHandles, FALSE, INFINITE);
        switch (dw)
        {
        case WAIT_OBJECT_0:
            DbgLog((LOG_TRACE, 0, TEXT("VPNotify event has been signaled")));
            ResetEvent(m_NotifyEventHandle);
            //
            // Since this plug-in cannot participate in the pin connection
            // logic of the proxy, we can't hold onto the connected pin's
            // interfaces between events. While we hold the interfaces, we
            // are guaranteed that the downstream pin exists (even though
            // it may get disconnected while we perform the notification).
            //
            // Finding that the pin is not connected is not an error.
            //
            hr = m_Pin->ConnectedTo(&pConnected);
            if (!FAILED(hr) && pConnected)
            {
                hr = pConnected->QueryInterface
                    ( __uuidof(IVPNotify)
                    , reinterpret_cast<PVOID*>(&pNotify)
                    );
                if (!FAILED(hr))
                {
                    DbgLog((LOG_TRACE, 0, TEXT("Calling IVPNotify::RenegotiateVPParameters()")));

                    pNotify->RenegotiateVPParameters();
                    pNotify->Release();
                }
                else
                    DbgLog(( LOG_ERROR, 2, TEXT("Cannot get IVPNotify interface")));

                pConnected->Release();
            }
            else
                DbgLog(( LOG_TRACE, 2, TEXT("VPNotify event signalled on unconnected pin")));
            break;

        case WAIT_OBJECT_0+1:
            DbgLog((LOG_TRACE, 2, TEXT("VPNotify event thread exiting")));
            return 1;

        default:
            DbgLog((LOG_ERROR, 1, TEXT("VPNotify event thread aborting")));
            return 0;
        }
    }

    return 1; // shouldn't get here
}


CUnknown*
CALLBACK
CVPVBIInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a VPE Config
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CVPVBIInterfaceHandler(UnkOuter, NAME("VPVBIConfigPropSet"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CVPVBIInterfaceHandler::CVPVBIInterfaceHandler
    ( LPUNKNOWN UnkOuter
    , TCHAR *Name
    , HRESULT *phr
    )
    : CVPInterfaceHandler(UnkOuter, Name, phr, &KSPROPSETID_VPVBIConfig, &KSEVENTSETID_VPVBINotify)
 
/*++

Routine Description:

    The constructor for the VPE Config Property Set object. Just initializes
    everything to NULL and acquires the object handle from the caller.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    if (m_ObjectHandle)
    {
        //
        // For passing format change notification to the VPMixer
        //
        m_NotifyEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (m_NotifyEventHandle != NULL)
        {
            DbgLog((LOG_TRACE, 0, TEXT("Got notify event handle (%ld)"), 
                m_NotifyEventHandle));

            //
            // Tell the base class to create the notification thread
            //
            HRESULT hr = CreateThread();
            if (!FAILED(hr))
            {
                KSEVENT Event;
                DWORD BytesReturned;

                m_EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
                m_EventData.EventHandle.Event = m_NotifyEventHandle;
                m_EventData.EventHandle.Reserved[0] = 0;
                m_EventData.EventHandle.Reserved[1] = 0;
                Event.Set = KSEVENTSETID_VPVBINotify;
                Event.Id = KSEVENT_VPNOTIFY_FORMATCHANGE;
                Event.Flags = KSEVENT_TYPE_ENABLE;
                hr = ::KsSynchronousDeviceControl
                    ( m_ObjectHandle
                    , IOCTL_KS_ENABLE_EVENT
                    , &Event
                    , sizeof(Event)
                    , &m_EventData
                    , sizeof(m_EventData)
                    , &BytesReturned
                    );
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("Event notification set up failed (hr = 0x%lx)"), hr));
                    *phr = hr;
                }
                else
                    DbgLog((LOG_TRACE, 0, TEXT("Event notification set up right")));
            }
            else
                *phr = hr;
        }
        else
        {
            *phr = HRESULT_FROM_WIN32(GetLastError());
            DbgLog((LOG_ERROR, 0, TEXT("Couldn't create an event")));
        }
    }
    else
        ASSERT(FAILED(*phr));
}


CVPVBIInterfaceHandler::~CVPVBIInterfaceHandler()
    
/*++

Routine Description:

    The desstructor for the VPE Config Property Set object. Just releases
    a couple of interface pointers created in the constructor, closes an 
    event handle and sends a disable event event set down to mini drviver.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    DbgLog((LOG_TRACE, 0, TEXT("Destructing CVPVBIInterfaceHandler...")));

    if (m_NotifyEventHandle)
    {
        // First send a disable event notification to mini driver
        //
        DWORD           BytesReturned;

        if (m_ObjectHandle)
        {
            // No point trying to catch the failure of the following call.  The
            // Stream class will do the clean up anyway; we are just being nice!!
            //
            ::KsSynchronousDeviceControl
                ( m_ObjectHandle
                , IOCTL_KS_DISABLE_EVENT
                , &m_EventData
                , sizeof(m_EventData)
                , NULL
                , 0
                , &BytesReturned
                );
        }

        ExitThread();

        CloseHandle(m_NotifyEventHandle);
    }
}


STDMETHODIMP
CVPVBIInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IVPVBIConfig.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IVPVBIConfig)) {
        return GetInterface(static_cast<IVPVBIConfig*>(this), ppv);
    } else if (riid == __uuidof(IDistributorNotify)) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


DWORD
CVPVBIInterfaceHandler::NotifyThreadProc(
    )
{
    IVPNotify *pNotify;
    IPin *pConnected;
    HANDLE EventHandles[2];
    HRESULT hr;

    DbgLog((LOG_TRACE, 0, TEXT("VPVBINotify thread proc has been called")));

    EventHandles[0] = m_NotifyEventHandle;
    EventHandles[1] = m_EndEventHandle;
    while (TRUE) {
        DbgLog((LOG_TRACE, 0, TEXT("Waiting for VPVBINotify event to be signalled")));

        DWORD dw = WaitForMultipleObjects(2, EventHandles, FALSE, INFINITE);
        switch (dw) {
        case WAIT_OBJECT_0:
            DbgLog((LOG_TRACE, 0, TEXT("VPVBINotify event has been signaled")));
            ResetEvent(m_NotifyEventHandle);
            //
            // Since this plug-in cannot participate in the pin connection
            // logic of the proxy, we can't hold onto the connected pin's
            // interfaces between events. While we hold the interfaces, we
            // are guaranteed that the downstream pin exists (even though
            // it may get disconnected while we perform the notification).
            //
            // Finding that the pin is not connected is not an error.
            //
            hr = m_Pin->ConnectedTo(&pConnected);
            if (!FAILED(hr) && pConnected) {
                hr = pConnected->QueryInterface(
                    __uuidof(IVPVBINotify),
                    reinterpret_cast<PVOID*>(&pNotify));
                if (!FAILED(hr)) {
                    DbgLog((LOG_TRACE, 0, TEXT("Calling IVPVBINotify::RenegotiateVPParameters()")));

                    pNotify->RenegotiateVPParameters();
                    pNotify->Release();
                } else {
                    DbgLog(( LOG_ERROR, 2, TEXT("Cannot get IVPVBINotify interface")));
                }
                pConnected->Release();
            } else {
                DbgLog(( LOG_TRACE, 2, TEXT("VPVBINotify event signalled on unconnected pin")));
            }
            break;

        case WAIT_OBJECT_0+1:
            DbgLog((LOG_TRACE, 2, TEXT("VPVBINotify event thread exiting")));
            return 1;

        default:
            DbgLog((LOG_ERROR, 1, TEXT("VPVBINotify event thread aborting")));
            return 0;
        }
    }

    return 1; // shouldn't get here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scope.rc
//
#define VERSION_RES_MINOR_VER           0
#define VERSION_RES_BUILD               0
#define VER_DEBUG                       0
#define VERSION_RES_MAJOR_VER           1
#define IDD_SCOPEDIALOG                 101
#define IDI_ICON1                       103
#define IDC_PID_LIST                    1005
#define IDC_PAT_LIST                    1006
#define IDC_PMT_LIST                    1007
#define IDC_CAT_LIST                    1008
#define IDC_FREEZE                      1013
#define IDC_FRAMES                      1017
#define IDC_FORMAT                      1023
#define IDC_BUFSIZE                     1024
#define IDC_DROPPED                     1024
#define IDC_TOTAL_TS_PACKETS            1027
#define IDC_TOTAL_TS_ERRORS             1028
#define IDC_TOTAL_TS_DISCONTINUITIES    1029
#define IDC_TOTAL_DISCONTINUITIES       1029
#define IDC_RESET                       1031
#define IDC_TOTAL_MEDIASAMPLES          1032
#define VERSION_RES_LANGUAGE            0x409
#define IDC_MEDIASAMPLE_SIZE            1033
#define IDC_VIEW_PID                    1034
#define IDC_VIEW_PAT                    1035
#define IDC_VIEW_PMT                    1036
#define IDC_VIEW_CAT                    1037
#define VERSION_RES_CHARSET             1252

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\scope.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// MPEG2Transport Scope filter

// {981CE280-43E4-11d2-8F82-C52201D96F5C}
DEFINE_GUID(CLSID_MPEG2TRANSPORT_SCOPE, 
0x981ce280, 0x43e4, 0x11d2, 0x8f, 0x82, 0xc5, 0x22, 0x1, 0xd9, 0x6f, 0x5c);

const int   TRANSPORT_SIZE = 188;
const int   TRANSPORT_HEADER_SIZE = 4;
const int   PID_MAX = 0x2000;                       // 8192 (actually one less)

#define INSYNC(p1, p2) (((p1 + TRANSPORT_SIZE) <= p2) ? \
            (*p1 == SYNC_BYTE) : (*(p1 + TRANSPORT_SIZE) == SYNC_BYTE))


#pragma pack(1)

typedef struct _TRANSPORTPACKET {
    BYTE    sync_byte;                              // Byte 0  0x47
    BYTE    PID_high:5;                             // Byte 1
    BYTE    transport_priority:1;
    BYTE    payload_unit_start_indicator:1;
    BYTE    transport_error_indicator:1;
    BYTE    PID_low;                                // Byte 2
    BYTE    continuity_counter:4;                   // Byte 3
    BYTE    adaptation_field_control:2;
    BYTE    transport_scrambling_control:2;
    BYTE    AdaptationAndData[TRANSPORT_SIZE - TRANSPORT_HEADER_SIZE];
} TRANSPORTPACKET, *PTRANSPORTPACKET;

#define GET_PID(p) ((UINT) ((p->PID_high << 8) + p->PID_low))

typedef struct _ADAPTATIONFIELDHEADER {
    BYTE    adaptation_field_length;                // Byte 0 of adaptation_field
    BYTE    adaptation_field_extension_flag:1;      // Byte 1
    BYTE    transport_private_data_flag:1;
    BYTE    splicing_point_flag:1;
    BYTE    OPCR_flag:1;
    BYTE    PCR_flag:1;
    BYTE    elementary_stream_priority_indicator:1;
    BYTE    random_access_indicator:1;
    BYTE    discontinuity_indicator:1;
} ADAPTATIONFIELDHEADER, *PADAPTATIONFIELDHEADER;

class PCR {
private:
    BYTE b[6];
public:
    _int64 PCR64() 
    {
        // 90 kHz
        return (_int64) ((unsigned _int64) b[0]  << 25 | 
                                           b[1]  << 17 |
                                           b[2]  <<  9 |
                                           b[3]  <<  1 |
                                           b[4]  >>  7 );
    };
};

#pragma pack()

typedef struct _PIDSTATS {
    _int64                  PacketCount;
    _int64                  transport_error_indicator_Count;
    _int64                  payload_unit_start_indicator_Count;
    _int64                  transport_priority_Count;
    _int64                  transport_scrambling_control_not_scrambled_Count;
    _int64                  transport_scrambling_control_user_defined_Count;
    _int64                  adaptation_field_Reserved_Count;
    _int64                  adaptation_field_payload_only_Count;
    _int64                  adaptation_field_only_Count;
    _int64                  adaptation_field_and_payload_Count;
    _int64                  continuity_counter_Error_Count;
    _int64                  discontinuity_indicator_Count;
    _int64                  random_access_indicator_Count;
    _int64                  elementary_stream_priority_indicator_Count;
    _int64                  PCR_flag_Count;
    _int64                  OPCR_flag_Count;
    _int64                  splicing_point_flag_Count;
    _int64                  transport_private_data_flag_Count;
    _int64                  adaptation_field_extension_flag_Count;

    BYTE                    continuity_counter_Last;
    BYTE                    splice_countdown;
    BYTE                    transport_private_data_length;

    ADAPTATIONFIELDHEADER   AdaptationFieldHeaderLast;
    PCR                     PCR_Last;
    PCR                     OPCR_Last;
} PIDSTATS, *PPIDSTATS;

typedef struct _TRANSPORTSTATS {
    _int64 TotalMediaSamples;
    _int64 TotalMediaSampleDiscontinuities;
    _int64 TotalTransportPackets;
    _int64 TotalSyncByteErrors;
    _int64 MediaSampleSize;
} TRANSPORTSTATS, *PTRANSPORTSTATS;

// -----------------------------------------------------------
// PIDSTATS
// -----------------------------------------------------------
enum {
    TSCOL_PID,
    TSCOL_0xPID,
    TSCOL_PACKETCOUNT,
    TSCOL_PERCENT,
    TSCOL_transport_error_indicator_Count,
    TSCOL_payload_unit_start_indicator_Count,              
    TSCOL_transport_priority_Count,                        
    TSCOL_transport_scrambling_control_not_scrambled_Count,
    TSCOL_transport_scrambling_control_user_defined_Count, 
    TSCOL_adaptation_field_Reserved_Count,                 
    TSCOL_adaptation_field_payload_only_Count,             
    TSCOL_adaptation_field_only_Count,                     
    TSCOL_adaptation_field_and_payload_Count,              
    TSCOL_continuity_counter_Error_Count,                  
    TSCOL_discontinuity_indicator_Count,                   
    TSCOL_random_access_indicator_Count,                   
    TSCOL_elementary_stream_priority_indicator_Count,      
    TSCOL_PCR_flag_Count,                                  
    TSCOL_OPCR_flag_Count,                                 
    TSCOL_splicing_point_flag_Count,                       
    TSCOL_transport_private_data_flag_Count,               
    TSCOL_adaptation_field_extension_flag_Count,           
    TSCOL_continuity_counter_Last,                         
    TSCOL_splice_countdown,                                
    TSCOL_transport_private_data_length,                   
    TSCOL_AdaptationFieldHeaderLast,                       
    TSCOL_PCR_Last,                                        
    TSCOL_OPCR_Last,
    TSCOL_PCR_LastMS,
} TSCOL;

typedef struct _TRANSPORT_COLUMN {
    BOOL    Enabled;
    int     TSCol;
    TCHAR   szText[80];
} TRANSPORT_COLUMN, *PTRANSPORT_COLUMN;

TRANSPORT_COLUMN TSColumns[] = {
    {TRUE, TSCOL_PID,                                               TEXT("PID") },
    {TRUE, TSCOL_0xPID,                                             TEXT("0xPID") },
    {TRUE, TSCOL_PACKETCOUNT,                                       TEXT("PacketCount") },
    {TRUE, TSCOL_PERCENT,                                           TEXT("%   ") },
    {TRUE, TSCOL_transport_error_indicator_Count,                   TEXT("error_indicator") },
    {TRUE, TSCOL_payload_unit_start_indicator_Count,                TEXT("payload_start_indicator") },
    {TRUE, TSCOL_transport_priority_Count,                          TEXT("priority") },
    {TRUE, TSCOL_transport_scrambling_control_not_scrambled_Count,  TEXT("not scrambled") },
    {TRUE, TSCOL_transport_scrambling_control_user_defined_Count,   TEXT("scrambled") },
    {TRUE, TSCOL_continuity_counter_Error_Count,                    TEXT("continuity_counter_Error_Count") },
    {TRUE, TSCOL_discontinuity_indicator_Count,                     TEXT("discontinuity_indicator_Count") },
    {TRUE, TSCOL_PCR_flag_Count,                                    TEXT("PCR_flag_Count") },
    {TRUE, TSCOL_OPCR_flag_Count,                                   TEXT("OPCR_flag_Count") },
    {TRUE, TSCOL_PCR_Last,                                          TEXT("PCR_Last (90kHz)") },
    {TRUE, TSCOL_PCR_LastMS,                                        TEXT("PCR_LastMS      ") },
};

#define NUM_TSColumns (NUMELMS (TSColumns))

// -----------------------------------------------------------
// PAT
// -----------------------------------------------------------

enum {
    PATCOL_PROGRAM,
    PATCOL_PID,
    PATCOL_0xPID,
} PAT_COL;

typedef struct _PAT_COLUMN {
    BOOL    Enabled;
    int     PATCol;
    TCHAR   szText[80];
} PAT_COLUMN, *PPAT_COLUMN;

PAT_COLUMN PATColumns[] = {
    {TRUE, PATCOL_PROGRAM,                                          TEXT("Program") },
    {TRUE, PATCOL_PID,                                              TEXT("Program Map Table PID") },
    {TRUE, PATCOL_0xPID,                                            TEXT("Program Map Table 0xPID") },
};

#define NUM_PATColumns (NUMELMS (PATColumns))

// -----------------------------------------------------------
// PMT
// -----------------------------------------------------------

enum {
    PMTCOL_PROGRAM,
    PMTCOL_TABLEID,
    PMTCOL_PCRPID,
    PMTCOL_0xPCRPID,
    PMTCOL_NUMSTREAMS,
    PMTCOL_0_Type,
    PMTCOL_0_PID,
    PMTCOL_0_0xPID,
    PMTCOL_1_Type,
    PMTCOL_1_PID,
    PMTCOL_1_0xPID,
    PMTCOL_2_Type,
    PMTCOL_2_PID,
    PMTCOL_2_0xPID,
    PMTCOL_3_Type,
    PMTCOL_3_PID,
    PMTCOL_3_0xPID,
    PMTCOL_4_Type,
    PMTCOL_4_PID,
    PMTCOL_4_0xPID,

} PMT_COL;

typedef struct _PMT_COLUMN {
    BOOL    Enabled;
    int     PMTCol;
    TCHAR   szText[80];
} PMT_COLUMN, *PPMT_COLUMN;

PMT_COLUMN PMTColumns[] = {
    {TRUE, PMTCOL_PROGRAM,                 TEXT("Program") },
    {TRUE, PMTCOL_TABLEID,                 TEXT("TableID") },
    {TRUE, PMTCOL_PCRPID,                  TEXT("PCRPID") },
    {TRUE, PMTCOL_0xPCRPID,                TEXT("0xPCRPID") },
    {TRUE, PMTCOL_NUMSTREAMS,              TEXT("NumStreams") },
    {TRUE, PMTCOL_0_Type,                  TEXT("0 Type") },
    {TRUE, PMTCOL_0_PID,                   TEXT("0 PID") },
    {TRUE, PMTCOL_0_0xPID,                 TEXT("0 0xPID") },
    {TRUE, PMTCOL_1_Type,                  TEXT("1 Type") },
    {TRUE, PMTCOL_1_PID,                   TEXT("1 PID") },
    {TRUE, PMTCOL_1_0xPID,                 TEXT("1 0xPID") },
    {TRUE, PMTCOL_2_Type,                  TEXT("2 Type") },
    {TRUE, PMTCOL_2_PID,                   TEXT("2 PID") },
    {TRUE, PMTCOL_2_0xPID,                 TEXT("2 0xPID") },
    {TRUE, PMTCOL_3_Type,                  TEXT("3 Type") },
    {TRUE, PMTCOL_3_PID,                   TEXT("3 PID") },
    {TRUE, PMTCOL_3_0xPID,                 TEXT("3 0xPID") },
};

#define NUM_PMTColumns (NUMELMS (PMTColumns))
  
// -----------------------------------------------------------
// 
// -----------------------------------------------------------

class CScopeFilter;
class CScopeWindow;

// Class supporting the scope input pin

class CScopeInputPin : public CBaseInputPin
{
    friend class CScopeFilter;
    friend class CScopeWindow;

public:
    CScopeFilter *m_pFilter;         // The filter that owns us

private:
    // class to pull data from IAsyncReader if we detect that interface
    // on the output pin
    class CImplPullPin : public CPullPin
    {
        // forward everything to containing pin
        CScopeInputPin* m_pPin;

    public:
        CImplPullPin(CScopeInputPin* pPin)
          : m_pPin(pPin)
        {
        };

        // Override allocator selection to make sure we get our own
        HRESULT DecideAllocator(
            IMemAllocator* pAlloc,
            ALLOCATOR_PROPERTIES * pProps)
        {
            HRESULT hr = CPullPin::DecideAllocator(pAlloc, pProps);
            if (SUCCEEDED(hr) && m_pAlloc != pAlloc) {
                return VFW_E_NO_ALLOCATOR;
            }
            return hr;
        }

        // forward this to the pin's IMemInputPin::Receive
        HRESULT Receive(IMediaSample* pSample) {
            return m_pPin->Receive(pSample);
        };

        // override this to handle end-of-stream
        HRESULT EndOfStream(void) {
            ((CBaseFilter*)(m_pPin->m_pFilter))->NotifyEvent(EC_COMPLETE, S_OK, 0);
            return m_pPin->EndOfStream();
        };
        
        // these errors have already been reported to the filtergraph
        // by the upstream filter so ignore them
        void OnError(HRESULT hr) {
            // ignore VFW_E_WRONG_STATE since this happens normally
            // during stopping and seeking
            // if (hr != VFW_E_WRONG_STATE) {
            //     m_pPin->NotifyError(hr);
            // }
        };

        // flush the pin and all downstream
        HRESULT BeginFlush() {
            return m_pPin->BeginFlush();
        };
        HRESULT EndFlush() {
            return m_pPin->EndFlush();
        };

    };

    CImplPullPin m_puller;

    // true if we are using m_puller to get data rather than
    // IMemInputPin
    BOOL m_bPulling;


public:

    CScopeInputPin(CScopeFilter *pTextOutFilter,
                   HRESULT *phr,
                   LPCWSTR pPinName);
    ~CScopeInputPin();

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);

    HRESULT CompleteConnect(IPin *pPin);

    // Lets us know where a connection ends
    HRESULT BreakConnect();

    // Check that we can support this input type
    HRESULT CheckMediaType(const CMediaType *pmt);

    // Actually set the current format
    HRESULT SetMediaType(const CMediaType *pmt);

    // IMemInputPin virtual methods

    // Override so we can show and hide the window
    HRESULT Active(void);
    HRESULT Inactive(void);

    // Here's the next block of data from the stream.
    // AddRef it if you are going to hold onto it
    STDMETHODIMP Receive(IMediaSample *pSample);

}; // CScopeInputPin


// This class looks after the management of a window. When the class gets
// instantiated the constructor spawns off a worker thread that does all
// the window work. The original thread waits until it is signaled to
// continue. The worker thread first registers the window class if it
// is not already done. Then it creates a window and sets it's size to
// a default iWidth by iHeight dimensions. The worker thread MUST be the
// one who creates the window as it is the one who calls GetMessage. When
// it has done all this it signals the original thread which lets it
// continue, this ensures a window is created and valid before the
// constructor returns. The thread start address is the WindowMessageLoop
// function. This takes as it's initialisation parameter a pointer to the
// CVideoWindow object that created it, the function also initialises it's
// window related member variables such as the handle and device contexts

// These are the video window styles

const DWORD dwTEXTSTYLES = (WS_POPUP | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN);
const DWORD dwCLASSSTYLES = (CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT | CS_OWNDC);
const LPTSTR RENDERCLASS = TEXT("MPEG2TransportScopeWindowClass");
const LPTSTR TITLE = TEXT("MPEG2TransportScope");

const int iWIDTH = 320;             // Initial window width
const int iHEIGHT = 240;            // Initial window height
const int WM_GOODBYE (WM_USER + 2); // Sent to close the window

class CScopeWindow : public CCritSec
{
    friend class CScopeInputPin;
    friend class CScopeFilter;

private:

    HINSTANCE m_hInstance;          // Global module instance handle
    CScopeFilter *m_pRenderer;      // The owning renderer object
    HWND m_hwndDlg;                 // Handle for our dialog
    HANDLE m_hThread;               // Our worker thread
    DWORD m_ThreadID;               // Worker thread ID
    CAMEvent m_SyncWorker;          // Synchronise with worker thread
    CAMEvent m_RenderEvent;         // Signals sample to render
    BOOL m_bActivated;              // Has the window been activated
    BOOL m_bStreaming;              // Are we currently streaming
    int m_LastMediaSampleSize;      // Size of last MediaSample

    BOOL m_fFreeze;                 // Flag to signal we're UI frozen
    BOOL m_NewPIDFound;             // Need to redo the list
    UINT    m_DisplayMode;          // What are we showing in the table?

    TRANSPORTPACKET m_PartialPacket;     // Packet which spans buffers
    ULONG           m_PartialPacketSize; // Size of last partial packet in next buffer

    PPIDSTATS m_PIDStats;
    TRANSPORTSTATS  m_TransportStats;

    // Tables
    Byte_Stream                 m_ByteStream;
    Transport_Packet            m_TransportPacket;
    Program_Association_Table   m_ProgramAssociationTable;
    Conditional_Access_Table    m_ConditionalAccessTable;
    Program_Map_Table           m_ProgramMapTable [256]; // ATSC limit of 255 programs


    REFERENCE_TIME  m_SampleStart;         // Most recent sample start time
    REFERENCE_TIME  m_SampleEnd;           // And it's associated end time
    REFERENCE_TIME  m_MediaTimeStart;
    REFERENCE_TIME  m_MediaTimeEnd;

    // Hold window handles to controls
    HWND m_hwndListViewPID;  
    HWND m_hwndListViewPAT;  
    HWND m_hwndListViewPMT;
    HWND m_hwndListViewCAT;
    HWND m_hwndTotalTSPackets;
    HWND m_hwndTotalTSErrors;
    HWND m_hwndTotalMediaSampleDiscontinuities;
    HWND m_hwndTotalMediaSamples;
    HWND m_hwndMediaSampleSize;
    HWND m_hwndFreeze;

    // These create and manage a video window on a separate thread

    HRESULT UninitialiseWindow();
    HRESULT InitialiseWindow(HWND hwnd);
    HRESULT MessageLoop();

    // Deal with the listviews
    HWND    InitListViewPID ();
    HWND    InitListViewPIDRows ();
    LRESULT ListViewNotifyHandlerPID (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    HWND    InitListViewPAT ();
    HWND    InitListViewPATRows();
    LRESULT ListViewNotifyHandlerPAT(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND    InitListViewPMT ();
    HWND    InitListViewPMTRows();
    LRESULT ListViewNotifyHandlerPMT (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    HWND    InitListViewCAT ();
    HWND    InitListViewCATRows ();
    LRESULT ListViewNotifyHandlerCAT (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static DWORD __stdcall WindowMessageLoop(LPVOID lpvThreadParm);

    // Maps windows message loop into C++ virtual methods
    friend LRESULT CALLBACK WndProc(HWND hwnd,      // Window handle
                                    UINT uMsg,      // Message ID
                                    WPARAM wParam,  // First parameter
                                    LPARAM lParam); // Other parameter

    // Called when we start and stop streaming
    HRESULT ResetStreamingTimes();

    // Window message handlers
    BOOL OnClose();
    BOOL OnPaint();
    void UpdateDisplay();
    void Analyze(IMediaSample *pMediaSample);
    void GatherPacketStats(PTRANSPORTPACKET pT);

    friend BOOL CALLBACK ScopeDlgProc(HWND hwnd,        // Window handle
                                    UINT uMsg,          // Message ID
                                    WPARAM wParam,      // First parameter
                                    LPARAM lParam);     // Other parameter

public:

    // Constructors and destructors

    CScopeWindow(TCHAR *pName, CScopeFilter *pRenderer, HRESULT *phr);
    virtual ~CScopeWindow();

    HRESULT StartStreaming();
    HRESULT StopStreaming();
    HRESULT InactivateWindow();
    HRESULT ActivateWindow();

    // Called when the input pin receives a sample
    HRESULT Receive(IMediaSample * pIn);

}; // CScopeWindow


// This is the COM object that represents the MPEG2TransportScope filter

class CScopeFilter 
    : public CBaseFilter
    , public CCritSec
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN


    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

public:

    CScopeFilter(LPUNKNOWN pUnk,HRESULT *phr);
    virtual ~CScopeFilter();

    // Return the pins that we support
    int GetPinCount();
    CBasePin *GetPin(int n);

    // This goes in the factory template table to create new instances
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN, HRESULT *);

    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

private:

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    
    // The nested classes may access our private state
    friend class CScopeInputPin;
    friend class CScopeWindow;

    CScopeInputPin *m_pInputPin;   // Handles pin interfaces
    CScopeWindow m_Window;         // Looks after the window
    CPosPassThru *m_pPosition;     // Renderer position controls


}; // CScopeFilter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\scope.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <pullpin.h>
#include <commctrl.h>
#include <initguid.h>
#include <stdio.h>
#include <wxdebug.h>
#include <ks.h>
#include <ksmedia.h>
#include <tchar.h>
#include "trnsport.h"
#include "scope.h"
#include "resource.h"

// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Stream,                      // Major type
    &MEDIASUBTYPE_MPEG2_TRANSPORT           // Minor type
};

const AMOVIESETUP_PIN sudPins  =
{
    L"Input",                   // Pin string name
    FALSE,                      // Is it rendered
    FALSE,                      // Is it an output
    FALSE,                      // Allowed zero pins
    FALSE,                      // Allowed many
    &CLSID_NULL,                // Connects to filter
    L"Output",                  // Connects to pin
    1,                          // Number of pins types
    &sudPinTypes } ;            // Pin information

const AMOVIESETUP_FILTER sudScope =
{
    &CLSID_MPEG2TRANSPORT_SCOPE,               // Filter CLSID
    L"MPEG-2 Transport Statistics",   // String name
    MERIT_DO_NOT_USE,           // Filter merit
    0,                          // Number pins
    NULL                        // Pin details
};


// List of class IDs and creator functions for class factory

CFactoryTemplate g_Templates []  = {
    { L"MPEG-2 Transport Statistics"
    , &CLSID_MPEG2TRANSPORT_SCOPE
    , CScopeFilter::CreateInstance
    , NULL
    , &sudScope }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


// ---------------------------------------------------------------------------------
// Filter
// ---------------------------------------------------------------------------------

//
// CreateInstance
//
// This goes in the factory template table to create new instances
//
CUnknown * WINAPI CScopeFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CScopeFilter(pUnk, phr);
} // CreateInstance


//
// Constructor
//
// Create the filter, scope window, and input pin
//
#pragma warning(disable:4355)
//
CScopeFilter::CScopeFilter(LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseFilter(NAME("MPEG2TransportScope"), pUnk, (CCritSec *) this, CLSID_MPEG2TRANSPORT_SCOPE)
    , m_Window(NAME("MPEG2TransportScope"), this, phr)
    , m_pPosition (NULL)
{
    // Create the single input pin

    m_pInputPin = new CScopeInputPin(this,phr,L"Stats Input Pin");
    if (m_pInputPin == NULL) {
        *phr = E_OUTOFMEMORY;
    }

} // (Constructor)


//
// Destructor
//
CScopeFilter::~CScopeFilter()
{
    // Delete the contained interfaces

    ASSERT(m_pInputPin);
    delete m_pInputPin;
    delete m_pPosition;

} // (Destructor)

//
// NonDelegatingQueryInterface
//
// Override this to say what interfaces we support where
//
STDMETHODIMP
CScopeFilter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    // Do we have this interface

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (m_pPosition == NULL) {

            HRESULT hr = S_OK;
            m_pPosition = new CPosPassThru(NAME("M2TScope Pass Through"),
                                           (IUnknown *) GetOwner(),
                                           (HRESULT *) &hr, m_pInputPin);
            if (m_pPosition == NULL) {
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                delete m_pPosition;
                m_pPosition = NULL;
                return hr;
            }
        }
        return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
	    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface

//
// GetPinCount
//
// Return the number of input pins we support
//
int CScopeFilter::GetPinCount()
{
    return 1;

} // GetPinCount


//
// GetPin
//
// Return our single input pin - not addrefed
//
CBasePin *CScopeFilter::GetPin(int n)
{
    // We only support one input pin and it is numbered zero

    ASSERT(n == 0);
    if (n != 0) {
        return NULL;
    }
    return m_pInputPin;

} // GetPin


//
// JoinFilterGraph
//
// Show our window when we join a filter graph
//   - and hide it when we are annexed from it
//
STDMETHODIMP CScopeFilter::JoinFilterGraph(IFilterGraph *pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (FAILED(hr)) {
        return hr;
    }

    // Hide or show the scope as appropriate

    if (pGraph == NULL) {
        m_Window.InactivateWindow();
    } else {
        m_Window.ActivateWindow();
    }
    return hr;

} // JoinFilterGraph


//
// Stop
//
// Switch the filter into stopped mode.
//
STDMETHODIMP CScopeFilter::Stop()
{
    CAutoLock lock(this);

    if (m_State != State_Stopped) {

        // Pause the device if we were running
        if (m_State == State_Running) {
            HRESULT hr = Pause();
            if (FAILED(hr)) {
                return hr;
            }
        }

        DbgLog((LOG_TRACE,1,TEXT("Stopping....")));

        // Base class changes state and tells pin to go to inactive
        // the pin Inactive method will decommit our allocator which
        // we need to do before closing the device

        HRESULT hr = CBaseFilter::Stop();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return NOERROR;

} // Stop


//
// Pause
//
// Override Pause to stop the window streaming
//
STDMETHODIMP CScopeFilter::Pause()
{
    CAutoLock lock(this);

    // Check we can PAUSE given our current state

    if (m_State == State_Running) {
        m_Window.StopStreaming();
    }

    // tell the pin to go inactive and change state
    return CBaseFilter::Pause();

} // Pause


//
// Run
//
// Overriden to start the window streaming
//
STDMETHODIMP CScopeFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock lock(this);
    HRESULT hr = NOERROR;
    FILTER_STATE fsOld = m_State;

    // This will call Pause if currently stopped

    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    m_Window.ActivateWindow();

    if (fsOld != State_Running) {
        m_Window.StartStreaming();
    }
    return NOERROR;

} // Run


// ---------------------------------------------------------------------------------
// Input Pin
// ---------------------------------------------------------------------------------

//
// Constructor
//
CScopeInputPin::CScopeInputPin(CScopeFilter *pFilter,
                               HRESULT *phr,
                               LPCWSTR pPinName) :
    CBaseInputPin(NAME("Scope Input Pin"), pFilter, pFilter, phr, pPinName)
    , m_bPulling(FALSE)
    , m_puller(this)

{
    m_pFilter = pFilter;

} // (Constructor)


//
// Destructor does nothing
//
CScopeInputPin::~CScopeInputPin()
{
} // (Destructor)

HRESULT
CScopeInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{

    pProps->cBuffers = 4;
    pProps->cbBuffer = 188 * 312; // 58,656 for Philips Coney
    pProps->cbAlign = 0;
    pProps->cbPrefix = 0;

    return S_OK;
}

HRESULT
CScopeInputPin::CompleteConnect(IPin *pPin)
{

#define READ_SIZE 32768
#define BUFFER_SIZE \
        (((MAX_MPEG_PACKET_SIZE + READ_SIZE - 1) / READ_SIZE) * READ_SIZE)

    //
    // look for IAsyncReader on the output pin and if found set up for
    // pulling data instead of using IMemInputPin.
    //
    // make an allocator first
    IMemAllocator* pAlloc;
    HRESULT hr = GetAllocator(&pAlloc);
    if (FAILED(hr)) {
        return hr;
    }
    pAlloc->Release();  // Our pin still has a ref count

    // Pull synchrously to avoid reading too much beyond the stop time
    // or seek position
    hr = m_puller.Connect(pPin, pAlloc, TRUE);
    if (S_OK == hr) {
        m_bPulling = TRUE;
    } else {
        hr = S_OK; // anything to do here?
    }
    return hr;
}

//
// BreakConnect
//
// This is called when a connection or an attempted connection is terminated
// and allows us to reset the connection media type to be invalid so that
// we can always use that to determine whether we are connected or not. We
// leave the format block alone as it will be reallocated if we get another
// connection or alternatively be deleted if the filter is finally released
//
HRESULT CScopeInputPin::BreakConnect()
{
    // Check we have a valid connection

    if (m_bPulling) {
        m_puller.Disconnect();
        m_bPulling = FALSE;
    }

    if (m_mt.IsValid() == FALSE) {
        return E_FAIL;
    }

    m_pFilter->Stop();

    // Reset the CLSIDs of the connected media type

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);
    return CBaseInputPin::BreakConnect();

} // BreakConnect


//
// CheckMediaType
//
// Check that we can support a given proposed type
//
HRESULT CScopeInputPin::CheckMediaType(const CMediaType *pmt)
{
    if (pmt->majortype != MEDIATYPE_Stream) {
        return E_INVALIDARG;
    }

#if 0
    if (pmt->subtype != MEDIASUBTYPE_MPEG2_TRANSPORT) {
        return E_INVALIDARG;
    }

    if (pmt->formattype != GUID_NULL) {
        return E_INVALIDARG;
    }
#endif

    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
// Actually set the format of the input pin
//
HRESULT CScopeInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock(m_pFilter);

    // Pass the call up to my base class

    HRESULT hr = CBaseInputPin::SetMediaType(pmt);
    if (SUCCEEDED(hr)) {
        // TODO Set format in dialog
        // This is a test code for reference only.
    }
    return hr;

} // SetMediaType


//
// Active
//
// Implements the remaining IMemInputPin virtual methods
//
HRESULT CScopeInputPin::Active(void)
{
    HRESULT hr;

    if (m_bPulling) {

        // since we control exactly when and where we get data from,
        // we should always explicitly set the start and stop position
        // ourselves here
        m_puller.Seek(m_tStart, m_tStop);

        // if we are pulling data from IAsyncReader, start our thread working
        hr = m_puller.Active();
        if (FAILED(hr)) {
            return hr;
        }
    }
    return CBaseInputPin::Active();

} // Active


//
// Inactive
//
// Called when the filter is stopped
//
HRESULT CScopeInputPin::Inactive(void)
{
    // if we are pulling data from IAsyncReader, stop our thread
    if (m_bPulling) {
        HRESULT hr = m_puller.Inactive();
        if (FAILED(hr)) {
            return hr;
        }
    }

    /*  Call the base class - future Receives will now fail */
    return CBaseInputPin::Inactive();

} // Inactive


//
// Receive
//
// Here's the next block of data from the stream
//
HRESULT CScopeInputPin::Receive(IMediaSample * pSample)
{
    // Lock this with the filter-wide lock
//     CAutoLock lock(m_pFilter);

    // If we're stopped, then reject this call
    // (the filter graph may be in mid-change)
    if (m_pFilter->m_State == State_Stopped) {
        return E_FAIL;
    }

    // Check all is well with the base class
    HRESULT hr = CBaseInputPin::Receive(pSample);
    if (FAILED(hr)) {
        return hr;
    }

    // Send the sample to the video window object for rendering
    return m_pFilter->m_Window.Receive(pSample);

} // Receive

// ---------------------------------------------------------------------------------
// Dialog
// ---------------------------------------------------------------------------------

//
// CScopeWindow Constructor
//
CScopeWindow::CScopeWindow(TCHAR *pName, CScopeFilter *pRenderer,HRESULT *phr)
    : m_hInstance(g_hInst)
    , m_pRenderer(pRenderer)
    , m_hThread(INVALID_HANDLE_VALUE)
    , m_ThreadID(0)
    , m_hwndDlg(NULL)
    , m_hwndListViewPID(NULL)
    , m_hwndListViewPAT (NULL)
    , m_hwndListViewPMT (NULL)
    , m_hwndListViewCAT (NULL)
    , m_bStreaming(FALSE)
    , m_bActivated(FALSE)
    , m_LastMediaSampleSize(0)
    , m_PIDStats (NULL)
    , m_PartialPacketSize (0)
    , m_fFreeze (FALSE)
    , m_NewPIDFound (FALSE)
    , m_DisplayMode (IDC_VIEW_PID)
{
    InitCommonControls();

    ZeroMemory (&m_TransportStats, sizeof (m_TransportStats));

    m_PIDStats = new PIDSTATS[PID_MAX];
    if (m_PIDStats == NULL) {
        *phr = E_FAIL;
        return;
    }

    ZeroMemory (m_PIDStats, sizeof (PIDSTATS) * PID_MAX); // Does New zero?

    // Create a thread to look after the window

    ASSERT(m_pRenderer);
    m_hThread = CreateThread(NULL,                  // Security attributes
                             (DWORD) 0,             // Initial stack size
                             WindowMessageLoop,     // Thread start address
                             (LPVOID) this,         // Thread parameter
                             (DWORD) 0,             // Creation flags
                             &m_ThreadID);          // Thread identifier

    // If we couldn't create a thread the whole thing's off

    ASSERT(m_hThread);
    if (m_hThread == NULL) {
        *phr = E_FAIL;
        return;
    }

    // Wait until the window has been initialised
    m_SyncWorker.Wait();

} // (Constructor)


//
// Destructor
//
CScopeWindow::~CScopeWindow()
{
    // Ensure we stop streaming and release any samples

    StopStreaming();
    InactivateWindow();

    // Tell the thread to destroy the window
    SendMessage(m_hwndDlg, WM_GOODBYE, (WPARAM)0, (LPARAM)0);

    // Make sure it has finished

    ASSERT(m_hThread != NULL);
    WaitForSingleObject(m_hThread,INFINITE);
    CloseHandle(m_hThread);

    if (m_PIDStats) {
        delete [] m_PIDStats;
    }
} // (Destructor)


//
// ResetStreamingTimes
//
// This resets the latest sample stream times
//
HRESULT CScopeWindow::ResetStreamingTimes()
{
    m_SampleStart = 0;
    m_SampleEnd = 0;
    return NOERROR;

} // ResetStreamingTimes


//
// StartStreaming
//
// This is called when we start running state
//
HRESULT CScopeWindow::StartStreaming()
{
    CAutoLock cAutoLock(this);

    // Are we already streaming

    if (m_bStreaming == TRUE) {
        return NOERROR;
    }

    m_bStreaming = TRUE;

    return NOERROR;

} // StartStreaming


//
// StopStreaming
//
// This is called when we stop streaming
//
HRESULT CScopeWindow::StopStreaming()
{
    CAutoLock cAutoLock(this);

    // Have we been stopped already

    if (m_bStreaming == FALSE) {
        return NOERROR;
    }

    m_bStreaming = FALSE;
    return NOERROR;

} // StopStreaming


//
// InactivateWindow
//
// Called at the end to put the window in an inactive state
//
HRESULT CScopeWindow::InactivateWindow()
{
    // Has the window been activated
    if (m_bActivated == FALSE) {
        return S_FALSE;
    }

    // Now hide the scope window

    ShowWindow(m_hwndDlg,SW_HIDE);
    m_bActivated = FALSE;
    return NOERROR;

} // InactivateWindow


//
// ActivateWindow
//
// Show the scope window
//
HRESULT CScopeWindow::ActivateWindow()
{
    // Has the window been activated
    if (m_bActivated == TRUE) {
        return S_FALSE;
    }

    m_bActivated = TRUE;
    ASSERT(m_bStreaming == FALSE);

    ShowWindow(m_hwndDlg,SW_SHOWNORMAL);
    return NOERROR;

} // ActivateWindow


//
// OnClose
//
// This function handles the WM_CLOSE message
//
BOOL CScopeWindow::OnClose()
{
    InactivateWindow();
    return TRUE;

} // OnClose


// ----------------------------------------------------------------
// PID
// ----------------------------------------------------------------

HWND
CScopeWindow::InitListViewPID ()
{
    int index;              // Index used in for loops.
    LVCOLUMN    lvC;        // List view column structure.

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_ORDER ;
    lvC.fmt = LVCFMT_RIGHT;  // Right -align the column.

    for (index = 0; index < NUM_TSColumns; index++)   {
        lvC.iOrder = index;
        lvC.iSubItem = TSColumns[index].TSCol;
        lvC.pszText = TSColumns[index].szText;   // The text for the column.
        lvC.cx = 24 + lstrlen (lvC.pszText) * 5;            // Width of the column, in pixels.
        if (ListView_InsertColumn(m_hwndListViewPID, index, &lvC) == -1)
            return NULL;
     }

    return (m_hwndListViewPID);
}

HWND
CScopeWindow::InitListViewPIDRows ()
{
    int index;              // Index used in for loops.
    LVITEM      lvI;        // List view item structure.

    ASSERT (m_hwndListViewPID);

    ListView_DeleteAllItems (m_hwndListViewPID);

    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask = 0;

    int NumRows = 0;

    for (index = 0; index <= PID_NULL_PACKET; index++, NumRows++)  {
        if (m_PIDStats[index].PacketCount == 0)
            continue;
        lvI.iItem = index;
        lvI.iSubItem = 0;
        // The parent window is responsible for storing the text. The list view
        // window will send an LVN_GETDISPINFO when it needs the text to display.
        lvI.pszText = LPSTR_TEXTCALLBACK;
        lvI.cchTextMax = 16; // MAX_ITEMLEN;
        lvI.iImage = index;
        lvI.lParam = index;  // (LPARAM)&rgHouseInfo[index];
        if (ListView_InsertItem(m_hwndListViewPID, &lvI) == -1)
            return NULL;
    }
    m_NewPIDFound = FALSE;

    return (m_hwndListViewPID);
}

LRESULT
CScopeWindow::ListViewNotifyHandlerPID (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LV_DISPINFO     *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW     *pNm = (NM_LISTVIEW *)lParam;
    static TCHAR     szText[80];
    int ColumnIndex;
    int PID;
    _int64 t;

    if (wParam != IDC_PID_LIST)
       return 0L;

    ASSERT (pLvdi);
    ASSERT (pNm);

    switch(pLvdi->hdr.code)   {

    case LVN_GETDISPINFO:
         // Display the appropriate item, getting the text or number

        *((int *) szText) = 0;
        pLvdi->item.pszText = szText;

        PID =  (int) pLvdi->item.lParam;

        ASSERT (PID <= PID_NULL_PACKET);
        ASSERT (pLvdi->item.iSubItem < NUM_TSColumns);

        ColumnIndex = TSColumns[pLvdi->item.iSubItem].TSCol;

        switch (ColumnIndex) {

        case TSCOL_PID:
            wsprintf(szText, _T("%u"), PID);
            break;
        case TSCOL_0xPID:
            wsprintf(szText, _T("0x%X"), PID);
            break;
        case TSCOL_PACKETCOUNT:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].PacketCount);
            break;
        case TSCOL_PERCENT:
            if (m_TransportStats.TotalTransportPackets) {
                _stprintf(szText, _T("%.2f"),
                         100.0 *  (double) m_PIDStats[PID].PacketCount /
                         m_TransportStats.TotalTransportPackets);
            }
            break;
        case TSCOL_transport_error_indicator_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].transport_error_indicator_Count);
            break;
        case TSCOL_payload_unit_start_indicator_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].payload_unit_start_indicator_Count);
            break;
        case TSCOL_transport_priority_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].transport_priority_Count);
            break;
        case TSCOL_transport_scrambling_control_not_scrambled_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].transport_scrambling_control_not_scrambled_Count);
            break;
        case TSCOL_transport_scrambling_control_user_defined_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].transport_scrambling_control_user_defined_Count);
            break;
        case TSCOL_continuity_counter_Error_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].continuity_counter_Error_Count);
            break;
        case TSCOL_discontinuity_indicator_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].discontinuity_indicator_Count);
            break;
        case TSCOL_PCR_flag_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].PCR_flag_Count);
            break;
        case TSCOL_OPCR_flag_Count:
            wsprintf(szText, _T("%u"), m_PIDStats[PID].OPCR_flag_Count);
            break;
        case TSCOL_PCR_Last:
            // 90 kHz.
            t = m_PIDStats[PID].PCR_Last.PCR64();
            if (t) {
                _stprintf(szText, _T("%10.10I64u"), t);
            }
            break;
        case TSCOL_PCR_LastMS:
            t = m_PIDStats[PID].PCR_Last.PCR64();
            if (t) {
                t = t * 1000 / 90000;
                _stprintf(szText, _T("%10.10I64u"), t);
            }
            break;

        default:
            break;

        }
        break;

    case LVN_COLUMNCLICK:
         // The user clicked one of the column headings. Sort by
         // this column. This function calls an application-defined
         // comparison callback function, ListViewCompareProc. The
         // code for the comparison procedure is listed in the next section.
#if 0
         ListView_SortItems( pNm->hdr.hwndFrom,
                            ListViewCompareProc,
                            (LPARAM)(pNm->iSubItem));
#endif
         break;

    default:
         break;
    }

    return 0L;
}

// ----------------------------------------------------------------
// PAT
// ----------------------------------------------------------------

HWND
CScopeWindow::InitListViewPAT ()
{
    int index;              // Index used in for loops.
    LVCOLUMN    lvC;        // List view column structure.

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_ORDER ;
    lvC.fmt = LVCFMT_RIGHT;  // Right -align the column.

    for (index = 0; index < NUM_PATColumns; index++)   {
        lvC.iOrder = index;
        lvC.iSubItem = PATColumns[index].PATCol;
        lvC.pszText = PATColumns[index].szText;   // The text for the column.
        lvC.cx = 24 + lstrlen (lvC.pszText) * 5;            // Width of the column, in pixels.
        if (ListView_InsertColumn(m_hwndListViewPAT, index, &lvC) == -1)
            return NULL;
     }

    return (m_hwndListViewPAT);
}

HWND
CScopeWindow::InitListViewPATRows ()
{
    int index;              // Index used in for loops.
    LVITEM      lvI;        // List view item structure.

    ASSERT (m_hwndListViewPAT);

    ListView_DeleteAllItems (m_hwndListViewPAT);

    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask = 0;

    int NumRows = 0;

    for (index = 0; index <= (int) m_ProgramAssociationTable.GetNumPrograms(); index++, NumRows++)  {
        lvI.iItem = index;
        lvI.iSubItem = 0;
        // The parent window is responsible for storing the text. The list view
        // window will send an LVN_GETDISPINFO when it needs the text to display.
        lvI.pszText = LPSTR_TEXTCALLBACK;
        lvI.cchTextMax = 16; // MAX_ITEMLEN;
        lvI.iImage = index;
        lvI.lParam = index;
        if (ListView_InsertItem(m_hwndListViewPAT, &lvI) == -1)
            return NULL;
    }

    return (m_hwndListViewPAT);
}

LRESULT
CScopeWindow::ListViewNotifyHandlerPAT (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LV_DISPINFO     *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW     *pNm = (NM_LISTVIEW *)lParam;
    static TCHAR     szText[80];
    int ColumnIndex;
    int Program;

    if (wParam != IDC_PAT_LIST)
       return 0L;

    switch(pLvdi->hdr.code)   {

    case LVN_GETDISPINFO:
         // Display the appropriate item, getting the text or number

        *((int *) szText) = 0;
        pLvdi->item.pszText = szText;

        Program =  (int) pLvdi->item.lParam;

        ASSERT (Program <= 255);
        ASSERT (pLvdi->item.iSubItem < NUM_PATColumns);

        ColumnIndex = PATColumns[pLvdi->item.iSubItem].PATCol;

        switch (ColumnIndex) {

        case PATCOL_PROGRAM:
            wsprintf(szText, _T("%u"), Program);
            break;
        case PATCOL_PID:
            wsprintf(szText, _T("%u"), m_ProgramAssociationTable.GetPIDForProgram (Program));
            break;
        case PATCOL_0xPID:
            wsprintf(szText, _T("0x%X"), m_ProgramAssociationTable.GetPIDForProgram (Program));
            break;

        default:
            break;

        }
        break;

    case LVN_COLUMNCLICK:
         // The user clicked one of the column headings. Sort by
         // this column. This function calls an application-defined
         // comparison callback function, ListViewCompareProc. The
         // code for the comparison procedure is listed in the next section.
#if 0
         ListView_SortItems( pNm->hdr.hwndFrom,
                            ListViewCompareProc,
                            (LPARAM)(pNm->iSubItem));
#endif
         break;

    default:
         break;
    }

    return 0L;
}

// ----------------------------------------------------------------
// PMT
// ----------------------------------------------------------------

HWND
CScopeWindow::InitListViewPMT ()
{
    int index;              // Index used in for loops.
    LVCOLUMN    lvC;        // List view column structure.

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_ORDER ;
    lvC.fmt = LVCFMT_RIGHT;  // Right -align the column.

    for (index = 0; index < NUM_PMTColumns; index++)   {
        lvC.iOrder = index;
        lvC.iSubItem = PMTColumns[index].PMTCol;
        lvC.pszText = PMTColumns[index].szText;   // The text for the column.
        lvC.cx = 24 + lstrlen (lvC.pszText) * 5;            // Width of the column, in pixels.
        if (ListView_InsertColumn(m_hwndListViewPMT, index, &lvC) == -1)
            return NULL;
     }

    return (m_hwndListViewPMT);
}

HWND
CScopeWindow::InitListViewPMTRows ()
{
    int index;              // Index used in for loops.
    LVITEM      lvI;        // List view item structure.

    ASSERT (m_hwndListViewPMT);

    ListView_DeleteAllItems (m_hwndListViewPMT);

    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask = 0;

    int NumRows = 0;

    for (index = 0; index <= 255; index++, NumRows++)  {
        if (m_ProgramMapTable[index].streams == 0) {
            continue;
        }
        lvI.iItem = index;
        lvI.iSubItem = 0;
        // The parent window is responsible for storing the text. The list view
        // window will send an LVN_GETDISPINFO when it needs the text to display.
        lvI.pszText = LPSTR_TEXTCALLBACK;
        lvI.cchTextMax = 16; // MAX_ITEMLEN;
        lvI.iImage = index;
        lvI.lParam = index;
        if (ListView_InsertItem(m_hwndListViewPMT, &lvI) == -1)
            return NULL;
    }

    return (m_hwndListViewPMT);
}

LRESULT
CScopeWindow::ListViewNotifyHandlerPMT (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LV_DISPINFO     *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW     *pNm = (NM_LISTVIEW *)lParam;
    static TCHAR     szText[80];
    int ColumnIndex;
    int Program;
    int j;


    if (wParam != IDC_PMT_LIST)
       return 0L;

    switch(pLvdi->hdr.code)   {

    case LVN_GETDISPINFO:
        // Display the appropriate item, getting the text or number

        *((int *) szText) = 0;
        pLvdi->item.pszText = szText;

        Program =  (int) pLvdi->item.lParam;

        ASSERT (Program <= 255);
        ASSERT (pLvdi->item.iSubItem < NUM_PMTColumns);

        ColumnIndex = PMTColumns[pLvdi->item.iSubItem].PMTCol;

        switch (ColumnIndex) {

        case PMTCOL_PROGRAM:
            wsprintf(szText, _T("%u"), Program);
            break;

        case PMTCOL_TABLEID:
            wsprintf(szText, _T("%u"), m_ProgramMapTable[Program].table_id);
            break;

        case PMTCOL_PCRPID:
            wsprintf(szText, _T("%u"), m_ProgramMapTable[Program].PCR_PID);
            break;

        case PMTCOL_0xPCRPID:
            wsprintf(szText, _T("0x%X"), m_ProgramMapTable[Program].PCR_PID);
            break;

        case PMTCOL_NUMSTREAMS:
            wsprintf(szText, _T("%u"), m_ProgramMapTable[Program].streams);
            break;

        case PMTCOL_0_Type:
            j = m_ProgramMapTable[Program].GetTypeForStream(0);
            if (j != PID_NULL_PACKET) {
                if (m_ProgramMapTable[Program].IsVideo(j)) {
                    wsprintf (szText, _T("Video %u"), j);
                }
                else if (m_ProgramMapTable[Program].IsAudio(j)) {
                    wsprintf (szText, _T("Audio %u"), j);
                }
                else {
                    wsprintf(szText, _T("%u"), j);
                }
            }
            break;
        case PMTCOL_0_PID:
            j = m_ProgramMapTable[Program].GetPIDForStream(0);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("%u"), j);
            }
            break;
        case PMTCOL_0_0xPID:
            j = m_ProgramMapTable[Program].GetPIDForStream(0);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("0x%X"), j);
            }
            break;



        case PMTCOL_1_Type:
            j = m_ProgramMapTable[Program].GetTypeForStream(1);
            if (j != PID_NULL_PACKET) {
                if (m_ProgramMapTable[Program].IsVideo(j)) {
                    wsprintf (szText, _T("Video %u"), j);
                }
                else if (m_ProgramMapTable[Program].IsAudio(j)) {
                    wsprintf (szText, _T("Audio %u"), j);
                }
                else {
                    wsprintf(szText, _T("%u"), j);
                }
            }
            break;
        case PMTCOL_1_PID:
            j = m_ProgramMapTable[Program].GetPIDForStream(1);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("%u"), j);
            }
            break;
        case PMTCOL_1_0xPID:
            j = m_ProgramMapTable[Program].GetPIDForStream(1);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("0x%X"), j);
            }
            break;




        case PMTCOL_2_Type:
            j = m_ProgramMapTable[Program].GetTypeForStream(2);
            if (j != PID_NULL_PACKET) {
                if (m_ProgramMapTable[Program].IsVideo(j)) {
                    wsprintf (szText, _T("Video %u"), j);
                }
                else if (m_ProgramMapTable[Program].IsAudio(j)) {
                    wsprintf (szText, _T("Audio %u"), j);
                }
                else {
                    wsprintf(szText, _T("%u"), j);
                }
            }
            break;
        case PMTCOL_2_PID:
            j = m_ProgramMapTable[Program].GetPIDForStream(2);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("%u"), j);
            }
            break;
        case PMTCOL_2_0xPID:
            j = m_ProgramMapTable[Program].GetPIDForStream(2);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("0x%X"), j);
            }
            break;



        case PMTCOL_3_Type:
            j = m_ProgramMapTable[Program].GetTypeForStream(3);
            if (j != PID_NULL_PACKET) {
                if (m_ProgramMapTable[Program].IsVideo(j)) {
                    wsprintf (szText, _T("Video %u"), j);
                }
                else if (m_ProgramMapTable[Program].IsAudio(j)) {
                    wsprintf (szText, _T("Audio %u"), j);
                }
                else {
                    wsprintf(szText, _T("%u"), j);
                }
            }
            break;
        case PMTCOL_3_PID:
            j = m_ProgramMapTable[Program].GetPIDForStream(3);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("%u"), j);
            }
            break;
        case PMTCOL_3_0xPID:
            j = m_ProgramMapTable[Program].GetPIDForStream(3);
            if (j != PID_NULL_PACKET) {
                wsprintf(szText, _T("0x%X"), j);
            }
            break;

        default:
            break;

        }
        break;

    case LVN_COLUMNCLICK:
         // The user clicked one of the column headings. Sort by
         // this column. This function calls an application-defined
         // comparison callback function, ListViewCompareProc. The
         // code for the comparison procedure is listed in the next section.
#if 0
         ListView_SortItems( pNm->hdr.hwndFrom,
                            ListViewCompareProc,
                            (LPARAM)(pNm->iSubItem));
#endif
         break;

    default:
         break;
    }

    return 0L;
}





//
// InitialiseWindow
//
// This is called by the worker window thread after it has created the main
// window and it wants to initialise the rest of the owner objects window
// variables such as the device contexts. We execute this function with the
// critical section still locked.
//
HRESULT CScopeWindow::InitialiseWindow(HWND hDlg)
{
    m_hwndFreeze =                              GetDlgItem (hDlg, IDC_FREEZE);

    m_hwndTotalTSPackets =                      GetDlgItem (hDlg, IDC_TOTAL_TS_PACKETS);
    m_hwndTotalTSErrors =                       GetDlgItem (hDlg, IDC_TOTAL_TS_ERRORS);
    m_hwndTotalMediaSampleDiscontinuities =     GetDlgItem (hDlg, IDC_TOTAL_DISCONTINUITIES);
    m_hwndTotalMediaSamples =                   GetDlgItem (hDlg, IDC_TOTAL_MEDIASAMPLES);
    m_hwndMediaSampleSize =                     GetDlgItem (hDlg, IDC_MEDIASAMPLE_SIZE);

    m_hwndListViewPID =                         GetDlgItem (hDlg, IDC_PID_LIST);
    m_hwndListViewPAT =                         GetDlgItem (hDlg, IDC_PAT_LIST);           ;
    m_hwndListViewPMT =                         GetDlgItem (hDlg, IDC_PMT_LIST);;
    m_hwndListViewCAT =                         GetDlgItem (hDlg, IDC_CAT_LIST);

    CheckDlgButton(hDlg, IDC_FREEZE, m_fFreeze);	

    InitListViewPID ();
    InitListViewPAT ();
    InitListViewPMT ();
//    InitListViewCAT ();

    return NOERROR;

} // InitialiseWindow


//
// UninitialiseWindow
//
// This is called by the worker window thread when it receives a WM_GOODBYE
// message from the window object destructor to delete all the resources we
// allocated during initialisation
//
HRESULT CScopeWindow::UninitialiseWindow()
{
    return NOERROR;

} // UninitialiseWindow


//
// ScopeDlgProc
//
// The Scope window is actually a dialog box, and this is its window proc.
// The only thing tricky about this is that the "this" pointer to the
// CScopeWindow is passed during the WM_INITDIALOG message and is stored
// in the window user data. This lets us access methods in the class
// from within the dialog.
//
BOOL CALLBACK ScopeDlgProc(HWND hDlg,	        // Handle of dialog box
                           UINT uMsg,	        // Message identifier
                           WPARAM wParam,	// First message parameter
                           LPARAM lParam)	// Second message parameter
{
    CScopeWindow *pScopeWindow;      // Pointer to the owning object

    // Get the window long that holds our owner pointer
    pScopeWindow = (CScopeWindow *) GetWindowLong(hDlg, GWL_USERDATA);

    switch (uMsg) {
        case WM_INITDIALOG:
            pScopeWindow = (CScopeWindow *) lParam;
            SetWindowLong(hDlg, (DWORD) GWL_USERDATA, (LONG) pScopeWindow);
            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hDlg, 0);
                    return TRUE;

                case IDC_FREEZE:
                    pScopeWindow->m_fFreeze =
                        (BOOL) IsDlgButtonChecked(hDlg,IDC_FREEZE);
                    break;

                case IDC_RESET:
                    ZeroMemory (pScopeWindow->m_PIDStats, sizeof (PIDSTATS) * PID_MAX);
                    ZeroMemory (&pScopeWindow->m_TransportStats, sizeof (pScopeWindow->m_TransportStats));
                    pScopeWindow->InitListViewPIDRows ();
                    break;

                // viewing modes
                case IDC_VIEW_PID:
                case IDC_VIEW_PAT:
                case IDC_VIEW_PMT:
                case IDC_VIEW_CAT:
                    pScopeWindow->m_DisplayMode = wParam;
                    ShowWindow (pScopeWindow->m_hwndListViewPID, SW_HIDE);
                    ShowWindow (pScopeWindow->m_hwndListViewPAT, SW_HIDE);
                    ShowWindow (pScopeWindow->m_hwndListViewPMT, SW_HIDE);
                    ShowWindow (pScopeWindow->m_hwndListViewCAT, SW_HIDE);

                    switch (wParam) {
                    case IDC_VIEW_PID:
                        pScopeWindow->InitListViewPIDRows ();
                        ShowWindow (pScopeWindow->m_hwndListViewPID, SW_SHOW);
                        break;
                    case IDC_VIEW_PAT:
                        pScopeWindow->InitListViewPATRows ();
                        ShowWindow (pScopeWindow->m_hwndListViewPAT, SW_SHOW);
                        break;
                    case IDC_VIEW_PMT:
                        pScopeWindow->InitListViewPMTRows ();
                        ShowWindow (pScopeWindow->m_hwndListViewPMT, SW_SHOW);
                        break;
                    case IDC_VIEW_CAT:
//                        pScopeWindow->InitListViewCATRows ();
                        ShowWindow (pScopeWindow->m_hwndListViewCAT, SW_SHOW);
                        break;
                    default:
                        ASSERT (FALSE);
                    }
                    break;

                default:
                    break;
            }

        case WM_PAINT:
            ASSERT(pScopeWindow != NULL);
            pScopeWindow->OnPaint();
            break;

        // We stop WM_CLOSE messages going any further by intercepting them
        // and then setting an abort signal flag in the owning renderer so
        // that it knows the user wants to quit. The renderer can then
        // go about deleting it's interfaces and the window helper object
        // which will eventually cause a WM_DESTROY message to arrive. To
        // make it look as though the window has been immediately closed
        // we hide it and then wait for the renderer to catch us up

        case WM_CLOSE:
            ASSERT(pScopeWindow != NULL);
            pScopeWindow->OnClose();
            return (LRESULT) 0;

        // We receive a WM_GOODBYE window message (synchronously) from the
        // window object destructor in which case we do actually destroy
        // the window and complete the process in the WM_DESTROY message

        case WM_GOODBYE:
            ASSERT(pScopeWindow != NULL);
            pScopeWindow->UninitialiseWindow();
            PostQuitMessage(FALSE);
            EndDialog (hDlg, 0);
            return (LRESULT) 0;

    case WM_NOTIFY:
        switch (pScopeWindow->m_DisplayMode) {

        case IDC_VIEW_PID:
            pScopeWindow->ListViewNotifyHandlerPID (hDlg, uMsg, wParam, lParam);
            break;

        case IDC_VIEW_PAT:
            pScopeWindow->ListViewNotifyHandlerPAT (hDlg, uMsg, wParam, lParam);
            break;

        case IDC_VIEW_PMT:
            pScopeWindow->ListViewNotifyHandlerPMT (hDlg, uMsg, wParam, lParam);
            break;

        case IDC_VIEW_CAT:
            // pScopeWindow->ListViewNotifyHandlerCAT (hDlg, uMsg, wParam, lParam);
            break;

        default:
            ASSERT (FALSE);
            break;
        }


        default:
            break;
    }
    return (LRESULT) 0;

} // ScopeDlgProc


//
// MessageLoop
//
// This is the standard windows message loop for our worker thread. It sits
// in a normal processing loop dispatching messages until it receives a quit
// message, which may be generated through the owning object's destructor
//
HRESULT CScopeWindow::MessageLoop()
{
    MSG Message;        // Windows message structure
    DWORD dwResult;     // Wait return code value

    HANDLE hWait[] = { (HANDLE) m_RenderEvent };

    // Enter the modified message loop

    while (TRUE) {

        // We use this to wait for two different kinds of events, the first
        // are the normal windows messages, the other is an event that will
        // be signaled when a sample is ready

        dwResult = MsgWaitForMultipleObjects((DWORD) 1,     // Number events
                                             hWait,         // Event handle
                                             FALSE,         // Wait for either
                                             INFINITE,      // No timeout
                                             QS_ALLINPUT);  // All messages

        // Has a sample become ready to render
        if (dwResult == WAIT_OBJECT_0) {
            UpdateDisplay();
        }

        // Process the thread's window message

        while (PeekMessage(&Message,NULL,(UINT) 0,(UINT) 0,PM_REMOVE)) {

            // Check for the WM_QUIT message

            if (Message.message == WM_QUIT) {
                return NOERROR;
            }

            // Send the message to the window procedure

            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
    }

} // MessageLoop


//
// WindowMessageLoop
//
// This creates a window and processes it's messages on a separate thread
//
DWORD __stdcall CScopeWindow::WindowMessageLoop(LPVOID lpvThreadParm)
{
    CScopeWindow *pScopeWindow;     // The owner renderer object

    // Cast the thread parameter to be our owner object
    pScopeWindow = (CScopeWindow *) lpvThreadParm;

    pScopeWindow->m_hwndDlg =
        CreateDialogParam(
            pScopeWindow->m_hInstance,	        // Handle of app instance
            MAKEINTRESOURCE (IDD_SCOPEDIALOG),	// Dialog box template
            NULL,	                        // Handle of owner window
            ScopeDlgProc,	        // Address of dialog procedure
            (LPARAM) pScopeWindow                 // Initialization value
        );

    if (pScopeWindow->m_hwndDlg != NULL)
    {
        // Initialise the window, then signal the constructor that it can
        // continue and then unlock the object's critical section and
        // process messages

        pScopeWindow->InitialiseWindow(pScopeWindow->m_hwndDlg);
    }

    pScopeWindow->m_SyncWorker.Set();

    if (pScopeWindow->m_hwndDlg != NULL)
    {
        pScopeWindow->MessageLoop();
    }

    ExitThread(TRUE);
    return TRUE;

} // WindowMessageLoop


//
// OnPaint
//
// WM_PAINT message
//
BOOL CScopeWindow::OnPaint()
{
    UpdateDisplay();
    return TRUE;

} // OnPaint

//
// UpdateDisplay
//
void CScopeWindow::UpdateDisplay()
{
    TCHAR szText[132];

    wsprintf (szText, _T("%ld"), m_TransportStats.TotalMediaSamples);
    SetWindowText (m_hwndTotalMediaSamples, szText);
    UpdateWindow (m_hwndTotalMediaSamples);

    wsprintf (szText, _T("%ld"), m_TransportStats.TotalMediaSampleDiscontinuities);
    SetWindowText (m_hwndTotalMediaSampleDiscontinuities, szText);
    UpdateWindow (m_hwndTotalMediaSampleDiscontinuities);

    wsprintf (szText, _T("%ld"), m_TransportStats.TotalTransportPackets);
    SetWindowText (m_hwndTotalTSPackets, szText);
    UpdateWindow (m_hwndTotalTSPackets);

    wsprintf (szText, _T("%ld"), m_TransportStats.TotalSyncByteErrors);
    SetWindowText (m_hwndTotalTSErrors, szText);
    UpdateWindow (m_hwndTotalTSErrors);

    wsprintf (szText, _T("%ld"), m_TransportStats.MediaSampleSize);
    SetWindowText (m_hwndMediaSampleSize, szText);
    UpdateWindow (m_hwndMediaSampleSize);

    if (m_NewPIDFound) {
        InitListViewPIDRows ();
    }
    else {
        InvalidateRect(m_hwndListViewPID, NULL, FALSE);
        UpdateWindow (m_hwndListViewPID);
    }

} // UpdateDisplay

//
// GatherPacketStats
//
void CScopeWindow::GatherPacketStats(PTRANSPORTPACKET pT)
{
    UINT    PID;
    PBYTE   pB;
    BYTE    continuity_counter;
    UINT    adaptation_field_control;
    ADAPTATIONFIELDHEADER AdaptationFieldHeader;

    ASSERT(m_PIDStats != NULL);

    m_TransportStats.TotalTransportPackets++;

    ZeroMemory (&AdaptationFieldHeader, sizeof (AdaptationFieldHeader));

    PID = GET_PID (pT);
    ASSERT (PID <= 0x1FFF);

    // if the packet has the error indicator set, only increment
    // the PacketCount if you've already found this packet before
    if (pT->transport_error_indicator) {
        m_TransportStats.TotalSyncByteErrors++;
        if (m_PIDStats[PID].PacketCount ) {
            m_PIDStats[PID].transport_error_indicator_Count++;
        }
        return;
    }

    m_PIDStats[PID].PacketCount++;

    if (m_PIDStats[PID].PacketCount == 1)
        m_NewPIDFound = TRUE;                       // redo the table

    if (pT->payload_unit_start_indicator)
        m_PIDStats[PID].payload_unit_start_indicator_Count++;
    if (pT->transport_priority)
        m_PIDStats[PID].transport_priority_Count++;

    switch (pT->transport_scrambling_control) {
        case 0:  m_PIDStats[PID].transport_scrambling_control_not_scrambled_Count++;   break;
        case 1:  // for now, we don't differentiate private scrambling control
        case 2:
        case 3:  m_PIDStats[PID].transport_scrambling_control_user_defined_Count++;    break;
        default: ASSERT (FALSE);
    }

    switch (adaptation_field_control = pT->adaptation_field_control) {
        case 0:  m_PIDStats[PID].adaptation_field_Reserved_Count++;     break;
        case 1:  m_PIDStats[PID].adaptation_field_payload_only_Count++; break;
        case 2:  m_PIDStats[PID].adaptation_field_only_Count++;         break;
        case 3:  m_PIDStats[PID].adaptation_field_and_payload_Count++;  break;
        default: ASSERT (FALSE);
    }


    // Process adaptation field
    if (adaptation_field_control > 0x01) {
        AdaptationFieldHeader = *((PADAPTATIONFIELDHEADER) pT->AdaptationAndData);
        if (AdaptationFieldHeader.adaptation_field_length) {

            if (AdaptationFieldHeader.discontinuity_indicator)
                m_PIDStats[PID].discontinuity_indicator_Count++;
            if (AdaptationFieldHeader.random_access_indicator)
                m_PIDStats[PID].random_access_indicator_Count++;
            if (AdaptationFieldHeader.elementary_stream_priority_indicator)
                m_PIDStats[PID].elementary_stream_priority_indicator_Count++;
            if (AdaptationFieldHeader.PCR_flag)
                m_PIDStats[PID].PCR_flag_Count++;
            if (AdaptationFieldHeader.OPCR_flag)
                m_PIDStats[PID].OPCR_flag_Count++;
            if (AdaptationFieldHeader.splicing_point_flag)
                m_PIDStats[PID].splicing_point_flag_Count++;
            if (AdaptationFieldHeader.transport_private_data_flag)
                m_PIDStats[PID].transport_private_data_flag_Count++;
            if (AdaptationFieldHeader.adaptation_field_extension_flag)
                m_PIDStats[PID].adaptation_field_extension_flag_Count++;

            // pB points after adaptation_flags
            pB = pT->AdaptationAndData + 2;

            if (AdaptationFieldHeader.PCR_flag) {
                m_PIDStats[PID].PCR_Last = *((PCR*) pB);
                pB += sizeof (PCR);
            }
            if (AdaptationFieldHeader.OPCR_flag) {
                m_PIDStats[PID].OPCR_Last = *((PCR*) pB);
                pB += sizeof (PCR);
            }
            if (AdaptationFieldHeader.splicing_point_flag) {
                m_PIDStats[PID].splice_countdown = *(pB);
                pB++;
            }
            if (AdaptationFieldHeader.transport_private_data_flag) {
                m_PIDStats[PID].transport_private_data_length = *(pB);
                pB++;
            }

        } // if non-zero adaptation field length
    } // if adaptation field

    // continuity doesn't apply to NULL packets
    if (PID != PID_NULL_PACKET) {

        continuity_counter = pT->continuity_counter;

        if (AdaptationFieldHeader.discontinuity_indicator == 0) {
            if (m_PIDStats[PID].PacketCount > 1) {
                // if reserved or no payload, then counter shouldn't increment
                if ((adaptation_field_control == 0x00) || (adaptation_field_control == 0x10)) {
                    if (m_PIDStats[PID].continuity_counter_Last != continuity_counter) {
                        m_PIDStats[PID].continuity_counter_Error_Count++;
                    }
                }
                // else, must have payload
                else {
                    if (m_PIDStats[PID].continuity_counter_Last == continuity_counter) {
                        ;   // OK if it doesn't increment
                            // but then duplicate packet values except PCR
                    }
                    else if (((m_PIDStats[PID].continuity_counter_Last + 1) & 0x0F)
                             != continuity_counter) {
                        m_PIDStats[PID].continuity_counter_Error_Count++;
                    }
                }
            }
        }

        m_PIDStats[PID].continuity_counter_Last = continuity_counter;
    }

    switch (PID) {
    case PID_PROGRAM_ASSOCIATION_TABLE:
        m_ByteStream.Initialize((BYTE *) pT, TRANSPORT_SIZE);
        m_TransportPacket.Init ();
        m_TransportPacket.ReadData (m_ByteStream);
        m_TransportPacket >> m_ProgramAssociationTable;
        break;
    case PID_CONDITIONAL_ACCESS_TABLE:
        m_ByteStream.Initialize((BYTE *) pT, TRANSPORT_SIZE);
        m_TransportPacket.Init ();
        m_TransportPacket.ReadData (m_ByteStream);
        m_TransportPacket >> m_ConditionalAccessTable;
        break;
    default:
        int i = m_ProgramAssociationTable.GetNumPrograms();
        for (int j = 0; j < i; j++) {
            if (PID == m_ProgramAssociationTable.GetPIDForProgram (j)) {
                m_ByteStream.Initialize((BYTE *) pT, TRANSPORT_SIZE);
                m_TransportPacket.Init ();
                m_TransportPacket.ReadData (m_ByteStream);
                m_TransportPacket >> m_ProgramMapTable[j];
            }
        }
        break;
    }


} // GatherPacketStats



//
// Analyze
//
void CScopeWindow::Analyze(IMediaSample *pMediaSample)
{
    BYTE                   *p1;     // Current pointer
    BYTE                   *p2;     // End pointer
    ULONG                   SampleSize;
    ULONG                   j;
    HRESULT                 hr;

    hr = pMediaSample->GetPointer(&p1);
    ASSERT(p1 != NULL);
    if (p1 == NULL) {
        return;
    }

    hr = pMediaSample->GetTime (&m_SampleStart,&m_SampleEnd);
    hr = pMediaSample->GetMediaTime (&m_MediaTimeStart, &m_MediaTimeEnd);
    SampleSize = pMediaSample->GetActualDataLength();
    m_TransportStats.MediaSampleSize = SampleSize;

    if (S_OK == pMediaSample->IsDiscontinuity()) {
        m_TransportStats.TotalMediaSampleDiscontinuities++;
    }

    p2 = p1 + SampleSize;           // p2 points 1 byte beyond end of buffer

    //
    // 1. See if we had a partial packet waiting from the last buffer
    //
    if (m_PartialPacketSize) {
        ASSERT (m_PartialPacketSize < TRANSPORT_SIZE);

        if (m_PartialPacketSize > SampleSize) {      // assumes buffers > TRANSPORT_SIZE
            m_TransportStats.TotalSyncByteErrors++;
            m_PartialPacketSize = 0;
            return;
        }
        else {
            if (SampleSize > m_PartialPacketSize) {
                if (*(p1 + m_PartialPacketSize) != SYNC_BYTE) {
                    goto Step2;
                }
            }
            CopyMemory ((PBYTE) &m_PartialPacket + (TRANSPORT_SIZE - m_PartialPacketSize),
                        p1,
                        m_PartialPacketSize);
            GatherPacketStats (&m_PartialPacket);
            p1 += m_PartialPacketSize;
        }
    }

    //
    // 2. Process all packets
    //
Step2:

    m_PartialPacketSize = 0;

    while (p1 <= (p2 - TRANSPORT_SIZE)) {
        if (*p1 != SYNC_BYTE) {
            p1++;
        }
        else if (INSYNC (p1, p2)) {
            GatherPacketStats ((PTRANSPORTPACKET) p1);
            p1 += TRANSPORT_SIZE;
        }
    }

    //
    // 3. Save any partial transport packet that remains
    //

    if (p1 < p2) {
        j = p2 - p1;
        ASSERT (j < TRANSPORT_SIZE);
        if (*p1 == SYNC_BYTE) {
            CopyMemory (&m_PartialPacket, p1, j);
            m_PartialPacketSize = TRANSPORT_SIZE - j;
        }
        else {
            m_TransportStats.TotalSyncByteErrors++;
        }
    }
} // Analyze


//
// Receive
//
// Called when the input pin receives another sample.
//
HRESULT CScopeWindow::Receive(IMediaSample *pSample)
{
    CAutoLock cAutoLock(this);
    ASSERT(pSample != NULL);

    m_TransportStats.TotalMediaSamples++;

    // Has our UI been frozen?
    if (m_fFreeze) {
        m_PartialPacketSize = 0;
        return NOERROR;
    }

//    if (m_bStreaming == TRUE) {
        Analyze (pSample);
        SetEvent(m_RenderEvent);
//    }
    return NOERROR;

} // Receive


//
// DllRegisterServer
//
// Handles DLL registry
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\pinprop\ksprxmtd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ksprxmtd.h
//
//--------------------------------------------------------------------------

#ifndef __KSPRXMTD_H__
#define __KSPRXMTD_H__


class CKSGetString
{
public:
    // Should be argv**, argc (an array of strings is returned)
    static int KsGetInterfaceString(KSPIN_INTERFACE KsPinInterface, char **pszKsPinInterface);
    static int KsGetMediumString(KSPIN_MEDIUM KsPinMedium, char **pszKsPinMedium);
    static int KsGetDataRangeString(KSDATARANGE *pKsDataRange, int *pCount, char *parszKsDataRange[]);
    static int KsGetDataFlowString(KSPIN_DATAFLOW KsPinDataFlow, char **pszKsPinDataFlow);
    static int KsGetCommunicationString(KSPIN_COMMUNICATION KsPinCommunication , char **pszKsPinCommunication);
    static int KsParseAudioRange(KSDATARANGE *pKsDataRange, char *parszKsDataRange[], int *piLinesReturned);

};

typedef struct _ULONGToString 
{
    ULONG ulType;
    PSTR pStr;
} ULONGToString;

typedef int (*LPFNParseFunc)(KSDATARANGE *pKsDataRange, char *parszKsDataRange[], int *piLinesReturned);

typedef struct _GuidToStr 
{
    GUID *m_rguid;
    PSTR m_pszName;
    LPFNParseFunc m_pParseFunc;
} GuidToStr, *pGuidToStr;

typedef struct _GuidToSet
{
    GUID *m_rguid;
    PSTR pStr;
    ULONGToString *m_par;
    int m_Count;
} GuidToSet, *pGuidToSet;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\trnsport.h ===
#ifndef __TRNSPORT_H__
#define __TRNSPORT_H__
#include "bytestrm.h"
#include "list.h"

#define SYNC_BYTE                      0x47
#define PID_PROGRAM_ASSOCIATION_TABLE  0x0000
#define PID_CONDITIONAL_ACCESS_TABLE   0x0001
#define PID_NULL_PACKET                0x1fff

#define ID_PROGRAM_STREAM_MAP          0xBC
#define ID_PRIVATE_STREAM_1            0xBD
#define ID_PADDING_STREAM              0xBE
#define ID_PRIVATE_STREAM_2            0xBF
#define ID_AUDIO_XXXX                  0xC0
#define ID_VIDEO_XXXX                  0xE0
#define ID_ECM_STREAM                  0xF0
#define ID_EMM_STREAM                  0xF1
#define ID_DSMCC_STREAM                0xF2
#define ID_ISO13522_STREAM             0xF3
#define ID_ITU_TYPE_A                  0xF4
#define ID_ITU_TYPE_B                  0xF5
#define ID_ITU_TYPE_C                  0xF6
#define ID_ITU_TYPE_D                  0xF7
#define ID_ITU_TYPE_E                  0xF8
#define ID_ANCILLARY                   0xF9
#define ID_RESERVED_XXXX               0xFC
#define ID_PROGRAM_STREAM_DIRECTORY    0xFF

UINT _inline BitField(UINT val, BYTE start=0, BYTE size=31)
{
   BYTE start_bit;
   BYTE bit_count;
   UINT mask;
   UINT value;

   // calculate startbit (0-31)
   start_bit=start;
   // calculate bit count
   bit_count= size;
   // generate mask  
   if (bit_count == 32)
      mask = 0xffffffff;
   else
   {
      mask = 1; 
      mask = mask <<bit_count;   
      mask = mask -1; 
      mask = mask << start_bit;
   }
   value = val;
   return ((value & mask) >> start_bit);
}

UINT _inline CRC_OK(BYTE * first,BYTE *last)
{
#define CRC_POLY   0x04c11db7
   char data;
   long crc_value;
   BYTE *word_addr;
   long count;
    
  /* Preset the crc_valueister to '1's */
  crc_value = 0xffffffff ;
    
  for(word_addr=first;word_addr<last;word_addr++)    {
      data = *(char*)word_addr ;
      for(count=0;count<8;count++){            // for every byte of data
      // if the most significant bit is set after xor
          if ( BitField(data,31,1) ^ BitField(crc_value,31,1) ){         
              crc_value = crc_value << 1;      // shift our crc by 1
              crc_value = crc_value ^ CRC_POLY; // xor with original polynomial
          }
          else {
            crc_value = crc_value << 1;         // just shift our crc by 1
        }
          data = data << 1 ;               // xor the original polynomial
        }
    }
 
  /* OR crc_values, '0' = no errors and '1' = errors */
  return(crc_value == 0x00000000) ;
}

class Transport_Packet {
public:
   // constructor & destructor
   Transport_Packet(){ Init();};
   ~Transport_Packet(){};

   void ReadData(Byte_Stream &s);
   // methods
   void Init();
   void Print();

   operator UINT() {return valid;};
   UINT valid;

   // packet header fields
   UINT sync_byte;
   UINT transport_error_indicator;
   UINT payload_unit_start_indicator;
   UINT transport_priority;
   UINT PID;
   UINT transport_scrambling_control;
   UINT adaptation_field_control;
   UINT continuity_counter;

   // adaptation field 
   UINT adaptation_field_length;
   UINT discontinuity_indicator;
   UINT random_access_indicator;
   UINT elementary_stream_priority_indicator;
   UINT PCR_flag;
   UINT OPCR_flag;                                     
   UINT splicing_point_flag;                           
   UINT transport_private_data_flag;                   
   UINT adaptation_field_extension_flag;              
   UINT PCR_base_MSB;                  
   UINT PCR_base;                  
   UINT PCR_extension;                  
   UINT program_clock_reference_extension;            
   UINT OPCR_base_MSB;         
   UINT OPCR_base;
   UINT OPCR_extension;
   UINT splice_countdown;                             
   UINT transport_private_data_length;                 
   UINT adaptation_field_extension_length;            
   UINT ltw_flag;
   UINT piecewise_rate_flag;
   UINT seamless_splice_flag;
   UINT ltw_valid_flag;
   UINT ltw_offset;
   UINT piecewise_rate;
   UINT splice_type;
   UINT DTS_next_AU_MSB;
   UINT DTS_next_AU;
   UINT reserved_bytes;
   UINT stuffing_bytes;
   UINT data_bytes;
   
   // packet payload fields
   BYTE *data_byte;

   // sync byte begin address
   UINT address;
};

class Transport_Section{
public:
   //methods
   Transport_Section(){new_version = 0;};
   ~Transport_Section(){};
   void ReadData(Transport_Packet &tp);
   operator UINT() {return valid;};

   // required methods
   virtual void Refresh() = 0;   
   virtual void ClearTable() = 0;

   UINT IsNewVersion();
   // variables
   UINT lcc;
   UINT pf;
   UINT ti;
   UINT ssi;
   UINT sl;
   UINT vn;
   UINT cni;
   UINT header_bytes; 
   BYTE data_byte[6144];
   UINT data_bytes;
   UINT valid;
   UINT version_number;
   UINT new_version;
   UINT CRC_32;
};

class Program_Association_Table : public Transport_Section {
public:
   // constructor & descructor
   Program_Association_Table();
   ~Program_Association_Table(){ClearTable();};

   // required methods   
   void Refresh();
   void Print();
   void ClearTable();
   // methods
   UINT GetPIDForProgram(UINT program);
   UINT GetPIDForProgram();
   UINT GetNumPrograms(){ return programs;};
   // fields in section
   UINT table_id;
   UINT section_syntax_indicator;
   UINT section_length;
   UINT transport_stream_id;
   UINT current_next_indicator;
   UINT section_number;
   UINT last_section_number;
   UINT programs;
   UINT pointer_field;

   typedef struct { 
      UINT program_number;
      UINT PID;
   } TRANSPORT_PROGRAM;

   TList<TRANSPORT_PROGRAM> ProgramList;
   
};


class Conditional_Access_Table : public Transport_Section {
public:
   // constructor & descructor
   Conditional_Access_Table();
   ~Conditional_Access_Table(){};

   // required methods   
   void Refresh();
   void Print();
   void ClearTable(){};

   // fields in section
   UINT table_id;
   UINT section_syntax_indicator;
   UINT section_length;
   UINT transport_stream_id;
   UINT current_next_indicator;
   UINT section_number;
   UINT last_section_number;
   UINT pointer_field;
};

class Program_Map_Table : public Transport_Section {
public:
   // constructor & descructor
   Program_Map_Table();
   ~Program_Map_Table(){ClearTable();};

   // required methods   
   void Refresh();
   void Print();
   void ClearTable();

   UINT GetPIDForStream(UINT);
   UINT GetPIDForAudio();
   UINT GetPIDForVideo();
   UINT GetTypeForStream(UINT);
   UINT IsVideo(UINT type){ return (type == 0x1 || type == 2);};
   UINT IsAudio(UINT type){ return (type == 0x3 || type == 4);};
   // fields in section
   UINT table_id;
   UINT section_syntax_indicator;
   UINT section_length;
   UINT program_number;
   UINT current_next_indicator;
   UINT section_number;
   UINT last_section_number;
   UINT PCR_PID;
   UINT program_info_length;
   LPBYTE program_info;
   UINT streams;
   UINT pointer_field;

   typedef struct { 
      UINT stream_type;
      UINT elementary_PID;
      UINT ES_info_length;
      LPBYTE ES_info;
   } STREAM_TABLE;

   TList<STREAM_TABLE> StreamTable;

};

class Private_Table : public Transport_Section {
public:
   // methods
   Private_Table();
   ~Private_Table(){};

   // required methods   
   void Refresh();
   void Print();
   void ClearTable(){};

   // fields 
   UINT table_id;
   UINT section_syntax_indicator;
   UINT private_indicator;
   UINT private_section_length;
   UINT private_data_bytes;

   UINT table_id_extension;
   UINT current_next_indicator;
   UINT section_number;
   UINT last_section_number;
   UINT pointer_field;
};

class PES_Stream{
public:
   PES_Stream(){Discontinuity = 1; Refresh(); };

   // method for reading data from packet
   void ReadData(Transport_Packet &s);
   void Print();

   // initializes fields;
   void Refresh(){
      stream_id = 0;
      PES_packet_length = 0;
      last_continuity_counter = 0;
      PES_scrambling_control = 0;
      PES_priority = 0;
      data_alignment_indicator = 0;
      copyright = 0;
      original_or_copy = 0;
      PTS_DTS_flags = 0;
      ESCR_flag = 0;
      ES_rate_flag = 0;
      DSM_trick_mode_flag = 0;
      additional_copy_info_flag = 0;
      PES_CRC_flag = 0;
      PES_extension_flag = 0;
      PES_header_data_length = 0;
      PTS_msb = 0;
      PTS = 0;
      DTS_msb = 0;
      DTS = 0;
      PES_private_data_flag = 0;
      pack_header_field_flag = 0;
      program_packet_sequence_counter_flag = 0;
      PSTD_buffer_flag = 0;
      PES_extension_flag_2 = 0;
      pack_field_length = 0;
      PES_extension_field_length = 0;
   };

   // fields
   UINT stream_id;
   UINT PES_packet_length;
   UINT packet_start_code_prefix;
   UINT last_continuity_counter;
   UINT PES_scrambling_control;
   UINT PES_priority;
   UINT data_alignment_indicator;
   UINT copyright;
   UINT original_or_copy;
   UINT PTS_DTS_flags;
   UINT ESCR_flag;
   UINT ES_rate_flag;
   UINT DSM_trick_mode_flag;
   UINT additional_copy_info_flag;
   UINT PES_CRC_flag;
   UINT PES_extension_flag;
   UINT PES_header_data_length;
   UINT PTS_msb;
   UINT PTS;
   UINT DTS_msb;
   UINT DTS;
   UINT PES_private_data_flag;
   UINT pack_header_field_flag;
   UINT program_packet_sequence_counter_flag;
   UINT PSTD_buffer_flag;
   UINT PES_extension_flag_2;
   UINT pack_field_length;
   UINT PES_extension_field_length;
   UINT data_bytes;
   UINT Discontinuity;
   // special pointers to data in transport packet
   LPBYTE pData;
   UINT lData;
};

// helper functions to clear up stream and filter concepts
Transport_Packet &operator>> (Byte_Stream &s,Transport_Packet &p);
Transport_Packet &operator>> (Transport_Packet &tp, Program_Association_Table &p);
Transport_Packet &operator>> (Transport_Packet &tp, Conditional_Access_Table &c);
Transport_Packet &operator>> (Transport_Packet &tp, Program_Map_Table &p);
Transport_Packet &operator>> (Transport_Packet &tp, Private_Table &p);
PES_Stream &operator>> (Transport_Packet &tp, PES_Stream &p);
PES_Stream &operator>> (PES_Stream &p,Output_File &os);
Transport_Packet &operator>> (Transport_Packet &tp,Output_File &os);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\m2tscope\trnsport.cpp ===
#include <windows.h>
#include "trnsport.h"

Transport_Packet &operator>> (Byte_Stream &s,Transport_Packet &p){ p.ReadData(s); return p;};
Transport_Packet &operator>> (Transport_Packet &tp, Program_Association_Table &p){ p.ReadData(tp); return tp;};
Transport_Packet &operator>> (Transport_Packet &tp, Conditional_Access_Table &c){ c.ReadData(tp); return tp;};
Transport_Packet &operator>> (Transport_Packet &tp, Program_Map_Table &p){ p.ReadData(tp); return tp;};
Transport_Packet &operator>> (Transport_Packet &tp, Private_Table &p){ p.ReadData(tp); return tp;};
PES_Stream &operator>> (Transport_Packet &tp, PES_Stream &p){ p.ReadData(tp); return p;};
PES_Stream &operator>> (PES_Stream &p,Output_File &os){
   if (p.lData && p.pData)   os.WriteData(p.pData,p.lData);
   return p;
}
Transport_Packet &operator>> (Transport_Packet &tp,Output_File &os){
   if (tp.data_byte && tp.data_bytes)   os.WriteData(tp.data_byte,tp.data_bytes);
   return tp;
}

          
void Transport_Packet::Init()
{
   valid = 0;
   sync_byte = 0;
   transport_error_indicator = 0;
   payload_unit_start_indicator = 0;
   transport_priority = 0;
   PID = 0;
   transport_scrambling_control = 0;
   adaptation_field_control = 0;
   continuity_counter = 0;
   adaptation_field_length = 0;
   discontinuity_indicator = 0;
   random_access_indicator = 0;
   elementary_stream_priority_indicator = 0;
   PCR_flag = 0;
   OPCR_flag = 0;                                     
   splicing_point_flag = 0;                           
   transport_private_data_flag = 0;                   
   adaptation_field_extension_flag = 0;              
   PCR_base_MSB = 0;                  
   PCR_base = 0;                  
   PCR_extension = 0;                  
   program_clock_reference_extension = 0;            
   OPCR_base_MSB = 0;         
   OPCR_base = 0;
   OPCR_extension = 0;
   splice_countdown = 0;                             
   transport_private_data_length = 0;                 
   adaptation_field_extension_length = 0;            
   ltw_flag = 0;
   piecewise_rate_flag = 0;
   seamless_splice_flag = 0;
   ltw_valid_flag = 0;
   ltw_offset = 0;
   piecewise_rate = 0;
   splice_type = 0;
   DTS_next_AU_MSB = 0;
   DTS_next_AU = 0;
   reserved_bytes = 0;
   stuffing_bytes = 0;
   data_bytes = 0;
   data_byte = 0;
}


void Transport_Packet::ReadData(Byte_Stream &input)
{
   UINT N;
   UINT temp = 0;
   UINT adaptation_field;
   UINT adaptation_field_extension;
   UINT sync_point;

start_sync:

   // initialize packet
   Init();

   // assume byte aligned
   // search for sync_byte
   while ((temp != SYNC_BYTE) &&    // not sync byte
         (!input.EndOfStream()) // not enough packet data
         ){
      if (input.GetPositionFromEnd() < 188)// at least 1 transport packet left
         break;
      temp = input.GetByte();
   }
    

   // check for end of stream;
   if (temp != SYNC_BYTE){
      PID = PID_NULL_PACKET;
      return;
   }

   // get current pointer
   sync_point = address = input.GetPosition() - 1;

   // set sync byte;                // 1 Byte
   sync_byte                        =   BitField(temp,0,8);

   // fill in fields
   temp = input.GetByte();          // 1 Byte
   transport_error_indicator        =   BitField(temp,7,1);
   payload_unit_start_indicator     =   BitField(temp,6,1);
   transport_priority               =   BitField(temp,5,1);         // may ignore

   // fill in fields
   temp = input.GetNextByte(temp);  // 1 Byte
   PID                              =   BitField(temp,0,13); 

   // fill in fields
   temp = input.GetByte();          // 1 Byte
   // fill in fields
   transport_scrambling_control     =   BitField(temp,6,2); // 00 none, 01 reserved, 10 even key, 11 odd key
   adaptation_field_control         =   BitField(temp,4,2); 
   continuity_counter               =   BitField(temp,0,4); 


   // error checking
   if ( (transport_error_indicator == 1) ||
      (payload_unit_start_indicator!=0  && PID==PID_NULL_PACKET) ||
      (adaptation_field_control!=0x01  && PID==PID_NULL_PACKET) ||
      (adaptation_field_control==0)||
      (transport_scrambling_control !=0 && (PID == 0x000  || PID==0x0001 || PID==PID_NULL_PACKET)) ){
      goto start_sync;
   }

   // calculate N
   N = 184;

   // adaptation field
   if ((adaptation_field_control == 0x2) || (adaptation_field_control == 0x3)){
      // get length of the field
      temp = input.GetByte();
      adaptation_field_length                =   BitField(temp,0,8); 

      // get current pointer
      adaptation_field = input.GetPosition();
      if (adaptation_field_length > 0 ){
         temp = input.GetByte();             // 1 Byte
         // fill in fields
         discontinuity_indicator             =   BitField(temp,7,1); 
         random_access_indicator             =   BitField(temp,6,1); // video sequence header after an I frame
         elementary_stream_priority_indicator=   BitField(temp,5,1);   // may ignore
         PCR_flag                            =   BitField(temp,4,1); // appears at most evey 100ms
         OPCR_flag                           =   BitField(temp,3,1); // may ignore
         splicing_point_flag                 =   BitField(temp,2,1); // may ignore
         transport_private_data_flag         =   BitField(temp,1,1);
         adaptation_field_extension_flag     =   BitField(temp,0,1);   // may ignore
         
         // fill in fields
         if (PCR_flag){                      // 6 Bytes
            temp = input.GetUINT();
               PCR_base_MSB                  =   BitField(temp,31,1);
            PCR_base                         =   BitField(temp,0,31) << 1;
            temp = input.GetByte();
            PCR_base                        |=   BitField(temp,7,1);
            PCR_extension                    =   BitField(temp,0,1) << 8;
            temp = input.GetByte();
            PCR_extension                   |=   BitField(temp,0,8);
         }
         if (OPCR_flag){                  // 6 Bytes
            temp = input.GetUINT();
               OPCR_base_MSB                 =   BitField(temp,31,1);
            OPCR_base                        =   BitField(temp,0,31) << 1;
            temp = input.GetByte();
            OPCR_base                       |=   BitField(temp,7,1);
            OPCR_extension                   =   BitField(temp,0,1) << 8;
            temp = input.GetByte();
            OPCR_extension                  |=   BitField(temp,0,8);
         }
         if (splicing_point_flag){            
            temp = input.GetByte();
            splice_countdown                 =   BitField(temp,0,8);
         }
         if (transport_private_data_flag){   
            temp = input.GetByte();
            transport_private_data_length    =   BitField(temp,0,8);
            // advance pointer
            input.Advance(transport_private_data_length);
         }

         if (adaptation_field_extension_flag){   
            temp = input.GetByte();             // 1 Byte
            adaptation_field_extension_length   =   BitField(temp,0,8);
            
            // get current pointer
            adaptation_field_extension = input.GetPosition();

            temp = input.GetByte();          // 1 Byte
            ltw_flag                         =   BitField(temp,7,1);
            piecewise_rate_flag              =   BitField(temp,6,1);
            seamless_splice_flag             =   BitField(temp,5,1);

            if (ltw_flag){               
               temp = input.GetWORD();       // 2 Bytes
               ltw_valid_flag                =   BitField(temp,15,1);
               ltw_offset                    =   BitField(temp,0,15);
            }
            if (piecewise_rate_flag){         
               temp = input.GetWORD();       // 3 Bytes
               temp = input.GetNextByte(temp);
               piecewise_rate                =   BitField(temp,0,22);
            }
            if (seamless_splice_flag){      
               temp = input.GetByte();       // 5 Bytes
               splice_type                   =   BitField(temp,4,4);
               DTS_next_AU_MSB               =   BitField(temp,3,1);
               DTS_next_AU                   =   BitField(temp,1,2) << 29;
               temp = input.GetWORD();
               DTS_next_AU                  |=   BitField(temp,1,15) << 14;
               temp = input.GetWORD();
               DTS_next_AU                  |=   BitField(temp,1,15);
            }
            // calculate number of reserved bytes
            N = adaptation_field_extension -
               (input.GetPosition() - adaptation_field_extension);
            reserved_bytes = N;
            input.Advance(N);
         }
         // calculate number of stuffing bytes
         N = adaptation_field_length -
            (input.GetPosition() - adaptation_field);
         stuffing_bytes = N;
         input.Advance(N);
      }
      N = 183 - adaptation_field_length;
   }
   // payload
   if ((adaptation_field_control == 0x1) || (adaptation_field_control == 0x3)){
      data_bytes = N;
      data_byte = input.GetBytePointer();
      input.Advance(N);
   }

   if (PID == PID_NULL_PACKET) 
      goto start_sync;

   // state that this packet is valid
   valid = 1;
}


Program_Association_Table::Program_Association_Table()
{
   valid = 0;
   table_id = 0;
   section_syntax_indicator = 0;
   section_length = 0;
   transport_stream_id = 0;
   version_number = 0;
   current_next_indicator = 0;
   section_number = 0;
   last_section_number = 0;
   programs = 0;
   CRC_32 = 0;
}

void Program_Association_Table::ClearTable()
{
   for(TListIterator * pNode = ProgramList.GetHead(); pNode != NULL; pNode=pNode->Next()){
        TRANSPORT_PROGRAM * pProgram = ProgramList.GetData(pNode);
      delete pProgram;
    };
   ProgramList.Flush();
}

void Program_Association_Table::Refresh()
{
UINT temp;
UINT i;
UINT N;
Byte_Stream pay_load;

   // initialize payload byte stream to point to data byte in the transport packet
   pay_load.Initialize(data_byte,data_bytes);

   temp = pay_load.GetByte();
   pointer_field = BitField(temp,0,8);
   // if pointer field exists move to it
   if (pointer_field){
       pay_load.Advance(pointer_field);
   }

   // get table id
   temp = pay_load.GetByte();
   table_id                   = BitField(temp,0,8);
   
   temp = pay_load.GetWORD();      // 2 Bytes
   section_syntax_indicator   = BitField(temp,15,1);
   section_length             = BitField(temp,0,12);

   temp = pay_load.GetWORD();      // 2 Bytes
   transport_stream_id        = BitField(temp,0,16);

   temp = pay_load.GetByte();      // 1 Byte
   version_number             = BitField(temp,1,5);
   current_next_indicator     = BitField(temp,0,1);
   
   temp = pay_load.GetByte();      // 1 Byte
   section_number             = BitField(temp,0,8);
   
   temp = pay_load.GetByte();      // 1 Byte
   last_section_number        = BitField(temp,0,8);

   // we consumed 5 bytes since section_length 
   // and we will consume the CRC (4 bytes)
   programs = (section_length - 9)/4;

   N = programs;
   
   for (i = 0;i < N; i++){
      // create new program struct
      TRANSPORT_PROGRAM * pProgram = new TRANSPORT_PROGRAM;
      
      // get program number
      temp = pay_load.GetWORD();      // 2 Byte      
      pProgram->program_number = BitField(temp,0,16);

      // get program PID
      temp = pay_load.GetWORD();      // 2 Byte2      
      pProgram->PID = BitField(temp,0,13);

      // add to our list of program map tables
      ProgramList.AddTail(pProgram);
   }
   
   temp = pay_load.GetUINT();      // 4 Byte      
   CRC_32 = BitField(temp,0,32);

   // state that this pat is valid
   valid =  1;
}

UINT Program_Association_Table::GetPIDForProgram(UINT program_number)
{
   // if the user requested a desired program &&
   if (!programs || !valid)
      return PID_NULL_PACKET;

   // find a match    
   for(TListIterator * pNode = ProgramList.GetHead(); pNode != NULL; pNode=pNode->Next()){
        TRANSPORT_PROGRAM * pProgram = ProgramList.GetData(pNode);
      if (pProgram->program_number == program_number)
         return    pProgram->PID;
    };
   return PID_NULL_PACKET;
}

UINT Program_Association_Table::GetPIDForProgram()
{
   // if the user requested a desired program &&
   if (!programs || !valid)
      return PID_NULL_PACKET;

   // find a match    
   for(TListIterator * pNode = ProgramList.GetHead(); pNode != NULL; pNode=pNode->Next()){
        TRANSPORT_PROGRAM * pProgram = ProgramList.GetData(pNode);
      if (pProgram->program_number != 0x00)
         return    pProgram->PID;
    };
   return PID_NULL_PACKET;
}

Conditional_Access_Table::Conditional_Access_Table()
{
   valid = 0;
   table_id = 0;
   section_syntax_indicator = 0;
   section_length = 0;
   transport_stream_id = 0;
   version_number = 0;
   current_next_indicator = 0;
   section_number = 0;
   last_section_number = 0;
   CRC_32 = 0;
}


void Conditional_Access_Table::Refresh()
{
UINT temp;
UINT i;
UINT N;
Byte_Stream pay_load;

   // initialize payload byte stream to point to data byte in the transport packet
   pay_load.Initialize(data_byte,data_bytes);

   temp = pay_load.GetByte();
   pointer_field = BitField(temp,0,8);
   // if pointer field exists move to it
   if (pointer_field){
      N = pointer_field;
      for (i = 0;i < N; i++)
         temp = pay_load.GetByte();
   }

   // get table id
   temp = pay_load.GetByte();
   table_id                   = BitField(temp,0,8);
   
   temp = pay_load.GetWORD(); // 2 Bytes
   section_syntax_indicator   = BitField(temp,15,1);
   section_length             = BitField(temp,0,12);

   temp = pay_load.GetWORD(); // 2 Bytes
   transport_stream_id        = BitField(temp,0,16);

   temp = pay_load.GetByte(); // 1 Byte
   version_number             = BitField(temp,1,5);
   current_next_indicator     = BitField(temp,0,1);
   
   temp = pay_load.GetByte(); // 1 Byte
   section_number             = BitField(temp,0,8);
   
   temp = pay_load.GetByte(); // 1 Byte
   last_section_number        = BitField(temp,0,8);

   // we consumed 5 bytes since section_length 
   // and we will consume the CRC (4 bytes)
   N = (section_length - 9);

   for (i = 0;i < N; i++)
      pay_load.GetByte();      // 1 Byte      

   temp = pay_load.GetUINT();  // 4 Byte      
   CRC_32 = BitField(temp,0,32);

   // state that this pat is valid
   valid =  1;
}


Program_Map_Table::Program_Map_Table()
{
   valid = 0;
   table_id = 0;
   section_syntax_indicator = 0;
   section_length = 0;
   program_number = 0;
   version_number = 0;
   current_next_indicator = 0;
   section_number = 0;
   last_section_number = 0;
   PCR_PID = 0;
   program_info_length = 0;
   streams = 0;
   CRC_32 = 0;
   program_info = NULL;
}

void Program_Map_Table::ClearTable()
{
   for(TListIterator * pNode = StreamTable.GetHead(); pNode != NULL; pNode=pNode->Next()){
        STREAM_TABLE * pStream = StreamTable.GetData(pNode);
      delete pStream;
    };
   StreamTable.Flush();
}

void Program_Map_Table::Refresh()
{
   UINT temp;
   UINT i;
   UINT N;
   Byte_Stream pay_load;

   // initialize payload byte stream to point to data byte in the transport packet
   pay_load.Initialize(data_byte,data_bytes);

   // get the pointer field
   temp = pay_load.GetByte();
   pointer_field = BitField(temp,0,8);
   // if pointer field exists move to it
   if (pointer_field){
      N = pointer_field;
      for (i = 0;i < N; i++)
         temp = pay_load.GetByte();
   }

   // get table id
   temp = pay_load.GetByte();
   table_id                   = BitField(temp,0,8);
   
   temp = pay_load.GetWORD();      // 2 Bytes
   section_syntax_indicator   = BitField(temp,15,1);
   section_length             = BitField(temp,0,12);

   temp = pay_load.GetWORD();      // 2 Bytes
   program_number             = BitField(temp,0,16);

   temp = pay_load.GetByte();      // 1 Byte
   version_number             = BitField(temp,1,5);
   current_next_indicator     = BitField(temp,0,1);
   
   temp = pay_load.GetByte();      // 1 Byte
   section_number             = BitField(temp,0,8);
   
   temp = pay_load.GetByte();      // 1 Byte
   last_section_number        = BitField(temp,0,8);

   temp = pay_load.GetWORD();      // 2 Bytes
   PCR_PID                    = BitField(temp,0,13);

   temp = pay_load.GetWORD();      // 2 Bytes
   program_info_length        = BitField(temp,0,12);

   // get descriptor
   if (program_info_length){
      // save descriptor pointer
      program_info = pay_load.GetBytePointer();
      // advance pointer
      pay_load.Advance(program_info_length);
   }
   
   // how many bytes consumed so far
   N = pay_load.GetPosition();

   // initialize index
   i = 0;

   // get stream info
   while ( (pay_load.GetPosition() - N) <    (section_length - 13 - program_info_length)){
      // create stream table entry
      STREAM_TABLE * pStream = new STREAM_TABLE;

      temp = pay_load.GetByte();   // 1Byte
      pStream->stream_type    = BitField(temp,0,8);
      
      temp = pay_load.GetWORD();   // 2Byte
      pStream->elementary_PID = BitField(temp,0,13);
      
      temp = pay_load.GetWORD();   // 2Byte
      pStream->ES_info_length = BitField(temp,0,12); 
      // get descriptor pointer
      pStream->ES_info = pay_load.GetBytePointer();

      // advance pointer
      pay_load.Advance(pStream->ES_info_length);

      StreamTable.AddTail(pStream);
      // increment index
      i++;
   }
   streams = i;
   // get crc
   temp = pay_load.GetUINT();      // 4 Byte      
   CRC_32 = BitField(temp,0,32);

   // state that this pat is valid
   valid =  1;

   return;
}

UINT Program_Map_Table::GetPIDForVideo()
{
   // if the user requested a desired program &&
   if (!streams || !valid)
      return PID_NULL_PACKET;

   // find a match    
   for(TListIterator * pNode = StreamTable.GetHead(); pNode != NULL; pNode=pNode->Next()){
        STREAM_TABLE * pStream = StreamTable.GetData(pNode);
      if (IsVideo(pStream->stream_type))
         return    pStream->elementary_PID;
    };
   return PID_NULL_PACKET;
}

UINT Program_Map_Table::GetPIDForAudio()
{
   // if the user requested a desired program &&
   if (!streams || !valid)
      return PID_NULL_PACKET;

   // find a match    
   for(TListIterator * pNode = StreamTable.GetHead(); pNode != NULL; pNode=pNode->Next()){
        STREAM_TABLE * pStream = StreamTable.GetData(pNode);
      if (IsAudio(pStream->stream_type))
         return    pStream->elementary_PID;
    };
   return PID_NULL_PACKET;
}
UINT Program_Map_Table::GetTypeForStream(UINT stream)
{
   // if the user requested a desired program &&
   if (!streams || !valid)
      return PID_NULL_PACKET;

   // find a match    
   UINT stream_no = 0;
   for(TListIterator * pNode = StreamTable.GetHead(); pNode != NULL; pNode=pNode->Next()){
      if (stream_no == stream){
         STREAM_TABLE * pStream = StreamTable.GetData(pNode);
         return   pStream->stream_type;
      }
      stream_no++;
   }
   return PID_NULL_PACKET;
}

UINT Program_Map_Table::GetPIDForStream(UINT stream)
{
   // if the user requested a desired program &&
   if (!streams || !valid)
      return PID_NULL_PACKET;

   // find a match    
   UINT stream_no = 0;
   for(TListIterator * pNode = StreamTable.GetHead(); pNode != NULL; pNode=pNode->Next()){
      if (stream_no == stream){
         STREAM_TABLE * pStream = StreamTable.GetData(pNode);
         return   pStream->elementary_PID;
      }
      stream_no++;
   }
   return PID_NULL_PACKET;
}

Private_Table::Private_Table()
{
   valid = 0;
   table_id = 0;
   section_syntax_indicator = 0;
   private_indicator = 0;
   private_section_length = 0;
   private_data_bytes = 0;
   table_id_extension = 0;
   version_number = 0;
   current_next_indicator = 0;
   section_number = 0;
   last_section_number = 0;
   CRC_32 = 0;
   pointer_field = 0;
}

void Private_Table::Refresh()
{
   UINT temp;
   UINT i;
   UINT N;
   UINT private_sync_point;
   Byte_Stream pay_load;

   // initialize payload byte stream to point to data byte in the transport packet
   pay_load.Initialize(data_byte,data_bytes);

   // get a sync point in stream
   private_sync_point = pay_load.GetPosition();

   temp = pay_load.GetByte();
   pointer_field = BitField(temp,0,8);
   // if pointer field exists move to it
   if (pointer_field){
      N = pointer_field;
      for(i = 0;i < N; i++)
         temp = pay_load.GetByte();
   }

   // get table id
   temp = pay_load.GetByte();
   table_id               = BitField(temp,0,8);
   
   temp = pay_load.GetWORD();      // 2 Bytes
   section_syntax_indicator       = BitField(temp,15,1);
   private_indicator         = BitField(temp,14,1);
   private_section_length      = BitField(temp,0,12);
   if (section_syntax_indicator == 0x00){
      N = data_bytes - (pay_load.GetPosition() - private_sync_point);
      private_data_bytes = N;
      for(i = 0; i < N; i++) {
         pay_load.GetByte();      // 1 Byte
      }
         // state that this pat is valid
      valid = 1;
   }else {
      temp = pay_load.GetWORD();       // 2 Bytes
      table_id_extension               = BitField(temp,0,16);

      temp = pay_load.GetByte();       // 1 Byte
      version_number                   = BitField(temp,1,5);
      current_next_indicator           = BitField(temp,0,1);
      
      temp = pay_load.GetByte();       // 1 Byte
      section_number                   = BitField(temp,0,8);
      
      temp = pay_load.GetByte();       // 1 Byte
      last_section_number              = BitField(temp,0,8);

      N = private_section_length - (pay_load.GetPosition() - private_sync_point);
      private_data_bytes = N;
      for (i = 0; i < N; i++) {
         pay_load.GetByte();           // 1 Byte
      }

      // get crc
      temp = pay_load.GetUINT();       // 4 Byte      
      CRC_32 = BitField(temp,0,32);

      // state that this pat is valid
      valid =  1;

   }
}

void PES_Stream::ReadData(Transport_Packet &tp)
{
   UINT temp;
   UINT N;
   UINT PES_extension;
   Byte_Stream payload;
   UINT video_error_code = 0x000001b4;

   // initialize payload byte stream to point to data byte in the transport packet
   payload.Initialize(tp.data_byte,tp.data_bytes);

   pData = NULL;
   lData = 0;
   
   // if pusi is set then this packet begins a PES packet
   if (tp.payload_unit_start_indicator){
      // new PES packet arrived initialize
      Refresh();

      // pes packet start code index
      temp = payload.GetByte();     // 1 Byte
      packet_start_code_prefix      = BitField(temp,0,8) << 16;

      temp = payload.GetByte();     // 1 Byte
      packet_start_code_prefix     |= BitField(temp,0,8) << 8;

      temp = payload.GetByte();     // 1 Byte
      packet_start_code_prefix     |= BitField(temp,0,8) ;

      temp = payload.GetByte();     // 1 Byte
      stream_id                     = BitField(temp,0,8);

      temp = payload.GetWORD();     // 2 Bytes
      PES_packet_length             = BitField(temp,0,16);

      if ((stream_id !=ID_PROGRAM_STREAM_MAP) &&
         (stream_id !=ID_PADDING_STREAM) &&
         (stream_id !=ID_PRIVATE_STREAM_2) &&
         (stream_id !=ID_ECM_STREAM) &&
         (stream_id !=ID_EMM_STREAM) &&
         (stream_id !=ID_DSMCC_STREAM) &&
         (stream_id !=ID_ITU_TYPE_E) &&
         (stream_id != ID_PROGRAM_STREAM_DIRECTORY)){
         temp = payload.GetByte();     // 1 Byte
         PES_scrambling_control        = BitField(temp,4,2);
         PES_priority                  = BitField(temp,3,1);   // may ignore
         data_alignment_indicator      = BitField(temp,2,1);
         copyright                     = BitField(temp,1,1);   // may ignore
         original_or_copy              = BitField(temp,0,1);   // may ignore

         temp = payload.GetByte();     // 1 Byte
         PTS_DTS_flags                 = BitField(temp,6,2);
         ESCR_flag                     = BitField(temp,5,1);   // may ignore
         ES_rate_flag                  = BitField(temp,4,1);   // may ignore
         DSM_trick_mode_flag           = BitField(temp,3,1);   // may ignore (not for broadcast)
         additional_copy_info_flag     = BitField(temp,2,1);   // may ignore
         PES_CRC_flag                  = BitField(temp,1,1);   // may ignore
         PES_extension_flag            = BitField(temp,0,1);   // may ignore

         temp = payload.GetByte();     // 1 Byte
         PES_header_data_length        = BitField(temp,0,8);

         // mark sync point in payload data
         PES_extension = payload.GetPosition();

         if (PTS_DTS_flags & 0x2){
            temp = payload.GetByte();  // 1 Byte
            PTS_msb                    = BitField(temp,3,1);
            PTS                        = BitField(temp,1,2) << 30;

            temp = payload.GetWORD();  // 2 Bytes
            PTS                       |=   BitField(temp,1,15) << 15;

            temp = payload.GetWORD();  // 2 Bytes
            PTS                       |=   BitField(temp,1,15);
         }

         if (PTS_DTS_flags & 0x1){
            temp = payload.GetByte();  // 1 Byte
            DTS_msb                    = BitField(temp,3,1);
            DTS                        = BitField(temp,1,2) << 30;

            temp = payload.GetWORD();  // 2 Bytes
            DTS                       |=   BitField(temp,1,15) << 15;

            temp = payload.GetWORD();  // 2 Bytes
            DTS                       |=   BitField(temp,1,15);
         }

         if (ESCR_flag){
            payload.Advance(4);//GetUINT();      // 4 Bytes
            payload.GetWORD();         // 2 Bytes
         }
         if (ES_rate_flag){
            payload.GetWORD();         // 2 Bytes
            payload.GetByte();         // 1 Byte
         }
         if (DSM_trick_mode_flag){
            payload.GetByte();         // 1 Byte
         }
         if (additional_copy_info_flag){
            payload.GetByte();         // 1 Byte
         }
         if (PES_CRC_flag){
            payload.GetWORD();         // 2 Bytes
         }
         if (PES_extension_flag == 0x1){
            temp = payload.GetByte();   // 1 Byte
            PES_private_data_flag   = BitField(temp,7,1);   // may ignore
            pack_header_field_flag  = BitField(temp,6,1);   // may ignore
            program_packet_sequence_counter_flag =  BitField(temp,5,1);    // may ignore
            PSTD_buffer_flag        = BitField(temp,4,1);   // may ignore
            PES_extension_flag_2    = BitField(temp,0,1);
            if (PES_private_data_flag){
               payload.Advance(4); // GetUINT();      // 4 Bytes
               payload.Advance(4); // GetUINT();      // 4 Bytes
               payload.Advance(4); // GetUINT();      // 4 Bytes
               payload.Advance(4); // GetUINT();      // 4 Bytes
            }
            if (pack_header_field_flag){
               temp = payload.GetByte();   // 1 Byte
               pack_field_length    = BitField(temp,0,8);
               // advance pointer
               payload.Advance(pack_field_length);
            }
            if (program_packet_sequence_counter_flag){
               payload.GetWORD();   // 2 Bytes
            }
            if (PSTD_buffer_flag){
               payload.GetWORD();   // 2 Bytes
            }
            if (PES_extension_flag_2){
               temp = payload.GetByte();   // 1 Byte
               PES_extension_field_length = BitField(temp,0,8);
               // advance pointer
               payload.Advance(PES_extension_field_length);
            }

         }
         // read off stuffing bytes
         N = PES_header_data_length - (payload.GetPosition() - PES_extension);
         payload.Advance(N);

      }else if ((stream_id ==ID_PROGRAM_STREAM_MAP) ||
         (stream_id ==ID_PRIVATE_STREAM_2) ||
         (stream_id ==ID_ECM_STREAM) ||
         (stream_id ==ID_EMM_STREAM) ||
         (stream_id ==ID_DSMCC_STREAM) ||
         (stream_id ==ID_ITU_TYPE_E) ||
         (stream_id == ID_PROGRAM_STREAM_DIRECTORY)){
      }else if (stream_id ==ID_PADDING_STREAM){
      }

      // clear out the number of bytes we consumed
      data_bytes = 0;
      
    }
   
   // this is the continuation of a PES packet
   // because the start code prefix already found
   if (packet_start_code_prefix == 0x000001){
      if (data_bytes){   // data_bytes will be zero on the first packet
         // if there was discontinuity then quit;
         // this will always quit
         if (tp.continuity_counter != ((last_continuity_counter + 1) % 16) ){
            // set discontinuity flag
            Discontinuity = 1;
            // discontinuity occured make sure not equal
            if (tp.continuity_counter == last_continuity_counter)
               return;
            Refresh();
            return;
         }
         // clear discontinuity flag
         Discontinuity = 0;
      }
      // set the last continuity counter to this packets counter
      last_continuity_counter =  tp.continuity_counter;

      // calculate the amount of rest of pes data
      if (PES_packet_length==0)
         N = tp.data_bytes - payload.GetPosition();         
      else
         N = min(tp.data_bytes - payload.GetPosition(),PES_packet_length - data_bytes);

      // update how many bytes have we consumed so far
      data_bytes+= N;

      // we ignore a padding stream
      if (stream_id ==ID_PADDING_STREAM)
         return;
      
      // write data to stream
      pData = payload.GetBytePointer();   // pointer to data in packet
      lData = N;      // how much data
   }
}

UINT Transport_Section::IsNewVersion()
{
   if (new_version){
      new_version = 0;
      return 1;
   }
   else 
      return 0;
}

void Transport_Section::ReadData(Transport_Packet &tp)
{
   UINT temp;
   UINT i;
   UINT N;
   Byte_Stream pay_load;

   if (tp.data_bytes == 0) {
      return;
   }
   
   // initialize payload byte stream to point to data byte in the transport packet
   pay_load.Initialize(tp.data_byte,tp.data_bytes);


   // if payload_unit_start_indicator is 1 then there is a pointer_field
   if (tp.payload_unit_start_indicator){

      // get the pointer field
      temp = pay_load.GetByte();
      pf = BitField(temp,0,8);
      // if pointer field exists move to it
      if (pf){
         N = pf;
         for (i = 0;i < N; i++)
            temp = pay_load.GetByte();
      }
      
      // table_id      
      temp = pay_load.GetByte();
      ti   = BitField(temp,0,8);

      // section_syntax_indicator      
      // section_length
      temp = pay_load.GetWORD();      // 2 Bytes
      ssi   = BitField(temp,15,1);
      sl = BitField(temp,0,12);

      header_bytes   = pay_load.GetPosition();

      // version_number
      // current_next_indicator
      temp = pay_load.GetWORD();      // 2 Bytes
      temp = pay_load.GetByte();      // 1 Byte
      vn   = BitField(temp,1,5);
      cni   = BitField(temp,0,1);

      // initialize number ofbytes have we consumed so far
      data_bytes = 0;
   }
   
   if (data_bytes){   // data_bytes will be zero on the first packet
      // if there was discontinuity then quit;
      // this will always quit
      if ( (++lcc % 16) != tp.continuity_counter){
         data_bytes = 0;
         return;
      }
   }

   // update the last continuity counter
   lcc = tp.continuity_counter;

   // how many bytes do we need to consume
   N = min(((header_bytes + sl) - data_bytes),tp.data_bytes);

   // copy the data
   CopyMemory(&data_byte[data_bytes],tp.data_byte,N);

   // update how many bytes have we consumed so far
   data_bytes+= N;

   // check to see if we have read enough
   if (data_bytes >= (sl + header_bytes)){
      // do a crc check
      // if crc is ok then initialize the contents of the table
      if (CRC_OK(&data_byte[0]+ pf + 1,&data_byte[header_bytes + sl])){
         UINT crc =0; // *(UINT *)(&data_byte[header_bytes + sl] - 4);
          //crc = _lrotl(((crc & 0xFF00FF00) >> 8) | ((crc & 0x00FF00FF) << 8), 16);
             crc = ((crc & 0x000000ff) << 24) | ((crc & 0x0000ff00) << 8) | ((crc & 0x00ff0000) >> 8) | ((crc & 0xff000000) >> 24);
         // if we are a currently valid table should we be
         // initializing the table this time
         if (!valid ||            // table not yet valid
            ((cni == 1) &&         // current_next_indicator set
            (vn!=version_number && CRC_32 != crc))){ // table is different
            // set our new version flag
            new_version = 1;
            // clear our list of old programs if this is the first section
            ClearTable();
            // valid update with new version
            Refresh();
         }
         return;   // don't update with new section
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\pinprop\pinprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       pinprop.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <streams.h>
#include <initguid.h>
#include "ksguid.h"
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <olectlid.h>
#include <memory.h>
#include "kspguids.h"
#include "resource.h"
#include "ikspin.h"
#include "ksprxmtd.h"
#include "pinprop.h"

//
//   The template provides the static classes we support in this DLL.
//
CFactoryTemplate g_Templates[] = 
{
    {L"KsProperties", &CLSID_KsPinProperties, CKSPinProperties::CreateInstance}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


CUnknown *CKSPinProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CKSPinProperties(lpunk, NAME("Pin Property Page"), phr);
    
    if (punk == NULL) 
        *phr = E_OUTOFMEMORY;

    return punk;
} 


CKSPinProperties::CKSPinProperties(LPUNKNOWN lpunk, TCHAR *pName, HRESULT *phr)
    : CUnknown(pName, lpunk, phr)
    , m_hwnd(NULL) 
    , m_fDirty(FALSE)
    , m_pPPSite(NULL)
    , m_CurrentItem(NULL)
{
    InitCommonControls();
} 

STDMETHODIMP CKSPinProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IPropertyPage) 
        return GetInterface((IPropertyPage *) this, ppv);
    else 
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP CKSPinProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{

    WCHAR szTitle[] = L"Pin";
    LPOLESTR pszTitle;

    pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(szTitle));
    memcpy(pszTitle, &szTitle, sizeof(szTitle));

    pPageInfo->cb                   = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle             = pszTitle;
    pPageInfo->size.cx              = 253;
    pPageInfo->size.cy              = 132;
    pPageInfo->pszDocString = NULL;
    pPageInfo->pszHelpFile  = NULL;
    pPageInfo->dwHelpContext= 0;

    return NOERROR;
}

BOOL CALLBACK CKSPinProperties::DialogProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CKSPinProperties *pThis = (CKSPinProperties *) GetWindowLong(hwnd, GWL_USERDATA);
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            // GWL_USERDATA has not been set yet. pThis is in lParam
            pThis = (CKSPinProperties *) lParam;
            return TRUE; 
            
        case WM_DESTROY:
            return TRUE;

        default:
            return FALSE;

    }
} 

STDMETHODIMP CKSPinProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk)
{
    if(cObjects == 1)
    {
       HRESULT hr = (*ppunk)->QueryInterface(IID_IKsPin, (void **) &m_pIKsPin);
       if (FAILED(hr)) 
            return hr;

       hr = m_pIKsPin->KsGetPinClass(&m_pIKsPinClass);
       if (FAILED(hr)) 
            return hr;
    }
    else if(cObjects == 0)
    {
        if(m_pIKsPin)
        {
            m_pIKsPin->Release();
            m_pIKsPin= 0;

        }
        if(m_pIKsPinClass)
        {
            m_pIKsPinClass->Release();
            m_pIKsPinClass= 0;

        }
    }
    return NOERROR;
} 

STDMETHODIMP CKSPinProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal)
{                                
    TCHAR* iDialog;

    iDialog = MAKEINTRESOURCE(IDD_PINDIALOG);               

    m_hwnd = CreateDialogParam( g_hInst, iDialog, hwndParent, DialogProc, (LPARAM) this);
    if (m_hwnd == NULL) 
    {
        DWORD dwErr = GetLastError();
        DbgLog(( LOG_ERROR, 1, TEXT("Could not create window.  Error code: 0x%x"), dwErr));
        return E_FAIL;
    }
    
    // Parent should control us, so the user can tab out of our property sheet
    SetWindowLong(m_hwnd, GWL_USERDATA, (long)this);
    DWORD dwStyle = ::GetWindowLong(m_hwnd, GWL_EXSTYLE);
    dwStyle = dwStyle | WS_EX_CONTROLPARENT;
    SetWindowLong(m_hwnd, GWL_EXSTYLE, dwStyle);

    // Fill in the window stuff now
    DisplayPinInfo();

    m_fDirty = FALSE;
    return Move(prect);
}  

/*
*/

void CKSPinProperties::DisplayPinInfo()
{
    int count;
    HWND hTree = GetDlgItem(m_hwnd, IDC_FORMATTREE);
    HTREEITEM hParent;
    char szString[128];
    TV_INSERTSTRUCT InsertItem;
    int i;

    // 
    // Interfaces
    //
    wsprintf( szString, "%s", "Interfaces");
    InsertItem.item.mask            = TVIF_TEXT;
    InsertItem.item.pszText         = szString;
    InsertItem.item.cchTextMax      = strlen(szString);
    InsertItem.hParent              = NULL;
    InsertItem.hInsertAfter         = TVI_LAST;
    hParent = TreeView_InsertItem(hTree, &InsertItem);

    InsertItem.item.pszText         = szString;
    InsertItem.hInsertAfter         = TVI_LAST;
    InsertItem.hParent              = hParent;

    count = m_pIKsPinClass->KsGetInterfaceCount();
    char *pszInterface;
    KSPIN_INTERFACE KsPinInterface;
    for(i = 0; i < count; i++)
    {
        m_pIKsPinClass->KsGetInterface(i, &KsPinInterface);
        CKSGetString::KsGetInterfaceString(KsPinInterface, &pszInterface);
        wsprintf( szString, "%s", pszInterface);
        InsertItem.item.cchTextMax       = strlen(szString);
        TreeView_InsertItem(hTree, &InsertItem);
    }
    // 
    // Mediums
    //
    wsprintf( szString, "%s", "Mediums");
    InsertItem.item.pszText         = szString;
    InsertItem.item.cchTextMax      = strlen(szString);
    InsertItem.hParent              = NULL;
    InsertItem.hInsertAfter         = TVI_LAST;
    hParent = TreeView_InsertItem(hTree, &InsertItem);

    InsertItem.item.pszText         = szString;
    InsertItem.hInsertAfter         = TVI_LAST;
    InsertItem.hParent              = hParent;

    count = m_pIKsPinClass->KsGetMediumCount();
    char *pszMedium;
    KSPIN_MEDIUM KsPinMedium;
    for(i = 0; i < count; i++)
    {
        m_pIKsPinClass->KsGetMedium(i, &KsPinMedium);
        CKSGetString::KsGetMediumString(KsPinMedium, &pszMedium);
        wsprintf( szString, "%s", pszMedium);
        InsertItem.item.cchTextMax       = strlen(szString);
        TreeView_InsertItem(hTree, &InsertItem);
    }
    // 
    // DataRanges
    //
    wsprintf( szString, "%s", "Data Ranges");
    InsertItem.item.pszText         = szString;
    InsertItem.item.cchTextMax      = strlen(szString);
    InsertItem.hParent              = NULL;
    InsertItem.hInsertAfter         = TVI_LAST;
    hParent = TreeView_InsertItem(hTree, &InsertItem);

    InsertItem.item.pszText         = szString;
    InsertItem.hInsertAfter         = TVI_LAST;
    InsertItem.hParent              = hParent;

    count = m_pIKsPinClass->KsGetDataRangeCount();
    char *pszDataRange[20];
    // We don't know how big the size is, so we just pass pointer? Or should we ask the size?
    KSDATARANGE *pKsDataRange;
    int cLines;
    int j;
    for(i = 0; i < count; i++)
    {
        m_pIKsPinClass->KsGetDataRange(i, &pKsDataRange);
        CKSGetString::KsGetDataRangeString(pKsDataRange, &cLines, (char **) pszDataRange);

        for(j = 0; j < cLines; j++)
        {
            // Now we get an array of string pointers back
            wsprintf( szString, "%s", pszDataRange[j]);
            InsertItem.item.cchTextMax       = strlen(szString);
            TreeView_InsertItem(hTree, &InsertItem);

            // Need to delete the format since they are not staic (the first few are though?) hmm
            // TODO: Figure out what to do with the allocation of the format strings.
            // Maybe I need to return an interface to another object. So the reference count can hold the allocation.
            // Or put an ID on which need to be freed? Or just assume first 3 will not need to be (!!) yes!
        }

        // Now we delete it (assume same allocator?) TODO: Fix this.
        if(pKsDataRange)
            delete pKsDataRange;
    }
    // 
    // DataFlow
    //
    wsprintf( szString, "%s", "Data Flow");
    InsertItem.item.pszText         = szString;
    InsertItem.item.cchTextMax      = strlen(szString);
    InsertItem.hParent              = NULL;
    InsertItem.hInsertAfter         = TVI_LAST;
    hParent = TreeView_InsertItem(hTree, &InsertItem);

    InsertItem.item.pszText         = szString;
    InsertItem.hInsertAfter         = TVI_LAST;
    InsertItem.hParent              = hParent;

    char *pszDataFlow;
    KSPIN_DATAFLOW KsDataFlow;
    m_pIKsPinClass->KsGetDataFlow(&KsDataFlow);
    CKSGetString::KsGetDataFlowString(KsDataFlow, &pszDataFlow);
    wsprintf( szString, "%s", pszDataFlow);
    InsertItem.item.cchTextMax       = strlen(szString);
    TreeView_InsertItem(hTree, &InsertItem);
    // 
    // Communication
    //
    wsprintf( szString, "%s", "Communication");
    InsertItem.item.pszText         = szString;
    InsertItem.item.cchTextMax      = strlen(szString);
    InsertItem.hParent              = NULL;
    InsertItem.hInsertAfter         = TVI_LAST;
    hParent = TreeView_InsertItem(hTree, &InsertItem);

    InsertItem.item.pszText         = szString;
    InsertItem.hInsertAfter         = TVI_LAST;
    InsertItem.hParent              = hParent;

    char *pszCommunication;
    KSPIN_COMMUNICATION KsCommunication;
    m_pIKsPinClass->KsGetCommunication(&KsCommunication);
    CKSGetString::KsGetCommunicationString(KsCommunication, &pszCommunication);
    wsprintf( szString, "%s", pszCommunication);
    InsertItem.item.cchTextMax       = strlen(szString);
    TreeView_InsertItem(hTree, &InsertItem);
}

STDMETHODIMP CKSPinProperties::Show(UINT nCmdShow)
{
    if (m_hwnd == NULL) 
        return E_UNEXPECTED;

    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);
    return NOERROR;
} 

STDMETHODIMP CKSPinProperties::Deactivate(void) 
{
    if (m_hwnd == NULL) 
        return E_UNEXPECTED;

    HWND hTree = GetDlgItem(m_hwnd, IDC_FORMATTREE);
    //
    // HACK: Remove WS_EX_CONTROLPARENT before DestroyWindow call
    //         (or NT crashes!)
    DWORD dwStyle = ::GetWindowLong(m_hwnd, GWL_EXSTYLE);
    dwStyle = dwStyle & (~WS_EX_CONTROLPARENT);
    SetWindowLong(m_hwnd, GWL_EXSTYLE, dwStyle);

    if (DestroyWindow(m_hwnd)) 
    {
        m_hwnd = NULL;
        return NOERROR;
    }
    else 
    {
        return E_FAIL;
    }
} 


 STDMETHODIMP CKSPinProperties::SetPageSite(LPPROPERTYPAGESITE pPPSite)
 {
    if(pPPSite == NULL)
    {
        // This is the cleanup case.
        if(m_pPPSite)
            m_pPPSite->Release();

        m_pPPSite = NULL;
    }
    else
    {
        m_pPPSite = pPPSite;
        m_pPPSite->AddRef();
    }

    return NOERROR;
 }


STDMETHODIMP CKSPinProperties::IsPageDirty(void)
{
    if(m_fDirty)
        return S_OK;
    else
        return S_FALSE;
}                          


STDMETHODIMP CKSPinProperties::Apply(void)
{
#ifdef DEBUG
    ASSERT(m_hwnd);
#endif

    // If we are not dirty, do not apply changes.
    if(m_fDirty == FALSE)
        return S_OK;

    return S_OK;
}               

STDMETHODIMP CKSPinProperties::Move(LPCRECT prect)
{

    if (MoveWindow(m_hwnd, 
                    prect->left, 
                    prect->top, 
                    prect->right - prect->left, 
                    prect->bottom - prect->top, 
                    TRUE)) 
        return NOERROR;
    else 
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\pinprop\ksprxmtd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ksprxmtd.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include "resource.h"
#include "ikspin.h"
#include "ksprxmtd.h"
#include "pinprop.h"

#define SIZE_AR(a) sizeof(a) / sizeof(a[0])
#define MakeEntry(s) { s, #s}
#define MakeSetEntry(s, f) { (LPCLSID) &s, #s, f, SIZE_AR(f) }

char *pszNULL = "";

ULONGToString arInterfaces[] = 
{
    MakeEntry(KSINTERFACE_STANDARD_STREAMING),
    MakeEntry(KSINTERFACE_STANDARD_PACKETSTREAMING),
    MakeEntry(KSINTERFACE_STANDARD_MDLSTREAMING),
    MakeEntry(KSINTERFACE_STANDARD_POSITION),
    MakeEntry(KSINTERFACE_STANDARD_PACKETPOSITION),
    MakeEntry(KSINTERFACE_STANDARD_MDLPOSITION)
}; 

ULONGToString arMediaInterfaces[] = 
{
    MakeEntry(KSINTERFACE_MEDIA_MUSIC),
    MakeEntry(KSINTERFACE_MEDIA_WAVE_BUFFERED),
    MakeEntry(KSINTERFACE_MEDIA_WAVE_QUEUED)
};

GuidToSet arInterfaceSets[] = 
{
    MakeSetEntry(KSINTERFACESETID_Standard, arInterfaces),
    MakeSetEntry(KSINTERFACESETID_Media, arMediaInterfaces)
};

ULONGToString arMediums[] = 
{
    MakeEntry(KSMEDIUM_STANDARD_DEVIO),
    MakeEntry(KSMEDIUM_STANDARD_FILEIO)
};

ULONGToString arMediaMediums[] = 
{
    MakeEntry(KSMEDIUM_STANDARD_MIDIBUS)
};

GuidToSet arMediumSets[] = 
{
    MakeSetEntry(KSMEDIUMSETID_Standard, arMediums),
    MakeSetEntry(KSMEDIUMSETID_Media, arMediaMediums)
};

ULONGToString arDataFlows[] = 
{
    MakeEntry(KSPIN_DATAFLOW_IN),
    MakeEntry(KSPIN_DATAFLOW_OUT),
    MakeEntry(KSPIN_DATAFLOW_FULLDUPLEX),
}; 

ULONGToString arCommunications[] = 
{
    MakeEntry(KSPIN_COMMUNICATION_NONE),
    MakeEntry(KSPIN_COMMUNICATION_SINK),
    MakeEntry(KSPIN_COMMUNICATION_SOURCE),
    MakeEntry(KSPIN_COMMUNICATION_BOTH),
    MakeEntry(KSPIN_COMMUNICATION_BRIDGE)
}; 

#define MakeGuidEntry(s, f) { (LPCLSID) &s, #s, f }

// changes here as well with the new format.
GuidToStr arFormats[] =
{
    // Major types
    MakeGuidEntry(KSDATAFORMAT_TYPE_AUDIO, NULL),
    MakeGuidEntry(KSDATAFORMAT_TYPE_MIXER, NULL),             
    MakeGuidEntry(KSDATAFORMAT_TYPE_MIXER_LINE, NULL),        
    MakeGuidEntry(KSDATAFORMAT_TYPE_MUSIC, NULL),   

    // ActiveMovie only
    MakeGuidEntry(MEDIATYPE_Text, NULL),
    MakeGuidEntry(MEDIATYPE_Midi, NULL),
    MakeGuidEntry(MEDIATYPE_Stream, NULL),
    MakeGuidEntry(MEDIATYPE_MPEG1SystemStream, NULL),

    // Sub types (note there are more than just PCM, see SUBTYPE_WAVEFORMATEX + id 
    MakeGuidEntry(KSDATAFORMAT_SUBTYPE_ANALOG, NULL),       
    MakeGuidEntry(KSDATAFORMAT_SUBTYPE_PCM, NULL),          
    MakeGuidEntry(KSDATAFORMAT_SUBTYPE_MIDI, NULL),         
    MakeGuidEntry(KSDATAFORMAT_SUBTYPE_MIDI_BUS, NULL),
    
    // ActiveMovie only
    MakeGuidEntry(MEDIASUBTYPE_YVU9, NULL),
    MakeGuidEntry(MEDIASUBTYPE_Y411, NULL),
    MakeGuidEntry(MEDIASUBTYPE_Y41P, NULL),
    MakeGuidEntry(MEDIASUBTYPE_YUY2, NULL),
    MakeGuidEntry(MEDIASUBTYPE_YVYU, NULL),
    MakeGuidEntry(MEDIASUBTYPE_UYVY, NULL),
    MakeGuidEntry(MEDIASUBTYPE_Y211, NULL),
    MakeGuidEntry(MEDIASUBTYPE_CLJR, NULL),
    MakeGuidEntry(MEDIASUBTYPE_IF09, NULL),
    MakeGuidEntry(MEDIASUBTYPE_CPLA, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB1, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB4, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB8, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB565, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB555, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB24, NULL),
    MakeGuidEntry(MEDIASUBTYPE_RGB32, NULL),
    MakeGuidEntry(MEDIASUBTYPE_Overlay, NULL),
    MakeGuidEntry(MEDIASUBTYPE_MPEG1Packet, NULL),
    MakeGuidEntry(MEDIASUBTYPE_MPEG1Payload, NULL),
    MakeGuidEntry(MEDIASUBTYPE_MPEG1System, NULL),
    MakeGuidEntry(MEDIASUBTYPE_MPEG1VideoCD, NULL),
    MakeGuidEntry(MEDIASUBTYPE_MPEG1Video, NULL),
    MakeGuidEntry(MEDIASUBTYPE_MPEG1Audio, NULL),
    MakeGuidEntry(MEDIASUBTYPE_Avi, NULL),
    MakeGuidEntry(MEDIASUBTYPE_QTMovie, NULL),
    MakeGuidEntry(MEDIASUBTYPE_PCMAudio, NULL),
    MakeGuidEntry(MEDIASUBTYPE_WAVE, NULL),
    MakeGuidEntry(MEDIASUBTYPE_AU, NULL),
    MakeGuidEntry(MEDIASUBTYPE_AIFF, NULL),

    // Format structure ids (all you need to parse the structure)
    MakeGuidEntry(KSDATAFORMAT_FORMAT_WAVEFORMATEX, CKSGetString::KsParseAudioRange),   
    MakeGuidEntry(KSDATAFORMAT_FORMAT_FILENAME, NULL),     
    
    // ActiveMovie only
    MakeGuidEntry(FORMAT_VideoInfo, NULL),
    MakeGuidEntry(FORMAT_MPEGVideo, NULL),
    MakeGuidEntry(FORMAT_MPEGStreams, NULL),

};
int CKSGetString::KsGetInterfaceString(KSPIN_INTERFACE KsPinInterface, char **pszKsPinInterface)
{
    // First find the proper guid
    ULONGToString *parUToS = NULL;
    for(int i = 0; i < SIZE_AR(arInterfaceSets); i++)
    {
        if(IsEqualGUID(*arInterfaceSets[i].m_rguid, KsPinInterface.Set))
        {
            parUToS = arInterfaceSets[i].m_par;         
            break;
        }
    }

    if(parUToS == NULL)
    {
        *pszKsPinInterface = pszNULL;
        return FALSE;
    }

    *pszKsPinInterface = pszNULL;
    for(int j = 0; j < arInterfaceSets[i].m_Count; j++)
    {
        if(parUToS[j].ulType == (ULONG) KsPinInterface.Id)
        {
            *pszKsPinInterface = parUToS[j].pStr;
            break;
        }
    }
    return TRUE;
}
int CKSGetString::KsGetMediumString(KSPIN_MEDIUM KsPinMedium, char **pszKsPinMedium)
{
    // First find the proper guid
    ULONGToString *parUToS = NULL;
    for(int i = 0; i < SIZE_AR(arMediumSets); i++)
    {
        if(IsEqualGUID(*arMediumSets[i].m_rguid, KsPinMedium.Set))
        {
            parUToS = arMediumSets[i].m_par;         
            break;
        }
    }

    if(parUToS == NULL)
    {
        *pszKsPinMedium = pszNULL;
        return FALSE;
    }

    *pszKsPinMedium = pszNULL;
    for(int j = 0; j < arMediumSets[i].m_Count; j++)
    {
        if(parUToS[j].ulType == (ULONG) KsPinMedium.Id)
        {
            *pszKsPinMedium = parUToS[j].pStr;
            break;
        }
    }
    return TRUE;
}
int CKSGetString::KsGetDataRangeString(KSDATARANGE *pKsDataRange, int *pCount, char *parszKsDataRange[])
{
    int i;
    int iLinesReturned = 0;

    // Format
    parszKsDataRange[iLinesReturned] = pszNULL;
    for(i = 0; i < SIZE_AR(arFormats); i++)
    {
        if(IsEqualGUID(*arFormats[i].m_rguid,pKsDataRange->MajorFormat))
        {
            parszKsDataRange[iLinesReturned] = arFormats[i].m_pszName;
            break;
        }
    }
    iLinesReturned++;

    // Subformat
    parszKsDataRange[iLinesReturned] = pszNULL;
    for(i = 0; i < SIZE_AR(arFormats); i++)
    {
        if(IsEqualGUID(*arFormats[i].m_rguid, pKsDataRange->SubFormat))
        {
            parszKsDataRange[iLinesReturned] = arFormats[i].m_pszName;
            break;
        }
    }
    iLinesReturned++;

    // Format structure (this also tells us how to parse structure)
    // TODO: Add a pointer to function to dump it out. Could also call it manually.
    parszKsDataRange[iLinesReturned] = pszNULL;
    for(i = 0; i < SIZE_AR(arFormats); i++)
    {
        if(IsEqualGUID(*arFormats[i].m_rguid, pKsDataRange->Specifier))
        {
            parszKsDataRange[iLinesReturned] = arFormats[i].m_pszName;
            iLinesReturned++;
            if(arFormats[i].m_pParseFunc)
                arFormats[i].m_pParseFunc(pKsDataRange, parszKsDataRange, &iLinesReturned);
            break;
        }
    }
    if(i == SIZE_AR(arFormats)) // Increment only if NOT found...
        iLinesReturned++;

    *pCount = iLinesReturned;

    return TRUE;
}

int CKSGetString::KsParseAudioRange(KSDATARANGE *pKsDataRange, char *parszKsDataRange[], int *piLinesReturned)
{
    // *piLinesReturned should point to the next line where we should put the information.
    KSDATARANGE_AUDIO* pAR = (KSDATARANGE_AUDIO*) pKsDataRange;
    char szTemp[128];

    wsprintf(szTemp, "cMaximumChannels=%d"         ,  pAR->MaximumChannels);           
    parszKsDataRange[*piLinesReturned] = new char [strlen(szTemp) + 1];
    strcpy(parszKsDataRange[*piLinesReturned], szTemp);
    (*piLinesReturned)++;
    wsprintf(szTemp, "cMinimumBitsPerSample=%d"    ,  pAR->MinimumBitsPerSample);      
    parszKsDataRange[*piLinesReturned] = new char [strlen(szTemp) + 1];
    strcpy(parszKsDataRange[*piLinesReturned], szTemp);
    (*piLinesReturned)++;
    wsprintf(szTemp, "cMaximumBitsPerSample=%d"    ,  pAR->MaximumBitsPerSample);      
    parszKsDataRange[*piLinesReturned] = new char [strlen(szTemp) + 1];
    strcpy(parszKsDataRange[*piLinesReturned], szTemp);
    (*piLinesReturned)++;
    wsprintf(szTemp, "ulMinimumSampleFrequency=%d" ,  pAR->MinimumSampleFrequency);   
    parszKsDataRange[*piLinesReturned] = new char [strlen(szTemp) + 1];
    strcpy(parszKsDataRange[*piLinesReturned], szTemp);
    (*piLinesReturned)++;
    wsprintf(szTemp, "ulMaximumSampleFrequency=%d" ,  pAR->MaximumSampleFrequency);   
    parszKsDataRange[*piLinesReturned] = new char [strlen(szTemp) + 1];
    strcpy(parszKsDataRange[*piLinesReturned], szTemp);
    (*piLinesReturned)++;

    return TRUE;
}


int CKSGetString::KsGetDataFlowString(KSPIN_DATAFLOW KsPinDataFlow, char **pszKsPinDataFlow)
{
    *pszKsPinDataFlow = pszNULL;
    for(int i = 0; i < SIZE_AR(arDataFlows); i++)
    {
        if(arDataFlows[i].ulType == (ULONG) KsPinDataFlow)
        {
            *pszKsPinDataFlow = arDataFlows[i].pStr;
        }
    }
    return TRUE;
}
int CKSGetString::KsGetCommunicationString(KSPIN_COMMUNICATION KsPinCommunication , char **pszKsPinCommunication)
{
    *pszKsPinCommunication = pszNULL;
    for(int i = 0; i < SIZE_AR(arCommunications); i++)
    {
        if(arCommunications[i].ulType == (ULONG) KsPinCommunication)
        {
            *pszKsPinCommunication = arCommunications[i].pStr;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\pinprop\pinprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       pinprop.h
//
//--------------------------------------------------------------------------

/*
 * Pinprop.h
 *
 * This file is entirely concerned with the implementation of the
 * properties page.
 */
class CKSPinProperties : public CUnknown, public IPropertyPage
{

public:
    DECLARE_IUNKNOWN;

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE) ;
    STDMETHODIMP IsPageDirty(void)             ;
    STDMETHODIMP Apply(void);                  
    STDMETHODIMP Help(LPCWSTR)                 { return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG)     { return E_NOTIMPL; }

private:
    void                DisplayPinInfo();

    BOOL                m_fDirty;
    IPropertyPageSite*  m_pPPSite;
    HWND                m_hwnd;                 // Handle of property window


    CKSPinProperties(LPUNKNOWN lpunk, TCHAR *pName, HRESULT *phr);
    static BOOL CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void CdDisplayDataRange(KSDATAFORMAT* pFormat);
    VOID CdSelectFormat(KSDATAFORMAT* pFormat);
    HTREEITEM           m_CurrentItem;          // Currently selected format
    IKsPin              *m_pIKsPin;
    IKsPinClass         *m_pIKsPinClass;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\streamci\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>

#include "debug.h"

#if ( DBG )
ULONG DbgPrint( LPSTR Format, ... )
{
    int         i;
    char        buf[256];
    va_list     va;

    va_start( va, Format );
    i = vsprintf( buf, Format, va );
    va_end( va );

    OutputDebugStringA( buf );
    return (ULONG) i;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\streamci\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=ks

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\streamci.def
DLLENTRY=_DllMainCRTStartup

TARGETLIBS=$(WIN32_LIBS)

LINKLIBS=\
    $(LINKLIBS) \
    $(BASEDIR)\public\sdk\lib\*\setupapi.lib \
    $(BASEDIR)\public\sdk\lib\*\user32.lib \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib


INCLUDES=..;$(BASE_INC_PATH)

UMTYPE=windows
UMRES=obj\*\streamci.res

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    ..\streamci.rc\
    ..\streamci.c\
    ..\debug.c

COFFBASE=streamci

#C_DEFINES=$(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_TERSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\streamci\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if (DBG)
   ULONG DbgPrint( PCH pchFormat, ... );

   #if !defined( DEBUG_LEVEL )
        #if defined( DEBUG_VARIABLE )
            #if defined( DEBUG_INIT )
                ULONG DEBUG_VARIABLE = DEBUGLVL_TERSE;
            #else
                extern ULONG DEBUG_VARIABLE;
            #endif
        #else
            #define DEBUG_VARIABLE DEBUGLVL_TERSE
        #endif
   #else 
        #if defined( DEBUG_VARIABLE )
            #if defined( DEBUG_INIT )
                ULONG DEBUG_VARIABLE = DEBUG_LEVEL;
            #else
                extern ULONG DEBUG_VARIABLE;
            #endif
        #else
            #define DEBUG_VARIABLE DEBUG_LEVEL
        #endif
   #endif

   #define _DbgPrintF(lvl, strings) \
{ \
    if ((lvl) <= DEBUG_VARIABLE) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        DbgPrint("\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DebugBreak();\
        } \
    } \
}
#else // !DBG
   #define _DbgPrintF(lvl, strings)
#endif // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\cppmemgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       cppmemgr.h
//
//--------------------------------------------------------------------------

//------------------------------------------------------------------------------
//      cppmemgr.h
//              This file exists solely because fwong doesn't like __cplusplus
//              in his code.  C++ app.s need to include this instead of memgr.h
//              in order to use memgr functions.
//------------------------------------------------------------------------------
#ifndef _INC_CPPMEMGR
#define _INC_CPPMEMGR

#ifdef __cplusplus
extern "C" {
#endif

#include "memgr.h"

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif  // _INC_CPPMEMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\streamci\streamci.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       streamci.h
//
//--------------------------------------------------------------------------

#define DEBUG_VARIABLE STREAMCIDebug
#define STR_MODULENAME "streamci: "

VOID
WINAPI
StreamingDeviceSetupA(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR CommandLine,
    IN INT ShowCommand
    );
    
VOID
WINAPI
StreamingDeviceSetupW(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR CommandLine,
    IN INT ShowCommand
    );

#if defined( UNICODE )
#define StreamingDeviceSetup StreamingDeviceSetupW
#else
#define StreamingDeviceSetup StreamingDeviceSetupA
#endif

VOID
WINAPI
StreamingDeviceRemoveA(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR CommandLine,
    IN INT ShowCommand
    );
    
VOID
WINAPI
StreamingDeviceRemoveW(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR CommandLine,
    IN INT ShowCommand
    );

#if defined( UNICODE )
#define StreamingDeviceRemove StreamingDeviceRemoveW
#else
#define StreamingDeviceRemove StreamingDeviceRemoveA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\enumcls\enumcls.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       enumcls.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <objbase.h>
#include <devioctl.h>
#include <tchar.h>
#include <stdio.h>
#include <conio.h>
#include <malloc.h>
#include <setupapi.h>
#include <ks.h>
#include <ksi.h>
#include <ksmedia.h>

#define STATIC_PMPORT_Transform \
    0x7E0EB9CBL, 0xB521, 0x11D1, 0x80, 0x72, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("7E0EB9CB-B521-11D1-8072-00A0C9223196", PMPORT_Transform);
#define PMPORT_Transform DEFINE_GUIDNAMED(PMPORT_Transform)

struct {
    GUID    ClassGuid;
    WCHAR*  TextName;
} TextTranslation[] = {
    {STATICGUIDOF(KSCATEGORY_BRIDGE), L"Bridge"},
    {STATICGUIDOF(KSCATEGORY_CAPTURE), L"Capture"},
    {STATICGUIDOF(KSCATEGORY_RENDER), L"Render"},
    {STATICGUIDOF(KSCATEGORY_MIXER), L"Mixer"},
    {STATICGUIDOF(KSCATEGORY_SPLITTER), L"Splitter"},
    {STATICGUIDOF(KSCATEGORY_DATACOMPRESSOR), L"DataCompressor"},
    {STATICGUIDOF(KSCATEGORY_DATADECOMPRESSOR), L"DataDecompressor"},
    {STATICGUIDOF(KSCATEGORY_DATATRANSFORM), L"DataTransform"},
    {STATICGUIDOF(KSCATEGORY_COMMUNICATIONSTRANSFORM), L"CommunicationTransform"},
    {STATICGUIDOF(KSCATEGORY_INTERFACETRANSFORM), L"InterfaceTransform"},
    {STATICGUIDOF(KSCATEGORY_MEDIUMTRANSFORM), L"MediumTransform"},
    {STATICGUIDOF(KSCATEGORY_FILESYSTEM), L"FileSystem"},
    {STATICGUIDOF(KSCATEGORY_AUDIO), L"Audio"},
    {STATICGUIDOF(KSCATEGORY_VIDEO), L"Video"},
    {STATICGUIDOF(KSCATEGORY_TEXT), L"Text"},
    {STATICGUIDOF(KSCATEGORY_CLOCK), L"Clock"},
    {STATICGUIDOF(KSCATEGORY_PROXY), L"Proxy"},
    {STATICGUIDOF(KSCATEGORY_QUALITY), L"Quality"},
    {STATICGUIDOF(KSNAME_Server), L"Server"},
    {STATICGUIDOF(PMPORT_Transform), L"TransformPort"},
	{STATICGUIDOF(KSCATEGORY_TOPOLOGY), L"Topology"}
};


BOOL TranslateClass(
    IN WCHAR*   ClassString,
    OUT GUID*   ClassGuid
)
{
    if (*ClassString == '{') {
        if (!CLSIDFromString(ClassString, ClassGuid)) {
            return TRUE;
        }
        printf("error: invalid class guid: \"%S\".\n", ClassString);
    } else {
        int     i;

        for (i = SIZEOF_ARRAY(TextTranslation); i--;) {
            if (!_wcsicmp(ClassString, TextTranslation[i].TextName)) {
                *ClassGuid = TextTranslation[i].ClassGuid;
                return TRUE;
            }
        }
        printf("error: invalid class name: \"%S\".\n\tPossible name:\n", ClassString);
        for (i = SIZEOF_ARRAY(TextTranslation); i--;) {
            printf("\t\t\"%S\"\n", TextTranslation[i].TextName);
        }
    }
    return FALSE;
}


int
_cdecl
main(
    int argc,
    char* argv[],
    char* envp[]
    )
{
    int                         i;
    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetails;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    BYTE                        Storage[ 256 * sizeof( WCHAR ) + 
                                    sizeof( *DeviceInterfaceDetails ) ];
    HANDLE                      FilterHandle;
    HDEVINFO                    Set;
    GUID                        ClassGuid;
    DWORD                       Error;

    if (argc != 2) {
        printf("%s {class Guid}\n", argv[0]);
        return 0;
    }
    MultiByteToWideChar(
        CP_ACP, 
        MB_PRECOMPOSED, 
        argv[1], 
        -1, 
        (WCHAR*)Storage, 
        sizeof(Storage));
    if (!TranslateClass((WCHAR*)Storage, &ClassGuid)) {
        return 0;
    }
    Set = SetupDiGetClassDevs( 
        &ClassGuid,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if (!Set) {
        printf( "error: NULL set returned (%u).\n", GetLastError());
        return 0;
    }       

    DeviceInterfaceData.cbSize = sizeof( DeviceInterfaceData );
    DeviceInterfaceDetails = (PSP_DEVICE_INTERFACE_DETAIL_DATA) Storage;

    for (i = 0; 
         SetupDiEnumDeviceInterfaces(
            Set,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            &ClassGuid,
            i,                          // DWORD MemberIndex
            &DeviceInterfaceData );
         i++) { 
        HKEY    DeviceKey;

        DeviceInterfaceDetails->cbSize = sizeof( *DeviceInterfaceDetails );
        if (!SetupDiGetDeviceInterfaceDetail(
            Set,
            &DeviceInterfaceData,
            DeviceInterfaceDetails,
            sizeof( Storage ),
            NULL,                           // PDWORD RequiredSize
            NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

            printf( 
                "error: unable to retrieve device details for set item %d (%u).\n",
                i, GetLastError() );
            continue;
        }

        printf("#%u: \"%S\"\n", i, DeviceInterfaceDetails->DevicePath);

        DeviceKey = SetupDiOpenDeviceInterfaceRegKey(Set, &DeviceInterfaceData, 0, KEY_READ);
        if (DeviceKey != INVALID_HANDLE_VALUE) {
            RegCloseKey(DeviceKey);
        } else {
            printf("\tfailed to open device interface key (%u)\n", GetLastError());
        }

        FilterHandle = CreateFile(
            DeviceInterfaceDetails->DevicePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL);

        if (FilterHandle == INVALID_HANDLE_VALUE) {
            printf("\tfailed to open device (%u)\n", GetLastError());
        } else {
            CloseHandle(FilterHandle);
        }

    }

    Error = GetLastError();
    if (Error && (Error != ERROR_NO_MORE_ITEMS)) {
        printf("Completed set with error (%u)\n", Error);
    }
    SetupDiDestroyDeviceInfoList(Set);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\streamci\streamci.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    streamci.c

Abstract:

    This module implements the streaming class device installer
    extensions.

Author:

    Bryan A. Woodruff (bryanw) 21-Apr-1997

--*/

#include <windows.h>
#include <devioctl.h>
#include <objbase.h>
#include <setupapi.h>
#ifdef UNICODE
#include <spapip.h>  // for DIF_INTERFACE_TO_DEVICE
#endif

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <ksguid.h>
#include <swenum.h>
#include <string.h>

#define DEBUG_INIT
#include "streamci.h"
#include "debug.h"

#define COMMAND_LINE_SEPARATORS_STRING L",\t\""
#define GUID_STRING_LENGTH 39

#if defined( UNICODE )
#define DEVICE_INSTANCE_STRING_FORMAT L"%s\\%s\\%s"
#else
#define DEVICE_INSTANCE_STRING_FORMAT "%S\\%S\\%S"
#endif

HRESULT
PerformDeviceIo(
    HANDLE DeviceHandle,
    ULONG IoControl,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG BytesReturned

    )
{
    BOOL        Result;
    HRESULT     hr;
    OVERLAPPED  Overlapped;

    RtlZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    if (NULL == (Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL))) {
        hr = GetLastError();
        return HRESULT_FROM_WIN32( hr );
    }

    Result =
        DeviceIoControl(
            DeviceHandle,
            IoControl,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength,
            BytesReturned,
            &Overlapped);

    if (!Result && (ERROR_IO_PENDING == GetLastError())) {
        Result =
            GetOverlappedResult(
                DeviceHandle,
                &Overlapped,
                BytesReturned,
                TRUE );
    }


    if (Result) {
        hr = S_OK;
    } else {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32( hr );
    }

    CloseHandle( Overlapped.hEvent );

    return hr;

}


HRESULT
InstallSoftwareDeviceInterface(
    REFGUID BusInterfaceGUID,
    PSWENUM_INSTALL_INTERFACE InstallInterface,
    ULONG InstallInterfaceSize
    )
{

    BOOL                                Result, IoResult;
    HANDLE                              BusEnumHandle;
    HDEVINFO                            Set;
    HRESULT                             hr;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    InterfaceDeviceDetails;
    PWCHAR                              BusIdentifier=NULL;
    SP_INTERFACE_DEVICE_DATA            InterfaceDeviceData;
    ULONG                               InterfaceDeviceDetailsSize, BytesReturned;

    hr = E_FAIL;

    Set = SetupDiGetClassDevs(
        BusInterfaceGUID,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_INTERFACEDEVICE );

    if (!Set) {
        hr = GetLastError();
        return HRESULT_FROM_WIN32( hr );
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("InstallSoftwareDeviceInterface() retrieved interface set") );

    InterfaceDeviceDetailsSize  =
        _MAX_PATH * sizeof( TCHAR ) +  sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    InterfaceDeviceDetails =
        HeapAlloc(
            GetProcessHeap(),
            0,
            InterfaceDeviceDetailsSize );

    if (NULL == InterfaceDeviceDetails) {
        SetupDiDestroyDeviceInfoList(Set);
        return E_OUTOFMEMORY;
    }

    InterfaceDeviceData.cbSize = sizeof( SP_INTERFACE_DEVICE_DATA );
    InterfaceDeviceDetails->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    if (SetupDiEnumInterfaceDevice(
            Set,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            BusInterfaceGUID,
            0,                          // DWORD MemberIndex
            &InterfaceDeviceData )) {

        if (SetupDiGetInterfaceDeviceDetail(
            Set,
            &InterfaceDeviceData,
            InterfaceDeviceDetails,
            InterfaceDeviceDetailsSize,
            NULL,                           // PDWORD RequiredSize
            NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

            BusEnumHandle = CreateFile(
                InterfaceDeviceDetails->DevicePath,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                NULL);

            if (INVALID_HANDLE_VALUE != BusEnumHandle) {
                //
                // Issue the install interface IOCTL.
                //

                hr =
                    PerformDeviceIo(
                        BusEnumHandle,
                        IOCTL_SWENUM_INSTALL_INTERFACE,
                        InstallInterface,
                        InstallInterfaceSize,
                        NULL,
                        0,
                        &BytesReturned );
            }
        }
    }

    if (SUCCEEDED( hr )) {

        _DbgPrintF( DEBUGLVL_VERBOSE, ("added interface via bus enumerator") );

        hr =
            PerformDeviceIo(
                BusEnumHandle,
                IOCTL_SWENUM_GET_BUS_ID,
                NULL,
                0,
                NULL,
                0,
                &BytesReturned );

        if (hr == HRESULT_FROM_WIN32( ERROR_MORE_DATA )) {
            BusIdentifier =
                HeapAlloc(
                    GetProcessHeap(),
                    0,
                    BytesReturned );

            //
            // The error condition case has ERROR_MORE_DATA already set and
            // will be reset below to match the HeapAlloc() failure.
            //

            if (BusIdentifier) {
                hr =
                    PerformDeviceIo(
                        BusEnumHandle,
                        IOCTL_SWENUM_GET_BUS_ID,
                        NULL,
                        0,
                        BusIdentifier,
                        BytesReturned,
                        &BytesReturned );
            }
        }
    }

    if (INVALID_HANDLE_VALUE != BusEnumHandle) {
        CloseHandle( BusEnumHandle );
    }

    if (BusIdentifier) {
        HeapFree( GetProcessHeap(), 0, BusIdentifier );
    }
    HeapFree( GetProcessHeap(), 0, InterfaceDeviceDetails );
    SetupDiDestroyDeviceInfoList(Set);


    return hr;
}

HRESULT
RemoveSoftwareDeviceInterface(
    REFGUID BusInterfaceGUID,
    PSWENUM_INSTALL_INTERFACE InstallInterface,
    ULONG InstallInterfaceSize
    )
{

    BOOL                                Result, IoResult;
    HANDLE                              BusEnumHandle;
    HDEVINFO                            Set;
    HRESULT                             hr;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    InterfaceDeviceDetails;
    PWCHAR                              BusIdentifier=NULL;
    SP_INTERFACE_DEVICE_DATA            InterfaceDeviceData;
    ULONG                               InterfaceDeviceDetailsSize, BytesReturned;

    hr = E_FAIL;

    Set = SetupDiGetClassDevs(
        BusInterfaceGUID,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_INTERFACEDEVICE );

    if (!Set) {
        hr = GetLastError();
        return HRESULT_FROM_WIN32( hr );
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("RemoveSoftwareDeviceInterface() retrieved interface set") );

    InterfaceDeviceDetailsSize  =
        _MAX_PATH * sizeof( TCHAR ) +  sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    InterfaceDeviceDetails =
        HeapAlloc(
            GetProcessHeap(),
            0,
            InterfaceDeviceDetailsSize );

    if (NULL == InterfaceDeviceDetails) {
        SetupDiDestroyDeviceInfoList(Set);
        return E_OUTOFMEMORY;
    }

    InterfaceDeviceData.cbSize = sizeof( SP_INTERFACE_DEVICE_DATA );
    InterfaceDeviceDetails->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    if (SetupDiEnumInterfaceDevice(
            Set,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            BusInterfaceGUID,
            0,                          // DWORD MemberIndex
            &InterfaceDeviceData )) {

        if (SetupDiGetInterfaceDeviceDetail(
            Set,
            &InterfaceDeviceData,
            InterfaceDeviceDetails,
            InterfaceDeviceDetailsSize,
            NULL,                           // PDWORD RequiredSize
            NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

            BusEnumHandle = CreateFile(
                InterfaceDeviceDetails->DevicePath,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                NULL);

            if (INVALID_HANDLE_VALUE != BusEnumHandle) {
                //
                // Issue the remove interface IOCTL.
                //

                hr =
                    PerformDeviceIo(
                        BusEnumHandle,
                        IOCTL_SWENUM_REMOVE_INTERFACE,
                        InstallInterface,
                        InstallInterfaceSize,
                        NULL,
                        0,
                        &BytesReturned );
            }
        }
    }

    if (SUCCEEDED( hr )) {

        _DbgPrintF( DEBUGLVL_VERBOSE, ("removed interface via bus enumerator") );

        hr =
            PerformDeviceIo(
                BusEnumHandle,
                IOCTL_SWENUM_GET_BUS_ID,
                NULL,
                0,
                NULL,
                0,
                &BytesReturned );

        if (hr == HRESULT_FROM_WIN32( ERROR_MORE_DATA )) {
            BusIdentifier =
                HeapAlloc(
                    GetProcessHeap(),
                    0,
                    BytesReturned );

            //
            // The error condition case has ERROR_MORE_DATA already set and
            // will be reset below to match the HeapAlloc() failure.
            //

            if (BusIdentifier) {
                hr =
                    PerformDeviceIo(
                        BusEnumHandle,
                        IOCTL_SWENUM_GET_BUS_ID,
                        NULL,
                        0,
                        BusIdentifier,
                        BytesReturned,
                        &BytesReturned );
            }
        }
    }

    if (INVALID_HANDLE_VALUE != BusEnumHandle) {
        CloseHandle( BusEnumHandle );
    }

    if (BusIdentifier) {
        HeapFree( GetProcessHeap(), 0, BusIdentifier );
    }
    HeapFree( GetProcessHeap(), 0, InterfaceDeviceDetails );
    SetupDiDestroyDeviceInfoList(Set);


    return hr;
}

#if !defined( UNICODE )
LPWSTR ReallyCharLowerW(
    LPWSTR String
    )

/*++

Routine Description:
    CharLowerW() is a nop under Windows 95/Memphis. This function does
    what it is supposed to do, performs an inplace towlower of the entire
    string.

Arguments:
    LPWSTR String -
        pointer to string

Return:
    The String pointer.

--*/

{
    LPWSTR RetVal = String;
    while (*String) {
        *String++ = towlower( *String );
    }
    return RetVal;
}
#else
#define ReallyCharLowerW CharLowerW
#endif

HRESULT
InstallInterfaceInfSection(
    IN PSWENUM_INSTALL_INTERFACE InstallInterface,
    IN PWSTR InfPath,
    IN PWSTR InfSection
    )
{
    int                                 i;
    HDEVINFO                            Set;
    HRESULT                             hr;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    InterfaceDeviceDetails;
    PWSTR                               DevicePath;
    SP_INTERFACE_DEVICE_DATA            InterfaceDeviceData;
    SP_DEVINFO_DATA                     DeviceInfo;
    ULONG                               InterfaceDeviceDetailsSize;
    WCHAR                               DeviceIdString[ GUID_STRING_LENGTH ];
#if !defined( UNICODE )
    WCHAR                               PathStorage[ _MAX_PATH + _MAX_FNAME ];
#endif

    hr = E_FAIL;

    Set = SetupDiGetClassDevs(
        &InstallInterface->InterfaceId,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_INTERFACEDEVICE );

    if (!Set) {
        hr = GetLastError();
        return HRESULT_FROM_WIN32( hr );
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("InstallInterfaceInfSection() retrieved interface set") );

    InterfaceDeviceDetailsSize  =
        (_MAX_PATH + _MAX_FNAME) * sizeof( TCHAR ) +
            sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    InterfaceDeviceDetails =
        HeapAlloc(
            GetProcessHeap(),
            0,
            InterfaceDeviceDetailsSize );

    if (NULL == InterfaceDeviceDetails) {
        SetupDiDestroyDeviceInfoList(Set);
        return E_OUTOFMEMORY;
    }

    i = 0;

    StringFromGUID2(
        &InstallInterface->DeviceId,
        DeviceIdString,
        GUID_STRING_LENGTH );

    while (
        InterfaceDeviceData.cbSize = sizeof( InterfaceDeviceData ),
        SetupDiEnumInterfaceDevice(
            Set,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            &InstallInterface->InterfaceId,
            i++,                        // DWORD MemberIndex
            &InterfaceDeviceData )) {

        InterfaceDeviceDetails->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );
        DeviceInfo.cbSize = sizeof( DeviceInfo );
        if (SetupDiGetInterfaceDeviceDetail(
                Set,
                &InterfaceDeviceData,
                InterfaceDeviceDetails,
                InterfaceDeviceDetailsSize,
                NULL,               // OUT PDWORD RequiredSize
                &DeviceInfo )) {    // OUT PSP_DEVINFO_DATA DevInfoData

            //
            // Note that by definition (and calling convention), the
            // reference string must be contained in the device path.
            //

#if !defined( UNICODE )
            MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                InterfaceDeviceDetails->DevicePath,
                -1,
                (WCHAR*) PathStorage,
                sizeof( PathStorage )/sizeof(WCHAR));
            DevicePath = PathStorage;
#else
            DevicePath = InterfaceDeviceDetails->DevicePath;
#endif
            ReallyCharLowerW( DevicePath );
            ReallyCharLowerW( InstallInterface->ReferenceString );
            ReallyCharLowerW( DeviceIdString );

            _DbgPrintF(
                DEBUGLVL_BLAB,
                ("scanning for: %S & %S & %S",
                DevicePath,
                DeviceIdString,
                InstallInterface->ReferenceString) );

            if (wcsstr(
                    DevicePath,
                    DeviceIdString ) &&
                wcsstr(
                    DevicePath,
                    InstallInterface->ReferenceString )) {

                _DbgPrintF( DEBUGLVL_BLAB, ("found match") );
                hr = S_OK;
                break;
            }
        }
    }

    //
    // The enumeration will return ERROR_NO_MORE_ITEMS if the end of the
    // set is reached.  Otherwise, it will break with hr = S_OK and the
    // interface device details will point to the matching device.
    //

    if (SUCCEEDED( hr )) {

        if (InfPath) {
            HINF    InterfaceInf;
            HKEY    InterfaceKey;
            PTSTR   InfSectionT, InfPathT;
#if !defined( UNICODE )
            char    InfPathA[ _MAX_PATH ];
            char    InfSectionA[ _MAX_PATH ];
#endif
            hr = E_FAIL;

#if defined( UNICODE )
            InfPathT = InfPath;
            _DbgPrintF( DEBUGLVL_VERBOSE, ("opening .INF = %S", InfPathT) );
#else
            WideCharToMultiByte(
                0,
                0,
                InfPath,
                -1,
                InfPathA,
                sizeof( InfPathA ),
                NULL,
                NULL );
            InfPathT = InfPathA;
            _DbgPrintF( DEBUGLVL_VERBOSE, ("opening .INF = %s", InfPathT) );
#endif

            InterfaceInf =
                SetupOpenInfFile(
                    InfPathT,
                    NULL,
                    INF_STYLE_WIN4,
                    NULL);

            if (INVALID_HANDLE_VALUE != InterfaceInf) {
                _DbgPrintF( DEBUGLVL_BLAB, ("creating interface registry key") );

#if defined( UNICODE )
                InfSectionT = InfSection;
#else
                WideCharToMultiByte(
                    0,
                    0,
                    InfSection,
                    -1,
                    InfSectionA,
                    sizeof( InfSectionA ),
                    NULL,
                    NULL );
                InfSectionT = InfSectionA;
#endif

                InterfaceKey =
                    SetupDiCreateInterfaceDeviceRegKey(
                        Set,
                        &InterfaceDeviceData,
                        0,                      // IN DWORD Reserved
                        KEY_ALL_ACCESS,
                        InterfaceInf,
                        InfSectionT );

                if (INVALID_HANDLE_VALUE != InterfaceKey) {
                    RegCloseKey( InterfaceKey );
                    hr = S_OK;
                }
                SetupCloseInfFile( InterfaceInf );
            }
            if (SUCCEEDED( hr )) {
                _DbgPrintF(
                    DEBUGLVL_VERBOSE,
                    ("successfully installed .INF section") );
            }
        }
    } else {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("failed to retrieve interface (DeviceID: %S, RefString: %S)",
            DeviceIdString,
            InstallInterface->ReferenceString) );
    }

    if (SUCCEEDED( hr )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("successful install of software device.") );
    } else {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32( hr );
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("return from InstallInterfaceInfSection=%x.", hr) );

    HeapFree( GetProcessHeap(), 0, InterfaceDeviceDetails );
    SetupDiDestroyDeviceInfoList(Set);

    return hr;
}



HRESULT
RemoveInterface(
    IN PSWENUM_INSTALL_INTERFACE InstallInterface
    )
{
    int                                 i;
    HDEVINFO                            Set;
    HRESULT                             hr;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    InterfaceDeviceDetails;
    PWSTR                               DevicePath;
    SP_INTERFACE_DEVICE_DATA            InterfaceDeviceData;
    SP_DEVINFO_DATA                     DeviceInfo;
    ULONG                               InterfaceDeviceDetailsSize;
    WCHAR                               DeviceIdString[ GUID_STRING_LENGTH ];
#if !defined( UNICODE )
    WCHAR                               PathStorage[ _MAX_PATH + _MAX_FNAME ];
#endif

    hr = E_FAIL;

    Set = SetupDiGetClassDevs(
        &InstallInterface->InterfaceId,
        NULL,
        NULL,
        DIGCF_INTERFACEDEVICE ); // not DIGCF_PRESENT

    if (!Set) {
        hr = GetLastError();
        return HRESULT_FROM_WIN32( hr );
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("RemoveInterface() retrieved interface set") );

    InterfaceDeviceDetailsSize  =
        (_MAX_PATH + _MAX_FNAME) * sizeof( TCHAR ) +
            sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    InterfaceDeviceDetails =
        HeapAlloc(
            GetProcessHeap(),
            0,
            InterfaceDeviceDetailsSize );

    if (NULL == InterfaceDeviceDetails) {
        SetupDiDestroyDeviceInfoList(Set);
        return E_OUTOFMEMORY;
    }

    i = 0;

    StringFromGUID2(
        &InstallInterface->DeviceId,
        DeviceIdString,
        GUID_STRING_LENGTH );

    while (
        InterfaceDeviceData.cbSize = sizeof( InterfaceDeviceData ),
        SetupDiEnumInterfaceDevice(
            Set,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            &InstallInterface->InterfaceId,
            i++,                        // DWORD MemberIndex
            &InterfaceDeviceData )) {

        InterfaceDeviceDetails->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );
        DeviceInfo.cbSize = sizeof( DeviceInfo );
        if (SetupDiGetInterfaceDeviceDetail(
                Set,
                &InterfaceDeviceData,
                InterfaceDeviceDetails,
                InterfaceDeviceDetailsSize,
                NULL,               // OUT PDWORD RequiredSize
                &DeviceInfo )) {    // OUT PSP_DEVINFO_DATA DevInfoData

            //
            // Note that by definition (and calling convention), the
            // reference string must be contained in the device path.
            //

#if !defined( UNICODE )
            MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                InterfaceDeviceDetails->DevicePath,
                -1,
                (WCHAR*) PathStorage,
                sizeof( PathStorage ) /sizeof(WCHAR));
            DevicePath = PathStorage;
#else
            DevicePath = InterfaceDeviceDetails->DevicePath;
#endif
            ReallyCharLowerW( DevicePath );
            ReallyCharLowerW( InstallInterface->ReferenceString );
            ReallyCharLowerW( DeviceIdString );

            _DbgPrintF(
                DEBUGLVL_BLAB,
                ("scanning for: %S & %S & %S",
                DevicePath,
                DeviceIdString,
                InstallInterface->ReferenceString) );

            if (wcsstr(
                    DevicePath,
                    DeviceIdString ) &&
                wcsstr(
                    DevicePath,
                    InstallInterface->ReferenceString )) {

                _DbgPrintF( DEBUGLVL_BLAB, ("found match") );
                hr = S_OK;
                break;
            }
        }
    }

    //
    // The enumeration will return ERROR_NO_MORE_ITEMS if the end of the
    // set is reached.  Otherwise, it will break with hr = S_OK and the
    // interface device details will point to the matching device.
    //

    if (SUCCEEDED( hr )) {

        //
        // Remove the device interface registry keys.
        //

        if (!SetupDiRemoveDeviceInterface(
                 Set,
                 &InterfaceDeviceData )) {
            _DbgPrintF(
                DEBUGLVL_TERSE,
                ("failed to remove interface (DeviceID: %S, RefString: %S)",
                DeviceIdString,
                InstallInterface->ReferenceString) );
            hr = E_FAIL;
        }

    } else {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("failed to retrieve interface (DeviceID: %S, RefString: %S)",
            DeviceIdString,
            InstallInterface->ReferenceString) );
    }

    if (SUCCEEDED( hr )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("successful removal of software device.") );
    } else {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32( hr );
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("return from RemoveInterface=%x.", hr) );

    HeapFree( GetProcessHeap(), 0, InterfaceDeviceDetails );
    SetupDiDestroyDeviceInfoList(Set);

    return hr;
}


#if defined( UNICODE )
//
// ANSI version
//
VOID
WINAPI
StreamingDeviceSetupA(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR CommandLine,
    IN INT ShowCommand
    )
#else
//
// Unicode version
//
VOID
WINAPI
StreamingDeviceSetupW(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR CommandLine,
    IN INT ShowCommand
    )
#endif
{
    UNREFERENCED_PARAMETER( Window );
    UNREFERENCED_PARAMETER( ModuleHandle );
    UNREFERENCED_PARAMETER( CommandLine );
    UNREFERENCED_PARAMETER( ShowCommand );
}


VOID
WINAPI
StreamingDeviceSetup(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN LPCTSTR CommandLine,
    IN INT ShowCommand
    )
{

    GUID                        BusInterfaceGUID;
    HRESULT                     hr;
    PWCHAR                      TokenPtr,
                                InstallInf,
                                InstallSection,
                                ReferenceString;
    PSWENUM_INSTALL_INTERFACE   InstallInterface;
    ULONG                       InstallInterfaceSize, StorageLength;
    PWCHAR                      Storage;

    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(ShowCommand);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("StreamingDeviceSetup()") );

    //
    // Process the command line.
    //

#if defined( UNICODE )
    StorageLength = (wcslen( CommandLine ) + 1) * sizeof( WCHAR );
    Storage = HeapAlloc( GetProcessHeap(), 0, StorageLength );

    if (NULL == Storage) {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("failed to allocate heap memory for command line") );
        return;
    }
    wcscpy( Storage, CommandLine );
    TokenPtr = (PWSTR) Storage;
#else
    StorageLength = (strlen( CommandLine ) + 1) * sizeof( WCHAR );
    Storage = HeapAlloc( GetProcessHeap(), 0, StorageLength );

    if (NULL == Storage) {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("failed to allocate heap memory for command line") );
        return;
    }

    MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        CommandLine,
        -1,
        (WCHAR*) Storage,
        StorageLength);
    TokenPtr = Storage;
#endif
    hr = S_OK;
    InstallInterface = NULL;
    InstallInf = NULL;
    InstallSection = NULL;
    BusInterfaceGUID = BUSID_SoftwareDeviceEnumerator;

    try {
        InstallInterfaceSize =
            sizeof( SWENUM_INSTALL_INTERFACE ) +
                (wcslen( TokenPtr ) - GUID_STRING_LENGTH * 2) *
                    sizeof( WCHAR ) +
                        sizeof( UNICODE_NULL );

        InstallInterface =
            HeapAlloc(
                GetProcessHeap(),
                0,  // IN DWORD dwFlags
                InstallInterfaceSize );
        if (!InstallInterface) {
            hr = E_OUTOFMEMORY;
        }

        //
        // The command line has the form:
        //
        // {Device ID},reference-string,{Interface ID},install-inf,install-section,{bus interface ID}
        //

        //
        // Parse the device ID
        //

        if (SUCCEEDED( hr )) {
            if (TokenPtr = wcstok( TokenPtr, COMMAND_LINE_SEPARATORS_STRING )) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("device id: %S", TokenPtr) );
                hr = IIDFromString( TokenPtr, &InstallInterface->DeviceId );
            } else {
                hr = E_FAIL;
            }
        }

        //
        // Parse the reference string
        //

        if (SUCCEEDED( hr )) {
            if (NULL ==
                    (TokenPtr =
                        wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING ))) {
                hr = E_FAIL;
            } else {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("reference: %S", TokenPtr) );
                wcscpy( InstallInterface->ReferenceString, TokenPtr );
            }
        }

        //
        // Parse the interface ID
        //

        if (SUCCEEDED( hr )) {
            if (TokenPtr = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING )) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("interface: %S", TokenPtr) );
                hr = IIDFromString( TokenPtr, &InstallInterface->InterfaceId );
            } else {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED( hr )) {

            //
            // parse the install .INF name
            //

            InstallInf = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING );

            //
            // The install section is the remaining portion of the string
            // (minus the token separators).
            //

            if (InstallInf) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("found install .INF: %S", InstallInf) );
                InstallSection = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING );
                if (InstallSection) {
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("found install section: %S", InstallSection) );
                }

                if (TokenPtr = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING )) {

                    _DbgPrintF( DEBUGLVL_VERBOSE, ("found interface ID: %S", TokenPtr) );

                    hr = IIDFromString( TokenPtr, &BusInterfaceGUID );
                }
            }

        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        //
        // Translate NT status (exception code) to HRESULT.
        //
        hr = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if (SUCCEEDED( hr )) {
        hr =
            InstallSoftwareDeviceInterface(
                &BusInterfaceGUID,
                InstallInterface,
                FIELD_OFFSET( SWENUM_INSTALL_INTERFACE, ReferenceString ) +
                    (wcslen( InstallInterface->ReferenceString ) + 1) *
                        sizeof( WCHAR ) );

        if (SUCCEEDED( hr )) {
            hr =
                InstallInterfaceInfSection(
                    InstallInterface,
                    InstallInf,
                    InstallSection );
        }
    }

    if (FAILED( hr )) {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("StreamingDeviceSetup failed: %08x", hr) );
    }

    if (InstallInterface) {
        HeapFree( GetProcessHeap(), 0, InstallInterface);
    }

    HeapFree( GetProcessHeap(), 0, Storage );
}

#if defined( UNICODE )
//
// ANSI version
//
VOID
WINAPI
StreamingDeviceRemoveA(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR CommandLine,
    IN INT ShowCommand
    )
#else
//
// Unicode version
//
VOID
WINAPI
StreamingDeviceRemoveW(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR CommandLine,
    IN INT ShowCommand
    )
#endif
{
    UNREFERENCED_PARAMETER( Window );
    UNREFERENCED_PARAMETER( ModuleHandle );
    UNREFERENCED_PARAMETER( CommandLine );
    UNREFERENCED_PARAMETER( ShowCommand );
}


VOID
WINAPI
StreamingDeviceRemove(
    IN HWND Window,
    IN HINSTANCE ModuleHandle,
    IN LPCTSTR CommandLine,
    IN INT ShowCommand
    )
{

    GUID                        BusInterfaceGUID;
    HRESULT                     hr;
    PWCHAR                      TokenPtr,
                                InstallInf,
                                InstallSection,
                                ReferenceString;
    PSWENUM_INSTALL_INTERFACE   InstallInterface;
    ULONG                       InstallInterfaceSize, StorageLength;
    PWCHAR                      Storage;

    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(ShowCommand);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("StreamingDeviceSetup()") );

    //
    // Process the command line.
    //

#if defined( UNICODE )
    StorageLength = (wcslen( CommandLine ) + 1) * sizeof( WCHAR );
    Storage = HeapAlloc( GetProcessHeap(), 0, StorageLength );

    if (NULL == Storage) {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("failed to allocate heap memory for command line") );
        return;
    }
    wcscpy( Storage, CommandLine );
    TokenPtr = (PWSTR) Storage;
#else
    StorageLength = (strlen( CommandLine ) + 1) * sizeof( WCHAR );
    Storage = HeapAlloc( GetProcessHeap(), 0, StorageLength );

    if (NULL == Storage) {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("failed to allocate heap memory for command line") );
        return;
    }

    MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        CommandLine,
        -1,
        (WCHAR*) Storage,
        StorageLength);
    TokenPtr = Storage;
#endif
    hr = S_OK;
    InstallInterface = NULL;
    InstallInf = NULL;
    InstallSection = NULL;
    BusInterfaceGUID = BUSID_SoftwareDeviceEnumerator;

    try {
        InstallInterfaceSize =
            sizeof( SWENUM_INSTALL_INTERFACE ) +
                (wcslen( TokenPtr ) - GUID_STRING_LENGTH * 2) *
                    sizeof( WCHAR ) +
                        sizeof( UNICODE_NULL );

        InstallInterface =
            HeapAlloc(
                GetProcessHeap(),
                0,  // IN DWORD dwFlags
                InstallInterfaceSize );
        if (!InstallInterface) {
            hr = E_OUTOFMEMORY;
        }

        //
        // The command line has the form:
        //
        // {Device ID},reference-string,{Interface ID},install-inf,install-section,{bus interface ID}
        //

        //
        // Parse the device ID
        //

        if (SUCCEEDED( hr )) {
            if (TokenPtr = wcstok( TokenPtr, COMMAND_LINE_SEPARATORS_STRING )) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("device id: %S", TokenPtr) );
                hr = IIDFromString( TokenPtr, &InstallInterface->DeviceId );
            } else {
                hr = E_FAIL;
            }
        }

        //
        // Parse the reference string
        //

        if (SUCCEEDED( hr )) {
            if (NULL ==
                    (TokenPtr =
                        wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING ))) {
                hr = E_FAIL;
            } else {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("reference: %S", TokenPtr) );
                wcscpy( InstallInterface->ReferenceString, TokenPtr );
            }
        }

        //
        // Parse the interface ID
        //

        if (SUCCEEDED( hr )) {
            if (TokenPtr = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING )) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("interface: %S", TokenPtr) );
                hr = IIDFromString( TokenPtr, &InstallInterface->InterfaceId );
            } else {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED( hr )) {

            //
            // parse the install .INF name
            //

            InstallInf = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING );

            //
            // The install section is the remaining portion of the string
            // (minus the token separators).
            //

            if (InstallInf) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("found install .INF: %S", InstallInf) );
                InstallSection = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING );
                if (InstallSection) {
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("found install section: %S", InstallSection) );
                }

                if (TokenPtr = wcstok( NULL, COMMAND_LINE_SEPARATORS_STRING )) {

                    _DbgPrintF( DEBUGLVL_VERBOSE, ("found interface ID: %S", TokenPtr) );

                    hr = IIDFromString( TokenPtr, &BusInterfaceGUID );
                }
            }

        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        //
        // Translate NT status (exception code) to HRESULT.
        //
        hr = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if (SUCCEEDED( hr )) {
        hr =
            RemoveSoftwareDeviceInterface(
                &BusInterfaceGUID,
                InstallInterface,
                FIELD_OFFSET( SWENUM_INSTALL_INTERFACE, ReferenceString ) +
                    (wcslen( InstallInterface->ReferenceString ) + 1) *
                        sizeof( WCHAR ) );

        if (SUCCEEDED( hr )) {
            hr =
                RemoveInterface(
                    InstallInterface );
        }
    }

    if (FAILED( hr )) {
        _DbgPrintF(
            DEBUGLVL_TERSE,
            ("StreamingDeviceRemove failed: %08x", hr) );
    }

    if (InstallInterface) {
        HeapFree( GetProcessHeap(), 0, InstallInterface);
    }

    HeapFree( GetProcessHeap(), 0, Storage );
}

DWORD
StreamingDeviceClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for streaming devices.
    It provides special handling for the following DeviceInstaller
    function codes:

    DIF_INSTALLDEVICE -
        installs class interfaces for software devices if required

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    NO_ERROR -
        if no error occurs

    ERROR_DI_DO_DEFAULT -
        if the default behavior is to be performed for the requested
        action

    Win32 error code -
        if an error occurs while attempting to perform the requested action

--*/

{
    switch (InstallFunction) {

    case DIF_INSTALLDEVICE :

        if(!SetupDiInstallDevice( DeviceInfoSet, DeviceInfoData )) {
            return GetLastError();
        }

        return NO_ERROR;

    default :
        //
        // Just do the default action.
        //
        return ERROR_DI_DO_DEFAULT;

    }
}

#ifdef UNICODE
DWORD
SwEnumInterfaceToDevicePostProcessing(
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
{
    SP_INTERFACE_TO_DEVICE_PARAMS_W clsParams;

    int slashCount = 0;
    LPCWSTR RefPart = NULL;
    LPCWSTR InstBreak = NULL;
    LPWSTR DevInstBreak = NULL;
    int p;

    ZeroMemory(&clsParams,sizeof(clsParams));
    clsParams.ClassInstallHeader.cbSize = sizeof(clsParams.ClassInstallHeader);
    clsParams.ClassInstallHeader.InstallFunction = DIF_INTERFACE_TO_DEVICE;
    if(!SetupDiGetClassInstallParamsW(DeviceInfoSet,DeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&clsParams,
                                        sizeof(clsParams),
                                        NULL)) {
        //
        // we failed to retrieve parameters
        //
        return GetLastError();
    }

    //
    // Determine what device the interface describes really
    // if Context->InstallResult is NO_ERROR
    // we could take a look at what's in clsInParams
    // if we want
    //
    // For now, the processing is simple
    // in WinXP (this could change in future)
    // the symbolic link is \\?\device[\reference]
    // if we have 4 slashes, this is interesting
    //
    for(p=0;clsParams.Interface[p];p++) {
        if(clsParams.Interface[p] == L'\\') {
            slashCount++;
            if(slashCount>=4) {
                RefPart = clsParams.Interface+p+1;
            }
        }
    }
    if(!RefPart) {
        //
        // not special/recognized, leave as is
        //
        return Context->InstallResult;
    }
    //
    // we also expect to find a '&'
    //
    InstBreak = wcschr(RefPart,L'&');
    if(!InstBreak) {
        //
        // not special/recognized, leave as is
        //
        return Context->InstallResult;
    }
    if(((wcslen(RefPart)+4)*sizeof(WCHAR)) > sizeof(clsParams.DeviceId)) {
        //
        // not valid, leave as is
        //
        return Context->InstallResult;
    }
    wcscpy(clsParams.DeviceId,L"SW\\");
    wcscat(clsParams.DeviceId,RefPart);
    DevInstBreak = wcschr(clsParams.DeviceId,L'&'); // we know this will be non-null
    *DevInstBreak = L'\\';

    //
    // we know it's a different device, return that information
    //
    if(!SetupDiSetClassInstallParamsW(DeviceInfoSet,
                                        DeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER)&clsParams,
                                        sizeof(clsParams))) {
        //
        // failed to modify
        //
        return GetLastError();
    }
    return NO_ERROR;
}
#endif

DWORD __stdcall
SwEnumCoInstaller(
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )

/*++

Routine Description:

    This routine acts as the swenum co-installer to support
    DIF_INTERFACE_TO_DEVICE

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Information applicable only to co-installers

Return Value:

    NO_ERROR -
        if no error occurs and no post-processing to do

   ERROR_DI_POSTPROCESSING_REQUIRED -
        if no error occurs but post-processing to do

    Win32 error code -
        if an error occurs while attempting to perform the requested action

--*/

{
#ifdef UNICODE
    switch (InstallFunction) {

    case DIF_INTERFACE_TO_DEVICE :
        if (!Context->PostProcessing) {
            //
            // we need to do everything in post-processing
            //
            return ERROR_DI_POSTPROCESSING_REQUIRED;
        }
        if((Context->InstallResult != NO_ERROR) &&
           (Context->InstallResult != ERROR_DI_DO_DEFAULT)) {
            //
            // an error occurred, pass it on
            //
            return Context->InstallResult;
        }
        return SwEnumInterfaceToDevicePostProcessing(DeviceInfoSet,DeviceInfoData,Context);

    default :
        //
        // indicate no problems and that we're not interested in post-processing
        //
        return NO_ERROR;

    }

#else
    return NO_ERROR;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\memgr.h ===
//--------------------------------------------------------------------------;
//
//  File: MeMgr.h
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Header files for exact allocation stuff.
//
//  Contents:
//
//  History:
//      12/01/93    Fwong       Collecting into one place.
//
//       5/23/95    blakeb      #defines for C++ linkage
//--------------------------------------------------------------------------;

//==========================================================================;
//
//                          Prototypes...
//
//==========================================================================;

#ifndef _INC_MEMGR
#define _INC_MEMGR

#ifdef __cplusplus
extern "C" {
#endif

extern LPVOID ExactAllocPtr
(
    UINT    fuAlloc,
    DWORD   cbAlloc
);

extern BOOL ExactFreePtr
(
    LPVOID  pvoid
);

extern DWORD GetNumAllocations
(
    void
);

extern HGLOBAL GetMemoryHandle
(
    LPVOID  pvoid
);

extern DWORD ExactSize
(
    LPVOID  pvoid
);

extern LPVOID ExactReAllocPtr
(
    LPVOID  pOldPtr,
    DWORD   cbAlloc,
    UINT    fuAlloc
);

extern LPVOID ExactHeapAllocPtr
(
    HANDLE  hHeap,
    UINT    fuAlloc,
    DWORD   cbAlloc
);

extern HANDLE ExactHeapCreate
(
    DWORD   fdwFlags
);

extern BOOL ExactHeapDestroy
(
    HANDLE  hHeap
);

extern BOOL ExactHeapFreePtr
(
    HANDLE  hHeap,
    UINT    fuFree,
    LPVOID  pMemFree
);

extern LPVOID ExactHeapReAllocPtr
(
    HANDLE  hHeap,
    LPVOID  pOldPtr,
    DWORD   cbAlloc,
    UINT    fuAlloc
);

extern DWORD ExactHeapSize
(
    HANDLE  hHeap,
    UINT    fuSize,
    LPVOID  pMemSize
);

#ifdef __cplusplus
}
#endif  //__cplusplus

#endif  //_INC_MEMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\resmgr.h ===
//--------------------------------------------------------------------------;
//
//  File: ResMgr.h
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Header file for binary resource manager stuff.
//
//  Contents:
//
//  History:
//      04/11/94    Fwong       Created for easy storage of binaries.
//
//--------------------------------------------------------------------------;

//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

extern DWORD SizeofBinaryResource
(
    HINSTANCE   hinst,
    HRSRC       hrsrc
);

extern BOOL ResourceToFile
(
    HINSTANCE   hinst,
    HRSRC       hrsrc,
    LPCSTR      pszFileName
);

extern BOOL GetBinaryResource
(
    HINSTANCE   hinst,
    HRSRC       hrsrc,
    LPVOID      pBuffer
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\mmtstver.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       mmtstver.h
//
//--------------------------------------------------------------------------

/*
 *  mmtstver.h - internal header file to define the build version for sonic
 *
 */

/* 
 *  All strings MUST have an explicit \0  
 *
 *  MMSYSRELEASE should be changed every build
 *
 *  Version string should be changed each build
 *
 *  Remove build extension on final release
 */

#define OFFICIAL                1
#define FINAL                   1

#define MMSYSVERSION            04
#define MMSYSREVISION           00
#define MMSYSRELEASE            091

// This is to coincide with the internal MMSYSTEM_VERSION
#define MMTST_VERSION		0X0400


#if defined(DEBUG_RETAIL)
#define MMSYSVERSIONSTR         "Motown Retail Debug Version 4.00.0091\0"
#elif defined(DEBUG)
#define MMSYSVERSIONSTR         "Motown Internal Debug Version 4.00.0091\0"
#else
#define MMSYSVERSIONSTR         "4.00\0"
#endif


/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED

#define MMVERSIONCOMPANYNAME    "Microsoft Corporation\0"
#define MMVERSIONPRODUCTNAME    "Microsoft Windows\0"
#define MMVERSIONCOPYRIGHT      "Copyright \251 Microsoft Corp. 1991\0"

/*
 *  Version flags 
 */

#ifndef OFFICIAL
#define MMVER_PRIVATEBUILD      VS_FF_PRIVATEBUILD
#else
#define MMVER_PRIVATEBUILD      0
#endif

#ifndef FINAL
#define MMVER_PRERELEASE        VS_FF_PRERELEASE
#else
#define MMVER_PRERELEASE        0
#endif

#if defined(DEBUG_RETAIL)
#define MMVER_DEBUG             VS_FF_DEBUG    
#elif defined(DEBUG)
#define MMVER_DEBUG             VS_FF_DEBUG    
#else
#define MMVER_DEBUG             0
#endif

#define MMVERSIONFLAGS          (MMVER_PRIVATEBUILD|MMVER_PRERELEASE|MMVER_DEBUG)
#define MMVERSIONFILEFLAGSMASK  0x0000003FL


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\inimgr.h ===
//--------------------------------------------------------------------------;
//
//  File: IniMgr.h
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Header files for .ini file stuff.
//
//  Contents:
//
//  History:
//      01/26/94    Fwong       Making the .ini file stuff into a library
//
//--------------------------------------------------------------------------;

//==========================================================================;
//
//                         Portability Stuff...
//                      "Borrowed" from AppPort.h
//
//==========================================================================;

#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK
    #endif
#else
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNCALLBACK  FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNCALLBACK  FAR PASCAL _export
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif
#endif

#ifdef   UNICODE
#ifndef  _UNICODE
#define  _UNICODE
#endif
#endif

#ifndef _TCHAR_DEFINED
    #define _TCHAR_DEFINED
    typedef char            TCHAR, *PTCHAR;
    typedef unsigned char   TBYTE, *PTUCHAR;

    typedef PSTR            PTSTR, PTCH;
    typedef LPSTR           LPTSTR, LPTCH;
    typedef LPCSTR          LPCTSTR;
#endif

//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define MAXINISTR           144
#define LINE_LIMIT           25

//==========================================================================;
//
//                              Globals...
//
//==========================================================================;

extern TCHAR    gszMmregIni[];

//==========================================================================;
//
//                             Prototypes...
//
//==========================================================================;

extern BOOL FNGLOBAL InitIniFile
(
    HINSTANCE   hinst,
    LPTSTR      pszIniFileName
);

extern BOOL FNGLOBAL InitIniFile_FullPath
(
    LPTSTR  pszFullPath
);

extern void FNGLOBAL EndIniFile
(
    void
);

extern void FNGLOBAL GetApplicationDir
(
    HINSTANCE   hinst,
    LPTSTR      pszPath,
    UINT        uSize
);

extern BOOL FNGLOBAL GetRegInfo
(
    DWORD   dwEntry,
    LPCTSTR pszSection,
    LPTSTR  pszName,
    UINT    cbName,
    LPTSTR  pszDesc,
    UINT    cbDesc
);

extern DWORD FNGLOBAL HexValue
(
    TCHAR   chDigit
);

extern DWORD FNGLOBAL atoDW
(
    LPCTSTR pszNumber,
    DWORD   dwDefault
);

extern DWORD FNGLOBAL GetIniBinSize
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry
);

extern BOOL FNGLOBAL WriteIniString
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPCTSTR pszString
);

extern BOOL FNGLOBAL WriteIniDWORD
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    DWORD   dwValue
);

extern void FNGLOBAL WriteIniBin
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPVOID  pvoid,
    DWORD   cbSize
);

extern int FNGLOBAL GetIniString
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPTSTR  pszBuffer,
    int     cbReturnBuffer
);

extern DWORD FNGLOBAL GetIniDWORD
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    DWORD   dwDefault
);

extern BOOL FNGLOBAL GetIniBin
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPVOID  pvoid,
    DWORD   cbSize
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tslog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tslog.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tslog.h - Include file for logging code of test shell.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
void logCaseStatus(int, int, UINT, UINT);

void Logging(void);

void logDateTimeBuild(LPSTR);

void SetLogfileName(LPSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsdlg.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsdlg.h - The dialog box constants for test shell code.
|                                                                              
|   History:                                                                   
|   02/18/91 prestonb   Created from tst.c
----------------------------------------------------------------------------*/
/* Constants for test case seletion dialog */
#define TS_ALLLIST          100
#define TS_SELLIST          101

#define TS_SELECT           110
#define TS_SELECTALL        111
#define TS_REMOVE           112
#define TS_CLEARALL         113

#define TS_ADDGROUP         130
#define TS_INT_REQUIRED     131
#define TS_INT_OPTIONAL     132
#define TS_INT_NO           133
                            
#define TS_ALL              140
#define TS_SELECTED         141
#define TS_UNSELECTED       142
#define TS_SELEXPAND        143

#define TS_SELOK            150
#define TS_SELCANCEL        151

/* Constants for menu items */
#define MENU_NEW            200
#define MENU_LOAD           201
#define MENU_SAVE           202
#define MENU_SAVEAS         203
#define MENU_EXIT           204
#define MENU_SETPATHS       205
#define MENU_SELECT         206
#define MENU_RUN            207
#define MENU_RUNSETUP       208
#define MENU_LOGGING        209
#define MENU_RESETLOGFILE   210
#define MENU_RESETENVT      211
#define MENU_CLS            214
#define MENU_EDITOR         215
#define MENU_TOOLBAR        216
#define MENU_STATUSBAR      217
#define MENU_DEFPROF        218
#define MENU_HELPINDEX      219
#define MENU_ABOUT          220
#define MENU_COPY           221
#define MENU_FIND           222
#define MENU_FINDNEXT       223
#define MENU_FONT           224

/* Constants for logging dialog */
#define TS_LOGOUTGRP        300
#define TS_LOGLVLGRP        301
#define TSLOG_OFF           302
#define TSLOG_TERSE         303
#define TSLOG_VERBOSE       304

#define TSLOG_WINDOW        320
#define TSLOG_COM1          321

#define TS_FLOGGRP          330
#define TS_FLVLGRP          331
#define TSLOG_FOFF          332
#define TSLOG_FTERSE        333
#define TSLOG_FVERBOSE      334

#define TSLOG_OK            340
#define TSLOG_CANCEL        341

#define TS_MODEGRP          400
#define TSLOG_OVERWRITE     401
#define TSLOG_APPEND        402
#define TS_FILEHELP         403
#define TS_LOGFPRMPT        404
#define TS_LOGFILE          405

/* Constants for run setup dialog */
#define TS_RUNCOUNT         600
#define TS_AUTOMATIC        601
#define TS_MANUAL           602
#define TS_STEP             603
#define TS_RANDOM           604
#define TS_RSOK             605
#define TS_RSCANCEL         606   
#define TS_SSAVEREN         607
#define TS_SSAVERDIS        608

/* Constants for step mode dialog */
#define TS_SPCONT           610
#define TS_SPPASS           611
#define TS_SPFAIL           612
#define TS_SPABORT          613

/* Constants for set paths dialog */
#define TS_INPRMPT          615
#define TS_OUTPRMPT         616
#define TS_INPATH           617
#define TS_OUTPATH          618


// Help constant
#define TS_ABOUTTEXT        619

/* Constants for find dialog */
#define TS_FINDLABEL        620
#define TS_FINDEDIT         621
#define TS_FINDCASE         622
#define TS_FINDOK           623
#define TS_FINDCANCEL       624

// Toolbar Constants:
#define IDBMP_TBAR       1400

#define BTN_OPEN            0
#define BTN_SAVE            1
#define BTN_RUN             2
#define BTN_RUNMIN          3
#define BTN_RUNALL          4
#define BTN_EDIT            5
#define BTN_CLEAR           6
#define BTN_SELECT          7
#define BTN_SETLOGGING      8
#define BTN_FILEOFF         9
#define BTN_FILETERSE       10
#define BTN_FILEVERBOSE     11
#define BTN_WPFOFF          12
#define BTN_WPFTERSE        13
#define BTN_WPFVERBOSE      14

#define BTN_LAST            BTN_WPFVERBOSE

#define ID_EDITLOGFILE      1900
#define ID_STATUSBAR        1901


// Constants which determine spacings on the Tool Bar
#define TOOLBEGIN   6
#define TOOLLENGTH  24
#define TOOLSPACE   8
#define LARGESPACE  2*TOOLSPACE
#define EDITLENGTH  160
#define EDITSTART   TOOLBEGIN + 9*TOOLLENGTH + 3*TOOLSPACE + LARGESPACE
#define EDITEND     EDITSTART + EDITLENGTH
#define TOOLLAST    EDITEND + TOOLSPACE + 6*TOOLLENGTH + LARGESPACE + 200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsglobal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsglobal.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsglobal.h - Include file that defines all the constants and structures
|                used by the test shell.
|                                                                              
|   History:                                                                   
|   02/18/91 prestonb   Created from tst.c
|   08/13/94 t-rajr     Added fields to struct _tstlogring
----------------------------------------------------------------------------*/

#include "tstshell.h"

#define BUFFER_LENGTH   100
#define EXTRA_BUFFER    25

#define LOG_NOLOG       0

#define LOG_WINDOW      1
#define LOG_COM1        2

#define LOG_OVERWRITE   1
#define LOG_APPEND      2

#define LOG_MANUAL      0
#define LOG_AUTO        1

#define TST_LISTEND    -1
#define TST_NOLOGFILE  -1

#define SSAVER_ENABLED  0
#define SSAVER_DISABLED 1

#define TSTMSG_TSTLOGFLUSH  WM_USER + 1

// Maximum number of lines on the status bar
#define MAXSTATBARLINES 20

/* used in calls to initEnterTstList() */

#define LIST_BY_CASE    1
#define LIST_BY_GROUP   2

/* Test case print statistics structures */
typedef struct tsprstat {
    TS_PR_STATS_STRUCT  tsPrStats;
    struct tsprstat FAR *lpLeft;
    struct tsprstat FAR *lpRight;
} TS_STAT_STRUCT;
typedef TS_STAT_STRUCT FAR *LPTS_STAT_STRUCT;

/* Test case run structures */
typedef struct tstrun {
    WORD              iCaseNum;
    struct tstrun FAR *lpNext;
} TST_RUN_STRUCT;
typedef TST_RUN_STRUCT FAR *LPTST_RUN_STRUCT;

typedef struct {
    LPTST_RUN_STRUCT  lpFirst;
    LPTST_RUN_STRUCT  lpLast;
} TST_RUN_HDR;

//// this structure contains global variables used by
//// tstLog and tstLogFlush do fast,deferred logging
////
//static struct _tstlogring {
//    BOOL    bFastLogging;
//    UINT    nArgCount;
//    UINT    cdwRing;
//    UINT    nCompositeLogLevel;
//#if defined(WIN32) && !defined(_ALPHA_)
//    LPDWORD lpdwRingBase;
//    LPDWORD lpdwRingNext;
//    LPDWORD lpdwRingLimit;
//    CRITICAL_SECTION cs;
//#endif
//    } tl = {FALSE, RING_ELM_SIZE -2 };

// this structure contains global variables used by
// tstLog and tstLogFlush do fast,deferred logging
//

typedef struct _tstlogring {
    BOOL    bFastLogging;
    UINT    nArgCount;
    UINT    cdwRing;
    UINT    nCompositeLogLevel;
#if defined(WIN32) && !defined(_ALPHA_)
    LPDWORD lpdwRingBase;
    LPDWORD lpdwRingNext;
    LPDWORD lpdwRingLimit;
    CRITICAL_SECTION cs;
    CRITICAL_SECTION csId;           // Added by t-rajr
    CRITICAL_SECTION csFlush;        // for thread support
#endif
} TST_LOGRING;
typedef TST_LOGRING FAR *LPTST_LOGRING;


/* Test case rcdata structure */
/*  Changed wStrID and wGroupId to UINT's from int's */
typedef struct
{
    WORD    wStrID; // An ID for the test case's string resource
    WORD    iMode;	// The mode for the test case (interaction)
    WORD    iFxID;	// ID for a function to execute for this test case
    WORD    wGroupId;
} TST_ITEM_STRUCT;
typedef TST_ITEM_STRUCT FAR *LPTST_ITEM_STRUCT;

// Same structure as before but with a platform identifying member
typedef struct
{
    WORD    wStrID; // An ID for the test case's string resource
    WORD    iMode;	// The mode for the test case (interaction)
    WORD    iFxID;	// ID for a function to execute for this test case
    WORD    wGroupId;
    WORD    wPlatformId;
} TST_ITEM_RC_STRUCT;
typedef TST_ITEM_RC_STRUCT FAR *LPTST_ITEM_RC_STRUCT;


// Allocating the string storage with the structure halves the number
// of GlobalAlloc's and thus increases efficiency and memory usage.

#define MAXRESOURCESTRINGSIZE   100

typedef struct tagTST_STR_STRUCT
{
    WORD                    wStrID;
    char                    lpszData[MAXRESOURCESTRINGSIZE+1];
} TST_STR_STRUCT;
typedef TST_STR_STRUCT FAR *LPTST_STR_STRUCT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsrunset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsrunset.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsrunset.h - Include file for run setup code of test shell.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
extern void RunSetup (HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsmain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsmain.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsmain.h - Include file for main code of test shell.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
HANDLE getTstIDListRes(void);

void updateEditVariable (void);

void helpToolBar (int iButton);

void restoreStatusBar (void);

int tstGetStatusBar (LPSTR lpszLogData, int cbMax);

// Custom read/Write handlers -- AlokC (06/30/94)
VOID (CALLBACK* tstReadCustomInfo) (LPCSTR) ;
VOID (CALLBACK* tstWriteCustomInfo) (LPCSTR) ;



// These macros are used to eliminate the structured exception
// handling in tsmain.c for 16 bit
#ifndef WIN32
#define __try
#define __finally
#define __except(x)         if(FALSE)
#define GetExceptionCode()  0
#endif

#ifndef MAX_PATH
#define MAX_PATH            260
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsseltst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsseltst.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsseltst.h - Include file for selection code of test shell.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
void removeRunCases(void);

void resetEnvt(void);

void Select(void);

void SaveProfile(UINT);

BOOL LoadProfile(BOOL);

void addModeTstCases(WORD wMode);

void MakeDefaultLogName(LPSTR lpName);

void calculateNumResourceTests (void);

void freeDynamicTests (void);

HGLOBAL VLoadListResource (HINSTANCE hInst, HRSRC hrsrc);

BOOL VFreeListResource(HGLOBAL hglbResource);

void FAR* VLockListResource(HGLOBAL hglb);

BOOL VUnlockListResource(HGLOBAL hglb);

void placeAllCases(void);

void removeRunCases(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsextern.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsextern.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsextern.h - Include file for external global variables.
|                                                                              
|   History:                                                                   
|   02/18/91 prestonb   Created from tst.c
|   08/13/94 t-rajr     Added globals for thread support
----------------------------------------------------------------------------*/
extern HINSTANCE   ghTSInstApp;

extern int         giTSTstRes;

extern char        szTSTestName[BUFFER_LENGTH];
extern char        szTSPathSection[BUFFER_LENGTH];
extern char        szTstsHellIni[BUFFER_LENGTH];

extern HCURSOR     ghTSwaitCur;
extern int         giTSWait;

extern HWND        ghwndTSMain;
extern HMENU       ghTSMainMenu;
     
/* Test case selection info */
extern HWND        ghTSWndSelList;
extern HWND        ghTSWndAllList;

/* Group print info */
extern LPTS_STAT_STRUCT  tsPrStatHdr;

/* Run setup info */
extern TST_RUN_HDR  tstRunHdr;

extern int    giTSRunCount;
extern int    gwTSStepMode;
extern int    gwTSRandomMode;
extern UINT   gwTSScreenSaver;

/* passed to GetProfileString as keys */

extern char  szTSInPathKey[];
extern char  szTSOutPathKey[];

/* Logging info */
extern OFSTRUCT  ofGlobRec;
extern int    giTSIndenting;
extern HWND   ghTSWndLog;

extern UINT   gwTSLogOut;
extern UINT   gwTSLogLevel;
extern UINT   gwTSFileLogLevel;
extern UINT   gwTSFileMode;
extern UINT   gwTSVerification;

extern char   szTSLogfile[BUFFER_LENGTH];
extern HFILE  ghTSLogfile;

/* Profile info */
extern char   szTSProfile[BUFFER_LENGTH];

/* these receive the output of GetPRofileString() */

extern char  szInPath [BUFFER_LENGTH];
extern char  szOutPath [BUFFER_LENGTH];

/* generic buffer */

extern BOOL  gbAllTestsPassed;
extern BOOL  gbTestListExpanded;

extern int giTSCasesRes;

extern char szTSDefProfKey[];
extern BOOL DefProfState;

extern WORD wPlatform;

extern char szToolBarClass[];

extern HWND hwndEditLogFile;
extern HWND hwndToolBar;

/********* Added by t-rajr ***********/
/* globals needed for multi-threading*/

extern HANDLE ghFlushEvent;
extern DWORD gdwMainThreadId;

#ifdef WIN32
extern CRITICAL_SECTION gCSLog;
#endif
/********* Added by t-rajr ***********/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tssetpth.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tssetpth.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tssetpth.h - Include file for setting the input and output paths for 
|                test cases.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
extern void SetInOutPaths (void);

/* This function get the current working directory */
extern void FAR PASCAL GetCWD (LPSTR lpstrPath, UINT uSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsstats.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsstats.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsstats.h - Include file for printing group info routines.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
void tsRemovePrStats(void);

LPTS_STAT_STRUCT tsUpdateGrpNodes(LPTS_STAT_STRUCT,int,UINT);

void tsPrAllGroups(void);

void tsPrFinalStatus(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tsstep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       tsstep.h
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
|   tsstep.h - Include file for step mode code of test shell.
|                                                                              
|   History:                                                                   
----------------------------------------------------------------------------*/
extern int StepMode (HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\waveutil.h ===
//--------------------------------------------------------------------------;
//
//  File: WaveUtil.h
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Header file for Wave Utilities.
//
//  Contents:
//      Prototypes, Macros, and Constants for Wave Stuff...
//
//  Notes:
//      Assumes that msacm.h is #included before.
//
//  History:
//      02/18/94    Fwong       To standardize on wave utilities.
//
//--------------------------------------------------------------------------;


//==========================================================================;
//
//                         Portability Stuff...
//                      "Borrowed" from AppPort.h
//
//==========================================================================;

#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK
    #endif
#else
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNCALLBACK  FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNCALLBACK  FAR PASCAL _export
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif
#endif

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define SIZEOFWAVEFORMAT(pwfx)  ((WAVE_FORMAT_PCM == pwfx->wFormatTag)?\
                                (sizeof(PCMWAVEFORMAT)):\
                                (sizeof(WAVEFORMATEX)+pwfx->cbSize))


//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define __FORMAT_SIZE       ACMFORMATDETAILS_FORMAT_CHARS
#define __FORMATTAG_SIZE    ACMFORMATTAGDETAILS_FORMATTAG_CHARS
#define MAXFMTSTR           (__FORMAT_SIZE + __FORMATTAG_SIZE)
#define MSB_FORMAT          WAVE_FORMAT_4S16
#define VALID_FORMAT_FLAGS  0x00000fff

//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

extern void FNGLOBAL wfxCpy
(
    LPWAVEFORMATEX  pwfxDst,
    LPWAVEFORMATEX  pwfxSrc
);

extern BOOL FNGLOBAL wfxCmp
(
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst
);

extern void FNGLOBAL GetFormatName
(
    LPSTR           pszFormat,
    LPWAVEFORMATEX  pwfx,
    DWORD           cbSize
);

extern BOOL FNGLOBAL FormatFlag_To_Format
(
    DWORD           dwMask,
    LPPCMWAVEFORMAT ppcmwf
);

extern void FNGLOBAL GetWaveOutDriverName
(
    UINT    uDeviceID,
    LPSTR   pszDriverName,
    DWORD   cbSize
);

extern void FNGLOBAL GetWaveInDriverName
(
    UINT    uDeviceID,
    LPSTR   pszDriverName,
    DWORD   cbSize
);

extern DWORD FNGLOBAL GetNumFormats
(
    void
);

extern BOOL FNGLOBAL GetFormat
(
    LPWAVEFORMATEX  pwfx,
    DWORD           cbwfx,
    DWORD           dwIndex
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\inc\tstshell.h ===
/***************************************************************************\
*                                                                           *
*   File: Tstshell.h                                                        *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This include file contains all the API prototypes, constants and    *
*       structures needed by test shell applications.                       *
*                                                                           *
*   Contents:                                                               *
*                                                                           *
*   History:                                                                *
*       02/17/91    prestonb   Created from tst.h                           *
*       07/11/93    T-OriG     Reformatted; added new APIs and this header  *
*                                                                           *
\***************************************************************************/

#ifndef _INC_TSTSHELL
#define _INC_TSTSHELL

#ifdef	__cplusplus
extern "C" {
#endif

// The constants indicate whether a test is manual or automatic
#define PLATFORM_ALL    0xffff

#define TST_AUTOMATIC   1
#define TST_MANUAL      2

#define TST_FAIL        0
#define TST_PASS        1
#define TST_OTHER       -1
#define TST_ABORT       -2
#define TST_TNYI        -3
#define TST_TRAN        -4
#define TST_TERR        -5
#define TST_STOP        -6

#define TS_MENUBASE     300

#define TERSE           1
#define VERBOSE         2
#define FLUSH           0x8000

#define TS_INPATH_ID    1
#define TS_OUTPATH_ID   2

//==========================================================================;
//
//                     Metrics for tstSetOptions...
//
//==========================================================================;

#define TST_ENABLEFASTLOGGING          1
#define TST_ENABLEEXCEPTIONHANDLING    2
#define TST_SETLOGBUFFERLIMIT          3

#ifdef WIN32
#define EXPORT
#else
#define EXPORT _export
#endif

#define DECLARE_TS_MENU_PTR(fpTest) LRESULT (CALLBACK* fpTest)(HWND,UINT,WPARAM,LPARAM)

typedef struct {
    UINT   wGroupId;
    int    iNumPass;
    int    iNumFail;
    int    iNumOther;
    int    iNumAbort;
    int    iNumNYI;
    int    iNumRan;
    int    iNumErr;
    int    iNumStop;
} TS_PR_STATS_STRUCT;
typedef TS_PR_STATS_STRUCT FAR *LPTS_PR_STATS_STRUCT;

#define SUMMARY_STAT_GROUP  65535


//
//  These shell APIs may be called by the test application
//

extern void tstWinYield
(
    void
);

extern int tstYesNoBox
(
    LPSTR   lpszQuestion,
    int     wDefault
);

extern BOOL tstLogFlush
(
    void
);

extern DWORD tstSetOptions
(
    UINT    uType,
    DWORD   dwValue
);

extern BOOL _cdecl tstLog
(
    UINT    iLogLevel,
    LPSTR   lpszFormat,
    ...
);

extern BOOL _cdecl tstLogFn
(
    UINT    iLogLevel,
    UINT (_cdecl FAR * pfnFormat)(LPSTR lpszOutBuffer, ...),
    ...
);

extern void tstBeginSection
(
    LPSTR   lpszTitle
);

extern void tstEndSection
(
    void
);

extern BOOL tstCheckRunStop
(
    UINT    wVirtKey
);

extern HMENU tstInstallCustomTest
(
    LPSTR               lpszMenuName,
    LPSTR               lpszMenuItem,
    UINT                wID,
    DECLARE_TS_MENU_PTR (fpTest)
);

extern void tstPrintStats
(
    LPTS_PR_STATS_STRUCT    lpPrStats
);

extern int tsAmInAuto
(
    void
);

extern void getTSInOutPaths
(
    int     iPathId,
    LPSTR   lpstrPath,
    int     cbBufferSize
);

extern void FAR PASCAL GetCWD
(
    LPSTR   lpstrPath,
    UINT    uSize
);

extern void tstInstallDefWindowProc
(
    LRESULT (CALLBACK* tstDWP) (HWND, UINT, WPARAM, LPARAM)
);

extern BOOL tstLogStatusBar
(
    LPSTR   lpszLogData
);

extern int tstGetStatusBar
(
    LPSTR   lpszLogData,
    int     cbMax
);

extern void tstDisplayCurrentTest
(
    void
);

extern void tstAddTestCase
(
    WORD    wStrID,
    WORD    iMode,
    WORD    iFxID,
    WORD    wGroupID
);

extern BOOL tstAddNewString
(
    WORD    wStrID,
    LPSTR   lpszData
);

extern int tstLoadString
(
    HINSTANCE   hInst,
    UINT        idResource,
    LPSTR       lpszBuffer,
    int         cbBuffer
);


extern void tstChangeStopVKey
(
    int vKey
);


extern int tstGetProfileString
(
    LPCSTR  lpszEntry,
    LPCSTR  lpszDefault,
    LPSTR   lpszReturnBuffer,
    int     cbReturnBuffer
);


extern BOOL tstWriteProfileString
(
    LPCSTR  lpszEntry,
    LPCSTR  lpszString
);

extern void tstInitHelpMenu
(
    void
);

extern void tstInstallReadCustomInfo
(
    void (CALLBACK* tstReadCI) (LPCSTR)
) ;

extern void tstInstallWriteCustomInfo
(
    void (CALLBACK* tstWriteCI) (LPCSTR)
) ;



//
// These routines are called by the main test shell code
//

extern int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      lpwPlatform
);

extern BOOL tstInit
(
    HWND    hwndMain
);

extern int execTest
(
    int     iFxID,
    int     iCase,
    UINT    wID,
    UINT    wGroupID
);

extern void tstTerminate
(
    void
);


//
// External Macros
//
#define tsIsAutoMode tsAmInAuto()

#ifdef __cplusplus
}
#endif	// __cplusplus
#endif	// _INC_TSTSHELL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\codebook.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       codebook.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/

#include "common.h"
#include "prototyp.h"
#include "fast.h"
#include "data.h"

/* Impulse Response Vector Calculator */

void iresp_vcalc(real COEFF_MEM sf_co[], 
		  real COEFF_MEM pwf_z_co[], real COEFF_MEM pwf_p_co[], 
		  real h[])
{
    static real temp[IDIM];
    static real rc[IDIM];
    real a0,a1,a2;
    int i,k;
    temp[0] = rc[0] = 1.0;
    for (k=1; k<IDIM; k++) {
   	a0=a1=a2=0.0;
   	for (i=k; i>=1; i--) {
	    temp[i] = temp[i-1];
	    rc[i] = rc[i-1];
	    a0 -= sf_co[i]   * temp[i];
	    a1 += pwf_z_co[i] * temp[i];
	    a2 -= pwf_p_co[i] * rc[i];
  	}
   	temp[0] = a0;
   	rc[0] = a0+a1+a2;
    }
    for (k=0; k<IDIM; k++)
	h[k] = rc[IDIM-1-k];
}

/* Cb_shape Codevector Convolution Module and Energy Table Calculator */
/* The output is energy table */

#ifdef PIPELINE

void
shape_conv(real h[], real shen[])
{
    int j;
    real *shep = shen;
    real CBMEM *cp = (real CBMEM *) cb_shape;
    real *hp = h;

    real
	lmul1, lmul2, rmul1, rmul2, ladd1, ladd2, ladd3, radd1, radd2;

#define e0  ladd1
#define x0  ladd2
#define x2  ladd2
#define x4  ladd2
#define x1  ladd3
#define x3  ladd3

#define e1  radd1
#define e2  radd1
#define e3  radd1
#define e4  radd1
#define t01 radd1
#define t11 radd1
#define t12 radd1
#define t22 radd1
#define t40 radd1
#define t20 radd2
#define t21 radd2
#define t03 radd2
#define t13 radd2
#define t31 radd2

#define c0 lmul1
#define c2 lmul1
#define c4 lmul1
#define c1 lmul2
#define c3 lmul2

#define h0 rmul1
#define h2 rmul1
#define h4 rmul1
#define h1 rmul2
#define h3 rmul2

    for (j=0; j<NCWD; j++) {
				c0=*cp++; h0=*hp++;
		x0 =c0*h0;
		e0 =x0*x0;	c1=*cp--;
		x1 =c1*h0;	c0=*cp++; h1=*hp++;
		t01=c0*h1;		  h2=*hp--;
x1+=t01;	x2 =c0*h2;
		e1 =x1*x1;	c1=*cp++; h1=*hp--;
e0+=e1;		t11=c1*h1;	c2=*cp++; h0=*hp++;
x2+=t11;	t20=c2*h0;	c3=*cp--;
x2+=t20;	x3 =c3*h0;
		e2 =x2*x2;	c2=*cp--; h1=*hp++;
e0+=e2;		t21=c2*h1;	c1=*cp--; h2=*hp++;
x3+=t21;	t12=c1*h2;	c0=*cp++; h3=*hp++;
x3+=t12;	t03=c0*h3;		  h4=*hp--;
x3+=t03;	x4 =c0*h4;
		e3 =x3*x3;	c1=*cp++; h3=*hp--;
e0+=e3;		t13=c1*h3;	c2=*cp++; h2=*hp--;
x4+=t13;	t22=c2*h2;	c3=*cp++; h1=*hp--;
x4+=t22;	t31=c3*h1;	c4=*cp++; h0=*hp;
x4+=t31;	t40=c4*h0;
x4+=t40;
		e4=x4*x4;
e0+=e4;
				*shep++=e0;
    }
}
#else
/** Unoptimized version -- kept for reference */

void
shape_conv(real h[], real shen[])
{
    int j;
    real h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3], h4 = h[4], tmp;
    for (j=0; j<NCWD; j++) {
	real energy=0;
	tmp = h0*cb_shape[j][0];
	energy += tmp*tmp;
	tmp = h0*cb_shape[j][1] + h1*cb_shape[j][0];
	energy += tmp*tmp;
	tmp = h0*cb_shape[j][2] + h1*cb_shape[j][1] + h2*cb_shape[j][0];
	energy += tmp*tmp;
	tmp = h0*cb_shape[j][3] + h1*cb_shape[j][2] + h2*cb_shape[j][1] +
	      h3*cb_shape[j][0];
	energy += tmp*tmp;
	tmp = h0*cb_shape[j][4] + h1*cb_shape[j][3] + h2*cb_shape[j][2] +
	      h3*cb_shape[j][1] + h4*cb_shape[j][0];
	energy += tmp*tmp;
	shen[j] = energy;
    }
}
#endif

/* Time Reversed Convolution Module -- Block 13 */


void
trev_conv(real h[], real target[],
	  real pn[])
{
    int j, k;
    for (k=0; k<IDIM; k++) {
	real tmp=0.0;
   	for (j=k; j<IDIM; j++)
	    tmp += target[j]*h[j-k];
	pn[k] = tmp;
    }
}


/* Error Calculator and Best Codebook Index Selector */
/* Blocks 17 and 18 */


void
cb_excitation (int ix, real v[])
{
    int
	i,
	sx = ix >>3,
	gx = ix & 7;
    real gain = cb_gain[gx];
    for(i=0; i<IDIM; i++)
	v[i] = cb_shape[sx][i] * gain;
}

#define GTINC(A,B,X) if(A>B)X++

int
cb_index (real pn[])
{
    real  d, distm = BIG;
    int
	j,
	is=0,		/* best shape index */
	ig=0,		/* best gain index */
	idxg,		/* current gain index */
	ichan;		/* resulting combined index */
    real CBMEM *shape_ptr = (real CBMEM *) cb_shape;
    real *sher_ptr  = shape_energy;
    real pcor, b0, b1, b2;
    real *pb=pn;
    real g2, gsq;
    register real
	cgm0 REG(r0) = cb_gain_mid_0,
	cgm1 REG(r1) = cb_gain_mid_1,
	x REG(r2),
	cgm2  = cb_gain_mid_2,
	energy REG(r4), y REG(r5),
	cor REG(r8) = 0,
	t REG(r12);
    register int minus5 REG(m0) = -5;
    
    for (j=0; j<NCWD; j++) {
	cor=cor-cor;
	energy = *sher_ptr++;

	b0 = cgm0 * energy; x=*shape_ptr++; y=*pb++;
	            t=x*y;  x=*shape_ptr++; y=*pb++;
	cor+=t;     t=x*y;  x=*shape_ptr++; y=*pb++;
	cor+=t;     t=x*y;  x=*shape_ptr++; y=*pb++;
	cor+=t;     t=x*y;  x=*shape_ptr++; y=*pb++;
	cor+=t;     t=x*y;
	cor+=t;     b1 = cgm1 * energy;
	
	pb += minus5;
	b2 = cgm2 * energy;
	idxg=idxg-idxg;
	pcor = cor;
	if (cor < 0.0) {
	    pcor = -cor;
	    idxg += 4;
	}
	GTINC(pcor, b0, idxg);
	GTINC(pcor, b1, idxg);
	GTINC(pcor, b2, idxg);
	
	g2 = cb_gain2[idxg];
	gsq = cb_gain_sq[idxg];
	d = gsq * energy - g2 * cor;
	
	if (d < distm) {
	    ig = idxg;
	    is = j;
	    distm = d;
	}
    }
    ichan = (is  << 3) + ig;
    return ichan;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef COMMON_H
#define COMMON_H

#include <windows.h>
#include <malloc.h>
#include <memory.h>

#include "parm.h"
#include "qsize.h"

typedef float real;

#define RCOPY(X,Y,N) memcpy(Y, X,(N)*sizeof(real))
#define EPSILON 1.0e-35

/* Use hand-pipelined loops for higher speed on 21000 */

#define PIPELINE 1

#define REALZEROP(x) ((x<EPSILON)&&(x>-EPSILON))

#define CLIPP(X,LOW,HIGH) ((X)<(LOW)?(LOW):(X)>(HIGH)?(HIGH):(X))

#define FLOAT2FIX(X,N) ((int)  (X))
#define FIX2FLOAT(X)   ((float)(X))
#define VOLATILE

#define sig_scale(SCALE,A,B) \
{int __i;for(__i=0;__i<IDIM;__i++)(B)[__i]=SCALE*(A)[__i];}

#define sub_sig(A,B,C) \
{int __i;for(__i=0;__i<IDIM;__i++) (C)[__i]=(A)[__i]-(B)[__i];}

#define pm
#define dm

/* Circular Buffer Register numbers for ADSP21000   */

#define NPUT 8
#define NGET 9

#define real float
#define RCOPY(X,Y,N) memcpy(Y, X,(N)*sizeof(real))
#define EPSILON 1.0e-35

#define IF(X) if(X)
#define ZARR(A) {for (i=sizeof(A)/sizeof(A[0])-1; i>=0 ; i--) A[i] = 0.0;}
#if 0
#define CHECK1(V) ({if (! (V>=-10000. && V<=10000.)) abort();})
#define CHECK(A,N) ({int __i;for(__i=0;__i<N;__i++)CHECK1((A)[__i]);})
#else
#define CHECK1(V) 
#define CHECK(A,N) 
#endif

#define PWFILTER
#define noCBDEBUG

#define QMEM
#define LPC_MEM
#define PSF_LPC_MEM
#define WIN_MEM
#define CBMEM
#define COEFF_MEM 
#define REG(X)

/* Update obsoleted atomic array */

#define UPDATE(NAME) {int _i;if(NAME ## _obsolete_p) \
		       for(_i=sizeof(NAME)/sizeof(NAME[0])-1;_i>=0;_i--)\
		       NAME[_i]=NAME ## _next[_i]; NAME ## _obsolete_p=0;}

/* Copy L words to X from circular buffer CIRC *ending* at offset EOS. 
   CL is the size of circular buffe CIRC */

#define CIRCOPY(X,CIRC,EOS,L,CL) {int _i1,_i2,_i,_lx=0;\
 if((EOS)>=(L)){_i1=(EOS)-(L);_i2=(CL);} \
 else            {_i1=0;        _i2=(CL)+(EOS)-(L);}\
 for(_i=_i2; _i<(CL);   _i++)X[_lx++]=CIRC[_i];\
 for(_i=_i1; _i<(EOS); _i++)X[_lx++]=CIRC[_i];}

/* get queue index of the most recent vector */

#define QINDEX  ({int __qx=vector_end-thequeue; \
		      __qx ? QSIZE-IDIM : __qx-IDIM;})

// extern real QMEM thequeue[];
// extern real QMEM * VOLATILE vector_end;

/* declare array and its copy together with a semafor */

#define ACLASS extern 

ACLASS real sf_coeff[LPC+1];
ACLASS real gp_coeff[LPCLG+1];
ACLASS real pwf_z_coeff[LPCW+1];
ACLASS real pwf_p_coeff[LPCW+1];
ACLASS real shape_energy[NCWD];
ACLASS real imp_resp[IDIM];

ACLASS real sf_coeff_next[LPC+1];
ACLASS real gp_coeff_next[LPCLG+1];
ACLASS real pwf_z_coeff_next[LPCW+1];
ACLASS real pwf_p_coeff_next[LPCW+1];
ACLASS real shape_energy_next[NCWD];
ACLASS real imp_resp_next[IDIM];

ACLASS int sf_coeff_obsolete_p;
ACLASS int gp_coeff_obsolete_p;
ACLASS int pwf_z_coeff_obsolete_p;
ACLASS int pwf_p_coeff_obsolete_p;
ACLASS int shape_energy_obsolete_p;
ACLASS int imp_resp_obsolete_p;

extern real synspeech [QSIZE];		/* Synthesized Speech */
extern real qspeech   [QSIZE];		/* Quantized   Speech */
extern real log_gains[QSIZE/IDIM];	/* Logarithm of Gains */

#define FFASE(N) if (ffase == N)
#define NEXT_FFASE ffase=(ffase==4?1:ffase+1)

extern int VOLATILE ffase;
extern CRITICAL_SECTION csLDCELP;

#undef  ACLASS
#define ACLASS

#endif /*COMMON_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\adapters.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       adapters.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/

#include "common.h"
#include "fast.h"
#include "parm.h"
#include "data.h"
#include "prototyp.h"

static int sf_levdur (real[], real[]);
static int levdur (real[], real[], int);
static void hybwin(int lpsize, int framesize, int nrsize,
	    real old_input[], real new_input[], real output[],
	    real window[], real rec[],  real decay);
static void bw_expand2(real input[],
		       real z_out[], real p_out[],
		       int order, real z_vec[], real p_vec[]);
static void bw_expand1(real input[], real  p_out[],
		int order, real p_vec[]);

/********************************** Adapter for Perceptual Weighting Filter */

static real 
    pwf_z_vec[LPCW+1],		/* Arrays for band widening: zeros and*/
    pwf_p_vec[LPCW+1],		/* poles */
    pwf_old_input[LPCW+NFRSZ+NONRW],
    pwf_rec[LPCW+1];			/* Recursive Part */
    

void
pwf_adapter (real input[],
	     real  z_out[], /* zero coefficients */
	     real  p_out[]) /* pole coefficients */
{
    static real
	acorr[LPCW+1],		/* autocorrelation coefficients */
	lpcoeff[LPCW+1];
    static real LPC_MEM
	temp[LPCW+1];

    hybwin(LPCW,	/* lpsize */
	   NFRSZ,	/* framesize */
	   NONRW,	/* nrsize -- nonrecursive size */
	   pwf_old_input,
	   input,
	   acorr,
	   hw_percw,
	   pwf_rec,
	   0.5);
    if (levdur(acorr, temp, LPCW))
      {
	RCOPY(temp, lpcoeff, LPCW+1);
	bw_expand2 (lpcoeff, z_out, p_out, LPCW,
		    pwf_z_vec, pwf_p_vec);
      }
}

void
init_pwf_adapter (real  z_co[], real  p_co[])
{
    real zv = 1.0, pv = 1.0;
    int i;
    for (i=0; i<=LPCW; i++)
    {
	pwf_z_vec[i] = zv;
	pwf_p_vec[i] = pv;
	zv *= WZCF;
	pv *= WPCF;
	z_co[i] = 0.0;
	p_co[i] = 0.0;
    }
    p_co[0] = 1.0;
    z_co[0] = 1.0;
    ZARR(pwf_old_input);
    ZARR(pwf_rec);
}

/*************************************** Backward Synthesis Filter Adapter */

static real facv[LPC+1];

static real
    bsf_old_input[LPC+NFRSZ+NONR],
    bsf_rec[LPC+1]; 


void
bsf_adapter (real input[], real p_out[])
{
    static real
	old_input[LPC + NFRSZ + NONR],
	acorr[LPC+1],		/* autocorrelation coefficients */
	lpcoeff[LPC+1];
    static real temp[LPC+1];
    hybwin(LPC,		/* lpsize */
	   NFRSZ,	/* framesize */
	   NONR,	/* nrsize -- nonrecursive size */
	   old_input,
	   input,
	   acorr,
	   hw_synth,
	   bsf_rec,
	   0.75);
    if (sf_levdur(acorr, temp))
      {
	k10 = -acorr[1]/acorr[0];
	RCOPY(temp, lpcoeff, LPC+1);
	bw_expand1(lpcoeff, p_out, LPC, facv);
      }
}

/******************************************************* Gain Adapter **/

#pragma warning( disable:4244 )

static real gain_p_vec[LPCLG+1]=  /* Array for band widening */
{1.0, 0.90625, 0.8212890625, 0.74432373046875, 0.67449951171875, 
0.61126708984375, 0.553955078125, 0.50201416015625, 0.4549560546875, 
0.41229248046875, 0.3736572265625};

#pragma warning( default:4244 )

static real g_rec[LPCLG+1];	/* Recursive part for Hybrid Window */
static real g_old_input[LPCLG + NUPDATE + NONRLG];

/*** recompute lpc_coeff **/


void gain_adapter (real log_gain[], real  coeff[])
{
    static real
	acorr[LPCLG+1],		/* autocorrelation coefficients */
	lpcoeff[LPCLG+1];
    
    static real temp[LPCLG+1];

    hybwin(LPCLG,	/* lpsize */
	   NUPDATE,	/* framesize */
	   NONRLG,	/* nrsize -- nonrecursive size */
	   g_old_input,
	   log_gain,
	   acorr,
	   hw_gain,
	   g_rec,
	   0.75);
    if (levdur(acorr, temp, LPCLG)) {
	int i;
	for(i=1; i<=LPCLG; i++)
	    lpcoeff[i] = temp[i];
    bw_expand1 (lpcoeff, coeff, LPCLG,
		gain_p_vec);
      }
}
/******************************************** Initializations **/

void
init_bsf_adapter(real co[])
{
    int i;
    real v = 1.0;

    for(i=0; i<=LPC; i++) {
	facv[i] = v;
	v *= FAC;
	co[i] = 0;
    }
    co[0] = 1.0;
    ZARR(bsf_old_input);
    ZARR(bsf_rec);
    
}


void init_gain_adapter (real coeff[])
{
    int i;
    gain_p_vec[0] = 1.0;
    coeff[0] = 1.0;
    coeff[1] = -1.0;
    for(i=0; i<LPCLG+NUPDATE+NONRLG; i++)
	g_old_input[i] = -GOFF;
    ZARR(g_rec);
    ZARR(g_old_input);
}

/******************************************** Hybrid Window Module **/

/*
  Hybrid Window 

  LPSIZE	- size of OUTPUT (autocorrelation vector)
  FRAMESIZE	- size of NEW_INPUT
  NRSIZE	- size of non-recursive part.
  OLD_INPUT	- buffer for holding old input (size LPSIZE+FRAMESIZE+NRSIZE)
  NEW_INPUT	- new input, or frame (size FRAMESIZE)
  OUTPUT	- autocorrelation vector (size LPSIZE)
  WINDOW	- window coefficients (size LPSIZE+FRAMESIZE+NRSIZE)
  REC	- 	- recursive part (size LPSIZE)
  DECAY	- 	- scaling for the old recursive part.
 */


static void
hybwin(int lpsize, int framesize, int nrsize, real old_input[], 
       real new_input[], real output[],real WIN_MEM window[],
		    real rec[],		/* Recursive Part */
		    real decay)
{
    static void autocorr();

    int		N1 = lpsize + framesize; /* M+L */
    int		N2 = lpsize + nrsize;	/* M+N */
    int		N3 = lpsize + framesize + nrsize;
    int		i;
    real	*ws, *tmp1, *tmp2;

	ws=(real *) malloc( N3 * sizeof( real ) );
	tmp1 = (real *) malloc( (lpsize+1) * sizeof( real ) );
	tmp2 = (real *) malloc( (lpsize+1) * sizeof( real ) );

    /* shift in INPUT into OLD_INPUT and window it*/
    
    for(i=0; i<N2; i++)
	old_input[i] = old_input[i+framesize];
    for(i=0; i<framesize; i++)
	old_input[N2+i] = new_input[i];

    VPROD(old_input,window,ws,N3);
    
    autocorr(ws, tmp1, lpsize, lpsize, N1);
    
    for(i=0; i<=lpsize; i++)
	rec[i] = decay * rec[i] + tmp1[i];
    
    autocorr(ws, tmp2, lpsize,  N1, N3);
    
    for(i=0; i<=lpsize; i++)
	output[i] = rec[i] + tmp2[i];

    output[0] *= WNCF;

	free( ws );
	free( tmp1 );
	free( tmp2 );
}


/********************************************* Levinson-Durbin Routines */


/* Levinson-Durbin algorithm */
/* return 1 if ok, otherwise 0 */


static int levdur(real acorr[], real  coeff[], int order)
{
  /* Local variables */
  static int minc, minc2;
  static float s;
  static int ib, mh;
  static float at;
  static int ip;
  static float rc[20];
  static float alpha;
  static float tmp;

  /* Parameter adjustments */
  --acorr;
  --coeff;

/* .......CHECK FOR ZERO SIGNAL OR ILLEGAL ZERO-LAG AUTOCORRELATION */
  if ((acorr[1] <= (float)0.)||(acorr[order+1] == 0))
    return 0;


/* .......START DURBIN's RECURSION */
  rc[1] = -acorr[2] / acorr[1];
  coeff[1] = (float)1.;
  coeff[2] = rc[1];
  alpha = acorr[1] + acorr[2] * rc[1];
  if (alpha <= (float)0.)
    return 0;
  for (minc = 2; minc <= order; ++minc) {
    minc2 = minc + 2;
    s = acorr[minc + 1];
    for (ip = 2; ip <= minc; ++ip) {
      s += acorr[minc2 - ip] * coeff[ip];
    }
    rc[minc] = -s / alpha;
    mh = minc / 2 + 1;
    for (ip = 2; ip <= mh; ++ip) {
      ib = minc2 - ip;
      at = rc[minc] * coeff[ib];
      at += coeff[ip];
      tmp = rc[minc] * coeff[ip];
      coeff[ib] += tmp;
      coeff[ip] = at;
    }
    coeff[minc + 1] = rc[minc];
    alpha += rc[minc] * s;

/* ...........IF RESIDUAL ENERGY LESS THAN ZERO (DUE TO ILL-CONDITIONING), */
/* ...........RETURN WITHOUT UPDATING FILTER COEFFICIENTS (USE OLD ONES). */
    if (alpha <= (float)0.)
      return 0;
  }
  return 1;
}

/*
  Levinson-Durbin algorithm  for Synthesis Filter. Its main 
  difference from the above is the fact that it saves 10-th
  order coefficients for Postfilter, plus some speedup since this 
  is one of the longest routines in the algorithm.
  */ 

real a10[11];
real k10;

static int sf_levdur(real acorr[], real  coeff[])
{
    real E;
    register real K REG(r9), c1 REG(r0), tmp REG(r12);
    int m, j, halfm;

    if (acorr[LPC] == 0)
        return 0;
    E = acorr[0];
    if (E<=0) 
	return 0;
    coeff[0] = 1.0;
    for(m=1; m<=LPC; m++) {
	K =  -acorr[m];
	if (m>1)
	{
	    real a1 REG(r4)=acorr[m-1];
	    c1=coeff[1];
	    tmp = c1*a1;
	    if (m>2) {
		c1 = coeff[2]; a1 = acorr[m-2];
		for(j=3; j<=m-1; j++) {
		    K -= tmp;
		    tmp = c1 * a1;
		    c1 = coeff[j];
		    a1 = acorr[m-j];
		}
		K -= tmp;
		tmp = c1*a1;
	    }
	    K -= tmp;
	}
	K = K/E;
	coeff[m] = K;
	halfm = m>>1;

	/** this is pipilened version of parallel assignment:  **/
	/*  coeff[j]   =     coeff[j] + K * coeff[m-j] */
	/*  coeff[m-j] = K * coeff[j] +     coeff[m-j] */

      {
	  if (halfm>=1) {
	      register real
		  x  REG(r1),   y  REG(r5), t1 REG(r10),
		  t2 REG(r14), t3 REG(r2), t4 REG(r6);
	      register real  *p  REG(i10);
	      register real  *pp REG(i11);
	      register real  *q  REG(i12);
	      register real  *qq REG(i13);

	      p = coeff+1;   pp = p;
	      q = coeff+m-1; qq = q;
	      x=*p++;
	      y=*q--;
	      t1 = K * x;
	      t2 = K * y;
	      for(j=2; j<=halfm; j++) {
		  t4 = t2 + x;	 x=*p++;
		  t3 = t1 + y;   y=*q--;      
		  t1 = K * x;	*pp++ = t4;
		  t2 = K * y;	*qq-- = t3;
	      }
	      t3 = t1 + y;
	      t4 = t2 + x;
	      *pp = t4;
	      *qq = t3;
	  }
      }
	if (m==10) {
	    int jj;
	    for(jj=0; jj<=10; jj++)
		a10[jj] = coeff[jj];
	}
	E = (1 - K * K) * E;
	if (E<0)
	    return 0;
    }
    return 1;
}

/******************************************** Band Width Expanders **/

/* Don't have to worry about i=0 -- z_vec[0] and p_vec[0] should stay 1.0. */

static void
bw_expand2(real input[], real z_out[], real p_out[],
		       int order, real z_vec[], real p_vec[])
{
	int i;
	for(i=1; i<=order; i++)
	    z_out[i] = z_vec[i] * input[i];
	for(i=1; i<=order; i++)
	    p_out[i] = p_vec[i]*input[i];
}

/* Poles only */

static void
bw_expand1(real input[],  real p_out[], int order, real p_vec[])
{
	int i;
	for(i=1; i<=order; i++)
	    p_out[i] = p_vec[i]*input[i];
}

static void
autocorr(real X[], real R[], int K, int M, int N)
{
  int  ii,jj;
  float tmp;

  for(ii=0; ii<=K; ii++) {
    R[ii] = 0;
    for(jj=M; jj<N; jj++) {
      tmp = X[jj] * X[jj-ii];
      R[ii] += tmp;
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\data.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       data.h
//
//--------------------------------------------------------------------------

#ifndef _DATA_H
#define _DATA_H

#include "common.h"

extern real CBMEM cb_shape[][5];
extern real cb_gain[];

/* Double Gains: */
extern real cb_gain2[];

/* Midpoints: */
extern real cb_gain_mid[];

/* Squared Gains: */
extern real cb_gain_sq[];

#define cb_gain_mid_0 0.708984375
#define cb_gain_mid_1 1.240722656
#define cb_gain_mid_2 2.171264649
#define cb_gain_mid_3 0
#define cb_gain_mid_4 -0.708984375
#define cb_gain_mid_5 -1.240722656
#define cb_gain_mid_6 -2.171264649
#define cb_gain_mid_7 0

#define cb_gain2_0  1.031250
#define cb_gain2_1  1.846875
#define cb_gain2_2  3.158203
#define cb_gain2_3  5.526855
#define cb_gain2_4  -1.031250
#define cb_gain2_5  -1.846875
#define cb_gain2_6  -3.158203
#define cb_gain2_7  -5.526855

#define cb_gain_sq_0 0.265869
#define cb_gain_sq_1 0.8527368
#define cb_gain_sq_2 2.493562
#define cb_gain_sq_3 7.636533
#define cb_gain_sq_4 0.265869
#define cb_gain_sq_5 0.8527368
#define cb_gain_sq_6 2.493562
#define cb_gain_sq_7 7.636533

extern WIN_MEM real hw_gain[];
extern WIN_MEM real hw_percw[];
extern WIN_MEM real hw_synth[];

/* Postfilter coefficients for low-pass decimating IIR filter */

#define A1 -2.34036589
#define A2  2.01190019
#define A3 -0.614109218

#define B0  0.0357081667
#define B1 -0.0069956244
#define B2 -0.0069956244
#define B3  0.0357081667

#endif /* _DATA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\data.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       data.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/

#include "common.h"
#include "data.h"

#pragma warning( disable:4244 )

real CBMEM cb_shape[128][5] =
{
{  0.326171875, -1.440429688, -0.612304688, -0.874023438, -1.246582031},
{ -2.457031250, -2.234863281, -0.510253906,  1.419921875,  1.620117188},
{ -1.376464844, -1.307128906, -0.462890625, -1.379394531, -2.172851563},
{ -3.261230469, -0.166015625,  0.723632813, -0.623046875,  0.616210938},
{ -0.274414063, -3.299316406,  0.625488281,  0.087402344, -0.622070313},
{ -1.226562500, -3.481445313, -2.404785156,  3.375488281,  1.177246094},
{ -1.209960938, -0.076171875,  2.286621094, -1.891113281,  0.000000000},
{ -4.007812500,  1.044921875, -0.233398438, -1.359863281,  0.260253906},
{  0.922363281,  1.347167969,  0.674316406, -3.395996094, -2.887207031},
{  2.481445313, -1.201171875, -2.821289063,  0.877441406,  0.277343750},
{ -1.078125000, -1.615722656, -2.208496094, -3.044921875, -3.664550781},
{ -1.327636719,  2.127929688, -1.458984375, -0.561035156,  1.300781250},
{  0.614746094,  0.485839844,  1.323730469, -1.203125000, -5.073242188},
{  0.840820313, -3.695800781, -1.338867188,  1.060058594, -1.137207031},
{  0.503906250,  0.364746094, -0.418945313, -3.879882813, -6.270996094},
{  1.516601563,  2.371093750, -2.047363281, -1.240722656,  0.505371094},
{  0.909179688, -0.468750000, -3.236328125,  0.200195313,  2.872070313},
{ -1.217285156, -1.283203125, -1.953125000, -0.029296875,  3.516601563},
{ -1.304687500,  0.706054688,  0.750000000, -1.870605469,  0.602050781},
{ -2.588867188,  3.375000000,  0.775878906, -2.044433594,  1.789550781},
{ -1.687500000, -3.989257813, -3.764160156,  0.675781250,  2.293945313},
{ -2.294433594, -3.031738281, -5.457031250,  3.957031250,  8.217773438},
{  0.454101563,  3.419921875,  0.619628906, -4.383300781,  1.253417969},
{  2.270019531,  5.763671875,  1.680175781, -2.762207031,  0.585449219},
{  1.241210938, -0.089355469, -4.325683594, -3.894531250,  1.577148438},
{ -1.402343750, -0.981933594, -4.742675781, -4.094238281,  6.339355469},
{  1.506835938,  1.044921875, -1.796875000, -4.708496094, -1.414062500},
{ -3.715332031,  3.181152344, -1.114746094, -1.231445313,  3.091796875},
{ -1.627441406, -2.744140625, -4.458007813, -5.435058594,  2.706542969},
{ -0.198730469, -3.281738281, -8.528320313, -1.410644531,  5.648437500},
{  1.802734375,  3.318359375, -0.127929688, -5.295898438, -0.906250000},
{  3.552246094,  6.544921875, -1.459472656, -5.173339844,  2.410156250},
{  0.119140625, -1.083496094,  1.296875000,  1.843750000, -2.642578125},
{ -1.974121094, -2.897460938,  1.040527344,  0.421386719, -1.399414063},
{ -1.612304688,  0.851074219, -0.979492188, -0.062500000, -1.001953125},
{ -3.105957031,  1.631835938, -0.772949219, -0.010253906,  0.557617188},
{ -1.873535156, -0.894042969,  3.123535156,  1.242675781, -1.390625000},
{ -4.556640625, -3.187500000,  2.592285156,  0.969726563, -1.096191406},
{ -2.192382813,  0.365234375,  0.944824219, -1.478027344, -0.240722656},
{ -4.519042969,  2.620117188,  1.559082031, -2.193847656,  0.871093750},
{  2.335937500, -0.180664063,  0.911132813,  0.516113281, -0.922363281},
{  3.584960938, -1.313476563, -1.258300781,  0.330078125, -0.298339844},
{ -0.245117188,  1.091308594, -0.903320313, -0.867675781, -1.000488281},
{  0.493652344,  1.894531250, -1.203613281,  1.078613281, -0.074218750},
{  1.265625000,  1.381347656,  2.728515625,  1.386230469, -3.567382813},
{ -1.488769531, -2.401367188,  2.907714844,  4.492675781, -2.171386719},
{  0.340332031,  1.908203125,  2.831054688, -2.173339844, -2.267578125},
{ -1.035644531,  2.658203125, -1.254882813,  0.156738281, -0.586914063},
{  1.389648438, -1.018554688,  1.724609375,  0.276367188, -0.345703125},
{ -2.089355469,  0.463867188,  2.431640625,  1.830566406,  0.220703125},
{ -1.212890625,  1.709960938,  0.839355469, -0.083007813,  0.116210938},
{ -1.677246094,  0.128417969,  1.032226563, -0.979003906,  1.152832031},
{ -3.583007813, -0.589843750,  4.563964844, -0.593750000, -1.959472656},
{ -6.590820313, -0.214355469,  3.919921875, -2.066406250,  0.176269531},
{ -1.820800781,  2.652832031,  0.978515625, -2.308105469, -0.614746094},
{ -1.946289063,  3.780761719,  4.115722656, -1.802246094, -0.481933594},
{  2.538085938, -0.206542969,  0.561523438, -0.625488281,  0.398437500},
{  3.617675781,  2.006347656, -1.928222656,  1.313476563,  0.014648438},
{  0.608398438,  1.491699219, -0.017089844, -0.668945313, -0.120117188},
{ -0.727050781,  2.751464844, -0.331054688, -1.282714844,  1.547851563},
{  2.358398438, -2.238769531,  0.980468750, -0.518554688,  0.390136719},
{ -0.062988281,  0.350097656,  2.243164063,  7.293457031,  5.227539063},
{  0.203613281,  1.347167969,  0.903320313, -2.469238281, -0.562988281},
{ -1.897949219,  3.594238281, -2.816406250,  2.092285156,  0.325195313},
{  0.704589844, -0.458007813,  0.009765625, -1.034667969, -0.828613281},
{ -1.812500000, -1.661132813, -1.080078125,  0.053710938,  1.042968750},
{ -1.441406250,  0.005859375, -0.765625000, -1.708984375, -0.905761719},
{ -0.642089844, -0.845214844,  0.566406250, -0.272460938,  0.834472656},
{  0.042968750, -2.230957031,  0.094726563, -0.221679688, -1.443847656},
{ -1.386230469, -0.813476563, -0.133300781,  1.017578125, -0.075683594},
{ -0.092285156, -1.160156250,  0.812011719, -0.507812500, -1.195800781},
{ -1.387695313, -0.668457031,  0.310546875, -0.121093750, -1.307128906},
{  0.740722656,  0.038574219, -1.471191406, -1.791503906, -0.475097656},
{  0.934082031, -1.217285156, -2.593750000, -0.365722656,  0.620605469},
{ -1.417480469, -1.623046875, -1.833984375, -1.801757813, -0.893066406},
{ -1.422363281, -0.755371094, -1.347656250, -0.686523438,  0.548828125},
{  0.900390625, -0.895507813,  0.222656250,  0.344726563, -2.085937500},
{  0.228027344, -2.078125000, -0.932128906,  0.742675781,  0.553710938},
{ -0.062011719, -0.485351563, -0.311035156, -0.728027344, -3.170898438},
{  0.426269531, -0.998535156, -1.869140625, -1.363281250, -0.282226563},
{  1.128417969, -0.887207031,  1.285156250, -1.490234375,  0.960937500},
{  0.312988281,  0.583007813,  0.924316406,  2.005371094,  3.096679688},
{ -0.021972656,  0.584960938,  1.054687500, -0.707519531,  1.075683594},
{ -0.978515625,  0.836425781,  1.717773438,  1.294921875,  2.075683594},
{  1.433593750, -1.937500000,  0.625000000,  0.063964844, -0.720703125},
{  1.380371094,  0.003906250, -0.941406250,  1.297851563,  1.715332031},
{  1.562011719, -0.398437500,  1.312011719, -0.850097656, -0.687011719},
{  1.439453125,  1.967285156,  0.192382813, -0.123535156,  0.633789063},
{  2.092773438,  0.024902344, -2.200683594, -0.015625000, -0.321777344},
{  1.905761719,  2.756835938, -2.728515625, -1.265625000,  2.786621094},
{ -0.295898438,  0.602539063, -0.784667969, -2.532714844,  0.324218750},
{ -0.256347656,  1.767578125, -1.070312500, -1.233886719,  0.833496094},
{  2.098144531, -1.587402344, -1.114746094,  0.396484375, -1.105468750},
{  2.814941406,  0.257812500, -1.604980469,  0.660156250,  0.816406250},
{  1.335449219,  0.605957031, -0.538574219, -1.598144531, -1.663574219},
{  1.969238281,  0.804687500, -1.447753906, -0.573242188,  0.705078125},
{  0.036132813,  0.448242188,  0.976074219,  0.446777344, -0.500976563},
{ -1.218750000, -0.783691406,  0.993164063,  1.440429688,  0.111816406},
{ -1.058593750,  0.994628906,  0.007324219, -0.617187500, -0.101562500},
{ -1.734375000,  0.747070313,  0.283691406,  0.728027344,  0.469726563},
{ -1.275878906, -1.141601563,  1.768066406, -0.726562500, -1.066894531},
{ -0.853027344,  0.039550781,  2.704101563,  0.699218750, -1.102050781},
{ -0.497558594,  0.423339844,  0.104492188, -1.115234375, -0.737304688},
{ -0.822265625,  1.375000000, -0.111816406,  1.245605469, -0.678222656},
{  1.321777344,  0.246093750,  0.233886719,  1.358886719, -0.492675781},
{  1.229003906, -0.726074219, -0.779296875,  0.303222656,  0.941894531},
{ -0.072265625,  1.077148438, -2.093750000,  0.630859375, -0.684082031},
{ -0.257324219,  0.606933594, -1.333496094,  0.932128906,  0.625000000},
{  1.049316406, -0.732910156,  1.800781250,  0.297851563, -2.241699219},
{  1.614257813, -1.645019531,  0.915527344,  1.775390625, -0.594238281},
{  1.256835938,  1.227050781,  0.707519531, -1.500976563, -2.431152344},
{  0.397460938,  0.891601563, -1.219238281,  2.067382813, -1.990722656},
{  0.812500000, -0.107421875,  1.668945313,  0.489257813,  0.544433594},
{  0.381347656,  0.809570313,  1.913574219,  2.993164063,  1.533203125},
{  0.560546875,  1.984863281,  0.740234375,  0.397949219,  0.097167969},
{  0.581542969,  1.215332031,  1.250488281,  1.182128906,  1.192871094},
{  0.375976563, -2.888183594,  2.692871094, -0.179687500, -1.562011719},
{  0.581054688,  0.511230469,  1.827148438,  3.382324219, -1.020019531},
{  0.142578125,  1.513183594,  2.103515625, -0.370117188, -1.198730469},
{  0.255371094,  1.914550781,  1.974609375,  0.676757813,  0.041503906},
{  2.132324219,  0.491210938, -0.611328125, -0.715820313, -0.675292969},
{  1.880859375,  0.770996094, -0.037597656,  1.007812500,  0.423828125},
{  2.494628906,  1.425292969, -0.098632813,  0.175292969, -0.248535156},
{  1.782226563,  1.565429688,  1.124511719,  0.826660156,  0.632812500},
{  1.418457031, -1.907714844,  0.111816406, -0.583984375, -1.138671875},
{  2.918457031, -1.750488281,  0.393066406,  1.867675781, -1.532226563},
{  1.829101563, -0.295898438,  0.025878906, -0.131347656, -1.611816406},
{  0.295898438,  0.985351563, -0.642578125,  1.984375000,  0.194335938}
};


real cb_gain[] = {
     0.515625,  .90234375,  1.579101563,  2.763427734,
    -0.515625, -.90234375, -1.579101563, -2.763427734
};

/* Double Gains: */
real cb_gain2[] = {
     1.031250,  1.8046875, 3.158203126,  5.526855468,
    -1.031250, -1.8046875, -3.158203126, -5.526855468};


/* Midpoints: */
real cb_gain_mid[] = {
     0.708984375,  1.240722656,  2.171264649, 0, 
    -0.708984375, -1.240722656, -2.171264649, 0};

/* Squared Gains: */
real cb_gain_sq[] = {
    0.26586914, 0.814224243, 2.493561746, 7.636532841,
    0.26586914, 0.814224243, 2.493561746, 7.636532841};


real WIN_MEM hw_gain[] = {
 0.583953857, 0.605346680, 0.627502441, 0.650482178, 0.674316406,
 0.699005127, 0.724578857, 0.751129150, 0.778625488, 0.807128906,
 0.836669922, 0.867309570, 0.899078369, 0.932006836, 0.961486816,
 0.982757568, 0.995635986, 1.000000000, 0.995819092, 0.983154297,
 0.962066650, 0.932769775, 0.895507812, 0.850585938, 0.798400879,
 0.739379883, 0.674072266, 0.602996826, 0.526763916, 0.446014404,
 0.361480713, 0.273834229, 0.183868408, 0.092346191
 };

real WIN_MEM hw_percw[] = {
 0.581085205, 0.591217041, 0.601562500, 0.612091064, 0.622772217,
 0.633666992, 0.644744873, 0.656005859, 0.667480469, 0.679138184,
 0.691009521, 0.703094482, 0.715393066, 0.727874756, 0.740600586,
 0.753570557, 0.766723633, 0.780120850, 0.793762207, 0.807647705,
 0.821746826, 0.836120605, 0.850738525, 0.865600586, 0.880737305,
 0.896148682, 0.911804199, 0.927734375, 0.943939209, 0.960449219,
 0.975372314, 0.986816406, 0.994720459, 0.999084473, 0.999847412,
 0.997070312, 0.990722656, 0.980865479, 0.967468262, 0.950622559,
 0.930389404, 0.906829834, 0.880035400, 0.850097656, 0.817108154,
 0.781219482, 0.742523193, 0.701171875, 0.657348633, 0.611145020,
 0.562774658, 0.512390137, 0.460174561, 0.406311035, 0.351013184,
 0.294433594, 0.236816406, 0.178375244, 0.119262695, 0.059722900
 };

real WIN_MEM hw_synth[] = {
 0.602020264, 0.606384277, 0.610748291, 0.615142822, 0.619598389,
 0.624084473, 0.628570557, 0.633117676, 0.637695312, 0.642272949,
 0.646911621, 0.651580811, 0.656280518, 0.661041260, 0.665802002,
 0.670593262, 0.675445557, 0.680328369, 0.685241699, 0.690185547,
 0.695159912, 0.700164795, 0.705230713, 0.710327148, 0.715454102,
 0.720611572, 0.725830078, 0.731048584, 0.736328125, 0.741638184,
 0.747009277, 0.752380371, 0.757812500, 0.763305664, 0.768798828,
 0.774353027, 0.779937744, 0.785583496, 0.791229248, 0.796936035,
 0.802703857, 0.808502197, 0.814331055, 0.820220947, 0.826141357,
 0.832092285, 0.838104248, 0.844146729, 0.850250244, 0.856384277,
 0.862548828, 0.868774414, 0.875061035, 0.881378174, 0.887725830,
 0.894134521, 0.900604248, 0.907104492, 0.913635254, 0.920227051,
 0.926879883, 0.933563232, 0.940307617, 0.947082520, 0.953918457,
 0.960815430, 0.967742920, 0.974731445, 0.981781006, 0.988861084,
 0.994842529, 0.998565674, 0.999969482, 0.999114990, 0.996002197,
 0.990600586, 0.982910156, 0.973022461, 0.960876465, 0.946533203,
 0.930053711, 0.911437988, 0.890747070, 0.868041992, 0.843322754,
 0.816680908, 0.788208008, 0.757904053, 0.725891113, 0.692199707,
 0.656921387, 0.620178223, 0.582000732, 0.542480469, 0.501739502,
 0.459838867, 0.416900635, 0.373016357, 0.328277588, 0.282775879,
 0.236663818, 0.189971924, 0.142852783, 0.095428467, 0.047760010
 };

#pragma warning( default:4244 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\fast.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       fast.h
//
//--------------------------------------------------------------------------

#ifndef FAST_H
#define FAST_H

#define PROD5(A,B,R) \
{ typeof (R) __x,__y,__t;	\
  typeof (&A[0]) __pa=A;	\
  typeof (&B[0]) __pb=B;	\
                          __x=*__pa++;__y=*__pb++;	\
  R=R-R;    __t=__x*__y;  __x=*__pa++;__y=*__pb++;	\
  R+=__t;   __t=__x*__y;  __x=*__pa++;__y=*__pb++;	\
  R+=__t;   __t=__x*__y;  __x=*__pa++;__y=*__pb++;	\
  R+=__t;   __t=__x*__y;  __x=*__pa++;__y=*__pb++;	\
  R+=__t;   __t=__x*__y;	\
  R+=__t;}


/* Autocorrelation : R[0:K] is autocorrelation of X[M:N-1]  i.e.
      R[k] = Sum X[i]*X[i-k]   for    M<=i<N     */

#define AUTOCORR(X,R,K,M,N) \
{\
    int  ii,jj;\
    for(ii=0; ii<=K; ii++) {\
	R[ii] = 0;\
	for(jj=M; jj<N; jj++) R[ii] += X[jj]*X[jj-ii];}}

/* if AC is autocorrelation of X (as in above) , then
   R[i] = D * R[i] + AC[i]    */

#define RECACORR(X,R,K,M,N,D)	\
{   int __k,__i,__M1=M+1;	\
    typeof (&R[0]) __rp=R;	\
    for(__k=0; __k<=K; __k++) {	\
	typeof (*R) __corr, __t;	\
	typeof (&X[0]) __xip=X+M, __xkp=__xip-__k;	\
	typeof(X[0]) __xi,__xk;	\
	__corr=__corr-__corr;	\
	__xi=*__xip++;	\
	__xk=*__xkp++;	\
	for(__i=__M1;__i<N;__i++) {	\
	    __t=__xi*__xk; __xi=*__xip++;	\
	    __corr+=__t; __xk=*__xkp++;	\
	}	\
	__t=__xi*__xk;	\
	__corr+=__t;	\
	__corr=*__rp*(D)+__corr;	\
	*__rp++=__corr;}}


/** Z[i] = X[i]*Y[i] **/

__inline void VPROD( float *X, float *Y, float *Z, int N )
{
    float *xp = X, *yp = Y, *zp = Z, xi, yi, zi;
    int   i;

    xi = *xp++;
    yi = *yp++;

    for (i = 1; i < N; i++)
    {
        zi=xi*yi;
        xi=*xp++;
        yi=*yp++;
        *zp++=zi;
    }
    zi = xi * yi;
    *zp = zi;
}

#if 0

#define VPROD(X,Y,Z,N)	\
{   typeof (&X[0]) __xp=X;	\
    typeof (&Y[0]) __yp=Y;	\
    typeof (&Z[0]) __zp=Z;	\
    int i;	\
    typeof (X[0]) __xi=*__xp++;	\
    typeof (Y[0]) __yi=*__yp++;	\
    typeof (Z[0]) __zi;	\
    for(i=1;i<N;i++) {	\
	__zi=__xi*__yi;	\
	__xi=*__xp++;	\
	__yi=*__yp++;	\
	*__zp++=__zi;}	\
    __zi=__xi*__yi;	\
    *__zp=__zi;}
#endif

__inline void RSHIFT( float *START, int LENGTH, int SHIFT )
{
	int   i;
	float *from, *to;

	from = &START[ LENGTH-1 ];
	to = &START[ LENGTH + SHIFT -1 ];

	for (i = 0; i < LENGTH; i++)
		*to-- = *from--;
}

#if 0
#define RSHIFT(START,LENGTH,SHIFT) \
{ typeof (&(START)[0]) __from = &(START)[LENGTH-1]; \
  typeof (&(START)[0]) __to = &(START)[LENGTH+SHIFT-1]; \
  int __i; for(__i=0; __i<LENGTH; __i++)      *__to-- = *__from--;\
}
#endif


/** Must have at least two elements, i.e. N >= 2.
  computes sum(x[i]*y[i]) **/

__inline float DOTPROD( float *X, float *Y, int N )
{
	int  i ;

    double  r = 0.0, t;
	float   x1, y1, *xp = X, *yp = Y;

	x1 = *xp++;
	y1 = *yp++;

	t = x1 * y1;
	x1 = *xp++;
	y1 = *yp++;

	for (i = 0; i < N - 2; i++)
	{
		r += t; 
		t = x1 * y1;
		x1 = *xp++; 
		y1 = *yp++;
    }
    r += t; 
	t = x1 * y1;
	r += t;

	return r; 
}

#if 0

#define DOTPROD(X,Y,N) \
({ int __i;	\
  typeof((X)[0]*(Y)[0]) __r=0, __t;	\
  typeof ((X)[0]) __x1;	\
  typeof ((Y)[0]) __y1;	\
  typeof (&(X)[0]) __xp = &(X)[0]; \
  typeof (&(Y)[0]) __yp = &(Y)[0]; \
                              __x1=*__xp++; __y1=*__yp++; 	\
             __t=__x1*__y1;   __x1=*__xp++; __y1=*__yp++; 	\
   for(__i=0; __i<(N)-2; __i++) {	\
   __r+=__t; __t=__x1*__y1;   __x1=*__xp++; __y1=*__yp++; }	\
   __r+=__t; __t=__x1*__y1;   	\
   __r+=__t; __r;})
#endif

#endif /*FAST_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\iphone.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       iphone.h
//
//--------------------------------------------------------------------------

typedef struct
{
    HWAVEIN     hwi;
    HWAVEOUT    hwo;
    OVERLAPPED  ovWrite, ovRead;
    SOCKET      sockHost, sockClient;
   
} IPHONE, *PIPHONE;

#define IPPORT_IPHONE  5001

BOOL iphoneInit
(
    PIPHONE pIPhone
);

ULONG iphoneSend
(
    PIPHONE pIPhone,
    PUCHAR  pBuffer,
    ULONG   cbBuffer
);

ULONG iphoneRecv
(
    PIPHONE pIPhone,
    PUCHAR  pBuffer,
    ULONG   cbBuffer
);

BOOL iphoneWaitForCall
(
    PIPHONE pIPhone
);

BOOL iphonePlaceCall
(
    PIPHONE pIPhone,
    PSTR    pszHost
);

BOOL iphoneHangup
(
    PIPHONE pIPhone
);                

VOID iphoneCleanup
(
    PIPHONE pIPhone
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\encode.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       encode.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/


/* Real multitasking works on a DSP target only, on other platform
   it is simulated */

#include <stdio.h>
#include <signal.h>

#include "common.h"
#include "parm.h"
#include "prototyp.h"

void init_encoder();
void encoder();
void encode_vector(int ignore, PSHORT psIndex );
void adapt_frame();

static int dec_end;	/* Index of the end of the decoded speech */
int encoder_done = 0;

static real thequeue[QSIZE];
static real * volatile vector_end;
static real rscale=(real) 0.125;  /* Scaling factor for input */

void ldcelpEncode
(
    PSHORT  pBuffer,
    ULONG   cSamples,
    PSHORT  pIndex,
    PULONG  pcIndices
)
{
    int vnum,i, j = 0;

    EnterCriticalSection( &csLDCELP );

    ffase = 1;
    init_encoder();

    *pcIndices = 0 ;

    for(i=0; i<QSIZE; i++) 
	    thequeue[i]=(real) 0.0;

    for(vnum=0; 
	    cSamples;
	    vnum++) 
    {
        for (i = 0; (i < IDIM) && cSamples; i++)
        {
            thequeue[ (vnum * IDIM) % QSIZE + i ] =
                rscale * (real) pBuffer[ j++ ];
            cSamples--;
        }

	    vector_end = thequeue+(vnum*IDIM)%QSIZE+IDIM;
	    encode_vector( 0, &pIndex[ (*pcIndices)++ ] );
	    adapt_frame();
    }

    LeaveCriticalSection( &csLDCELP );
}

void init_encoder()
{
    int i;

    init_pwf_adapter(pwf_z_coeff, pwf_p_coeff);
    pwf_z_coeff_next[0] = pwf_p_coeff_next[0] = (real) 1.0;
    pwf_z_coeff_obsolete_p = 0;
    init_bsf_adapter(sf_coeff);
    sf_coeff_next[0] = (real) 1.0;
    sf_coeff_obsolete_p = 0;
    init_gain_adapter(gp_coeff);
    init_gain_buf();
    gp_coeff_next[0] = (real) 1.0;
    gp_coeff_next[1] = (real) -1.0;
    gp_coeff_obsolete_p = 0;
    vector_end=thequeue;
    ZARR(imp_resp);
    imp_resp[0] = (real) 1.0;
    shape_conv(imp_resp, shape_energy);
}

void encode_vector(int ignore, PSHORT psIndex )
{
    int ix;	/* Computed Codebook Index */
    int vx;    	/* Index of Recently Read Vector  */
    int lgx;	/* Logarithmic Gain Index */

    static real QMEM *vector;	/* recently read vector in the queue */

    static real
	zero_response[IDIM],
	weighted_speech[IDIM],
	target[IDIM],
	normtarg[IDIM],
	cb_vec[IDIM],
	pn[IDIM];
    static real	gain =(real) 1.0, scale=(real) 1.0;
    
    vector = vector_end - IDIM;
    if (vector < thequeue)
	vector += QSIZE;
    vx = vector-thequeue;
    UPDATE(pwf_z_coeff);	/* Copy new coeff if flag set */
    UPDATE(pwf_p_coeff);
    pwfilter2(vector, weighted_speech);
    UPDATE(sf_coeff);
    zresp(zero_response);
    sub_sig(weighted_speech, zero_response, target);
    UPDATE(gp_coeff);
    gain = predict_gain();
    scale = (real) 1.0 / gain;
    sig_scale(scale, target, normtarg);
    UPDATE(imp_resp);
    trev_conv(imp_resp, normtarg, pn);
    UPDATE(shape_energy);
    ix = cb_index(pn);
    *psIndex = (SHORT) ix;
    cb_excitation(ix, cb_vec);
    sig_scale(gain, cb_vec, qspeech+vx);
    lgx = vx/IDIM;
    update_gain(qspeech+vx, log_gains + lgx);
    mem_update(qspeech+vx, synspeech+vx);
    dec_end = vx+IDIM;
    if (dec_end >= QSIZE)
	dec_end -= QSIZE;
    NEXT_FFASE;			/* Update vector counter  */
}

/* Update the filter coeff if we are at the correct vector in the frame */
/* ffase is the vector count (1-4) within the current frame */
void adapt_frame()
{
    static real
	input [NUPDATE*IDIM],
	synth [NUPDATE*IDIM],
	lg [NUPDATE];
    int gx;	/* Index for log_gains, cycle end */

    /* Backward syn. filter coeff update.  Occurs after full frame (before
       first vector) but not used until the third vector of the frame */
    FFASE(1)
    {
      CIRCOPY(synth,synspeech,dec_end,NUPDATE*IDIM,QSIZE);
      bsf_adapter (synth, sf_coeff_next); /* Compute then new coeff */
    }

    /* Before third vector of frame */
    FFASE(3)
      sf_coeff_obsolete_p = 1;	/* Copy coeff computed above(2 frames later)*/

    /* Gain coeff update before second vector of frame */
    FFASE(2)
    {
	gx = dec_end/IDIM;
	CIRCOPY(lg, log_gains, gx, NUPDATE, QSIZE/IDIM);
	gain_adapter(lg, gp_coeff_next);
	gp_coeff_obsolete_p = 1;
    }

    FFASE(3)
    {
	CIRCOPY(input,thequeue,dec_end,NUPDATE*IDIM,QSIZE);
	pwf_adapter(input, pwf_z_coeff_next, pwf_p_coeff_next);
	pwf_z_coeff_obsolete_p = 1;
	pwf_p_coeff_obsolete_p = 1;
    }
	
    FFASE(3)
    {
	iresp_vcalc(sf_coeff_next, pwf_z_coeff_next, pwf_p_coeff_next, 
		    imp_resp_next);
	shape_conv(imp_resp_next, shape_energy_next);
	shape_energy_obsolete_p = 1;
	imp_resp_obsolete_p = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\decode.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       decode.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/

#include <stdio.h>
#include <signal.h>
#include "common.h"
#include "parm.h"
#include "prototyp.h"

void init_decoder();
void decoder();
void decode_vector(int ignore, int ix);
void adapt_decoder();

int postfiltering_p = 0;

static int d_vec_start;	/* Index of the start of the decoded speech vector */
static int d_vec_end;	/* Index of the end   of the decoded speech vector */
static int w_vec_start;	/* Index of the start of vector being written */
static int w_vec_end;	/* Index of the end   of vector being written */

static real thequeue[QSIZE];
static real * volatile vector_end;
static real rscale=(real) 0.125;  /* Scaling factor for input */

ULONG ldcelpDecode
(
    PSHORT  pIndex,
    ULONG   cIndices,
    PSHORT  pBuffer,
    PULONG  pcSamples,
    ULONG   cbMaxSamples
)
{
    int i, j = 0;

    *pcSamples = 0 ;

    EnterCriticalSection( &csLDCELP );

    ffase = 1;
    for(i=0; i<QSIZE; i++) 
	    thequeue[i]=(real) 0.0;
    init_decoder();
    cbMaxSamples = (cbMaxSamples / IDIM) * IDIM;

    for (w_vec_start=0; 
         cbMaxSamples && (j < (int) cIndices); 
         j++, w_vec_start += IDIM) 
    {
        float xx;

	    if (w_vec_start >= QSIZE)
	        w_vec_start = 0;
	    w_vec_end = w_vec_start;
	    vector_end = thequeue + w_vec_end;
	    decode_vector(0, pIndex[ j ]);
	    w_vec_end = w_vec_start + IDIM;

	    if (w_vec_end >= QSIZE)
	        w_vec_end = 0;

        for (i = 0; (i < IDIM) && cbMaxSamples; i++)
        {
            xx = thequeue[ w_vec_end + i ] / rscale;

	        if (xx > 0.0)
            {
	            if (xx > 32767.0)
	                xx = (real) 32767.0;
    	        else
	                xx += (real) 0.5;
            }
	        else
            {
	            if (xx < -32768.0)
	                xx = (real) -32768.0;
	            else
	                xx -= (real) 0.5;
            }

            pBuffer[ (*pcSamples)++ ] = (SHORT) xx;
            cbMaxSamples--;
        }

	    adapt_decoder();
    }

    LeaveCriticalSection( &csLDCELP );

    return j;
}

void init_decoder()
{
    init_bsf_adapter(sf_coeff);
    sf_coeff_next[0] = (real) 1.0;
    sf_coeff_obsolete_p = 0;
    init_gain_adapter(gp_coeff);
    init_gain_buf();
    gp_coeff_next[0] = (real) 1.0;
    gp_coeff_next[1] = (real) -1.0;
    gp_coeff_obsolete_p = 0;
    vector_end=thequeue;
}

void decode_vector(int ignore, int ix)
{
    int lgx;	/* Log Gains INdex */
    static real zero_response[IDIM], cb_vec[IDIM];
    static real pf_speech[IDIM];
    real qs[NUPDATE*IDIM];

    static real	gain = (real) 1.0;
    w_vec_end = vector_end - thequeue;
    d_vec_start = w_vec_end + IDIM;
    if (d_vec_start >= QSIZE)
	d_vec_start -= QSIZE;

    UPDATE(sf_coeff);
    zresp(zero_response);
    cb_excitation(ix, cb_vec);
    UPDATE(gp_coeff);
    gain = predict_gain();
    sig_scale(gain, cb_vec, qspeech+d_vec_start);
    lgx = d_vec_start/IDIM;
    update_gain(qspeech+d_vec_start, log_gains+lgx);
    mem_update(qspeech+d_vec_start, synspeech+d_vec_start);
    d_vec_end = d_vec_start + IDIM;
    if (d_vec_end >= QSIZE)
	d_vec_end -= QSIZE;
    if (postfiltering_p) {
      inv_filter(synspeech+d_vec_start);
      FFASE(3) 
	{
	  CIRCOPY(qs, synspeech, d_vec_end, NUPDATE*IDIM, QSIZE);
	  psf_adapter(qs);
	}
      FFASE(1)
	compute_sh_coeff();
      postfilter(synspeech+d_vec_start, pf_speech);
      RCOPY(pf_speech, thequeue+d_vec_start, IDIM);
    }
    else {
	RCOPY(synspeech+d_vec_start, thequeue+d_vec_start, IDIM);
    }
    NEXT_FFASE;
}

void adapt_decoder()
{
    real
	synth [NUPDATE*IDIM],
	lg    [NUPDATE];
    int
	gx; /* gain index */
    
    
    FFASE(1)
    {     
	CIRCOPY(synth, synspeech, d_vec_end, NUPDATE*IDIM, QSIZE);
	bsf_adapter (synth, sf_coeff_next);
    }
    FFASE(2)
    {
	gx = d_vec_end / IDIM;
	CIRCOPY(lg, log_gains, gx, NUPDATE, QSIZE/IDIM);
	gain_adapter(lg, gp_coeff_next);
	gp_coeff_obsolete_p = 1;
    }
    FFASE(3)
      sf_coeff_obsolete_p = 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\global.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       global.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/

#include "common.h"

/*
  This data is used by both encoder and decoder. We have to define it 
  once for cases when encoder and decoder are linked together (like ezplay).
  */

ACLASS real sf_coeff[LPC+1];
ACLASS real gp_coeff[LPCLG+1];
ACLASS real pwf_z_coeff[LPCW+1];
ACLASS real pwf_p_coeff[LPCW+1];
ACLASS real shape_energy[NCWD];
ACLASS real imp_resp[IDIM];

ACLASS real sf_coeff_next[LPC+1];
ACLASS real gp_coeff_next[LPCLG+1];
ACLASS real pwf_z_coeff_next[LPCW+1];
ACLASS real pwf_p_coeff_next[LPCW+1];
ACLASS real shape_energy_next[NCWD];
ACLASS real imp_resp_next[IDIM];

ACLASS int sf_coeff_obsolete_p;
ACLASS int gp_coeff_obsolete_p;
ACLASS int pwf_z_coeff_obsolete_p;
ACLASS int pwf_p_coeff_obsolete_p;
ACLASS int shape_energy_obsolete_p;
ACLASS int imp_resp_obsolete_p;
CRITICAL_SECTION csLDCELP;

real synspeech [QSIZE];		/* Synthesized Speech */
real qspeech [QSIZE];		/* Quantized  Speech */
real log_gains[QSIZE/IDIM];	/* Logarithm of Gains */

int VOLATILE ffase = -4;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\filters.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       filters.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/


/********************************* Perceptual Weighting Filter **/

#include "common.h"
#include "parm.h"
#include "fast.h"
#include "prototyp.h"

/* Filter Memory in reverse order, i.e. firmem[0] is the most recent */

static real firmem[LPCW+IDIM];
static real iirmem[LPCW+IDIM];


void pwfilter2(real QMEM input[], real output[])
{
    int k;
    real out;

    RSHIFT(firmem, LPCW, IDIM);
    for(k=0; k<IDIM; k++)
	firmem[k] = input[IDIM-1-k];
    RSHIFT(iirmem, LPCW, IDIM);

    for (k=0; k<IDIM; k++) {
	out = firmem[IDIM-1-k];		/* pwf_z_coeff[0] is always 1.0 */
	out += DOTPROD(firmem+IDIM-k, pwf_z_coeff+1, LPCW);
	out -= DOTPROD(iirmem+IDIM-k, pwf_p_coeff+1, LPCW);
	iirmem[IDIM-1-k] = out;
	output[k] = out;
    }
}

/*  Synthesis and Perceptual Weighting Filter. */

#define STATE_MEM
#define ZF_MEM   
#define ZI_MEM   

real STATE_MEM statelpc[LPC+IDIM];
real ZF_MEM    zirwfir[LPCW];
real ZI_MEM    zirwiir[LPCW];

/** Updateable coefficients **/

void sf_zresp(real []);
void pwf_zresp(real [], real[]);

void sf_zresp(real output[])
{
  int k,j;

#if PIPELINE
  for(j=LPC-1; j>=0; j--)
      statelpc[j+IDIM] = statelpc[j];

{
    real STATE_MEM * sjpk = statelpc + LPC+IDIM-1; 
    real out = 0.0;
    for (k=0; k<IDIM; k++) {
      real COEFF_MEM *ajp = sf_coeff+LPC;
      real sj, aj;
      real STATE_MEM *sjp;
      out = 0.0;
      sjp = sjpk;
      sj = *sjp--;
      aj = *ajp--;
      for (j=LPC-2; j>=0; j--) {
	  out -= sj*aj;
	  sj = *sjp--;
	  aj = *ajp--;
      }
      output[k] = out - sj*aj;
      *sjp--= output[k];
      sjpk--;
  }
}
#else
/** This is un-pipelined version of the above. Kept for reference **/
    for(j=LPC-1; j>=0; j--)
      statelpc[j+IDIM] = statelpc[j];
  for (k=0; k<IDIM; k++) {
      real out = 0.0, sj, aj;
      sj = statelpc[LPC+IDIM-k-1];
      aj = sf_coeff[LPC];
      for (j=LPC-2; j>=1; j--) {
	  out -= sj*aj;
	  sj = statelpc[IDIM-k+j];
	  aj = sf_coeff[j+1];
      }
      output[k] = out - sj*aj-statelpc[IDIM-k] * sf_coeff[1];
      statelpc[IDIM-1-k] = output[k];
  }
return;
#endif
}

void
pwf_zresp(real input[], real output[])
{
   int j,k;
   real tmp;

#if PIPELINE
   for (k=0; k<IDIM; k++) {
   	tmp = input[k];
   	for (j=LPCW-1; j>=1; j--) {
   	   input[k] += zirwfir[j] * pwf_z_coeff[j+1];
   	   zirwfir[j] = zirwfir[j-1];
   	}
	input[k] += zirwfir[0] * pwf_z_coeff[1];
   	zirwfir[0] = tmp;
   	for (j=LPCW-1; j>=1; j--) {
   	    input[k] -= zirwiir[j] * pwf_p_coeff[j+1];
   	    zirwiir[j] = zirwiir[j-1];
   	}
   	output[k] = input[k] - zirwiir[0] * pwf_p_coeff[1];
   	zirwiir[0] = output[k];
   }
#else
   /** Un-pipelined version, kept for reference **/
   for (k=0; k<IDIM; k++) {
   	tmp = input[k];
   	for (j=LPCW-1; j>=1; j--) {
   	   input[k] += zirwfir[j] * pwf_z_coeff[j+1];
   	   zirwfir[j] = zirwfir[j-1];
   	}
	input[k] += zirwfir[0] * pwf_z_coeff[1];
   	zirwfir[0] = tmp;
   	for (j=LPCW-1; j>=1; j--) {
   	    input[k] -= zirwiir[j] * pwf_p_coeff[j+1];
   	    zirwiir[j] = zirwiir[j-1];
   	}
   	output[k] = input[k] - zirwiir[0] * pwf_p_coeff[1];
   	zirwiir[0] = output[k];
   }
#endif   
}


void zresp(real output[])
{
    real temp[IDIM];
    sf_zresp(temp);
    pwf_zresp(temp, output);
}


void mem_update (real input[], real output[])
{
    int i,k;
    real temp[IDIM], a0, a1, a2;
    real STATE_MEM *t2 = zirwfir;
    t2[0] = temp[0] = input[0];
    for (k=1; k<IDIM; k++) {
	a0 = input[k];
	a1 = a2 = 0.0;
	for (i=k; i>= 1; i--) {
	    t2[i] = t2[i-1];
	    temp[i] = temp[i-1];
	    a0 -=   sf_coeff[i] * t2[i];
	    a1 += pwf_z_coeff[i] * t2[i];
	    a2 -= pwf_p_coeff[i] * temp[i];
	}
	t2[0] = a0;
	temp[0] = a0+a1+a2;
    }
    
    for (k=0; k<IDIM; k++) {
   	statelpc[k] += t2[k];
   	if (statelpc[k] > Max)
	    statelpc[k] = Max;
        else if (statelpc[k] < Min)
	    statelpc[k] = Min;
        zirwiir[k] += temp[k];
    }
    for (i=0; i<LPCW; i++)
   	zirwfir[i] = statelpc[i];
    for (k=0; k<IDIM; k++)
	output[k] = statelpc[IDIM-1-k];
    return;
}

#include <math.h>

# define LOG10(X) log10(X)
# define EXP10(X) pow(10,X)

/*********************************************** The Gain Predictor */

extern real COEFF_MEM gp_coeff[];
static real gain_input[LPCLG];

static real log_rms(real input[])
{
    real etrms=0.0;
    int k;
    for(k=0; k<IDIM; k++)
	etrms += input[k]*input[k];
    etrms /= IDIM;
    if (etrms<1.0)
	etrms = 1.0;
    etrms = 10.0*log10(etrms);
    return (etrms);
}

real predict_gain()
{
  int i;
  real new_gain = GOFF;
  real temp;

  for (i=1;i<=LPCLG;i++)
    {
      temp = gp_coeff[i] * gain_input[LPCLG-i];
      new_gain -= temp;
    }
  if (new_gain <  0.0) new_gain = 0.0;
  if (new_gain > 60.0) new_gain = 60.0;
  new_gain = EXP10(0.05*new_gain);
  return (new_gain);
}

void update_gain(real input[], real *lgp)
{
    int i;

    *lgp = log_rms(input) - GOFF;
    for (i=0; i<LPCLG-1; i++)
      gain_input[i] = gain_input[i+1];
    gain_input[LPCLG-1] = *lgp;
}

void init_gain_buf()
{
  int i;

  for(i=0;i<LPCLG;i++)
    gain_input[i] = -GOFF;
  for(i=0;i<QSIZE/IDIM;i++)
    log_gains[i] = -GOFF;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\parm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       parm.h
//
//--------------------------------------------------------------------------

#ifndef PARM_H
#define PARM_H

#define AGCFAC 	0.99	/* Adaptive Gain Control FACtor */
#define FAC    	(253./256.)
#define FACGP	(29./32.)
#define DIMINV	0.2	/* Inverse if IDIM */
#define IDIM	5	/* Size of Speech Vector */
#define GOFF	32	/* Gain (Logarithmic) Offset */
#define KPDELTA	6
#define KPMIN	20	/* Min Pitch Period ( 400 Hz) */
#define KPMAX	140	/* Max Pitch Period (~ 57 Hz) */
#define LPC	50	/* # of LPC Coeff. in Sinthesys Filter */
#define LPCLG	10	/* # of LPC Coeff. in Gain Predictor */
#define LPCW	10	/* # of LPC Coeff. in Weighting Filter */
#define NCWD	128	/* Shape Codebook Size */
#define NFRSZ	20	/* Frame Size */


#define NG	8	/* Gain Codebook Size */
#define NONR	35	/* Size of Nonrecursive Part of Synth. Adapter */ 
#define NONRLG	20	/* ------------------------- of Gain Adapter */
#define NONRW	30	/* ------------------------- of Weighting Filter */
#define NPWSZ	100	/* Pitch Predictor Window Size */
#define NUPDATE	4	/* Predictor Update Period */
#define PPFTH	0.6
#define PPFZCF	0.15
#define SPFPCF	0.75
#define SPFZCF	0.65
#define TAPTH	0.4
#define TILTF	0.15
#define WNCF	(257./256.)
#define WPCF	0.6
#define WZCF	0.9

#define BIG 10.e+30

#define Max 4095.0
#define Min (-4095.0)

#endif /*PARM_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\qsize.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       qsize.h
//
//--------------------------------------------------------------------------

#ifndef QSIZE_H
#define QSIZE_H

/* Size of the queue (I/O buffer) */

//#define QSIZE 64
#define QSIZE 60

#endif /*QSIZE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\postfil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       postfil.c
//
//--------------------------------------------------------------------------

/*************************************************************************/
/*                                                                       */
/*                            LD-CELP  G.728                             */
/*                                                                       */
/*    Low-Delay Code Excitation Linear Prediction speech compression.    */
/*                                                                       */
/*    Code edited by Michael Concannon.                                  */
/*    Based on code written by Alex Zatsman, Analog Devices 1993         */
/*                                                                       */
/*************************************************************************/

/* Postfilter of LD-CELP Decoder */

#include "common.h"
#include "prototyp.h"
#include "parm.h"
#include "data.h"

#define ABS(X) ((X)<0.0?(-X):(X))

/*  Parameters from the adapter: */

#define SPORDER 10

#define DECIM 4
#define PMSIZE  (NPWSZ+KPMAX)	/* Postfilter Memory SIZE */
#define PDMSIZE (PMSIZE/DECIM)  /* Post. Decim. Memory SIZE */
#define DPERMAX (KPMAX/DECIM)	/* Max. Decimated Period */
#define DPERMIN (KPMIN/DECIM)	/* Min. Decimated Period */
#define SHIFTSZ (KPMAX+NPWSZ-NFRSZ+IDIM)


static real tap_mem[KPMAX+NPWSZ+IDIM]; /* Post-Filter Memory for syn. sp. */

int  pitch_period = 50;

real pitch_tap=0.0;

real pitch_gain=1;

static real shzscale[SPORDER+1]= /* Precomputed Scales for IIR coefficients */
{ 1.0, 0.6500244140625, 0.4224853515625, 0.27459716796875, 
  0.17852783203125, 0.11602783203125, 0.075439453125, 
  0.04901123046875, 0.0318603515625, 0.02069091796875, 0.01348876953125};

static real shpscale[SPORDER+1]= /* Precomputed Scales for FIR Coefficients */
{ 1.0, 0.75, 0.5625, 0.421875, 0.31640625, 0.2373046875, 0.177978515625, 
  0.13348388671875, 0.10009765625, 0.0750732421875, 0.05633544921875};

static real
    shpcoef[SPORDER+1],	/* Short Term Filter (Poles/IIR) Coefficients */
    shzcoef[SPORDER+1], /* Short Term Filter (Zeros/FIR) Coefficients */
    tiltz,
    fil_mem[PMSIZE];	/* Post-Filter Memory for residual */

static void  longterm(real[], real[]);
static void shortterm(real[], real[]);

/* Compute sum of absolute values of vector V */

static real vec_abs(real v[])
{
    int i;
    real r = ABS(v[0]);
    for(i=1; i<IDIM; i++)
	r+=ABS(v[i]);
    return r;
}


    /* Inverse Filter */

void inv_filter(real input[])
{
  int i,j,k;
  static int ip=IDIM;
  static real mem1[SPORDER+NFRSZ];
  
  /** Shift in input into mem1 **/
  for(i=IDIM; i<SPORDER+IDIM; i++)
    mem1[i-IDIM] = mem1[i];
  for(i=0; i<IDIM; i++)
    mem1[SPORDER+i] = input[i];
  for(k=0; k<IDIM; k++) {
    real tmp = mem1[SPORDER+k];
    for(j=1; j<=SPORDER; j++)
      tmp += mem1[SPORDER+k-j]*a10[j];
    fil_mem[PMSIZE-NFRSZ+ip+k] = tmp;
  }
  if(ip == (NFRSZ-IDIM))
    ip = 0;
  else
    ip += IDIM;
}

void
postfilter(real input[], real output[])
{
    int i;
    static
    real
	temp[IDIM], 	/* Output of long term filter*/
	temp2[IDIM], 	/* Input of short term filter*/
	new_gain,	/* Gain of filtered output */
	input_gain, 	/* Gain of input */
	scale;		/* Scaling factor for gain preservation */

    static real scalefil=1.0;	/* Smoother version of scale */
    static real vec_abs();

    longterm(input, temp);
    shortterm(temp, temp2);

    /* Computed scale for gain preservation */

    new_gain = vec_abs(temp2);
    if (new_gain > 1.0)
    {
	input_gain = vec_abs(input);
	scale = input_gain/new_gain;
    }
    else 
	scale = 1.0;
    
    /* Smooth out scale, then scale the output */

    for(i=0; i<IDIM; i++) {
	scalefil = AGCFAC * scalefil + (1.0 - AGCFAC)*scale;
	output[i] = scalefil * temp2[i];
    }
}

static void
longterm(real input[], real output[])
{
    int i;
    real out;
    static real lmemory[KPMAX];

    /* Add weighted pitch_period-delayed signal */

    for(i=0; i<IDIM; i++) {
	out = pitch_tap * lmemory[KPMAX+i-pitch_period];
	out += input[i];
	output[i] = pitch_gain*out;
    }
    
    /* Shift-in input to lmemory */

    for (i=0; i<KPMAX-IDIM; i++)
	lmemory[i] = lmemory[i+IDIM];
    for(i=0; i<IDIM; i++)
	lmemory[KPMAX-IDIM+i] = input[i];
}

/*
  Again, memories (shpmem, shzmem) are in reverse order, 
  i.e. [0] is the oldest.
 */

static void
shortterm(real input[], real output[])
{
    int k,j;
    
    static real shpmem[SPORDER], shzmem[SPORDER];
    for(k=0; k<IDIM; k++) {
      
      /* FIR Part */
      
      real in = input[k], out;
      out = in;
      for(j=SPORDER-1; j>=1; j--) {
	out += shzmem[j]*shzcoef[j+1];
	shzmem[j] = shzmem[j-1];
      }
      out += shzmem[0] * shzcoef[1];
      shzmem[0] = in;
      
      /* IIR Part */
      
	for(j=SPORDER-1; j>=1; j--) {
	    out -= shpmem[j]*shpcoef[j+1];
	    shpmem[j] = shpmem[j-1];
	}
	out -= shpmem[0] * shpcoef[1];
	shpmem[0] = out;
	output[k] = out+tiltz*shpmem[1];
    }
}


/*********************************/
/***** Postfilter Adapter ********/
/*********************************/

static int extract_pitch();

void
psf_adapter (real frame[])
{

    pitch_period = extract_pitch();

    /** Compute Pitch Tap **/
    {
      int i;
      real corr=0.0, corr_per=0.0;
      /** Shift old memory **/
      for(i=0;i<SHIFTSZ;i++)
	tap_mem[i] = tap_mem[i+NFRSZ];
      /** Shift new frame into memory **/
      for(i=0;i<NFRSZ;i++)
	tap_mem[SHIFTSZ+i] = frame[i];

      for(i=KPMAX-pitch_period; i<(KPMAX-pitch_period+NPWSZ); i++) {
	  corr     += tap_mem[i] * tap_mem[i];
	  corr_per += tap_mem[i] * tap_mem[i+pitch_period];
      }
      if REALZEROP(corr)
	  pitch_tap = 0.0;
      else
	  pitch_tap = corr_per/corr;
    }
    
    /** Compute Long Term Coefficients **/
    
    {
      if (pitch_tap > 1)
	  pitch_tap = 1.0;
      if (pitch_tap < PPFTH)
	  pitch_tap = 0.0;
      pitch_tap = PPFZCF * pitch_tap;
      pitch_gain = 1.0/(1.0+pitch_tap);
    }
};

void compute_sh_coeff()
{

  /** Compute Short Term Coefficients **/
  {
    int i;
    for(i=1; i<=SPORDER; i++) {
	shzcoef[i] = shzscale[i]*a10[i];
	  shpcoef[i] = shpscale[i]*a10[i];
      }
      tiltz = TILTF * k10;
  }
}

static int best_period (real buffer[], int buflen,
			int pmin, int pmax)
{
    int i, per, best_per = -1;
    real best_corr = -(BIG);
    for(per = pmin; per<pmax; per++) {
	real corr = 0.0;
	for(i=pmax; i<buflen; i++)
	    corr += buffer[i] * buffer[i-per];
	if (corr > best_corr) {
	    best_corr = corr;
	    best_per  = per;
	}	    
    }
    return best_per;
}

#define DCFRSZ NFRSZ/DECIM /* size of decimated frame */

static int
extract_pitch()
{
    int
	i, j, k,
	best_per=KPMAX,		 /* Best Period (undecimated) */
	best_dper = KPMAX/DECIM, /* Best Decimated Period */
	best_old_per=KPMAX,	 /* Best Old Period */
	permin,			 /* Limits for search of best period */
	permax;
    real
	best_corr=-(BIG), best_old_corr=-(BIG), tap0=0.0, tap1=0.0;
    static int old_per = (KPMIN+KPMAX)>>1;
    static real
	fil_decim_mem[PDMSIZE],
	fil_out_mem[NFRSZ+DECIM];

#define FIL_DECIM_MEM(I) fil_decim_mem[I]
#define FIL_OUT_MEM(I)   fil_out_mem[I]
    
    /** Shift decimated filtered output */

    for(i=DCFRSZ; i<PDMSIZE; i++)
	FIL_DECIM_MEM(i-DCFRSZ) = FIL_DECIM_MEM(i);
  
    /* Filter and  decimate  input */

  {
      int decim_phase = 0, dk;
      for (k = 0, dk=0; k<NFRSZ; k++)
      {
	  real tmp;
	  tmp = fil_mem[PMSIZE-NFRSZ+k] - A1 * FIL_OUT_MEM(2)
	                 - A2 * FIL_OUT_MEM(1)
	                 - A3 * FIL_OUT_MEM(0);
	  decim_phase++;
	  if (decim_phase == 4) {
	      FIL_DECIM_MEM(PDMSIZE-DCFRSZ+dk) = 
		  B0 * tmp
		+ B1 * FIL_OUT_MEM(2)
		+ B2 * FIL_OUT_MEM(1)
		+ B3 * FIL_OUT_MEM(0);
	      decim_phase = 0;
	      dk++;
	  }
	  FIL_OUT_MEM(0) = FIL_OUT_MEM(1);
	  FIL_OUT_MEM(1) = FIL_OUT_MEM(2);
	  FIL_OUT_MEM(2) = tmp;
      }
  }

    /* Find best Correlation in decimated domain: */

    best_dper = best_period(fil_decim_mem, PDMSIZE, DPERMIN, DPERMAX);

    /* Now fine-tune best correlation on undecimated  domain */
    
    permin = best_dper * DECIM - DECIM + 1;
    permax = best_dper * DECIM + DECIM - 1;
    if (permax > KPMAX)
	permax = KPMAX;
    if (permin < KPMIN)
	permin = KPMIN;
    
  {
      int per;
      best_corr = -(BIG);
      for(per = permin; per<=permax; per++) {
	  real corr = 0.0;
	  for(i=1,j=(per+1);   i<= NPWSZ;   i++,j++)
	      corr += fil_mem[PMSIZE-i]*fil_mem[PMSIZE-j];
	  if (corr > best_corr) {
	      best_corr = corr;
	      best_per = per;
	  }
      }
  }
    
    /** If we are not exceeding old period by too much, we have a real
       period and not a multiple */
    
    permax = old_per + KPDELTA;
    if (best_per <= permax)
	goto done;

    /** Now compute best period around the old period **/
    
    permin = old_per - KPDELTA;
    if (permin<KPMIN) permin = KPMIN;
  {
      int per;
      best_old_corr = -(BIG);
      for(per = permin; per<=permax; per++) {
	  real corr = 0.0;
	  for(i=1,j=(per+1);
	      i<=NPWSZ;
	      i++,j++)
	      corr += fil_mem[PMSIZE-i]*fil_mem[PMSIZE-j];
	  if (corr > best_old_corr) {
	      best_old_corr = corr;
	      best_old_per = per;
	  }
      }
  }
    
				/***** Compute the tap ****/

  {
      real s0=0.0, s1=0.0;
      for(i=1; i<=NPWSZ; i++) {
	s0 += fil_mem[PMSIZE-i-best_per] * fil_mem[PMSIZE-i-best_per];
	s1 += fil_mem[PMSIZE-i-best_old_per] * fil_mem[PMSIZE-i-best_old_per];
      }
      if (! REALZEROP(s0))
	  tap0 = best_corr/s0;
      if (! REALZEROP(s1))
	  tap1 = best_old_corr/s1;
      tap0 = CLIPP(tap0, 0.0, 1.0);
      tap1 = CLIPP(tap1, 0.0, 1.0);
      if (tap1 > TAPTH * tap0)
	  best_per = best_old_per;
  }
  done:

    /** Shift fil_mem **/

    for(i=NFRSZ; i<PMSIZE; i++)
	fil_mem[i-NFRSZ] = fil_mem[i];

    old_per = best_per;
    return best_per;
}

void
init_postfilter()
{
    int i;
    shzscale[0] = shpscale[0] = 1.0;
    for (i=1; i<=SPORDER; i++)
    {
	shzscale[i] = SPFZCF * shzscale[i-1];
	shpscale[i] = SPFPCF * shpscale[i-1];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\prototyp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       prototyp.h
//
//--------------------------------------------------------------------------

#ifndef PROTOTYP_H
#define PROTOTYP_H

#include "common.h"
#include "qsize.h"
#include "parm.h"

extern real PSF_LPC_MEM a10[];
extern real PSF_LPC_MEM k10;
extern void adapt_coder();
extern void bsf_adapter();
extern void cb_excitation();
extern int  cb_index ();
extern void code_frame();
extern void gain_adapter ();
extern int  get_index();
extern void init_bsf_adapter();
extern void init_coder();
extern void init_gain_adapter();
extern void init_gain_buf();
extern void init_io();
extern void init_postfilter();
extern void init_pwf_adapter ();
extern void iresp_vcalc();
extern void mem_update ();
extern void postfilter();
extern real predict_gain();
extern void update_gain();
extern void psf_adapter();
extern void inv_filter();
extern void compute_sh_coeff();	/* for the post filter short-term coeff */
extern void put_index();
extern void pwf_adapter ();
extern void pwfilter2();
extern int  read_sound_buffer();
extern void shape_conv();
extern void trev_conv();
extern void update_sfilter();
extern int  write_sound_buffer();
extern void zresp();

#endif /*PROTOTYP_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\main.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       main.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <winsock.h>
#include <mmsystem.h>
#include <stdio.h>
#include <conio.h>

#include "iphone.h"

//#define BUFFER_SIZE 60

#define BUFFER_SIZE 64

void ldcelpEncode
(
    PUSHORT pBuffer,
    ULONG   cbBuffer,
    PSHORT  pIndex,
    PULONG  pcbIndices
);

ULONG ldcelpDecode
(
    PSHORT  pIndex,
    ULONG   cIndices,
    PSHORT  pBuffer,
    PULONG  pcSamples,
    ULONG   cbMaxSamples
);

extern CRITICAL_SECTION csLDCELP;

DWORD ReadThread
(
    DWORD   dwContext
)
{
    MSG         msg;
    PIPHONE     pIPhone = (PIPHONE) dwContext;

    printf( "entered read thread.\n" );
    do
    {
        GetMessage( &msg, NULL, 0, 0 );

        switch (msg.message)
        {
            case MM_WIM_OPEN:
                printf( "wavein opened.\n" );
                break;

            case MM_WIM_DATA:
            {
                LPWAVEHDR  phdr = (LPWAVEHDR) msg.lParam;

                if (phdr)
                {
                    waveInUnprepareHeader( pIPhone->hwi, phdr, sizeof( WAVEHDR ) );
                    if (phdr->dwBytesRecorded)
                    {
#if 0
                        WORD        rgwEncode[ BUFFER_SIZE ];
                        ULONG       cIndices;

//                        LONGLONG    llStart, llEnd, llFreq;  
//
//                        QueryPerformanceFrequency( &llFreq );
//
//                        QueryPerformanceCounter( &llStart );
//
                        ldcelpEncode( phdr->lpData, 
                                      phdr->dwBufferLength / sizeof( WORD ),
                                      rgwEncode,
                                      &cIndices );

//                        QueryPerformanceCounter( &llEnd );
//                        llEnd = 1000000 * (llEnd - llStart) / llFreq;
//
//                        printf( "encoding took %d us\n", (ULONG) llEnd );


//                        printf( "encoded: %d indices\n", cIndices );

                        
                        ldcelpDecode( rgwEncode,
                                      cIndices,
                                      phdr->lpData,
                                      &phdr->dwBufferLength,
                                      BUFFER_SIZE );

                        phdr->dwBufferLength *= sizeof( WORD );

//                        printf( "decoded: %d bytes\n", phdr->dwBufferLength );
#endif
                        iphoneSend( pIPhone, phdr->lpData, phdr->dwBufferLength);


                    }
                    phdr->dwBufferLength = BUFFER_SIZE * sizeof( WORD );
                    waveInPrepareHeader( pIPhone->hwi, phdr, sizeof( WAVEHDR ) );
                    waveInAddBuffer( pIPhone->hwi, phdr, sizeof( WAVEHDR ) );
                }
                break;
            }
        }

    }
    while (msg.message != MM_WIM_CLOSE);

    printf( "exited read thread.\n");

    return 0;
}

DWORD WriteThread
(
    DWORD   dwContext
)
{
    MSG         msg;
    PIPHONE     pIPhone = (PIPHONE) dwContext;

    printf( "entered write thread.\n" );
    do
    {
        GetMessage( &msg, NULL, 0, 0 );

        switch (msg.message)
        {
            case MM_WOM_OPEN:
                //printf( "waveout opened.\n" );
                break;

            case MM_WOM_DONE:
            {
                LPWAVEHDR  phdr = (LPWAVEHDR) msg.lParam;

                //printf( "done: %x\n", phdr );
            }
            break;
        }

    }
    while (msg.message != MM_WOM_CLOSE);

    printf( "exited write thread.\n");

    return 0;
}

void usage( void )
{
    printf( "usage: iphone [-c <hostname>]\n" );
}

int __cdecl main
(
    int     argc,
    char    *argv[]
)
{
    int           i;
    HANDLE        htRead, htWrite;
    IPHONE        IPhone;
    ULONG         tidRead, tidWrite;
    WAVEFORMATEX  wf;
    WAVEHDR       rgwhRead[ 16 ], rgwhWrite[ 16 ];

    if (!iphoneInit( &IPhone ))
    {
        printf( "failed to initialize.\n" );
        return -1;
    }

    if (argc < 2)
    {
        // No command-line arguments

        iphoneWaitForCall( &IPhone );
    }
    else
    {
        // Check first argument

        if (*(argv[ 1 ]) != '/' && *(argv[ 1 ]) != '-')
        {
            usage();
            return -1;
        }
        else
        {
            switch( *(argv[ 1 ] + 1))
            {
                case 'c':
                case 'C':
                    if (argc < 3)
                    {
                        printf( "error: must specify host name\n" );
                        return -1;
                    }

                    if (!iphonePlaceCall( &IPhone, argv[ 2 ] ))
                        return -1;
                    break;

                default:
                    usage();
                     return -1;
            }
        }
    }

    InitializeCriticalSection( &csLDCELP );

    htRead =
        CreateThread( NULL,                 // no security
                      0,                    // default stack
                      (PTHREAD_START_ROUTINE) ReadThread,
                      (PVOID) &IPhone,   // parameter
                      0,                   // default create flags
                      &tidRead );         // container for thread id

    if (NULL == htRead)
    {
        printf( "ERROR: failed to create read thread\n" );
        return -1;
    }

//    SetThreadPriority( htRead, THREAD_PRIORITY_TIME_CRITICAL );

    htWrite =
        CreateThread( NULL,                 // no security
                      0,                    // default stack
                      (PTHREAD_START_ROUTINE) WriteThread,
                      (PVOID) &IPhone,   // parameter
                      0,                   // default create flags
                      &tidWrite );         // container for thread id

    if (NULL == htWrite)
    {
        printf( "ERROR: failed to create write thread\n" );
        CloseHandle( htRead );
        return -1;
    }

//    SetThreadPriority( htWrite, THREAD_PRIORITY_TIME_CRITICAL );

    wf.wFormatTag = WAVE_FORMAT_PCM;
    wf.nChannels = 1;
    wf.nSamplesPerSec = 8000; 
    wf.wBitsPerSample = 8; 
    wf.nAvgBytesPerSec = wf.nSamplesPerSec * wf.nChannels * (wf.wBitsPerSample / 8); 
    wf.nBlockAlign = 2; 
    wf.cbSize = sizeof( WAVEFORMATEX );

    RtlZeroMemory( rgwhRead, sizeof( rgwhRead ) );
    RtlZeroMemory( rgwhWrite, sizeof( rgwhWrite ) );

    if (waveOutOpen( &IPhone.hwo, 0, &wf, tidWrite, 
                     0L, CALLBACK_THREAD ))
    {
        printf( "ERROR: failed to open wave output device.\n" );
        CloseHandle( htRead );
        CloseHandle( htWrite );
        return -1;
    }

    if (waveInOpen( &IPhone.hwi, 0, &wf, tidRead, 
                     0L, CALLBACK_THREAD ))
    {
        printf( "ERROR: failed to open wave input device.\n" );
        CloseHandle( htRead );
        CloseHandle( htWrite );
        return -1;
    }

    for (i = 0; i < 16; i++)
    {
        rgwhRead[ i ].lpData = 
            HeapAlloc( GetProcessHeap(), 0, BUFFER_SIZE * sizeof( WORD ) );
        rgwhRead[ i ].dwBufferLength = BUFFER_SIZE * sizeof( WORD );
        waveInPrepareHeader( IPhone.hwi, &rgwhRead[ i ], sizeof( WAVEHDR ) );
        waveInAddBuffer( IPhone.hwi, &rgwhRead[ i ], sizeof( WAVEHDR ) );
        rgwhWrite[ i ].lpData = 
            HeapAlloc( GetProcessHeap(), 0, BUFFER_SIZE * sizeof( WORD ) );
        rgwhWrite[ i ].dwBufferLength = BUFFER_SIZE * sizeof( WORD );
        waveOutPrepareHeader( IPhone.hwo, &rgwhWrite[ i ], sizeof( WAVEHDR ) );
    }

    waveInStart( IPhone.hwi );

    printf( "\nPress any key to terminate..." );

    i = 0;
    while (!_kbhit())
    {

        if (0 == (rgwhWrite[ i ].dwFlags & WHDR_INQUEUE))
        {
            if (rgwhWrite[ i ].dwBufferLength = 
                   iphoneRecv( &IPhone, rgwhWrite[ i ].lpData, 
                               BUFFER_SIZE * sizeof( WORD ) ))
            {
                waveOutWrite( IPhone.hwo, &rgwhWrite[ i ], sizeof( WAVEHDR ) );
                if (++i == 16)
                    i = 0;
            }
        }
#if 0
        WORD   rgwData[ BUFFER_SIZE ];
        ULONG  cbData, cIndex;

        if (cbData = iphoneRecv( &IPhone, rgwData, sizeof( rgwData ) ))
        {
            cIndex = 0;

            cbData /= 2;
//            printf( "recv: %d indices\n", cbData );

            while (cbData - cIndex)
            {
                if (0 == (rgwhWrite[ i ].dwFlags & WHDR_INQUEUE))
                {
                    cIndex += 
                        ldcelpDecode( &rgwData[ cIndex ], 
                                      cbData - cIndex,
                                      rgwhWrite[ i ].lpData, 
                                      &rgwhWrite[ i ].dwBufferLength,
                                      BUFFER_SIZE );
                    printf( "decoded: %d samples\n", rgwhWrite[ i ].dwBufferLength ) ;
                    rgwhWrite[ i ].dwBufferLength *= sizeof( WORD );
                    waveOutWrite( IPhone.hwo, &rgwhWrite[ i ], sizeof( WAVEHDR ) );
                    if (++i == 16)
                        i = 0;
                }
            }
        }
#endif
        Sleep( 0 );
    }

    printf( "\n" );

    if (_kbhit ())
        _getch ();

    waveInStop( IPhone.hwi );

    waveInReset( IPhone.hwi );
    waveInClose( IPhone.hwi );

    waveOutReset( IPhone.hwo );
    waveOutClose( IPhone.hwo );

    CloseHandle( htWrite );
    CloseHandle( htRead );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midi\play.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <windows.h>
#include <objbase.h>
#include <devioctl.h>
#include <avddk.h>

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <tchar.h>

#include "play.h"

/*	-	-	-	-	-	-	-	-	*/
#define	PORTID		TEXT("\\\\.\\msmpu401.SB16_Dev0")

/*	-	-	-	-	-	-	-	-	*/
typedef struct {
	ULONG	uSequenceFormat;
	ULONG	uTracks;
	ULONG	uResolution;
	ULONG	uDivType;
} MIDIINFO, *PMIDIINFO;

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN modWrite(
	HANDLE	hDevice,
	PVOID	pvOut,
	ULONG	cbOut)
{
	BOOLEAN		fResult;
	OVERLAPPED	ov;
	DWORD		cbWritten;

	RtlZeroMemory(&ov, sizeof(OVERLAPPED));
	if (!(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
		return FALSE;
	ov.OffsetHigh = 0;
	ov.Offset = 0;
	if (!(fResult = WriteFile(hDevice, pvOut, cbOut, &cbWritten, &ov)))
		if (GetLastError() == ERROR_IO_PENDING) {
			WaitForSingleObject(ov.hEvent, INFINITE);
			fResult = TRUE;
		} else
			_tprintf(TEXT("ERROR: failed writefile: %lx.\n"), GetLastError());
	CloseHandle(ov.hEvent);
	return fResult;
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN modControl(
	HANDLE	hDevice,
	DWORD	dwIoControl,
	PVOID	pvIn,
	ULONG	cbIn,
	PVOID	pvOut,
	ULONG	cbOut,
	PULONG	pcbReturned)
{
	BOOLEAN		fResult;
	OVERLAPPED	ov;

	RtlZeroMemory(&ov, sizeof(OVERLAPPED));
	if (!(ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
		return FALSE;
	if (!(fResult = DeviceIoControl(hDevice, dwIoControl, pvIn, cbIn, pvOut, cbOut, pcbReturned, &ov)))
		if (GetLastError() == ERROR_IO_PENDING) {
			WaitForSingleObject(ov.hEvent, INFINITE);
			fResult = TRUE;
		} else
			_tprintf(TEXT("ERROR: failed ioctl to device: %lx.\n"), GetLastError());
	CloseHandle(ov.hEvent);
	return fResult;
}

/*	-	-	-	-	-	-	-	-	*/
BYTE bEventOn[] =	{0x90,0x50,0x50, 0x91,0x50,0x50, 0x92,0x50,0x50};
BYTE bEventOff[] =	{0x80,0x50,0x00, 0x81,0x50,0x00, 0x82,0x50,0x00};
BYTE bEventAllOff[] =	{0xb0,0x7b,0x00, 0xb1,0x7b,0x00, 0xb2,0x7b,0x00};

/*	-	-	-	-	-	-	-	-	*/
VOID modOut(
	HANDLE hDevice)
{   
	ULONG			cbReturned;
	AVPROPERTY		Property;
	UCHAR			aConnect[sizeof(AVPIN_CONNECT)+sizeof(AVDATAFORMAT_MUSIC)];
	PAVPIN_CONNECT	pConnect;
	PAVDATAFORMAT_MUSIC	pMusic;
	HANDLE			hConnection;
	PVOID			pvConnection;
	AVP_CONNECTION		Connection;
	WCHAR			achDeviceName[64];
	AVSTATE			State;

	pConnect = (PAVPIN_CONNECT)aConnect;
	pConnect->idPin = 0;
	pConnect->idPinTo = 0;
	pConnect->hConnectTo = NULL;
	pConnect->Protocol.guidSet = AVPROTOCOLSETID_Standard;
	pConnect->Protocol.id = AVPROTOCOL_STANDARD_MUSIC;
	pConnect->Transport.guidSet = AVTRANSPORTSETID_Standard;
	pConnect->Transport.id = AVTRANSPORT_STANDARD_DEVIO;
	pConnect->Priority.ulPriorityClass = AVPRIORITY_NORMAL;
	pConnect->Priority.ulPrioritySubClass = 0;
	pMusic = (PAVDATAFORMAT_MUSIC)(pConnect + 1);
	pMusic->DataFormat.guidMajorFormat = AVDATAFORMAT_TYPE_MUSIC;
	pMusic->DataFormat.cbFormat = sizeof(AVDATAFORMAT_MUSIC);
	pMusic->idFormat = AVDATAFORMAT_MUSIC_MIDI;
	_tprintf(TEXT("cb=%u, id=%u\n"), pMusic->DataFormat.cbFormat, pMusic->idFormat);
	if (modControl(hDevice, IOCTL_AV_CONNECT, pConnect, sizeof(aConnect), &pvConnection, sizeof(PVOID), &cbReturned))
		_tprintf(TEXT("Play: connect\n\n"));
	else {
		_tprintf(TEXT("Play: failed to connect\n\n"));
		return;
	}
	Connection.Property.guidSet = AVPROPSETID_Pin;
	Connection.Property.id = AVPROPERTY_PIN_DEVICENAME;
	Connection.pvConnection = pvConnection;
	modControl(hDevice, IOCTL_AV_GET_PROPERTY, &Connection, sizeof(AVP_CONNECTION), achDeviceName, sizeof(achDeviceName), &cbReturned);
	hConnection = CreateFileW(achDeviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (hConnection != (HANDLE)-1)
		_tprintf(TEXT("Play: opened connection\n\n"));
	else {
		_tprintf(TEXT("Play: failed to open connection\n\n"));
		modControl(hDevice, IOCTL_AV_DISCONNECT, &pvConnection, sizeof(PVOID), NULL, 0, &cbReturned);
		return;
	}
	Property.guidSet = AVPROPSETID_Control;
	Property.id = AVPROPERTY_CONTROL_DEVICESTATE;
	State = AVSTATE_RUN;
	if (modControl(hConnection, IOCTL_AV_SET_PROPERTY, &Property, sizeof(Property), &State, sizeof(State), &cbReturned))
		_tprintf(TEXT("Play: change device state\n\n"));
	else {
		_tprintf(TEXT("Play: failed to change device state\n\n"));
		CloseHandle(hConnection);
		modControl(hDevice, IOCTL_AV_DISCONNECT, &pvConnection, sizeof(PVOID), NULL, 0, &cbReturned);
		return;
	}
	if (modWrite(hConnection, bEventOn, sizeof(bEventOn)))
		_tprintf(TEXT("Play: send on data\n\n"));
	else
		_tprintf(TEXT("Play: failed to send on data\n\n"));
	Sleep(5000);
	if (modWrite(hConnection, bEventOff, sizeof(bEventOff)))
		_tprintf(TEXT("Play: send off data\n\n"));
	else
		_tprintf(TEXT("Play: failed to send off data\n\n"));
	Sleep(5000);
	if (modWrite(hConnection, bEventAllOff, sizeof(bEventAllOff)))
		_tprintf(TEXT("Play: send all off data\n\n"));
	else
		_tprintf(TEXT("Play: failed to send all off data\n\n"));
	State = AVSTATE_STOP;
	modControl(hConnection, IOCTL_AV_SET_PROPERTY, &Property, sizeof(Property), &State, sizeof(State), &cbReturned);
	CloseHandle(hConnection);
	modControl(hDevice, IOCTL_AV_DISCONNECT, &pvConnection, sizeof(PVOID), NULL, 0, &cbReturned);
}

/*	-	-	-	-	-	-	-	-	*/
int _cdecl main(
	int argc,
	char *argv[],
	char *envp[])
{
	HANDLE	hDevice;

	hDevice = CreateFile(PORTID, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (hDevice == (HANDLE)-1) {
		_tprintf(TEXT("failed to open port (%ld)\n"), GetLastError());
		return 0;
	}
	_tprintf(TEXT("retrieved functional handle\n"));
	modOut(hDevice);
	CloseHandle(hDevice);
	return 0;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\iphone\socket.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       socket.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <winsock.h>
#include <mmsystem.h>
#include <stdio.h>
#include <conio.h>

#include "iphone.h"

BOOL iphoneInit
(
    PIPHONE pIPhone
)
{
    BOOL            fTrue = TRUE;
    SOCKET          sock;
    WSADATA         wsaData;
    ULONG           ulZero = 0;

    RtlZeroMemory( &pIPhone->ovRead, sizeof( OVERLAPPED ) );
    RtlZeroMemory( &pIPhone->ovWrite, sizeof( OVERLAPPED ) );

    if (WSAStartup( MAKEWORD( 2, 0 ), &wsaData ))
        return FALSE ;

    if (INVALID_SOCKET == (sock = socket( AF_INET, SOCK_STREAM, 0 )))
    {
        WSACleanup();
        return FALSE;
    }

    pIPhone->sockHost = sock;

    if (NULL == (pIPhone->ovRead.hEvent = 
                    CreateEvent( NULL, TRUE, FALSE, NULL )))
    {
        closesocket( pIPhone->sockHost );
        pIPhone->sockHost = INVALID_SOCKET;
        WSACleanup();
        return FALSE;
    }

    if (NULL == (pIPhone->ovWrite.hEvent = 
                    CreateEvent( NULL, TRUE, FALSE, NULL )))
    {
        closesocket( pIPhone->sockHost );
        pIPhone->sockHost = INVALID_SOCKET;
        CloseHandle( pIPhone->ovRead.hEvent );
        pIPhone->ovRead.hEvent = NULL;
        WSACleanup();
        return FALSE;
    }

    return TRUE;
}


BOOL iphoneWaitForCall
(
    PIPHONE pIPhone
)
{
    SOCKADDR_IN     saAccept, saLocal;

    printf( "waiting for call...\n" ) ;

    saLocal.sin_port = htons( IPPORT_IPHONE );
    saLocal.sin_family = AF_INET;
    saLocal.sin_addr.s_addr = INADDR_ANY;

    if (bind( pIPhone->sockHost, (const struct sockaddr *) &saLocal, sizeof( saLocal )))
    {
        printf( "failed to bind to socket: %d\n", WSAGetLastError() );
        return FALSE;
    }

    if (listen( pIPhone->sockHost, 1 ))
    {
        printf( "error on listen: %d\n", WSAGetLastError() );
        return FALSE;
    }
    else
    {
        ULONG  cbAccept;

        cbAccept = sizeof( saAccept );

        if (SOCKET_ERROR ==
                (pIPhone->sockClient=
                    accept( pIPhone->sockHost,
                            (struct sockaddr *) &saAccept,
                            &cbAccept )))
        {
            printf( "error on accept: %d\n", WSAGetLastError() );
            return FALSE;
        }
        else
        {
            BOOL    fTrue = TRUE;
            ULONG   ulZero = 0;

            printf( "connect\n" );

            setsockopt( pIPhone->sockClient, IPPROTO_TCP, TCP_NODELAY, &fTrue, sizeof( BOOL ) );
            setsockopt( pIPhone->sockClient, SOL_SOCKET, SO_SNDBUF, (char *)&ulZero, sizeof( ulZero ) );

            return TRUE;
        }
    }
}

BOOL iphonePlaceCall
(
    PIPHONE pIPhone,
    PSTR    pszHost
)
{
    struct hostent  *pHost;
    SOCKADDR_IN     saCall;

    if (pHost = gethostbyname( pszHost ))
    {
        printf( "calling: %s (%u.%u.%u.%u)\n", pszHost, 
                (UCHAR)*(pHost->h_addr), (UCHAR)*(pHost->h_addr + 1),
                (UCHAR)*(pHost->h_addr + 2), (UCHAR)*(pHost->h_addr + 3));
        saCall.sin_port = htons( IPPORT_IPHONE );
        saCall.sin_family = AF_INET;
        memcpy( &saCall.sin_addr, pHost->h_addr, pHost->h_length );
        pIPhone->sockClient = pIPhone->sockHost;
        if (SOCKET_ERROR == 
                connect( pIPhone->sockClient, (PSOCKADDR) &saCall, sizeof( saCall )))
        {
            printf( "error on connect: %d\n", WSAGetLastError() );
            return FALSE;
        }
        else
            return TRUE;
    }
    else
    {
        printf( "error: unknown host\n" ) ;
        return FALSE;
    }
}

ULONG iphoneSend
(
    PIPHONE pIPhone,
    PUCHAR  pBuffer,
    ULONG   cbBuffer
)
{
    ULONG cbWritten;

    if (!WriteFile( (HANDLE) pIPhone->sockClient, pBuffer, cbBuffer, 
                    &cbWritten, &pIPhone->ovWrite ))
    {
        if (GetLastError() != ERROR_IO_PENDING)
            cbWritten = 0;
        else if (!GetOverlappedResult( (HANDLE) pIPhone->sockClient, 
                                       &pIPhone->ovWrite, 
                                       &cbWritten, TRUE ))
            cbWritten = 0;
    }

    return cbWritten;
}

ULONG iphoneRecv
(
    PIPHONE pIPhone,
    PUCHAR  pBuffer,
    ULONG   cbBuffer
)
{
    ULONG           cbRead;

    if (!ReadFile( (HANDLE) pIPhone->sockClient, pBuffer, cbBuffer, 
                    &cbRead, &pIPhone->ovRead ))
    {
        if (GetLastError() != ERROR_IO_PENDING)
            cbRead = 0;
        else if (!GetOverlappedResult( (HANDLE) pIPhone->sockClient, 
                                        &pIPhone->ovRead, 
                                        &cbRead, TRUE ))
            cbRead = 0;
    }

    return cbRead;

}

VOID iphoneCleanup
(
    PIPHONE pIPhone
)
{
    if (pIPhone->sockClient)
        closesocket( pIPhone->sockClient );

    if (pIPhone->ovWrite.hEvent)
    {
        CloseHandle( pIPhone->ovWrite.hEvent );
        pIPhone->ovWrite.hEvent = NULL;
    }

    if (pIPhone->ovRead.hEvent)
    {
        CloseHandle( pIPhone->ovRead.hEvent );
        pIPhone->ovRead.hEvent = NULL;
    }

    WSACleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\circbuf.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 * circbuf.c - Routines to manage the circular MIDI input buffer.
 *      This buffer is filled by the low-level callback function and
 *      emptied by the application.  Since this buffer is accessed
 *      by a low-level callback, memory for it must be allocated
 *      exactly as shown in AllocCircularBuffer().
 */

#include <windows.h>
#include "globals.h"
//#include "circbuf.h"

/*
 * AllocCircularBuffer -    Allocates memory for a CIRCULARBUFFER structure 
 * and a buffer of the specified size.  Each memory block is allocated 
 * with GlobalAlloc() using GMEM_SHARE and GMEM_MOVEABLE flags, locked 
 * with GlobalLock(), and page-locked with GlobalPageLock().
 *
 * Params:  dwSize - The size of the buffer, in events.
 *
 * Return:  A pointer to a CIRCULARBUFFER structure identifying the 
 *      allocated display buffer.  NULL if the buffer could not be allocated.
 */
LPCIRCULARBUFFER AllocCircularBuffer(ULONG ulSize)
{
    HANDLE hMem;
    LPCIRCULARBUFFER lpBuf;
    LPEVENT lpMem;
    
    /* Allocate and lock a CIRCULARBUFFER structure.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(CIRCULARBUFFER));
    if(hMem == NULL)
        return NULL;

    lpBuf = (LPCIRCULARBUFFER)GlobalLock(hMem);
    if(lpBuf == NULL)
    {
        GlobalFree(hMem);
        return NULL;
    }
    
    /* Page lock the memory.  Global memory blocks accessed by
     * low-level callback functions must be page locked.
     */
    //GlobalPageLock((HGLOBAL)HIWORD(lpBuf));

    /* Save the memory handle.
     */
    lpBuf->hSelf = hMem;
    
    /* Allocate and lock memory for the actual buffer.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, ulSize * sizeof(EVENT));
    if(hMem == NULL)
    {
	//GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
        GlobalUnlock(lpBuf->hSelf);
        GlobalFree(lpBuf->hSelf);
        return NULL;
    }
    
    lpMem = (LPEVENT)GlobalLock(hMem);
    if(lpMem == NULL)
    {
        GlobalFree(hMem);
	//GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
        GlobalUnlock(lpBuf->hSelf);
        GlobalFree(lpBuf->hSelf);
        return NULL;
    }
    
    /* Page lock the memory.  Global memory blocks accessed by
     * low-level callback functions must be page locked.
     */
    //GlobalPageLock((HGLOBAL)HIWORD(lpMem));
    
    /* Set up the CIRCULARBUFFER structure.
     */
    lpBuf->hBuffer = hMem;
    lpBuf->wError = 0L;
    lpBuf->ulSize = ulSize;
    lpBuf->ulCount = 0L;
    lpBuf->lpStart = lpMem;
    lpBuf->lpEnd = lpMem + ulSize;
    lpBuf->lpTail = lpMem;
    lpBuf->lpHead = lpMem;
        
    return lpBuf;
}

/* FreeCircularBuffer - Frees the memory for the given CIRCULARBUFFER 
 * structure and the memory for the buffer it references.
 *
 * Params:  lpBuf - Points to the CIRCULARBUFFER to be freed.
 *
 * Return:  void
 */
void FreeCircularBuffer(LPCIRCULARBUFFER lpBuf)
{
    HANDLE hMem;
    
    /* Free the buffer itself.
     */
    //GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf->lpStart));
    GlobalUnlock(lpBuf->hBuffer);
    GlobalFree(lpBuf->hBuffer);
    
    /* Free the CIRCULARBUFFER structure.
     */
    hMem = lpBuf->hSelf;
    //GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}

/* GetEvent - Gets a MIDI event from the circular input buffer.  Events
 *  are removed from the buffer.  The corresponding PutEvent() function
 *  is called by the low-level callback function, so it must reside in
 *  the callback DLL.  PutEvent() is defined in the CALLBACK.C module.
 *
 * Params:  lpBuf - Points to the circular buffer.
 *          lpEvent - Points to an EVENT structure that is filled with the
 *              retrieved event.
 *
 * Return:  Returns non-zero if successful, zero if there are no 
 *   events to get.
 */
WORD GetEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent)
{
    /* If no event available, return.
     */
    if(lpBuf->ulCount <= 0)
        return 0;
    
    /* Get the event.
     */
    *lpEvent = *lpBuf->lpTail;
    
    /* Decrement the byte count, bump the tail pointer.
     */
    --lpBuf->ulCount;
    ++lpBuf->lpTail;
    
    /* Wrap the tail pointer, if necessary.
     */
    if(lpBuf->lpTail >= lpBuf->lpEnd)
        lpBuf->lpTail = lpBuf->lpStart;

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\display.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 *  display.h
 */


/* MIDI status byte definitions
 */
#define NOTEON          0x90
#define NOTEOFF         0x80
#define KEYAFTERTOUCH   0xa0
#define CONTROLCHANGE   0xb0
#define PROGRAMCHANGE   0xc0
#define CHANAFTERTOUCH  0xd0
#define PITCHBEND       0xe0
#define SYSTEMMESSAGE   0xf0
#define BEGINSYSEX      0xf0
#define MTCQUARTERFRAME 0xf1
#define SONGPOSPTR      0xf2
#define SONGSELECT      0xf3

/* Format strings used by GetDisplayText()
 */
#define FORMAT3  " %08lX  %02X     %02X    %02X    %2d   %-21s "
#define FORMAT2  " %08lX  %02X     %02X    --    %2d   %-21s "
#define FORMAT3X " %08lX  %02X     %02X    %02X    --   %-21s "
#define FORMAT2X " %08lX  %02X     %02X    --    --   %-21s "
#define FORMAT1X " %08lX  %02X     --    --    --   %-21s "


/* Data structure to manage a display buffer.
 */
typedef struct displayBuffer_tag
{
    HANDLE  hSelf;          /* handle to this structure */
    HANDLE  hBuffer;        /* buffer handle */
    WORD    wError;         /* error flags */
    DWORD   ulSize;         /* buffer size (in EVENTS) */
    DWORD   ulCount;        /* byte count (in EVENTS) */
    LPEVENT lpStart;        /* ptr to start of buffer */
    LPEVENT lpEnd;          /* ptr to end of buffer (last byte + 1) */
    LPEVENT lpHead;         /* ptr to head (next location to fill) */
    LPEVENT lpTail;         /* ptr to tail (next location to empty) */
} DISPLAYBUFFER;
typedef DISPLAYBUFFER FAR *LPDISPLAYBUFFER;


/* Function prototypes
 */
int GetDisplayText(NPSTR npText, LPEVENT lpEvent);
VOID AddDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent);
VOID GetDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent, DWORD wNum);
LPDISPLAYBUFFER AllocDisplayBuffer(ULONG ulSize);
VOID FreeDisplayBuffer(LPDISPLAYBUFFER lpBuf);
VOID ResetDisplayBuffer(LPDISPLAYBUFFER lpBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midi\play.h ===
//---------------------------------------------------------------------------
//
//  Module:   play.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
//---------------------------------------------------------------------------

BOOLEAN MIDIPortControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
) ;

VOID MIDIOutFile
(
   HANDLE hDevice,
   PSTR   pszFileName
) ;

//---------------------------------------------------------------------------
//  End of File: play.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\exectest.c ===
//--------------------------------------------------------------------------;
//
//  File: exectest.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      This module contains the execTest function required by tstshell
//      in order to execute each test case.
//
//  Contents:
//      execTest()
//      
//  History:
//      
//      
//--------------------------------------------------------------------------;

#include <windows.h>    // Include file for windows APIs
#include <tstshell.h>
#include <mmsystem.h>
#include "globals.h"


//--------------------------------------------------------------------------;
//
//  int execTest
//
//  Description:
//      This is the actual test function which is called from within the
//      test shell.  It is passed various information about the test case
//      it is asked to run, and branches off to the appropriate test
//      function.  Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Arguments:
//      int nID: The test case identifier, also found in the third column
//          in the third column of the test list in the resource file
//
//      int iCase: The test case's number, which expresses the ordering
//          used by the test shell.
//
//      UINT wID: The test case's string ID, which identifies the string
//          containing the description of the test case.  Note that it is
//          also a good candidate for use in the switch statement, as it
//          is unique to each test case.
//
//      UINT wGroupID: The test case's group's string ID, which identifies
//          the string containing the description of the test case's group.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//  History:
//      06/08/93    T-OriG
//      08/02/94    a-MSava     Modified for MIDIPERF.
//
//--------------------------------------------------------------------------;

int execTest
(
    int     nID,
    int     iCase,
    UINT    wID,
    UINT    wGroupID
)
{
    int     ret = TST_OTHER;
   
    tstBeginSection(" ");

    switch(nID)
    {
        //
        //  The test cases    
        //
        case ID_CPUWORKTEST:

            ret = RunCPUWorkTest (TESTLEVEL_F_WIN31);
            break;

        case ID_CPUWORKTEST_MOREDATA:

            ret = RunCPUWorkTest (TESTLEVEL_F_MOREDATA);
            break;

        case ID_CPUWORKTEST_CONNECT:

            ret = RunCPUWorkTest (TESTLEVEL_F_CONNECT);
            break;

        case ID_PERFTEST:

            ret = RunPerfTest (TESTLEVEL_F_WIN31);
            break;

        case ID_PERFTEST_MOREDATA:
            ret = RunPerfTest (TESTLEVEL_F_MOREDATA);
            break;
            
        case ID_PERFTEST_CONNECT:
            ret = RunPerfTest (TESTLEVEL_F_CONNECT);
            break;

        default:
            break;
            
    }

    tstEndSection();

    return(ret);

//Abort:  
//    return(TST_ABORT);
} // execTest()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\filter.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 * filter.c - Routines to filter MIDI events.
 */

#include <windows.h>
#include "globals.h"
#include "display.h"
#include "filter.h"

/* CheckEventFilter - Checks the given EVENT against the given FILTER.
 *      
 * Params:  lpEvent - Points to an EVENT.
 *          lpFilter - Points to a FILTER structure.
 *
 * Return:  Returns 1 if the event is filtered, 0 if it is not filtered.
 */
BOOL CheckEventFilter(LPEVENT lpEvent, LPFILTER lpFilter)
{
    BYTE bStatus, bStatusRaw, bChannel, bData1, bData2;

    /* Get the essential info from the EVENT.
     */
    bStatusRaw = LOBYTE(LOWORD(lpEvent->data));
    bStatus = bStatusRaw & (BYTE) 0xf0;
    bChannel = LOBYTE(LOWORD(lpEvent->data)) & (BYTE) 0x0f;
    bData1 = HIBYTE(LOWORD(lpEvent->data));
    bData2 = LOBYTE(HIWORD(lpEvent->data));

    /* Do channel filtering for all but system events.
     */
    if(bStatus != SYSTEMMESSAGE){
        if(lpFilter->channel[bChannel])
            return 1;
    }

    /* Do event-type filtering.
     */
    switch(bStatus){
        case NOTEOFF:
            if(lpFilter->event.noteOff)
                return 1;
            break;

        case NOTEON:
            /* A note on with a velocity of 0 is a note off.
             */
            if(bData2 == 0){
                if(lpFilter->event.noteOff)
                    return 1;
                break;
            }
            
            if(lpFilter->event.noteOn)
                return 1;
            break;

        case KEYAFTERTOUCH:
            if(lpFilter->event.keyAftertouch)
                return 1;
            break;

        case CONTROLCHANGE:
            if(lpFilter->event.controller)
                return 1;
            
            /* Channel mode messages can be filtered.
             */
            if((bData1 >= 121) && lpFilter->event.channelMode)
                return 1;
            break;

        case PROGRAMCHANGE:
            if(lpFilter->event.progChange)
                return 1;
            break;

        case CHANAFTERTOUCH:
            if(lpFilter->event.chanAftertouch)
                return 1;
            break;

        case PITCHBEND:
            if(lpFilter->event.pitchBend)
                return 1;
            break;

        case SYSTEMMESSAGE:
            /* System common messages.
             */
            if((bStatusRaw < 0xf8) && (lpFilter->event.sysCommon))
                return 1;

            /* Active sensing messages.
             */
            if((bStatusRaw == 0xfe) && (lpFilter->event.activeSense))
                return 1;

            /* System real time messages.
             */
            if((bStatusRaw >= 0xf8) && lpFilter->event.sysRealTime)
                return 1;
            break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiin\midiin.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <windows.h>
#include <objbase.h>
#include <devioctl.h>
#include <avddk.h>

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <tchar.h>

/*	-	-	-	-	-	-	-	-	*/
#define	FILE_LONG_ALIGNMENT	0x00000003

#define	FUNCTIONALID	TEXT("\\\\.\\msmpu401.SB16_Dev0")

/*	-	-	-	-	-	-	-	-	*/
#define	STREAM_SIZE	256
#define	STREAM_BUFFERS	3

typedef struct tagSTREAM_DATA {
	OVERLAPPED		ov;
	struct tagSTREAM_DATA*	psdNext;
} STREAM_DATA, *PSTREAM_DATA;

/*	-	-	-	-	-	-	-	-	*/
typedef struct {
	HANDLE			hFunctionalDevice;
	HANDLE			hConnectionDevice;
	HANDLE			hFunctionalEvent;
	HANDLE			hConnectionEvent;
	HANDLE			hThread;
	HANDLE			hCloseEvent;
	DWORD			dwThreadId;
	ULONG			ulLastChunkLength;
	PSTREAM_DATA		psd;
	BOOL			fClosingDevice;
} MIDIINSTANCE, *PMIDIINSTANCE;

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midFunctionalControl(
	PMIDIINSTANCE	pmi,
	ULONG		ulIoControl,
	PVOID		pvIn,
	ULONG		cbIn,
	PVOID		pvOut,
	ULONG		cbOut)
{
	BOOLEAN		fResult;
	OVERLAPPED	ov;
	ULONG		cbReturned;

	ZeroMemory(&ov, sizeof(OVERLAPPED));
	ov.hEvent = pmi->hFunctionalEvent;
	if (!(fResult = DeviceIoControl(pmi->hFunctionalDevice, ulIoControl, pvIn, cbIn, pvOut, cbOut, &cbReturned, &ov)))
		if (GetLastError() == ERROR_IO_PENDING) {
			WaitForSingleObject(ov.hEvent, INFINITE);
			fResult = TRUE;
		} else
			_tprintf(TEXT("ERROR: failed to write to functional device. %x\n"), GetLastError());
	return fResult;
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midConnectionControl(
	PMIDIINSTANCE	pmi,
	ULONG		ulIoControl,
	PVOID		pvIn,
	ULONG		cbIn,
	PVOID		pvOut,
	ULONG		cbOut)
{
	BOOLEAN		fResult;
	OVERLAPPED	ov;
	ULONG		cbReturned;

	ZeroMemory(&ov, sizeof(OVERLAPPED));
	ov.hEvent = pmi->hConnectionEvent;
	if (!(fResult = DeviceIoControl(pmi->hConnectionDevice, ulIoControl, pvIn, cbIn, pvOut, cbOut, &cbReturned, &ov)))
		if (GetLastError() == ERROR_IO_PENDING) {
			WaitForSingleObject(ov.hEvent, INFINITE);
			fResult = TRUE;
		} else
			_tprintf(TEXT("ERROR: failed to write to connnection device. %x\n"), GetLastError());
	return fResult;
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midGetPosition(
	PMIDIINSTANCE	pmi,
	PLONGLONG	plcbPosition)
{
	AVPROPERTY	Property;

	Property.guidSet = AVPROPSETID_Control;
	Property.id = AVPROPERTY_CONTROL_POSITION;
	return midConnectionControl(pmi, IOCTL_AV_GET_PROPERTY, &Property, sizeof(Property), plcbPosition, sizeof(*plcbPosition));
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midSetState(
	PMIDIINSTANCE	pmi,
	AVSTATE		State)
{
	AVPROPERTY	Property;

	Property.guidSet = AVPROPSETID_Control;
	Property.id = AVPROPERTY_CONTROL_DEVICESTATE;
	return midConnectionControl(pmi, IOCTL_AV_SET_PROPERTY, &Property, sizeof(Property), &State, sizeof(State));
}

/*	-	-	-	-	-	-	-	-	*/
VOID midServiceData(
	PMIDIINSTANCE	pmi,
	ULONG		cbBytesRead)
{
	PUCHAR	pbData;
	ULONG	cbByte;

	pbData = (PUCHAR)(pmi->psd + 1);
	for (cbByte = 0; cbByte < cbBytesRead;) {
		if (!pmi->ulLastChunkLength) {
			_tprintf(TEXT("%16.16lu\t"), *(PULONG)&pbData[cbByte]);
			cbByte += sizeof(ULONG);
			pmi->ulLastChunkLength = pbData[cbByte++];
		}
		for (; pmi->ulLastChunkLength; pmi->ulLastChunkLength--)
			if (cbByte == cbBytesRead)
				return;
			else
				_tprintf(TEXT("%.2lx "), pbData[cbByte++]);
		cbByte = (cbByte + 3) & ~3;
		_tprintf(TEXT("\n"));
	}
}

/*	-	-	-	-	-	-	-	-	*/
DWORD midThread(
	PMIDIINSTANCE  pmi)
{
	HANDLE		ahWaitList[2];
	PSTREAM_DATA	psd;
	ULONG		cbBytesRead;

	ahWaitList[0] = (HANDLE)pmi->hCloseEvent;
	for (psd = pmi->psd; psd; psd = psd->psdNext)
		if (!ReadFile(pmi->hConnectionDevice, psd + 1, STREAM_SIZE, &cbBytesRead, &psd->ov) && (GetLastError() != ERROR_IO_PENDING))
			_tprintf(TEXT("midThread: initial read failed (%x)\n"), GetLastError());
	for (;;) {
		ahWaitList[1] = pmi->psd->ov.hEvent;
		WaitForMultipleObjects(sizeof(ahWaitList) / sizeof(ahWaitList[0]), ahWaitList, FALSE, INFINITE);
		if (pmi->fClosingDevice)
			break;
		GetOverlappedResult(pmi->hConnectionDevice, &pmi->psd->ov, &cbBytesRead, TRUE);
		midServiceData(pmi, cbBytesRead);
		for (psd = pmi->psd; psd->psdNext; psd = psd->psdNext)
			;
		psd->psdNext = pmi->psd;
		pmi->psd = pmi->psd->psdNext;
		psd = psd->psdNext;
		psd->psdNext = NULL;
		if (!ReadFile(pmi->hConnectionDevice, psd + 1, STREAM_SIZE, &cbBytesRead, &psd->ov) && (GetLastError() != ERROR_IO_PENDING))
			_tprintf(TEXT("midThread: read failed (%x)\n"), GetLastError());
	}
	for (; pmi->psd;) {
		GetOverlappedResult(pmi->hConnectionDevice, &pmi->psd->ov, &cbBytesRead, TRUE);
		midServiceData(pmi, cbBytesRead);
		CloseHandle(pmi->psd->ov.hEvent);
		psd = pmi->psd;
		pmi->psd = psd->psdNext;
		LocalFree(psd);
	}
	return 0;
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midStart(
	PMIDIINSTANCE  pmi)
{
	if (!pmi->hThread) {
		ULONG	cBuffers;

		pmi->hCloseEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		for (cBuffers = 0; cBuffers < STREAM_BUFFERS; cBuffers++) {
			PSTREAM_DATA	psd;

			psd = (PSTREAM_DATA)LocalAlloc(LPTR, sizeof(STREAM_DATA)+STREAM_SIZE);
			psd->ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
			psd->psdNext = pmi->psd;
			pmi->psd = psd;
		}
		pmi->hThread = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)midThread, pmi, 0, &pmi->dwThreadId);
		SetThreadPriority(pmi->hThread, THREAD_PRIORITY_TIME_CRITICAL);
	}
	return midSetState(pmi, AVSTATE_RUN);
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midConnect(
	PMIDIINSTANCE	pmi)
{
	UCHAR			aConnect[sizeof(AVPIN_CONNECT)+sizeof(AVDATAFORMAT_MUSIC)];
	PAVPIN_CONNECT		pConnect;
	PAVDATAFORMAT_MUSIC	pMusic;

	pConnect = (PAVPIN_CONNECT)aConnect;
	pConnect->idPin = 2;
	pConnect->idPinTo = 0;
	pConnect->hConnectTo = NULL;
	pConnect->Protocol.guidSet = AVPROTOCOLSETID_Standard;
	pConnect->Protocol.id = AVPROTOCOL_STANDARD_MUSIC;
	pConnect->Transport.guidSet = AVTRANSPORTSETID_Standard;
	pConnect->Transport.id = AVTRANSPORT_STANDARD_DEVIO;
	pConnect->Priority.ulPriorityClass = AVPRIORITY_NORMAL;
	pConnect->Priority.ulPrioritySubClass = 0;
	pMusic = (PAVDATAFORMAT_MUSIC)(pConnect + 1);
	pMusic->DataFormat.guidMajorFormat = AVDATAFORMAT_TYPE_MUSIC_TIMESTAMPED;
	pMusic->DataFormat.cbFormat = sizeof(AVDATAFORMAT_MUSIC);
	pMusic->idFormat = AVDATAFORMAT_MUSIC_MIDI;
	return midFunctionalControl(pmi, IOCTL_AV_CONNECT, aConnect, sizeof(aConnect), &pmi->hConnectionDevice, sizeof(HANDLE));
}

/*	-	-	-	-	-	-	-	-	*/
BOOLEAN midClose(
	PMIDIINSTANCE  pmi)
{
	AVMETHOD	Method;

	midSetState(pmi, AVSTATE_STOP);
	pmi->fClosingDevice = TRUE;
	Method.guidSet = AVMETHODSETID_Control;
	Method.id = AVMETHOD_CONTROL_CANCELIO | AVMETHOD_TYPE_NONE;
	midConnectionControl(pmi, IOCTL_AV_METHOD, &Method, sizeof(Method), NULL, 0);
	if (pmi->hThread) {
		SetEvent(pmi->hCloseEvent);
		WaitForSingleObject(pmi->hThread, INFINITE);
		CloseHandle(pmi->hThread);
		CloseHandle(pmi->hCloseEvent);
	}
	CloseHandle(pmi->hConnectionDevice);
	CloseHandle(pmi->hFunctionalDevice);
	CloseHandle(pmi->hFunctionalEvent);
	CloseHandle(pmi->hConnectionEvent);
	LocalFree(pmi);
	return TRUE;
}

/*	-	-	-	-	-	-	-	-	*/
BOOL midOpen(
	PMIDIINSTANCE*	ppmi)
{
	HANDLE		hFunctionalDevice;
	PMIDIINSTANCE	pmi;

	hFunctionalDevice = CreateFile(FUNCTIONALID, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (hFunctionalDevice == (HANDLE)-1) {
		_tprintf(TEXT("failed to open functional device (%ld)\n"), GetLastError());
		return FALSE;
	}
	if (pmi = (PMIDIINSTANCE)LocalAlloc(LPTR, sizeof(MIDIINSTANCE))) {
		pmi->hConnectionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		pmi->hFunctionalEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		pmi->hFunctionalDevice = hFunctionalDevice;
		if (midConnect(pmi)) {
			if (midSetState(pmi, AVSTATE_IDLE)) {
				*ppmi = pmi;
				return TRUE;
			} else
				_tprintf(TEXT("Failed to set IDLE state\n\n"));
		} else
			_tprintf(TEXT("Failed to connect device\n\n"));
		CloseHandle(pmi->hFunctionalEvent);
		CloseHandle(pmi->hConnectionEvent);
		LocalFree(pmi);
	} else
		_tprintf(TEXT("failed alloc (%ld)\n"), GetLastError());
	CloseHandle(hFunctionalDevice);
	return FALSE;
}

/*	-	-	-	-	-	-	-	-	*/
int _cdecl main(
	int	argc,
	TCHAR	*argv[],
	TCHAR	*envp[])


{
	PMIDIINSTANCE  pmi;

	if (midOpen(&pmi)) {
		midStart(pmi);
		_tprintf(TEXT("wait..."));
		_fgettchar();
		midClose(pmi);
	}
	return 0;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\filter.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 *   filter.h
 */

/* Structure to specify a filter for MIDI events.
 */
typedef struct filter_tag
{
    BOOL channel[16];
    struct {
        BOOL noteOn;
        BOOL noteOff;
        BOOL keyAftertouch;
        BOOL controller;
        BOOL progChange;
        BOOL chanAftertouch;
        BOOL pitchBend;
        BOOL channelMode;
    
        BOOL sysEx;
        BOOL sysCommon;
        BOOL sysRealTime;
        BOOL activeSense;
        BOOL pad0;
        BOOL pad1;
        BOOL pad2;
        BOOL pad3;
    } event;
} FILTER;

typedef FILTER FAR *LPFILTER;


/* Function prototypes
 */
BOOL CheckEventFilter(LPEVENT lpEvent, LPFILTER lpFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\globals.h ===
//--------------------------------------------------------------------------;
//                                                                           
//  File: GLOBALS.H                                                        
//                                                                           
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          
//                                                                           
//  Abstract:                                                               
//      This header file contains various global various, constants 
//      and prototypes used in MIDIPERF, the MIDI Performance test application 
//      for Chicago.                               
//                                                                           
//  Contents:                                                               
//
//  History:                                                                
//      08/03/93    a-MSava      Created.                                                         
//                                                                           
//--------------------------------------------------------------------------;

#include <mmsystem.h>

//--------------------------------------------------------------------------;
//
//                     CONSTANTS
//
//--------------------------------------------------------------------------;

#define MAXLONGSTR          MAXERRORLENGTH + 50

//   Test Shell Constants

// Menu IDs
#define IDM_OUTPUT_BASE         710
#define IDM_INPUT_BASE          725


// Stops the logging intensive test
#define VSTOPKEY            VK_SPACE

// The string identifiers for the group's names
#define GRP_1                   100
#define GRP_2                   101      
#define GRP_LAST                GRP_2

// The string identifiers for the test's names
#define ID_CPUWORKTEST                  200
#define ID_PERFTEST                     201
#define ID_CPUWORKTEST_MOREDATA         202
#define ID_CPUWORKTEST_CONNECT          203
#define ID_PERFTEST_MOREDATA            204
#define ID_PERFTEST_CONNECT             205

#define ID_TESTLAST             ID_PERFTEST

// Identifies the test list section of the resource file
#define TEST_LIST               500

// Multiple platform support
#define PLTFRM_WIN31            0x0001
#define PLTFRM_WIN4             0x0010
#define PLTFRM_WIN32C           0x0100
#define PLTFRM_WIN32S           0x1000
//#define PLTFRM_WINNT         

#define DEVICE_F_NOTSELECTED    0x8000  //Using an unexpected dev ID
                                        //Can't use -1 since Mapper has this ID

//Callback windows procedure class names
#define CLASSNAME_MIDIPERF_CALLBACK "MIDIPerfCallback"
#define CLASSNAME_MIDIPERF_CALLBACK2 "MIDIPerfCallback2"


//Dialog Box Defines
//#define IDD_CPUWORKTESTPARAMS           101
// These defines are used in both startup dboxes for CPU Work & Perf tests
#define IDE_OS                          1000
#define IDE_TESTTIME                    1002
#define IDE_TESTFILE                    1003
#define IDE_DELTALOGFILE                1004
#define IDCHK_LOGDELTATIMES              1005
#define IDCHK_THRUON                    1006
#define IDE_INPUTBUFSIZE                1007
#define IDC_STATIC                      -1


//Upper and Lower limits on the test time
#define CPUWORKTEST_MINTIME             5000
#define CPUWORKTEST_MAXTIME             50000

#define PERFTEST_DEF_DELTAFILENAME      "deltas.log"

#define MIDI_F_SHORTEVENT    0x0001
#define MIDI_F_LONGEVENT     0x0002

#define TESTLEVEL_F_WIN31       0x0000
#define TESTLEVEL_F_MOREDATA    0x0001
#define TESTLEVEL_F_CONNECT     0x0002
//--------------------------------------------------------------------------;
//
//                     GLOBAL VARIABLES
//
//--------------------------------------------------------------------------;
HINSTANCE   ghinst;         // A handle to the running instance of the test
                            // shell.  It's not used here, but may be used by
                            // test apps.
HWND        ghwndTstShell;  // A handle to the main window of the test shell.



UINT        guiOutputDevID;
UINT        guiInputDevID;              

extern  WORD        gwPlatform;
extern  LPSTR       szAppName;

#define DELTA_EXPECTED           30  //30 msecs between NOTE ONs
#define DELTA_TOLERANCE_IN_MSECS 3

#define LOGOP_F_OPEN             0x00000001
#define LOGOP_F_INTERMED_RESULT  0x00000002
#define LOGOP_F_CLOSE            0x00000004
#define LOGOP_CPUTEST_F_CLOSE    0x00000008


/* Compile-time application metrics
 */
#define MAX_NUM_DEVICES         8       // max # of MIDI input devices
//#define INPUT_BUFFER_SIZE       200     // size of input buffer in events
#define INPUT_BUFFER_SIZE       200     // size of input buffer in events
#define DISPLAY_BUFFER_SIZE     1000    // size of display buffer in events

/* Menu IDs 
 */
#define IDM_SAVE                101
#define IDM_EXIT                102
#define IDM_SETBUFSIZE          201
#define IDM_SETDISPLAY          202
#define IDM_SAVESETUP           203
#define IDM_SENDTOMAPPER        204
#define IDM_FILTCHAN0           300
#define IDM_FILTCHAN1           301
#define IDM_FILTCHAN2           302
#define IDM_FILTCHAN3           303
#define IDM_FILTCHAN4           304
#define IDM_FILTCHAN5           305
#define IDM_FILTCHAN6           306
#define IDM_FILTCHAN7           307
#define IDM_FILTCHAN8           308
#define IDM_FILTCHAN9           309
#define IDM_FILTCHAN10          310
#define IDM_FILTCHAN11          311
#define IDM_FILTCHAN12          312
#define IDM_FILTCHAN13          313
#define IDM_FILTCHAN14          314
#define IDM_FILTCHAN15          315
#define IDM_NOTEOFF             316
#define IDM_NOTEON              317
#define IDM_POLYAFTERTOUCH      318
#define IDM_CONTROLCHANGE       319
#define IDM_PROGRAMCHANGE       320
#define IDM_CHANNELAFTERTOUCH   321
#define IDM_PITCHBEND           322
#define IDM_CHANNELMODE         323
#define IDM_SYSTEMEXCLUSIVE     324
#define IDM_SYSTEMCOMMON        325
#define IDM_SYSTEMREALTIME      326
#define IDM_ACTIVESENSE         327
#define IDM_STARTSTOP           400
#define IDM_CLEAR               500
#define IDM_ABOUT               600

//
//Dialog Control IDs
//
#define IDB_PERFTEST_STOP       700

/* String resource IDs   
 */
#define IDS_APPNAME             1


/* Custom messages sent by low-level callback to application 
 */
#define MM_MIDIINPUT_SHORT          WM_USER + 0
#define MM_MIDIINPUT_LONG           WM_USER + 1
#define PERFTEST_STOP               WM_USER + 2
#define CALLBACKERR_BUFFULL         WM_USER + 3
#define CALLBACKERR_MOREDATA_RCVD   WM_USER + 4


/* The label for the display window.
 */
#define LABEL " TIMESTAMP STATUS DATA1 DATA2 CHAN EVENT                 "

/* Structure for translating virtual key messages to scroll messages.
 */
typedef struct keyToScroll_tag
{
     WORD wVirtKey;
     int  iMessage;
     WORD wRequest;
} KEYTOSCROLL;




/* Structure to store MIDI performance statistics
 */
typedef struct perfstats_tag
{
    DWORD dwShortEventsRcvd;
    DWORD dwLongEventsRcvd;
    DWORD dwLateEvents;
    DWORD dwEarlyEvents;
    DWORD dwTotalDelta;
    DWORD dwAverageDelta;
    DWORD dwLastEventDelta;
    DWORD dwLatestDelta;
    DWORD dwEarliestDelta;
} PERFSTATS;

typedef struct cpuwork_tag
{
    DWORD dwTestTime;
    ULONG ulMIDIThruCntr1;
    ULONG ulMIDIThruCntr2;
    ULONG ulMIDIThruCallbacksShort;
    ULONG ulMIDIThruCallbacksLong;
    ULONG ulMIDINoThruCntr1;
    ULONG ulMIDINoThruCntr2;
    ULONG ulMIDINoThruCallbacksShort;
    ULONG ulMIDINoThruCallbacksLong;
    ULONG ulBaselineCntr1;
    ULONG ulBaselineCntr2;
    ULONG ulBaselineCallbacksShort;
    ULONG ulBaselineCallbacksLong;
} CPUWORK;
typedef CPUWORK FAR *LPCPUEVENT;


/* Structure to represent a single MIDI event.
 */
typedef struct event_tag
{
    DWORD dwDevice;
    DWORD timestamp;
    DWORD data;
} EVENT;
typedef EVENT FAR *LPEVENT;





// Circbuf.h includes
/* Structure to manage the circular input buffer.
 */
typedef struct circularBuffer_tag
{
    HANDLE  hSelf;          /* handle to this structure */
    HANDLE  hBuffer;        /* buffer handle */
    WORD    wError;         /* error flags */
    ULONG   ulSize;         /* buffer size (in EVENTS) */
    ULONG   ulCount;        /* byte count (in EVENTS) */
    LPEVENT lpStart;        /* ptr to start of buffer */
    LPEVENT lpEnd;          /* ptr to end of buffer (last byte + 1) */
    LPEVENT lpHead;         /* ptr to head (next location to fill) */
    LPEVENT lpTail;         /* ptr to tail (next location to empty) */
} CIRCULARBUFFER;
typedef CIRCULARBUFFER FAR *LPCIRCULARBUFFER;


/* Function prototypes
 */
LPCIRCULARBUFFER AllocCircularBuffer(ULONG ulSize);
VOID FreeCircularBuffer(LPCIRCULARBUFFER lpBuf);
WORD GetEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent);


// Callback.c Function prototypes
//
VOID midiInputHandler (HMIDIIN, WORD, DWORD, DWORD, DWORD);
BOOL PutEvent (LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent);



// Instdata.h includes
/*
 * instdata.h
 */

/* Structure to pass instance data from the application
   to the low-level callback function.
 */
typedef struct callbackInstance_tag
{
    HWND                hWnd;
    HANDLE              hSelf;  
    DWORD               dwDevice;
    DWORD               fdwLevel;
    LPCIRCULARBUFFER    lpBuf;
    //HMIDIOUT            hMapper; Changed to make this any output device
    HMIDIOUT            hMidiOut;
    ULONG               ulCallbacksShort;
    ULONG               ulCallbacksLong;
    BOOL                fPostEvent;
    ULONG               ulPostMsgFails;
} CALLBACKINSTANCEDATA;
typedef CALLBACKINSTANCEDATA FAR *LPCALLBACKINSTANCEDATA;

/* Function prototypes
 */
LPCALLBACKINSTANCEDATA AllocCallbackInstanceData(void);
VOID FreeCallbackInstanceData(LPCALLBACKINSTANCEDATA lpBuf);





typedef struct testparams_tag
{
    DWORD   dwCPUWorkTestTime;
    DWORD   dwInputBufSize;
    BYTE    szCPUWorkTestFile[MAXLONGSTR];
    BYTE    szCPUWorkTestOS[MAXLONGSTR];
    BYTE    szPerfTestFile[MAXLONGSTR];
    BYTE    szPerfTestOS[MAXLONGSTR];
    BYTE    szPerfTestDeltaFile[MAXLONGSTR];
    BYTE    szInputDevice[MAXLONGSTR];
    BYTE    szOutputDevice[MAXLONGSTR];

} TESTPARAMS;

TESTPARAMS  gtestparams;




/* Function prototypes 
 */
//LRESULT FAR PASCAL WndProc(HWND, UINT, WPARAM , LPARAM);
//VOID CommandMsg(HWND hWnd, WPARAM wParam, LPARAM lParam);
//void DoMenuItemCheck(HWND hWnd, WORD menuItem, BOOL newState);
//void SetupCustomChecks(HANDLE hInstance, HWND hWnd);
//BOOL InitFirstInstance(HANDLE);
//int Error(LPSTR msg);
//VOID UpdatePerformanceStats (LPEVENT);
//VOID LogPerformanceStats (DWORD);

int RunCPUWorkTest (DWORD fdwLevel);
int RunPerfTest (DWORD fdwLevel);

LONG glpfnMIDIPerfCallback
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
);

LONG glpfnMIDIPerfCallback2
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
);


int tstGetTestInfo
(
    HINSTANCE hinstance,
    LPSTR lpszTestName,
    LPSTR lpszPathSection,
    LPWORD wPlatform
);

BOOL tstInit (HWND hwndMain);
int execTest (int nFxID, int nCase, UINT nID, UINT wGroupID);
VOID tstTerminate (void);

WORD GetWinVersion(void);
BOOL GetTestDevsInfo(void);
 
BOOL GetDeviceID(LPSTR pszName, UINT *puDeviceID, UINT uMidiType);

BOOL ValidateBufSettings (HWND hdlg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\midiperf.c ===
//--------------------------------------------------------------------------;
//
//  File: Midiperf.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Contains the startup code for the MIDIPERF test application. This
//      application measures the performance of the MIDI subsystem and also
//      the work required by the CPU to record and play MIDI data.
//
//
//  Contents:
//      tstGetTestInfo()
//      tstInit()
//      InitDeviceMenu()
//      tstTerminate()
//      GetWinVersion()
//      MenuProc()
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;
#include <windows.h>
#include <mmsystem.h>
#include <tstshell.h>
#include <stdio.h>
#include "globals.h"
#include "prefer.h"
#include "filter.h"
 

PREFERENCES preferences;                // User preferences structure
PERFSTATS   perfstats;                  // Performance Statistics structure

MIDIINCAPS  midiInCaps;                 // Device capabilities structures
HMIDIIN     hMidiIn;                    // MIDI input device handles
MIDIOUTCAPS midiOutCaps;
HMIDIOUT    hMidiOut;


// Display filter structure
FILTER filter = {
                    0, 0, 0, 0, 0, 0, 0, 0, 
                    0, 0, 0, 0, 0, 0, 0, 0, 
                    0, 0, 0, 0, 0, 0, 0, 0, 
                    0, 0, 0, 0, 0, 0, 0, 0
                };


HMENU       hmenuOptions;   // A handle to the options menu
WORD        gwPlatform;     // Platform the tests are currently running on

// App Name
LPSTR           szAppName = "MIDIPerf Test - 32-Bit";

VOID InitDeviceMenu 
(
    void
);

LRESULT MenuProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
);

//--------------------------------------------------------------------------;
//
//  int tstGetTestInfo
//
//  Description:
//      Called by the test shell to get information about the test.  Also
//      saves a copy of the running instance of the test shell.
//
//  Arguments:
//      HINSTANCE hinstance: A handle to the running instance of the test
//          shell
//
//      LPSTR lpszTestName: Pointer to buffer of name for test.  Among
//          other things, it is used as a caption for the main window and
//          as the name of its class.
//
//      LPSTR lpszPathSection: Pointer to buffer of name of section in
//          win.ini in which the default input and output paths are
//          stored.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically.  In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on.  It is enough for one bit to be turned off
//          to disqualify the test.  This also means that if this value is
//          zero, all tests will be run.  In order to make this more
//          mathematically precise, I shall give the relation which Test
//          Shell uses to decide whether a test with platform flags
//          wTestPlatform may run:  It may run if the following is TRUE:
//          ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      The value which identifies the test list resouce (found in the
//      resource file).
//
//  History:
//      08/03/93    T-OriG
//      08/02/93    A-MSava     Modified for use in MIDIPERF.
//
//--------------------------------------------------------------------------;

int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      wPlatform
)
{
    ghinst = hinstance;     // Save a copy of a handle to the running
                            // instance of test shell. 
    lstrcpy (lpszTestName, szAppName);
    lstrcpy (lpszPathSection, szAppName);

    
    gwPlatform = GetWinVersion();   // The platform the test is running on,
                                    // to be determined dynamically.  
    *wPlatform = gwPlatform;

    return TEST_LIST;
} // information()


//--------------------------------------------------------------------------;
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell to provide the test program with an
//      opportunity to do whatever initialization it needs to do before
//      user interaction is initiated.  It also provides the test program
//      with an opportunity to keep a copy of a handle to the main window,
//      if the test program needs it.  In order to use some of the more
//      advanced features of test shell, several installation must be done
//      here:
//
//      -- If the test application would like to use the status bar for
//          displaying the name of the currently running test, it must
//          call tstDisplayCurrentTest here.
//
//      -- If the test application would like to add dynamic test cases
//          to the test list, it must first add their names to the
//          virtual string table using tstAddNewString (and add their
//          group's name too), and then add the actual tests using
//          tstAddTestCase.  The virtual string table is an abstraction
//          which behaves just like a string table from the outside with
//          the exception that it accepts dynamically added string.
//
//  Arguments:
//      HWND hwndMain: A handle to the main window
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//  History:
//      
//
//--------------------------------------------------------------------------;

BOOL tstInit
(
    HWND    hwndMain
)
{
    char        szErrorText[256];
    WORD        wNumDevices;
    WORD        i;
    WORD        wRtn;
    WNDCLASS    wc;

    // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    //Initialize Test Parameters

    gtestparams.dwInputBufSize = INPUT_BUFFER_SIZE;

    wsprintf ((LPSTR) &gtestparams.szPerfTestDeltaFile[0], PERFTEST_DEF_DELTAFILENAME);

    wNumDevices = midiInGetNumDevs();
    if (!wNumDevices)
    {
        MessageBox(
            ghwndTstShell,
            "No MIDI input driver is loaded. Unable to run Performance Test. Exiting...",
            szAppName,
            MB_OK | MB_APPLMODAL);

        return FALSE;
    }
    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++)
    {
        wRtn = midiInGetDevCaps(i, (LPMIDIINCAPS) &midiInCaps,
                                sizeof(MIDIINCAPS));
        if(wRtn)
        {
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, 
                               sizeof(szErrorText));
            MessageBox(
                ghwndTstShell,
                szErrorText,
                szAppName,
                MB_OK | MB_APPLMODAL);

            return FALSE;
        }
    }
    
    wNumDevices = midiOutGetNumDevs();
    if (!wNumDevices)
    {
        MessageBox(
            ghwndTstShell,
            "No MIDI output driver is loaded. Unable to run Performance Test. Exiting...",
            szAppName,
            MB_OK | MB_APPLMODAL);

        return FALSE;
    }
    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++)
    {
        wRtn = midiOutGetDevCaps(i, (LPMIDIOUTCAPS) &midiOutCaps,
                                sizeof(MIDIOUTCAPS));
        if(wRtn)
        {
            midiOutGetErrorText(wRtn, (LPSTR)szErrorText, 
                               sizeof(szErrorText));
            MessageBox(
                ghwndTstShell,
                szErrorText,
                szAppName,
                MB_OK | MB_APPLMODAL);

            return FALSE;
        }
    }

    // This is a shell API which tells Test Shell to display the name of
    // the currenly executing API in its status bar.  It is a really nice
    // feature for test applications which do not use the toolbar for any
    // other purpose, as it comfortably notifies the user of the progress
    // of the tests.
    tstDisplayCurrentTest();


    //
    // Initialize the input and output device selection to NOTSELECTED
    //
    guiInputDevID = DEVICE_F_NOTSELECTED;
    guiOutputDevID = DEVICE_F_NOTSELECTED;

    InitDeviceMenu ();


    //
    // Define the class for the input notification window procs.
    //                                               
    wc.lpszClassName    = CLASSNAME_MIDIPERF_CALLBACK2;
    wc.style            = CS_HREDRAW | CS_VREDRAW; //Not used
    wc.hCursor          = NULL;
    wc.hIcon            = NULL;
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = NULL;
    wc.hInstance        = ghinst;
    wc.lpfnWndProc      = (WNDPROC) glpfnMIDIPerfCallback2;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = sizeof (DWORD);
    
    if (!RegisterClass (&wc))
    {
        MessageBox(
            ghwndTstShell,
            "Error trying to register window class(2)! Exiting...",
            szAppName,
            MB_OK | MB_APPLMODAL);
        return FALSE;
    }

    //
    // Define the class for the input notification window procs.
    //                                               
    wc.lpszClassName    = CLASSNAME_MIDIPERF_CALLBACK;
    wc.style            = CS_HREDRAW | CS_VREDRAW; //Not used
    wc.hCursor          = NULL;
    wc.hIcon            = NULL;
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = NULL;
    wc.hInstance        = ghinst;
    wc.lpfnWndProc      = (WNDPROC) glpfnMIDIPerfCallback;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = sizeof (DWORD);
    
    if (!RegisterClass (&wc))
    {
        MessageBox(
            ghwndTstShell,
            "Error trying to register window class! Exiting...",
            szAppName,
            MB_OK | MB_APPLMODAL);
        return FALSE;
    }
    return TRUE;
} // tstInit()


//--------------------------------------------------------------------------;
//
//  void InitDeviceMenu
//
//  Description:
//      Add input and output MIDI devices to the menu to allow the user
//      to select a desired device.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

void InitDeviceMenu 
(
    void
)
{
    UINT        u;
    UINT        uDevs;
    MMRESULT    mmr;
    MIDIINCAPS  mic;
    MIDIOUTCAPS moc;
    
    uDevs = midiInGetNumDevs ();
    
    for (u = 0; u < uDevs; u++)
    {
        mmr = midiInGetDevCaps (u, &mic, sizeof (MIDIINCAPS));
        
        if (MMSYSERR_NOERROR == mmr)
        {        
        tstInstallCustomTest (
            "&Input Devices",
            mic.szPname,
            (u + IDM_INPUT_BASE),
            MenuProc);                    
            
        }
        else
        {
            tstLog (TERSE, "Error adding input device to menu (ID = %u)", u);
        }
    }
    
       
    uDevs = midiOutGetNumDevs ();
    tstInstallCustomTest (
        "&Output Devices",
        "MIDI Mapper",
        IDM_OUTPUT_BASE,
        MenuProc);
    
    for (u = 0; u < uDevs; u++)
    {
        mmr = midiOutGetDevCaps (u, &moc, sizeof (MIDIOUTCAPS));
        
        if (MMSYSERR_NOERROR == mmr)
        {        
        tstInstallCustomTest (
            "&Output Devices",
            moc.szPname,
            (u + IDM_OUTPUT_BASE + 1),
            MenuProc);

        }
        else
        {
            tstLog (TERSE, "Error adding output device to menu (ID = %u)", u);
        }
    }       
} //InitDeviceMenu
    
                                                                                     
//--------------------------------------------------------------------------;
//
//  void tstTerminate
//
//  Description:
//      This function is called when the test series is finished to free
//      structures and do whatever cleanup work it needs to do.  If it
//      does not need to do anything, it may just return.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      
//
//--------------------------------------------------------------------------;

void tstTerminate
(
    void
)
{
    return;
} // tstTerminate()



WORD GetWinVersion(void)
{
    DWORD   dwVersion;

    dwVersion=GetVersion();
    return PLTFRM_WIN32C;
}




//--------------------------------------------------------------------------;
//
//  BOOL MenuProc
//
//  Description:
//      Hooks into test shell's main menu proc to handle
//      custom menu options.
//
//  Arguments:
//
//  Return (LONG):
//      TRUE if no error. Else FALSE.
//
//  History:
//
//--------------------------------------------------------------------------;
LRESULT MenuProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UINT    u;

    switch (wParam)
    {

        default:                             
        
            u = midiInGetNumDevs ();      
            
            if ((wParam >= (IDM_INPUT_BASE)) &&
                (wParam <= (IDM_INPUT_BASE + u)))
            {
                // Set Input Device ID to selected device
                guiInputDevID = wParam - IDM_INPUT_BASE;
                
                // Set Test Parameter Input Device string
                GetMenuString
                    (
                    GetMenu (ghwndTstShell),
                    wParam,
                    gtestparams.szInputDevice,
                    sizeof (gtestparams.szInputDevice) - 1,
                    MF_BYCOMMAND
                    );


                //Input Device state change
                for (u += (IDM_INPUT_BASE); u >= IDM_INPUT_BASE; u--)
                {
                    CheckMenuItem (
                        GetMenu (ghwndTstShell),
                        u,
                        MF_BYCOMMAND | ((wParam == u) ? MF_CHECKED: MF_UNCHECKED));
                }         
            }
            else
            {
                u = midiOutGetNumDevs ();
                
                if ((wParam >= (IDM_OUTPUT_BASE)) &&
                    (wParam <= (IDM_OUTPUT_BASE + u)))
                {
                    guiOutputDevID = wParam - IDM_OUTPUT_BASE - 1;
        
                    // Set Test Parameter Output Device string
                    GetMenuString
                        (
                        GetMenu (ghwndTstShell),
                        wParam,
                        gtestparams.szOutputDevice,
                        sizeof (gtestparams.szOutputDevice) - 1,
                        MF_BYCOMMAND
                        );

                    //Output Device state change
                    for (u += (IDM_OUTPUT_BASE + 1); u >= IDM_OUTPUT_BASE; u--)
                    {
                        CheckMenuItem (
                            GetMenu (ghwndTstShell),
                            u,
                            MF_BYCOMMAND | ((wParam == u) ? MF_CHECKED: MF_UNCHECKED));
                    }
                }
            }
            break;
    }

    return 0L;
} // MenuProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\midiperf.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 *    midiperf.h
 */

#define DELTA_EXPECTED           30  //30 msecs between NOTE ONs
#define DELTA_TOLERANCE_IN_MSECS 3

#define LOGOP_F_OPEN             0x00000001
#define LOGOP_F_INTERMED_RESULT  0x00000002
#define LOGOP_F_CLOSE            0x00000004
#define LOGOP_CPUTEST_F_CLOSE    0x00000008


/* Compile-time application metrics
 */
#define MAX_NUM_DEVICES         8       // max # of MIDI input devices
#define INPUT_BUFFER_SIZE       200     // size of input buffer in events
#define DISPLAY_BUFFER_SIZE     1000    // size of display buffer in events

/* Menu IDs 
 */
#define IDM_SAVE                101
#define IDM_EXIT                102
#define IDM_SETBUFSIZE          201
#define IDM_SETDISPLAY          202
#define IDM_SAVESETUP           203
#define IDM_SENDTOMAPPER        204
#define IDM_FILTCHAN0           300
#define IDM_FILTCHAN1           301
#define IDM_FILTCHAN2           302
#define IDM_FILTCHAN3           303
#define IDM_FILTCHAN4           304
#define IDM_FILTCHAN5           305
#define IDM_FILTCHAN6           306
#define IDM_FILTCHAN7           307
#define IDM_FILTCHAN8           308
#define IDM_FILTCHAN9           309
#define IDM_FILTCHAN10          310
#define IDM_FILTCHAN11          311
#define IDM_FILTCHAN12          312
#define IDM_FILTCHAN13          313
#define IDM_FILTCHAN14          314
#define IDM_FILTCHAN15          315
#define IDM_NOTEOFF             316
#define IDM_NOTEON              317
#define IDM_POLYAFTERTOUCH      318
#define IDM_CONTROLCHANGE       319
#define IDM_PROGRAMCHANGE       320
#define IDM_CHANNELAFTERTOUCH   321
#define IDM_PITCHBEND           322
#define IDM_CHANNELMODE         323
#define IDM_SYSTEMEXCLUSIVE     324
#define IDM_SYSTEMCOMMON        325
#define IDM_SYSTEMREALTIME      326
#define IDM_ACTIVESENSE         327
#define IDM_STARTSTOP           400
#define IDM_CLEAR               500
#define IDM_ABOUT               600

/* String resource IDs   
 */
#define IDS_APPNAME             1


/* Custom messages sent by low-level callback to application 
 */
#define MM_MIDIINPUT    WM_USER + 0


/* The label for the display window.
 */
#define LABEL " TIMESTAMP STATUS DATA1 DATA2 CHAN EVENT                 "

/* Structure for translating virtual key messages to scroll messages.
 */
typedef struct keyToScroll_tag
{
     WORD wVirtKey;
     int  iMessage;
     WORD wRequest;
} KEYTOSCROLL;

/* Structure to store MIDI performance statistics
 */
typedef struct perfstats_tag
{
    DWORD dwShortEventsRcvd;
    DWORD dwLateEvents;
    DWORD dwEarlyEvents;
    DWORD dwTotalDelta;
    DWORD dwAverageDelta;
    DWORD dwLastEventDelta;
    DWORD dwLatestDelta;
    DWORD dwEarliestDelta;
} PERFSTATS;


/* Structure to represent a single MIDI event.
 */
typedef struct event_tag
{
    DWORD dwDevice;
    DWORD timestamp;
    DWORD data;
} EVENT;
typedef EVENT FAR *LPEVENT;


/* Function prototypes 
 */
LRESULT WndProc(HWND, UINT, WPARAM , LPARAM);
VOID CommandMsg(HWND hWnd, WPARAM wParam, LPARAM lParam);
VOID DoMenuItemCheck(HWND hWnd, WORD menuItem, BOOL newState);
VOID SetupCustomChecks(HANDLE hInstance, HWND hWnd);
BOOL InitFirstInstance(HANDLE);
int Error(LPSTR msg);
VOID UpdatePerformanceStats (LPEVENT);
VOID LogPerformanceStats (DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\instdata.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 * instdata.c - Functions to allocate and free the instance
 *      data structure passed to the low-level callback function.
 */

#include <windows.h>
#include <mmsystem.h>
#include "globals.h"
//#include "circbuf.h"
//#include "instdata.h"

/* AllocCallbackInstanceData - Allocates a CALLBACKINSTANCEDATA
 *      structure.  This structure is used to pass information to the
 *      low-level callback function, each time it receives a message.
 *
 *      Because this structure is accessed by the low-level callback
 *      function, it must be allocated using GlobalAlloc() with the 
 *      GMEM_SHARE and GMEM_MOVEABLE flags and page-locked with
 *      GlobalPageLock().
 *
 * Params:  void
 *
 * Return:  A pointer to the allocated CALLBACKINSTANCE data structure.
 */
LPCALLBACKINSTANCEDATA AllocCallbackInstanceData(void)
{
    HANDLE hMem;
    LPCALLBACKINSTANCEDATA lpBuf;
    
    /* Allocate and lock global memory.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(CALLBACKINSTANCEDATA));
    if(hMem == NULL)
        return NULL;
    
    lpBuf = (LPCALLBACKINSTANCEDATA)GlobalLock(hMem);
    if(lpBuf == NULL){
        GlobalFree(hMem);
        return NULL;
    }
    
    /* Page lock the memory.
     */
    //GlobalPageLock((HGLOBAL)HIWORD(lpBuf)); //This line was commented in MIDIMON

    /* Save the handle.
     */
    lpBuf->hSelf = hMem;

    return lpBuf;
}

/* FreeCallbackInstanceData - Frees the given CALLBACKINSTANCEDATA structure.
 *
 * Params:  lpBuf - Points to the CALLBACKINSTANCEDATA structure to be freed.
 *
 * Return:  void
 */
VOID FreeCallbackInstanceData(LPCALLBACKINSTANCEDATA lpBuf)
{
    HANDLE hMem;

    /* Save the handle until we're through here.
     */
    hMem = lpBuf->hSelf;

    /* Free the structure.
     */
    //GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//  History:
//       9/21/93    cjp     [curtisp] 
//       9/23/93    stl     [toddla]
//       1/26/94    rmh     [bobhed]
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#if ( defined(WIN32) || defined(_WIN32) ) && !defined(WIN4)

    //
    //  Compile for Daytona - use __int64 support on C9.
    //


    INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
    {
        return (LONG)( ((LONGLONG)a*b) / c );
    }


    INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( ((DWORDLONG)a*b) / c );
    }


    INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (((DWORDLONG)a*b)+c/2) / c );
    }


    INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (((DWORDLONG)a*b)+c-1) / c );
    }


#else

    //
    //  Compile for Win16 or Chicago - either way, we can use X86 assembly.
    //
    #pragma warning(disable:4035 4704)

#ifdef WIN32

    //
    //  Compile for 32-bit Chicago - we can use i386 assembly.
    //
    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
	_asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
	_asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     shr     ebx,1            //  sar  ebx,1
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     dec     ebx              //  dec  ebx
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRD32()

#else

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //
    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

#endif

    #pragma warning(default:4035 4704)


#endif

//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\midprfcb.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/* callback.c - Contains the low-level MIDI input callback function for
 *      MIDIPerf.  This module also contains the LibMain() and WEP() 
 *      DLL routines, and other functions accessed by the callback.
 *
 *      Because this module contains a low-level callback function,
 *      this entire module must reside in a FIXED code segment in a DLL.
 *      The data segment must be FIXED as well, since it accessed by
 *      the callback.
 */

#include <windows.h>
#include <mmsystem.h>
#include "globals.h"

static EVENT event;
    
/* midiInputHandler - Low-level callback function to handle MIDI input.
 *      Installed by midiInOpen().  The input handler takes incoming
 *      MIDI events and places them in the circular input buffer.  It then
 *      notifies the application by posting a MM_MIDIINPUT message.
 *
 *      This function is accessed at interrupt time, so it should be as 
 *      fast and efficient as possible.  You can't make any
 *      Windows calls here, except PostMessage().  The only Multimedia
 *      Windows call you can make are timeGetSystemTime(), midiOutShortMsg().
 *      
 *
 * Param:   hMidiIn - Handle for the associated input device.
 *          wMsg - One of the MIM_***** messages.
 *          dwInstance - Points to CALLBACKINSTANCEDATA structure.
 *          dwParam1 - MIDI data.
 *          dwParam2 - Timestamp (in milliseconds)
 *
 * Return:  void
 */     
VOID midiInputHandler
(
    HMIDIIN     hMidiIn, 
    WORD        wMsg, 
    DWORD       dwInstance, 
    DWORD       dwParam1, 
    DWORD       dwParam2
)
{
    switch(wMsg)
    {
        case MIM_OPEN:
            break;

        /* The only error possible is invalid MIDI data, so just pass
         * the invalid data on so we'll see it.
         */
        case MIM_ERROR:


        case MIM_DATA:
//            OutputDebugStr ("MIM_DATA received");
            event.dwDevice = ((LPCALLBACKINSTANCEDATA)dwInstance)->dwDevice;
            event.data = dwParam1;
            event.timestamp = dwParam2;
            
            ((LPCALLBACKINSTANCEDATA)dwInstance)->ulCallbacksShort++;

            // If we're not using the midiConnect api to thru the input data
            // send the MIDI event to the output destination, put it in the
            // circular input buffer, and notify the application that
            // data was received.
            //

            if(((LPCALLBACKINSTANCEDATA)dwInstance)->hMidiOut)
            {
                midiOutShortMsg (
                        ((LPCALLBACKINSTANCEDATA)dwInstance)->hMidiOut, 
                        dwParam1
                        );
            }

            if(((LPCALLBACKINSTANCEDATA)dwInstance)->fPostEvent)
            {
                if (!PutEvent(((LPCALLBACKINSTANCEDATA)dwInstance)->lpBuf,
                       (LPEVENT) &event))
                {
                    if (!PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                          CALLBACKERR_BUFFULL, 0, 0L))
                    {
                        ;
                        //++((LPCALLBACKINSTANCEDATA)dwInstance)->ulPostMsgFails;
                    }
                }
                else
                {
                    if (!PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                          MM_MIDIINPUT_SHORT, 0, 0L))
                    {
                        ++((LPCALLBACKINSTANCEDATA)dwInstance)->ulPostMsgFails;
                    }
                }
            }
            break;

        case MIM_MOREDATA:
            //OutputDebugStr ("MIM_MOREDATA received");
            //
            // Right now verify that we only receive this message if the input device
            // was opened in the correct mode.
            //
            if (TESTLEVEL_F_MOREDATA != ((LPCALLBACKINSTANCEDATA)dwInstance)->fdwLevel)
            {
                PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                      CALLBACKERR_MOREDATA_RCVD, 0, 0L);

            }
            event.dwDevice = ((LPCALLBACKINSTANCEDATA)dwInstance)->dwDevice;
            event.data = dwParam1;
            event.timestamp = dwParam2;
            
            ((LPCALLBACKINSTANCEDATA)dwInstance)->ulCallbacksShort++;

            if(((LPCALLBACKINSTANCEDATA)dwInstance)->hMidiOut)
            {
                midiOutShortMsg (
                        ((LPCALLBACKINSTANCEDATA)dwInstance)->hMidiOut, 
                        dwParam1
                        );
            }

            // With the MIM_MOREDATA message we don't call PostMessage with
            // the MM_MIDIINPUT_SHORT message, instead we keep filling 
            // the input buffer here in the DLL until we receive a 
            // MIM_DATA message and then call PostMessage to have the app
            // unload this input buffer. This prevents us from losing data
            // if we're being bombarded with events.            //

            if(((LPCALLBACKINSTANCEDATA)dwInstance)->fPostEvent)
            {
                if (!PutEvent(((LPCALLBACKINSTANCEDATA)dwInstance)->lpBuf,
                       (LPEVENT) &event))
                {
                    if (!PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                          CALLBACKERR_BUFFULL, 0, 0L))
                    {
                        ;
                        //++((LPCALLBACKINSTANCEDATA)dwInstance)->ulPostMsgFails;
                    }
                }
            }
            break;


        case MIM_LONGDATA:
            OutputDebugStr ("MIM_LONGDATA received");
            event.dwDevice = ((LPCALLBACKINSTANCEDATA)dwInstance)->dwDevice;

            // For now drop the long data and don't provide any thru support
            //
            event.data = dwParam1;
            event.timestamp = dwParam2;
            
            ((LPCALLBACKINSTANCEDATA)dwInstance)->ulCallbacksLong++;

            /* Send the MIDI event to the MIDI Mapper, put it in the
             * circular input buffer, and notify the application that
             * data was received.
             */
            //if(((LPCALLBACKINSTANCEDATA)dwInstance)->hMapper)
            //    midiOutShortMsg( 
            //                ((LPCALLBACKINSTANCEDATA)dwInstance)->hMapper, 
            //                  dwParam1);
            
            //A-MSava changed the above lines for MIDIPERF to allow echo to
            //any installed output device. This required a change to the
            //EVENT structure
            //if(((LPCALLBACKINSTANCEDATA)dwInstance)->hMidiOut)
            //    midiOutShortMsg( 
            //                ((LPCALLBACKINSTANCEDATA)dwInstance)->hMidiOut, 
            //                  dwParam1);

            if (!PutEvent(((LPCALLBACKINSTANCEDATA)dwInstance)->lpBuf,
                   (LPEVENT) &event))
            {
                PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                      CALLBACKERR_BUFFULL, 0, 0L);
            }
            else
            {
                PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                      MM_MIDIINPUT_LONG, 0, 0L);
            }
            break;



        default:
            break;
    }
} // midiInputHandler()

/* PutEvent - Puts an EVENT in a CIRCULARBUFFER.  If the buffer is full, 
 *      it sets the wError element of the CIRCULARBUFFER structure 
 *      to be non-zero.
 *
 * Params:  lpBuf - Points to the CIRCULARBUFFER.
 *          lpEvent - Points to the EVENT.
 *
 * Return:  void
*/
BOOL PutEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent)
{
    /* If the buffer is full, set an error and return. 
     */
    if(lpBuf->ulCount >= lpBuf->ulSize)
    {
        lpBuf->wError = 1;
        return FALSE;
    }
    
    /* Put the event in the buffer, bump the head pointer and the byte count.
     */
    *lpBuf->lpHead = *lpEvent;
    
    ++lpBuf->lpHead;
    ++lpBuf->ulCount;

    /* Wrap the head pointer, if necessary.
     */
    if(lpBuf->lpHead >= lpBuf->lpEnd)
        lpBuf->lpHead = lpBuf->lpStart;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\prefer.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 * prefer.c - Routines to get and set user preferences.
 */

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <tstshell.h>
#include "globals.h"
#include "prefer.h"

/* getPreferences - Reads .INI file and gets the setup preferences.
 *      Currently, the only user preferences are window location and size.
 *      If the .INI file does not exist, returns default values.
 *
 * Params:  lpPreferences - Points to a PREFERENCES data structure that
 *              is filled with the retrieved user preferences.
 *
 * Return:  void
*/
VOID getPreferences(LPPREFERENCES lpPreferences, HWND hMainWnd)
{
    BYTE szMsg[80];

    lpPreferences->iInitialX = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_X, DEF_X, INI_FILENAME);

    lpPreferences->iInitialY = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_Y, DEF_Y, INI_FILENAME);

    lpPreferences->iInitialW = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_W, DEF_W, INI_FILENAME);

    lpPreferences->iInitialH = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_H, DEF_H, INI_FILENAME);


    lpPreferences->uiPerfLogType =
        GetPrivateProfileInt(INI_PERFTESTPARAMS, INI_LOGTYPE, DEF_LOGTYPE, INI_FILENAME);


    wsprintf (szMsg, "LogType: %d", lpPreferences->uiPerfLogType);
    MessageBox (hMainWnd, szMsg, "MIDIPerf", MB_OK);


    lpPreferences->uiExpDelta =
        GetPrivateProfileInt(INI_PERFTESTPARAMS, INI_EXPDELTA, DEF_EXPDELTA, INI_FILENAME);

    wsprintf (szMsg, "ExpDelta: %d", lpPreferences->uiExpDelta);
    MessageBox (hMainWnd, szMsg, "MIDIPerf", MB_OK);

    lpPreferences->uiTolerance =
        GetPrivateProfileInt(INI_PERFTESTPARAMS, INI_TOLERANCE, DEF_TOLERANCE, INI_FILENAME);

    wsprintf (szMsg, "Tolerance: %d", lpPreferences->uiTolerance);
    MessageBox (hMainWnd, szMsg, "MIDIPerf", MB_OK);


}

/* setPreferences - Writes the .INI file with the given setup preferences.
 *
 * Params:  lpPreferences - Points to a PREFERENCES data structure containing
 *              the user preferences.
 *
 * Return:  void
 */
VOID setPreferences(LPPREFERENCES lpPreferences)
{
    char szTempString[20];

    sprintf(szTempString, "%d", lpPreferences->iInitialX);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_X,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        tstLog (TERSE, "Error writing MIDIPERF.INI");
        
    sprintf(szTempString, "%d", lpPreferences->iInitialY);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_Y,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        tstLog (TERSE, "Error writing MIDIPERF.INI");
        
    sprintf(szTempString, "%d", lpPreferences->iInitialW);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_W,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        tstLog (TERSE, "Error writing MIDIPERF.INI");
        
    sprintf(szTempString, "%d", lpPreferences->iInitialH);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_H,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        tstLog (TERSE, "Error writing MIDIPERF.INI");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\perftest.c ===
//--------------------------------------------------------------------------;
//
//  File: perftest.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Contains the MIDI performance test code which logs the delta time for 
//      recieved events to a separate file. The data in the log file can then
//      be used to obtain information such as the number of events dropped at
//      stressful MIDI input data rates, and also the difference in MIDI driver
//      performance comparing the same driver on difference OS's (Win3.1 &
//      Chicago) or comparing different drivers on the same OS (i.e. compare
//      Chicago's SBPro driver with Win3.1's on Chicago).
//
//
//  Contents:
//      RunPerfTest()
//      ComputeAndLogPerfResults()
//      PerformPerfTest()
//      glpfnMIDIPerfCallback2()
//      PerfParamsDlg()
//      UpdatePerformanceStats()
//      LogDelta()
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>
#include <mmsystem.h>
#include <tstshell.h>   // Include file for the test shell's APIs
#include "globals.h"    // Various constants and prototypes
//#include "muldiv32.h"


BOOL bRecordingEnabled = 1;             // Enable/disable recording flag
BOOL bEnablePerformanceTest = 1;        // Flag to Enable/Disable logging of
                                        // performance statistics.
BOOL gfStopTest;
BOOL gfLogDeltaTimes = TRUE;
BOOL gfMIDIThru;


HGLOBAL     ghwndMIDIPerfCallback2;
HFILE       ghDeltaFile;
PERFSTATS   perfstats;


BOOL PerformPerfTest (VOID);

BOOL ComputeAndLogPerfResults
(
);

LRESULT PerfParamsDlg
(
    HWND    hdlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
);

LRESULT PerfTestStopDlg
(
    HWND    hdlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
);

VOID UpdatePerformanceStats
(
    LPEVENT lpCurrentEvent,
    DWORD   dwfEventType
);

VOID LogDelta (void);

// Callback instance data pointers
LPCALLBACKINSTANCEDATA lpCallbackInstanceData;
LPCIRCULARBUFFER lpInputBuffer;         // Input buffer structure


//--------------------------------------------------------------------------;
//
//  int RunPerfTest
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

int RunPerfTest (DWORD fdwLevel)
{
    char        szErrorText[MAXLONGSTR];
    WORD        wRtn;
    HMIDIIN     hMidiIn;
    HMIDIOUT    hMidiOut;
    int         iTstStatus = TST_PASS;
    DLGPROC     lpfnDlg;
    int         iRet;

    //
    // First make sure that the user has selected an input and output device.
    // 
    if (DEVICE_F_NOTSELECTED == guiInputDevID)
    {
        MessageBox
            (
            ghwndTstShell,
            "No Input Device was selected. Please select and try again.",
            szAppName,
            MB_OK | MB_APPLMODAL
            );
            
        return (int) TST_ABORT;
        
    }
    else if (DEVICE_F_NOTSELECTED == guiOutputDevID)
    {
        MessageBox
            (
            ghwndTstShell,
            "No Output Device was selected. Please select and try again.",
            szAppName,
            MB_OK | MB_APPLMODAL
            );
            
        return (int) TST_ABORT;
        
    }


    //
    // Startup callback window proc in which to receive notice of input
    // MIDI messages.
    //
    ghwndMIDIPerfCallback2 = CreateWindow
                            (
                            CLASSNAME_MIDIPERF_CALLBACK2,
                            NULL,
                            WS_OVERLAPPEDWINDOW,
                            0,
                            0,
                            0, 
                            0,
                            (HWND) NULL,
                            (HMENU) NULL,
                            ghinst,
                            (LPSTR) NULL
                            );
    
    
    if (NULL == ghwndMIDIPerfCallback2)
    {   
        MessageBox
            (
            ghwndTstShell,
            "Unable to create callback window. Aborting test...",
            szAppName,
            MB_OK | MB_APPLMODAL
            );
            
        return (int) TST_ABORT;
    }


    // Display a dialog box for the user to enter useful test information
    // to make logging easier. Also allow the user to enter a custom test
    // length.
    lpfnDlg = (DLGPROC) MakeProcInstance ((FARPROC) PerfParamsDlg, ghinst);
    if (-1 == (iRet = DialogBox
                            (
                            ghinst,
                            "IDD_PERFTESTPARAMS",
                            ghwndTstShell,
                            (DLGPROC) lpfnDlg
                            )
                            ))
    {
        tstLog (TERSE, "Error: Could not create test parameter dialog! Exiting...");
        return (int) TST_ABORT;
    }
    else if (0 == iRet)
    {
        //User cancelled
        //
        FreeProcInstance ((FARPROC) lpfnDlg);
        tstLog (TERSE, "Test aborted by user.");
        DestroyWindow (ghwndMIDIPerfCallback2);
        return (int) TST_ABORT;
    }
    else
    {
        FreeProcInstance ((FARPROC) lpfnDlg);
    }

    // Initialize performance stats structure
    //
    perfstats.dwShortEventsRcvd = 0;
    perfstats.dwLongEventsRcvd  = 0;
    perfstats.dwLateEvents      = 0;
    perfstats.dwEarlyEvents     = 0;
    perfstats.dwAverageDelta    = 0;
    perfstats.dwLastEventDelta  = 0;
    perfstats.dwLatestDelta     = 0;
    perfstats.dwEarliestDelta   = 0;
    perfstats.dwTotalDelta      = 0;

    //
    // Allocate a circular buffer for low-level MIDI input.  This buffer
    // is filled by the low-level callback function and emptied by the
    // application when it receives MM_MIDIINPUT messages.
    //
    lpInputBuffer = AllocCircularBuffer
                        ((ULONG)(gtestparams.dwInputBufSize * sizeof(EVENT)));
    if (lpInputBuffer == NULL)
    {
        tstLog (TERSE, "Not enough memory available for input buffer.");
        DestroyWindow (ghwndMIDIPerfCallback2);
        return TST_ABORT;
    }


    // Open selected input device after allocating and setting up
    // instance data for it.  The instance data is used to
    // pass buffer management information between the application and
    // the low-level callback function.  It also includes a device ID,
    // a handle to the output device (if the test uses one), a handle 
    // to the application's display window, so the callback can notify 
    // the window when input data is available, and a test type flag.  
    //
    if ((lpCallbackInstanceData = AllocCallbackInstanceData()) == NULL)
    {
        tstLog(TERSE, "Not enough memory available for input data buffer.");
        FreeCircularBuffer(lpInputBuffer);
        DestroyWindow (ghwndMIDIPerfCallback2);
        return TST_ABORT;
    }
    lpCallbackInstanceData->hWnd = ghwndMIDIPerfCallback2;         
    lpCallbackInstanceData->dwDevice = guiInputDevID;
    lpCallbackInstanceData->lpBuf = lpInputBuffer;
    lpCallbackInstanceData->hMidiOut = 0;
    lpCallbackInstanceData->fPostEvent = TRUE;
    lpCallbackInstanceData->ulPostMsgFails = 0;
    lpCallbackInstanceData->ulCallbacksShort = 0;
    lpCallbackInstanceData->fdwLevel = fdwLevel;

    if (TESTLEVEL_F_MOREDATA == fdwLevel)
    {
        //
        //Only Win 95 32-Bit supports the MIDI_IO_STATUS flag on the open call.
        //This flag enables the sending of MID_MOREDATA messages by the input
        //driver to the callback DLL.
        //
        wRtn = midiInOpen
                (
                (LPHMIDIIN)&hMidiIn,
                guiInputDevID,
                (DWORD)midiInputHandler,
                (DWORD)lpCallbackInstanceData,
                CALLBACK_FUNCTION | MIDI_IO_STATUS
                );

        if(MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to open input device.");
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback2);
            return TST_ABORT;
        }

        tstLog (VERBOSE, "midiInOpen using MIDI_IO_STATUS flag (MIDM_MOREDATA msgs supported)");
    }
    else
    {
        wRtn = midiInOpen
                    (
                    (LPHMIDIIN)&hMidiIn,
                    guiInputDevID,
                    (DWORD)midiInputHandler,
                    (DWORD)lpCallbackInstanceData,
                    CALLBACK_FUNCTION
                    );

        if(MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to open input device.");
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback2);
            return TST_ABORT;
        }

        tstLog (VERBOSE, "midiInOpen not using MIDI_IO_STATUS flag (MIDM_MOREDATA msgs not supported)");
    }

    //
    // Attempt to open a MIDI output device for use in the Thru portion
    // of the tests if the Thru option is enabled.
    //
    if (gfMIDIThru)
    {
        wRtn = midiOutOpen((LPHMIDIOUT)&hMidiOut,
                      guiOutputDevID,
                      (DWORD)midiInputHandler,
                      (DWORD)lpCallbackInstanceData,
                      CALLBACK_FUNCTION);

        if(MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to open output device.");
            midiOutGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            midiInClose (hMidiIn);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback2);
            return TST_ABORT;
        }

        if (fdwLevel != TESTLEVEL_F_CONNECT)
        {
            //
            // If we're not using the connect api for thru'ing then 
            // set this handle to the output device.
            //
            lpCallbackInstanceData->hMidiOut = hMidiOut;
        }
        else
        {
            //
            // If we *are* using the connect api to thru then set this
            // handle to NULL so that the callback DLL doesn't call
            // midiOutShortMsg.
            //
            lpCallbackInstanceData->hMidiOut = NULL;
        }

#if 0
        //If we're in 32-Bit land and the OS supports the midiConnect api then
        //we can let the 32-Bit driver transparently perform the thru'ing.
        //
        if (TESTLEVEL_F_CONNECT == fdwLevel)
        {
            wRtn = midiConnect (hMidiIn, hMidiOut, NULL);
            if (MMSYSERR_NOERROR != wRtn)
            {
                tstLog (TERSE, "Error: Unable to connect Input device to Out device.");
                midiOutGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
                tstLog (TERSE, szErrorText);
                midiInClose (hMidiIn);
                midiOutClose (hMidiOut);
                FreeCallbackInstanceData(lpCallbackInstanceData);
                FreeCircularBuffer(lpInputBuffer);
                DestroyWindow (ghwndMIDIPerfCallback2);
                return TST_ABORT;
            }
            tstLog (VERBOSE, "midiConnect api used for thru support");
        }
        else
        {
            tstLog (VERBOSE, "midiConnect api not used for thru");
        }
#endif

    }


    //
    // Start Input Recording and Log Delta Times
    //

    //
    // Display start prompt for the test (tell the user to start playing
    // MIDI to the input port from an external source after clicking OK).
    //
    if (IDOK != MessageBox
        (
        ghwndTstShell,
        "To begin Input Performance Test Click OK and then start playing MIDI from external source. Click Cancel to exit.",
        szAppName,
        MB_OKCANCEL | MB_APPLMODAL
        ))
    {
        iTstStatus = TST_ABORT;
        tstLog (TERSE, "User aborted Performance Test");
        if (gfMIDIThru)
        {
            midiOutClose (hMidiOut);
        }
        goto CleanupTest;
    }

    //
    //Start MIDI input
    //
    midiInStart(hMidiIn);

    PerformPerfTest
            (
            );

    //
    //Stop and reset MIDI input
    //
    midiInStop(hMidiIn);
    midiInReset (hMidiIn);

#if 0
    //
    //Disconnect the thru'ing support if we used this feature
    //
    if (gfMIDIThru && (TESTLEVEL_F_CONNECT == fdwLevel))
    {
        wRtn = midiDisconnect (hMidiIn, hMidiOut, NULL);
        if (MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to disconnect Input device to Out device.");
            midiOutGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            midiInClose (hMidiIn);
            midiOutClose (hMidiOut);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback2);
            return TST_ABORT;
        }
    }
#endif
    //
    // Close the input device
    //
    midiInClose (hMidiIn);

    //
    // Close the output device if Thru was enabled 
    //
    if (gfMIDIThru)
    {
        midiOutClose (hMidiOut);
    }

    //
    // Test complete. Log results and then cleanup.
    //
    if (!ComputeAndLogPerfResults ())
    {
        //
        // Problem with data.
        //
        iTstStatus = TST_ABORT;
    }


CleanupTest:
    //
    //Free callback data.
    //
    FreeCallbackInstanceData(lpCallbackInstanceData);

    //
    // Close the input device
    //
    midiInClose (hMidiIn);

    //
    //Stop the callback processing window.
    //
    DestroyWindow (ghwndMIDIPerfCallback2);

    return iTstStatus; 
} // RunPerfTest ()


//--------------------------------------------------------------------------;
//
//  BOOL ComputeAndLogWorkResults
//
//  Description:
//      Takes perfstats structure results and computes average delta time and 
//      other stats, then writes results to log file.
//
//  Arguments:
//      CPUWORK cpuwork:
//
//  Return (BOOL):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

BOOL ComputeAndLogPerfResults (void)
{
    tstLog (TERSE, "MIDI Record/Thru Performance Tests Results - Event Count, Delta Log (w/Input DLL Msg Post To Window)");
    tstLog (TERSE, "\nOS:             %s", (LPSTR) gtestparams.szCPUWorkTestOS);
    tstLog (TERSE, "Test App:       %s", (LPSTR) szAppName);
    tstLog (TERSE, "Input Device:   %s", (LPSTR) gtestparams.szInputDevice);
    if (gfMIDIThru)
    {
        tstLog (TERSE, "MIDI Thru: ON");
        tstLog (TERSE, "Output Device:  %s", (LPSTR) gtestparams.szOutputDevice);
    }
    else
    {
        tstLog (TERSE, "MIDI Thru: OFF");
    }

    tstLog (TERSE, "Test File:      %s", (LPSTR) gtestparams.szCPUWorkTestFile);


    tstLog (TERSE, "\nTotal NOTEON Events Received: %d", perfstats.dwShortEventsRcvd);
    tstLog (TERSE, "\nTotal SYSEX  Events Received: %d", perfstats.dwLongEventsRcvd);

    tstLog (TERSE, "\n DLL Callbacks: %lu", lpCallbackInstanceData->ulCallbacksShort);

    if (lpCallbackInstanceData->ulPostMsgFails)
    {
        tstLog (TERSE, "\n PostMessage Fails: %lu", lpCallbackInstanceData->ulPostMsgFails);
    }
    

    //tstLog
    //    (
    //    TERSE,
    //    "\nLate Events (+%dms): %d",
    //    perfstats.dwShortEventsRcvd,
    //    perfstats.dwLateEvents
    //    );
        
    //tstLog
    //    (
    //    TERSE,
    //    "Early Events (-%dms): %d\r\n",
    //    preferences.uiTolerance,
    //    perfstats.dwEarlyEvents
    //    );

    //tstLog
    //    (
    //    TERSE,
    //    "Largest Event Delta (ms): %d\r\n",
    //    perfstats.dwLatestDelta,
    //    preferences.uiTolerance
    //    );

    //tstLog
    //    (
    //    TERSE,
    //    "Smallest Event Delta (ms): %d\r\n",
    //    perfstats.dwEarliestDelta,
    //    preferences.uiTolerance
    //    );

    //Make sure that at least 2 events were received
    if (perfstats.dwShortEventsRcvd > 1)
    {
        tstLog
            (
            TERSE,
            "Average Time Between NOTEON Events (ms): %d \r\n",
            (perfstats.dwTotalDelta / (perfstats.dwShortEventsRcvd - 1))
            );
    }
    else
    {
        tstLog (TERSE, "Average Time Between Events (ms): n/a\r\n");
    }


    return TRUE;
} //ComputeAndLogPerfResults



//--------------------------------------------------------------------------;
//
//  void PerformPerfTest
//
//  Description:
//      Runs a single performance test by staying in a loop and processing
//      window callback messages until the user chooses to end the test.
//      The function callback DLL posts a message to the window proc when it
//      receives a message.
//
//  Arguments:
//
//  Return (void):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

BOOL PerformPerfTest (VOID)
{
    static  OFSTRUCT    OpenBuf;
    MSG     msg;
    HWND    hwndPerfTestStopDlg;
    FARPROC lpfnPerfTestStopDlg;
    DWORD   dwCntr;

    if (gfLogDeltaTimes)
    {
        if (HFILE_ERROR ==
            (ghDeltaFile = OpenFile
                    (
                    gtestparams.szPerfTestDeltaFile,
                    &OpenBuf,
                    OF_CREATE | OF_READWRITE))
                    )
        {
            tstLog (TERSE, "Could not open delta time log file.");
            return FALSE;
        }
    }



    lpfnPerfTestStopDlg = (FARPROC) MakeProcInstance ((FARPROC) PerfTestStopDlg, ghinst);
    hwndPerfTestStopDlg = CreateDialog (ghinst, "IDD_PERFTESTSTOP",  ghwndTstShell, (DLGPROC)PerfTestStopDlg);
    if (NULL == hwndPerfTestStopDlg)
    {
        tstLog (TERSE, "Unable to create End Perf Test dialog box. Aborting...");
        FreeProcInstance ((FARPROC) lpfnPerfTestStopDlg);
        return FALSE;
    }

    gfStopTest = FALSE;
    dwCntr = 0;
    while (!gfStopTest)
    {
        while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE) && !gfStopTest)
//            if (GetMessage (&msg, ghwndMIDIPerfCallback2, 0, 0))
        {
            if (!IsDialogMessage(ghwndMIDIPerfCallback2, &msg) &&
                !IsDialogMessage(hwndPerfTestStopDlg, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    DestroyWindow (hwndPerfTestStopDlg);
    FreeProcInstance ((FARPROC) lpfnPerfTestStopDlg);

    if (gfLogDeltaTimes)
    {
        _lclose (ghDeltaFile);
    }
    return TRUE;
} //End PerformPerfTest



//--------------------------------------------------------------------------;
//
//  LONG glpfnMIDIPerfCallback2
//
//  Description:
//      Window callback for performance test. Causes event deltas to be logged
//      and also processes user initiated test end message.
//
//  Arguments:
//      HWND hWnd:
//
//      UINT message:
//
//      WPARAM wParam:
//
//      LPARAM lParam:
//
//  Return (LONG):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

LONG glpfnMIDIPerfCallback2
(
    HWND	hWnd,
    UINT	message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    EVENT       incomingEvent;
        
    switch(message)
    {
        case CALLBACKERR_MOREDATA_RCVD:

            tstLog (TERSE, "Callback received a MIM_MOREDATA message when input dev opened w/o STATUS flag!");
            gfStopTest = TRUE;

            return 0;

        case PERFTEST_STOP:
            tstLog (TERSE, "\nPerfTest Ended");
            gfStopTest = TRUE;

            return 0;

        case CALLBACKERR_BUFFULL:

            tstLog (TERSE, "Error: Input Buffer Full. Try Re-Running With Larger Input Buffer.");
            tstLog (TERSE, "Cause: Input Buffer In Callback DLL Filling Up Faster Than Window Callback Can Unload.");
            tstLog (TERSE, "Exiting...");
            gfStopTest = TRUE;

            return 0;

        case MM_MIDIINPUT_SHORT:
            /* This is a custom message sent by the low level callback
             * function telling us that there is at least one MIDI event
             * in the input buffer.  We empty the input buffer, and put
             * each event in the display buffer, if it's not filtered.
             * If the input buffer is being filled as fast we can empty
             * it, then we'll stay in this loop and not process any other
             * Windows messages, or yield to other applications.  We need
             * something to restrict the amount of time we spend here...
             */
            while(GetEvent(lpInputBuffer, (LPEVENT)&incomingEvent))
            {
                UpdatePerformanceStats ((LPEVENT)&incomingEvent, MIDI_F_SHORTEVENT);
            }

            return 0;

        case MM_MIDIINPUT_LONG:

            //Long message handling just barely implemented
            //
            while(GetEvent(lpInputBuffer, (LPEVENT)&incomingEvent))
            {
                UpdatePerformanceStats ((LPEVENT)&incomingEvent, MIDI_F_LONGEVENT);
            }
            return 0;

        default:
            break;
    }       
    return DefWindowProc(hWnd, message, wParam, lParam);
} //End glpfnMIDIPerfCallback2


LRESULT PerfTestStopDlg
(
    HWND    hdlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch(Message)
    {
        case WM_COMMAND:
            switch(wParam)
            {              
                case IDB_PERFTEST_STOP:

                    PostMessage (ghwndMIDIPerfCallback2,PERFTEST_STOP, 0, 0L);
                    break;
            }
            break;

        default:

            break;         
    }

    return(0L);
} //PerfTestStopDlg ()


//--------------------------------------------------------------------------;
//
//  LRESULT PerfParamsDlg
//
//  Description:
//      DialogProc which handles startup parameters for the Perf tests.
//      This includes text strings for logging and the desired output file
//      to use for logging event delta times.
//
//  Arguments:
//      HWND hdlg:
//
//      UINT Message:
//
//      WPARAM wParam:
//
//      LPARAM lParam:
//
//  Return (LRESULT):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

LRESULT PerfParamsDlg
(
    HWND    hdlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UINT uiTmp;
    BOOL fTranslated;

    switch(Message)
    {
        case WM_INITDIALOG:
            
            SetDlgItemText
                (
                hdlg,
                IDE_TESTFILE,
                gtestparams.szPerfTestFile
                );

            SetDlgItemText
                (
                hdlg,
                IDE_OS,
                gtestparams.szPerfTestOS
                );

            SetDlgItemText
                (
                hdlg,
                IDE_DELTALOGFILE,
                gtestparams.szPerfTestDeltaFile
                );

            SetDlgItemInt
                (
                hdlg,
                IDE_INPUTBUFSIZE,
                (UINT) gtestparams.dwInputBufSize,
                FALSE
                );

            CheckDlgButton
                (
                hdlg,
                IDCHK_LOGDELTATIMES,
                0
                );

            CheckDlgButton
                (
                hdlg,
                IDCHK_THRUON,
                1
                );

            break;

        case WM_COMMAND:
            switch(wParam)
            {
                case IDCHK_LOGDELTATIMES:
                    CheckDlgButton
                        (
                        hdlg,
                        IDCHK_LOGDELTATIMES,
                        (IsDlgButtonChecked (hdlg, IDCHK_LOGDELTATIMES)?0:1)
                        );

                    EnableWindow
                        (
                        GetDlgItem (hdlg, IDE_DELTALOGFILE),
                        (IsDlgButtonChecked (hdlg, IDCHK_LOGDELTATIMES)?TRUE:FALSE)
                        );

                    break;

                case IDCHK_THRUON:
                    CheckDlgButton
                        (
                        hdlg,
                        IDCHK_THRUON,
                        (IsDlgButtonChecked (hdlg, IDCHK_THRUON)?0:1)
                        );

                    break;

                case IDOK:

                    uiTmp = GetDlgItemInt
                        (
                        hdlg,
                        IDE_INPUTBUFSIZE,
                        &fTranslated,
                        FALSE
                        );

                    if (!fTranslated || uiTmp < 200 || uiTmp > 15000)
                    {
                        MessageBox
                            (
                            ghwndTstShell,
                            "Input Buffer Size Must Be Between 200 and 15000",
                            szAppName,
                            MB_OK | MB_APPLMODAL
                            );

                        break;
                    }
                    else
                    {
                        gtestparams.dwInputBufSize = (DWORD) uiTmp;
                    }

                    GetDlgItemText
                        (
                        hdlg,
                        IDE_TESTFILE,
                        gtestparams.szPerfTestFile,
                        sizeof(gtestparams.szPerfTestFile)-1
                        );
                    GetDlgItemText
                        (
                        hdlg,
                        IDE_OS,
                        gtestparams.szPerfTestOS,
                        sizeof(gtestparams.szPerfTestOS) - 1
                        );
                    GetDlgItemText
                        (
                        hdlg,
                        IDE_DELTALOGFILE,
                        gtestparams.szPerfTestDeltaFile,
                        sizeof(gtestparams.szPerfTestDeltaFile) - 1
                        );

                    gfLogDeltaTimes =
                        (IsDlgButtonChecked (hdlg, IDCHK_LOGDELTATIMES)?TRUE:FALSE);

                    gfMIDIThru =
                        (IsDlgButtonChecked (hdlg, IDCHK_THRUON)?TRUE:FALSE);

                    EndDialog(hdlg,1);

                    break;

                case IDCANCEL:
                    EndDialog(hdlg,0);
                    break;
            }
            break;

        case WM_SYSCOMMAND:
            switch(wParam)
            {
                case SC_CLOSE:
                    EndDialog(hdlg,0);
                    break;
            }

        default:
            break;         
    }

    return(0L);
} //PerfParamsDlg ()


//--------------------------------------------------------------------------;
//
//  VOID UpdatePerformanceStats
//
//  Description:
//      This function filters out desired events and if an event comes in that
//      that we're interested in a counter is incremented. Event statistics
//      are processed in this function. This function also calls the function
//      which writes delta times to a file if this test option is chosen.
//
//
//  Arguments:
//      LPEVENT lpCurrentEvent:
//
//  Return (LPEVENT):
//
//  History:
//      08/23/94    a-MSava
//
//--------------------------------------------------------------------------;

VOID UpdatePerformanceStats
(
    LPEVENT lpCurrentEvent,
    DWORD   fdwEventType
)
{
    //DWORD dwEventDelta;
    static DWORD dwLastEventTime;
    BYTE bStatusRaw, bStatus, bData2;


    //If this is the first event in the performance test instance, initialize
    //starting event time to current event's timestamp.
    if (perfstats.dwShortEventsRcvd == 0 && perfstats.dwLongEventsRcvd == 0)
    {
        dwLastEventTime = lpCurrentEvent->timestamp;
    }


    if (MIDI_F_SHORTEVENT == fdwEventType)
    {
        //Exit function if event is not a NOTEON with a non-zero velocity
        bStatusRaw = LOBYTE(LOWORD(lpCurrentEvent->data));
        bStatus = bStatusRaw & (BYTE) 0xf0;
        bData2 = LOBYTE(HIWORD(lpCurrentEvent->data));


        if (!(90 == bStatus && 0 != bData2))	//note on
        {
            return;
        }

        //
        //Increment Short Event (we only care about NOTEONs) count 
        //
        ++perfstats.dwShortEventsRcvd;
    }
    else
    {
        //
        // Event is Long so Increment Long Event count
        //
        ++perfstats.dwLongEventsRcvd;
    }

    //Get time between current and last event
    perfstats.dwLastEventDelta = lpCurrentEvent->timestamp - dwLastEventTime;
    //if (perfstats.dwLastEventDelta > (preferences.uiExpDelta + preferences.uiTolerance))
    //{
    //    ++perfstats.dwLateEvents;
    //}
    //else if (perfstats.dwLastEventDelta < (preferences.uiExpDelta - preferences.uiTolerance))
    //{
    //    ++perfstats.dwEarlyEvents;
    //}

    if (perfstats.dwLastEventDelta > perfstats.dwLatestDelta)
    {
        perfstats.dwLatestDelta = perfstats.dwLastEventDelta;
    }
    else if ((perfstats.dwLastEventDelta < perfstats.dwEarliestDelta)
              && (perfstats.dwLastEventDelta > 0))
    {
        perfstats.dwEarliestDelta = perfstats.dwLastEventDelta;
    }
        
    perfstats.dwTotalDelta += perfstats.dwLastEventDelta;
    dwLastEventTime = lpCurrentEvent->timestamp;

    if (gfLogDeltaTimes)
    {
        LogDelta ();
    }
}


//--------------------------------------------------------------------------;
//
//  VOID LogDelta
//
//  Description:
//      Writes an event delta time to a file. This file is intended to be used
//      by an Excel Macro function which parses the file and provides statistics
//      on the received data.
//
//  Arguments:
//      None.
//
//  Return (VOID):
//
//  History:
//      08/23/94    a-MSava
//
//--------------------------------------------------------------------------;

VOID LogDelta (void)
{
    BYTE    szOut[MAXLONGSTR];

    wsprintf (szOut, "%d\r\n", perfstats.dwLastEventDelta);
    _lwrite (ghDeltaFile, szOut, lstrlen (szOut));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\worktest.c ===
//--------------------------------------------------------------------------;
//
//  File: worktest.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Contains the CPU Work Test code which measures the workload MIDI
//      recording and playback places on the CPU.
//
//
//  Contents:
//      RunCPUWorkTest()
//      ComputeAndLogWorkResults()
//      PerformCPUWorkTest()
//      glpfnMIDIPerfCallback()
//      CPUWorkParamsDlg()
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>
#include <mmsystem.h>
#include <tstshell.h>   // Include file for the test shell's APIs
#include "globals.h"    // Various constants and prototypes
#include "muldiv32.h"


HGLOBAL     ghwndMIDIPerfCallback;


VOID PerformCPUWorkTest
(
    DWORD   dwTestTime,
    ULONG   *pulWrkCntr1,
    ULONG   *pulWrkCntr2
);

BOOL ComputeAndLogWorkResults
(
    CPUWORK cpuwork
);

LRESULT CPUWorkParamsDlg
(
    HWND    hdlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
);


// Callback instance data pointers
LPCALLBACKINSTANCEDATA lpCallbackInstanceData;
LPCIRCULARBUFFER lpInputBuffer;         // Input buffer structure
//EVENT incomingEvent;                    // Incoming MIDI event structure


//--------------------------------------------------------------------------;
//
//  int RunCPUWorkTest
//
//  Description:
//      This function runs the CPU Work Load test. This test works in three
//      parts.
//          1. Starts a timer loop which, for the specfied length of time,
//             does the following: 
//
//              a.Increments a counter.
//
//              b.Uses the selected input device to receive MIDI events via 
//                a callback DLL, echoing the input data to the selected 
//                output MIDI device.
//
//              c. Stores results.
//
//          2. Repeat #1 above only this time don't echo events to output port.
//
//          3. Repeat #3 without starting MIDI input.
//
//      The counter totals are then compared and used to give a CPU work 
//      estimate for MIDI recording and playback.
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

int RunCPUWorkTest (DWORD fdwLevel)
{
    CPUWORK     cpuwork;
    char        szErrorText[MAXLONGSTR];
    WORD        wRtn;
    HMIDIIN     hMidiIn;
    HMIDIOUT    hMidiOut;
    int         iTstStatus = TST_PASS;
    DLGPROC     lpfnDlg;
    int         iRet;

    //
    // First make sure that the user has selected an input and output device.
    // 
    if (DEVICE_F_NOTSELECTED == guiInputDevID)
    {
        MessageBox
            (
            ghwndTstShell,
            "No Input Device was selected. Please select and try again.",
            szAppName,
            MB_OK | MB_APPLMODAL
            );
            
        return (int) TST_ABORT;
        
    }
    else if (DEVICE_F_NOTSELECTED == guiOutputDevID)
    {
        MessageBox
            (
            ghwndTstShell,
            "No Output Device was selected. Please select and try again.",
            szAppName,
            MB_OK | MB_APPLMODAL
            );
            
        return (int) TST_ABORT;
        
    }

    //
    // Initialize the test time parameter, although we'd like to do this
    // eventually from an INI file.
    //
    gtestparams.dwCPUWorkTestTime = 25000;

    //
    // Startup callback window proc in which to receive notice of input
    // MIDI messages.
    //
    ghwndMIDIPerfCallback = CreateWindow
                            (
                            CLASSNAME_MIDIPERF_CALLBACK,
                            NULL,
                            WS_OVERLAPPEDWINDOW,
                            0,
                            0,
                            0, 
                            0,
                            (HWND) NULL,
                            (HMENU) NULL,
                            ghinst,
                            (LPSTR) NULL
                            );
    
    
    if (NULL == ghwndMIDIPerfCallback)
    {   
        MessageBox
            (
            ghwndTstShell,
            "Unable to create callback window. Aborting test...",
            szAppName,
            MB_OK | MB_APPLMODAL
            );
            
        return (int) TST_ABORT;
    }


    //
    // Display a dialog box for the user to enter useful test information
    // to make logging easier. Also allow the user to enter a custom test
    // length.
    lpfnDlg = (DLGPROC) MakeProcInstance ((FARPROC) CPUWorkParamsDlg, ghinst);
    if (-1 == (iRet = DialogBox
                            (
                            ghinst,
                            "IDD_CPUWORKTESTPARAMS",
                            ghwndTstShell,
                            (DLGPROC) lpfnDlg))
                            )
    {
        tstLog (TERSE, "Error: Could not create test parameter dialog! Exiting...");
        return (int) TST_ABORT;
    }
    else if (0 == iRet)
    {
        //User cancelled
        //
        FreeProcInstance ((FARPROC) lpfnDlg);
        tstLog (TERSE, "Test aborted by user.");
        DestroyWindow (ghwndMIDIPerfCallback);
        return (int) TST_ABORT;
    }
    else
    {
        FreeProcInstance ((FARPROC) lpfnDlg);
    }

    //
    //Initialze test parameters and work units structure.
    //
    cpuwork.dwTestTime                  = gtestparams.dwCPUWorkTestTime;
    cpuwork.ulMIDIThruCntr1             = 0L;
    cpuwork.ulMIDIThruCntr2             = 0L;
    cpuwork.ulMIDIThruCallbacksShort    = 0L;
    cpuwork.ulMIDIThruCallbacksLong     = 0L;
    cpuwork.ulMIDINoThruCntr1           = 0L;
    cpuwork.ulMIDINoThruCntr2           = 0L;
    cpuwork.ulMIDINoThruCallbacksShort  = 0L;
    cpuwork.ulMIDINoThruCallbacksLong   = 0L;
    cpuwork.ulBaselineCntr1             = 0L;
    cpuwork.ulBaselineCntr2             = 0L;
    cpuwork.ulBaselineCallbacksShort    = 0L;
    cpuwork.ulBaselineCallbacksLong     = 0L;


    //
    // Allocate a circular buffer for low-level MIDI input.  This buffer
    // is filled by the low-level callback function and emptied by the
    // application when it receives MM_MIDIINPUT messages.
    //
    lpInputBuffer = AllocCircularBuffer
                        ((DWORD)(INPUT_BUFFER_SIZE * sizeof(EVENT)));
    if (lpInputBuffer == NULL)
    {
        tstLog (TERSE, "Not enough memory available for input buffer.");
        DestroyWindow (ghwndMIDIPerfCallback);
        return TST_ABORT;
    }


    // Open selected input device after allocating and setting up
    // instance data for it.  The instance data is used to
    // pass buffer management information between the application and
    // the low-level callback function.  It also includes a device ID,
    // a handle to the MIDI Mapper, and a handle to the application's
    // display window, so the callback can notify the window when input
    // data is available.  
    //
    if ((lpCallbackInstanceData = AllocCallbackInstanceData()) == NULL)
    {
            tstLog(TERSE, "Not enough memory available for input data buffer.");
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback);
            return TST_ABORT;
    }
    lpCallbackInstanceData->hWnd = ghwndMIDIPerfCallback;         
    lpCallbackInstanceData->dwDevice = guiInputDevID;
    lpCallbackInstanceData->lpBuf = lpInputBuffer;
    lpCallbackInstanceData->hMidiOut = 0;
    lpCallbackInstanceData->fPostEvent = FALSE; //We don't care about data here
    lpCallbackInstanceData->fdwLevel = fdwLevel;
        
    
    if (TESTLEVEL_F_MOREDATA == fdwLevel) 
    {    
        //
        //Only Win 95 supports the MIDI_IO_STATUS flag on the open call.
        //This flag enables the sending of MIDM_MOREDATA messages by the input
        //driver to the callback DLL.
        //
        wRtn = midiInOpen
                (
                (LPHMIDIIN)&hMidiIn,
                guiInputDevID,
                (DWORD)midiInputHandler,
                (DWORD)lpCallbackInstanceData,
                CALLBACK_FUNCTION | MIDI_IO_STATUS
                );

        if(MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to open input device.");
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback);
            return TST_ABORT;
        }

        tstLog (VERBOSE, "midiInOpen using MIDI_IO_STATUS flag (MIDM_MOREDATA msgs supported)");
    }
    else
    {
        wRtn = midiInOpen
                    (
                    (LPHMIDIIN)&hMidiIn,
                    guiInputDevID,
                    (DWORD)midiInputHandler,
                    (DWORD)lpCallbackInstanceData,
                    CALLBACK_FUNCTION
                    );

        if(MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to open input device.");
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback);
            return TST_ABORT;
        }

        tstLog (VERBOSE, "midiInOpen not using MIDI_IO_STATUS flag (MIDM_MOREDATA msgs not supported)");
    }
    
    //
    // Attempt to open a MIDI output device for use in the Thru portion
    // of the tests.
    //
    wRtn = midiOutOpen((LPHMIDIOUT)&hMidiOut,
                      guiOutputDevID,
                      (DWORD)midiInputHandler,
                      (DWORD)lpCallbackInstanceData,
                      CALLBACK_FUNCTION);

    if(MMSYSERR_NOERROR != wRtn)
    {
        tstLog (TERSE, "Error: Unable to open output device.");
        midiOutGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
        tstLog (TERSE, szErrorText);
        midiInClose (hMidiIn);
        FreeCallbackInstanceData(lpCallbackInstanceData);
        FreeCircularBuffer(lpInputBuffer);
        DestroyWindow (ghwndMIDIPerfCallback);
        return TST_ABORT;
    }
#if 0
//#ifdef WINNT 
//!!Remember this api doesn't exist in NT so don't build it there!!

    if (TESTLEVEL_F_CONNECT == fdwLevel)
    {
        wRtn = midiConnect (hMidiIn, hMidiOut, NULL);
        if (MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to connect Input device to Out device.");
            midiOutGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            midiInClose (hMidiIn);
            midiOutClose (hMidiOut);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback);
            return TST_ABORT;
        }
        tstLog (VERBOSE, "midiConnect api used for thru support");
    }
#endif
    //
    //Run MIDI CPU Work Tests
    //

    //
    // Set the output device handle in the instance data to the selected
    // device and prepare to run the Thru test.
    //
    //lpCallbackInstanceData->hMidiOut = hMidiOut;
    if (fdwLevel != TESTLEVEL_F_CONNECT)
    {
        //
        // If we're not using the connect api for thru'ing then 
        // set this handle to the output device.
        //
        lpCallbackInstanceData->hMidiOut = hMidiOut;
    }
    else
    {
        //
        // If we *are* using the connect api to thru then set this
        // handle to NULL so that the callback DLL doesn't call
        // midiOutShortMsg.
        //
        lpCallbackInstanceData->hMidiOut = NULL;
    }
     

    //
    // Display start prompt for test #1 (tell the user to start playing
    // MIDI to the input port from an external source).
    //
    if (IDOK != MessageBox
        (
        ghwndTstShell,
        "To begin CPU Work Test #1 (w/thru) start playing MIDI from external source and then click OK. Click Cancel to exit.",
        szAppName,
        MB_OKCANCEL | MB_APPLMODAL
        ))
    {
        iTstStatus = TST_ABORT;
        tstLog (TERSE, "User aborted CPU Work Test");
        midiOutClose (hMidiOut);
        goto CleanupTest;
    }
    
    //
    //Initialize DLL callback count
    //
    lpCallbackInstanceData->ulCallbacksShort = 0;
    lpCallbackInstanceData->ulCallbacksLong  = 0;

    //
    //Start MIDI input for Test 1.
    //
    midiInStart(hMidiIn);

    //For Thru Work test set global echo flag for function callback
    PerformCPUWorkTest
            (
            cpuwork.dwTestTime,
            &(cpuwork.ulMIDIThruCntr1),
            &(cpuwork.ulMIDIThruCntr2)
            );

    //
    //Stop and reset MIDI input for Test 1.
    //
    midiInStop(hMidiIn);
    midiInReset (hMidiIn);
    cpuwork.ulMIDIThruCallbacksShort = lpCallbackInstanceData->ulCallbacksShort;
    cpuwork.ulMIDIThruCallbacksLong = lpCallbackInstanceData->ulCallbacksLong;


#if 0
    if (TESTLEVEL_F_CONNECT == fdwLevel)
    {
        //If this is a 32-Bit build which supports the midiConnect api disconnect
        //disconnect the thru'ing support from the 32-bit driver
        //
        wRtn = midiDisconnect (hMidiIn, hMidiOut, NULL);
        if (MMSYSERR_NOERROR != wRtn)
        {
            tstLog (TERSE, "Error: Unable to disconnect Input device to Out device.");
            midiOutGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            tstLog (TERSE, szErrorText);
            midiInClose (hMidiIn);
            midiOutClose (hMidiOut);
            FreeCallbackInstanceData(lpCallbackInstanceData);
            FreeCircularBuffer(lpInputBuffer);
            DestroyWindow (ghwndMIDIPerfCallback);
            return TST_ABORT;
        }
    }
    
#endif    
    //
    // Close the input device
    //
    //midiInClose (hMidiIn);

    //
    // Close the output device and NULL the handle in the instance data to 
    // disable the MIDI thru and then prepare to run the NoThru test.
    //
    midiOutClose (hMidiOut);

    //
    // Display start prompt for test #2 (tell the user to start playing
    // MIDI to the input port from an external source).
    //
    if (IDOK != MessageBox
        (
        ghwndTstShell,
        "To begin CPU Work Test #2 (no thru) start playing MIDI from external source and then click OK. Click Cancel to exit.",
        szAppName,
        MB_OKCANCEL | MB_APPLMODAL
        ))
    {
        tstLog (TERSE, "User aborted CPU Work Test");
        iTstStatus = TST_ABORT;
        goto CleanupTest;
    }

    //
    // Re-Open Input Device. For some reason input didn't worked after a stop,
    // reset, and start.
    //
    lpCallbackInstanceData->hWnd = ghwndMIDIPerfCallback;         
    lpCallbackInstanceData->dwDevice = guiInputDevID;
    lpCallbackInstanceData->lpBuf = lpInputBuffer;
    lpCallbackInstanceData->hMidiOut = 0;
    //wRtn = midiInOpen((LPHMIDIIN)&hMidiIn,
    //                  guiInputDevID,
    //                  (DWORD)midiInputHandler,
    //                  (DWORD)lpCallbackInstanceData,
    //                  CALLBACK_FUNCTION);

    //if(wRtn)
    //{
    //    midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
    //    tstLog (TERSE, szErrorText);
    //    FreeCallbackInstanceData(lpCallbackInstanceData);
    //    FreeCircularBuffer(lpInputBuffer);
    //    DestroyWindow (ghwndMIDIPerfCallback);
    //    return TST_ABORT;
    //}
    
    //
    // Initialize DLL callback count
    //
    lpCallbackInstanceData->ulCallbacksShort = 0;
    lpCallbackInstanceData->ulCallbacksLong  = 0;

    //
    //Start MIDI input for test 2.
    //
    wRtn = midiInStart(hMidiIn);
    if (wRtn)
    {
        midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
        tstLog (TERSE, szErrorText);
        iTstStatus = TST_ABORT;
        goto CleanupTest;
    }

    //For NoThru Work test disable global echo flag for function callback 
    PerformCPUWorkTest
            (
            cpuwork.dwTestTime,
            &(cpuwork.ulMIDINoThruCntr1),
            &(cpuwork.ulMIDINoThruCntr2)
            );

    //
    // Stop and reset MIDI input for baseline test. Wait until 
    // baseline test is complete before freeing callback data to keep
    // baseline test environment as similar as possible to loaded one.
    //
    midiInStop(hMidiIn);
    midiInReset(hMidiIn);
    cpuwork.ulMIDINoThruCallbacksShort = lpCallbackInstanceData->ulCallbacksShort;
    cpuwork.ulMIDINoThruCallbacksLong = lpCallbackInstanceData->ulCallbacksLong;

    
    if (IDOK != MessageBox
        (
        ghwndTstShell,
        "To begin baseline click OK, no MIDI input necessary. Click Cancel to exit.",
        szAppName,
        MB_OKCANCEL | MB_APPLMODAL
        ))
    {
        tstLog (TERSE, "User aborted CPU Work Test");
        iTstStatus = TST_ABORT;
        goto CleanupTest;
    }

    //
    //Initialize DLL callback count (We always expect this be zero here!).
    //
    lpCallbackInstanceData->ulCallbacksShort = 0;
    lpCallbackInstanceData->ulCallbacksLong  = 0;
    
    //
    //Now perform baseline test. DON'T restart MIDI input for this test.
    //

    PerformCPUWorkTest
            (
            cpuwork.dwTestTime,
            &(cpuwork.ulBaselineCntr1),
            &(cpuwork.ulBaselineCntr2)
            );
    cpuwork.ulBaselineCallbacksShort = lpCallbackInstanceData->ulCallbacksShort;
    cpuwork.ulBaselineCallbacksLong = lpCallbackInstanceData->ulCallbacksLong;

    //
    //Baseline test complete.
    //

    //
    //All tests complete. Log results and then cleanup.
    //
    if (!ComputeAndLogWorkResults (cpuwork))
    {
        //
        // Problem with data.
        //
        iTstStatus = TST_ABORT;
    }

CleanupTest:
    //
    //Free callback data.
    //
    FreeCallbackInstanceData(lpCallbackInstanceData);

    //
    // Close the input device
    //
    midiInClose (hMidiIn);

    //
    //Stop the callback processing window.
    //
    DestroyWindow (ghwndMIDIPerfCallback);

    return iTstStatus; //What should I return if no conclusion can be drawn yet?
} // RunCPUWorkTest ()


//--------------------------------------------------------------------------;
//
//  BOOL ComputeAndLogWorkResults
//
//  Description:
//      Takes CPU Work structure results and computes work numbers and 
//      writes results to log output.
//
//  Arguments:
//      CPUWORK cpuwork:
//
//  Return (BOOL):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

BOOL ComputeAndLogWorkResults
(
    CPUWORK cpuwork
)
{
    ULONG   ulCPUUsage;


    // First ensure that data is worth logging results on. 
    //
    if (0 == cpuwork.ulBaselineCntr1 ||
        0 == cpuwork.ulMIDIThruCntr1 ||
        0 == cpuwork.ulMIDINoThruCntr1)
    {
        //If any work counters are zero don't continue.
        //
        tstLog (TERSE, "Unable to give CPU work results due to non-existent or incomplete results");
        return FALSE;
    }
    else if (cpuwork.ulBaselineCntr2 ||
             cpuwork.ulMIDIThruCntr2 ||
             cpuwork.ulMIDINoThruCntr2)
    {
        // For now don't allow test times which overflow the 1st counter.
        //
        tstLog (TERSE, "Exceeded counter limit. Test time too long/CPU too fast for storage.");
        return FALSE;
    }
    else if (!(cpuwork.ulBaselineCntr1 >= cpuwork.ulMIDINoThruCntr1 &&
               cpuwork.ulMIDINoThruCntr1 >= cpuwork.ulMIDIThruCntr1))
    {
        // Make sure that Baseline Work >= NoThru Work >= Thru Work
        // This might assume too much, but if the condition fails it
        // generally points to some other kind of problem with the test
        // results. One possible case in which this condition could fail and
        // NOT be because of an error is
        // when the MIDI test file is not very stressful and creates little work
        // for the CPU.
        //
        if (!(cpuwork.ulBaselineCntr1 >= cpuwork.ulMIDINoThruCntr1))
        {
            tstLog
                (
                TERSE,
                "Unable to give CPU work results due to data which indicates possible test error (NoThru Work > Baseline Work!)"
                );
        }
        else
        {
            tstLog
                (
                TERSE,
                "Unable to give CPU work results due to data which indicates possible test error (Thru Work > NoThru Work)"
                );
        }

        tstLog
            (
            TERSE,
            "Baseline Cntr1: %ld, Baseline Cntr2: %ld",
            cpuwork.ulBaselineCntr1,
            cpuwork.ulBaselineCntr2
            );
        tstLog
            (
            TERSE,
            "NoThru Cntr1: %ld, NoThru Cntr2: %ld",
            cpuwork.ulMIDINoThruCntr1,
            cpuwork.ulMIDINoThruCntr2
            );
        tstLog
            (
            TERSE,
            "Thru Cntr1: %ld, Thru Cntr2: %ld",
            cpuwork.ulMIDIThruCntr1,
            cpuwork.ulMIDIThruCntr2
            );
        tstLog
            (
            TERSE,
            "Thru Callbacks: %ld(short), %ld(long)",
            cpuwork.ulMIDIThruCallbacksShort,
            cpuwork.ulMIDIThruCallbacksLong
            );
        tstLog
            (
            TERSE,
            "NoThru Callbacks: %ld(short), %ld(long)",
            cpuwork.ulMIDINoThruCallbacksShort,
            cpuwork.ulMIDINoThruCallbacksLong
            );
        return FALSE;
    }

    //
    // Log results
    //
    tstLog (TERSE, "CPU Work Required For MIDI - Test Results");
    tstLog (TERSE, "\nOS:             %s", (LPSTR) gtestparams.szCPUWorkTestOS);
    tstLog (TERSE, "Test App:       %s", (LPSTR) szAppName);
    tstLog (TERSE, "Input Device:   %s", (LPSTR) gtestparams.szInputDevice);
    tstLog (TERSE, "Output Device:  %s", (LPSTR) gtestparams.szOutputDevice);
    tstLog (TERSE, "Test File:      %s", (LPSTR) gtestparams.szCPUWorkTestFile);

    tstLog (TERSE, "Test Time:      %lumsecs\n", cpuwork.dwTestTime);

    tstLog (TERSE, "1. MIDI Recording (with Thru to output device):");
    tstLog
        (
        TERSE,
        "    Work Units: %lu",
        cpuwork.ulMIDIThruCntr1
        );
    tstLog
        (
        TERSE,
        "    [Callbacks: %lu(short) %lu(long)]",
        cpuwork.ulMIDIThruCallbacksShort,
        cpuwork.ulMIDIThruCallbacksLong
        );


    
    ulCPUUsage = MulDivRN
                    (
                    cpuwork.ulBaselineCntr1 - cpuwork.ulMIDIThruCntr1,
                    100,
                    cpuwork.ulBaselineCntr1
                    );

    tstLog (TERSE, "    %%CPU Required: %lu", ulCPUUsage);


    tstLog (TERSE, "\n2. MIDI Recording (NO thru):");
    tstLog
        (
        TERSE,
        "    Work Units: %lu",
        cpuwork.ulMIDINoThruCntr1
        );
    tstLog
        (
        TERSE,
        "    [Callbacks: %lu(short) %lu(long)]",
        cpuwork.ulMIDINoThruCallbacksShort,
        cpuwork.ulMIDINoThruCallbacksLong
        );

    ulCPUUsage = MulDivRN
                    (
                    cpuwork.ulBaselineCntr1 - cpuwork.ulMIDINoThruCntr1,
                    100,
                    cpuwork.ulBaselineCntr1
                    );

    tstLog (TERSE, "    %%CPU Required: %lu", ulCPUUsage);


 
    tstLog (TERSE, "\n3. No MIDI activity:");
    tstLog
        (
        TERSE,
        "    Work Units: %lu",
        cpuwork.ulBaselineCntr1
        );

// Decided that these results aren't particularly useful since they're just
// using the previous data.
    /*
    tstLog (TERSE, "\n4. MIDI Playback only (using previous data)");
    tstLog
        (
        TERSE,
        "    Work Units: %lu",
        cpuwork.ulBaselineCntr1 - (cpuwork.ulMIDINoThruCntr1 - cpuwork.ulMIDIThruCntr1)
        );

    ulCPUUsage = MulDivRN
                    (
                    cpuwork.ulMIDINoThruCntr1 -
                    cpuwork.ulMIDIThruCntr1,
                    100,
                    cpuwork.ulBaselineCntr1
                    );

    tstLog (TERSE, "    %%CPU Required: %lu", ulCPUUsage);
    tstLog (TERSE, "\n");
    */

    return TRUE;
} //ComputeAndLogWorkResults



//--------------------------------------------------------------------------;
//
//  void PerformCPUWorkTest
//
//  Description:
//      Runs a single work test by staying in a loop for the specified test
//      time while incrementing a counter and monitoring the MIDI input
//      callback function. Baseline results are obtained using same loop
//      while MIDI input is disabled. 
//
//  Arguments:
//      DWORD dwTestTime:
//
//      ULONG *pulWrkCntr1:
//
//      ULONG *pulWrkCntr2:
//
//  Return (void):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

VOID PerformCPUWorkTest
(
    DWORD dwTestTime,
    ULONG *pulWrkCntr1,
    ULONG *pulWrkCntr2
)
{
    DWORD   dwStartTime, dwCurrTime;
    MSG     msg;

    dwCurrTime = timeGetTime ();
    dwStartTime = dwCurrTime;
    while ((dwCurrTime - dwStartTime) < dwTestTime)
    {
        if (PeekMessage (&msg, ghwndMIDIPerfCallback, 0, 0, PM_NOYIELD | PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        (*pulWrkCntr1)++;

        if (0xFFFFFFFF == *pulWrkCntr1)
        {
            //
            // Counter rollover, increment 2nd counter and reset
            //
            *pulWrkCntr1 = 0;
            ++(*pulWrkCntr2);
        }

        dwCurrTime = timeGetTime ();
    }

} //End PerformCPUWorkTest



//--------------------------------------------------------------------------;
//
//  LONG glpfnMIDIPerfCallback
//
//  Description:
//      Window callback for MIDI input. Not used for anything during CPU Work
//      test.
//
//  Arguments:
//      HWND hWnd:
//
//      UINT message:
//
//      WPARAM wParam:
//
//      LPARAM lParam:
//
//  Return (LONG):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

LONG glpfnMIDIPerfCallback
(
    HWND	hWnd,
    UINT	message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    //EVENT       incomingEvent;
        
    switch(message)
    {
        case CALLBACKERR_BUFFULL:

            tstLog (TERSE, "User Warning: Input buffer full.");
            break;


        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
            break;
    }
    return 0;
} //End glpfnMIDIPerfCallback

//--------------------------------------------------------------------------;
//
//  LRESULT CPUWorkParamsDlg
//
//  Description:
//      DialogProc which handles startup parameters for the CPU Work tests.
//      This includes text strings for logging and the desired test time.
//
//  Arguments:
//      HWND hdlg:
//
//      UINT Message:
//
//      WPARAM wParam:
//
//      LPARAM lParam:
//
//  Return (LRESULT):
//
//  History:
//      08/09/94    a-MSava
//
//--------------------------------------------------------------------------;

LRESULT CPUWorkParamsDlg
(
    HWND    hdlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL    fTranslated;
    DWORD   dwTmpTestTime;

    switch(Message)
    {
        case WM_INITDIALOG:
            


            SetDlgItemInt
                (
                hdlg,
                IDE_TESTTIME,
                (UINT) gtestparams.dwCPUWorkTestTime,
                FALSE
                );

            SetDlgItemText
                (
                hdlg,
                IDE_TESTFILE,
                gtestparams.szCPUWorkTestFile
                );

            SetDlgItemText
                (
                hdlg,
                IDE_OS,
                gtestparams.szCPUWorkTestOS
                );

            break;

        case WM_COMMAND:
            switch(wParam)
            {              
                case IDOK:

                    GetDlgItemText
                        (
                        hdlg,
                        IDE_TESTFILE,
                        gtestparams.szCPUWorkTestFile,
                        sizeof(gtestparams.szCPUWorkTestFile)-1
                        );
                    GetDlgItemText
                        (
                        hdlg,
                        IDE_OS,
                        gtestparams.szCPUWorkTestOS,
                        sizeof(gtestparams.szCPUWorkTestOS) - 1
                        );
                    dwTmpTestTime = GetDlgItemInt
                                        (
                                        hdlg,
                                        IDE_TESTTIME,
                                        &fTranslated,
                                        FALSE
                                        );
                    if (!fTranslated ||
                        (dwTmpTestTime < CPUWORKTEST_MINTIME ||
                         dwTmpTestTime > CPUWORKTEST_MAXTIME))
                    {
                        MessageBox
                            (
                            ghwndTstShell,
                            "Invalid Test Time.",
                            szAppName,
                            MB_OK | MB_APPLMODAL);
                 
                        //Don't leave DialogProc until a Cancel or Exit
                    }
                    else
                    {
                        gtestparams.dwCPUWorkTestTime = dwTmpTestTime;
                        EndDialog(hdlg,1);
                    }

                    break;

                case IDCANCEL:
                    EndDialog(hdlg,0);
                    break;
            }
            break;

        case WM_SYSCOMMAND:
            switch(wParam)
            {
                case SC_CLOSE:
                    EndDialog(hdlg,0);
                    break;
            }

        default:
            break;         
    }

    return(0L);
} //CPUWorkParamsDlg ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midiperf\exe\prefer.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (C) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

/*
 *  prefer.h
 */


/* MIDIPERF.INI entries.
 */







#define INI_FILENAME        (LPSTR) "MIDIPERF.INI"
#define INI_DISPLAYWINDOW   (LPSTR) "Display Window"
#define INI_X               (LPSTR) "x"
#define INI_Y               (LPSTR) "y"
#define INI_W               (LPSTR) "w"
#define INI_H               (LPSTR) "h"

#define INI_PERFTESTPARAMS  (LPSTR) "PerfTestParams"
#define INI_LOGTYPE         (LPSTR) "LogType"
#define INI_EXPDELTA        (LPSTR) "Delta"
#define INI_TOLERANCE       (LPSTR) "Tolerance"

/* Default values for preference variables.
 */
#define DEF_X               20
#define DEF_Y               20
#define DEF_W               481
#define DEF_H               256

#define DEF_LOGTYPE         2
#define DEF_EXPDELTA        30
#define DEF_TOLERANCE       3

/* Data structure used to specify user preferences.
 */
typedef struct preferences_tag
{
    int iInitialX;
    int iInitialY;
    int iInitialW;
    int iInitialH;
    DWORD dwInputBufferSize;
    DWORD dwDisplayBufferSize;
    int wDisplayFormat;
    UINT uiPerfLogType;
    UINT uiExpDelta;
    UINT uiTolerance;
} PREFERENCES;
typedef PREFERENCES FAR *LPPREFERENCES;



/* Function prototypes
 */
VOID getPreferences(LPPREFERENCES, HWND);
VOID setPreferences(LPPREFERENCES);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\pasystem\main.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       main.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <mmsystem.h>

#include <stdio.h>
#include <conio.h>

typedef struct
{
    HWAVEOUT hwo;
    HWAVEIN  hwi;
   
} PA_SYSTEM, *PPA_SYSTEM;

DWORD ReadThread( DWORD dwContext )
{
    MSG         msg;
    PPA_SYSTEM  pPaSystem = (PPA_SYSTEM) dwContext;

    printf( "entered read thread.\n" );
    do
    {
        GetMessage( &msg, NULL, 0, 0 );

        switch (msg.message)
        {
            case MM_WIM_OPEN:
                printf( "wavein opened.\n" );
                break;

            case MM_WIM_DATA:
            {
                LPWAVEHDR  phdr = msg.lParam;

                waveInUnprepareHeader( pPaSystem->hwi, phdr, sizeof( WAVEHDR ) );
                printf( "wavein completed, %d\n", phdr->dwBytesRecorded ) ;
                if (phdr->dwBytesRecorded)
                {
                    phdr->dwBufferLength = phdr->dwBytesRecorded;
                    waveOutPrepareHeader( pPaSystem->hwo, phdr, sizeof( WAVEHDR ) );
                    waveOutWrite( pPaSystem->hwo, phdr, sizeof( WAVEHDR ) );
                }
                break;
            }
        }

    }
    while (msg.message != MM_WIM_CLOSE);

    printf( "exited read thread.\n");

    return 0;
}

DWORD WriteThread( DWORD dwContext )
{
    MSG         msg;
    PPA_SYSTEM  pPaSystem = (PPA_SYSTEM) dwContext;

    printf( "entered write thread.\n" );
    do
    {
        GetMessage( &msg, NULL, 0, 0 );

        switch (msg.message)
        {
            case MM_WOM_OPEN:
                printf( "waveout opened.\n" );
                break;

            case MM_WOM_DONE:
            {
                LPWAVEHDR  phdr = msg.lParam;

                waveOutUnprepareHeader( pPaSystem->hwo, phdr, sizeof( WAVEHDR ) );
                if (phdr->dwBufferLength)
                {
                    waveInPrepareHeader( pPaSystem->hwi, phdr, sizeof( WAVEHDR ) );
                    waveInAddBuffer( pPaSystem->hwi, phdr, sizeof( WAVEHDR ) );
                }
                break;
            }
        }

    }
    while (msg.message != MM_WOM_CLOSE);

    printf( "exited write thread.\n");

    return 0;
}

int main
(
    int     argc,
    char    *argv[]
)
{
    int           i;
    HANDLE        htRead, htWrite;
    PA_SYSTEM     PaSystem;
    ULONG         tidRead, tidWrite;
    WAVEFORMATEX  wf;
    WAVEHDR       rgwh[ 16 ];

    htRead =
        CreateThread( NULL,                 // no security
                      0,                    // default stack
                      (PTHREAD_START_ROUTINE) ReadThread,
                      (PVOID) &PaSystem,   // parameter
                      0,                   // default create flags
                      &tidRead );         // container for thread id

    if (NULL == htRead)
    {
        printf( "ERROR: failed to create read thread\n" );
        return;
    }

    SetThreadPriority( htRead, THREAD_PRIORITY_TIME_CRITICAL );

    htWrite =
        CreateThread( NULL,                 // no security
                      0,                    // default stack
                      (PTHREAD_START_ROUTINE) WriteThread,
                      (PVOID) &PaSystem,   // parameter
                      0,                   // default create flags
                      &tidWrite );         // container for thread id

    if (NULL == htWrite)
    {
        printf( "ERROR: failed to create write thread\n" );
        CloseHandle( htRead );
        return;
    }

    SetThreadPriority( htWrite, THREAD_PRIORITY_TIME_CRITICAL );

    wf.wFormatTag = WAVE_FORMAT_PCM;
    wf.nChannels = 1;
    wf.nSamplesPerSec = 11025; 
    wf.nAvgBytesPerSec = wf.nSamplesPerSec * wf.nChannels * (wf.wBitsPerSample / 8); 
    wf.nBlockAlign = 1; 
    wf.wBitsPerSample = 8; 
    wf.cbSize = sizeof( WAVEFORMATEX );

    RtlZeroMemory( rgwh, sizeof( rgwh ) );

    if (waveOutOpen( &PaSystem.hwo, 0, &wf, tidWrite, 
                     0L, CALLBACK_THREAD ))
    {
        printf( "ERROR: failed to open wave output device.\n" );
        CloseHandle( htRead );
        CloseHandle( htWrite );
        return -1;
    }

    if (waveInOpen( &PaSystem.hwi, 0, &wf, tidRead, 
                     0L, CALLBACK_THREAD ))
    {
        printf( "ERROR: failed to open wave input device.\n" );
        CloseHandle( htRead );
        CloseHandle( htWrite );
        return -1;
    }

    for (i = 0; i < 16; i++)
    {
        rgwh[ i ].lpData = HeapAlloc( GetProcessHeap(), 0, 256 );
        rgwh[ i ].dwBufferLength = 256;
        waveInPrepareHeader( PaSystem.hwi, &rgwh[ i ], sizeof( WAVEHDR ) );
        waveInAddBuffer( PaSystem.hwi, &rgwh[ i ], sizeof( WAVEHDR ) );
    }

    printf( "\nPress any key to begin P/A system..." );
    while (!_kbhit())
        Sleep( 0 );
    printf( "\n" );

    if (_kbhit ())
        _getch ();

    waveInStart( PaSystem.hwi );

    printf( "\nPress any key to terminate..." );
    while (!_kbhit())
        Sleep( 0 );
    printf( "\n" );

    if (_kbhit ())
        _getch ();

    waveInStop( PaSystem.hwi );

    waveInReset( PaSystem.hwi );
    waveInClose( PaSystem.hwi );

    waveOutReset( PaSystem.hwo );
    waveOutClose( PaSystem.hwo );

    CloseHandle( htWrite );
    CloseHandle( htRead );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\midirec\midirec.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <tchar.h>

/*	-	-	-	-	-	-	-	-	*/
struct {
	UCHAR	len;
	LPTSTR	name;
} gabMsg[] = {
	1,	TEXT("SysEx"),		/* F0 sysex begin	*/
	2,	TEXT("TCQF"),		/* F1 midi tcqf		*/
	3,	TEXT("SongPosition"),	/* F2 song position	*/
	2,	TEXT("SongSelect"),	/* F3 song select	*/
	1,	TEXT("*undefined*"),	/* F4 undefined		*/
	1,	TEXT("*undefined*"),	/* F5 undefined		*/
	1,	TEXT("TuneRequest"),	/* F6 tune request	*/
	1,	TEXT("EOX"),		/* F7 sysex eox		*/

	1,	TEXT("TimingClock"),	/* F8 timing clock	*/
	1,	TEXT("*undefined*"),	/* F9 undefined		*/
	1,	TEXT("Start"),		/* FA start		*/
	1,	TEXT("Continue"),	/* FB continue		*/
	1,	TEXT("Stop"),		/* FC stop		*/
	1,	TEXT("*undefined*"),	/* FD undefined		*/
	1,	TEXT("ActiveSensing"),	/* FE active sensing	*/
	1,	TEXT("SystemReset"),	/* FF system reset	*/

	3,	TEXT("NoteOff"),	/* 80 note off		*/
	3,	TEXT("NoteOn"),		/* 90 note on		*/
	3,	TEXT("KeyPressure"),	/* A0 key pressure	*/
	3,	TEXT("ControlChange"),	/* B0 control change	*/
	2,	TEXT("ProgramChange"),	/* C0 program change	*/
	2,	TEXT("ChannelPressure"),/* D0 channel pressure	*/
	3,	TEXT("PitchBend")	/* E0 pitch bend	*/
};

#define	IS_SYSTEM(b)		(((b) & 0xF0) == 0xF0)

/*	-	-	-	-	-	-	-	-	*/
VOID midCallback(
	HDRVR	hdrvr,
	UINT	uMsg,
	DWORD	dwUser,
	DWORD	dw1,
	DWORD	dw2)
{
	ULONG	index;
	ULONG	i;

	switch (uMsg) {
	case MIM_OPEN:
		_tprintf(TEXT("MIM_OPEN\n"));
		break;
	case MIM_CLOSE:
		_tprintf(TEXT("MIM_CLOSE\n"));
		break;
	case MIM_DATA:
		if (IS_SYSTEM((UCHAR)dw1))
			index = (UCHAR)dw1 & 0x0F;
		else
			index = ((UCHAR)dw1 >> 4) + 0x08;
		_tprintf(TEXT("%.10lu %16.16s "), dw2, gabMsg[index].name);
		for (i = 0; i < gabMsg[index].len; i++)
			_tprintf(TEXT("%.2lx"), ((PUCHAR)&dw1)[i]);
		_tprintf(TEXT("\n"));
		break;
	case MIM_LONGDATA:
		_tprintf(TEXT("MIM_LONGDATA\n"));
		break;
	case MIM_ERROR:
		_tprintf(TEXT("%.10lu        MIM_ERROR "), dw2);
		if (((PUCHAR)&dw1)[3] > 3)
			_tprintf(TEXT("%lx*\n"), dw1);
		else {
			for (i = 0; i < ((PUCHAR)&dw1)[3]; i++)
				_tprintf(TEXT("%.2lx"), ((PUCHAR)&dw1)[i]);
			_tprintf(TEXT("\n"));
		}
		break;
	case MIM_LONGERROR:
		_tprintf(TEXT("MIM_LONGERROR\n"));
		break;
	}
}

/*	-	-	-	-	-	-	-	-	*/
int _cdecl main(
	int	argc,
	TCHAR	*argv[],
	TCHAR	*envp[])
{
	HMIDIIN		hmidi;
	MMRESULT	mmr;

	if (!(mmr = midiInOpen(&hmidi, 0, (DWORD)midCallback, 0, CALLBACK_FUNCTION))) {
		midiInStart(hmidi);
		_tprintf(TEXT("wait...\n"));
		_fgettchar();
		midiInStop(hmidi);
		midiInClose(hmidi);
	} else
		_tprintf(TEXT("failed to open device 0 (%lx)\n"), mmr);
	return 0;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\pinquery\pinquery.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    pinquery.c

Abstract:

    Pin test app.

--*/

#define STREAMING
#define CLOSEHANDLES

#include <windows.h>
#include <objbase.h>
#include <devioctl.h>

#include <tchar.h>
#include <stdio.h>
#include <conio.h>
#include <malloc.h>

#include <mmsystem.h>
#include <mmreg.h>
#include <ks.h>
#include <ksi.h>
#include <ksmedia.h>
#include <setupapi.h>

#ifndef FILE_QUAD_ALIGNMENT
#define FILE_QUAD_ALIGNMENT             0x00000007
#endif // FILE_QUAD_ALIGNMENT

#define AUDIO_SRC       L"\\??\\c:\\winnt\\media\\ringin.wav"

PSTR StateStrings[] = {
    "Stop",
    "Acquire",
    "Pause",
    "Run"
};

PSTR DataFlowStrings[] = {
    "Undefined",
    "Input",
    "Output",
    "Full duplex"
};

PSTR CommunicationStrings[] = {
    "None",
    "Sink",
    "Source",
    "Both",
    "Bridge"
};

VOID
PinDisplayDataRange(
    PKSDATARANGE    DataRange
    );

BOOL
HandleControl(
    HANDLE   DeviceHandle,
    DWORD    IoControl,
    PVOID    InBuffer,
    ULONG    InSize,
    PVOID    OutBuffer,
    ULONG    OutSize,
    PULONG   BytesReturned
    )
{
    BOOL            IoResult;
    OVERLAPPED      Overlapped;

    RtlZeroMemory(&Overlapped, sizeof(OVERLAPPED));
    if (!(Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
        return FALSE;
    IoResult = DeviceIoControl(DeviceHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, BytesReturned, &Overlapped);
    if (!IoResult && (ERROR_IO_PENDING == GetLastError())) {
        WaitForSingleObject(Overlapped.hEvent, INFINITE);
        IoResult = TRUE;
    }
    CloseHandle(Overlapped.hEvent);
    return IoResult;
}

VOID
DigitalAudioFormat(
    PKSDATARANGE    DataRange
    )
{
    PKSDATARANGE_AUDIO  AudioRange = (PKSDATARANGE_AUDIO)DataRange;

    printf("\tSubFormat: ");
    if (IsEqualGUID(&AudioRange->DataRange.SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD))
        printf("KSDATAFORMAT_SUBTYPE_WILDCARD\n");
    else
        switch(EXTRACT_WAVEFORMATEX_ID(&AudioRange->DataRange.SubFormat)) {
        case WAVE_FORMAT_PCM:
            printf("WAVE_FORMAT_PCM\n");
            break;
        case WAVE_FORMAT_ALAW:
            printf("WAVE_FORMAT_ALAW\n");
            break;
        case WAVE_FORMAT_MULAW:
            printf("WAVE_FORMAT_MULAW\n");
            break;
        default:
            printf("unknown\n");
            break;
        }
    printf("\tMaximumChannels: %u\n", AudioRange->MaximumChannels);
    printf("\tMinimumBitsPerSample: %u\n", AudioRange->MinimumBitsPerSample);
    printf("\tMaximumBitsPerSample: %u\n", AudioRange->MaximumBitsPerSample);
    printf("\tMinimumSampleFrequency: %u\n", AudioRange->MinimumSampleFrequency);
    printf("\tMaximumSampleFrequency: %u\n", AudioRange->MaximumSampleFrequency);
}

VOID
MusicFormat(
    PKSDATARANGE    DataRange
    )
{
    printf("\tSubFormat: ");
    if (IsEqualGUID(&DataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_MIDI))
        printf("KSDATAFORMAT_SUBTYPE_MIDI\n");
    else if (IsEqualGUID(&DataRange->SubFormat, &KSDATAFORMAT_SUBTYPE_MIDI_BUS))
        printf("KSDATAFORMAT_SUBTYPE_MIDI_BUS\n");
    else
        printf("unknown\n");
}

HANDLE
DigitalAudioConnect(
    HANDLE          FilterHandle,
    ULONG           PinId,
    REFGUID         MajorFormat
    )
{
    UCHAR                           ConnectBuffer[sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX)];
    PKSPIN_CONNECT                  Connect;
    PKSDATAFORMAT_WAVEFORMATEX      AudioFormat;
    HANDLE                          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
#ifdef STREAMING
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
#else // !STREAMING
    Connect->Interface.Set = KSINTERFACESETID_Media;
    Connect->Interface.Id = KSINTERFACE_MEDIA_WAVE_BUFFERED;
#endif // !STREAMING
    Connect->Interface.Flags = 0;
    Connect->Medium.Set = KSMEDIUMSETID_Standard;
    Connect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Connect->Medium.Flags = 0;
    Connect->PinId = PinId;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;

    AudioFormat = (PKSDATAFORMAT_WAVEFORMATEX)(Connect + 1);
    AudioFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    AudioFormat->DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
    AudioFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
    AudioFormat->DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    AudioFormat->DataFormat.Reserved = 0;
    AudioFormat->WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
    AudioFormat->WaveFormatEx.nChannels = 1;
    AudioFormat->WaveFormatEx.nSamplesPerSec = 11025;
    AudioFormat->WaveFormatEx.nAvgBytesPerSec = 11025;
    AudioFormat->WaveFormatEx.wBitsPerSample = 8;
    AudioFormat->WaveFormatEx.nBlockAlign = 1;
    AudioFormat->WaveFormatEx.cbSize = 0;
    if (KsCreatePin(FilterHandle, Connect, GENERIC_WRITE, &PinHandle))
        return NULL;
    return PinHandle;
}

HANDLE
MusicConnect(
    HANDLE          FilterHandle,
    ULONG           PinId,
    REFGUID         MajorFormat
    )
{
    UCHAR           ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT)];
    PKSPIN_CONNECT  Connect;
    PKSDATAFORMAT   MusicFormat;
    HANDLE          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    Connect->Interface.Flags = 0;
    Connect->PinId = PinId;
    Connect->Medium.Set = KSMEDIUMSETID_Standard;
    Connect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Connect->Medium.Flags = 0;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    MusicFormat = (PKSDATAFORMAT)(Connect + 1);
    MusicFormat->MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
    MusicFormat->SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    MusicFormat->Specifier = KSDATAFORMAT_SPECIFIER_NONE;
    MusicFormat->FormatSize = sizeof(KSDATAFORMAT);
    MusicFormat->Reserved = 0;
    if (KsCreatePin(FilterHandle, Connect, GENERIC_WRITE, &PinHandle))
        return NULL;
    return PinHandle;
}

HANDLE
RiffAudioConnect(
    HANDLE          FilterHandle,
    ULONG           PinId,
    REFGUID         MajorFormat
    )
{
    UCHAR           ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT)+sizeof(AUDIO_SRC)];
    PKSPIN_CONNECT  Connect;
    PKSDATAFORMAT   FileFormat;
    HANDLE          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    Connect->Interface.Flags = 0;
    Connect->PinId = PinId;
    Connect->Medium.Set = KSMEDIUMSETID_FileIo;
    Connect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Connect->Medium.Flags = 0;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    FileFormat = (PKSDATAFORMAT)(Connect + 1);
    FileFormat->MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    FileFormat->SubFormat = KSDATAFORMAT_SUBTYPE_WILDCARD;
    FileFormat->Specifier = KSDATAFORMAT_SPECIFIER_FILENAME;
    FileFormat->FormatSize = sizeof(KSDATAFORMAT) + sizeof(AUDIO_SRC);
    FileFormat->Reserved = 0;
    wcscpy((PWCHAR)(FileFormat + 1), AUDIO_SRC);
    if (KsCreatePin(FilterHandle, Connect, GENERIC_WRITE, &PinHandle))
        return NULL;
    return PinHandle;
}

HANDLE
StreamFileConnect(
    HANDLE          FilterHandle,
    ULONG           PinId,
    REFGUID         MajorFormat
    )
{
    UCHAR           ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT)+sizeof(AUDIO_SRC)];
    PKSPIN_CONNECT  Connect;
    PKSDATAFORMAT   FileFormat;
    HANDLE          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    Connect->Interface.Flags = 0;
    Connect->Medium.Set = KSMEDIUMSETID_FileIo;
    Connect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Connect->Medium.Flags = 0;
    Connect->PinId = PinId;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    FileFormat = (PKSDATAFORMAT)(Connect + 1);
    FileFormat->MajorFormat = KSDATAFORMAT_TYPE_STREAM;
    FileFormat->SubFormat = KSDATAFORMAT_SUBTYPE_NONE;
    FileFormat->Specifier = KSDATAFORMAT_SPECIFIER_FILENAME;
    FileFormat->FormatSize = sizeof(KSDATAFORMAT) + sizeof(AUDIO_SRC);
    FileFormat->Reserved = 0;
    wcscpy((PWCHAR)(FileFormat + 1), AUDIO_SRC);
    if (KsCreatePin(FilterHandle, Connect, GENERIC_WRITE, &PinHandle))
        return NULL;
    return PinHandle;
}

HANDLE
StreamDevConnect(
    HANDLE          FilterHandle,
    ULONG           PinId,
    REFGUID         MajorFormat
    )
{
    UCHAR           ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT)];
    PKSPIN_CONNECT  Connect;
    PKSDATAFORMAT   FileFormat;
    HANDLE          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    Connect->Interface.Flags = 0;
    Connect->Medium.Set = KSMEDIUMSETID_Standard;
    Connect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Connect->Medium.Flags = 0;
    Connect->PinId = PinId;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    FileFormat = (PKSDATAFORMAT)(Connect + 1);
    FileFormat->MajorFormat = KSDATAFORMAT_TYPE_STREAM;
    FileFormat->SubFormat = KSDATAFORMAT_SUBTYPE_NONE;
    FileFormat->Specifier = KSDATAFORMAT_SPECIFIER_NONE;
    FileFormat->FormatSize = sizeof(KSDATAFORMAT);
    FileFormat->Reserved = 0;
    if (KsCreatePin(FilterHandle, Connect, GENERIC_READ, &PinHandle))
        return NULL;
    return PinHandle;
}

typedef VOID (*PFNFORMAT)(
    PKSDATARANGE    DataRange
    );

typedef HANDLE (*PFNCONNECT)(
    HANDLE          FilterHandle,
    ULONG           PinId,
    REFGUID         MajorFormat
    );

typedef struct {
    REFGUID         Type;
    REFGUID         Format;
    PSTR            FormatName;
    PFNFORMAT       FormatFunction;
    PFNCONNECT      ConnectFunction;
} GUIDTOSTR, *PGUIDTOSTR;

GUIDTOSTR DataFormatStrings[] = {
    { 
        &KSDATAFORMAT_TYPE_AUDIO,
        &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
        "KSDATAFORMAT_TYPE_AUDIO [KSDATAFORMAT_SPECIFIER_WAVEFORMATEX]",
        DigitalAudioFormat,
        DigitalAudioConnect
    },
    { 
        &KSDATAFORMAT_TYPE_MUSIC,
        &KSDATAFORMAT_SPECIFIER_NONE,
        "KSDATAFORMAT_TYPE_MUSIC [KSDATAFORMAT_SPECIFIER_NONE]",
        MusicFormat,
        MusicConnect
    },
    { 
        &KSDATAFORMAT_TYPE_AUDIO,
        &KSDATAFORMAT_SPECIFIER_FILENAME,
        "KSDATAFORMAT_TYPE_AUDIO [KSDATAFORMAT_SPECIFIER_FILENAME]",
        NULL,
        RiffAudioConnect
    },
    { 
        &KSDATAFORMAT_TYPE_STREAM,
        &KSDATAFORMAT_SPECIFIER_FILENAME,
        "KSDATAFORMAT_TYPE_STREAM [KSDATAFORMAT_SPECIFIER_FILENAME]",
        NULL,
        StreamFileConnect
    },
    { 
        &KSDATAFORMAT_TYPE_STREAM,
        &KSDATAFORMAT_SPECIFIER_NONE,
        "KSDATAFORMAT_TYPE_STREAM [KSDATAFORMAT_SPECIFIER_NONE]",
        NULL,
        StreamDevConnect
    },
    { 
        &KSDATAFORMAT_TYPE_WILDCARD,
        &KSDATAFORMAT_SPECIFIER_WILDCARD,
        "KSDATAFORMAT_TYPE_WILDCARD [KSDATAFORMAT_SPECIFIER_WILDCARD]",
        NULL,
        NULL
    }
    
};

int
PinFindDataFormat(
    REFGUID Type,
    REFGUID Format
    )
{
    int     StringCount;

    for (StringCount = 0; StringCount < SIZEOF_ARRAY(DataFormatStrings); StringCount++)
        if (IsEqualGUID(DataFormatStrings[StringCount].Type, Type) && IsEqualGUID(DataFormatStrings[StringCount].Format, Format))
            return StringCount;
    return -1;
}

VOID
PinDisplayDataRange(
    PKSDATARANGE    DataRange
    )
{
    int     StringCount;

    printf("\nDATARANGE: FormatSize = %u\n", DataRange->FormatSize);

    StringCount = PinFindDataFormat(&DataRange->MajorFormat, &DataRange->Specifier);
    if (StringCount != -1) {
        printf("\tMajorFormat: %s\n", DataFormatStrings[StringCount].FormatName);
        if (DataFormatStrings[StringCount].FormatFunction)
            DataFormatStrings[StringCount].FormatFunction(DataRange);
    }
}

#if 0
VOID
PinDisplayDataRouting(
    HANDLE          FilterHandle,
    ULONG           PinId
    )
{
    KSP_PIN         Pin;
    ULONG           BytesReturned;
    ULONG           DataRoutingSize;
    BOOLEAN         IoResult;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_DATAROUTING;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;
    IoResult = HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), &DataRoutingSize, sizeof(ULONG), &BytesReturned);
    if (!IoResult || !BytesReturned)
        printf("failed to retrieve Pin %u data routing count.\n", PinId);
    else {
        PULONG              DataRoutingBuffer;

        printf("Pin %u data routing pin size = %u.\n", PinId, DataRoutingSize);
        DataRoutingBuffer = HeapAlloc(GetProcessHeap(), 0, DataRoutingSize);
        IoResult = HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), DataRoutingBuffer, DataRoutingSize, &BytesReturned);
        if (!IoResult || (DataRoutingSize != BytesReturned))
            printf("\n\nfailed to retrieve Pin %u data routing data.\n", PinId);
        else {
            PKSMULTIPLE_ITEM    MultipleItem;

            printf("\n\n-----------Start Data Routing for Pin %u-----------", PinId);
            MultipleItem = (PKSMULTIPLE_ITEM)DataRoutingBuffer;
            DataRoutingBuffer = (PULONG)(MultipleItem + 1);
            for (; MultipleItem->Count--;) {
                printf("\n\nPin = %u\n", DataRoutingBuffer[MultipleItem->Count]);
            }
            printf("\n\n-----------End Data Routing for Pin %u-----------\n", PinId);
        }
        HeapFree(GetProcessHeap(), 0, DataRoutingBuffer);
    }
}
#endif

#if 0
VOID
PinDisplayComponents(
    HANDLE          FilterHandle,
    ULONG           PinId
    )
{
    KSP_PIN         Pin;
    ULONG           BytesReturned;
    ULONG           ComponentsSize;
    BOOLEAN         IoResult;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_COMPONENTS;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;
    IoResult = HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), &ComponentsSize, sizeof(ULONG), &BytesReturned);
    if (!IoResult || !BytesReturned)
        printf("failed to retrieve Pin %u components size.\n", PinId);
    else {
        PUCHAR  ComponentsBuffer;

        printf("Pin %u components size = %u.\n", PinId, ComponentsSize);
        ComponentsBuffer = HeapAlloc(GetProcessHeap(), 0, ComponentsSize);
        IoResult = HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), ComponentsBuffer, ComponentsSize, &BytesReturned);
        if (!IoResult || (ComponentsSize != BytesReturned))
            printf("\n\nfailed to retrieve Pin %u components.\n", PinId);
        else {
            GUID*               ComponentsList;
            PKSMULTIPLE_ITEM    MultipleItem;

            printf("\n\n-----------Start Components for Pin %u-----------", PinId);
            MultipleItem = (PKSMULTIPLE_ITEM)ComponentsBuffer;
            ComponentsList = (GUID*)(MultipleItem + 1);
            for (; MultipleItem->Count--;) {
                printf("\n\nComponent = {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                    ComponentsList[MultipleItem->Count].Data1,
                    ComponentsList[MultipleItem->Count].Data2,
                    ComponentsList[MultipleItem->Count].Data3,
                    ComponentsList[MultipleItem->Count].Data4[0],
                    ComponentsList[MultipleItem->Count].Data4[1],
                    ComponentsList[MultipleItem->Count].Data4[2],
                    ComponentsList[MultipleItem->Count].Data4[3],
                    ComponentsList[MultipleItem->Count].Data4[4],
                    ComponentsList[MultipleItem->Count].Data4[5],
                    ComponentsList[MultipleItem->Count].Data4[6],
                    ComponentsList[MultipleItem->Count].Data4[7]);
            }
            printf("\n\n-----------End Components for Pin %u-----------\n", PinId);
        }
        HeapFree(GetProcessHeap(), 0, ComponentsBuffer);
    }
}
#endif

VOID
PinSetState(
    HANDLE  PinHandle,
    KSSTATE DeviceState
    )
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    if (HandleControl(PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &DeviceState, sizeof(DeviceState), &BytesReturned))
        printf("Set state to %s\n", StateStrings[DeviceState]);

    else
        printf("Failed to set state to %ul\n", StateStrings[DeviceState]);
}

VOID
PinGetVolume(
    HANDLE          PinHandle
    )
{
    KSPROPERTY              Property;
    KSWAVE_VOLUME           Volume;
    ULONG                   BytesReturned;

    Property.Set = KSPROPSETID_Wave;
    Property.Id = KSPROPERTY_WAVE_VOLUME;
    Property.Flags = KSPROPERTY_TYPE_GET;

    if (HandleControl(PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Volume, sizeof(Volume), &BytesReturned)) {
        PVOID                   Data;
        KSPROPERTY_DESCRIPTION  Description;

        printf("Volume: %lx,%lx\n", Volume.LeftAttenuation, Volume.RightAttenuation);
        Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
        if (HandleControl(PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Description, sizeof(Description), &BytesReturned)) {
            printf("\tAccess=%lx setid=%lx cbSize=%lu\n", Description.AccessFlags, Description.PropTypeSet.Id, Description.DescriptionSize);
            Data = HeapAlloc(GetProcessHeap(), 0, Description.DescriptionSize);
            if (HandleControl(PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), Data, Description.DescriptionSize, &BytesReturned)) {
                if (Description.MembersListCount) {
                    PKSPROPERTY_MEMBERSHEADER    MembersHeader;

                    MembersHeader = (PKSPROPERTY_MEMBERSHEADER)((PKSPROPERTY_DESCRIPTION)Data + 1);
                    printf("\tMembersFlags=%lx MembersSize=%lu MembersCount=%lu\n", MembersHeader->MembersFlags, MembersHeader->MembersSize, MembersHeader->MembersCount);
                    if (MembersHeader->MembersCount) {
                        PKSPROPERTY_BOUNDS_LONG    Bounds;

                        Bounds = (PKSPROPERTY_BOUNDS_LONG)(MembersHeader + 1);
                        printf("\tUnsignedMinimum=%lu UnsignedMaximum=%lu\n", Bounds->UnsignedMinimum, Bounds->UnsignedMaximum);
                    }
                }
            } else
                printf("\tDescription failed\n");
            HeapFree(GetProcessHeap(), 0, Data);
        } else
            printf("\tDescription header failed\n");
    } else
        printf("Volume: failed\n");
}

#ifdef STREAMING
BOOL
PinReadStream(
    HANDLE  PinHandle
    )
{
    KSSTREAM_HEADER StreamHdr;
    UCHAR           StreamBuffer[1024];
    ULONG           BytesReturned;

    StreamHdr.FrameExtent = sizeof(StreamBuffer);
    StreamHdr.DataUsed = 0;
    StreamHdr.Data = &StreamBuffer;
    StreamHdr.OptionsFlags = 0;
    if (HandleControl(PinHandle, IOCTL_KS_READ_STREAM, NULL, 0, &StreamHdr, sizeof(StreamHdr), &BytesReturned)) {
        printf("ReadStream: DataUsed=%u, PresentationTime=%I64u OptionsFlags=%x\n", StreamHdr.DataUsed, StreamHdr.PresentationTime.Time, StreamHdr.OptionsFlags);
        if (StreamHdr.DataUsed == StreamHdr.FrameExtent)
            return TRUE;
    } else
        printf("***ReadStream failed***\n");
    return FALSE;
}

BOOL
PinWriteStream(
    HANDLE  PinHandle
    )
{
    KSSTREAM_HEADER StreamHdr;
    UCHAR           StreamBuffer[1024];
    ULONG           BytesReturned;

    StreamHdr.PresentationTime.Time = 0;
    StreamHdr.PresentationTime.Numerator = 1;
    StreamHdr.PresentationTime.Denominator = 1;
    StreamHdr.FrameExtent = sizeof(StreamBuffer);
    StreamHdr.DataUsed = sizeof(StreamBuffer);
    StreamHdr.Data = &StreamBuffer;
    StreamHdr.OptionsFlags = 0;
    if (HandleControl(PinHandle, IOCTL_KS_WRITE_STREAM, NULL, 0, &StreamHdr, sizeof(StreamHdr), &BytesReturned)) {
        printf("WriteStream: BytesReturned=%u DataUsed=%u\n", BytesReturned, StreamHdr.DataUsed);
        return TRUE;
    } else {
        printf("***WriteStream failed***\n");
        return FALSE;
    }
}

VOID
PinGetTime(
    HANDLE  PinHandle
    )
{
    KSPROPERTY  Property;
    KSTIME      Time;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_PRESENTATIONTIME;
    Property.Flags = KSPROPERTY_TYPE_GET;
    HandleControl(PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(KSPROPERTY), &Time, sizeof(Time), &BytesReturned);
    if (BytesReturned)
        printf("PinGetTime: Time=%I64u Numerator=%u Denominator=%u\n", Time.Time, Time.Numerator, Time.Denominator);
    else
        printf("***PinGetTime: failed****\n");
}

VOID
PinGetExtent(
    HANDLE  PinHandle
    )
{
    KSPROPERTY  Property;
    DWORDLONG   Extent;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_PRESENTATIONEXTENT;
    Property.Flags = KSPROPERTY_TYPE_GET;
    HandleControl(PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(KSPROPERTY), &Extent, sizeof(Extent), &BytesReturned);
    if (BytesReturned)
        printf("PinGetExtent: Extent=%I64u\n", Extent);
    else
        printf("***PinGetExtent: failed****\n");
}
#endif // STREAMING

VOID
GetPinClock(
    HANDLE  PinHandle
    )
{
    KSCLOCK_CREATE  ClockCreate;
    HANDLE          ClockHandle;

    ClockCreate.CreateFlags = 0;
    if (!KsCreateClock(PinHandle, &ClockCreate, &ClockHandle)) {
        KSPROPERTY              Property;
        BOOLEAN                 IoResult;
        DWORDLONG               Time;
        ULONG                   BytesReturned;
        ULONG                   Rate;
        KSEVENT                 Event;
        KSEVENT_TIME_MARK       EventTimeMark;

        Property.Set = KSPROPSETID_Clock;
        Property.Id = KSPROPERTY_CLOCK_TIME;
        Property.Flags = KSPROPERTY_TYPE_GET;
        IoResult = HandleControl(ClockHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Time, sizeof(DWORDLONG), &BytesReturned);
        if (!IoResult || !BytesReturned)
            printf("failed to retrieve Time.\n");
        else
            printf("Time=%I64u\n", Time);
        Property.Id = KSPROPERTY_CLOCK_PHYSICALTIME;
        IoResult = HandleControl(ClockHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Time, sizeof(DWORDLONG), &BytesReturned);
        if (!IoResult || !BytesReturned)
            printf("failed to retrieve Physical Time.\n");
        else
            printf("Physical Time=%I64u\n", Time);
        Event.Set = KSEVENTSETID_Clock;
        Event.Id = KSEVENT_CLOCK_POSITION_MARK;
        Event.Flags = KSEVENT_TYPE_ENABLE;
        EventTimeMark.EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
        if (EventTimeMark.EventData.EventHandle.Event = CreateEvent(NULL, TRUE, FALSE, NULL)) {
            EventTimeMark.EventData.EventHandle.Reserved[ 0 ] = 0;
            EventTimeMark.EventData.EventHandle.Reserved[ 1 ] = 0;
            EventTimeMark.MarkTime = 0;
            IoResult = HandleControl(ClockHandle, IOCTL_KS_ENABLE_EVENT, &Event, sizeof(Event), &EventTimeMark, sizeof(EventTimeMark), &BytesReturned);
            if (!IoResult)
                printf("failed to enable mark event.\n");
            else {
                WaitForSingleObject(EventTimeMark.EventData.EventHandle.Event, INFINITE);
                IoResult = HandleControl(ClockHandle, IOCTL_KS_DISABLE_EVENT, &EventTimeMark, sizeof(EventTimeMark), NULL, 0, &BytesReturned);
                if (!IoResult)
                    printf("failed to disable mark event.\n");
            }
            CloseHandle(EventTimeMark.EventData.EventHandle.Event);
        } else
            printf("could not create event handle to use for enabling mark event.\n");
        CloseHandle(ClockHandle);
    } else
        printf("failed to create clock.\n");
}

VOID
CycleEvent(
    HANDLE  Handle,
    GUID const*   Set,
    ULONG   Id
    )
{
    KSEVENT     Event;
    KSEVENTDATA EventData;

    Event.Set = *Set;
    Event.Id = Id;
    Event.Flags = KSEVENT_TYPE_ENABLE;
    EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
    if (EventData.EventHandle.Event = CreateEvent(NULL, TRUE, FALSE, NULL)) {
        BOOLEAN     IoResult;
        ULONG       BytesReturned;

        EventData.EventHandle.Reserved[ 0 ] = 0;
        EventData.EventHandle.Reserved[ 1 ] = 0;
        IoResult = HandleControl(Handle, IOCTL_KS_ENABLE_EVENT, &Event, sizeof(Event), &EventData, sizeof(EventData), &BytesReturned);
        if (!IoResult)
            printf("failed to enable event.\n");
        else {
            printf("Enabled event.\n");
            IoResult = HandleControl(Handle, IOCTL_KS_DISABLE_EVENT, &EventData, sizeof(EventData), NULL, 0, &BytesReturned);
            if (!IoResult)
                printf("failed to disable event.\n");
            else
                printf("Disabled event.\n");
        }
        CloseHandle(EventData.EventHandle.Event);
    } else
        printf("could not create event handle to use for enabling event.\n");
}

VOID
PinDisplayProperties(
    HANDLE  FilterHandle
    )
{
    KSPIN_CINSTANCES        Instances;
    KSPIN_DATAFLOW          DataFlow;
    KSPIN_COMMUNICATION     Communication;
    KSP_PIN                 Pin;
//    ULONG                   Components;
    HANDLE                  PinHandleList[16];
    ULONG                   PinId, j, BytesReturned, RangesSize, RangeCount, TypeCount;
    PVOID                   Data;
    PVOID                   DataOffset;
    ULONG                   MajorFormatCount;
    PKSDATARANGE            DataRange;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_CTYPES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(KSPROPERTY), &TypeCount, sizeof(ULONG), &BytesReturned);
    if (BytesReturned)
        printf("Pin types: %u\n", TypeCount);
    else {
        printf("failed to retrieve number of Pin types.\n");
        return;
    }

    for (PinId = 0; PinId < TypeCount; PinId++) {
        printf("\nPin: %u\n", PinId);
        printf("-----------------------------------------------------------------------\n");

        PinHandleList[PinId] = NULL;
        Pin.PinId = PinId;
        Pin.Reserved = 0;

        Pin.Property.Id = KSPROPERTY_PIN_DATAFLOW;
        HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), &DataFlow, sizeof(KSPIN_DATAFLOW), &BytesReturned);
        if (BytesReturned)
            printf("DATAFLOW: %s\n", DataFlowStrings[DataFlow]);
        else {
            printf("failed to retrieve Pin dataflow.\n");
            return;
        }

        Pin.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
        HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), &Communication, sizeof(KSPIN_COMMUNICATION), &BytesReturned);
        if (BytesReturned)
            printf("COMMUNICATION: %s\n", CommunicationStrings[Communication]);
        else {
            printf("failed to retrieve Pin communication.\n");
            return;
        }

//        PinDisplayComponents(FilterHandle, PinId);

        Pin.Property.Id = KSPROPERTY_PIN_CINSTANCES;
        HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), &Instances, sizeof(KSPIN_CINSTANCES), &BytesReturned);
        if (BytesReturned)
            printf("CINSTANCES: PossibleCount = %u, CurrentCount = %u\n", Instances.PossibleCount, Instances.CurrentCount);
        else {
            printf("failed to retrieve Pin instances.\n");
            return;
        }

        Pin.Property.Id = KSPROPERTY_PIN_DATARANGES;
        HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), &RangesSize, sizeof(ULONG), &BytesReturned);
        if (!BytesReturned) {
            printf("failed to retrieve Pin data range size.\n");
            return;
        }

        printf("DATARANGES: size = %u", RangesSize);

        Data = HeapAlloc(GetProcessHeap(), 0, RangesSize);
        HandleControl(FilterHandle, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), Data, RangesSize, &BytesReturned);
        if (RangesSize != BytesReturned) {
            printf("\n\nfailed to retrieve Pin data range data.\n");
            return;
        }

        RangeCount = ((PKSMULTIPLE_ITEM)Data)->Count;
        DataOffset = (PUCHAR)Data + sizeof(KSMULTIPLE_ITEM);

        printf(", range count = %u\n", RangeCount);
        for (j = 0; j < RangeCount; j++) {
            PinDisplayDataRange(DataOffset);
            (PUCHAR) DataOffset += ((((PKSDATARANGE) DataOffset)->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
        }
//        PinDisplayDataRouting(FilterHandle, PinId);

        DataRange = (PKSDATARANGE)((PUCHAR)Data + sizeof(KSMULTIPLE_ITEM));
        MajorFormatCount = PinFindDataFormat(&DataRange->MajorFormat, &DataRange->Specifier);
        if ((MajorFormatCount != -1) &&
            (Communication != KSPIN_COMMUNICATION_NONE) && 
            DataFormatStrings[MajorFormatCount].ConnectFunction) {
            PinHandleList[PinId] = DataFormatStrings[MajorFormatCount].ConnectFunction(FilterHandle, PinId, DataFormatStrings[MajorFormatCount].Type);

            if (!PinHandleList[PinId])
                printf("failed to connect (%x)\n", GetLastError());
            else {

                printf("connection successful\n");

                GetPinClock(PinHandleList[PinId]);
                CycleEvent(PinHandleList[PinId], &KSEVENTSETID_Connection, KSEVENT_CONNECTION_DATADISCONTINUITY);
#ifdef STREAMING
                if (Communication == KSPIN_COMMUNICATION_SINK) {
                    if (DataFlow == KSPIN_DATAFLOW_IN) {
                        PinWriteStream(PinHandleList[PinId]);
                        PinWriteStream(PinHandleList[PinId]);
                    } else if (DataFlow == KSPIN_DATAFLOW_OUT) {
                        while (PinReadStream(PinHandleList[PinId]))
                            ;
                        PinReadStream(PinHandleList[PinId]);
                    }
                    PinGetTime(PinHandleList[PinId]);
                    PinGetExtent(PinHandleList[PinId]);
                }
#else // !STREAMING
                PinGetVolume(PinHandleList[PinId]);
                PinSetState(PinHandleList[PinId], KSSTATE_ACQUIRE);
                PinSetState(PinHandleList[PinId], KSSTATE_PAUSE);
                PinSetState(PinHandleList[PinId], KSSTATE_RUN);
                PinSetState(PinHandleList[PinId], KSSTATE_STOP);
#endif // !STREAMING
            }
        }

        HeapFree(GetProcessHeap(), 0, Data);

        printf("\n");
    }
#ifdef CLOSEHANDLES
    for (PinId = 0; PinId < TypeCount; PinId++)
        if (PinHandleList[PinId])
            CloseHandle(PinHandleList[PinId]);
#endif // CLOSEHANDLES
}

#define STATIC_PMPORT_Transform \
    0x7E0EB9CBL, 0xB521, 0x11D1, 0x80, 0x72, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("7E0EB9CB-B521-11D1-8072-00A0C9223196", PMPORT_Transform);
#define PMPORT_Transform DEFINE_GUIDNAMED(PMPORT_Transform)

struct {
    GUID    ClassGuid;
    WCHAR*  TextName;
} TextTranslation[] = {
    {STATICGUIDOF(KSCATEGORY_BRIDGE), L"Bridge"},
    {STATICGUIDOF(KSCATEGORY_CAPTURE), L"Capture"},
    {STATICGUIDOF(KSCATEGORY_RENDER), L"Render"},
    {STATICGUIDOF(KSCATEGORY_MIXER), L"Mixer"},
    {STATICGUIDOF(KSCATEGORY_SPLITTER), L"Splitter"},
    {STATICGUIDOF(KSCATEGORY_DATACOMPRESSOR), L"DataCompressor"},
    {STATICGUIDOF(KSCATEGORY_DATADECOMPRESSOR), L"DataDecompressor"},
    {STATICGUIDOF(KSCATEGORY_DATATRANSFORM), L"DataTransform"},
    {STATICGUIDOF(KSCATEGORY_COMMUNICATIONSTRANSFORM), L"CommunicationTransform"},
    {STATICGUIDOF(KSCATEGORY_INTERFACETRANSFORM), L"InterfaceTransform"},
    {STATICGUIDOF(KSCATEGORY_MEDIUMTRANSFORM), L"MediumTransform"},
    {STATICGUIDOF(KSCATEGORY_FILESYSTEM), L"FileSystem"},
    {STATICGUIDOF(KSCATEGORY_AUDIO), L"Audio"},
    {STATICGUIDOF(KSCATEGORY_VIDEO), L"Video"},
    {STATICGUIDOF(KSCATEGORY_TEXT), L"Text"},
    {STATICGUIDOF(KSCATEGORY_CLOCK), L"Clock"},
    {STATICGUIDOF(KSCATEGORY_PROXY), L"Proxy"},
    {STATICGUIDOF(KSCATEGORY_QUALITY), L"Quality"},
    {STATICGUIDOF(KSNAME_Server), L"Server"},
    {STATICGUIDOF(PMPORT_Transform), L"TransformPort"}
};


BOOL TranslateClass(
    IN WCHAR*   ClassString,
    OUT GUID*   ClassGuid
)
{
    if (*ClassString == '{') {
        if (!CLSIDFromString(ClassString, ClassGuid)) {
            return TRUE;
        }
        printf("error: invalid class guid: \"%S\".\n", ClassString);
    } else {
        int     i;

        for (i = SIZEOF_ARRAY(TextTranslation); i--;) {
            if (!_wcsicmp(ClassString, TextTranslation[i].TextName)) {
                *ClassGuid = TextTranslation[i].ClassGuid;
                return TRUE;
            }
        }
        printf("error: invalid class name: \"%S\".\n" );
    }
    return FALSE;
}

int
_cdecl
main(
    int     argc,
    char*   argv[],
    char*   envp[]
    )
{
    int                                 i;
    BYTE                                Storage[ 256 * sizeof( WCHAR ) + 
                                            sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA ) ];
    HANDLE                              FilterHandle;
    GUID                                ClassGuid;
    HDEVINFO                            Set;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    InterfaceDeviceDetails;
    PSTR                                DevicePath;
    SP_INTERFACE_DEVICE_DATA            InterfaceDeviceData;
    ULONG                               BytesReturned;

    if (argc == 1) {
        printf("%s <device path> | <{class-guid}> | <class-name>\n", argv[0]);
        printf("where <class-name> is one of:\n" );
        for (i = SIZEOF_ARRAY(TextTranslation); i--;) {
            printf("    %S\n", TextTranslation[i].TextName);
        }
        
        return 0;
    }

    if (*argv[ 1 ] != '\\') {
    
        InterfaceDeviceDetails = (PSP_INTERFACE_DEVICE_DETAIL_DATA) Storage;
        
        MultiByteToWideChar(
            CP_ACP, 
            MB_PRECOMPOSED, 
            argv[1], 
            -1, 
            (WCHAR*)Storage, 
            sizeof(Storage));
        if (!TranslateClass((WCHAR*)Storage, &ClassGuid)) {
            return 0;
        }
        Set = SetupDiGetClassDevs( 
            &ClassGuid,
            NULL,
            NULL,
            DIGCF_PRESENT | DIGCF_INTERFACEDEVICE );

        if (!Set) {
            printf( "error: NULL set returned (%u).\n", GetLastError());
            return 0;
        }       

        InterfaceDeviceData.cbSize = 
            sizeof( SP_INTERFACE_DEVICE_DATA );
        InterfaceDeviceDetails->cbSize = 
            sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

        if (!SetupDiEnumInterfaceDevice(
            Set,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            &ClassGuid,
            0,                          // DWORD MemberIndex
            &InterfaceDeviceData )) {
            printf("error: unable to enumerate default device in category (%u).\n", GetLastError());
            return 0;
        }
        if (!SetupDiGetInterfaceDeviceDetail(
            Set,
            &InterfaceDeviceData,
            InterfaceDeviceDetails,
            sizeof( Storage ),
            NULL,                           // PDWORD RequiredSize
            NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

            printf( 
                "error: unable to retrieve device details for set item (%u).\n",
                 GetLastError() );
            return 0;        
        } else {
            DevicePath = InterfaceDeviceDetails->DevicePath;
        }
    } else {
        DevicePath = argv[ 1 ];
    }
    
    FilterHandle = CreateFile(DevicePath, GENERIC_READ | GENERIC_WRITE, 0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                              NULL);
    if (FilterHandle == (HANDLE) -1) {
        printf("failed to open \"%s\" (%x)\n", argv[1], GetLastError());
        return 0;
    }
    printf("\n\tProperties for \"%s\"\n\n\n", argv[1]);
    PinDisplayProperties(FilterHandle);
    CloseHandle(FilterHandle);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\play\play.h ===
//---------------------------------------------------------------------------
//
//  Module:   play.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define ERR_BADFORMAT (1)
#define ERR_CORRUPTED (2)
#define ERR_NOOPEN    (3)

#define FILE_ERR_OK   (0)
#define FILE_ERR_READ (1)
#define FILE_ERR_EOF  (2)

#define FOURCC_WAVE   mmioFOURCC('W', 'A', 'V', 'E')
#define FOURCC_FMT    mmioFOURCC('f','m','t',' ')
#define FOURCC_DATA   mmioFOURCC('d','a','t','a')

typedef struct
{
   KSEVENT_DATA_MARK  DataMark ;
   HANDLE             hDev, hfm ;
   BOOLEAN            fRunning, fEOF ;
   BYTE               bSilence ;
   ULONG              cBuffers, cbCache, cbDevice, cbTotal,
                      ulCachePosition, ulEndDevicePosition,
                      ulLastDevicePosition, ulLastReportedPosition ;
   PBYTE              pCacheBuffer ;
   PVOID              pvConnection ;

} WAVECACHE, *PWAVECACHE ;

//
// function prototypes
//

BOOL WvControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
) ;

VOID WvSetState
(
    HANDLE  hDevice,
    KSSTATE DeviceState
) ;

VOID WvGetPosition
(
   HANDLE   hDevice,
   PULONG   pulCurrentDevicePosition
) ;

DWORD ServiceThread
(
   PWAVECACHE  pCache
) ;

VOID waveOutFile
(
   PSTR   pszFileName
) ;

BOOL waveCreateCache
(
   HANDLE            hf,
   PWAVECACHE        pCache,
   BYTE              bSilence
) ;

VOID waveDestroyCache
(
   PWAVECACHE  pCache
) ;

VOID waveFillBuffer
(
   PWAVECACHE  pCache,
   BOOL        fPrime
) ;

ULONG waveGetPosition
(
   PWAVECACHE  pCache
) ;

HANDLE waveOpenFile
(
   PSTR                        pszFileName,
   PKSDATAFORMAT_DIGITAL_AUDIO AudioFormat
) ;

WORD waveReadGetWord( HANDLE hf ) ;

DWORD waveReadGetDWord( HANDLE hf ) ;

DWORD waveReadSkipSpace
(
   HANDLE   hf,
   ULONG    cbSkip
) ;

int waveFillCache
(
   HANDLE      hf,
   PWAVECACHE  pCache
) ;

//---------------------------------------------------------------------------
//  End of File: play.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\play\play.c ===
//---------------------------------------------------------------------------
//
//  Module:   play.c
//
//  Description:
//     Borrowed pieces from the WSS MS-DOS Developer's Kit.  Quick, 
//     easy (yeah, kinda dirty) but this way I don't have to write it 
//     once again...
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <objbase.h>
#include <devioctl.h>
#include <mmsystem.h>
#include <ks.h>

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>

#include "play.h"


BOOL WvWrite
(
   HANDLE   hDevice,
   PVOID    pBuffer,
   ULONG    cbSize,
   ULONG    ulPosition,
   PULONG   pcbWritten
)
{
   BOOL        fResult ;
   OVERLAPPED  ov ;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) ) ;
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
      return FALSE ;

   ov.OffsetHigh = 0 ;
   ov.Offset = ulPosition ;
   fResult = WriteFile( hDevice, pBuffer, cbSize, pcbWritten, &ov ) ;

   if (!fResult)
   {
      if (ERROR_IO_PENDING == GetLastError())
      {
         WaitForSingleObject( ov.hEvent, INFINITE ) ;
         fResult = TRUE ;
      }
      else
         fResult = TRUE ;
   }

   CloseHandle( ov.hEvent ) ;

   return fResult ;
}

BOOL WvControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
)
{
   BOOL        fResult ;
   OVERLAPPED  ov ;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) ) ;
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
      return FALSE ;

   fResult =
      DeviceIoControl( hDevice,
                       dwIoControl,
                       pvIn,
                       cbIn,
                       pvOut,
                       cbOut,
                       pcbReturned,
                       &ov ) ;


   if (!fResult)
   {
      if (ERROR_IO_PENDING == GetLastError())
      {
         WaitForSingleObject( ov.hEvent, INFINITE ) ;
         fResult = TRUE ;
      }
      else
         fResult = FALSE ;
   }

   CloseHandle( ov.hEvent ) ;

   return fResult ;

}

VOID WvSetState
(
   HANDLE         hDevice,
   KSSTATE        DeviceState
)
{
   KSPROPERTY   Property ;
   ULONG        cbReturned ;

   Property.guidSet = KSPROPSETID_Control ;
   Property.id = KSPROPERTY_CONTROL_STATE ;

   WvControl( hDevice,
              (DWORD) IOCTL_KS_SET_PROPERTY,
              &Property,
              sizeof( KSPROPERTY ),
              &DeviceState,
              sizeof( KSSTATE ),
              &cbReturned ) ;
}

VOID WvGetPosition
(
   HANDLE   hDevice,
   PULONG   pulCurrentDevicePosition
)
{
   KSPROPERTY   avProp ;
   DWORDLONG    Position ;
   ULONG        cbReturned ;

   avProp.guidSet = KSPROPSETID_Control;
   avProp.id =  KSPROPERTY_CONTROL_PHYSICALPOSITION ;

   if (!WvControl( hDevice,
                   (DWORD) IOCTL_KS_GET_PROPERTY,
                   &avProp,
                   sizeof( KSPROPERTY ),
                   &Position,
                   sizeof( DWORDLONG ),
                   &cbReturned ) || !cbReturned)
      *pulCurrentDevicePosition = (ULONG) 0 ;
   else
      *pulCurrentDevicePosition = (ULONG) Position ;
}

DWORD ServiceThread
(
   PWAVECACHE  pCache
)
{
   BOOL       fDone ;
   ULONG      cbReturned ;

   fDone = FALSE ;
   while (!fDone)
   {
      WaitForSingleObject( pCache -> DataMark.EventData.EventHandle.hEvent, INFINITE ) ;

      // If the device is being closed, hDevice is set to NULL

      if (!pCache -> hDev)
         fDone = TRUE ;
                        
      if (!fDone)
         waveFillBuffer( pCache, FALSE ) ;
   }

   return 0 ;
}

#define REGSTR_PATH_WDMAUDIO L"System\\CurrentControlSet\\Control\\MediaProperties\\wdm\\audio"

VOID waveOutFile
(
   PSTR   pszFileName
)
{   
   int                nFileErr ;
   BYTE               bSilence ;
   DWORD              dwThreadId ;
   HANDLE             hThread ;
   HANDLE             hf ;
   ULONG              cbReturned, ulDeltaMax, ulDeltaMin,
                      ulLastPos, ulDelta ;
   WCHAR              aszValue[32];

   PKSPIN_CONNECT   pConnect ;
   KSEVENT          Event ;
   KSPROPERTY       Property ;
   KSWAVE_BUFFER    Buffer ;
   HANDLE           hPin, hDevice ;
   PVOID            pvConnection ;
   WAVECACHE        waveCache ;

   RtlZeroMemory( &waveCache, sizeof( WAVECACHE ) ) ;

   //
   //  Open input file.  Make sure it's a WAV.
   //

   if (NULL == 
         (pConnect = HeapAlloc( GetProcessHeap(), 0, 
                                sizeof( KSPIN_CONNECT ) + 
                                   sizeof( KSDATAFORMAT_DIGITAL_AUDIO ) )))
   {
      printf( "\n\nERROR: unable to allocate memory for pin.\n\n" ) ;
      return ;
   }

   hf = waveOpenFile( pszFileName, 
                      (PKSDATAFORMAT_DIGITAL_AUDIO) (pConnect + 1) ) ;

   if (NULL == hf)
   {
      printf( "\n\nERROR: unable to open input file.\n\n" ) ;
      HeapFree( GetProcessHeap(), 0, pConnect ) ;
      return ;
   }

   cbReturned = sizeof(aszValue);
   if (RegQueryValueW (HKEY_LOCAL_MACHINE, REGSTR_PATH_WDMAUDIO, aszValue, &cbReturned) != ERROR_SUCCESS)
      hPin = (HANDLE) INVALID_HANDLE_VALUE;
   else
   hPin = CreateFileW( aszValue,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                      NULL ) ;

   if (hPin == (HANDLE) INVALID_HANDLE_VALUE)
   {
      CloseHandle( hf ) ;
      HeapFree( GetProcessHeap(), 0, pConnect ) ;
      printf( "\n\nERROR: unable to open pin device.\n\n" ) ;
      return ;
   } 

   pConnect -> idPin = 2 ;
   // no "connect to"
   pConnect -> hPinTo = NULL ;
   pConnect -> Interface.guidSet = KSINTERFACESETID_Standard ;
   pConnect -> Interface.id = KSINTERFACE_STANDARD_WAVE_BUFFERED ;
   // verify this...
   pConnect -> Bus.guidSet = KSBUSSETID_Standard ;
   pConnect -> Bus.id = KSBUS_STANDARD_DEVIO ;
   pConnect -> Priority.ulPriorityClass = KSPRIORITY_NORMAL ;
   pConnect -> Priority.ulPrioritySubClass = 0 ;

   if (!(waveCache.hDev = KsCreatePin( hPin, pConnect )))
   {
      printf( "\n\nERROR: unable to connect to device.\n\n" ) ;
      HeapFree( GetProcessHeap(), 0, pConnect ) ;
      CloseHandle( hPin ) ;
      CloseHandle( hf ) ;
      return ;
   }

   CloseHandle( hPin ) ;

   if (((PKSDATAFORMAT_DIGITAL_AUDIO) (pConnect + 1)) -> cBitsPerSample == 8)
      bSilence = 0x80 ;
   else
      bSilence = 0x00 ;

   HeapFree( GetProcessHeap(), 0, pConnect ) ;

   //
   // Prepare the device...
   //

   WvSetState( waveCache.hDev, KSSTATE_PAUSE ) ;

   //
   // HACK! HACK! HACK!
   //

   //
   // OK, after idle, the buffer has been mapped to user space...
   // Assuming many things, like system DMA, etc.
   //

   Property.guidSet = KSPROPSETID_Wave ;
   Property.id = KSPROPERTY_WAVE_BUFFER ;
   WvControl( waveCache.hDev,
              (DWORD) IOCTL_KS_GET_PROPERTY,
              &Property,
              sizeof( KSPROPERTY ),
              &Buffer,
              sizeof( KSWAVE_BUFFER ),
              &cbReturned ) ;

   //
   //  Perform device setup, and create the service thread
   //

   if (!waveCreateCache( hf, &waveCache, bSilence ))
   {
      printf( "ERROR: unable to create cache\n" ) ;
      CloseHandle( hf ) ;
      return ;
   }

   waveCache.cbDevice = Buffer.cbBuffer ;

   //
   // prime the device 
   //

   waveFillBuffer( &waveCache, TRUE ) ;

   waveCache.DataMark.EventData.EventHandle.ulReserved = 0 ;
   waveCache.DataMark.EventData.EventHandle.hEvent = 
      CreateEvent( NULL,     // no security
                   FALSE,    // auto-reset
                   FALSE,    // initially not-signalled
                   NULL ) ;  // no name

   waveCache.DataMark.EventData.fulNotificationType = KSEVENTF_SYNCHANDLE ;                
   waveCache.DataMark.Interval = 32 ;
   waveCache.DataMark.fulFlags = KSEVENT_DATA_MARKF_FILETIME ;

   Event.guidSet = KSEVENTSETID_Data ;
   Event.id = KSEVENT_DATA_INTERVAL_MARK ;

   WvControl( waveCache.hDev, 
              (DWORD) IOCTL_KS_ENABLE_EVENT,
              &Event,
              sizeof( KSEVENT ),
              &waveCache.DataMark,
              sizeof( KSEVENT_DATA_MARK ),
              &cbReturned ) ;

   hThread =
      CreateThread( NULL,                 // no security
                    0,                    // default stack
                    (PTHREAD_START_ROUTINE) ServiceThread,
                    (PVOID) &waveCache,   // parameter
                    0,                    // default create flags
                    &dwThreadId ) ;       // container for thread id

   if (NULL == hThread)
   {
      printf( "ERROR: failed to create thread\n" ) ;
      return ;
   }

   printf( "press any key to stop playback..." ) ;

   WvSetState( waveCache.hDev, KSSTATE_RUN ) ;
   waveCache.fRunning = TRUE ;

   //
   //  Loop 'til we're done, filling up our buffer, as necessary.
   //

   ulLastPos = 0 ;
   ulDeltaMax = 0 ;
   ulDeltaMin = (ULONG) -1 ;
   while (waveCache.fRunning && !_kbhit())
   {
      ULONG ulPos ;

      ulDelta = ulLastPos ;
      ulLastPos = waveGetPosition( &waveCache ) ;
      if (ulDelta = ulLastPos - ulDelta)
      {
         ulDeltaMax = max( ulDelta, ulDeltaMax ) ;
         ulDeltaMin = min( ulDelta, ulDeltaMin ) ;
      }
   }

   if (_kbhit ())
   {
      _getch ();
       WvSetState( waveCache.hDev, KSSTATE_PAUSE ) ;
   }

   printf( "\n" );

   WvSetState( waveCache.hDev, KSSTATE_STOP ) ;

   WvControl( waveCache.hDev, 
              (DWORD) IOCTL_KS_DISABLE_EVENT,
              &waveCache.DataMark,
              sizeof( KSEVENT_DATA_MARK ),
              NULL,
              0,
              &cbReturned ) ;

   hDevice = NULL ;
   hDevice = 
      (HANDLE) InterlockedExchange( (PLONG) &waveCache.hDev, (LONG) hDevice ) ;
   CloseHandle( hDevice ) ;

   SetEvent( waveCache.DataMark.EventData.EventHandle.hEvent ) ;

   if (hThread)
   {
      WaitForSingleObject( hThread, INFINITE ) ;
      CloseHandle( hThread ) ;
   }

   CloseHandle( waveCache.DataMark.EventData.EventHandle.hEvent ) ;
   CloseHandle( hf ) ;

   waveDestroyCache( &waveCache ) ;

   printf( "position delta max: %lu\n", ulDeltaMax ) ;
   printf( "position delta min: %lu\n", ulDeltaMin ) ;
}

BOOL waveCreateCache
(
   HANDLE             hf,
   PWAVECACHE         pCache,
   BYTE               bSilence
)
{
   ULONG  cbFileLow, cbFileHigh, cbPositionLow ;

   pCache -> bSilence = bSilence ;
   cbFileLow = GetFileSize( hf, &cbFileHigh ) ;
   if (NULL == 
          (pCache -> hfm = 
              CreateFileMapping( hf, NULL, PAGE_READONLY,
                                 cbFileHigh, cbFileLow, NULL )))
      return FALSE ;

   // extremely uninteligent for now, map the entire buffer and hope
   // it's not a REALLY BIG .WAV.

   if (NULL ==
          (pCache -> pCacheBuffer = 
              MapViewOfFile( pCache -> hfm, FILE_MAP_READ, 
                             0, 0, cbFileLow )))
   {
      CloseHandle( pCache -> hfm ) ;
      return FALSE ;
   }

   pCache -> cbCache = cbFileLow ;

   // get current file position (skip WAVHDR stuff)
   
   cbPositionLow = SetFilePointer( hf, 0, NULL, FILE_CURRENT ) ;
   pCache -> ulCachePosition = cbPositionLow ;

   return TRUE ;
}

VOID waveDestroyCache( PWAVECACHE pCache )
{
   if (pCache -> pCacheBuffer)
   {
      UnmapViewOfFile( pCache -> pCacheBuffer ) ;
      pCache -> pCacheBuffer = NULL ;
      CloseHandle( pCache -> hfm ) ;
   }
}

VOID waveFillSilence
(
   HANDLE      hDevice,
   ULONG       cbSilence,
   ULONG       ulSilencePos,
   BYTE        bSilence
)
{
   PVOID pvSilence ;
   ULONG cbReturned ;

   if (pvSilence = HeapAlloc( GetProcessHeap(), 0, cbSilence ))
   {
      FillMemory( pvSilence, cbSilence, bSilence ) ;
      WvWrite( hDevice,
               pvSilence,
               cbSilence,
               ulSilencePos,
               &cbReturned ) ;
      HeapFree( GetProcessHeap(), 0, pvSilence ) ;
   }
}

ULONG waveGetPosition
(
   PWAVECACHE  pCache
)
{
   ULONG cBuffers, ulBytes, ulCurrentPos ;
   
   do
   {
      cBuffers = pCache -> cBuffers ;
      WvGetPosition( pCache -> hDev, &ulCurrentPos ) ;
      ulBytes = cBuffers * pCache -> cbDevice + ulCurrentPos ;
   }
   while (cBuffers != pCache -> cBuffers) ;

   if (ulBytes < pCache -> ulLastReportedPosition)
      ulBytes += pCache -> cbDevice ;

   if (ulBytes > pCache -> cbTotal)
      ulBytes = pCache -> cbTotal ;

   pCache -> ulLastReportedPosition = ulBytes ;

   return ulBytes ;
}

VOID waveFillBuffer
(
   PWAVECACHE  pCache,
   BOOL        fPrime
)
{
   BOOL        fResult ;
   ULONG       cbDevice, cbInCache, cbReturned, cbSilence,
               ulCurrentDevicePosition ;

   cbSilence = 0;

   // need to watch roll-over

   if (fPrime)
   {
      cbDevice = pCache -> cbDevice ;
      pCache -> ulLastDevicePosition = 0 ;
      ulCurrentDevicePosition = 0 ;
   }
   else
   {
      WvGetPosition( pCache -> hDev, &ulCurrentDevicePosition ) ;
      if ((pCache -> fEOF) &&
          (ulCurrentDevicePosition >= pCache -> ulEndDevicePosition))
      {
         WvSetState( pCache -> hDev, KSSTATE_PAUSE ) ;
         pCache -> fRunning = FALSE ;
         return ;
      }

      if (pCache -> ulLastDevicePosition < ulCurrentDevicePosition)
         cbDevice = ulCurrentDevicePosition - pCache -> ulLastDevicePosition ;
      else
      {
         InterlockedIncrement( &pCache -> cBuffers ) ;
         cbDevice =
            pCache -> cbDevice -
               pCache -> ulLastDevicePosition +
                  ulCurrentDevicePosition ;
      }
   }

   cbInCache = pCache -> cbCache - pCache -> ulCachePosition ;

   if (cbDevice > cbInCache)
   {
      cbSilence        = cbDevice - cbInCache ;
      cbDevice         = cbInCache  ;
   }

   if (cbDevice)
   {
      ULONG  ulBufferPos, cbBuffer, cbWrap ;

      ulBufferPos = pCache -> ulLastDevicePosition ;
      cbBuffer = cbDevice ;
      cbWrap = 0 ;
      if (pCache -> ulLastDevicePosition + cbDevice > pCache -> cbDevice)
      {
         cbBuffer = pCache -> cbDevice - pCache -> ulLastDevicePosition ;
         cbWrap = cbDevice - cbBuffer ;
      }

      WvWrite( pCache -> hDev, 
               pCache -> pCacheBuffer + pCache -> ulCachePosition,
               cbBuffer,
               ulBufferPos,
               &cbReturned ) ;

      pCache -> ulCachePosition += cbBuffer ;

      if (cbWrap)
      {
          WvWrite( pCache -> hDev,
                   pCache -> pCacheBuffer + pCache -> ulCachePosition,
                   cbWrap,
                   0,
                   &cbReturned ) ;
         pCache -> ulCachePosition += cbWrap ;
      }
   }
//   printf( "copied %d bytes to device\n", cbDevice ) ;
   pCache -> cbTotal += cbDevice ;

   if (cbSilence)
   {
      ULONG  cbBuffer, cbWrap, ulSilencePos ;

      ulSilencePos = pCache -> ulLastDevicePosition + cbDevice ;
      if (ulSilencePos > pCache -> cbDevice)
         ulSilencePos -= pCache -> cbDevice ;

      cbBuffer = cbSilence ;
      cbWrap = 0 ;
      if (ulSilencePos + cbSilence > pCache -> cbDevice)
      {
         cbBuffer = pCache -> cbDevice - ulSilencePos ;
         cbWrap = cbSilence - cbBuffer ;
      }

      waveFillSilence( pCache -> hDev, 
                       cbBuffer, 
                       ulSilencePos, 
                       pCache -> bSilence ) ;

      if (cbWrap)
         waveFillSilence( pCache -> hDev,
                          cbWrap,
                          0, 
                          pCache -> bSilence ) ;

//      printf( "filled %d bytes of silence\n", cbSilence ) ;
   }

   pCache -> ulLastDevicePosition = ulCurrentDevicePosition ;

   // When first hitting EOF, mark the ending position...

   if ((pCache -> ulCachePosition == pCache -> cbCache) &&
       (!pCache -> fEOF)) 
   {
      pCache -> fEOF = TRUE ;
      pCache -> ulEndDevicePosition = 
         ulCurrentDevicePosition + cbDevice ;
      if (pCache -> ulEndDevicePosition > pCache -> cbDevice)
         pCache -> ulEndDevicePosition -= pCache -> cbDevice ;
//      printf( "EOF: position %d\n", pCache -> ulEndDevicePosition ) ;
   }
} 

HANDLE waveOpenFile
(
   PSTR                        pszFileName,
   PKSDATAFORMAT_DIGITAL_AUDIO AudioFormat
)
{
   HANDLE       hf ;
   WORD         wBits ;
   ULONG        cbRiffSize, cSamples, ulTemp, ulTemp2, ulWordAlign ;
   WAVEFORMAT   wf ; 

   hf = CreateFile( pszFileName, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    NULL ) ;
   if (hf == INVALID_HANDLE_VALUE)
      return NULL ;

   //
   //  Make sure that we have a RIFF chunk - read in four bytes
   //

   if (waveReadGetDWord( hf ) != FOURCC_RIFF)
      goto wOF_ErrExit;

   //
   //  Find out how big it is.
   //

   cbRiffSize = waveReadGetDWord( hf ) ;
   cbRiffSize += (cbRiffSize & 0x01) ;  // word align

   //
   //  Make sure it's a wave file
   //

   if (waveReadGetDWord(hf) != FOURCC_WAVE)
      goto wOF_ErrExit;

   cbRiffSize -= 4 ;

   //
   //  Keep reading chunks until we have a FOURCC_FMT
   //

   while (TRUE)
   {
      if (waveReadGetDWord(hf) == FOURCC_FMT)
      {
         // Found it

         cbRiffSize -= 4 ;
         break ;
      }

      // See how big this tag is so we can skip it.

      ulTemp = waveReadGetDWord( hf ) ;
      if (ulTemp)
         goto wOF_ErrExit;

      ulWordAlign = ulTemp + (ulTemp & 0x01) ;

      // Skip it

      ulTemp2 = waveReadSkipSpace( hf, ulWordAlign ) ;
      if (ulWordAlign != ulTemp2)
         goto wOF_ErrExit;

      // Adjust size

      ulTemp += 8 ;    // for two DWORDS read in
      ulWordAlign += 8 ;
      if (ulWordAlign > cbRiffSize)
         goto wOF_ErrExit;
      cbRiffSize -= ulWordAlign ;
   }

   //
   //  Now that we have a format tag, find out how big it
   //  is and load the header.
   //

   ulTemp = waveReadGetDWord( hf ) ;
   ulWordAlign = ulTemp + (ulTemp & 0x01);

   if ((ulTemp < sizeof( WAVEFORMAT )) || (ulTemp > cbRiffSize))
      goto wOF_ErrExit;

   ReadFile( hf, &wf, sizeof( WAVEFORMAT ), &ulTemp2, NULL ) ;
   if (ulTemp2 != sizeof( WAVEFORMAT ))
      goto wOF_ErrExit;

   // How much space left

   ulTemp -= ulTemp2 ;
   ulWordAlign -= ulTemp2 ;

   // Verify that we can handle this format

   switch (wf.wFormatTag)
   {
      case WAVE_FORMAT_PCM:
         if (ulTemp < 2)
            goto wOF_ErrExit;

         wBits = waveReadGetWord( hf ) ;
         ulTemp -= 2 ;
         ulWordAlign -= 2 ;
         break ;

      default:
         printf ("wave format unsupported (probably a compressed WAV).\n");
         goto wOF_ErrExit;
   }

   //
   //  Copy format information
   //

   AudioFormat -> DataFormat.guidMajorFormat = KSDATAFORMAT_TYPE_DIGITAL_AUDIO ;
   AudioFormat -> DataFormat.guidSubFormat = GUID_NULL ;
   AudioFormat -> DataFormat.cbFormat = sizeof( KSDATAFORMAT_DIGITAL_AUDIO ) ;
   AudioFormat -> idFormat = wf.wFormatTag ;
   AudioFormat -> cChannels = wf.nChannels ;
   AudioFormat -> ulSamplingFrequency = wf.nSamplesPerSec ;
   AudioFormat -> cbFramingAlignment = wf.nBlockAlign ;
   AudioFormat -> cBitsPerSample = wBits ;

   printf( "wave format: %dkHz ", AudioFormat -> ulSamplingFrequency/1000 ) ;
   printf( "%d bit ", AudioFormat -> cBitsPerSample ) ;
   printf( "%s\n", (AudioFormat -> cChannels == 2) ? "stereo" : "mono" ) ;

   // Skip any extra space

   if (ulWordAlign)
      waveReadSkipSpace( hf, ulWordAlign ) ;
   cbRiffSize -= ulWordAlign ;

   // Loop until data

   while (TRUE)
   {
      if (waveReadGetDWord( hf ) == FOURCC_DATA)
      {
         // Found it.
         cbRiffSize -= 4 ;
         break ;
      }

      // See how big this tag is so we can skip it

      ulTemp = waveReadGetDWord(hf);
      ulWordAlign = ulTemp + (ulTemp & 0x01) ;

      // Skip it

      ulTemp2 = waveReadSkipSpace( hf, ulWordAlign ) ;
      if (ulWordAlign != ulTemp2)
         goto wOF_ErrExit;

      // Adjust size

      ulTemp += 8 ;    // for two DWORDS read
      ulWordAlign += 8 ;
      if (ulWordAlign > cbRiffSize)
         goto wOF_ErrExit;
      cbRiffSize -= ulWordAlign ;
   }

   //
   //  Return what we need...
   //

   printf ("wave size: %d\n", waveReadGetDWord( hf ) ) ;
   return hf;

wOF_ErrExit:
   CloseHandle( hf ) ;
   return NULL;

} // end of waveOpenFile()

WORD waveReadGetWord( HANDLE hf )
{
   BYTE   ch0, ch1 ;
   ULONG  cbRead ;

   ReadFile( hf, &ch0, 1, &cbRead, NULL ) ;
   ReadFile( hf, &ch1, 1, &cbRead, NULL ) ;
   return ( (WORD) mmioFOURCC( ch0, ch1, 0, 0 ) ) ;

} // end of waveReadGetWord()

DWORD waveReadGetDWord( HANDLE hf )
{
   BYTE ch0, ch1, ch2, ch3 ;
   ULONG cbRead ;

   ReadFile( hf, &ch0, 1, &cbRead, NULL ) ;
   ReadFile( hf, &ch1, 1, &cbRead, NULL ) ;
   ReadFile( hf, &ch2, 1, &cbRead, NULL ) ;
   ReadFile( hf, &ch3, 1, &cbRead, NULL ) ;
   return ((DWORD) mmioFOURCC( (BYTE) ch0, (BYTE) ch1, 
                               (BYTE) ch2, (BYTE) ch3) ) ;

} 

DWORD waveReadSkipSpace
(
   HANDLE hf,
   DWORD cbSkip
)
{
   if (!SetFilePointer( hf, cbSkip, NULL, FILE_CURRENT ))
      return cbSkip ;
   else
      return 0 ;
} 

int _cdecl main
(
   int argc,
   char *argv[],
   char *envp[]
)
{
   char             szFileName[ 255 ],  
                    szguidWv[ 40 ], 
                    szDeviceName[ 128 ] ;
   ULONG            cbReturned ;

   // Play a wave

   if (argc < 2)
   {
      // No command-line arguments

      printf( "\nEnter .WAV filename: " ) ;
      scanf( "%s", szFileName ) ;
   }
   else
   {
      // Check first argument

      if (*(argv[ 1 ]) != '/' && *(argv[ 1 ]) != '-')
      {
         // Assume argv[ 1 ] is a file name

         strcpy( szFileName, argv[1] ) ;
      }
      else
         exit( 0 ) ;
   }

   if (szFileName[0])
      waveOutFile( szFileName ) ;

   return 0 ;

} // end of main()

//---------------------------------------------------------------------------
//  End of File: play.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testlib\binres.c ===
//--------------------------------------------------------------------------;
//
//  File: Binres.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      This creates a binary that prepares arbitrary files as resources
//      for Windows binaries.
//
//  Contents:
//      parse_cmdline()
//      create_file()
//      main()
//
//  History:
//      04/10/94    Fwong       Created for binary resources.
//
//--------------------------------------------------------------------------;

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <fcntl.h>
#include <io.h>

//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define BYTE        unsigned char
#define STRING_SIZE 144
#define BUFFER_SIZE 2048
#define ERROR       1
#define NO_ERROR    0

//==========================================================================;
//
//                              Globals...
//
//==========================================================================;

char    szInputFile[STRING_SIZE];
char    szOutputFile[STRING_SIZE];


//--------------------------------------------------------------------------;
//
//  int parse_cmdline
//
//  Description:
//      Parses command line and fills in input and output file names.
//
//  Arguments:
//      char *pszInputFile: Buffer for input file name.
//
//      char *pszOutputFile: Buffer for output file name.
//
//      char *pszArg1: First argument.
//
//      char *pszArg2: Second argument.
//
//  Return (int):
//      ERROR if error occurs, NO_ERROR otherwise.
//
//  History:
//      04/10/94    Fwong       Created for binary resources.
//
//--------------------------------------------------------------------------;

int parse_cmdline
(
    char    *pszInputFile,
    char    *pszOutputFile,
    char    *pszArg1,
    char    *pszArg2
)
{
    char    szScrap[STRING_SIZE];

    //
    //  Setting both filenames to NULL strings.
    //

    pszInputFile[0] = 0;
    pszOutputFile[0] = 0;

    //
    //  Checking first argument...
    //

    strcpy(szScrap,pszArg1);

    //
    //  ASCII trick, allows '/' and '-' to be synonymous
    //

    szScrap[0] = (szScrap[0]|(0x02));
    strlwr(szScrap);

    if(0 == strncmp(szScrap,"/out:",5))
    {
        strcpy(pszOutputFile,((char*)(&szScrap[5])));
    }

    if(0 == strncmp(szScrap,"/in:",4))
    {
        strcpy(pszInputFile,((char*)(&szScrap[4])));
    }

    //
    //  Checking second argument...
    //

    strcpy(szScrap,pszArg2);

    //
    //  ASCII trick, allows '/' and '-' to be synonymous
    //

    szScrap[0] = (szScrap[0]|(0x02));
    strlwr(szScrap);

    if(0 == strncmp(szScrap,"/out:",5))
    {
        strcpy(pszOutputFile,((char*)(&szScrap[5])));
    }

    if(0 == strncmp(szScrap,"/in:",4))
    {
        strcpy(pszInputFile,((char*)(&szScrap[4])));
    }

    //
    //  Did we miss one?
    //

    if(0 == pszInputFile[0])
    {
        return ERROR;
    }

    if(0 == pszOutputFile[0])
    {
        return ERROR;
    }

    //
    //  No error.
    //

    return NO_ERROR;
} // parse_cmdline()


//--------------------------------------------------------------------------;
//
//  int create_file
//
//  Description:
//      Given input and output files names, creates the output file.
//      This function does the *real* work of the program.
//
//  Arguments:
//      char *pszInputFile: Input file name.
//
//      char *pszOutputFile: Output file name.
//
//  Return (int):
//      ERROR if error occurs, NO_ERROR otherwise.
//
//  History:
//      04/10/94    Fwong       Created for binary resources.
//
//--------------------------------------------------------------------------;

int create_file
(
    char    *pszInputFile,
    char    *pszOutputFile
)
{
    FILE    *pIFile;
    FILE    *pOFile;
    size_t  cbCount;
    long    cbSize;
    long    cbWritten;
    BYTE    *pBuffer;

    //
    //  Allocating transfer buffer...
    //

    pBuffer = (BYTE*)malloc(BUFFER_SIZE);

    if(NULL == pBuffer)
    {
        return ERROR;
    }
    
    //
    //  Opening input file...
    //

    pIFile = fopen(pszInputFile,"rb");

    if(NULL == pIFile)
    {
        free(pBuffer);
        return ERROR;
    }

    //
    //  Getting size...
    //

    cbSize = filelength(fileno(pIFile));

    if((-1) == cbSize)
    {
        fclose(pIFile);
        free(pBuffer);

        return ERROR;
    }

    if(0 != fseek(pIFile,0,SEEK_SET))
    {
        fclose(pIFile);
        free(pBuffer);

        return ERROR;
    }

    //
    //  Opening output file...
    //

    pOFile = fopen(pszOutputFile,"wb");

    if(NULL == pOFile)
    {
        fclose(pIFile);
        free(pBuffer);

        return ERROR;
    }

    //
    //  First, let's write the size of file...
    //

    printf("File size (in bytes) of %s: %lu.\n",pszInputFile,cbSize);

    cbCount = fwrite(&cbSize,sizeof(cbSize),1,pOFile);

    if(1 != cbCount)
    {
        fclose(pOFile);
        fclose(pIFile);
        free(pBuffer);

        return ERROR;
    }

    //
    //  Next, let's write the actual data...
    //  Note: Counting that cbCount != 0
    //

    for(cbWritten=0;cbCount;)
    {
        //
        //  Reading data...
        //

        cbCount = fread(pBuffer,1,BUFFER_SIZE,pIFile);

        if(0 == cbCount)
        {
            //
            //  No more data?!
            //

            break;
        }

        //
        //  Writing data...
        //

        if(cbCount != fwrite(pBuffer,1,cbCount,pOFile))
        {
            fclose(pOFile);
            fclose(pIFile);
            free(pBuffer);

            return ERROR;
        }

        cbWritten += cbCount;
    }

    printf("Total bytes written to %s: %lu.\n",pszOutputFile,cbWritten);

    //
    //  Cleaning up...
    //

    fclose(pOFile);
    fclose(pIFile);
    free(pBuffer);

    return NO_ERROR;
} // create_file()


//--------------------------------------------------------------------------;
//
//  int main
//
//  Description:
//      Typical character based "main" function for C.
//
//  Arguments:
//      int argc: Number of command line arguments.
//
//      char *argv[]: Value of command line arguments.
//
//      char *envp[]: Value of enviroment variables.
//
//  Return (int):
//      ERROR if error occurs, NO_ERROR otherwise.
//
//  History:
//      04/10/94    Fwong       Created for binary resources.
//
//--------------------------------------------------------------------------;

int main
(
    int     argc,
    char    *argv[],
    char    *envp[]
)
{
    if(3 != argc)
    {
        //
        //  Incorrect number of parameters
        //

        printf("Usage: binres /in:InputFile /out:OutputFile");

        return ERROR;
    }

    if(0 != parse_cmdline(szInputFile,szOutputFile,argv[1],argv[2]))
    {
        //
        //  Something wrong with command line?
        //

        return ERROR;
    }

    if(0 != create_file(szInputFile,szOutputFile))
    {
        //
        //  Something wrong with one of the files?
        //

        return ERROR;
    }

    return NO_ERROR;
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testlib\resmgr.c ===
//--------------------------------------------------------------------------;
//
//  File: ResMgr.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      This library extracts a binary resources into memory or into a
//      file.
//
//  Contents:
//      ResourceToFile()
//      SizeofBinaryResource()
//      GetBinaryResource()
//
//  History:
//      04/11/94    Fwong       Created for easy storage of binaries.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef  WIN32
#include <windowsx.h>
#endif  //  WIN32
#include <mmsystem.h>
#include "ResMgr.h"

//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define  BUFFER_SIZE    2048


//--------------------------------------------------------------------------;
//
//  DWORD SizeofBinaryResource
//
//  Description:
//      Gets the size of a binary resource.
//
//  Arguments:
//      HINSTANCE hinst: HINSTANCE of application.
//
//      HRSRC hrsrc: HRSRC of resource.
//
//  Return (DWORD):
//      Size (in bytes) of binary resource, 0L if error.
//
//  History:
//      04/11/94    Fwong       Created for easy storage of binaries.
//
//--------------------------------------------------------------------------;

DWORD SizeofBinaryResource
(
    HINSTANCE   hinst,
    HRSRC       hrsrc
)
{
    HGLOBAL         hRes;
    LPDWORD         pdwSize;
    DWORD           cbSize;

    if(NULL == hrsrc)
    {
        return 0L;
    }

    hRes = LoadResource(hinst,hrsrc);

    if(NULL == hRes)
    {
        return 0L;
    }

    pdwSize = LockResource(hRes);

    if(NULL == pdwSize)
    {
        FreeResource(hRes);

        return 0L;
    }

    //
    //  Note: The first 4 bytes represent a DWORD of resource size.
    //

    cbSize = *pdwSize;

    UnlockResource(hRes);
    FreeResource(hRes);

    return cbSize;
} // SizeofBinaryResource()


//--------------------------------------------------------------------------;
//
//  BOOL ResourceToFile
//
//  Description:
//      Exacts a binary resource to a file.
//
//  Arguments:
//      HINSTANCE hinst: HINSTANCE of application.
//
//      HRSRC hrsrc: HRSRC of resource.
//
//      LPCSTR pszFileName: Buffer of destination file name.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      04/11/94    Fwong       Created for easy storage of binaries.
//
//--------------------------------------------------------------------------;

BOOL ResourceToFile
(
    HINSTANCE   hinst,
    HRSRC       hrsrc,
    LPCSTR      pszFileName
)
{
    HGLOBAL         hRes;
    LPSTR           pRes;
    OFSTRUCT        ofs;
    HFILE           hFile;
    UINT            cbData;
    DWORD           cbSize;
    DWORD           cbWritten;

    cbSize = SizeofBinaryResource(hinst,hrsrc);

    if(NULL == hrsrc)
    {
        return FALSE;
    }

    hRes = LoadResource(hinst,hrsrc);

    if(NULL == hRes)
    {
        return FALSE;
    }

    pRes = LockResource(hRes);

    if(NULL == pRes)
    {
        FreeResource(hRes);

        return FALSE;
    }

    //
    //  Incrementing past resource size...
    //

    pRes = &(pRes[sizeof(DWORD)]);

    //
    //  Doing file stuff...
    //

    hFile = OpenFile(pszFileName,&ofs,OF_CREATE|OF_WRITE);

    if(HFILE_ERROR == hFile)
    {
        UnlockResource(hRes);
        FreeResource(hRes);

        return FALSE;
    }

    //
    //  Actually writing file...
    //

    for(cbWritten = 0;cbSize != cbWritten;)
    {
        cbData = (UINT)(min(BUFFER_SIZE,(cbSize - cbWritten)));

        cbData = _lwrite(hFile,pRes,cbData);

        if(HFILE_ERROR == cbData)
        {
            _lclose(hFile);
            UnlockResource(hRes);
            FreeResource(hRes);

            return FALSE;
        }

        if(0 == cbData)
        {
            break;
        }

        pRes = &(pRes[cbData]);

        cbWritten += cbData;
    }

    _lclose(hFile);

    UnlockResource(hRes);
    FreeResource(hRes);

    return TRUE;
} // ResourceToFile()


//--------------------------------------------------------------------------;
//
//  BOOL GetBinaryResource
//
//  Description:
//      Stores binary resource into a buffer.
//
//  Arguments:
//      HINSTANCE hinst: HINSTANCE of application.
//
//      HRSRC hrsrc: HRSRC of resource.
//
//      LPVOID pBuffer: Buffer to store resource.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      04/11/94    Fwong       Created for easy storage of binaries.
//
//--------------------------------------------------------------------------;

BOOL GetBinaryResource
(
    HINSTANCE   hinst,
    HRSRC       hrsrc,
    LPVOID      pBuffer
)
{
    HGLOBAL         hRes;
    LPSTR           pRes;
    DWORD           cbSize;

    cbSize = SizeofBinaryResource(hinst,hrsrc);

#ifdef WIN32
    if(IsBadWritePtr(pBuffer,cbSize))
    {
        //
        //  Bad pointer...
        //

        return FALSE;
    }
#endif

    if(NULL == hrsrc)
    {
        return FALSE;
    }

    hRes = LoadResource(hinst,hrsrc);

    if(NULL == hRes)
    {
        return FALSE;
    }

    pRes = LockResource(hRes);

    if(NULL == pRes)
    {
        FreeResource(hRes);

        return FALSE;
    }

    //
    //  Incrementing past resource size...
    //

    pRes = &(pRes[sizeof(DWORD)]);

    //
    //  Copying from resource buffer to actual buffer...
    //

    hmemcpy(pBuffer,pRes,cbSize);

    UnlockResource(hRes);
    FreeResource(hRes);

    return TRUE;
} // GetBinaryResource()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\strmtest\strmtest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strmtest.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <devioctl.h>

#include <tchar.h>
#include <stdio.h>
#include <conio.h>
#include <malloc.h>

#include <setupapi.h>

#include <mmsystem.h>
#include <mmreg.h>
#include <ks.h>
#include <ksmedia.h>

#include <objbase.h>


#ifndef FILE_QUAD_ALIGNMENT
#define FILE_QUAD_ALIGNMENT             0x00000007
#endif // FILE_QUAD_ALIGNMENT

#define FOURCC_WAVE   mmioFOURCC('W', 'A', 'V', 'E')
#define FOURCC_FMT    mmioFOURCC('f','m','t',' ')
#define FOURCC_DATA   mmioFOURCC('d','a','t','a')

typedef struct {
    BOOL            InUse;
    BOOL            Last;
    HANDLE          hEvent;
    OVERLAPPED      Overlapped;
    KSSTREAM_HEADER StreamHeader;

} STREAM_FRAME, *PSTREAM_FRAME;

#define STREAM_FRAME_SIZE   5120
#define STREAM_USED_SIZE    4096
#define STREAM_FRAMES       4

BOOL
HandleControl(
    HANDLE   DeviceHandle,
    DWORD    IoControl,
    PVOID    InBuffer,
    ULONG    InSize,
    PVOID    OutBuffer,
    ULONG    OutSize,
    PULONG   BytesReturned
    )
{
    BOOL            IoResult;
    OVERLAPPED      Overlapped;

    RtlZeroMemory(&Overlapped, sizeof(OVERLAPPED));
    if (!(Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
        return FALSE;
    IoResult = DeviceIoControl(DeviceHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, BytesReturned, &Overlapped);
    if (!IoResult && (ERROR_IO_PENDING == GetLastError())) {
        WaitForSingleObject(Overlapped.hEvent, INFINITE);
        IoResult = TRUE;
    }
    CloseHandle(Overlapped.hEvent);
    return IoResult;
}

HANDLE
ConnectStreamOut(
    HANDLE FilterHandle,
    ULONG PinId,
    PKSDATAFORMAT_WAVEFORMATEX AudioFormat
    )
{
    UCHAR           ConnectBuffer[ sizeof( KSPIN_CONNECT ) +
                                   sizeof( KSDATAFORMAT_WAVEFORMATEX )];
    PKSPIN_CONNECT  Connect;
    HANDLE          PinHandle;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->Interface.Set = KSINTERFACESETID_Standard;
    Connect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    Connect->Interface.Flags = 0;
    Connect->Medium.Set = KSMEDIUMSETID_Standard;
    Connect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    Connect->Medium.Flags = 0;
    Connect->PinId = PinId;
    Connect->PinToHandle = NULL;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
    *(PKSDATAFORMAT_WAVEFORMATEX)(Connect + 1) = *AudioFormat;

    if (KsCreatePin(FilterHandle, Connect, GENERIC_WRITE, &PinHandle))
        return NULL;
    return PinHandle;
}

VOID
PinSetState(
    HANDLE  PinHandle,
    KSSTATE DeviceState
    )
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    HandleControl( PinHandle, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &DeviceState, sizeof(DeviceState), &BytesReturned );
}

WORD waveReadGetWord( HANDLE hf )
{
   BYTE   ch0, ch1;
   ULONG  cbRead;

   ReadFile( hf, &ch0, 1, &cbRead, NULL );
   ReadFile( hf, &ch1, 1, &cbRead, NULL );
   return ( (WORD) mmioFOURCC( ch0, ch1, 0, 0 ) );

} // end of waveReadGetWord()

DWORD waveReadGetDWord( HANDLE hf )
{
   BYTE ch0, ch1, ch2, ch3;
   ULONG cbRead;

   ReadFile( hf, &ch0, 1, &cbRead, NULL );
   ReadFile( hf, &ch1, 1, &cbRead, NULL );
   ReadFile( hf, &ch2, 1, &cbRead, NULL );
   ReadFile( hf, &ch3, 1, &cbRead, NULL );
   return ((DWORD) mmioFOURCC( (BYTE) ch0, (BYTE) ch1,
                               (BYTE) ch2, (BYTE) ch3) );

}

DWORD waveReadSkipSpace(
    HANDLE hf,
    DWORD cbSkip
    )
{
   if (!SetFilePointer( hf, cbSkip, NULL, FILE_CURRENT ))
      return cbSkip;
   else
      return 0;
}

HANDLE waveOpenFile(
    PSTR pszFileName,
    PKSDATAFORMAT_WAVEFORMATEX AudioFormat
    )
{
   HANDLE       hf;
   WORD         wBits;
   ULONG        cbRiffSize, cSamples, ulTemp, ulTemp2, ulWordAlign;
   WAVEFORMATEX wf;

   hf = CreateFile( pszFileName, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    NULL );
   if (hf == INVALID_HANDLE_VALUE) {
      return hf;
   }

   //
   //  Make sure that we have a RIFF chunk - read in four bytes
   //

   if (waveReadGetDWord( hf ) != FOURCC_RIFF) {
      printf( "wavOpenFile error: FOURCC( RIFF ) expected.\n" );
      goto wOF_ErrExit;
   }

   //
   //  Find out how big it is.
   //

   cbRiffSize = waveReadGetDWord( hf );
   cbRiffSize += (cbRiffSize & 0x01);  // word align

   //
   //  Make sure it's a wave file
   //

   if (waveReadGetDWord(hf) != FOURCC_WAVE) {
      printf( "wavOpenFile error: FOURCC( WAVE ) expected.\n" );
      goto wOF_ErrExit;
   }

   cbRiffSize -= 4;

   //
   //  Keep reading chunks until we have a FOURCC_FMT
   //

   while (TRUE) {
      if (waveReadGetDWord(hf) == FOURCC_FMT) {
         // Found it

         cbRiffSize -= 4;
         break;
      }

      // See how big this tag is so we can skip it.

      ulTemp = waveReadGetDWord( hf );
      if (ulTemp) {
         goto wOF_ErrExit;
      }

      ulWordAlign = ulTemp + (ulTemp & 0x01);

      // Skip it

      ulTemp2 = waveReadSkipSpace( hf, ulWordAlign );
      if (ulWordAlign != ulTemp2) {
         goto wOF_ErrExit;
      }

      // Adjust size

      ulTemp += 8;    // for two DWORDS read in
      ulWordAlign += 8;
      if (ulWordAlign > cbRiffSize) {
         goto wOF_ErrExit;
      }
      cbRiffSize -= ulWordAlign;
   }

   //
   //  Now that we have a format tag, find out how big it
   //  is and load the header.
   //

   ulTemp = waveReadGetDWord( hf );
   ulWordAlign = ulTemp + (ulTemp & 0x01);

   if ((ulTemp < sizeof( WAVEFORMAT )) || (ulTemp > cbRiffSize)) {
      goto wOF_ErrExit;
   }

   ReadFile( hf, &wf, ulTemp, &ulTemp2, NULL );
   if (ulTemp2 != ulTemp) {
      goto wOF_ErrExit;
   }

   // How much space left

   ulTemp -= ulTemp2;
   ulWordAlign -= ulTemp2;

   // Verify that we can handle this format

   switch (wf.wFormatTag) {

   case WAVE_FORMAT_PCM:
      break;

   default:
      printf ("wave format unsupported (probably a compressed WAV).\n");
      goto wOF_ErrExit;

   }

   //
   //  Copy format information
   //

   AudioFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
   AudioFormat->DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
   AudioFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
   AudioFormat->DataFormat.FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
   AudioFormat->DataFormat.Flags = 0;
   AudioFormat->WaveFormatEx = wf;

   printf( "wave format: %dHz ", AudioFormat->WaveFormatEx.nSamplesPerSec );
   printf( "%d bit ", AudioFormat->WaveFormatEx.wBitsPerSample );
   printf( "%s\n", (AudioFormat->WaveFormatEx.nChannels == 2) ? "stereo" : "mono" );

   // Skip any extra space

   if (ulWordAlign) {
      waveReadSkipSpace( hf, ulWordAlign );
   }
   cbRiffSize -= ulWordAlign;

   // Loop until data

   while (TRUE) {
      if (waveReadGetDWord( hf ) == FOURCC_DATA) {
         // Found it.
         cbRiffSize -= 4;
         break;
      }

      // See how big this tag is so we can skip it

      ulTemp = waveReadGetDWord(hf);
      ulWordAlign = ulTemp + (ulTemp & 0x01);

      // Skip it

      ulTemp2 = waveReadSkipSpace( hf, ulWordAlign );
      if (ulWordAlign != ulTemp2)
         goto wOF_ErrExit;

      // Adjust size

      ulTemp += 8;    // for two DWORDS read
      ulWordAlign += 8;
      if (ulWordAlign > cbRiffSize)
         goto wOF_ErrExit;
      cbRiffSize -= ulWordAlign;
   }

   //
   //  Return what we need...
   //

   printf ("wave size: %d\n", waveReadGetDWord( hf ) );
   return hf;

wOF_ErrExit:
   printf( "wavOpenFile error.\n" );
   CloseHandle( hf );
   return (HANDLE) -1;

} // end of waveOpenFile()

int
_cdecl
main(
    int argc,
    char* argv[],
    char* envp[]
    )
{
    int                         i;
    BOOL                        IoResult, Running, Reading;
    BYTE                        Storage[ 256 * sizeof( WCHAR ) +
                                         sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA ) ];
    HANDLE                      FilterHandle, FileHandle, PinHandle;
    HDEVINFO                    RendererSet;
    KSDATAFORMAT_WAVEFORMATEX   AudioFormat;
//    PSP_INTERFACE_DEVICE_DETAIL_DATA InterfaceDeviceDetails;
//    SP_INTERFACE_DEVICE_DATA    InterfaceDeviceData;
    STREAM_FRAME                Frames[ STREAM_FRAMES ];
    ULONG                       BytesReturned;


//    InterfaceDeviceDetails = (PSP_INTERFACE_DEVICE_DETAIL_DATA) Storage;

    if (argc < 2) {
        printf("%s <.WAV file>\n", argv[ 0 ] );
        return 0;
    }

#if 0
    RendererSet =
        SetupDiGetClassDevs(
            &KSCATEGORY_RENDER,
            NULL,
            NULL,
            DIGCF_PRESENT | DIGCF_INTERFACEDEVICE );

    if (!RendererSet) {
        printf( "error: no renderers present.\n" );
        return 0;
    }

    InterfaceDeviceData.cbSize = sizeof( SP_INTERFACE_DEVICE_DATA );
    if (!SetupDiEnumInterfaceDevice(
            RendererSet,
            NULL,                       // PSP_DEVINFO_DATA DevInfoData
            &KSCATEGORY_RENDER,
            0,                          // DWORD MemberIndex
            &InterfaceDeviceData )) {


        printf(
            "error: unable to retrieve information for renderer, %d.\n",
            GetLastError() );
        return 0;
    }


    InterfaceDeviceDetails->cbSize = sizeof( SP_INTERFACE_DEVICE_DETAIL_DATA );

    if (!SetupDiGetInterfaceDeviceDetail(
        RendererSet,
        &InterfaceDeviceData,
        InterfaceDeviceDetails,
        sizeof( Storage ),
        NULL,                           // PDWORD RequiredSize
        NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

        printf(
            "error: unable to retrieve device details for renderer, %d.\n",
            GetLastError() );
        return 0;
    }

    printf(
        "opening renderer: %s\n",
        InterfaceDeviceDetails->DevicePath );
#endif
    FilterHandle =
        CreateFile(
            "\\\\.\\PortClass0\\wave",
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL );

    if (FilterHandle == INVALID_HANDLE_VALUE) {
        printf(
            "failed to open device %s : (%x)\n",
            "\\\\.\\PortClass0\\Wave",
            GetLastError() );
        return 0;
    }

    FileHandle = waveOpenFile( argv[ 1 ], &AudioFormat );

    if (FileHandle == (HANDLE) -1) {
        printf( "failed to open %s\n", argv[ 1 ] );
    }

    if (NULL == (PinHandle = ConnectStreamOut( FilterHandle, 2, &AudioFormat ))) {
        printf( "failed to connect pin.\n" );
    }

    for (i = 0; i < STREAM_FRAMES; i++) {
        if (!(Frames[ i ].hEvent = CreateEvent(NULL, TRUE, FALSE, NULL))) {
            printf( "error: failed to create event handle\n" );
            exit( -1 );
        }

        Frames[ i ].InUse = FALSE;
        Frames[ i ].Last  = FALSE;
        Frames[ i ].StreamHeader.Data =
            HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, STREAM_FRAME_SIZE );
        Frames[ i ].StreamHeader.FrameExtent = STREAM_FRAME_SIZE;
        Frames[ i ].StreamHeader.DataUsed = STREAM_USED_SIZE;
        Frames[ i ].StreamHeader.OptionsFlags = 0;

        {
            // Insert an obnoxious tone into the buffer.
            PSHORT p = (PSHORT) Frames[ i ].StreamHeader.Data;
            ULONG count;
            for (count = STREAM_FRAME_SIZE / sizeof(SHORT); count--; p++)
            {
                *p = (count & 64) ? 32767 : -32768;
            }
        }
    }


    Running = FALSE;
    Reading = TRUE;
    i = 0;
    while (1) {
        if (Frames[ i ].InUse) {
            WaitForSingleObject(Frames[ i ].Overlapped.hEvent, INFINITE);
            printf("got back Frame %d\n", i );
        }

        if (Frames[ i ].Last)
        {
            printf( "last frame completed.\n" );
            break;
        }

        memset(Frames[i].StreamHeader.Data, 0, STREAM_USED_SIZE);

        if (Reading)
        {
            ULONG BytesRead;

            if (!ReadFile( FileHandle,
                           Frames[ i ].StreamHeader.Data,
                           STREAM_USED_SIZE,
                           &BytesRead,
                           NULL )) {

                 printf( "file read error.\n" );
                 exit( -1 );
            }

            if (BytesRead < STREAM_USED_SIZE)
            {
                printf( "file read completed.\n" );
                Frames[ i ].Last = TRUE;
                Reading = FALSE;
            }
        }

        Frames[ i ].StreamHeader.PresentationTime.Time = 0;
        Frames[ i ].StreamHeader.PresentationTime.Numerator = 1;
        Frames[ i ].StreamHeader.PresentationTime.Denominator = 1;
        RtlZeroMemory( &Frames[ i ].Overlapped, sizeof( OVERLAPPED ) );
        Frames[ i ].Overlapped.hEvent = Frames[ i ].hEvent;

        printf("Sending Frame %d\n", i );
        IoResult = DeviceIoControl( PinHandle,
                                    IOCTL_KS_WRITE_STREAM,
                                    NULL,
                                    0,
                                    &Frames[ i ].StreamHeader,
                                    sizeof( Frames[ i ].StreamHeader ),
                                    &BytesReturned,
                                    &Frames[ i ].Overlapped );

        if (!IoResult) {
            if (ERROR_IO_PENDING == GetLastError()) {
                Frames[ i ].InUse = TRUE;
           }
        } else {
            printf( "stream write error.\n" );
        }

        if (++i == STREAM_FRAMES) {
            //
            // This allows us to prime the device.
            //
            //
            if (!Running) {
                PinSetState( PinHandle, KSSTATE_RUN );
                Running = TRUE;
            }

            i = 0;
        }
    }

    PinSetState( PinHandle, KSSTATE_STOP );

#if 0
    //
    // Wait for I/O to complete.
    //

    if (!Running) {
        PinSetState( PinHandle, KSSTATE_RUN );
        Running = TRUE;
    }
#endif

    for (i = 0; i < STREAM_FRAMES; i++) {
        if (Frames[ i ].InUse) {
            printf("final wait on %d\n", i );
            WaitForSingleObject(Frames[ i ].Overlapped.hEvent, INFINITE);
            printf("final wait got back %d\n", i );
            Frames[ i ].InUse = FALSE;
        }
        HeapFree( GetProcessHeap(), 0, Frames[ i ].StreamHeader.Data );
        CloseHandle( Frames[ i ].hEvent );
    }

    CloseHandle( PinHandle );
    CloseHandle( FileHandle );
    CloseHandle( FilterHandle );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testlib\inistuff.c ===
//--------------------------------------------------------------------------;
//
//  File: IniStuff.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//      Set of functions to make dealing with .ini files a little easier.
//
//  Contents:
//      GetApplicationDir()
//      InitIniFile()
//      InitIniFile_FullPath()
//      EndIniFile()
//      GetRegInfo()
//      HexValue()
//      atoDW()
//      GetIniBinSize()
//      WriteIniString()
//      WriteIniDWORD()
//      WriteIniBin()
//      GetIniString()
//      GetIniDWORD()
//      GetIniBin()
//
//  History:
//      01/26/94    Fwong       Just trying to lend a hand.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include "IniMgr.h"
#ifdef   WIN32
#include <tchar.h>
#endif

#ifndef  WIN32
#define  GlobalHandleOfPtr(p)   (HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(p)))
#else
#define  GlobalHandleOfPtr(p)   (HGLOBAL)GlobalHandle(p)
#ifndef  lstrcpyn
#define  lstrcpyn               _tcsncpy
#endif  //  lstrncpy
#endif  //  WIN32

#define  SIZEOF(a)              (sizeof(a)/sizeof(a[0]))

#ifndef  TEXT
#define  TEXT(a)                (a)
#endif  //  TEXT

LPTSTR      pszAppIniFile   = NULL;
TCHAR       gszMmregIni[]   = TEXT("mmreg.ini");


//--------------------------------------------------------------------------;
//
//  void GetApplicationDir
//
//  Description:
//      Gets the directory of the application.
//
//  Arguments:
//      HINSTANCE hinst: Instance handle of .exe.
//
//      LPSTR pszPath: Buffer to store string in.
//
//      UINT uSize: Size of buffer in bytes.
//
//  Return (void):
//
//  History:
//      04/04/94    Fwong       To "Do the right thing."
//
//--------------------------------------------------------------------------;

void FNGLOBAL GetApplicationDir
(
    HINSTANCE   hinst,
    LPTSTR      pszPath,
    UINT        uSize
)
{
    int iCount;

    iCount = GetModuleFileName(hinst,pszPath,uSize);

    if(0 == iCount)
    {
        pszPath[0] = 0;
        return;
    }

    for(iCount--;iCount;iCount--)
    {
        if('\\' == pszPath[iCount])
        {
            pszPath[iCount] = 0;

            return;
        }
    }
} // GetApplicationDir()


//--------------------------------------------------------------------------;
//
//  BOOL InitIniFile
//
//  Description:
//      Sets the name of the file for .ini file API's
//
//  Arguments:
//      HINSTANCE hinst: HINSTANCE of application to get full path.
//
//      LPTSTR pszIniFileName: Name of file.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      01/26/94    Fwong       To generalize .ini API's
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL InitIniFile
(
    HINSTANCE   hinst,
    LPTSTR      pszIniFileName
)
{
    HGLOBAL hmem;
    TCHAR   szPath[MAXINISTR];
    DWORD   cbSize;

    if(NULL != pszAppIniFile)
    {
        hmem = GlobalHandleOfPtr(pszAppIniFile);

        GlobalUnlock(hmem);
        GlobalFree(hmem);

        pszAppIniFile = NULL;
    }

    GetApplicationDir(hinst,szPath,SIZEOF(szPath));
    
    //
    //  Note: Two additional one byte for '\0' and one for '\\'
    //

    cbSize = lstrlen(pszIniFileName) + lstrlen(szPath) + 2;

    hmem   = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == hmem)
    {
        return FALSE;
    }

    pszAppIniFile = GlobalLock(hmem);

    lstrcpy(pszAppIniFile,szPath);
    lstrcat(pszAppIniFile,TEXT("\\"));
    lstrcat(pszAppIniFile,pszIniFileName);

    return TRUE;
} // InitIniFile()


//--------------------------------------------------------------------------;
//
//  BOOL InitIniFile_FullPath
//
//  Description:
//      Sets the name of the file for .ini file API's
//
//  Arguments:
//      LPTSTR pszFullPath: Full pathed name of file.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      04/08/94    Fwong       To generalize .ini API's
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL InitIniFile_FullPath
(
    LPTSTR  pszFullPath
)
{
    HGLOBAL hmem;

    if(NULL != pszAppIniFile)
    {
        hmem = GlobalHandleOfPtr(pszAppIniFile);

        GlobalUnlock(hmem);
        GlobalFree(hmem);

        pszAppIniFile = NULL;
    }

    hmem   = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,lstrlen(pszFullPath)+1);

    if(NULL == hmem)
    {
        return FALSE;
    }

    pszAppIniFile = GlobalLock(hmem);

    lstrcpy(pszAppIniFile,pszFullPath);

    return TRUE;
} // InitIniFile_FullPath()


//--------------------------------------------------------------------------;
//
//  void EndIniFile
//
//  Description:
//      Frees memory allocated by InitIniFile()
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      01/26/94    Fwong       To generalize .ini API's
//
//--------------------------------------------------------------------------;

void FNGLOBAL EndIniFile
(
    void
)
{
    HGLOBAL hmem;

    if(NULL != pszAppIniFile)
    {
        hmem = GlobalHandleOfPtr(pszAppIniFile);

        GlobalUnlock(hmem);
        GlobalFree(hmem);

        pszAppIniFile = NULL;
    }

} // EndIniFile()


//--------------------------------------------------------------------------;
//
//  BOOL GetRegInfo
//
//  Description:
//      Gets Appropriate version information from MMREG.INI
//
//  Arguments:
//      DWORD dwEntry: Value of actual entry
//
//      LPCTSTR pszSection: Section to look under
//
//      LPTSTR pszName: Pointer to buffer to store name.  If NULL no attempt
//                      to copy will be made.
//
//      UINT cbName: Size of buffer (in bytes) of pszName.  If pszName is
//                   NULL, this is ignored.
//
//      LPTSTR pszDesc: Pointer to buffer for description.  If NULL no
//                      attempt to copy will be made.  If pszName is NULL,
//                      this parameter is ignored.
//
//      UINT cbDesc: Size of buffer (in bytes) of pszDesc.  If pszDesc is
//                   NULL, this is ignored.
//
//  Return (BOOL):
//      TRUE if value found, FALSE otherwise
//
//      pszName and pszDesc are return strings.
//
//  History:
//      03/25/93    Fwong       Created for checking Mid's and Pid's
//      08/10/93    Fwong       Updated to check current directory
//      01/30/94    Fwong       Added string sizes in parameters
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL GetRegInfo
(
    DWORD   dwEntry,
    LPCTSTR pszSection,
    LPTSTR  pszName,
    UINT    cbName,
    LPTSTR  pszDesc,
    UINT    cbDesc
)
{
    DWORD cbBytesCopied,i;
    TCHAR szIniFile[MAXINISTR];
    TCHAR szEntry[11];
    TCHAR szFullString[MAXINISTR];

    wsprintf(szEntry,TEXT("%lu"),dwEntry);

    //
    //  Getting full path...
    //

    lstrcpy(szIniFile,pszAppIniFile);

    //
    //  Looking for '\\'
    //

    for(i=lstrlen(szIniFile)-1;'\\' != szIniFile[i];i--);

    szIniFile[i+1] = 0;
    lstrcat(szIniFile,gszMmregIni);

    //
    //  Getting String
    //

    cbBytesCopied = GetPrivateProfileString(
        pszSection,
        szEntry,
        TEXT(""),
        szFullString,
        SIZEOF(szFullString),
        szIniFile);

    //
    //  Checking for No Entry
    //

    if(cbBytesCopied!=(DWORD)GetPrivateProfileString(
        pszSection,
        szEntry,
        TEXT("a"),
        szFullString,
        SIZEOF(szFullString),
        szIniFile))
    {
        //
        //  Not in application directory, trying Windows directory.
        //

        lstrcpy(szIniFile,gszMmregIni);

        cbBytesCopied = GetPrivateProfileString(
            pszSection,
            szEntry,
            TEXT(""),
            szFullString,
            SIZEOF(szFullString),
            szIniFile);

        if(cbBytesCopied!=(DWORD)GetPrivateProfileString(
            pszSection,
            szEntry,
            TEXT("a"),
            szFullString,
            SIZEOF(szFullString),
            szIniFile))
        {
            return (FALSE);
        }
    }

    if(NULL == pszName)
    {
        //
        //  No return string just verifying that it exists.
        //

        return (TRUE);
    }

    //
    //  Looking for comma
    //

    for(i=0;;i++)
    {

        //
        //  If no comma is found szDesc is NULL string and
        //      szName is szFullString
        //

        if(i==cbBytesCopied)
        {
            if(NULL != pszDesc)
            {
                pszDesc[0]=0;
            }
            lstrcpyn(pszName,szFullString,cbName);
            return (TRUE);
        }
        else
        {
            //
            //  Stop Searching if comma is found
            //

            if(szFullString[i]==',')
                break;
        }
    }

    //
    //  Copy up to comma [non-inclusive]
    //

    szFullString[i++]=0;
    lstrcpyn(pszName,szFullString,cbName);

    if(NULL == pszDesc)
    {
        //
        //  No need to return pszDesc.
        //

        return (TRUE);
    }

    for(;;i++)
    {
        TCHAR   c=szFullString[i];

        if(!c)
        {
            pszDesc[0]=0;
            return(TRUE);
        }
        else
        {
            if((c!=' ')&&(c!='\t'))
            {
                break;
            }
        }
    }

    //
    //  Copying remainder of string
    //

    lstrcpyn(pszDesc,(LPTSTR)&(szFullString[i]),cbDesc);

    return (TRUE);
} // GetRegInfo()


//--------------------------------------------------------------------------;
//
//  DWORD HexValue
//
//  Description:
//      Returns the hexvalue of a particular hex digit.
//
//  Arguments:
//      TCHAR chDigit: Hex digit in question.
//
//  Return (DWORD):
//      The actual hex value, OR 16 if not valid digit.
//
//  History:
//      11/24/93    Fwong       For other stuff to work.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL HexValue
(
    TCHAR   chDigit
)
{
    if(('0' <= chDigit) && ('9' >= chDigit))
    {
        return ((DWORD)(chDigit - '0'));
    }

    if(('a' <= chDigit) && ('f' >= chDigit))
    {
        return ((DWORD)(chDigit - 'a' + 10));
    }

    if(('A' <= chDigit) && ('F' >= chDigit))
    {
        return ((DWORD)(chDigit - 'A' + 10));
    }

    return (16);
} // HexValue()


//--------------------------------------------------------------------------;
//
//  DWORD atoDW
//
//  Description:
//      Given a string gives the numerical value.
//
//  Arguments:
//      LPCSTR pszNumber: Pointer to string.
//
//      DWORD dwDefault: Default value if error occurs.
//
//  Return (DWORD):
//      Value of integer in string, or dwDefault if error occurs.
//
//  History:
//      08/23/94    Fwong       Expanding GetIniDWORD
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL atoDW
(
    LPCTSTR pszNumber,
    DWORD   dwDefault
)
{
    DWORD   dwDigit;
    DWORD   dwReturn;
    UINT    uBase = 16;
    UINT    u     = 2;

    if(('0' != pszNumber[0]) || ('x' != pszNumber[1]))
    {
        if(10 <= HexValue(pszNumber[0]))
        {
            return dwDefault;
        }

        //
        //  Note:
        //      uBase = the base (10 for decimal, 16 for hex).
        //      u     = string offset to start decoding.
        //

        uBase = 10;
        u     = 0;
    }

    for(dwReturn = 0L;u <= 9;u++)
    {
        dwDigit = HexValue(pszNumber[u]);

        if(uBase <= dwDigit)
        {
            //
            //  Error!!
            //

            break;
        }

        dwDigit  = uBase*dwReturn + dwDigit;

        if(dwReturn != (dwDigit/uBase))
        {
            //
            //  OVERFLOWED!!  Returning default.
            //

            return dwDefault;
        }

        dwReturn = dwDigit;
    }

    return dwReturn;
} // atoDW()


//--------------------------------------------------------------------------;
//
//  DWORD GetIniBinSize
//
//  Description:
//      Gets the size of a binary in the .ini file.
//
//  Arguments:
//      LPCTSTR pszSection:  Section for binary.
//
//      LPCTSTR pszEntry:  Name of binary.
//
//  Return (DWORD):
//      Size (in bytes) of binary, or 0 if not found.
//
//  History:
//      01/07/94    Fwong       Another thingy for binary stuff...
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL GetIniBinSize
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry
)
{
    TCHAR   szScrap[MAXINISTR];

    if(NULL == pszAppIniFile)
    {
        return 0L;
    }

    wsprintf(szScrap,TEXT("%s.size"),pszEntry);
    return GetIniDWORD(pszSection,szScrap,0);
} // GetIniBinSize()


//--------------------------------------------------------------------------;
//
//  BOOL WriteIniString
//
//  Description:
//      Writes a string into the .ini file for the application.
//
//  Arguments:
//      LPCTSTR pszSection: Name of Section.
//
//      LPCTSTR pszEntry: Name of Entry.
//
//      LPCTSTR pszString: String to write.
//
//  Return (BOOL):
//      Return value from WritePrivateProfileString().
//
//  History:
//      11/24/93    Fwong       Adding .ini file support.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL WriteIniString
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPCTSTR pszString
)
{
    if(NULL == pszAppIniFile)
    {
        return FALSE;
    }

    return WritePrivateProfileString(
        pszSection,
        pszEntry,
        pszString,
        pszAppIniFile);

} // WriteIniString()


//--------------------------------------------------------------------------;
//
//  BOOL WriteIniDWORD
//
//  Description:
//      Writes a DWORD to the .ini file for the app.
//
//  Arguments:
//      LPCTSTR pszSection: Name of section.
//
//      LPCTSTR pszEntry: Entry of section.
//
//      DWORD dwValue: Value to write.
//
//  Return (BOOL):
//      Return value from WriteIniString();
//
//  History:
//      11/24/93    Fwong
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL WriteIniDWORD
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    DWORD   dwValue
)
{
    TCHAR   szValue[12];

    if(NULL == pszAppIniFile)
    {
        return FALSE;
    }

    wsprintf(szValue,TEXT("0x%08lx"),dwValue);

    return WriteIniString(pszSection,pszEntry,szValue);
} // WriteIniDWORD()


//--------------------------------------------------------------------------;
//
//  void WriteIniBin
//
//  Description:
//      Writes binary information to the .ini file.
//
//  Arguments:
//      LPCTSTR pszSection: Section name.
//
//      LPCTSTR pszEntry: Entry name.
//
//      LPVOID pvoid: Buffer to write.
//
//      DWORD cbSize: Size of buffer in bytes.
//
//  Return (void):
//
//  History:
//      01/07/94    Fwong       Yet another random thing.
//
//--------------------------------------------------------------------------;

void FNGLOBAL WriteIniBin
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPVOID  pvoid,
    DWORD   cbSize
)
{
    TCHAR   szEntry[MAXINISTR];
    TCHAR   szScrap[MAXINISTR];
    LPBYTE  pByte = pvoid;
    LPTSTR  pszMiddle;
    UINT    u;
    DWORD   dw;

    if(NULL == pszAppIniFile)
    {
        return;
    }

    //
    //  Clearing previous entry...
    //

    dw = GetIniBinSize(pszSection,pszEntry);

    dw = (dw / LINE_LIMIT) + ((dw % LINE_LIMIT)?1:0);

    for (;dw;dw--)
    {
        wsprintf(szEntry,TEXT("%s.%03lu"),pszEntry,dw-1);
        WriteIniString(pszSection,szEntry,NULL);
    }

    //
    //  Writing new entry...
    //

    wsprintf(szEntry,TEXT("%s.size"),pszEntry);
    WriteIniDWORD(pszSection,szEntry,cbSize);

    for (dw=0,u=0;dw < cbSize;u++,dw++)
    {
        pszMiddle = &(szScrap[0]);

        //
        //  Doing individual lines...
        //

        for (;dw < cbSize;dw++)
        {
            wsprintf(pszMiddle,TEXT("%02x"),pByte[0]);
            pszMiddle += 2;
            pByte++;

            if((LINE_LIMIT-1)==(dw % LINE_LIMIT))
            {
                //
                //  Is it time for next line?!
                //

                break;
            }
        }

        wsprintf(szEntry,TEXT("%s.%03u"),pszEntry,u);

        WriteIniString(pszSection,szEntry,szScrap);
    }
} // WriteIniBin()


//--------------------------------------------------------------------------;
//
//  int GetIniString
//
//  Description:
//      Similar to GetProfileString, but for the .ini file for this app.
//
//  Arguments:
//      LPCTSTR pszSection: Section name.
//
//      LPCTSTR pszEntry: Entry name.
//
//      LPTSTR pszBuffer: Return buffer.
//
//      int cchReturnBuffer: Size of return buffer.
//
//  Return (int):
//      Number of bytes returned in buffer.
//
//  History:
//      10/19/93    Fwong       Adding .ini file for app.
//
//--------------------------------------------------------------------------;

int FNGLOBAL GetIniString
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    LPTSTR  pszBuffer,
    int     cchReturnBuffer
)
{
    DWORD   cbBytesCopied;
    LPTSTR   pszShortName;

    if(NULL == pszAppIniFile)
    {
        return 0;
    }

    cbBytesCopied = (DWORD)GetPrivateProfileString(
        pszSection,
        pszEntry,
        TEXT(""),
        pszBuffer,
        cchReturnBuffer,
        pszAppIniFile);

    //
    //  Checking for No Entry
    //

    if(cbBytesCopied != (DWORD)GetPrivateProfileString(
        pszSection,
        pszEntry,
        TEXT("a"),
        pszBuffer,
        cchReturnBuffer,
        pszAppIniFile))
    {
        //
        //  Not in application directory, trying Windows directory.
        //

        pszShortName =  pszAppIniFile;
        pszShortName += lstrlen(pszAppIniFile);
        for(;'\\' != pszShortName[0];pszShortName--);
        pszShortName++;

        cbBytesCopied = (DWORD)GetPrivateProfileString(
            pszSection,
            pszEntry,
            TEXT(""),
            pszBuffer,
            cchReturnBuffer,
            pszShortName);

        if(cbBytesCopied != (DWORD)GetPrivateProfileString(
            pszSection,
            pszEntry,
            TEXT("a"),
            pszBuffer,
            cchReturnBuffer,
            pszShortName))
        {
            pszBuffer[0] = 0;
            return 0;
        }
    }

    return ((int)cbBytesCopied);
} // GetIniString()


//--------------------------------------------------------------------------;
//
//  DWORD GetIniDWORD
//
//  Description:
//      Gets A DWORD from the .ini file for this app.
//
//  Arguments:
//      LPCTSTR pszSection: Section name.
//
//      LPCTSTR pszEntry: Entry name.
//
//      DWORD dwDefault: Default value.
//
//  Return (DWORD):
//      Value from .ini file or dwDefault if error occurs.
//
//  History:
//      11/24/93    Fwong       Adding .ini file for app.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL GetIniDWORD
(
    LPCTSTR pszSection,
    LPCTSTR pszEntry,
    DWORD   dwDefault
)
{
    TCHAR   szValue[12];

    if(NULL == pszAppIniFile)
    {
        return dwDefault;
    }

    if(0 == GetIniString(pszSection,pszEntry,szValue,SIZEOF(szValue)))
    {
        return dwDefault;
    }

    return atoDW(szValue,dwDefault);

} // GetIniDWORD()


//--------------------------------------------------------------------------;
//
//  BOOL GetIniBin
//
//  Description:
//      Reads binary information to the .ini file.
//
//  Arguments:
//      LPCTSTR pszSection: Section name.
//
//      LPCTSTR pszEntry: Entry name.
//
//      LPVOID pvoid: Buffer to read into.
//
//      DWORD cbSize: Size of buffer in bytes.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      01/07/94    Fwong       Yet another random thing.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL GetIniBin
(
    LPCTSTR  pszSection,
    LPCTSTR  pszEntry,
    LPVOID  pvoid,
    DWORD   cbSize
)
{
    TCHAR   szEntry[MAXINISTR];
    TCHAR   szScrap[MAXINISTR];
    LPBYTE  pByte = pvoid;
    LPTSTR  pszMiddle;
    UINT    u;
    DWORD   dw,dwDigit1,dwDigit2;
    
    if(NULL == pszAppIniFile)
    {
        return FALSE;
    }

    if(IsBadWritePtr(pvoid,(UINT)cbSize))
    {
        //
        //  Can't fit data into buffer...
        //

        return FALSE;
    }

    dw = GetIniBinSize(pszSection,pszEntry);

    if(dw > cbSize)
    {
        //
        //  Binary (in .ini file) is larger than given size...
        //

        return FALSE;
    }

    cbSize = dw;

    for (dw=0,u=0;dw < cbSize;u++)
    {
        //
        //  Doing individual lines...
        //

        wsprintf(szEntry,TEXT("%s.%03u"),pszEntry,u);
        GetIniString(pszSection,szEntry,szScrap,MAXINISTR);

        pszMiddle = &(szScrap[0]);

        for (;;dw++,pszMiddle += 2)
        {
            dwDigit1 = HexValue(*pszMiddle);
            
            if(16 == dwDigit1)
            {
                break;
            }

            dwDigit2 = HexValue(*(pszMiddle+1));

            if(16 == dwDigit2)
            {
                return FALSE;
            }

            dwDigit2 += (dwDigit1 * 16);

            pByte[dw] = (BYTE)dwDigit2;
        }
    }

    return TRUE;
} // GetIniBin()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testlib\exact.c ===
//--------------------------------------------------------------------------;
//
//  File: Exact.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Contains exact memory allocation routines.
//
//  Contents:
//      GetPageSize()
//      SetExactHeaderInfo()
//      GetExactHeaderInfo()
//      ExactAllocPtr()
//      ExactFreePtr()
//      GetNumAllocations()
//      GetMemoryHandle()
//      ExactSize()
//      ExactReAllocPtr()
//      GetPointer()
//      SetPointer()
//      ExactHeapAllocPtr()
//      ExactHeapCreate()
//      ExactHeapDestroy()
//      ExactHeapFreePtr()
//      ExactHeapReAllocPtr()
//      ExactHeapSize()
//
//  History:
//      12/01/93    Fwong       Verifying correctness.
//      01/14/94    Fwong       Adding Win32 Support.
//
//--------------------------------------------------------------------------;

#include <windows.h>

#ifdef  WIN32
#include <windowsx.h>
#endif

//==========================================================================;
//
//                            Structures...
//
//==========================================================================;

#ifdef  WIN32

typedef struct EXACTHDR_tag
{
    DWORD   fdwFlags;
    LPVOID  pEvil;
    LPVOID  pStart;
} EXACTHDR;
typedef EXACTHDR       *PEXACTHDR;
typedef EXACTHDR NEAR *NPEXACTHDR;
typedef EXACTHDR FAR  *LPEXACTHDR;

#else

typedef struct EXACTHDR_tag
{
    DWORD   fdwFlags;
    HGLOBAL hMem;
} EXACTHDR;
typedef EXACTHDR       *PEXACTHDR;
typedef EXACTHDR NEAR *NPEXACTHDR;
typedef EXACTHDR FAR  *LPEXACTHDR;

#endif

typedef struct EXACTHEAP_tag
{
    HGLOBAL     hMem;
    DWORD       cNumAlloc;
    DWORD       cMaxAlloc;
    DWORD       fdwFlags;
    LPVOID      pPointers;
} EXACTHEAP;
typedef EXACTHEAP       *PEXACTHEAP;
typedef EXACTHEAP NEAR *NPEXACTHEAP;
typedef EXACTHEAP FAR  *LPEXACTHEAP;

//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define EXACTMEM_SIGNATURE      0xdead0000
#define EXACTMEM_SIGNATUREMASK  0xffff0000

#define EXACTMEM_HANDLE         0x00000001
#define EXACTMEM_INUSE          0x00000002

#define HEAPCHUNKSIZE           32

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define IS_BAD_HEADER_SIGNATURE(a)  (EXACTMEM_SIGNATURE != \
                                    ((a).fdwFlags & EXACTMEM_SIGNATUREMASK))

#define IS_BAD_HEAP_SIGNATURE(a)    (EXACTMEM_SIGNATURE != \
                                    ((a)->fdwFlags & EXACTMEM_SIGNATUREMASK))

#define LOCK_HEAP(a)        ((a)->fdwFlags |= EXACTMEM_INUSE)
#define UNLOCK_HEAP(a)      ((a)->fdwFlags &= (~EXACTMEM_INUSE))

#ifdef  WIN32
#define WAIT_FOR_HEAP(a)    while((a)->fdwFlags & EXACTMEM_INUSE) Sleep(0)
#else
#define WAIT_FOR_HEAP(a)    while((a)->fdwFlags & EXACTMEM_INUSE)
#endif


//==========================================================================;
//
//                            Debug Stuff...
//
//==========================================================================;

#ifdef DEBUG
#define DBGOUT(a)   OutputDebugString("MEMGR:" a "\r\n");
#else
#define DBGOUT(a)   //
#endif

#define DIVRU(a,b)  (((a)/(b)) + (((a)%(b))?1:0))

DWORD   gcAllocations = 0L;

//--------------------------------------------------------------------------;
//
//  DWORD GetPageSize
//
//  Description:
//      Gets the page size for this platform.
//
//  Arguments:
//      None.
//
//  Return (DWORD):
//      Size (in bytes) of a page.
//
//  History:
//      08/09/94    Fwong       Retroactive commenting.  <Internal>
//
//--------------------------------------------------------------------------;

#ifdef  WIN32

DWORD GetPageSize
(
    void
)
{
    SYSTEM_INFO sinf;

    GetSystemInfo(&sinf);

    return (sinf.dwPageSize);
} // GetPageSize()

#endif  //  WIN32


//--------------------------------------------------------------------------;
//
//  BOOL SetExactHeaderInfo
//
//  Description:
//      Given a pointer to an ExactAlloc'ed buffer, it stores the header
//      information.
//
//  Arguments:
//      LPVOID pStart: Pointer to ExactAlloc'ed buffer.
//
//      LPEXACTHDR pExactHdr: Pointer to header.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      08/10/94    Fwong       Facilitating writing headers.  <Internal>
//
//--------------------------------------------------------------------------;

BOOL SetExactHeaderInfo
(
    LPVOID      pStart,
    LPEXACTHDR  pExactHdr
)
{
    pStart = ((LPBYTE)pStart) - sizeof(EXACTHDR);

    if(IsBadWritePtr(pStart,sizeof(EXACTHDR)))
    {
        return FALSE;
    }

    hmemcpy(pStart,pExactHdr,sizeof(EXACTHDR));

    return TRUE;
} // SetExactHeaderInfo()


//--------------------------------------------------------------------------;
//
//  BOOL GetExactHeaderInfo
//
//  Description:
//      Given a pointer to an ExactAlloc'ed buffer, it stores the header
//      information.
//
//  Arguments:
//      LPVOID pStart: Pointer to ExactAlloc'ed buffer.
//
//      LPEXACTHDR pExactHdr: Pointer to header.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      08/10/94    Fwong       Facilitating reading headers.  <Internal>
//
//--------------------------------------------------------------------------;

BOOL GetExactHeaderInfo
(
    LPVOID      pStart,
    LPEXACTHDR  pExactHdr
)
{
    pStart = ((LPBYTE)pStart) - sizeof(EXACTHDR);

    if(IsBadReadPtr(pStart,sizeof(EXACTHDR)))
    {
        return FALSE;
    }

    hmemcpy(pExactHdr,pStart,sizeof(EXACTHDR));

    return TRUE;
} // GetExactHeaderInfo()


//==========================================================================;
//
//  Explanation:  Okay, before I get flamed.  This is the explanation of
//      how things work in the Win32 version of ExactAllocPtr(); it is
//      relatively non-trivial.
//
//  Windows NT sets memory access on a per page basis.  You can mark a page
//      of memory with certain access rights.  The concept is to return a
//      pointer that will hit a PAGE_NOACCESS page on the boundary.
//      Like this...
//
//  ----|-----------|-----------|-no-access-|-----------|-----------|-----
//                       ^
//                       +---- pointer n bytes from "no access" page
//
//  Very simple.  However, you shouldn't be marking a page as PAGE_NOACCESS
//      unless you own the entire page.  (Windows NT doesn't hesitate
//      allocating memory within the same page with GlobalAlloc, and having
//      other things faulting).
//
//  The only way to guarantee getting a full block is to allocate at a
//      buffer at least a full block larger in length.  So we have
//      something that looks like this...
//
//                  |<----buffer-length---->|
//  ----|-----------|-----------|-no-access-|-----------|-----------|-----
//                  ^      ^
//                  +------+---- actual pointer from allocation
//                         +---- offset pointer to return
//
//  Note: Since the implementation changed to using VirtualAlloc (formerly
//      used GlobalAlloc), we are guaranteed all memory allocations to be
//      on page boundaries.
//
//  In addition, we also need to keep track of some other things (so that
//      we can free the memory and return the access rights on the "no
//      access" page to "read/write access".  Moreover, to confirm that
//      the memory allocation was actually done by us, we also put in a
//      "signature."  These are all stored in a header, which is stored
//      right before the pointer to return.  It should look like this...
//
//                  |<----buffer-length---->|
//  ----|-----------|-----------|-no-access-|-----------|-----------|-----
//                  ^    ^ ^
//                  +----+-+---- actual pointer from allocation
//                       + +---- offset pointer to return
//                       +------ location to store header information
//
//  Note: Due to alignment problems (with the MIPS architecture) with
//      writing the header data directly into memory, we're doing an
//      hmemcpy to from a local header.  It may look bad and/or
//      ugly.  DON'T CHANGE IT!  IT WORKS!
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LPVOID ExactAllocPtr
//
//  Description:
//      Performs an exact memory allocation.
//
//      Note: WIN32 Version counts on VirtualAlloc allocating memory in
//            page boundaries.
//
//  Arguments:
//      UINT fuAlloc: Flags for GlobalAlloc.  These are ignored for WIN32.
//
//      DWORD cbAlloc: Size of Buffer.
//
//  Return (LPVOID):
//      Pointer to allocated buffer.
//
//  History:
//      11/17/93    Fwong       Created for exact allocation management.
//      01/14/94    Fwong       Adding Win32 Support.
//      01/26/94    Fwong       Revising to workaround NT problem.
//      08/02/94    Fwong       Changing to use VirtualAlloc.
//
//--------------------------------------------------------------------------;

#ifdef  WIN32

LPVOID ExactAllocPtr
(
    UINT    fuAlloc,
    DWORD   cbAlloc
)
{
    static DWORD    dwPageSize = 0L;
    DWORD           dw;
    DWORD           cbActual;
    DWORD           cbExtra;
    EXACTHDR        ExactHdr;
    LPVOID          pCurrent;

    if(0 == dwPageSize)
    {
        dwPageSize = GetPageSize();
    }

    //
    //  Header info...
    //

    cbExtra = sizeof(EXACTHDR);

    //
    //  dw       = Number of Pages to allocate.
    //  cbActual = Number of bytes.
    //

    dw       = DIVRU(cbAlloc + cbExtra, dwPageSize) + 1;
    cbActual = dw * dwPageSize;

    //
    //  Getting pointer...
    //

    ExactHdr.pStart = VirtualAlloc(
                        NULL,
                        cbActual,
                        MEM_COMMIT|MEM_RESERVE,
                        PAGE_READWRITE);

    if(NULL == ExactHdr.pStart)
    {
        //
        //  Something failed here...
        //

        DBGOUT("VirtualAlloc failed.");

        return NULL;
    }

    //
    //  pEvil = first byte in last page.
    //

    ExactHdr.pEvil = ((LPBYTE)ExactHdr.pStart) + cbActual - dwPageSize;

    //
    //  pCurrent = cbAlloc number of bytes from "Evil" page.
    //

    pCurrent = ((LPBYTE)ExactHdr.pEvil) - cbAlloc;

    //
    //  Making page "Evil"!
    //

    if(FALSE == VirtualProtect(ExactHdr.pEvil,1,PAGE_NOACCESS,&dw))
    {
        //
        //  VirtualProtect failed.  Failing ExactAllocPtr.
        //

        DBGOUT("VirtualProtect failed.");

        VirtualFree(ExactHdr.pStart,0,MEM_RELEASE);

        return NULL;
    }

    ExactHdr.fdwFlags = EXACTMEM_SIGNATURE;

    //
    //  Storing header information.
    //

    SetExactHeaderInfo(pCurrent,&ExactHdr);

    gcAllocations++;

    return (LPVOID)(((LPBYTE)ExactHdr.pEvil) - cbAlloc);
} // ExactAllocPtr()

#else

LPVOID ExactAllocPtr
(
    UINT    fuAlloc,
    DWORD   cbAlloc
)
{
    HGLOBAL     hMem;
    EXACTHDR    ExactHdr;
    LPBYTE      pbyte;

    hMem = GlobalAlloc(fuAlloc,cbAlloc + sizeof(EXACTHDR));

    //
    //  Something failed here...
    //

    if(NULL == hMem)
    {
        DBGOUT("GlobalAlloc failed.");
        return NULL;
    }

    //
    //  Offsetting the pointer by the amount of "extra" bytes.
    //    extra bytes = actual (GlobalSize) - wanted (cbAlloc)
    //

    pbyte = (LPBYTE)GlobalLock(hMem);
    
    if(NULL == pbyte)
    {
        DBGOUT("GlobalLock failed.");
        GlobalFree(hMem);
        return NULL;
    }

    pbyte += (GlobalSize(hMem) - cbAlloc);

    ExactHdr.hMem     = hMem;
    ExactHdr.fdwFlags = EXACTMEM_SIGNATURE;

    //
    //  Storing Header information.
    //

    SetExactHeaderInfo(pbyte,&ExactHdr);

    gcAllocations++;
    return pbyte;

} // ExactAllocPtr()

#endif


//--------------------------------------------------------------------------;
//
//  BOOL ExactFreePtr
//
//  Description:
//      Frees a previously allocated pointer.
//
//  Arguments:
//      LPVOID pvoid: Pointer to buffer.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      11/17/93    Fwong       Created for exact allocation management.
//      01/26/94    Fwong       Adding stuff to workaround NT problem.
//      08/08/94    Fwong       Changed to use VirtualFree.
//
//--------------------------------------------------------------------------;

BOOL ExactFreePtr
(
    LPVOID  pvoid
)
{
    EXACTHDR    ExactHdr;

    if(NULL == pvoid)
    {
        DBGOUT("Bad Pointer.");
        return FALSE;
    }

    //
    //  Retrieving header info.
    //

    if(FALSE == GetExactHeaderInfo(pvoid,&ExactHdr))
    {
        DBGOUT("Bad Header.");
        return FALSE;
    }

    //
    //  Is the signature correct?
    //

    if(IS_BAD_HEADER_SIGNATURE(ExactHdr))
    {
        DBGOUT("Bad Signature.");
        return FALSE;
    }

    //
    //  Was it allocated through "Handle" API's?
    //

    if(EXACTMEM_HANDLE & ExactHdr.fdwFlags)
    {
        DBGOUT("Using Heap memory for non heap API.");
        return FALSE;
    }

#ifdef  WIN32
{
    DWORD       dw;

    //
    //  Setting access rights back to PAGE_READWRITE.
    //

    if(FALSE == VirtualProtect(ExactHdr.pEvil,1,PAGE_READWRITE,&dw))
    {
        //
        //  What is wrong now?!
        //

        DBGOUT("VirtualProtect failed.");
        return FALSE;
    }

    //
    //  Freeing memory.
    //

    if(FALSE == VirtualFree(ExactHdr.pStart,0,MEM_RELEASE))
    {
        //
        //  VirtualFree failed?!
        //

        DBGOUT("VirtualFree failed.");
        return FALSE;
    }
}
#else

    GlobalUnlock(ExactHdr.hMem);

    if(NULL != GlobalFree(ExactHdr.hMem))
    {
        DBGOUT("GlobalFree failed.");
        return FALSE;
    }

#endif

    gcAllocations--;

    return TRUE;
} // ExactFreePtr()


//--------------------------------------------------------------------------;
//
//  DWORD GetNumAllocations
//
//  Description:
//      Returns the number of allocations that have been performed through
//          memgr.
//
//  Arguments:
//      None.
//
//  Return (DWORD):
//      Count of number of allocations.
//
//  History:
//      06/06/94    Fwong       To minimize memory leaks.
//
//--------------------------------------------------------------------------;

DWORD GetNumAllocations
(
    void
)
{
    return gcAllocations;
} // GetNumAllocations()


//--------------------------------------------------------------------------;
//
//  HGLOBAL GetMemoryHandle
//
//  Description:
//      Given a pointer (allocated by memgr) it returns the handle.
//
//  Arguments:
//      LPVOID pvoid: Pointer to buffer.
//
//  Return (HGLOBAL):
//      handle to memory.
//
//  History:
//      06/06/94    Fwong       To make things more flexible.
//
//--------------------------------------------------------------------------;

#ifdef  WIN32

HGLOBAL GetMemoryHandle
(
    LPVOID  pvoid
)
{
    //
    //  The algorithm does not use memory handles for WIN32 anymore.
    //

    return NULL;
} // GetMemoryHandle()

#else

HGLOBAL GetMemoryHandle
(
    LPVOID  pvoid
)
{
    EXACTHDR    ExactHdr;

    if(NULL == pvoid)
    {
        DBGOUT("Bad Pointer.");
        return NULL;
    }

    //
    //  Retrieving header info.
    //

    if(FALSE == GetExactHeaderInfo(pvoid,&ExactHdr))
    {
        DBGOUT("Bad Header.");
        return NULL;
    }

    //
    //  Is the signature correct?
    //

    if(IS_BAD_HEADER_SIGNATURE(ExactHdr))
    {
        DBGOUT("Bad Signature.");
        return NULL;
    }

    return (HGLOBAL)(ExactHdr.hMem);
} // GetMemoryHandle()

#endif


//--------------------------------------------------------------------------;
//
//  DWORD ExactSize
//
//  Description:
//      Given an ExactAlloc'ed pointer, it returns the "exact" size of the
//      buffer.
//
//  Arguments:
//      LPVOID pvoid: Originally ExactAlloc'ed pointer.
//
//  Return (DWORD):
//      Size (in bytes) of buffer; Zero if an error occurs.
//
//  History:
//      08/08/94    Fwong       Adding this for ReAlloc support.
//
//--------------------------------------------------------------------------;

#ifdef  WIN32

DWORD ExactSize
(
    LPVOID  pvoid
)
{
    EXACTHDR    ExactHdr;

    if(NULL == pvoid)
    {
        DBGOUT("Bad Pointer.");
        return 0L;
    }

    //
    //  Retrieving header info.
    //

    if(FALSE == GetExactHeaderInfo(pvoid,&ExactHdr))
    {
        DBGOUT("Bad Header.");
        return 0L;
    }

    //
    //  Is the signature correct?
    //

    if(IS_BAD_HEADER_SIGNATURE(ExactHdr))
    {
        DBGOUT("Bad Signature.");
        return 0L;
    }

    return (DWORD)(((LPBYTE)ExactHdr.pEvil) - (LPBYTE)(pvoid));
} // ExactSize()

#else

DWORD ExactSize
(
    LPVOID  pvoid
)
{
    EXACTHDR    ExactHdr;
    DWORD       dw;

    if(NULL == pvoid)
    {
        DBGOUT("Bad Pointer.");
        return 0L;
    }

    //
    //  Retrieving header info.
    //

    if(FALSE == GetExactHeaderInfo(pvoid,&ExactHdr))
    {
        DBGOUT("Bad Header.");
        return 0L;
    }

    //
    //  Is the signature correct?
    //

    if(IS_BAD_HEADER_SIGNATURE(ExactHdr))
    {
        DBGOUT("Bad Signature.");
        return 0L;
    }

    dw = LOWORD(pvoid);
    return (DWORD)(GlobalSize(ExactHdr.hMem) - dw);
} // ExactSize()

#endif


//--------------------------------------------------------------------------;
//
//  LPVOID ExactReAlloc
//
//  Description:
//      Re-allocates the buffer to be a different size of different
//      allocation flags.
//
//      Note: Don't count on the pointer remaining the same; the pointer
//            _WILL_ change.
//
//  Arguments:
//      LPVOID pOldPtr: Pointer to old buffer.
//
//      DWORD cbAlloc: Number of bytes to re-allocate to.
//
//      UINT fuAlloc: Allocation flags.
//
//  Return (LPVOID):
//      Pointer to buffer, or NULL if unsuccessful.
//
//  History:
//      08/08/94    Fwong       To make life a little easier.
//
//--------------------------------------------------------------------------;

LPVOID ExactReAllocPtr
(
    LPVOID  pOldPtr,
    DWORD   cbAlloc,
    UINT    fuAlloc
)
{
    LPVOID      pNewPtr;
    DWORD       dw;
    EXACTHDR    ExactHdr;

    //
    //  Retrieving header info.
    //

    if(FALSE == GetExactHeaderInfo(pOldPtr,&ExactHdr))
    {
        DBGOUT("Bad Header.");
        return NULL;
    }

    //
    //  Is the signature correct?
    //

    if(IS_BAD_HEADER_SIGNATURE(ExactHdr))
    {
        DBGOUT("Bad Signature.");
        return NULL;
    }

    //
    //  Was it allocated through "Handle" API's?
    //

    if(EXACTMEM_HANDLE & ExactHdr.fdwFlags)
    {
        DBGOUT("Using heap memory for non heap API.");
        return NULL;
    }

    pNewPtr = ExactAllocPtr(fuAlloc,cbAlloc);

    if(NULL == pNewPtr)
    {
        DBGOUT("ExactAllocPtr failed.");
        return NULL;
    }

    //
    //  Determining how many bytes to copy over...
    //

    dw = ExactSize(pOldPtr);
    dw = min(dw,cbAlloc);

    hmemcpy(pNewPtr,pOldPtr,dw);

    ExactFreePtr(pOldPtr);

    return pNewPtr;
} // ExactReAllocPtr()


//--------------------------------------------------------------------------;
//
//  LPVOID GetPointer
//
//  Description:
//      Given the index, gets the pointer from a buffer of pointers.
//
//      Note: This was done very carefully due to the alignment problems
//            with MIPS machines.  DON'T MESS WITH IT!
//
//  Arguments:
//      LPVOID pvoid: Pointer to buffer.
//
//      DWORD index: Index into buffer.
//
//  Return (LPVOID):
//      The pointer at the appropriate index.
//
//  History:
//      08/11/94    Fwong       For Heap Management. <Internal>
//
//--------------------------------------------------------------------------;

LPVOID GetPointer
(
    LPVOID  pvoid,
    DWORD   index
)
{
    LPVOID  pReturn;

    index *= sizeof(LPVOID);
    pvoid  = ((LPBYTE)pvoid) + index;

    hmemcpy((LPVOID)(&pReturn),pvoid,sizeof(LPVOID));

    return pReturn;
} // GetPointer()


//--------------------------------------------------------------------------;
//
//  void SetPointer
//
//  Description:
//      Given the index, sets a pointer within a buffer of pointers.
//
//      Note: This was done very carefully due to the alignment problems
//            with MIPS machines.  DON'T MESS WITH IT!
//
//  Arguments:
//      LPVOID pvoid: Pointer to buffer.
//
//      DWORD index: Index into buffer.
//
//      LPVOID ptr: Pointer to store.
//
//  Return (void):
//
//  History:
//      08/11/94    Fwong       For Heap Management. <Internal>
//
//--------------------------------------------------------------------------;

void SetPointer
(
    LPVOID  pvoid,
    DWORD   index,
    LPVOID  ptr
)
{
    index *= sizeof(LPVOID);
    pvoid  = ((LPBYTE)pvoid) + index;

    hmemcpy(pvoid,(LPVOID)(&ptr),sizeof(LPVOID));
} // SetPointer()


//--------------------------------------------------------------------------;
//
//  LPVOID ExactHeapAllocPtr
//
//  Description:
//      ExactAlloc's a buffer through a heap handle.
//
//  Arguments:
//      HANDLE hHeap: Handle to heap.
//
//      UINT fuAlloc: Allocation flags for memory (See GlobalAlloc).
//
//      DWORD cbAlloc: Size (in bytes) of buffer.
//
//  Return (LPVOID):
//      Pointer to buffer, or NULL if an error occurs.
//
//  History:
//      08/11/94    Fwong       Adding heap support.
//
//--------------------------------------------------------------------------;

LPVOID ExactHeapAllocPtr
(
    HANDLE  hHeap,
    UINT    fuAlloc,
    DWORD   cbAlloc
)
{
    NPEXACTHEAP npExactHeap;
    EXACTHDR    ExactHdr;
    LPVOID      pNewMem;
    HGLOBAL     hMem;
    DWORD       dw;

    npExactHeap = (NPEXACTHEAP)hHeap;

    //
    //  Checking if it is a bad pointer.
    //

    if(IsBadReadPtr(npExactHeap,sizeof(EXACTHEAP)))
    {
        DBGOUT("Bad hHeap.");
        return NULL;
    }

    //
    //  Checking if it is a bad handle.
    //

    if(IS_BAD_HEAP_SIGNATURE(npExactHeap))
    {
        DBGOUT("Bad hHeap.");
        return NULL;
    }

    //
    //  If someone else has a hold of the heap, we wait.
    //

    WAIT_FOR_HEAP(npExactHeap);
    LOCK_HEAP(npExactHeap);

    //
    //  Can we store the pointer?
    //

    if(npExactHeap->cNumAlloc == npExactHeap->cMaxAlloc)
    {
        //
        //  Getting room for HEAPCHUNKSIZE number of more items
        //

        dw = (npExactHeap->cMaxAlloc + HEAPCHUNKSIZE) * sizeof(LPVOID);

        hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,dw);

        if(NULL == hMem)
        {
            DBGOUT("GlobalAlloc failed.");
            UNLOCK_HEAP(npExactHeap);
            return NULL;
        }

        pNewMem = GlobalLock(hMem);

        if(NULL == pNewMem)
        {
            DBGOUT("GlobalLock failed.");
            GlobalFree(hMem);

            UNLOCK_HEAP(npExactHeap);
            return NULL;
        }

        //
        //  Copying all old pointers.
        //

        dw = npExactHeap->cMaxAlloc * sizeof(LPVOID);

        hmemcpy(pNewMem,npExactHeap->pPointers,dw);

        //
        //  Freeing old buffer.
        //

        GlobalUnlock(npExactHeap->hMem);
        GlobalFree(npExactHeap->hMem);

        //
        //  Updating heap header.
        //

        npExactHeap->cMaxAlloc += HEAPCHUNKSIZE;
        npExactHeap->hMem       = hMem;
        npExactHeap->pPointers  = pNewMem;
    }

    pNewMem = ExactAllocPtr(fuAlloc,cbAlloc);

    if(NULL == pNewMem)
    {
        DBGOUT("ExactAllocPtr failed.");

        UNLOCK_HEAP(npExactHeap);
        return NULL;
    }

    //
    //  Marking buffer as allocated by HEAP API's.
    //

    GetExactHeaderInfo(pNewMem,&ExactHdr);
    ExactHdr.fdwFlags |= EXACTMEM_HANDLE;
    SetExactHeaderInfo(pNewMem,&ExactHdr);

    //
    //  Updating Heap info.
    //

    SetPointer(npExactHeap->pPointers,npExactHeap->cNumAlloc,pNewMem);
    npExactHeap->cNumAlloc++;

    UNLOCK_HEAP(npExactHeap);
    return pNewMem;

} // ExactHeapAllocPtr()


//--------------------------------------------------------------------------;
//
//  HANDLE ExactHeapCreate
//
//  Description:
//      Creates a heap to do subsequent memory allocations.
//
//  Arguments:
//      DWORD fdwFlags: Flags for function (none are defined yet).
//
//  Return (HANDLE):
//      Handle to heap, or NULL if an error occured.
//
//  History:
//      08/11/94    Fwong       Adding heap support.
//
//--------------------------------------------------------------------------;

HANDLE ExactHeapCreate
(
    DWORD   fdwFlags
)
{
    NPEXACTHEAP npExactHeap;
    HGLOBAL     hMem;

    npExactHeap = (NPEXACTHEAP)LocalAlloc(LPTR,sizeof(EXACTHEAP));

    if(NULL == npExactHeap)
    {
        DBGOUT("LocalAlloc failed.");
        return NULL;
    }

    hMem = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,HEAPCHUNKSIZE*sizeof(LPVOID));

    if(NULL == hMem)
    {
        DBGOUT("GlobalAlloc failed.");

        LocalFree((HLOCAL)npExactHeap);
        return NULL;
    }

    npExactHeap->pPointers = GlobalLock(hMem);

    if(NULL == npExactHeap->pPointers)
    {
        DBGOUT("GlobalLock failed.");

        GlobalFree(hMem);
        LocalFree((HLOCAL)npExactHeap);

        return NULL;
    }

    npExactHeap->fdwFlags  = EXACTMEM_SIGNATURE;
    npExactHeap->cNumAlloc = 0L;
    npExactHeap->cMaxAlloc = HEAPCHUNKSIZE;
    npExactHeap->hMem      = hMem;

    return (HANDLE)(npExactHeap);
} // ExactHeapCreate()


//--------------------------------------------------------------------------;
//
//  BOOL ExactHeapDestroy
//
//  Description:
//      "Destroys" heap.  Invalidates handle and frees all associated
//      memory allocations.
//
//  Arguments:
//      HANDLE hHeap: Handle to heap.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      08/11/94    Fwong       Adding heap support.
//
//--------------------------------------------------------------------------;

BOOL ExactHeapDestroy
(
    HANDLE  hHeap
)
{
    NPEXACTHEAP npExactHeap;
    EXACTHDR    ExactHdr;
    LPVOID      pMem;
    DWORD       dw;

    npExactHeap = (NPEXACTHEAP)hHeap;

    //
    //  Checking if it is a bad pointer.
    //

    if(IsBadReadPtr(npExactHeap,sizeof(EXACTHEAP)))
    {
        DBGOUT("Bad hHeap.");
        return FALSE;
    }

    //
    //  Checking if it is a bad handle.
    //

    if(IS_BAD_HEAP_SIGNATURE(npExactHeap))
    {
        DBGOUT("Bad hHeap.");
        return FALSE;
    }

    //
    //  If someone else has a hold of the heap, we wait.
    //

    WAIT_FOR_HEAP(npExactHeap);
    LOCK_HEAP(npExactHeap);

    //
    //  Freeing all memory...
    //

    for(dw = npExactHeap->cNumAlloc;dw;dw--)
    {
        pMem = GetPointer(npExactHeap->pPointers,dw-1);
        GetExactHeaderInfo(pMem,&ExactHdr);
        ExactHdr.fdwFlags &= (~EXACTMEM_HANDLE);
        SetExactHeaderInfo(pMem,&ExactHdr);
        
        if(FALSE == ExactFreePtr(pMem))
        {
            DBGOUT("ExactFreePtr failed.");

            UNLOCK_HEAP(npExactHeap);
            return FALSE;
        }
    }

    //
    //  Invalidating handle... Just in case.
    //

    npExactHeap->fdwFlags = 0L;

    //
    //  Freeing memory.
    //

    GlobalUnlock(npExactHeap->hMem);
    GlobalFree(npExactHeap->hMem);
    LocalFree((HLOCAL)(npExactHeap));

    return TRUE;
} // ExactHeapDestroy()


//--------------------------------------------------------------------------;
//
//  BOOL ExactHeapFreePtr
//
//  Description:
//      Frees memory allocated through ExactHeapAllocPtr.
//
//  Arguments:
//      HANDLE hHeap: Handle to heap.
//
//      UINT fuFree: Flags for function (None are defined yet).
//
//      LPVOID pMemFree: Buffer to free.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      08/11/94    Fwong       Adding heap support.
//
//--------------------------------------------------------------------------;

BOOL ExactHeapFreePtr
(
    HANDLE  hHeap,
    UINT    fuFree,
    LPVOID  pMemFree
)
{
    NPEXACTHEAP npExactHeap;
    EXACTHDR    ExactHdr;
    LPVOID      pMem;
    DWORD       dw;

    npExactHeap = (NPEXACTHEAP)hHeap;

    //
    //  Checking if it is a bad pointer.
    //

    if(IsBadReadPtr(npExactHeap,sizeof(EXACTHEAP)))
    {
        DBGOUT("Bad hHeap.");
        return FALSE;
    }

    //
    //  Checking if it is a bad handle.
    //

    if(IS_BAD_HEAP_SIGNATURE(npExactHeap))
    {
        DBGOUT("Bad hHeap.");
        return FALSE;
    }

    //
    //  If someone else has a hold of the heap, we wait.
    //

    WAIT_FOR_HEAP(npExactHeap);
    LOCK_HEAP(npExactHeap);

    //
    //  Searching for pointer...
    //

    for(dw = npExactHeap->cNumAlloc;dw;dw--)
    {
        pMem = GetPointer(npExactHeap->pPointers,dw-1);

        if(pMemFree == pMem)
        {
            //
            //  Marking buffer as not allocated by HEAP API's.
            //

            GetExactHeaderInfo(pMem,&ExactHdr);
            ExactHdr.fdwFlags &= (~EXACTMEM_HANDLE);
            SetExactHeaderInfo(pMem,&ExactHdr);

            //
            //  Freeing memory...
            //

            if(FALSE == ExactFreePtr(pMem))
            {
                DBGOUT("ExactFreePtr failed.");

                ExactHdr.fdwFlags |= EXACTMEM_HANDLE;
                SetExactHeaderInfo(pMem,&ExactHdr);

                UNLOCK_HEAP(npExactHeap);
                return FALSE;
            }

            //
            //  Exchanging this pointer and last pointer...
            //

            npExactHeap->cNumAlloc--;
            pMem = GetPointer(npExactHeap->pPointers,npExactHeap->cNumAlloc);
            SetPointer(npExactHeap->pPointers,dw-1,pMem);

            UNLOCK_HEAP(npExactHeap);
            return TRUE;
        }
    }

    //
    //  Pointer was not found?!
    //

    DBGOUT("Pointer not found.");

    UNLOCK_HEAP(npExactHeap);
    return FALSE;

} // ExactHeapFreePtr()


//--------------------------------------------------------------------------;
//
//  LPVOID ExactHeapReAllocPtr
//
//  Description:
//      Reallocates a buffer to different size or allocation flags.
//
//      Note: Don't count on the pointer remaining the same; the pointer
//            _WILL_ change.
//
//  Arguments:
//      HANDLE hHeap: Handle to heap.
//
//      LPVOID pOldPtr: Buffer to reallocate.
//
//      DWORD cbAlloc: New size of buffer (in bytes).
//
//      UINT fuAlloc: New allocation flags (See GlobalAlloc).
//
//  Return (LPVOID):
//      Pointer to new buffer, or NULL if error occurs.
//
//  History:
//      08/11/94    Fwong       Adding heap support.
//
//--------------------------------------------------------------------------;

LPVOID ExactHeapReAllocPtr
(
    HANDLE  hHeap,
    LPVOID  pOldPtr,
    DWORD   cbAlloc,
    UINT    fuAlloc
)
{
    NPEXACTHEAP npExactHeap;
    EXACTHDR    ExactHdr;
    LPVOID      pMem;
    DWORD       dw;

    npExactHeap = (NPEXACTHEAP)hHeap;

    //
    //  Checking if it is a bad pointer.
    //

    if(IsBadReadPtr(npExactHeap,sizeof(EXACTHEAP)))
    {
        DBGOUT("Bad hHeap.");
        return NULL;
    }

    //
    //  Checking if it is a bad handle.
    //

    if(IS_BAD_HEAP_SIGNATURE(npExactHeap))
    {
        DBGOUT("Bad hHeap.");
        return NULL;
    }

    //
    //  If someone else has a hold of the heap, we wait.
    //

    WAIT_FOR_HEAP(npExactHeap);
    LOCK_HEAP(npExactHeap);

    //
    //  Searching for pointer...
    //

    for(dw = npExactHeap->cNumAlloc;dw;dw--)
    {
        pMem = GetPointer(npExactHeap->pPointers,dw-1);

        if(pOldPtr == pMem)
        {
            //
            //  Marking buffer as not allocated by HEAP API's.
            //

            GetExactHeaderInfo(pMem,&ExactHdr);
            ExactHdr.fdwFlags &= (~EXACTMEM_HANDLE);
            SetExactHeaderInfo(pMem,&ExactHdr);

            //
            //  Doing ReAlloc...
            //

            pMem = ExactReAllocPtr(pOldPtr,cbAlloc,fuAlloc);

            if(NULL == pMem)
            {
                DBGOUT("ExactReAllocPtr failed.");

                UNLOCK_HEAP(npExactHeap);
                return NULL;
            }

            //
            //  Marking buffer as allocated by HEAP API's.
            //

            GetExactHeaderInfo(pMem,&ExactHdr);
            ExactHdr.fdwFlags |= EXACTMEM_HANDLE;
            SetExactHeaderInfo(pMem,&ExactHdr);

            //
            //  Updating pointer...
            //

            SetPointer(npExactHeap->pPointers,dw-1,pMem);

            UNLOCK_HEAP(npExactHeap);
            return pMem;
        }
    }

    //
    //  Pointer not found?!
    //

    DBGOUT("Pointer not found.");

    UNLOCK_HEAP(npExactHeap);
    return NULL;

} // ExactHeapReAllocPtr()


//--------------------------------------------------------------------------;
//
//  DWORD ExactHeapSize
//
//  Description:
//      Gets the size of the buffer the pointer refers to.
//
//  Arguments:
//      HANDLE hHeap: Handle to heap.
//
//      UINT fuSize: Flags to function (None defined).
//
//      LPVOID pMemSize: Pointer to buffer in question.
//
//  Return (DWORD):
//      Size (in bytes) of buffer, or Zero if error occurs
//
//  History:
//      08/11/94    Fwong       Adding heap support.
//
//--------------------------------------------------------------------------;

DWORD ExactHeapSize
(
    HANDLE  hHeap,
    UINT    fuSize,
    LPVOID  pMemSize
)
{
    NPEXACTHEAP npExactHeap;
    LPVOID      pMem;
    DWORD       dw;

    npExactHeap = (NPEXACTHEAP)hHeap;

    //
    //  Checking if it is a bad pointer.
    //

    if(IsBadReadPtr(npExactHeap,sizeof(EXACTHEAP)))
    {
        DBGOUT("Bad hHeap.");
        return 0L;
    }

    //
    //  Checking if it is a bad handle.
    //

    if(IS_BAD_HEAP_SIGNATURE(npExactHeap))
    {
        DBGOUT("Bad hHeap.");
        return 0L;
    }

    //
    //  If someone else has a hold of the heap, we wait.
    //

    WAIT_FOR_HEAP(npExactHeap);
    LOCK_HEAP(npExactHeap);

    //
    //  Searching for pointer...
    //

    for(dw = npExactHeap->cNumAlloc;dw;dw--)
    {
        pMem = GetPointer(npExactHeap->pPointers,dw-1);

        if(pMemSize == pMem)
        {
            UNLOCK_HEAP(npExactHeap);
            return ExactSize(pMem);
        }
    }

    //
    //  Pointer not found.
    //

    DBGOUT("Pointer not found.");

    UNLOCK_HEAP(npExactHeap);
    return 0L;

} // ExactHeapSize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testmix\testmix.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       testmix.c
//
//--------------------------------------------------------------------------

/****************************************************************************
44

	PROGRAM: Generic.c

	PURPOSE: Generic template for Windows applications

	FUNCTIONS:

	WinMain() - calls initialization function, processes message loop
	InitApplication() - initializes window data and registers window
	InitInstance() - saves instance handle and creates main window
	WndProc() - processes messages
	CenterWindow() - used to center the "About" box over application window
	About() - processes messages for "About" dialog box

	COMMENTS:

		The Windows SDK Generic Application Example is a sample application
		that you can use to get an idea of how to perform some of the simple
		functionality that all Applications written for Microsoft Windows
		should implement. You can use this application as either a starting
		point from which to build your own applications, or for quickly
		testing out functionality of an interesting Windows API.

		This application is source compatible for with Windows 3.1 and
		Windows NT.

****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <devioctl.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <ks.h>


#include "testmix.h"   // specific to this program

#if !defined (APIENTRY) // Windows NT defines APIENTRY, but 3.x doesn't
#define APIENTRY far pascal
#endif

#if !defined(WIN32) // Windows 3.x uses a FARPROC for dialogs
#define DLGPROC FARPROC
#endif

#define WM_GENERICTEST      (WM_USER+1)
#define UPARAM_GENERICTEST  72639

HINSTANCE hInst;          // current instance


char szAppName[] = "TestMix";   // The name of this application
char szTitle[]   = "Dolby Prologic Encoder"; // The title bar text
char szGridName[] = "PrologicGrid" ;
char szResult[] = "This is a test error message 4 everyone";
char szFormat[]  = "This is a %1!s! error m%2!c!ssage %3!d! everyone";
char szTest[] = "test";
char cArg = 'e';
int  dArg = 4;
BOOL fVB13406 = FALSE;

#define EW_ENUMWINDOWS          0
#define EW_ENUMCHILDWINDOWS     1
#define EW_ENUMTHREADWINDOWS    2

BOOL fEnumCalled;
BOOL fReturnFalse;

void    DebugDude(void);

VOID    CALLBACK SendCallback(HWND, UINT, DWORD, LRESULT);
BOOL    CALLBACK EnumWndCallback(HWND, LPARAM);
BOOL    CALLBACK EnumPropsCallback(HWND, LPCSTR, DWORD);
BOOL    CALLBACK EnumPropsExCallback(HWND, LPCSTR, DWORD, LPARAM);
BOOL    CALLBACK StateCallback(HDC, LPARAM, WPARAM, INT, INT);
LRESULT CALLBACK HookProc(int, WPARAM, LPARAM);

BOOL DoFormatMessage(HWND);
BOOL DoEmCharFromPos(HWND);
void DoGetSetClassTest(HWND);
void DoGetSetWindowTest(HWND);
void DoDrawState(HWND);
void VerifyB13406(HWND);
void TestSubclassing(HWND);
void TestMDIGetActive(HWND);
void TestMDISetMenu(HWND);
void TestNextMenu(HWND);
LRESULT CALLBACK FakeControlProc(HWND, UINT, WPARAM, LPARAM);

void MixWaveFile(int) ;
BOOL CopyToSoundBuffer() ;
//void MixChannels() ;

BOOL GetWaveFile(int, BOOL) ;
void PlayWave(int) ;
void InitPCMBuf(int) ;
BOOL ControlPanelDialog ( HWND hDlg, UINT message, WPARAM wParam, LONG lParam ) ;
void ControlPanel(int, HWND hwnd) ;
BOOL CreateSndBuffer(int) ;
BOOL ReadWaveFile(int) ;
void Play(int) ;
void StopWave(int) ;
void DestroyWave(int) ;
void MoveGridTo( int, HWND hwnd, int x, int y ) ;
int GetFreeSrc() ;
int GetSrcFromGrid ( HWND hGrid ) ;
void RelMem(int srcno) ;

BOOL CALLBACK DSEnumProc( LPGUID, LPSTR, LPSTR, LPVOID );
BOOL CALLBACK DSEnumDlgProc( HWND, UINT, WPARAM, LPARAM );

void InitJoyStick(void) ;
void InitAutoPilot(void) ;
#define	CCHFILENAMEMAX	260
#define	CCHFILTERMAX		64


#define	CH_LEFT	0
#define	CH_RIGHT	1
#define	CH_CENTER	2
#define	CH_SURROUND	3

#define	MAX_CHANNELS	4

HANDLE hInst ;

FARPROC lpfnCtrlPanelDlg ;
GUID                    guID;

CHAR     szWaveFileName[CCHFILENAMEMAX] = "" ;	 /* New file name */
CHAR WaveFilter[] = {'W','a','v','e',' ','F','i','l','e','s','\0','*','.','W','A','V', '\0', '\0', '\0'} ;

char *DefFiles[2] = { "c:\\WAV\\HELI5.Wav", "c:\\WAV\\MACHGN2.WAV" } ;
WORD LFTable[21] = { 32768,
			31086,
			29309,
			27416,
			25382,
			23171,
			20724,
			17945,
			14654,
			10362,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
			} ;
WORD RFTable[21] = { 0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			10362,
			14654,
			17945,
			20724,
			23171,
			25382,
			27416,
			29309,
			31086,
			32768
			} ;
WORD CFTable[21] = { 0,
			10362,
			14654,
			17945,
			20724,
			23171,
			25382,
			27416,
			29309,
			31086,
			32768,
			31086,
			29309,
			27416,
			25382,
			23171,
			20724,
			17945,
			14654,
			10362,
			0
			} ;

WORD SFTable[21] = { 32768, //100,
			32440, //99,
			32113, //98,
			31457, //96,
			30802, //94,
			29819, //91
			28508, //87,
			26870, //82,
			24904, //76,
			22938, //70,
			22938, //70,
			22938, //70,
			20644, //63,
			18022, //55,
			15073, //46,
			11796, //36,
			8102, //25,
			4915, //15,
			3277, //10,
			1638, //5,
			0
} ;

WORD VolTable[21] = { 32768,
			31938,
			31086,
			30211,						
			29309,
			28378,
			27416,
			26418,
			25382,
			24301,
			23170,
			21981,
			20724,
			19386,
			17948,
			16384,
			14654,
			12691,
			10362,
			7327,
			0
} ;



#define	MAX_SOUND_SOURCE	4

BOOL SrcIsFree[MAX_SOUND_SOURCE] = {TRUE, TRUE, TRUE, TRUE} ;
HWND hDlgs[MAX_SOUND_SOURCE] ;
HWND GridHnd[MAX_SOUND_SOURCE] ;
char *DlgNames[MAX_SOUND_SOURCE] = { "SoundControl1", "SoundControl2", "SoundControl3", "SoundControl4" } ; ;

HWND ghDlg = NULL ;	// active dialog box

struct _wvhdr {
 DWORD Res1 ;
 WORD Tag ;
 WORD Channels ;
 DWORD SampPerSec ;
 DWORD BytesPerSec ;
 WORD  Align ;
 WORD BitsPerSample ;
 DWORD Res2 ;
 DWORD Size ;
} ;

struct _pcmdata {
 signed short Left ;
 signed short Right ;
} ;
	
struct SNDSRC {
	OPENFILENAME OFN ;
	struct _wvhdr WaveFileHeader ;
	BOOL GridButtonDown ;
	BOOL Stop ;
	BOOL GotWaveFile ;
	WORD LeftFactor ;
	WORD RightFactor ;
	WORD CenterFactor ;
	WORD SurroundFactor ;
	short int HPos ;
	short int VPos ;
	DWORD MixerThId ;
	HANDLE MixerEvent ;
	HANDLE MixerTh ;
	BOOL fMixerExit ;
	struct _pcmdata *PCM ;
	signed short *TmpBuf ;
	int TotalSamples ;
	int AvgPhaseShift ;
	BOOL IsPlaying ;
	BOOL JoyCaptured ;
	WAVEHDR WaveHeader ;
	ULONG cbWritten ;
	OVERLAPPED Ov ;
	HANDLE hMixerSink ;
} ;

struct SNDSRC SndSrc[MAX_SOUND_SOURCE] ;


BOOL HaveJoyStick = FALSE ;
BOOL ButtonDown = FALSE ;
int loopcnt = -2 ;
BOOL AutoPilot = TRUE ;

HANDLE AutoEvent, AutoTh ;
DWORD AutoThId ;

DWORD JoyXThreshold, JoyYThreshold ;
JOYCAPS JoyCaps ;

DWORD GetPos(int) ;
void MixerThread(LPARAM) ;
void AutoPilotThread(LPARAM) ;
void AutoPlay(void) ;
void MixChannels(int, DWORD, DWORD) ;
void CopyToDSB( int, UCHAR *src, DWORD trgoffset, DWORD cbBytes ) ;
void CalcPhaseShift(int srcno) ;

HANDLE		hMixerHandle ;
HANDLE hWaveBuffSink ;
HANDLE hSB16Sink ;
BOOL MixerRunning = FALSE ;

BOOL WvControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
) ;

void SetFormat
(
	PKSDATAFORMAT_DIGITAL_AUDIO pAudioFormat
) ;

BOOL SetupFilterGraph
(
	PHANDLE phMixerHandle
) ;

VOID WvSetState
(
   HANDLE         hDevice,
   KSSTATE        DeviceState
) ;
// --------------------------------------------------------------------------
//
//  DebugDude()
//
// --------------------------------------------------------------------------
void DebugDude(void)
{
    MessageBeep(0);
    DebugBreak();
}


/****************************************************************************

	FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

	PURPOSE: calls initialization function, processes message loop

	COMMENTS:

		Windows recognizes this function by name as the initial entry point
		for the program.  This function calls the application initialization
		routine, if no other instance of the program is running, and always
		calls the instance initialization routine.  It then executes a message
		retrieval and dispatch loop that is the top-level control structure
		for the remainder of execution.  The loop is terminated when a WM_QUIT
		message is received, at which time this function exits the application
		instance by returning the value passed by PostQuitMessage().

		If this function must abort before entering the message loop, it
		returns the conventional value NULL.

****************************************************************************/
int APIENTRY WinMain(
	HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int nCmdShow)
{

	MSG msg;
	HANDLE hAccelTable;

	if (!hPrevInstance) {       // Other instances of app running?
			if (!InitApplication(hInstance)) { // Initialize shared things
			return (FALSE);     // Exits if unable to initialize
		}
	}

	/* Perform initializations that apply to a specific instance */

	if (!InitInstance(hInstance, nCmdShow)) {
		return (FALSE);
	}

	hAccelTable = LoadAccelerators (hInstance, szAppName);

	/* Acquire and dispatch messages until a WM_QUIT message is received. */

	while (GetMessage(&msg, // message structure
	   NULL,   // handle of window receiving the message
	   0,      // lowest message to examine
	   0))     // highest message to examine
	{
	    if ( (ghDlg == NULL) || !(IsDialogMessage(ghDlg, &msg)) ) {
		if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
			TranslateMessage(&msg);// Translates virtual key codes
			DispatchMessage(&msg); // Dispatches message to window
		}
	    }
	}


	return (msg.wParam); // Returns the value from PostQuitMessage

	lpCmdLine; // This will prevent 'unused formal parameter' warnings
}


/****************************************************************************

	FUNCTION: InitApplication(HINSTANCE)

	PURPOSE: Initializes window data and registers window class

	COMMENTS:

		This function is called at initialization time only if no other
		instances of the application are running.  This function performs
		initialization tasks that can be done once for any number of running
		instances.

		In this case, we initialize a window class by filling out a data
		structure of type WNDCLASS and calling the Windows RegisterClass()
		function.  Since all instances of this application use the same window
		class, we only need to do this when the first instance is initialized.


****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
	WNDCLASSEX  wc;

    // Fill in window class structure with parameters that describe the
	// main window.

	wc.cbSize        = sizeof(WNDCLASSEX);
	wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
	wc.lpfnWndProc   = (WNDPROC)WndProc;       // Window Procedure
	wc.cbClsExtra    = 0;                      // No per-class extra data.
	wc.cbWndExtra    = 4;                      // No per-window extra data.
	wc.hInstance     = hInstance;              // Owner of this class
	wc.hIcon         = LoadIcon (hInstance, szAppName); // Icon name from .RC
	wc.hCursor       = LoadCursor (NULL, IDC_ARROW); // Icon name from .RC
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);// Default color
	wc.lpszMenuName  = szAppName;              // Menu name from .RC
	wc.lpszClassName = szAppName;              // Name to register as
    wc.hIconSm       = NULL;

	// Register the window class and return success/failure code.
	return (RegisterClassEx(&wc));
}


/****************************************************************************

	FUNCTION:  InitInstance(HINSTANCE, int)

	PURPOSE:  Saves instance handle and creates main window

	COMMENTS:

		This function is called at initialization time for every instance of
		this application.  This function performs initialization tasks that
		cannot be shared by multiple instances.

		In this case, we save the instance handle in a static variable and
		create and display the main program window.

****************************************************************************/

HWND            hWind; // Main window handle.

BOOL InitInstance(
	HINSTANCE          hInstance,
	int             nCmdShow)
{

	// Save the instance handle in static variable, which will be used in
	// many subsequence calls from this application to Windows.

	hInst = hInstance; // Store instance handle in our global variable

	// Create a main window for this application instance.

	hWind = CreateWindow(
		szAppName,	     // See RegisterClass() call.
		szTitle,	     // Text for window title bar.
		WS_OVERLAPPEDWINDOW,// Window style.
		CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, // Use default positioning
		NULL,		     // Overlapped windows have no parent.
		NULL,		     // Use the window class menu.
		hInstance,	     // This instance owns this window.
		NULL		     // We don't use any data in our WM_CREATE
	);

	// If window could not be created, return "failure"
	if (!hWind) {
		return (FALSE);
	}

	// Make the window visible; update its client area; and return "success"
	ShowWindow(hWind, nCmdShow); // Show the window
	UpdateWindow(hWind);         // Sends WM_PAINT message

	return (SetupFilterGraph(&hMixerHandle)) ;

}

/****************************************************************************

	FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)

	PURPOSE:  Processes messages

	MESSAGES:

	WM_COMMAND    - application menu (About dialog box)
	WM_DESTROY    - destroy window

	COMMENTS:

	To process the IDM_ABOUT message, call MakeProcInstance() to get the
	current instance address of the About() function.  Then call Dialog
	box which will create the box according to the information in your
	generic.rc file and turn control over to the About() function.  When
	it returns, free the intance address.

****************************************************************************/

LRESULT CALLBACK WndProc(
		HWND hWnd,         // window handle
		UINT message,      // type of message
		WPARAM uParam,     // additional information
		LPARAM lParam)     // additional information
{
	FARPROC lpProcAbout;  // pointer to the "About" function
	int wmId, wmEvent, srcno;

	switch (message) {

	 case WM_CREATE:
	     hInst = ((LPCREATESTRUCT)lParam)->hInstance ;
	     lpfnCtrlPanelDlg = MakeProcInstance (ControlPanelDialog, hInst) ;
	     break ;

        case WM_MDIGETACTIVE:
            if (lParam)
                *((LPBOOL)lParam) = TRUE;
            return((LRESULT)GetShellWindow());

        case WM_MDISETMENU:
            if (lParam == (LPARAM)GetMenu(hWnd))
                return((LRESULT)GetMenu(hWnd));
            else
                return(0L);
            break;

	 case WM_MOVE:
		break ;
        case WM_NEXTMENU:
            if (lParam && (((LPMDINEXTMENU)lParam)->hmenuIn == GetMenu(hWnd)))
            {
                ((LPMDINEXTMENU)lParam)->hmenuNext = GetSystemMenu(hWnd, FALSE);
                ((LPMDINEXTMENU)lParam)->hwndNext = GetShellWindow();
                return(TRUE);
            }
            return(FALSE);

		case WM_COMMAND:  // message: command from application menu

// Message packing of uParam and lParam have changed for Win32, let us
// handle the differences in a conditional compilation:
#if defined (WIN32)   
			wmId    = LOWORD(uParam);
			wmEvent = HIWORD(uParam);
#else
			wmId    = uParam;
			wmEvent = HIWORD(lParam);
#endif

			switch (wmId)
            {
				case IDM_ABOUT:
					lpProcAbout = MakeProcInstance((FARPROC)About, hInst);

					DialogBox(hInst,           // current instance
						"AboutBox",            // dlg resource to use
						hWnd,                  // parent handle
						(DLGPROC)lpProcAbout); // About() instance address

					FreeProcInstance(lpProcAbout);
					break;

				case IDM_EXIT:
					DestroyWindow (hWnd);
					break;

				case IDM_CONTROLS:
					ControlPanel(0, hWnd) ;
					break ;
				case IDM_OPEN:
					srcno = GetFreeSrc() ;
					if (!srcno)
						break ;
					srcno-- ;		// 0 based
					if (GetWaveFile (srcno, FALSE))
						ControlPanel(srcno, hWnd) ;
					break ;
				case IDM_PLAY:
					PlayWave(0) ;
					break ;
				default:
					return (DefWindowProc(hWnd, message, uParam, lParam));
			}
			break;

        case WM_SYSCOLORCHANGE:
            VerifyB13406(hWnd);
            break;

		case WM_DESTROY:  // message: window being destroyed
			// todo: do this for all active sound sources
            // this is a test code for reference only
			for ( srcno = 0; srcno < MAX_SOUND_SOURCE; srcno++ ) {
				if ( SrcIsFree[srcno] )
					continue ;
				StopWave(srcno) ;
				DestroyWave(srcno) ;
				RelMem(srcno) ;
				SndSrc[srcno].fMixerExit = TRUE ;
			}
			PostQuitMessage(0);
			break;

        case WM_GENERICTEST:
            if (uParam != UPARAM_GENERICTEST)
            {
                // Failure.  DWORD significant wParam didn't make it thru.
                DebugDude();
                MessageBox(hWnd, "HIWORD of wParam 72,639 was stripped out.",
                    szAppName, MB_SYSTEMMODAL | MB_OK);
            }
            else
            {
                // Success!
                MessageBox(hWnd, "wParam 72,639 passed through!",
                    szAppName, MB_SYSTEMMODAL | MB_OK);
            }
            break;

        case WM_COMPAREITEM:
            if (((COMPAREITEMSTRUCT *)lParam)->CtlID != UPARAM_GENERICTEST)
                goto FailureCtlID;
            else if (((COMPAREITEMSTRUCT *)lParam)->dwLocaleId != UPARAM_GENERICTEST)
            {                             
                // dwLocaleID wasn't passed through.
                DebugDude();
                MessageBox(hWnd, "dwLocaleId of COMPAREITEMSTRUCT was stripped out.",
                    szAppName, MB_SYSTEMMODAL | MB_OK);
            }
            else
                goto SuccessCtlID;
            break;

        case WM_DELETEITEM:
            if (((DELETEITEMSTRUCT *)lParam)->CtlID != UPARAM_GENERICTEST)
                goto FailureCtlID;
            else
                goto SuccessCtlID;
            break;

        case WM_DRAWITEM:
            if (((DRAWITEMSTRUCT *)lParam)->CtlID != UPARAM_GENERICTEST)
                goto FailureCtlID;
            else
                goto SuccessCtlID;
            break;

        case WM_MEASUREITEM:
            if (((MEASUREITEMSTRUCT *)lParam)->CtlID != UPARAM_GENERICTEST)
            {
FailureCtlID:
                // CtlID wasn't passed through completely
                DebugDude();
                MessageBox(hWnd, "CtlID of OWNERDRAWSTRUCT was stripped out.",
                    szAppName, MB_SYSTEMMODAL | MB_OK);
            }
            else
            {
SuccessCtlID:
                // Success!
                MessageBox(hWnd, "Complete OWNERDRAWSTRUCT was passed through (includes CtlID and dwLocaleId)!",
                    szAppName, MB_SYSTEMMODAL | MB_OK);
            }
            break;

		default:          // Passes it on if unproccessed
			return (DefWindowProc(hWnd, message, uParam, lParam));
	}
	return (0);
}

/****************************************************************************

	FUNCTION: CenterWindow (HWND, HWND)

	PURPOSE:  Center one window over another

	COMMENTS:

	Dialog boxes take on the screen position that they were designed at,
	which is not always appropriate. Centering the dialog over a particular
	window usually results in a better position.

****************************************************************************/

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent;
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xNew, yNew;
	HDC     hdc;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the display limits
	hdc = GetDC (hwndChild);
	wScreen = GetDeviceCaps (hdc, HORZRES);
	hScreen = GetDeviceCaps (hdc, VERTRES);
	ReleaseDC (hwndChild, hdc);

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < 0) {
		xNew = 0;
	} else if ((xNew+wChild) > wScreen) {
		xNew = wScreen - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < 0) {
		yNew = 0;
	} else if ((yNew+hChild) > hScreen) {
		yNew = hScreen - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL,
		xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


/****************************************************************************

	FUNCTION: About(HWND, UINT, WPARAM, LPARAM)

	PURPOSE:  Processes messages for "About" dialog box

	MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

	COMMENTS:

	Display version information from the version section of the
	application resource.

	Wait for user to click on "Ok" button, then close the dialog box.

****************************************************************************/

LRESULT CALLBACK About(
		HWND hDlg,           // window handle of the dialog box
		UINT message,        // type of message
		WPARAM uParam,       // message-specific information
	        LPARAM lParam)
{
	static  HFONT hfontDlg;
	LPSTR   lpVersion;       
	DWORD   dwVerInfoSize;
	DWORD   dwVerHnd;
	UINT    uVersionLen;
	WORD    wRootLen;
	BOOL    bRetCode;
	int     i;
	char    szFullPath[256];
	char    szResult[256];
	char    szGetName[256];

	switch (message) {
		case WM_INITDIALOG:  // message: initialize dialog box
            dwVerInfoSize = (DWORD)GetWindowLong(hDlg, DWL_DLGPROC);
            if (dwVerInfoSize != (DWORD)About)
                DebugDude();

			// Create a font to use
			hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0,
				VARIABLE_PITCH | FF_SWISS, "");

			// Center the dialog over the application window
			CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

			// Get version information from the application
			GetModuleFileName (hInst, szFullPath, sizeof(szFullPath));
			dwVerInfoSize = 0 ;
//			dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &dwVerHnd);
			if (dwVerInfoSize) {
				// If we were able to get the information, process it:
				LPSTR   lpstrVffInfo;
				HANDLE  hMem;
				hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
				lpstrVffInfo  = GlobalLock(hMem);
				GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo);
				lstrcpy(szGetName, "\\StringFileInfo\\040904E4\\");
				wRootLen = lstrlen(szGetName);

				// Walk through the dialog items that we want to replace:
				for (i = DLG_VERFIRST; i <= DLG_VERLAST; i++) {
					GetDlgItemText(hDlg, i, szResult, sizeof(szResult));
					szGetName[wRootLen] = (char)0;
					lstrcat (szGetName, szResult);
					uVersionLen   = 0;
					lpVersion     = NULL;
					bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
						(LPSTR)szGetName,
						(LPVOID)&lpVersion,
#if defined (WIN32)
						(LPDWORD)&uVersionLen); // For MIPS strictness
#else
						(UINT *)&uVersionLen);
#endif

					if ( bRetCode && uVersionLen && lpVersion) {
						// Replace dialog item text with version info
						lstrcpy(szResult, lpVersion);
						SetDlgItemText(hDlg, i, szResult);
						SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, (UINT)hfontDlg, TRUE);
					}
				} // for (i = DLG_VERFIRST; i <= DLG_VERLAST; i++)

				GlobalUnlock(hMem);
				GlobalFree(hMem);
			} // if (dwVerInfoSize)

			return (TRUE);

		case WM_COMMAND:                      // message: received a command
			if (LOWORD(uParam) == IDOK        // "OK" box selected?
			|| LOWORD(uParam) == IDCANCEL) {  // System menu close command?
				EndDialog(hDlg, TRUE);        // Exit the dialog
				DeleteObject (hfontDlg);
				return (TRUE);
			}
			break;
	}
	return (FALSE); // Didn't process the message

	lParam; // This will prevent 'unused formal parameter' warnings
}



// --------------------------------------------------------------------------
//
//  DoFormatMessage()
//
//  Basic format message sanity check.
//
// --------------------------------------------------------------------------
BOOL DoFormatMessage(HWND hwnd)
{
    LPSTR   lpsz;
    char    szTmp[128];
    DWORD   rgArgs[3];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, 126,
        MAKELONG(LANG_NEUTRAL, SUBLANG_NEUTRAL), szTmp, sizeof(szTmp), NULL);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, hInst, 126,
        MAKELONG(LANG_NEUTRAL, SUBLANG_NEUTRAL), szTmp, sizeof(szTmp), NULL);

    rgArgs[0] = (DWORD)szTest;
    rgArgs[1] = cArg;
    rgArgs[2] = dArg;

    lpsz = NULL;
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
        FORMAT_MESSAGE_ARGUMENT_ARRAY, szFormat, 0, 0, (LPSTR)&lpsz, 128,
        (va_list *)rgArgs);
    if (!lpsz)
        return(FALSE);

    if (strcmp(lpsz, szResult))
    {
        LocalFree(lpsz);
        return(FALSE);
    }

    LocalFree(lpsz);
    
    lpsz = szTmp;
    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szFormat, 0, 0, lpsz, 128, (va_list *)rgArgs);
    if (strcmp(lpsz, szResult))
        return(FALSE);

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, hInst, 0x80070004, MAKELONG(LANG_NEUTRAL, SUBLANG_NEUTRAL),
        szTmp, sizeof(szTmp), NULL);
    if (!*szTmp)
        return(FALSE);

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | (12), hInst, 0x80004012, MAKELONG(LANG_NEUTRAL, SUBLANG_NEUTRAL),
        szTmp, sizeof(szTmp), NULL);

    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
        hInst, 0x00009999, MAKELONG(LANG_NEUTRAL, SUBLANG_NEUTRAL), szTmp, sizeof(szTmp), NULL) ||
        (GetLastError() != ERROR_MR_MID_NOT_FOUND))
        return(FALSE);

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  SendCallback()
//
//  Called from SendMessageCallback()
//
// --------------------------------------------------------------------------
VOID CALLBACK SendCallback(HWND hwnd, UINT msg, DWORD dwData, LRESULT lResult)
{
    if ((msg != BM_CLICK) && (msg != WM_COMMAND))
    {
        DebugDude();
    }
    return;
}


// --------------------------------------------------------------------------
//
//  EnumWndCallback()
//
//  Called from EnumWindows APIs.
//
// --------------------------------------------------------------------------
BOOL CALLBACK EnumWndCallback(HWND hwnd, LPARAM lParam)
{
    return(fEnumCalled = TRUE);
}


// --------------------------------------------------------------------------
//
//  DoEmCharFromPos()
//
//  Tests EM_CHARFROMPOS, EM_POSFROMCHAR for single line & multiple line
//  edit controls.
//
// --------------------------------------------------------------------------
BOOL DoEmCharFromPos(HWND hwnd)
{
    HWND    hwndEdit;
    int     ipos;
    DWORD   xypos;

    hwndEdit = CreateWindowEx(0, "edit", "78978978978989789789",
        WS_CHILD | WS_VISIBLE | ES_MULTILINE,
        8, 8, 84, 48, hwnd, (HMENU)522122, hInst, NULL);
    if (!hwndEdit)
        return(FALSE);

    UpdateWindow(hwndEdit);

    if (GetDlgItemInt(hwnd, 522122, &ipos, FALSE) || ipos)
    {
        DebugDude();
    }

    SetDlgItemInt(hwnd, 522122, 12124412, FALSE);
    UpdateWindow(hwndEdit);

    if (GetDlgItemInt(hwnd, 522122, NULL, FALSE) != 12124412)
    {
        DebugDude();
    }

    SetDlgItemInt(hwnd, 522122, (UINT)-445665, TRUE);
    UpdateWindow(hwndEdit);

    if ((int)GetDlgItemInt(hwnd, 522122, NULL, TRUE) != -445665)
    {
        DebugDude();
    }

    SetDlgItemText(hwnd, 522122, "sample text");
    UpdateWindow(hwndEdit);

    xypos = SendMessage(hwndEdit, EM_POSFROMCHAR, 9, 0L);
    ipos = SendMessage(hwndEdit, EM_CHARFROMPOS, 0, xypos);
    
    if (ipos != 9)
    {
ErrorDestroy:
        DestroyWindow(hwndEdit);
        return(FALSE);
    }

    if (SendMessage(hwndEdit, EM_CHARFROMPOS, 0, MAKELONG(-1, -1)) != -1)
    {
        goto ErrorDestroy;
    }

    DestroyWindow(hwndEdit);


    hwndEdit = CreateWindowEx(WS_EX_CLIENTEDGE, "edit",
        "this is pretty darned MF long test test, tally ho",
        WS_CHILD | WS_VISIBLE | ES_LEFT | ES_MULTILINE,
        8, 8, 84, 64, hwnd, NULL, hInst, NULL);
    if (!hwndEdit)
        return(FALSE);

    xypos = SendMessage(hwndEdit, EM_POSFROMCHAR, 30, 0L);
    ipos = SendMessage(hwndEdit, EM_CHARFROMPOS, 0, xypos);

    if (ipos != 30)
    {
        goto ErrorDestroy;
    }

    DestroyWindow(hwndEdit);

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  GetSetClassData()
//
// --------------------------------------------------------------------------
void DoGetSetClassTest(HWND hwnd)
{
    DWORD    lTmp;

    // GCL_MENUNAME
    lTmp = GetClassLong(hwnd, GCL_MENUNAME);
    if (strcmp((LPSTR)lTmp, szAppName))
        DebugDude();

    // This should fail!
    SetClassLong(hwnd, GCL_MENUNAME, (DWORD)szAppName);

    // GCL_HBRBACKGROUND
    lTmp = GetClassLong(hwnd, GCL_HBRBACKGROUND);
    if (lTmp != (COLOR_WINDOW+1))
        DebugDude();
    SetClassLong(hwnd, GCL_HBRBACKGROUND, (DWORD)(COLOR_3DFACE+1));

    // GCL_HCURSOR
    lTmp = GetClassLong(hwnd, GCL_HCURSOR);
    if (lTmp != (DWORD)LoadCursor(NULL, IDC_ARROW))
        DebugDude();
    SetClassLong(hwnd, GCL_HCURSOR, (DWORD)LoadCursor(NULL, IDC_SIZE));

    // GCL_HICON
    lTmp = GetClassLong(hwnd, GCL_HICON);
    if (lTmp != (DWORD)LoadIcon(hInst, szAppName))
        DebugDude();
    SetClassLong(hwnd, GCL_HICON, (DWORD)LoadIcon(hInst, szAppName));

    // GCL_HMODULE
    lTmp = GetClassLong(hwnd, GCL_HMODULE);
    if (lTmp != (DWORD)hInst)
        DebugDude();

    // This should fail!
    SetClassLong(hwnd, GCL_HMODULE, (DWORD)hInst);

    // GCL_CBWNDEXTRA
    lTmp = GetClassLong(hwnd, GCL_CBWNDEXTRA);
    SetClassLong(hwnd, GCL_CBWNDEXTRA, lTmp-4);

    // GCL_CBCLSEXTRA
    lTmp = GetClassLong(hwnd, GCL_CBCLSEXTRA);

    // This should fail!
    SetClassLong(hwnd, GCL_CBCLSEXTRA, lTmp+4);

    // GCL_WNDPROC
    lTmp = GetClassLong(hwnd, GCL_WNDPROC);
    if (lTmp != (DWORD)WndProc)
        DebugDude();
    SetClassLong(hwnd, GCL_WNDPROC, (DWORD)WndProc);

    // GCL_STYLE
    lTmp = GetClassLong(hwnd, GCL_STYLE);
    if (lTmp != (CS_HREDRAW | CS_VREDRAW))
        DebugDude();
    SetClassLong(hwnd, GCL_STYLE, CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS);

    // GCL_ATOM
    lTmp = GetClassLong(hwnd, GCW_ATOM);

    // This should fail!
    SetClassLong(hwnd, GCW_ATOM, lTmp);
}


// --------------------------------------------------------------------------
//
//  GetSetWindowData()
//
// --------------------------------------------------------------------------
void DoGetSetWindowTest(HWND hwnd)
{
    DWORD lTmp;
    HWND    hwndP, hwndC;

    // GWL_WNDPROC
    lTmp = GetWindowLong(hwnd, GWL_WNDPROC);
    if (lTmp != (DWORD)WndProc)
        DebugDude();
    SetWindowLong(hwnd, GWL_WNDPROC, (DWORD)WndProc);

    // GWL_HINSTANCE
    lTmp = GetWindowLong(hwnd, GWL_HINSTANCE);
    if (lTmp != (DWORD)hInst)
        DebugDude();

    // This should fail!
    SetWindowLong(hwnd, GWL_HINSTANCE, lTmp);

    // GWL_HWNDPARENT
    lTmp = GetWindowLong(hwnd, GWL_HWNDPARENT);
    if (lTmp)
        DebugDude();
    SetWindowLong(hwnd, GWL_HWNDPARENT, (DWORD)GetShellWindow());
    SetWindowLong(hwnd, GWL_HWNDPARENT, 0);

    hwndP = CreateWindowEx(0L, "combobox", NULL, WS_CHILD | WS_VISIBLE |
        WS_CLIPSIBLINGS | WS_DISABLED | CBS_SIMPLE, 12, 12, 124, 124,
        hwnd, NULL, hInst, NULL);
    hwndC = FindWindowEx(hwndP, NULL, "edit", NULL);
    SetWindowLong(hwndC, GWL_HWNDPARENT, (DWORD)hwnd);;
    if ((HWND)GetWindowLong(hwndC, GWL_HWNDPARENT) != hwnd)
        DebugDude();
    SetWindowLong(hwndC, GWL_HWNDPARENT, (DWORD)hwndP);
    DestroyWindow(hwndP);

    // GWL_ID
    lTmp = GetWindowLong(hwnd, GWL_ID);
    if (lTmp != (DWORD)GetMenu(hwnd))
        DebugDude();
    SetWindowLong(hwnd, GWL_ID, lTmp);

    // GWL_STYLE
    SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE));

    // GWL_EXSTYLE
    lTmp = GetWindowLong(hwnd, GWL_EXSTYLE);
    if (!(lTmp & WS_EX_WINDOWEDGE))
        DebugDude();

    // GWL_USERDATA
    SetWindowLong(hwnd, GWL_USERDATA, 0x12345678);
    if (GetWindowLong(hwnd, GWL_USERDATA) != 0x12345678)
        DebugDude();

    // Private data
    SetWindowLong(hwnd, 0, 0x86427531);
    if (GetWindowLong(hwnd, 0) != 0x86427531)
        DebugDude();

    if (SetWindowLong(hwnd, 4, 0x11122233) ||
        (GetWindowLong(hwnd, 4) == 0x11122233))
        DebugDude();

    if (GetWindowWord(hwnd, 0) != LOWORD(0x86427531))
        DebugDude();

    if (SetWindowWord(hwnd, 4, LOWORD(0x11122233)) ||
        (GetWindowWord(hwnd, 4) == LOWORD(0x11122233)))
        DebugDude();
}



// --------------------------------------------------------------------------
//
//  DoDrawState()
//
//  Tests DrawState().
//
// --------------------------------------------------------------------------
void DoDrawState(HWND hwnd)
{
    HDC hdc;
    HBRUSH hbr;
    HBITMAP hbmp;

    hdc = GetDC(hwnd);
    hbr = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));

    DrawState(hdc, GetStockObject(GRAY_BRUSH), NULL, (LPARAM)"F&ooBar", 6,
        4, 36, 100, 32, DST_PREFIXTEXT | DSS_UNION);
    DrawState(hdc, NULL, StateCallback, 0x12345678, 6, 4, 68, 100, 32,
        DST_COMPLEX | DSS_MONO);

    DrawState(hdc, hbr, NULL, (LPARAM)LoadCursor(NULL, IDC_ARROW), 0, 4, 100, 0, 0, DST_ICON | DSS_NORMAL);

    hbmp = LoadBitmap(NULL, MAKEINTRESOURCE(32739));
    DeleteObject(hbmp);

    DeleteObject(hbr);
    ReleaseDC(hwnd, hdc);
}


// --------------------------------------------------------------------------
//
//  StateCallback()
//
//  Owner-draw rendering for DrawState() image.
//
// --------------------------------------------------------------------------
BOOL CALLBACK StateCallback(HDC hdc, LPARAM lParam, WPARAM wParam, int cx, int cy)
{
    DrawIcon(hdc, 0, 0, LoadIcon(NULL, IDI_EXCLAMATION));
    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  HookProc()
//
//  For setting hook tests.
//
// --------------------------------------------------------------------------
LRESULT CALLBACK HookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  EnumPropsCallback()
//
// --------------------------------------------------------------------------
BOOL CALLBACK EnumPropsCallback(HWND hwnd, LPCSTR lpszName, DWORD dwProp)
{
    if (lstrcmp(lpszName, "MyDwordProp") || (dwProp != 0x12345678))
    {
        DebugDude();
    }

    fEnumCalled = TRUE;
    return(!fReturnFalse);
}


// --------------------------------------------------------------------------
//
//  EnumPropsExCallback()
//
// --------------------------------------------------------------------------
BOOL CALLBACK EnumPropsExCallback(HWND hwnd, LPCSTR lpszName, DWORD dwProp,
    LPARAM lParam)
{
    if (lstrcmp(lpszName, "MyDwordProp") || (dwProp != 0x12345678) ||
        (lParam != 0x12345678))
    {
        DebugDude();
    }

    fEnumCalled = TRUE;
    return(!fReturnFalse);
}


// --------------------------------------------------------------------------
//
//  VerifyB13406()
//
//  Verifies that B#13406 submitted by Excel32 is fixed:
//      (1) Change system colors
//      (2) On WM_SYSCOLORCHANGE, put up a message box
//              * If not hung, OK
//      (3) Call GetDC(NULL)
//      (4) Call GetPixel(hdc).  Is this 0xFFFFFFFF?
//      
// --------------------------------------------------------------------------
void VerifyB13406(HWND hwnd)
{
    HDC hdc;
    COLORREF rgb;

    if (fVB13406)
    {
        DebugDude();
        MessageBox(hwnd, "Test B#13406", "Test B#13406", MB_OK);

        hdc = GetDC(NULL);
        rgb = GetPixel(hdc, 0, 0);
        DebugBreak();

        fVB13406 = FALSE;
    }
}


// --------------------------------------------------------------------------
//
//  TestSubclassing()
//
//  Tests whether messages are thunked properly when someone does funky
//  stuff with control subclassing.  Even if the window doesn't have the
//  same class name as one of ours, like "button", we detect what kind
//  of window it is anyway in USER16.  Micrografx Designer and VB32 are
//  two apps that do this.
//
// --------------------------------------------------------------------------
LRESULT CALLBACK FakeControlProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    DWORD   dw;

    dw = GetClassLong(hwnd, GCL_CBCLSEXTRA) - 4;

    if (uMsg == WM_NCCREATE)
    {
        SetClassLong(hwnd, dw, (DWORD)((LPCREATESTRUCT)lParam)->lpCreateParams);
    }

    dw = GetClassLong(hwnd, dw);
    if (dw)
        return(CallWindowProc((WNDPROC)dw, hwnd, uMsg, wParam, lParam));
    else
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));
}

void TestSubclassing(HWND hWnd)
{
    WNDCLASSEX  wc;
    WNDPROC     lpfnWndProcOld;
    HWND        hwnd;

    //
    // BUTTON
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, "button", &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_button";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    //
    // Fake Button
    //

    // We have to create a window to change the class!
    hwnd = CreateWindowEx(0, "generic_button", "foo bar", WS_CHILD | BS_CHECKBOX,
        0, 0, 50, 50, hWnd, (HMENU)16, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, BM_CLICK, 0, 0L);
    CheckDlgButton(hWnd, 16, TRUE);

    DestroyWindow(hwnd);
    UnregisterClass("generic_button", hInst);

    //
    // Real Button
    //
    hwnd = CreateWindowEx(0, "button", "foo bar", WS_CHILD | BS_CHECKBOX,
        0, 0, 50, 50, hWnd, (HMENU)16, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }


    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, BM_CLICK, 0, 0L);
    CheckDlgButton(hWnd, 16, TRUE);

    DestroyWindow(hwnd);


    //
    // COMBO
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, "combobox", &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_combobox";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    //
    // Fake Combo
    //

    // We have to create a window to change the class!
    hwnd = CreateWindowEx(0, "generic_combobox", "", WS_CHILD | CBS_HASSTRINGS |
        CBS_DROPDOWN, 0, 0, 50, 50, hWnd, (HMENU)16, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)"FooBarDude");
    DlgDirListComboBox(hWnd, "*.*", 16, 0, DDL_DIRECTORY);

    DestroyWindow(hwnd);
    UnregisterClass("generic_combobox", hInst);

    //
    // Real Combo
    //
    // We have to create a window to change the class!
    hwnd = CreateWindowEx(0, "combobox", "", WS_CHILD | CBS_HASSTRINGS |
        CBS_DROPDOWN, 0, 0, 50, 50, hWnd, (HMENU)16, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)"FooBarDude");
    DlgDirListComboBox(hWnd, "*.*", 16, 0, DDL_DIRECTORY);

    DestroyWindow(hwnd);


    //
    // EDIT
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, "edit", &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_edit";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    //
    // Fake Edit
    //

    // We have to create a window to change the class!
    hwnd = CreateWindowEx(WS_EX_CLIENTEDGE, "generic_edit", "foo bar", WS_CHILD | ES_LEFT,
        0, 0, 50, 50, hWnd, (HMENU)16, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, EM_SETSEL, 0, 0);
    SendMessage(hwnd, WM_CONTEXTMENU, (WPARAM)hwnd, MAKELONG(25, 25));

    DestroyWindow(hwnd);
    UnregisterClass("generic_edit", hInst);

    //
    // Real Edit
    //
    hwnd = CreateWindowEx(WS_EX_CLIENTEDGE, "edit", "foo bar", WS_CHILD | ES_LEFT,
        0, 0, 50, 50, hWnd, (HMENU)16, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, EM_SETSEL, 0, 0);
    SendMessage(hwnd, WM_CONTEXTMENU, (WPARAM)hwnd, MAKELONG(25, 25));

    DestroyWindow(hwnd);

        
    //
    // LISTBOX
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, "listbox", &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_listbox";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    //
    // Fake Listbox
    //
    hwnd = CreateWindowEx(0, "generic_listbox", "", WS_CHILD | LBS_SORT |
        WS_BORDER | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS, 0, 0, 50, 50, hWnd,
        (HMENU)16, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, LB_ADDSTRING, 0, (LPARAM)"FooBarDude");
    DlgDirList(hWnd, "*.*", 16, 0, DDL_DIRECTORY);

    DestroyWindow(hwnd);
    UnregisterClass("generic_listbox", hInst);

    //
    // Real Listbox
    //
    hwnd = CreateWindowEx(0, "listbox", "", WS_CHILD | LBS_SORT |
        WS_BORDER | LBS_NOINTEGRALHEIGHT | LBS_HASSTRINGS, 0, 0, 50, 50, hWnd,
        (HMENU)16, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    SendMessage(hwnd, LB_ADDSTRING, 0, (LPARAM)"FooBarDude");
    DlgDirList(hWnd, "*.*", 16, 0, DDL_DIRECTORY);

    DestroyWindow(hwnd);


    //
    // MENU
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, MAKEINTRESOURCE(0x8000), &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_menu";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    //
    // Fake Menu
    //
    hwnd = CreateWindowEx(0, "generic_menu", "", WS_POPUP, 0, 0, 0, 0,
        hWnd, NULL, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    ShowWindow(hwnd, SW_SHOWNOACTIVATE);
    UpdateWindow(hwnd);

    SendMessage(hwnd, WM_KEYDOWN, VK_DOWN, 0L);

    DestroyWindow(hwnd);
    UnregisterClass("generic_menu", hInst);

    //
    // Real Menu
    //
    hwnd = CreateWindowEx(0, MAKEINTRESOURCE(0x8000), "", WS_POPUP, 0, 0, 0, 0,
        hWnd, NULL, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    UpdateWindow(hwnd);

    SendMessage(hwnd, WM_KEYDOWN, VK_DOWN, 0L);

    DestroyWindow(hwnd);


    //
    // SCROLLBAR
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, "scrollbar", &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_scrollbar";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    //
    // Fake Scrollbar
    //
    hwnd = CreateWindowEx(0, "generic_scrollbar", "", WS_CHILD | SBS_LEFTALIGN,
        0, 0, 50, 50, hWnd, (HMENU)16, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    EnableScrollBar(hwnd, SB_CTL, ESB_DISABLE_LEFT);
    SendMessage(hwnd, SBM_ENABLE_ARROWS, ESB_DISABLE_RIGHT, 0);

    DestroyWindow(hwnd);
    UnregisterClass("generic_scrollbar", hInst);

    //
    // Real Scrollbar
    //
    hwnd = CreateWindowEx(0, "scrollbar", "", WS_CHILD | SBS_LEFTALIGN,
        0, 0, 50, 50, hWnd, (HMENU)16, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    EnableScrollBar(hwnd, SB_CTL, ESB_DISABLE_LEFT);
    SendMessage(hwnd, SBM_ENABLE_ARROWS, ESB_DISABLE_RIGHT, 0);

    DestroyWindow(hwnd);


    //
    // STATIC
    //

    wc.cbSize = sizeof(wc);
    if (!GetClassInfoEx(NULL, "static", &wc))
    {
        DebugDude();
        return;
    }

    lpfnWndProcOld = wc.lpfnWndProc;
    wc.lpfnWndProc = FakeControlProc;
    wc.cbClsExtra += sizeof(WNDPROC);
    wc.lpszClassName = "generic_static";
    wc.hInstance = hInst;
    if (!RegisterClassEx(&wc))
    {
        DebugDude();
        return;
    }

    // 
    // Fake Static
    //
    hwnd = CreateWindowEx(0, "generic_static", "test static", WS_CHILD |
        SS_ICON, 0, 0, 50, 50, hWnd, (HMENU)16, hInst, (LPVOID)lpfnWndProcOld);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    SendMessage(hwnd, STM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadIcon(NULL, IDI_WINLOGO));

    DestroyWindow(hwnd);
    UnregisterClass("generic_static", hInst);

    //
    // Real Static
    //
    hwnd = CreateWindowEx(0, "static", "test static", WS_CHILD |
        SS_ICON, 0, 0, 50, 50, hWnd, (HMENU)16, hInst, NULL);
    if (!hwnd)
    {
        DebugDude();
        return;
    }

    SendMessage(hwnd, STM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadIcon(NULL, IDI_WINLOGO));

    DestroyWindow(hwnd);
}


// --------------------------------------------------------------------------
//
//  TestMDIGetActive()
//
// --------------------------------------------------------------------------
void TestMDIGetActive(HWND hwnd)
{
    BOOL    fMaxed = FALSE;
    HWND    hwndA;

    hwndA = (HWND)SendMessage(hwnd, WM_MDIGETACTIVE, 0, 0);
    if (hwndA != GetShellWindow())
    {
        DebugBreak();
    }

    hwndA = (HWND)SendMessage(hwnd, WM_MDIGETACTIVE, 0, (LPARAM)(LPBOOL)&fMaxed);
    if ((hwndA != GetShellWindow()) || !fMaxed)
    {
        DebugBreak();
    }
}


// --------------------------------------------------------------------------
//
//  TestMDISetMenu()
//
// --------------------------------------------------------------------------
void TestMDISetMenu(HWND hwnd)
{
    HMENU   hmenuOld;
    HMENU   hmenuFoo;
    HMENU   hmenuSys;

    hmenuSys = GetSystemMenu(hwnd, FALSE);
    hmenuFoo = GetMenu(hwnd);

    hmenuOld = (HMENU)SendMessage(hwnd, WM_MDISETMENU, (WPARAM)hmenuSys,
        (LPARAM)hmenuFoo);
    if (hmenuOld != hmenuFoo)
    {
        DebugBreak();
    }
}


// --------------------------------------------------------------------------
//
//  TestNextMenu()
//
// --------------------------------------------------------------------------
void TestNextMenu(HWND hwnd)
{
    MDINEXTMENU nm;

    nm.hmenuIn = GetMenu(hwnd);
    nm.hmenuNext = NULL;
    nm.hwndNext = NULL;

    if (!SendMessage(hwnd, WM_NEXTMENU, 0, (LPARAM)&nm))
    {
        DebugBreak();
    }
    else
    {
        if (nm.hmenuNext != GetSystemMenu(hwnd, FALSE))
        {
            DebugBreak();
        }

        if (nm.hwndNext != GetShellWindow())
        {
            DebugBreak();
        }
    }
}

void ControlPanel(int srcno, HWND hwnd)
{
	hDlgs[srcno] = CreateDialogParam ( hInst, "SoundControl", hwnd, lpfnCtrlPanelDlg, srcno ) ;
}

ControlPanelDialog ( HWND hDlg, UINT message, WPARAM wParam, LONG lParam )
{
	int	srcno ;

	if (message == WM_INITDIALOG) {
		srcno = lParam ;
	}
	else {
		for ( srcno = 0; srcno < MAX_SOUND_SOURCE; srcno++ ) {
			if ( hDlgs[srcno] == hDlg )
				break ;
		}
	}
	switch (message) {
		case WM_ACTIVATE:
			if ( LOWORD(wParam) == 0 ) {
				ghDlg = NULL ;
			}
			else {
				ghDlg = hDlg ;
			}
			break ;
		case WM_INITDIALOG:
			SetWindowText(hDlg, SndSrc[srcno].OFN.lpstrFile+
						SndSrc[srcno].OFN.nFileOffset) ;
			return TRUE ;
		case WM_COMMAND:
			switch (wParam) {
				case IDD_PLAY:
					PlayWave(srcno) ;
					break ;
				case IDD_STOP:
					StopWave(srcno) ;
					if ( !SrcIsFree[1])
						StopWave(1) ;
					break ;
				case IDOK:
				case IDCANCEL:
					StopWave(srcno) ;
					DestroyWave(srcno) ;
					RelMem(srcno) ;
					SrcIsFree[srcno] = TRUE ;
					SndSrc[srcno].fMixerExit = TRUE ;
					if ( !SrcIsFree[1]) {
						StopWave(1) ;
						DestroyWave(1) ;
						RelMem(1) ;
						SrcIsFree[1] = TRUE ;
						SndSrc[1].fMixerExit = TRUE ;
					}
					DestroyWindow ( hDlg ) ;
					ghDlg = NULL ;
					return TRUE ;
			}
			return TRUE ;
	}
	return FALSE ;
}

BOOL GetWaveFile (int srcno, BOOL def)
{

	SndSrc[srcno].OFN.lpstrFile = szWaveFileName;
	if ( !def ) {
		SndSrc[srcno].OFN.lStructSize = sizeof(OPENFILENAME);
		SndSrc[srcno].OFN.hwndOwner = hWind;
		SndSrc[srcno].OFN.lpstrFileTitle = 0;
		SndSrc[srcno].OFN.nMaxCustFilter = CCHFILTERMAX;
		SndSrc[srcno].OFN.nFilterIndex = 1;
		SndSrc[srcno].OFN.nMaxFile = CCHFILENAMEMAX;
		SndSrc[srcno].OFN.lpfnHook = NULL;
		SndSrc[srcno].OFN.Flags = 0L;/* for now, since there's no readonly support */
		SndSrc[srcno].OFN.lpstrTitle = NULL;
		SndSrc[srcno].OFN.lpstrInitialDir = NULL;
	
		SndSrc[srcno].OFN.lpstrFilter  = &WaveFilter[0] ;
		SndSrc[srcno].OFN.lpstrCustomFilter = NULL ;
		SndSrc[srcno].OFN.lpstrDefExt = "WAV";  /* points to */
		SndSrc[srcno].OFN.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
	
		if (GetOpenFileName ((LPOPENFILENAME)&SndSrc[srcno].OFN)) {
			SndSrc[srcno].GotWaveFile = TRUE ;
		}
		else {
			SrcIsFree[srcno] = TRUE ;
			return FALSE ;
		}
	}
	else {
		strcpy ( SndSrc[srcno].OFN.lpstrFile, DefFiles[srcno] ) ;
		SndSrc[srcno].GotWaveFile = TRUE ;
	}
	if ( !ReadWaveFile(srcno) )
		return FALSE ;

	return TRUE ;
}



					  
void PlayWave(int srcno)
{
	PKSPIN_CONNECT   pConnect;
	OVERLAPPED  ov;
	ULONG		cbReturned ;

	if ( !SndSrc[srcno].hMixerSink ) {
		if (NULL == (pConnect = HeapAlloc( GetProcessHeap(), 0, 
       	                         sizeof( KSPIN_CONNECT ) + 
              	                     sizeof( KSDATAFORMAT_DIGITAL_AUDIO ) )))
			return ;

		RtlZeroMemory( &ov, sizeof( OVERLAPPED ) );
		if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ))) {
			HeapFree( GetProcessHeap(), 0, pConnect );
			return ;
		}


		pConnect->idPin = 1;  // KMIXER SINK
		// no "connect to"
		pConnect->hPinTo = NULL;
		pConnect->Interface.guidSet = KSINTERFACESETID_Standard;
		pConnect->Interface.id = KSINTERFACE_STANDARD_WAVE_QUEUED;
		pConnect->Transport.guidSet = KSTRANSPORTSETID_Standard;
		pConnect->Transport.id = KSTRANSPORT_STANDARD_DEVIO;
		pConnect->Priority.ulPriorityClass = KSPRIORITY_NORMAL;
		pConnect->Priority.ulPrioritySubClass = 0;

		SetFormat( (PKSDATAFORMAT_DIGITAL_AUDIO) (pConnect + 1) );
		if (!WvControl( hMixerHandle,
			(DWORD) IOCTL_KS_CONNECT,
			pConnect,
			sizeof( KSPIN_CONNECT ) + 
			sizeof( KSDATAFORMAT_DIGITAL_AUDIO ),
			&SndSrc[srcno].hMixerSink,
			sizeof( HANDLE ),
			&cbReturned ) || !cbReturned) {

			HeapFree( GetProcessHeap(), 0, pConnect );
			return ;
		}
	}

	WriteFile ( SndSrc[srcno].hMixerSink,
			&SndSrc[srcno].WaveHeader,
			sizeof(WAVEHDR),
			&SndSrc[srcno].cbWritten,
			&SndSrc[srcno].Ov ) ;
	
	if (!MixerRunning) {
		WvSetState ( SndSrc[srcno].hMixerSink, KSSTATE_RUN ) ;
		MixerRunning = TRUE ;
	}
}

BOOL ReadWaveFile(srcno)
{
	HFILE FileHandle ;
	OFSTRUCT of ;
	LONG hiseek ;
	DWORD	i ;
	UCHAR	ch ;

	FileHandle = OpenFile ( SndSrc[srcno].OFN.lpstrFile,
					&of,
 					OF_READ )  ;
	if ( FileHandle == HFILE_ERROR ) {
		i = GetLastError() ;
		return FALSE ;
	}
	hiseek = 0 ;
	SetFilePointer ((HANDLE)FileHandle, 0x10, &hiseek, FILE_BEGIN) ;
	ReadFile ((HANDLE)FileHandle,
			&SndSrc[srcno].WaveFileHeader,
			sizeof(struct _wvhdr),
			&hiseek,
			NULL) ;
	SndSrc[srcno].TotalSamples = SndSrc[srcno].WaveFileHeader.Size/(2*SndSrc[srcno].WaveFileHeader.Channels) ;
	SndSrc[srcno].TmpBuf = GlobalAlloc ( GMEM_FIXED, SndSrc[srcno].WaveFileHeader.Size ) ;
	ReadFile ((HANDLE)FileHandle, SndSrc[srcno].TmpBuf, SndSrc[srcno].WaveFileHeader.Size, &hiseek, NULL ) ;
	_lclose(FileHandle) ;

	SndSrc[srcno].WaveHeader.lpData = SndSrc[srcno].TmpBuf;
	SndSrc[srcno].WaveHeader.dwBufferLength = SndSrc[srcno].WaveFileHeader.Size ;
	SndSrc[srcno].WaveHeader.dwLoops = 0 ;
	SndSrc[srcno].WaveHeader.lpNext = NULL ;
	return TRUE ;
}

void Play(int srcno)
{
}

void StopWave(int srcno)
{
}

void InitPCMBuf(srcno)
{
	SndSrc[srcno].PCM = GlobalAlloc ( GMEM_FIXED, SndSrc[srcno].TotalSamples*4 ) ;
}

void DestroyWave(int srcno)
{
}

void RelMem(int srcno)
{
	if (GlobalFree(SndSrc[srcno].TmpBuf))
		DebugDude();
	if (GlobalFree(SndSrc[srcno].PCM))
		DebugDude();
}

int GetFreeSrc()
{
	int i ;

	for ( i = 0; i < MAX_SOUND_SOURCE; i++ ) {
		if (SrcIsFree[i]) {
			SrcIsFree[i] = FALSE ;
			SndSrc[i].IsPlaying = FALSE ;
			SndSrc[i].hMixerSink = NULL ;
			GridHnd[i] = FALSE ;
			SndSrc[i].JoyCaptured = FALSE ;
			SndSrc[i].fMixerExit = FALSE ;
			return (i+1) ;
		}
	}
	return (0) ;

}

BOOL SetupFilterGraph ( PHANDLE phMixerHandle )
{
	PKSPIN_CONNECT   pConnect;
	HANDLE	hSB16, hWaveBuff, hMixer, hWaveBuffConnection ;
	ULONG	cbReturned ;

	*phMixerHandle = NULL ;

	hSB16 = CreateFile( "\\\\.\\SB16",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
			NULL );

	if ( hSB16 == NULL )
		return ( FALSE ) ;

	hWaveBuff = CreateFile( "\\\\.\\WAVEBUFF",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
			NULL );

	if ( hWaveBuff == NULL ) {
		CloseHandle ( hSB16 ) ;
		return ( FALSE ) ;
	}

	hMixer = CreateFile( "\\\\.\\KMIXER",
			GENERIC_READ | GENERIC_WRITE,
			0,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
			NULL );

	if ( hMixer == NULL ) {
		CloseHandle ( hSB16 ) ;
		CloseHandle ( hWaveBuff ) ;
		return ( FALSE ) ;
	}

	if (NULL == (pConnect = HeapAlloc( GetProcessHeap(), 0, 
                                sizeof( KSPIN_CONNECT ) + 
                                   sizeof( KSDATAFORMAT_DIGITAL_AUDIO ) )))
		return (FALSE) ;

	pConnect->idPin = 2;  // SOUNDPRT DAC SINK
	// no "connect to"
	pConnect->hPinTo = NULL;
	pConnect->Interface.guidSet = KSINTERFACESETID_Standard;
	pConnect->Interface.id = KSINTERFACE_STANDARD_WAVE_BUFFERED;
	pConnect->Transport.guidSet = KSTRANSPORTSETID_Standard;
	pConnect->Transport.id = KSTRANSPORT_STANDARD_DEVIO;
	pConnect->Priority.ulPriorityClass = KSPRIORITY_NORMAL;
	pConnect->Priority.ulPrioritySubClass = 0;

	SetFormat( (PKSDATAFORMAT_DIGITAL_AUDIO) (pConnect + 1) );

	if (!WvControl( hSB16,
                (DWORD) IOCTL_KS_CONNECT,
                pConnect,
                sizeof( KSPIN_CONNECT ) + 
                   sizeof( KSDATAFORMAT_DIGITAL_AUDIO ),
                &hSB16Sink,
                sizeof( HANDLE ),
                &cbReturned ) || !cbReturned) {

	_asm {int 3}
		HeapFree( GetProcessHeap(), 0, pConnect );
		CloseHandle( hWaveBuff );
		CloseHandle( hSB16 );
		CloseHandle( hMixer );
		return ( FALSE ) ;
	}


	pConnect->idPin = 0;  // WAVEBUFF SOURCE
	pConnect->hPinTo = hSB16Sink;
	pConnect->Interface.guidSet = KSINTERFACESETID_Standard;
	pConnect->Interface.id = KSINTERFACE_STANDARD_WAVE_BUFFERED;
	pConnect->Transport.guidSet = KSTRANSPORTSETID_Standard;
	pConnect->Transport.id = KSTRANSPORT_STANDARD_DEVIO;
	pConnect->Priority.ulPriorityClass = KSPRIORITY_NORMAL;
	pConnect->Priority.ulPrioritySubClass = 0;

	if (!WvControl( hWaveBuff,
                (DWORD) IOCTL_KS_CONNECT,
                pConnect,
                sizeof( KSPIN_CONNECT ) + 
                   sizeof( KSDATAFORMAT_DIGITAL_AUDIO ),
                &hWaveBuffConnection,
                sizeof( HANDLE ),
                &cbReturned ) || !cbReturned) {
	_asm {int 3}
		HeapFree( GetProcessHeap(), 0, pConnect );
		CloseHandle( hSB16Sink );
		CloseHandle( hWaveBuff );
		CloseHandle( hSB16 );
		CloseHandle( hMixer );
		return ( FALSE ) ;
	}

	pConnect->idPin = 1;  // WAVEBUFF SINK
	// no "connect to"
	pConnect->hPinTo = NULL;
	pConnect->Interface.guidSet = KSINTERFACESETID_Standard;
	pConnect->Interface.id = KSINTERFACE_STANDARD_WAVE_QUEUED;
	pConnect->Transport.guidSet = KSTRANSPORTSETID_Standard;
	pConnect->Transport.id = KSTRANSPORT_STANDARD_DEVIO;
	pConnect->Priority.ulPriorityClass = KSPRIORITY_NORMAL;
	pConnect->Priority.ulPrioritySubClass = 0;

	if (!WvControl( hWaveBuff,
			(DWORD) IOCTL_KS_CONNECT,
			pConnect,
			sizeof( KSPIN_CONNECT ) + 
			sizeof( KSDATAFORMAT_DIGITAL_AUDIO ),
			&hWaveBuffSink,
			sizeof( HANDLE ),
			&cbReturned ) || !cbReturned) {

	_asm {int 3}
		HeapFree( GetProcessHeap(), 0, pConnect );
		CloseHandle( hWaveBuffConnection );
		CloseHandle( hWaveBuff );
		CloseHandle( hSB16Sink ) ;
		CloseHandle( hSB16 );
		CloseHandle( hMixer );
		return ( FALSE ) ;
	}

	pConnect->idPin = 0;  // KMIXER SOURCE
	pConnect->hPinTo = hWaveBuffSink;
	pConnect->Interface.guidSet = KSINTERFACESETID_Standard;
	pConnect->Interface.id = KSINTERFACE_STANDARD_WAVE_QUEUED;
	pConnect->Transport.guidSet = KSTRANSPORTSETID_Standard;
	pConnect->Transport.id = KSTRANSPORT_STANDARD_DEVIO;
	pConnect->Priority.ulPriorityClass = KSPRIORITY_NORMAL;
	pConnect->Priority.ulPrioritySubClass = 0;

	if (!WvControl( hMixer,
                (DWORD) IOCTL_KS_CONNECT,
                pConnect,
                sizeof( KSPIN_CONNECT ) + 
                   sizeof( KSDATAFORMAT_DIGITAL_AUDIO ),
                &hWaveBuffConnection,
                sizeof( HANDLE ),
                &cbReturned ) || !cbReturned) {
	_asm {int 3}
		HeapFree( GetProcessHeap(), 0, pConnect );
		CloseHandle( hMixer );
		CloseHandle( hWaveBuffSink );
		CloseHandle( hSB16Sink );
		CloseHandle( hWaveBuff );
		CloseHandle( hSB16 );
		return ( FALSE ) ;
	}
	*phMixerHandle = hMixer ;
	WvSetState ( hWaveBuffSink, KSSTATE_RUN ) ;
	WvSetState ( hSB16Sink, KSSTATE_RUN ) ;
	return (TRUE) ;
}

void SetFormat (pAudioFormat)
PKSDATAFORMAT_DIGITAL_AUDIO pAudioFormat ;
{
   pAudioFormat->DataFormat.guidMajorFormat = KSDATAFORMAT_TYPE_DIGITAL_AUDIO;
   pAudioFormat->DataFormat.cbFormat = sizeof( KSDATAFORMAT_DIGITAL_AUDIO );
   pAudioFormat->DataFormat.guidSubFormat = GUID_NULL;
   pAudioFormat->idFormat = WAVE_FORMAT_PCM;
   pAudioFormat->cChannels = 2;
   pAudioFormat->ulSamplingFrequency = 22000;
   pAudioFormat->cbFramingAlignment = 4;
   pAudioFormat->cBitsPerSample = 16;
}


BOOL WvControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
)
{
   BOOL        fResult;
   OVERLAPPED  ov;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) );
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
      return FALSE;

   fResult =
      DeviceIoControl( hDevice,
                       dwIoControl,
                       pvIn,
                       cbIn,
                       pvOut,
                       cbOut,
                       pcbReturned,
                       &ov );


   if (!fResult)
   {
      if (ERROR_IO_PENDING == GetLastError())
      {
         WaitForSingleObject( ov.hEvent, INFINITE );
         fResult = TRUE;
      }
      else
         fResult = FALSE;
   }

   CloseHandle( ov.hEvent );

   return fResult;

}

VOID WvSetState
(
   HANDLE         hDevice,
   KSSTATE        DeviceState
)
{
   KSPROPERTY   Property;
   ULONG        cbReturned;

   Property.guidSet = KSPROPSETID_Control;
   Property.id = KSPROPERTY_CONTROL_STATE;

   WvControl( hDevice,
              (DWORD) IOCTL_KS_SET_PROPERTY,
              &Property,
              sizeof( KSPROPERTY ),
              &DeviceState,
              sizeof( KSSTATE ),
              &cbReturned );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testlib\wavetool.c ===
//--------------------------------------------------------------------------;
//
//  File: WaveUtil.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Contains general utilities mostly to do with wave.
//
//  Contents:
//      wfxCpy()
//      wfxCmp()
//      GetFormatName()
//      FormatFlag_To_Format()
//
//  History:
//      11/24/93    Fwong       Re-doing WaveTest.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include "waveutil.h"

#ifdef  WIN32
#ifndef _HUGE
#define _HUGE
#endif
#ifndef lstrcpyn
#define lstrcpyn strncpy
#endif
#else
#ifndef _HUGE
#define _HUGE   huge
#endif
#endif   

//==========================================================================;
//
//                            Structures...
//
//==========================================================================;

typedef struct enumtype_tag
{
    DWORD           dwCount;
    DWORD           dwTarget;
} ENUMTYPE;
typedef ENUMTYPE        *PENUMTYPE;
typedef ENUMTYPE NEAR   *NPENUMTYPE;
typedef ENUMTYPE FAR    *LPENUMTYPE;


//--------------------------------------------------------------------------;
//
//  BOOL BufferCompare
//
//  Description:
//      Compares the contents of two buffers.
//
//      Note: This *needs* to work across segments _fmemcmp may not always
//            work.
//
//  Arguments:
//      LPBYTE pSrc: Pointer to first buffer.
//
//      LPBYTE pDst: Pointer to second buffer.
//
//      DWORD dwSize: Number of bytes to compare.
//
//  Return (BOOL):
//      returns TRUE if contents are similar, FALSE otherwise.
//
//  History:
//      08/23/93    Fwong       To verify structure similarity.
//
//--------------------------------------------------------------------------;

BOOL mem_cmp
(
    LPBYTE  pSrc,
    LPBYTE  pDst,
    DWORD   dwSize
)
{
    BYTE _HUGE *pSource;
    BYTE _HUGE *pDestination;

    pSource      = pSrc;
    pDestination = pDst;

    for(;dwSize;dwSize--)
    {
        if(pSource[(dwSize-1)] != pDestination[(dwSize-1)])
        {
            return FALSE;
        }
    }

    return TRUE;
} // mem_cmp()


//--------------------------------------------------------------------------;
//
//  void wfxCpy
//
//  Description:
//      Copies one wave format to another...  Independent of size.
//      Uses cbSize (if not PCM) to determine number of remaining bytes.
//
//  Arguments:
//      LPWAVEFORMATEX lpwfxDst: Destination wave format.
//
//      LPWAVEFORMATEX lpwfxSrc: Source wave format.
//
//  Return (void):
//
//  History:
//      03/27/93    Fwong       Created to facilitate things...
//
//--------------------------------------------------------------------------;

void FNGLOBAL wfxCpy
(
    LPWAVEFORMATEX  pwfxDst,
    LPWAVEFORMATEX  pwfxSrc
)
{
    DWORD   dwBufferSize;

    //
    //  Warning!!!  Assumes no cross segment copying...
    //

    dwBufferSize = SIZEOFWAVEFORMAT(pwfxSrc);

    if(IsBadWritePtr(pwfxDst,(UINT)dwBufferSize))
    {
        return;
    }

    //
    //  Warning!!!  Will not work with formats > 64K for Win16
    //

    _fmemcpy(pwfxDst,pwfxSrc,(UINT)dwBufferSize);

} // wfxCpy()


//--------------------------------------------------------------------------;
//
//  BOOL wfxCmp
//
//  Description:
//      Compares the contents of the two WAVEFORMATEX structures.
//          Note: Does intelligent compare including contents after cbSize.
//
//  Arguments:
//      LPWAVEFORMATEX pwfxSrc: Pointer to first WAVEFORMATEX structure.
//
//      LPWAVEFORMATEX pwfxDst: Pointer to second WAVEFORMATEX structure.
//
//  Return (BOOL):
//      TRUE if formats are similar, FALSE otherwise.
//
//  History:
//      08/25/93    Fwong       To verify structure similarity.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL wfxCmp
(
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst
)
{
    DWORD   dwBufferSize;

    if(pwfxSrc->wFormatTag != pwfxDst->wFormatTag)
    {
        //
        //  Hmm... Format tags are different.
        //

        return FALSE;
    }

    dwBufferSize = SIZEOFWAVEFORMAT(pwfxSrc);

    if(dwBufferSize != (DWORD)SIZEOFWAVEFORMAT(pwfxDst))
    {
        return FALSE;
    }

    //
    //  Note: Not using _fmemcmp since this *has* to work across segments
    //        Which means with huge pointers.  _fmemset does not use
    //        huge pointers w/ medium model, nor does it ever use it w/
    //        intrinsic version.
    //
    
    return (mem_cmp((LPBYTE)pwfxSrc,(LPBYTE)pwfxDst,dwBufferSize));

} // wfxCmp()


//--------------------------------------------------------------------------;
//
//  void GetFormatString
//
//  Description:
//      Gets a string representation for the given format.
//
//  Arguments:
//      LPSTR pszFormat: Buffer to store the string in.
//
//      LPWAVEFORMATEX pwfx: The format in question.
//
//      DWORD cbSize: Size (in bytes) of the string buffer.
//
//  Return (void):
//
//  History:
//      11/30/93    Fwong       Doing this function one more time!!
//
//--------------------------------------------------------------------------;

void FNGLOBAL GetFormatName
(
    LPSTR           pszFormat,
    LPWAVEFORMATEX  pwfx,
    DWORD           cbSize
)
{
    ACMFORMATDETAILS    afd;
    ACMFORMATTAGDETAILS aftd;
    MMRESULT            mmr;
    DWORD               dw;
    char                szFormat[MAXFMTSTR];

    dw = SIZEOFWAVEFORMAT(pwfx);

    aftd.cbStruct         = sizeof(ACMFORMATTAGDETAILS);
    aftd.dwFormatTagIndex = 0L;
    aftd.dwFormatTag      = (DWORD)pwfx->wFormatTag;
    aftd.fdwSupport       = 0L;

    mmr = acmFormatTagDetails(NULL,&aftd,ACM_FORMATTAGDETAILSF_FORMATTAG);

    if(MMSYSERR_NOERROR != mmr)
    {
        pszFormat[0] = 0;
        return;
    }

    afd.cbStruct      = sizeof(ACMFORMATDETAILS);
    afd.dwFormatIndex = 0L;
    afd.dwFormatTag   = (DWORD)pwfx->wFormatTag;
    afd.fdwSupport    = 0L;
    afd.pwfx          = pwfx;
    afd.cbwfx         = dw;

    mmr = acmFormatDetails(NULL,&afd,ACM_FORMATDETAILSF_FORMAT);

    if(MMSYSERR_NOERROR != mmr)
    {
        pszFormat[0] = 0;
        return;
    }

    wsprintf(szFormat,"%s %s",(LPSTR)aftd.szFormatTag,(LPSTR)afd.szFormat);

    dw = (DWORD)(lstrlen(szFormat)+1);
    dw = min(dw,cbSize);

    lstrcpyn(pszFormat,szFormat,(int)dw);

} // GetFormatName()


//--------------------------------------------------------------------------;
//
//  BOOL FormatFlag_To_Format
//
//  Description:
//      Returns a standard PCM format from a given format flag.
//          Format flags are based on WAVEXCAPS.
//
//  Arguments:
//      DWORD dwMask: Format Mask.
//
//      LPPCMWAVEFORMAT ppcmwf: Buffer for PCM wave format.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      12/01/93    Fwong       Re-done for WaveTest.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL FormatFlag_To_Format
(
    DWORD           dwMask,
    LPPCMWAVEFORMAT ppcmwf
)
{
    LPWAVEFORMATEX  pwfx;

    if(0 == (dwMask & VALID_FORMAT_FLAGS))
    {
        //
        //  Not valid format flag!!
        //

        return FALSE;
    }

    pwfx = (LPWAVEFORMATEX)ppcmwf;

    pwfx->wFormatTag      = WAVE_FORMAT_PCM;
    pwfx->nSamplesPerSec  = 11025;

    for(;dwMask & 0xfffffff0;dwMask /= 0x10)
    {
        pwfx->nSamplesPerSec *= 2;
    }

    switch (dwMask)
    {
        case WAVE_FORMAT_1M08:
            pwfx->nChannels      = 1;
            pwfx->wBitsPerSample = 8;
            break;

        case WAVE_FORMAT_1S08:
            pwfx->nChannels      = 2;
            pwfx->wBitsPerSample = 8;
            break;

        case WAVE_FORMAT_1M16:
            pwfx->nChannels      = 1;
            pwfx->wBitsPerSample = 16;
            break;

        case WAVE_FORMAT_1S16:
            pwfx->nChannels      = 2;
            pwfx->wBitsPerSample = 16;
            break;
    }

    //
    //  Note: This may not work with 12 bit samples
    //        if they're done pairwise...
    //

    pwfx->nBlockAlign     = (pwfx->nChannels * pwfx->wBitsPerSample) / 8;
    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
} // FormatFlag_To_Format()


//--------------------------------------------------------------------------;
//
//  void GetWaveInDriverName
//
//  Description:
//      Given a device ID, retrieves a driver name.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      LPSTR pszDriverName: Buffer to store driver name.
//
//      DWORD cbSize: Size (in bytes) of buffer.
//
//  Return (void):
//
//  History:
//      02/18/94    Fwong       Another random thing.
//
//--------------------------------------------------------------------------;

void FNGLOBAL GetWaveOutDriverName
(
    UINT    uDeviceID,
    LPSTR   pszDriverName,
    DWORD   cbSize
)
{
    WAVEOUTCAPS woc;
    MMRESULT    mmr;
    DWORD       dw;

    mmr = waveOutGetDevCaps(uDeviceID,&woc,sizeof(WAVEOUTCAPS));

    dw = (DWORD)(lstrlen(woc.szPname)+1);
    dw = min(dw,cbSize);

    lstrcpyn(pszDriverName,woc.szPname,(int)dw);
} // GetWaveOutDriverName()


//--------------------------------------------------------------------------;
//
//  void GetWaveOutDriverName
//
//  Description:
//      Given a device ID, retrieves a driver name.
//
//  Arguments:
//      UINT uDeviceID: Device ID.
//
//      LPSTR pszDriverName: Buffer to store driver name.
//
//      DWORD cbSize: Size (in bytes) of buffer.
//
//  Return (void):
//
//  History:
//      02/18/94    Fwong       Another random thing.
//
//--------------------------------------------------------------------------;

void FNGLOBAL GetWaveInDriverName
(
    UINT    uDeviceID,
    LPSTR   pszDriverName,
    DWORD   cbSize
)
{
    WAVEINCAPS  wic;
    MMRESULT    mmr;
    DWORD       dw;

    mmr = waveInGetDevCaps(uDeviceID,&wic,sizeof(WAVEINCAPS));

    dw = (DWORD)(lstrlen(wic.szPname)+1);
    dw = min(dw,cbSize);

    lstrcpyn(pszDriverName,wic.szPname,(int)dw);
} // GetWaveInDriverName()


//--------------------------------------------------------------------------;
//
//  LRESULT FormatEnumCB
//
//  Description:
//      Callback for enumerating formats.
//
//  Arguments:
//      HACMDRIVERID hadid: Handle to ACM driver.
//
//      LPACMFORMATDETAILS pafd: Pointer to info structure.
//
//      DWORD dwInstance: In our case, pointer to ENUMTYPE structure.
//
//      DWORD fdwSupport: from API call.
//
//  Return (LRESULT):
//      FALSE if finished enumerating, TRUE otherwise.
//
//  History:
//      07/05/93    Fwong       For easy enumeration of ACM's format.
//      08/01/93    Fwong       Logic changed to match Window's Enum.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT FormatEnumCB
(
    HACMDRIVERID        hadid,
    LPACMFORMATDETAILS  pafd,
    DWORD               dwInstance,
    DWORD               fdwSupport
)
{
    LPENUMTYPE  pet = (LPENUMTYPE)(dwInstance);

    if(pet->dwTarget == pet->dwCount)
    {
        //
        //  Keep count accurate and stop enumerating.
        //

        (pet->dwCount)++;
        return (FALSE);
    }

    (pet->dwCount)++;
    return (TRUE);
} // FormatEnumCB()


//--------------------------------------------------------------------------;
//
//  DWORD GetNumFormats
//
//  Description:
//      This funtion returns the number of standard formats supported by
//          driver for all format tags.
//
//  Arguments:
//      None.
//
//  Return (DWORD):
//      The actual number of formats.
//
//  History:
//      09/08/93    Fwong       Generalizing to include all tags.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL GetNumFormats
(
    void
)
{
    ENUMTYPE            et;
    ACMFORMATDETAILS    afd;
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    HGLOBAL             hmem;
    DWORD               dwMaxSize;

    mmr = acmMetrics(NULL,ACM_METRIC_MAX_SIZE_FORMAT,&dwMaxSize);

    if(MMSYSERR_NOERROR != mmr)
    {
        return 0L;
    }

    hmem = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,dwMaxSize);

    if(NULL == hmem)
    {
        //
        //  GlobalAlloc failed...
        //

        return 0L;
    }

    pwfx = (LPWAVEFORMATEX)GlobalLock(hmem);

    et.dwCount  = 0L;
    et.dwTarget = (DWORD)(-1);

    afd.cbStruct         = sizeof(afd);
    afd.pwfx             = pwfx;
    afd.cbwfx            = dwMaxSize;
    afd.pwfx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    afd.fdwSupport       = 0L;

    mmr = acmFormatEnum(NULL,&afd,FormatEnumCB,(DWORD)(LPENUMTYPE)&et,0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        et.dwCount = 0L;
    }

    //
    //  Cleaning up...
    //

    GlobalUnlock(hmem);
    GlobalFree(hmem);

    return (et.dwCount);
} // GetNumFormats()


//--------------------------------------------------------------------------;
//
//  BOOL GetFormat
//
//  Description:
//      This function returns the wave format according to the index.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Return buffer for format.
//
//      DWORD cbwfx: Size of format.
//
//      DWORD dwIndex: Index to enumerate to.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      09/08/93    Fwong       Generalizing to include all tags.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL GetFormat
(
    LPWAVEFORMATEX  pwfx,
    DWORD           cbwfx,
    DWORD           dwIndex
)
{
    ENUMTYPE            et;
    ACMFORMATDETAILS    afd;
    MMRESULT            mmr;
    HGLOBAL             hmem;
    DWORD               dwMaxSize;
    LPWAVEFORMATEX      pwfxTemp;

    mmr = acmMetrics(NULL,ACM_METRIC_MAX_SIZE_FORMAT,&dwMaxSize);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  acmMetrics failed....
        //

        return FALSE;
    }

    hmem = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,dwMaxSize);

    if(NULL == hmem)
    {
        //
        //  GlobalAlloc failed...
        //

        return (FALSE);
    }

    pwfxTemp = GlobalLock(hmem);

    et.dwCount  = 0L;
    et.dwTarget = dwIndex;

    afd.cbStruct         = sizeof(afd);
    afd.pwfx             = pwfxTemp;
    afd.cbwfx            = dwMaxSize;
    afd.pwfx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    afd.fdwSupport       = 0L;

    mmr = acmFormatEnum(NULL,&afd,FormatEnumCB,(DWORD)(LPENUMTYPE)&et,0L);

    if(MMSYSERR_NOERROR != mmr)
    {
        GlobalUnlock(hmem);
        GlobalFree(hmem);

        return (FALSE);
    }

    //
    //  Cleaning up...
    //

    dwMaxSize = SIZEOFWAVEFORMAT(pwfxTemp);

    if(dwMaxSize > cbwfx)
    {
        //
        //  We don't have enough room?!
        //

        GlobalUnlock(hmem);
        GlobalFree(hmem);

        return (FALSE);
    }

    wfxCpy(pwfx,pwfxTemp);

    GlobalUnlock(hmem);
    GlobalFree(hmem);

    return (TRUE);
} // GetFormatNumber()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\testmix\testmix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       testmix.h
//
//--------------------------------------------------------------------------

#define IDM_OPEN		101
#define IDM_PLAY	       102
#define IDM_CONTROLS		103
#define IDM_EXIT            104


#define IDM_ABOUT		201

#define IDD_PLAY		301
#define IDD_STOP		302
#define IDD_LEFT		303
#define IDD_CENTER		304
#define IDD_RIGHT		305
#define IDD_HSCROLL		306
#define IDD_VSCROLL		307
#define IDD_SECOND		308

#define IDD_AUTO		309
#define IDD_MAN		310

#define IDD_DSENUMBOX	320

#define IDC_DSENUM_COMBO    1001

#define DLG_VERFIRST        400
#define DLG_VERLAST         004

#define IDS_ERRORMSG        1
#define IDS_MSGBOXTEXT      2
#define IDS_MSGBOXCAPTION   3


BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK About  (HWND, UINT, WPARAM, LPARAM);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\topotest\topotest.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    topotest.c

Abstract:

    Topology port test.

--*/

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <devioctl.h>

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>

#include <mmsystem.h>
#include <mmreg.h>
#include <ks.h>
#include <ksmedia.h>

#include <audprop.h>

BOOL
HandleControl
(
    HANDLE   DeviceHandle,
    DWORD    IoControl,
    PVOID    InBuffer,
    ULONG    InSize,
    PVOID    OutBuffer,
    ULONG    OutSize,
    PULONG   BytesReturned
)
{
    BOOL            IoResult;
    OVERLAPPED      Overlapped;

    RtlZeroMemory(&Overlapped, sizeof(OVERLAPPED));
    if (!(Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        printf("ERROR:  failed to create event\n");
        return FALSE;
    }
    IoResult = DeviceIoControl(DeviceHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, BytesReturned, &Overlapped);
    if (!IoResult && (ERROR_IO_PENDING == GetLastError())) 
    {
        WaitForSingleObject(Overlapped.hEvent, INFINITE);
        IoResult = TRUE;
    }
    else
    if (!IoResult)
    {
        printf("ERROR:  DeviceIoControl:  0x%08x\n",GetLastError());
        *BytesReturned = 0;
    }

    CloseHandle(Overlapped.hEvent);
    return IoResult;
}

HANDLE
CreatePin
(
    HANDLE  FilterHandle
)
{
    HANDLE  pinHandle;
    struct
    {
        KSPIN_CONNECT   Connect;
        KSDATAFORMAT    Format;
    }       Connect;

    Connect.Connect.Interface.Set               = KSINTERFACESETID_Standard;
    Connect.Connect.Interface.Id                = KSINTERFACE_STANDARD_STREAMING;
    Connect.Connect.Interface.Flags             = 0;
    Connect.Connect.Medium.Set                  = KSMEDIUMSETID_Standard;
    Connect.Connect.Medium.Id                   = KSMEDIUM_STANDARD_DEVIO;
    Connect.Connect.Medium.Flags                = 0;
    Connect.Connect.PinId                       = 0;
    Connect.Connect.PinToHandle                 = NULL;
    Connect.Connect.Priority.PriorityClass      = KSPRIORITY_NORMAL;
    Connect.Connect.Priority.PrioritySubClass   = 0;
    Connect.Format.FormatSize                   = sizeof(KSDATAFORMAT);
    Connect.Format.Reserved                     = 0;
    Connect.Format.MajorFormat                  = KSDATAFORMAT_FORMAT_NONE;
    Connect.Format.SubFormat                    = KSDATAFORMAT_FORMAT_NONE;
    Connect.Format.Specifier                    = KSDATAFORMAT_FORMAT_NONE;

    if (KsCreatePin(FilterHandle,(PKSPIN_CONNECT) &Connect,&pinHandle))
    {
        return NULL;
    }

    return pinHandle;
}

struct
{
    char *  Name;
    BOOLEAN FloatValues;
} 
Types[] =
{
    { "AudioInternalSource",    FALSE   },
    { "AudioExternalSource",    FALSE   },
    { "AudioInternalDest",      FALSE   },
    { "AudioExternalDest",      FALSE   },
    { "AudioVirtualDest",       FALSE   },
    { "AudioMix",               FALSE   },
    { "AudioMux",               FALSE   },
    { "AudioVolume",            TRUE    },
    { "AudioVolume_LR",         TRUE    },
    { "AudioSwitch_1X1",        FALSE   },
    { "AudioSwitch_2X1",        FALSE   },
    { "AudioSwitch_1X2",        FALSE   },
    { "AudioSwitch_2X2",        FALSE   },
    { "AudioSwitch_2GANG",      FALSE   },
    { "AudioSwitch_2PAR",       FALSE   },
    { "AudioAGC",               FALSE   },
    { "AudioBass",              TRUE    },
    { "AudioBass_LR",           TRUE    },
    { "AudioTreble",            TRUE    },
    { "AudioTreble_LR",         TRUE    },
    { "AudioGain",              TRUE    },
    { "AudioGain_LR",           TRUE    }
};

enum
{
    WAVEOUT_SOURCE = 0,
    WAVEOUT_VOLUME,

    SYNTH_SOURCE,
    SYNTH_VOLUME,
    SYNTH_WAVEIN_SWITCH,

    CD_SOURCE,
    CD_VOLUME,
    CD_LINEOUT_SWITCH,
    CD_WAVEIN_SWITCH,

    LINEIN_SOURCE,
    LINEIN_VOLUME,
    LINEIN_LINEOUT_SWITCH,
    LINEIN_WAVEIN_SWITCH,

    MIC_SOURCE,
    MIC_AGC,
    MIC_VOLUME,
    MIC_LINEOUT_SWITCH,
    MIC_WAVEIN_SWITCH,

    LINEOUT_MIX,
    LINEOUT_VOL,
    LINEOUT_BASS,
    LINEOUT_TREBLE,
    LINEOUT_GAIN,
    LINEOUT_DEST,

    WAVEIN_MIX,
    WAVEIN_GAIN,
    WAVEIN_DEST,

    VOICEIN_DEST
};

char *
Units[] =
{
    "WAVEOUT_SOURCE",
    "WAVEOUT_VOLUME",

    "SYNTH_SOURCE",
    "SYNTH_VOLUME",
    "SYNTH_WAVEIN_SWITCH",

    "CD_SOURCE",
    "CD_VOLUME",
    "CD_LINEOUT_SWITCH",
    "CD_WAVEIN_SWITCH",

    "LINEIN_SOURCE",
    "LINEIN_VOLUME",
    "LINEIN_LINEOUT_SWITCH",
    "LINEIN_WAVEIN_SWITCH",

    "MIC_SOURCE",
    "MIC_AGC",
    "MIC_VOLUME",
    "MIC_LINEOUT_SWITCH",
    "MIC_WAVEIN_SWITCH",

    "LINEOUT_MIX",
    "LINEOUT_VOL",
    "LINEOUT_BASS",
    "LINEOUT_TREBLE",
    "LINEOUT_GAIN",
    "LINEOUT_DEST",

    "WAVEIN_MIX",
    "WAVEIN_GAIN",
    "WAVEIN_DEST",

    "VOICEIN_DEST"
};

void
PrintUnit
(
    char *          Prefix,
    PTOPOLOGY_UNIT  Unit
)
{
    if (Unit->Identifier <= WAVEIN_DEST)
    {
        printf("%sName from identifier: %s\n",Prefix,Units[Unit->Identifier]);
    }
    else
    {
        printf("%sName from identifier: UNKNOWN IDENTIFIER\n",Prefix);
    }

    if (IsEqualGUID(&UNITTYPESETID_Audio,&Unit->Type.Set))
    {
        if (Unit->Type.Id <= UNITTYPEID_AudioGain_LR)
        {
            printf("%sType:                 %s\n",Prefix,Types[Unit->Type.Id].Name);
        }
        else
        {
            printf("%sType:                 Audio %d\n",Prefix,Unit->Type.Id);
        }
    }
    else
    {
        printf("%sType:                 Unknown set, id=%d\n",Prefix,Unit->Type.Id);
    }

    printf("%sIdentifier:           %d\n",Prefix,Unit->Identifier);
    printf("%sIncomingConnections:  %d\n",Prefix,Unit->IncomingConnections);
    printf("%sOutgoingConnections:  %d\n",Prefix,Unit->OutgoingConnections);
}

void
PrintConnection
(
    char *                  Prefix,
    PTOPOLOGY_CONNECTION    Connection
)
{
    printf("%sFromUnit:  %d\n",Prefix,Connection->FromUnit);
    printf("%sFromPin:   %d\n",Prefix,Connection->FromPin);
    printf("%sToUnit:    %d\n",Prefix,Connection->ToUnit);
    printf("%sToPin:     %d\n",Prefix,Connection->ToPin);
}

void
PrintValue
(
    char *          Prefix,
    PULONG          Value,
    ULONG           ValueSize,
    PKSIDENTIFIER   Type
)
{   
    char *  pattern     = "%s%s    0x%08x\n";
    char *  postPrefix  = "Values:";
    BOOLEAN doFloat     = FALSE;

    if (IsEqualGUID(&UNITTYPESETID_Audio,&Type->Set))
    {
        if (Type->Id <= UNITTYPEID_AudioGain_LR)
        {
            if (Types[Type->Id].FloatValues)
            {
                pattern = "%s%s    %f (0x%08x)\n";
                doFloat = TRUE;
            }
            else
            {
                pattern = "%s%s    %d (0x%08x)\n";
            }
        }
    }

    printf("%sSize:      %d\n",Prefix,ValueSize);

    for (; ValueSize >= sizeof(ULONG); ValueSize -= sizeof(ULONG), Value++)
    {
        if (doFloat)
        {
            printf(pattern,Prefix,postPrefix,*((float *) Value),*Value);
        }
        else
        {
            printf(pattern,Prefix,postPrefix,*Value,*Value);
        }
        postPrefix = "       ";
    }
}

VOID
DumpUnit
(
    HANDLE  PinHandle,
    ULONG   UnitID,
    ULONG   DestID
)
{
    struct
    {
        KSPROPERTY  Property;
        ULONG       Param1;
        ULONG       Param2;
    }
    propWithInstance;

    TOPOLOGY_UNIT   unit;
    ULONG           connID;
    ULONG           value[4];
    ULONG           returned;

    propWithInstance.Property.Set    = KSPROPSETID_Topology;
    propWithInstance.Property.Id     = KSPROPERTY_TopologyUnit;
    propWithInstance.Property.Flags  = KSPROPERTY_TYPE_GET;

    propWithInstance.Param1 = UnitID;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + sizeof(ULONG),&unit,sizeof(unit),&returned))
        return;
    printf("KSPROPERTY_TopologyUnit(%d):\n",UnitID);
    PrintUnit("    ",&unit);

    propWithInstance.Property.Id = KSPROPERTY_TopologyIncomingConnection;
    for (connID = 0; connID < unit.IncomingConnections; connID++)
    {
        TOPOLOGY_CONNECTION connection;
        propWithInstance.Param2 = connID;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + 2 * sizeof(ULONG),&connection,sizeof(connection),&returned))
            return;
        printf("    KSPROPERTY_TopologyIncomingConnection(%d,%d):\n",UnitID,connID);
        PrintConnection("        ",&connection);
    }

    propWithInstance.Property.Id = KSPROPERTY_TopologyOutgoingConnection;
    for (connID = 0; connID < unit.OutgoingConnections; connID++)
    {
        TOPOLOGY_CONNECTION connection;
        propWithInstance.Param2 = connID;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + 2 * sizeof(ULONG),&connection,sizeof(connection),&returned))
            return;
        printf("    KSPROPERTY_TopologyOutgoingConnection(%d,%d):\n",UnitID,connID);
        PrintConnection("        ",&connection);
    }

    propWithInstance.Property.Id = KSPROPERTY_TopologyValue;
    propWithInstance.Param2 = DestID;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + 2 * sizeof(ULONG),value,sizeof(value),&returned))
        return;
    if (DestID == (ULONG) -1)
        printf("    KSPROPERTY_TopologyValue(%d,ULONG(-1)):\n",UnitID);
    else
        printf("    KSPROPERTY_TopologyValue(%d,%d):\n",UnitID,DestID);
    PrintValue("        ",value,returned,&unit.Type);
}

void SetUnitValues
(
    HANDLE  PinHandle,
    ULONG   UnitID,
    ULONG   DestID,
    double *Values,
    ULONG   ValueCount
)
{
    struct
    {
        KSPROPERTY  Property;
        ULONG       Param1;
        ULONG       Param2;
    }
    propWithInstance;

    TOPOLOGY_UNIT   unit;
    ULONG           connID;
    ULONG           value[4];
    ULONG           returned;
    BOOLEAN         isFloat = FALSE;

    propWithInstance.Property.Set    = KSPROPSETID_Topology;
    propWithInstance.Property.Id     = KSPROPERTY_TopologyUnit;
    propWithInstance.Property.Flags  = KSPROPERTY_TYPE_GET;

    propWithInstance.Param1 = UnitID;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + sizeof(ULONG),&unit,sizeof(unit),&returned))
        return;

    if (IsEqualGUID(&UNITTYPESETID_Audio,&unit.Type.Set))
    {
        if (unit.Type.Id <= UNITTYPEID_AudioGain_LR)
        {
            isFloat = Types[unit.Type.Id].FloatValues;
            if (isFloat)
            {
                printf("Value type indicates values are float\n");
            }
            else
            {
                printf("Value type indicates values are ULONG\n");
            }
        }
        else
        {
            printf("Value type unknown:  assuming ULONG\n");
        }
    }
    else
    {
        printf("Value type unknown:  assuming ULONG\n");
    }

    propWithInstance.Property.Id = KSPROPERTY_TopologyValue;
    propWithInstance.Param2 = DestID;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + 2 * sizeof(ULONG),value,sizeof(value),&returned))
        return;

    if (returned != ValueCount * 4)
    {
        printf("ERROR:  get value returned %d bytes, %d bytes presented for set value.\n",returned,ValueCount * 4);
    }
    else
    {
        ULONG i;
        for (i = 0; i < ValueCount; i++)
        {
            if (isFloat)
            {
                float f = (float) Values[i];
                value[i] = *((ULONG *) &f);
            }
            else
            {
                value[i] = (ULONG) Values[i];
            }
        }

        propWithInstance.Property.Flags  = KSPROPERTY_TYPE_SET;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + 2 * sizeof(ULONG),value,ValueCount * 4,&returned))
            return;
    }
}

VOID
DumpTopology
(
    HANDLE  PinHandle
)
{
    struct
    {
        KSPROPERTY  Property;
        ULONG       Param1;
        ULONG       Param2;
    }
    propWithInstance;

    ULONG unitCount;
    ULONG connectionCount;
    ULONG sourceCount;
    ULONG destinationCount;
    ULONG returned;
    ULONG unitID;
    ULONG connID;

    propWithInstance.Property.Set    = KSPROPSETID_Topology;
    propWithInstance.Property.Id     = 0;    // Set later.
    propWithInstance.Property.Flags  = KSPROPERTY_TYPE_GET;

    propWithInstance.Property.Id = KSPROPERTY_TopologyUnitCount;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY),&unitCount,sizeof(ULONG),&returned))
        return;
    printf("KSPROPERTY_TopologyUnitCount:          %d\n",unitCount);

    propWithInstance.Property.Id = KSPROPERTY_TopologyConnectionCount;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY),&connectionCount,sizeof(ULONG),&returned))
        return;
    printf("KSPROPERTY_TopologyConnectionCount:    %d\n",connectionCount);

    propWithInstance.Property.Id = KSPROPERTY_TopologySourceCount;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY),&sourceCount,sizeof(ULONG),&returned))
        return;
    printf("KSPROPERTY_TopologySourceCount:        %d\n",sourceCount);

    propWithInstance.Property.Id = KSPROPERTY_TopologyDestinationCount;
    if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY),&destinationCount,sizeof(ULONG),&returned))
        return;
    printf("KSPROPERTY_TopologyDestinationCount:   %d\n",destinationCount);

    printf("\n");
    propWithInstance.Property.Id = KSPROPERTY_TopologyUnit;
    for (unitID = 0; unitID < unitCount; unitID++)
    {
        TOPOLOGY_UNIT unit;
        propWithInstance.Param1 = unitID;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + sizeof(ULONG),&unit,sizeof(unit),&returned))
            return;
        printf("KSPROPERTY_TopologyUnit(%d):\n",unitID);
        PrintUnit("    ",&unit);
    }

    printf("\n");
    propWithInstance.Property.Id = KSPROPERTY_TopologyConnection;
    for (connID = 0; connID < connectionCount; connID++)
    {
        TOPOLOGY_CONNECTION connection;
        propWithInstance.Param1 = connID;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + sizeof(ULONG),&connection,sizeof(connection),&returned))
            return;
        printf("KSPROPERTY_TopologyConnection(%d):\n",connID);
        PrintConnection("    ",&connection);
    }

    printf("\n");
    propWithInstance.Property.Id = KSPROPERTY_TopologySource;
    for (unitID = 0; unitID < sourceCount; unitID++)
    {
        TOPOLOGY_UNIT unit;
        propWithInstance.Param1 = unitID;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + sizeof(ULONG),&unit,sizeof(unit),&returned))
            return;
        printf("KSPROPERTY_TopologySource(%d):\n",unitID);
        PrintUnit("    ",&unit);
    }

    printf("\n");
    propWithInstance.Property.Id = KSPROPERTY_TopologyDestination;
    for (unitID = 0; unitID < destinationCount; unitID++)
    {
        TOPOLOGY_UNIT unit;
        propWithInstance.Param1 = unitID;
        if (!HandleControl(PinHandle,IOCTL_KS_PROPERTY,&propWithInstance,sizeof(KSPROPERTY) + sizeof(ULONG),&unit,sizeof(unit),&returned))
            return;
        printf("KSPROPERTY_TopologyDestination(%d):\n",unitID);
        PrintUnit("    ",&unit);
    }

    printf("\n");
    for (unitID = 0; unitID < unitCount; unitID++)
    {
        DumpUnit(PinHandle,unitID,(ULONG) -1);
    }
}

int usage(char *programName)
{
    fprintf(stderr,"usage:  %s <options> [ device ]\n");
    fprintf(stderr,"          -t                  dump entire topology\n");
    fprintf(stderr,"          -u<id>              specify unit of interest\n");
    fprintf(stderr,"          -d<id>              specify destination of interest\n");
    fprintf(stderr,"          -=<value,value...>  set unit values\n");
    return 0;
}

#define MAX_VALUES 4

char *ParseValues(char *p,double *values,ULONG *count)
{
    for (*count = 0; *count < MAX_VALUES; )
    {
        if  (   (! isdigit(*p))
            &&  (*p != '-')
            )
        {
            return NULL;
        }
        *values++ = atof(p);
        (*count)++;
        while (isdigit(*++p));
        if (*p == '.')
        {
            while (isdigit(*++p));
        }
        if (*p != ',')
        {
            return p;
        }
        p++;
    }
    return NULL;
}

int
_cdecl
main
(
    int     argc,
    char*   argv[],
    char*   envp[]
)
{
    char*   deviceName = NULL;
    HANDLE  filterHandle;
    HANDLE  pinHandle;
    BOOLEAN dumpTopology = FALSE;
    ULONG   setValues = 0;
    ULONG   unitID = (ULONG) -1;
    ULONG   destID = (ULONG) -1;
    double  values[4];
    float   biteMe = ((float) 10)/((float) 3);
    int     i;

	for (i = 1; i < argc; i++)
	{
		char *p = argv[i];
		if ((*p == '/') || (*p == '-'))
		{
			for (p++; *p != '\0';)
			{
				char cOption = *p++;
				switch (cOption)
				{
                case 't':
                case 'T':
                    dumpTopology = TRUE;
                    break;
                
                case 'u':
                case 'U':
                    if (unitID != (ULONG) -1)
                    {
                        return usage(argv[0]);
                    }
                    if (! isdigit(*p))
                    {
                        return usage(argv[0]);
                    }
                    unitID = atoi(p);
                    while (isdigit(*++p));
                    break;
                
                case 'd':
                case 'D':
                    if (destID != (ULONG) -1)
                    {
                        return usage(argv[0]);
                    }
                    if (! isdigit(*p))
                    {
                        return usage(argv[0]);
                    }
                    destID = atoi(p);
                    while (isdigit(*++p));
                    break;
                
                case '=':
                    if (unitID == (ULONG) -1)
                    {
                        return usage(argv[0]);
                    }
                    p = ParseValues(p,values,&setValues);
                    if (! p)
                    {
                        return usage(argv[0]);
                    }
                    break;
                
				default:
					return usage(argv[0]);
				}
			}
		}
        else
        if (deviceName == NULL)
        {
            deviceName = argv[i];
        }
		else
		{
			return usage(argv[0]);
		}
	}

    if (deviceName == NULL)
    {
        deviceName = "\\\\.\\WavePort0\\Topology";
    }

    filterHandle = CreateFile
    (
        deviceName, 
        GENERIC_READ | GENERIC_WRITE, 
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    if (filterHandle == (HANDLE) -1) 
    {
        printf("failed to open %s (%x)\n",deviceName,GetLastError());
    }
    else
    {
        pinHandle = CreatePin(filterHandle);
        if (pinHandle)
        {
            if (dumpTopology)
            {
                DumpTopology(pinHandle);
            }
            if (unitID != (ULONG) -1)
            {
                DumpUnit(pinHandle,unitID,destID);
                if (setValues)
                {
                    SetUnitValues(pinHandle,unitID,destID,values,setValues);
                    DumpUnit(pinHandle,unitID,destID);
                }
            }

            CloseHandle(pinHandle);
        }
        else
        {
            printf("failed to create pin (%x)\n",GetLastError());
        }

        CloseHandle(filterHandle);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\gmem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       gmem.h
//
//--------------------------------------------------------------------------

/*
 * GMEM.H - Macros for windows 3.0 memory management in protected mode
 *
 * because windows 3.0 runs in pmode GlobalLock and GlobalUnlock are
 * unnessary.  The "Selector" to a memory object will always be the
 * same for the life of the memory object.
 *
 * these macros take advantage of the following win3 memory "facts"
 *
 *      a SELECTOR (to a global object) is a HANDLE
 *      a HANDLE is *not* a SELECTOR!!!!!!!!
 *
 *      GlobalLock() and GlobalUnlock() do *not* keep lock counts
 *
 *      GlobalLock() is the only way to convert a HANDLE to a SELECTOR
 *
 * functions:
 *
 *      GHandle(sel)                convert a SELECTOR to a HANDLE
 *      GSelector(h)                convert a HANDLE to a SELECTOR
 *
 *      GAllocSel(ulBytes)          allocate a SELECTOR ulBytes in size
 *      GAllocPtr(ulBytes)          allocate a POINTER ulBytes in size
 *
 *      GReAllocSel(sel,ulBytes)    re-alloc a SELECTOR
 *      GReAllocPtr(lp,ulBytes)     re-alloc a POINTER
 *
 *      GSizeSel(sel)               return the size in bytes of a SELECTOR
 *
 *      GLockSel(sel)               convert a SELECTOR into a POINTER
 *      GUnlockSel(sel)             does nothing
 *
 *      GFreeSel(sel)               free a SELECTOR
 *      GFreePtr(lp)                free a POINTER
 *
 * 5/31/90 ToddLa
 *
 */

HANDLE __H;

#ifdef WIN32

#define GAllocPtr(ulBytes)    GlobalAlloc(GMEM_FIXED,ulBytes)
#define GAlloc(ulBytes) GAllocPtr(ulBytes)

#define GReAllocSel(sel,ulBytes)   ((__H=GlobalReAlloc((HANDLE)(sel),(LONG)(ulBytes),0)) ? GSelector(__H) : NULL )
#define GReAllocPtr(lp,ulBytes)     GlobalReAlloc(lp,ulBytes,0)
#define GReAlloc(sel,ulBytes)	    GReAllocPtr(sel,ulBytes)

#define GSizeSel(sel)       GlobalSize((HANDLE)(sel))
#define GSize(sel)          GSizeSel(sel)

#define GLockSel(sel)	    GlobalLock(sel)
#define GUnlockSel(sel)     GlobalUnlock(sel)
#define GLock(sel)          GLockSel(sel)
#define GUnlock(sel)        GUnlockSel(sel)

#define GFreeSel(sel)	    GlobalFree(sel)
#define GFreePtr(lp)	    GlobalFree(lp)
#define GFree(sel)	    GlobalFree(sel)


#else

#define MAKEP(sel,off)      ((LPVOID)MAKELONG(off,sel))

#define GHandle(sel)        ((HANDLE)(sel))  /* GlobalHandle? */
#define GSelector(h)        (HIWORD((DWORD)GlobalLock(h)))

#define GAllocSelF(f,ulBytes) ((__H=GlobalAlloc(f,(LONG)(ulBytes))) ? GSelector(__H) : NULL )
#define GAllocPtrF(f,ulBytes) MAKEP(GAllocSelF(f,ulBytes),0)
#define GAllocF(f,ulBytes)    GAllocSelF(f,ulBytes)

#define GAllocSel(ulBytes)    GAllocSelF(GMEM_MOVEABLE,ulBytes)
#define GAllocPtr(ulBytes)    GAllocPtrF(GMEM_MOVEABLE,ulBytes)
#define GAlloc(ulBytes)       GAllocSelF(GMEM_MOVEABLE,ulBytes)

#define GReAllocSel(sel,ulBytes)   ((__H=GlobalReAlloc((HANDLE)(sel),(LONG)(ulBytes),0)) ? GSelector(__H) : NULL )
#define GReAllocPtr(lp,ulBytes)    MAKEP(GReAllocSel(HIWORD((DWORD)(lp)),ulBytes),0)
#define GReAlloc(sel,ulBytes)      GReAllocSel(sel,ulBytes)

#define GSizeSel(sel)       GlobalSize((HANDLE)(sel))
#define GSize(sel)          GSizeSel(sel)

#define GLockSel(sel)       MAKEP(sel,0)
#define GUnlockSel(sel)     /* nothing */
#define GLock(sel)          GLockSel(sel)
#define GUnlock(sel)        GUnlockSel(sel)

#define GFreeSel(sel)       (GlobalUnlock(GHandle(sel)),GlobalFree(GHandle(sel)))
#define GFreePtr(lp)        GFreeSel(HIWORD((DWORD)(lp)))
#define GFree(sel)          GFreeSel(sel)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\support.h ===
/***************************************************************************\
*                                                                           *
*   File: Support.h                                                         *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract: Support for the test shell after removal of mprt1632.h        *                                                                   *
*                                                                           *
*   Contents: Various Macros which allow the same code to run on both       *
*             16bit and 32bit platforms                                     *
*                                                                           *
*   History:                                                                *
*       06/07/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/


// Support for GET_MM_COMMAND

#ifdef WIN32
//// From pwin32.h
//#define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(wp)
//#define GET_WM_COMMAND_ID(wp, lp)                   LOWORD(wp)
//#define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)(lp)
#else

#ifndef GET_WM_COMMAND_CMD
    // From pwin16.h
    #define GET_WM_COMMAND_CMD(wp, lp)                  HIWORD(lp)
    #define GET_WM_COMMAND_ID(wp, lp)                   (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)                 (HWND)LOWORD(lp)
#endif

#endif


// More support...
#ifdef WIN32
// From pwin32.h
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLong(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLong(hwnd, index, (LONG)(ui))
#define MLockData(dummy)
#define MUnlockData(dummy)                  
//#define GET_WM_VSCROLL_CODE(wp, lp)     (wp)
//#define GET_WM_VSCROLL_POS(wp, lp)      LOWORD(lp)
//#define GET_WM_VSCROLL_HWND(wp, lp)     (HWND)HIWORD(lp)
#else
// From pwin16.h
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define MLockData(dummy)                LockData(dummy)
#define MUnlockData(dummy)              UnlockData(dummy)

#ifndef GET_WM_VSCROLL_CODE
    #define GET_WM_VSCROLL_CODE(wp, lp)     LOWORD(wp)
    #define GET_WM_VSCROLL_POS(wp, lp)      HIWORD(wp)
    #define GET_WM_VSCROLL_HWND(wp, lp)     (HWND)(lp)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\defdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       defdlg.h
//
//--------------------------------------------------------------------------

#define DLGOPEN_CTL_MIN		20
#define DLGOPEN_CTL_MAX		30
#define DLGOPEN_EDIT		20
#define DLGOPEN_FILE_LISTBOX	21
#define DLGOPEN_DIR_LISTBOX	22
#define DLGOPEN_PATH		23
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\toolbar.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/*****************************************************************************
*                                                                            *
*  TOOLBAR.H                                                                 *
*                                                                            *
*  Program Description: Implements a generic toolbar.         		     *
*                                                                            *
*  Here's how to use it:                                                     *
*                                                                            *
*            Include the source files "toolbar.h" and "toolbar.c" in your    *
*  application.                                                              *
*                                                                            *
*            Include a line in your application's RC file that gives a file  *
*  name with a resource id eg. IDBMP_BUTTONS.  This is a .BMP file that      *
*  contains all of the pictures of the buttons you want on your toolbar.     *
*  Also, make a define for your label with a unique value.  If your app has  *
*  more than one toolbar, and all toolbars don't share a bitmap file, then   *
*  you will need several defines.                                            *
*                                                                            *
*  e.g.		IDBMP_BUTTONS     BITMAP     "buttons.bmp"                   *
*      		IDBMP_ARROWS      BITMAP     "arrows.bmp"                    *
*                                                                            *
*            This file must have the different buttons across horizontally   *
*  and the different states for these buttons vertically.  Change the        *
*  defines in this header file to match the button names and state names of  *
*  your buttons.  You must include the states listed here, and actually      *
*  you probably won't need to change them at all.  The numbers for a button  *
*  or state are indexes into the bitmap, so the pictures must match.         *
*                                                                            *
*  STATE DESCRIPTIONS:                                                       *
*                       GRAYED:  The button cannot be pressed & is inactive  *
*                           UP:  The button is up                            *
*                         DOWN:  The button is down                          *
*                      FOCUSUP:  The button is up and is the one with focus  *
*                    FOCUSDOWN:  The button is down and is the one with focus*
*                     FULLDOWN:  A checkbox button has this additional state *
*                                where it is all the way down when pressed   *
*                                and when it is let go, it will go into      *
*                                either the UP or DOWN state (maybe focused) *
*                                                                            *
*  When you draw the pictures, make sure to get the right state in the right *
*  vertical position in the bitmap to match the #define's.                   *
*                                                                            *
*  A button can also have a type associated with it:                         *
*                                                                            *
*                 PUSH:  When pressed it goes down, when let go it bounces   *
*                        up.  Therefore, when you aren't currently holding   *
*                        the mouse button or space bar on it, it will        *
*                        ALWAYS be in the up position. It can be in any      *
*                        state except FULLDOWN, which is invalid.            *
*                                                                            *
*             CHECKBOX:  This button can be up or down.  When pushed, it     *
*                        toggles into the opposite state.  However, it       *
*                        is always in the FULLDOWN state when being held     *
*                        down with the mouse button or space bar, and when   *
*                        let go, it will go into the opposite state of what  *
*                        it was in before you pressed it.  E.G.  The button  *
*                        is up.  You press it, and it goes way down. You let *
*                        go, and it comes up a bit, but it's still down.  You*
*                        press it again, and it goes further down before     *
*                        popping all the way up.                             *
*                                                                            *
*                RADIO:  This is a group of buttons that can be up or down,  *
*                        and also have the intermediate step of being        *
*                        FULLDOWN when being held down.  But, when you       *
*                        push one of the radio buttons down, all other radio *
*                        buttons in its group will pop up.  Any group can    *
*                        have only 1 down at a time, and 1 must be down.     *
*                                                                            *
*                CUSTOM: If your application is wierd, you can have a custom *
*                        type button that does anything you want it to.      *
*                                                                            *
*  First, your app must call:    toolbarInit(hInst, hPrev);                  *
*  with the two instance parameters to register a toolbar window class.      *
*  Then your app is free to call CreateWindow with a class of                *
*  szToolBarClass   to create one or more toolbar windows anywhere it wants  *
*  and of any size it wants, presumably as the child window of another of the*
*  app's windows.  The file that creates the window must declare an          *
*  extern char szToolBarClass[];   All messages about activity to a toolbar  *
*  button will go to the parent window of the toolbar.                       *
*                                                                            *
*  Next, call:     toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,       *
*							 POINT ptSize);      *
*  Pass it the resource ID (eg. IDBMP_BUTTONS) to tell the toolbar where to  *
*  find the pictures for the buttons.  Also pass a point with the width and  *
*  height of each button (eg. 24 X 22) so it knows how to find individual    *
*  buttons in the bitmap file.                                               *
*                                                                            *
*  Next, call:     toolbarAddTool(HWND hwnd, TOOLBUTTON tb);                 *
*  as many times as you want to add a button to the toolbar specified by     *
*  hwnd.  You fill in the "tb" struct with the following information:        *
*                                                                            *
*       tb.rc        = the rect in the toolbar window to place the button    *
*                      based at 0,0 and measured in pixels.                  *
*       tb.iButton   = the ID of the button you wish the add (which is       *
*                      the horizontal offset into the bitmap of buttons).    *
*                      Only one of each button allowed.  Use one of the      *
*                      defines (BTN_??????).                                 *
*       tb.iState    = the initial state of the button (GRAYED, UP, DOWN).   *
*                      If you wish, you can specify a FOCUS'ed state to give *
*                      any button you wish the focus.  By default, it's the  *
*                      one furthest left and tabbing order goes to the right.*
*                      This is the vertical offset into the bitmap.          *
*                      Use one of the defines (BTNST_?????).                 *
*       tb.iType     = The type of button (BTNTYPE_???).  Either pushbutton, *
*                      checkbox, or radio button. (or custom).  If it is a   *
*                      radio button, you can have many groups of radio btn's *
*                      on the same toolbar.  Type BTNTYPE_RADIO is one group.*
*                      Use BTNTYPE_RADIO+1 for another group, BTNTYPE_RADIO+2*
*                      for a third group, etc.  You have thousands.          *
*       tb.iString   = The resource ID of a string to be associated with     *
*                      this button (if you'd like).                          *
*                                                                            *
*                                                                            *
*   At any time in the app, you can call toolbarAddTool to add more buttons  *
*   or toolbarRemoveTool to take some away.  To take one away, identify it   *
*   with it's button ID (horizontal offset in the bitmap).                   *
*                                                                            *
*   You can also call toolbarRetrieveTool to get the TOOLBUTTON struct back  *
*   from a button that is on the toolbar.  This is the way to change a       *
*   button's position.  Change the tb.rc and then Remove and Add the button  *
*   again so that the tabbing order will be re-calculated based on the new   *
*   rect of the tool.                                                        *
*                                                                            *
*   Now, all buttons will automatically behave properly.  They'll go up and  *
*   down as you press on them, or use the keyboard, groups of radio buttons  *
*   will pop up as you press a different one down, etc. etc. etc.            *
*   You don't have to do a thing!                                            *
*                                                                            *
*   The parent of the toolbar window will get a WM_COMMAND message with      *
*   a wParam of IDC_TOOLBAR  whenever anything happens to a button.          *
*   The LOWORD of the lParam is the hwnd of the toolbar window that has the  *
*   button on it.  The (HIWORD & 0xFF) is the button ID of the button.       *
*   Remember to change IDC_TOOLBAR to something unique.                      *
*                                                                            *
*   The app can then call   toolbarIndexFromButton(hwnd, buttonID)           *
*   to get the index of the button (used for subsequent calls).              *
*                                                                            *
*   Then call:      toolbarStateFromButton(hwnd, buttonID)                   *
*                                                                            *
*                   to get either BTNST_UP or BTNST_DOWN.  This is the       *
*                   NEW state of the button since the activity on the        *
*                   button.  It can also be BTNST_GRAYED, but you won't get  *
*                   any activity messages while it's grayed, unless it is a  *
*                   cutsom button.                                           *
*                                                                            *
*             Call  toolbarFullStateFromButton(hwnd, buttonID)               *
*                                                                            *
*                   to get more detail about the state.  It can also return  *
*                   BTNST_FULLDOWN as well as the above states. In the case  *
*                   of BTNST_FULLDOWN, you'll have to call                   *
*                   toolbarPrevStateFromButton(hwnd, btn ID) to get the state*
*                   before it went full down.                                *
*                                                                            *
*                   toolbarPrevStateFromButton(hwnd, buttonID)               *
*                                                                            *
*                   is only valid when the state is BTNST_FULLDOWN.          *
*                                                                            *
*                   toolbarActivityFromIndex(hwnd, buttonID)                 *
*                                                                            *
*                   tells you what just happened to the button.              *
*                   BTNACT_KEYDOWN, BTNACT_MOUSEUP, etc. are possibilities.  *
*                   BTNACT_MOUSEMOUSEOFF means that they pressed it down and *
*                   moved the mouse off of the button (  so it was re- drawn *
*                   in its previous state before being pressed).             *
*                   BTNACT_MOUSEMOUSEON  means that the above happened and   *
*                   then the mouse moved back on top of the button again, so *
*                   the button was re-drawn as if it was pushed again.       *
*                                                                            *
*                   For any of the above activities.......                   *
*                                                                            *
*   HIWORD & BTN_SHIFT     is set if this activity involves the right mouse  *
*                          button, or else it is clear.                      *
*   HIWORD & BTN_DBLCLICK  is set means that this mouse button down activity *
*                          is really a double click (if you care).           *
*                                                                            *
*           If you are a custom button, you can also receive this message... *
*                                                                            *
*   HIWORD & BTN_REPEAT    is set means that the button or key is being held *
*                          down, and you are being sent many down messages   *
*                          in a row.  The first such message is sent with    *
*                          this flag clear, all others have this flag set.   *
*                          If you are a custom button, you will have to      *
*                          ignore messages that are repeats if you don't     *
*                          want to get many down messages in a row.          *
*                                                                            *
*                                                                            *
*                    toolbarStringFromIndex(hwnd, index)                     *
*                                                                            *
*                    will return you the string resource ID you gave when    *
*                    you registered this button.                             *
*                                                                            *
*                                                                            *
*  IMPORTANT !!!!!!!!!!!!!!!!!!!                                             *
*  =============================                                             *
*                                                                            *
*  When you get the state of a button, it's already been changed by the      *
*  activity so it's the NEW STATE!!!!!!!!!                                   *
*                                                                            *
*   EXCEPT!!!   for a custom button!  For a custom button, NOTHING WILL      *
*   happen, you have to do it all yourself!!!! So the state is going to be   *
*   the state BEFORE the activity and you have to call                       *
*   toolbarModifyState(hwnd, buttonID, newState) to change the state         *
*   yourself!!!!                                                             *
*                                                                            *
*   You also have toolbarGetNumButtons(hwnd) to tell you how many are on the *
*   the toolbar.                                                             *
*   And... you have other routines you can use if you really want.           *
*                                                                            *
*   ENJOY!!                                                                  *
*                                                                            *
*  P.S.  Don't forget to pass on WM_SYSCOLORCHANGE msgs to each toolbar.     *
******************************************************************************
*                                                                            *
*  Revision History:  Created by Danny Miller, based on David Maymudes' code *
*				which was based on Todd Laney's SBUTTON code *
*				and stuff from Eric Ledoux.  Did I miss any- *
*				body?                                        *
*                                                                            *
*****************************************************************************/

#define TOOLGROW	8		// power of 2

#define IDC_TOOLBAR	189		// wParam sent to Parent

/* We keep an array of these around (one for each button on the toolbar) */

typedef struct {
	RECT	rc;		// draw it at this postion in the toolbar
	int	iButton;	// it's this button
	int	iState;		// in this state
	int	iPrevState;	// for non-push buttons - last state
	int	iType;		// type of button
	int	iActivity;	// what just happened to button
	int	iString;	// string resource associated with button
} TOOLBUTTON, FAR *LPTOOLBUTTON;

BOOL FAR PASCAL toolbarInit(HANDLE hInst, HANDLE hPrev);
BOOL FAR PASCAL toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,
								POINT ptSize);
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, TOOLBUTTON tb);
BOOL FAR PASCAL toolbarRetrieveTool(HWND hwnd, int iButton, LPTOOLBUTTON tb);
BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton);
int FAR PASCAL toolbarGetNumButtons(HWND hwnd);
int FAR PASCAL toolbarButtonFromIndex(HWND hwnd, int iBtnPos);
int FAR PASCAL toolbarIndexFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarPrevStateFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarActivityFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarIndexFromPoint(HWND hwnd, POINT pt);
BOOL FAR PASCAL toolbarRectFromIndex(HWND hwnd, int iBtnPos, LPRECT lprc);
int FAR PASCAL toolbarStringFromIndex(HWND hwnd, int iBtnPos);
int FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarFullStateFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarTypeFromIndex(HWND hwnd, int iBtnPos);
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int iState);
BOOL FAR PASCAL toolbarModifyString(HWND hwnd, int iButton, int iString);
BOOL FAR PASCAL toolbarModifyPrevState(HWND hwnd, int iButton, int iPrevState);
BOOL FAR PASCAL toolbarModifyActivity(HWND hwnd, int iButton, int iActivity);
BOOL FAR PASCAL toolbarExclusiveRadio(HWND hwnd, int iType, int iButton);
BOOL FAR PASCAL toolbarMoveFocus(HWND hwnd, BOOL fBackward);
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton);
HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCSTR      szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);          // color to use for "Window Frame"

/*******************************/
/* REMOVE TO MAKE GENERIC CODE */
extern BOOL gfWin31;
/*******************************/

/* In a bitmap file, each button is the same size, and contains
 * the picture of a button.  Each column contains the picture of a distinct
 * button (e.g. BTN_REWIND, BTN_REVERSE, etc.) and each row contains
 * a specific button state (BTNST_UP, BTNST_DOWN,
 * BTNBAR_GRAYED, etc. just as an example).
 *
 */

#define TB_FIRST	-1
#define TB_LAST		-2

#ifdef _SHOWEDIT
/* Here are the buttons for the main toolbar */
#define BTN_BACK		0
#define BTN_CLOSER		1
#define BTN_ENTERNOW		2
#define BTN_EXITNOW		3
#define BTN_FARTHER		4
#define BTN_FRAMEINFO		5
#define BTN_FRAMEINFO2		6
#define BTN_FRONT    		7
#ifdef TWO_WINDOWS
#define BTN_FULLSCREEN		8
#endif
#define BTN_EDITMIDI		9
#define BTN_NOICON		10
#define BTN_NOINFO		11
#define BTN_EDITOBJ		12
#define BTN_OBJINFO		13
#define BTN_OBJPROP		14
#define BTN_REPAINT		19

/* Here are the buttons for the arrow toolbar for the frame scrollbar */
#define ARROW_PREV		0
#define ARROW_NEXT		1

#endif


#ifdef _AVIEDIT
#define BTN_FILEOPEN		0
#define BTN_FILESAVE		1
#define BTN_CUT			2
#define BTN_COPY		3
#define BTN_PASTE		4
#define BTN_UNDO		5
#define BTN_VIDCAP		6
#define BTN_REPAINT		7
#define BTN_ZOOM		8
#ifdef TWO_WINDOWS
#define BTN_FULLSCREEN		9
#endif

/* Here are the buttons for the arrow toolbar for the frame scrollbar */
#define ARROW_PREV		0
#define ARROW_NEXT		1

/* Now the mark buttons */
#define BTN_MARKIN		0
#define BTN_MARKOUT		1

/* Now the buttons for the transport */
#define BTN_PLAY		0
#define BTN_STOP		1
#define BTN_HOME		2
#define BTN_REW			3
#define BTN_FWD			4
#define BTN_END			5

/* Now the audio/video editing mode */
#define BTN_AUDVID		0
#define BTN_VID			1
#define BTN_AUD			2

#endif

#ifdef _VIDCAP
#define BTN_SETFILE		0
#define BTN_EDITCAP		1
#define BTN_LIVE		2
#define BTN_CAPFRAME		3
#define BTN_CAPSEL		4
#define BTN_CAPAVI		5
#define BTN_CAPPAL		6
#define BTN_OVERLAY		7
#endif


#define BTNST_GRAYED		0	// 
#define BTNST_UP		1	//
#define BTNST_DOWN		2	// 
#define BTNST_FOCUSUP		3	// 
#define BTNST_FOCUSDOWN		4	// 
#define BTNST_FULLDOWN		5	// 

#define BTN_REPEAT		0x100	// add this to button index
#define BTN_SHIFT		0x200
#define BTN_DBLCLICK		0x400


/* Types of buttons */

#define BTNTYPE_PUSH		0
#define BTNTYPE_CHECKBOX	1
#define BTNTYPE_CUSTOM		2
#define BTNTYPE_RADIO		3	// MUST BE LAST to reserve room for more
					// radio groups.  (3 == one group, 
					// 4 == another group, etc.)


/* tells parent recent activity on button */
#define BTNACT_MOUSEDOWN	0	// clicked mouse button down on tool
#define BTNACT_MOUSEUP		1	// let go of mouse button while on tool
#define BTNACT_MOUSEMOVEOFF	2	// moved mouse off tool while btn down
#define BTNACT_MOUSEMOVEON	3	// moved back on tool (btn still down)
#define BTNACT_MOUSEDBLCLK	4	// dbl clicked on tool
#define BTNACT_KEYDOWN		5	// key down on tool
#define BTNACT_KEYUP		6	// key up from tool


/* constants */
#define MSEC_BUTTONREPEAT	200	// milliseconds for auto-repeat

/* timers */
#define TIMER_BUTTONREPEAT	1	// timer for button auto-repeat

/* bitmap resources */
#define IDBMP_TOOLBAR		100	// main toolbar

#ifndef _VIDCAP
#define IDBMP_ARROWS		101	// frame scrollbar arrows
#endif

#ifdef _AVIEDIT
#define IDBMP_MARK		110	// mark in/out
#define IDBMP_TRANSPORT		111	// transport controls
#define IDBMP_AUDVID		112	// editing mode
#endif




// Window words for Toolbar
#define GWW_ARRAYBUTT	0		/* Pointer to array of buttons  */
#define GWW_NUMBUTTONS	4		/* Number of buttons in array   */
#define GWW_PRESSED	8		/* Is a button currently pressed*/
#define GWW_KEYPRESSED	12		/* Is a key currently pressed?  */
#define GWW_WHICH	16		/* Which button has the focus?  */
#define GWW_SHIFTED	20		/* Is it rt-click or shift-left?*/
#define GWW_BMPHANDLE	24		/* handle to bmp of the buttons */
#define GWW_BMPINT	28		/* resource int of button bmp	*/
#define GWL_BUTTONSIZE	32		/* a point (x=hi y=lo)		*/
#define GWW_HINST	36		/* hinst of the app   		*/
#define TOOLBAR_EXTRABYTES	40

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\text.c ===
//--------------------------------------------------------------------------;
//
//  File: Text.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      TextInit()
//      TextEnd()
//      TextCreateWindow()
//      lstrLineLen()
//      GetTextLines()
//      NewBuffer()
//      TextOutputString()
//      TextPrintf()
//      DeleteText()
//      SetTextSizeLimit()
//      GotoTextLine()
//      TextSearch()
//      TextCopy()
//      DrawVScroll()
//      TextUp()
//      TextDown()
//      TextPaint()
//      TextSetFont()
//      TextGetFont()
//      TextClose()
//      TextVScroll()
//      TextHScroll()
//      TextSize()
//      TextSetRedraw()
//      TextColorChange()
//      TextLButtonDown()
//      TextLButtonUp()
//      TextMouseMove()
//      TextKey()
//      TextFocusProc()
//      TextWndProc()
//
//  History:
//      05/27/94    Fwong       Created for Wave Watcher project.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "text.h"


//==========================================================================;
//
//                             Constants...
//
//==========================================================================;

#define TEXT_BUFFER_SIZE     4096
#define VSCROLL_RANGE        1000

#define TM_PROPAGATE         WM_USER

#define TEXTFLAG_END         0x00000001
#define TEXTFLAG_REDRAW      0x00000002
#define TEXTFLAG_SELECT      0x00000004
#define TEXTFLAG_CLICK       0x00000008
#define TEXTFLAG_SCROLLUP    0x00000010
#define TEXTFLAG_SCROLLDOWN  0x00000020
#define TEXTFLAG_SCROLLLEFT  0x00000040
#define TEXTFLAG_SCROLLRIGHT 0x00000080
#define TEXTFLAG_SCROLL      0x00000100

#define TEXTFLAG_DIRMASK     0x000000f0

#define TEXTKEY_SHIFT        0x00000001
#define TEXTKEY_CONTROL      0x00000002

//==========================================================================;
//
//                         Portability Stuff...
//
//==========================================================================;

#ifdef  WIN32
#define EXPORT
#else
#define EXPORT  _export
#endif


//==========================================================================;
//
//                               Types...
//
//==========================================================================;

#ifndef LPUINT
typedef UINT FAR*           LPUINT;
#endif


//==========================================================================;
//
//                            Structures...
//
//==========================================================================;

typedef struct textbuffer_tag
{
    UINT                        uLines;
    UINT                        uOffset;
    struct textbuffer_tag FAR   *pPrev;
    struct textbuffer_tag FAR   *pNext;
    LPSTR                       pText;
    HGLOBAL                     hText;
    HGLOBAL                     hmem;
} TEXTBUFFER;
typedef TEXTBUFFER       *PTEXTBUFFER;
typedef TEXTBUFFER NEAR *NPTEXTBUFFER;
typedef TEXTBUFFER FAR  *LPTEXTBUFFER;

typedef struct location_tag
{
    DWORD   dwRow;
    UINT    uCol;
} LOCATION;
typedef LOCATION       *PLOCATION;
typedef LOCATION NEAR *NPLOCATION;
typedef LOCATION FAR  *LPLOCATION;

typedef struct textwindowinfo_tag
{
    DWORD           dwLines;
    DWORD           dwCurLine;
    DWORD           dwScroll;
    LPTEXTBUFFER    ptbFirst;
    LPTEXTBUFFER    ptbLast;
    DWORD           fdwFlags;
    COLORREF        crText;
    COLORREF        crBackGnd;
    COLORREF        crHiLiteText;
    COLORREF        crHiLiteBackGnd;
    LOCATION        locStart;
    LOCATION        locEnd;
    UINT            uBuffers;
    UINT            uCurCol;
    UINT            uMaxBuffers;
    UINT            uTextHeight;
    UINT            uTextWidth;
    HFONT           hFont;
    HGLOBAL         hmem;
} TEXTWINDOWINFO;
typedef TEXTWINDOWINFO       *PTEXTWINDOWINFO;
typedef TEXTWINDOWINFO NEAR *NPTEXTWINDOWINFO;
typedef TEXTWINDOWINFO FAR  *LPTEXTWINDOWINFO;


//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define CLEAR_FLAG(dw,flag) (dw &= (~(flag)))
#define SET_FLAG(dw,flag)   (dw |= (flag))

//==========================================================================;
//
//                              Globals...
//
//==========================================================================;

char    szTextClassName[] = "TextWindowClass";

//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

LRESULT CALLBACK EXPORT TextWndProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
);

//==========================================================================;
//
//                             Functions...
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  BOOL TextInit
//
//  Description:
//      Initializes Text window class.
//
//  Arguments:
//      HINSTANCE hinst: Handle to instance of application.
//
//  Return (BOOL):
//      TRUE if successful, FALSE otherwise.
//
//  History:
//      07/02/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

BOOL TextInit
(
    HINSTANCE   hInstance
)
{
    WNDCLASS    wc;

    //
    //  Registering window class.
    //

    wc.style          = CS_HREDRAW|CS_VREDRAW;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = sizeof(LPTEXTWINDOWINFO);
    wc.hInstance      = hInstance;
    wc.lpfnWndProc    = TextWndProc;
    wc.hIcon          = NULL;
    wc.hCursor        = LoadCursor(NULL,IDC_IBEAM);
    wc.hbrBackground  = NULL;
    wc.lpszMenuName   = NULL;
    wc.lpszClassName  = szTextClassName;
    
    if(!RegisterClass(&wc))
    {
        return FALSE;
    }

    return TRUE;
} // TextInit()


//--------------------------------------------------------------------------;
//
//  void TextEnd
//
//  Description:
//      Undoes things done by InitText.
//
//  Arguments:
//      HINSTANCE hinst: Handle to instance of application.
//
//  Return (void):
//
//  History:
//      07/02/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

void TextEnd
(
    HINSTANCE   hInstance
)
{
    //
    //  Unregistering window class.
    //

    UnregisterClass(szTextClassName,hInstance);
} // TextEnd()


//--------------------------------------------------------------------------;
//
//  HWND TextCreateWindow
//
//  Description:
//      Creates a Text Window
//
//  Arguments:
//      DWORD dwStyle: Window Style.
//
//      int x: X position of window.
//
//      int y: Y position of window.
//
//      int nWidth: Width of window.
//
//      int nHeight: Height of window.
//
//      HWND hWndParent: Handle to parent window.
//
//      HMENU hMenu: Handle to Menu.
//
//      HINSTANCE hInstance: Handle to instance.
//
//  Return (HWND):
//      Handle to window if successful, NULL otherwise.
//
//  History:
//      07/10/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

HWND TextCreateWindow
(
    DWORD       dwStyle,
    int         x,
    int         y,
    int         nWidth,
    int         nHeight,
    HWND        hWndParent,
    HMENU       hMenu,
    HINSTANCE   hInstance
)
{
    HWND                hWnd;
    HGLOBAL             hMem;
    HDC                 hDC;
    HFONT               hFont;
    TEXTMETRIC          tm;
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;

    //
    //  Allocating memory for TEXTWINDOWINFO
    //
    
    hMem = GlobalAlloc(GMEM_MOVEABLE,sizeof(TEXTWINDOWINFO));

    if(NULL == hMem)
    {
        return NULL;
    }

    ptwi = GlobalLock(hMem);

    ptwi->dwLines         = 0;
    ptwi->dwCurLine       = 0L;
    ptwi->dwScroll        = 0L;
    ptwi->uCurCol         = 0;
    ptwi->fdwFlags        = TEXTFLAG_END;
    ptwi->hmem            = hMem;
    ptwi->uBuffers        = 1;
    ptwi->uMaxBuffers     = (UINT)(-1);
    ptwi->hFont           = GetStockFont(ANSI_FIXED_FONT);
    ptwi->crText          = GetSysColor(COLOR_WINDOWTEXT);
    ptwi->crBackGnd       = GetSysColor(COLOR_WINDOW);
    ptwi->crHiLiteText    = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ptwi->crHiLiteBackGnd = GetSysColor(COLOR_HIGHLIGHT);

    ptwi->locStart.dwRow  = 0L;
    ptwi->locStart.uCol   = 0;
    ptwi->locEnd.dwRow    = 0L;
    ptwi->locEnd.uCol     = 0;

    //
    //  Allocating memory for TEXTBUFFER
    //

    hMem = GlobalAlloc(GMEM_MOVEABLE,sizeof(TEXTBUFFER));

    if(NULL == hMem)
    {
        hMem = ptwi->hmem;

        GlobalUnlock(hMem);
        GlobalFree(hMem);

        return NULL;
    }

    ptb = GlobalLock(hMem);

    ptwi->ptbFirst = ptb;
    ptwi->ptbLast  = ptb;

    ptb->uLines  = 0;
    ptb->uOffset = 0;
    ptb->pPrev   = ptb;
    ptb->pNext   = ptb;
    ptb->hmem    = hMem;

    //
    //  Allocating memory for text
    //

    hMem = GlobalAlloc(GMEM_MOVEABLE,TEXT_BUFFER_SIZE);

    if(NULL == hMem)
    {
        hMem = ptwi->hmem;

        GlobalUnlock(hMem);
        GlobalFree(hMem);

        hMem = ptb->hmem;

        GlobalUnlock(hMem);
        GlobalFree(hMem);

        return NULL;
    }

    ptb->hText = hMem;
    ptb->pText = GlobalLock(hMem);

    //
    //  Creating window...
    //

    hWnd = CreateWindow(
        szTextClassName,
        "",
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        NULL);

    SetWindowLong(hWnd,0,(LONG)ptwi);

    //
    //  Disabling scroll bars...
    //

    SetScrollRange(hWnd,SB_VERT,0,0,TRUE);
    SetScrollRange(hWnd,SB_HORZ,0,0,TRUE);

    hDC   = GetDC(hWnd);
    hFont = SelectFont(hDC,ptwi->hFont);

    GetTextMetrics(hDC,&tm);
    ptwi->uTextHeight = tm.tmHeight + tm.tmExternalLeading;
    ptwi->uTextWidth  = tm.tmAveCharWidth;

    SelectFont(hDC,hFont);
    ReleaseDC(hWnd,hDC);

    return hWnd;
} // TextCreateWindow()


//--------------------------------------------------------------------------;
//
//  int lstrLineLen
//
//  Description:
//      Gets the length of a zero, '\r' or '\n' terminated string.
//
//  Arguments:
//      LPSTR pszStr: Pointer to character string.
//
//  Return (int):
//      Size (in characters) of string.
//
//  History:
//      10/17/94    Fwong       Support function.
//
//--------------------------------------------------------------------------;

int lstrLineLen
(
    LPSTR   pszStr
)
{
    int     i;
    char    c;

    for(i=0;;i++,pszStr++)
    {
        c = *pszStr;

        if(('\n' == c) || ('\r' == c) || (0 == c))
        {
            return i;
        }
    }
} // lstrLineLen()


//--------------------------------------------------------------------------;
//
//  UINT GetTextLines
//
//  Description:
//      Gets the number of lines displayable in current window.
//
//  Arguments:
//      HWND hWnd:  Window Handle.
//
//  Return (UINT):
//      Number of lines that current window can hold.
//
//  History:
//      10/17/94    Fwong       Support function.
//
//--------------------------------------------------------------------------;

UINT GetTextLines
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;
    RECT                r;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    GetClientRect(hWnd,&r);

    return (UINT)(r.bottom / ptwi->uTextHeight);
} // GetTextLines()


//--------------------------------------------------------------------------;
//
//  LPTEXTBUFFER NewBuffer
//
//  Description:
//      Allocates or recycles buffer for output.
//
//  Arguments:
//      LPTEXTWINDOWINFO ptwi: Pointer to TEXTWINDOWINFO.
//
//  Return (LPTEXTBUFFER):
//      Pointer to "new" TEXTBUFFER.
//
//  History:
//      07/02/94    Fwong       Doing Text window class.
//
//--------------------------------------------------------------------------;

LPTEXTBUFFER NewBuffer
(
    HWND    hWnd
)
{
    LPTEXTBUFFER        ptb;
    LPTEXTWINDOWINFO    ptwi;
    HGLOBAL             hMem;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    //
    //  Have we reached our maximum number of buffers?
    //

    if(ptwi->uBuffers < ptwi->uMaxBuffers)
    {
        //
        //  Allocating memory for new buffer...
        //

        hMem = GlobalAlloc(GMEM_MOVEABLE,sizeof(TEXTWINDOWINFO));

        if(NULL != hMem)
        {
            //
            //  Memory allocation successful; let's initialize.
            //

            ptb = GlobalLock(hMem);

            ptb->uLines   = 0;
            ptb->uOffset  = 0;
            ptb->pPrev    = ptwi->ptbLast;
            ptb->pNext    = ptwi->ptbFirst;
            ptb->hmem     = hMem;

            //
            //  Allocating memory for text.
            //

            hMem = GlobalAlloc(GMEM_MOVEABLE,TEXT_BUFFER_SIZE);

            if(NULL != hMem)
            {
                //
                //  Memory allocation successful; let's finish up and return
                //

                ptb->pText    = GlobalLock(hMem);
                ptb->hText    = hMem;

                ptwi->ptbLast->pNext  = ptb;
                ptwi->ptbFirst->pPrev = ptb;
                ptwi->ptbLast         = ptb;
                ptwi->uBuffers++;

                return ptb;
            }
            else
            {
                //
                //  Second allocation unsuccessful; clean up first buffer
                //  recycle first buffer.
                //

                hMem = ptb->hmem;

                GlobalUnlock(hMem);
                GlobalFree(hMem);
            }
        }

    }

    //
    //  Okay... we're recycling buffers...
    //  Note: This is _assuming_ we have more than one buffer.
    //

    ptb = ptwi->ptbFirst;

    ptwi->ptbFirst = ptwi->ptbFirst->pNext;
    ptwi->ptbLast  = ptwi->ptbLast->pNext;

    ptwi->dwLines -= (ptb->uLines);

    if(!(ptwi->fdwFlags & TEXTFLAG_END))
    {
        if(ptwi->dwCurLine < ptb->uLines)
        {
            ptwi->dwCurLine  = 0;
        }
        else
        {
            ptwi->dwCurLine -= ptb->uLines;
        }
    }

    if(ptwi->fdwFlags & TEXTFLAG_SELECT)
    {
        if(ptwi->locEnd.dwRow < ptb->uLines)
        {
            ptwi->locEnd.dwRow = 0;
            ptwi->locEnd.uCol  = 0;
        }
        else
        {
            ptwi->locEnd.dwRow -= ptb->uLines;
        }

        if(ptwi->locStart.dwRow < ptb->uLines)
        {
            ptwi->locStart.dwRow = 0;
            ptwi->locStart.uCol  = 0;
        }
        else
        {
            ptwi->locStart.dwRow -= ptb->uLines;
        }
    }

    ptb->uLines   = 0;
    ptb->uOffset  = 0;

    return ptb;
} // NewBuffer()


//--------------------------------------------------------------------------;
//
//  void TextOutputString
//
//  Description:
//      Outputs raw string into Text Window.
//
//  Arguments:
//      HWND hWnd: Handle to Text Window.
//
//      LPSTR pszText: String to output.
//
//  Return (void):
//
//  History:
//      10/17/94    Fwong       "Exported" function.
//
//--------------------------------------------------------------------------;

void TextOutputString
(
    HWND    hWnd,
    LPSTR   pszText
)
{
    int                 i;
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    UINT                uLines;
    RECT                r;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    ptb = ptwi->ptbLast;

    for(;;)
    {
        i = lstrLineLen(pszText) + 1;

        if(TEXT_BUFFER_SIZE < (ptb->uOffset + i))
        {
            ptb = NewBuffer(hWnd);
        }

        ptwi->dwLines++;
        ptb->uLines++;
        ptwi->dwScroll++;
        lstrcpyn((LPSTR)(&(ptb->pText[ptb->uOffset])),pszText,i);
        ptb->uOffset += (i);
        pszText += (i-1);

        if(0 == *pszText)
        {
            break;
        }

        if('\r' == *pszText)
        {
            pszText++;
        }

        if('\n' == *pszText)
        {
            pszText++;
        }
    }

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        if(ptwi->fdwFlags & TEXTFLAG_REDRAW)
        {
            GetClientRect(hWnd,&r);

            uLines = (UINT)ptwi->dwScroll;
            ptwi->dwScroll = 0L;

            if(ptwi->dwLines <= (r.bottom / ptwi->uTextHeight))
            {
                r.top    = (int)((ptwi->dwLines - (DWORD)uLines) *
                        ptwi->uTextHeight);

                r.bottom = r.top + uLines * ptwi->uTextHeight;

                InvalidateRect(hWnd,&r,FALSE);
            }
            else
            {
                uLines  *= ptwi->uTextHeight;

                r.bottom = r.bottom - r.bottom % ptwi->uTextHeight;
                r.top    = uLines;

                ScrollWindow(hWnd,0,(-1)*uLines,&r,NULL);
            }

            UpdateWindow(hWnd);
        }
        else
        {
            if(!(ptwi->fdwFlags & TEXTFLAG_SCROLL))
            {
                SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLL);
                PostMessage(hWnd,TM_PROPAGATE,0,0L);
            }
        }
    }

//    if(ptwi->fdwFlags & TEXTFLAG_REDRAW)
//    {
//        UpdateWindow(hWnd);
//    }

} // TextOutputString()


//--------------------------------------------------------------------------;
//
//  int TextPrintf
//
//  Description:
//      Equivalent to printf, but goes to window.  Note there is a 250
//          character limit.  Bump up if needed.
//
//  Arguments:
//      HWND hWnd: Handle to Text window.
//
//      LPSTR pszFormat: Pointer to format string.
//
//  Return (int):
//      Number of characters outputted.
//
//  History:
//      10/25/94    Fwong       Printf-like output function.
//
//--------------------------------------------------------------------------;

int _cdecl TextPrintf
(
    HWND    hWnd,
    LPSTR   pszFormat,
    ...
)
{
    char    szOutput[250];
    va_list va;
    int     cch;

    va_start(va,pszFormat);
    cch = wvsprintf(szOutput,pszFormat,va);
    va_end(va);

    TextOutputString(hWnd,szOutput);

    return cch;
} // TextPrintf()


void PropagateDraw(HWND hWnd)
{
    RECT                r;
    UINT                uLines;
    LPTEXTWINDOWINFO    ptwi;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    GetClientRect(hWnd,&r);

    uLines = r.bottom / ptwi->uTextHeight;

    if(ptwi->dwScroll > (DWORD)uLines)
    {
        InvalidateRect(hWnd,NULL,FALSE);
        UpdateWindow(hWnd);
    }

    uLines = (UINT)ptwi->dwScroll;
    ptwi->dwScroll = 0L;

    if(ptwi->dwLines <= (r.bottom / ptwi->uTextHeight))
    {
        r.top    = (int)((ptwi->dwLines - (DWORD)uLines) * ptwi->uTextHeight);
        r.bottom = r.top + uLines * ptwi->uTextHeight;

        InvalidateRect(hWnd,&r,FALSE);
    }
    else
    {
        uLines  *= ptwi->uTextHeight;

        r.bottom = r.bottom - r.bottom % ptwi->uTextHeight;
        r.top    = uLines;

        ScrollWindow(hWnd,0,(-1)*uLines,&r,NULL);
    }

    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLL);
    UpdateWindow(hWnd);
}


//--------------------------------------------------------------------------;
//
//  void DeleteText
//
//  Description:
//      Clears window of text.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Adding functionality to clear the screen.
//
//--------------------------------------------------------------------------;

void DeleteText
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    HGLOBAL             hMem;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    
    if(ptwi->ptbLast != ptwi->ptbFirst)
    {
        //
        //  Freeing memory for all but first TEXTBUFFER...
        //

        ptwi->ptbLast->pNext = NULL;

        for(ptb = ptwi->ptbFirst->pNext;NULL != ptb;)
        {
            //
            //  Freeing memory for actual text.
            //

            hMem = ptb->hText;

            GlobalUnlock(hMem);
            GlobalFree(hMem);

            //
            //  Freeing memory for this (TEXTBUFFER) structure...
            //

            hMem = ptb->hmem;
            ptb  = ptb->pNext;

            GlobalUnlock(hMem);
            GlobalFree(hMem);
        }
    }

    ptwi->dwLines   = 0;
    ptwi->dwCurLine = 0L;
    ptwi->uBuffers  = 1;
    ptwi->ptbLast   = ptwi->ptbFirst;

    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);

    ptb          = ptwi->ptbFirst;
    ptb->uLines  = 0;
    ptb->uOffset = 0;
    ptb->pPrev   = ptb;
    ptb->pNext   = ptb;

    InvalidateRect(hWnd,NULL,TRUE);
} // DeleteText()


//--------------------------------------------------------------------------;
//
//  DWORD GetTextSizeLimit
//
//  Description:
//      Gets the current size limit (in bytes) for text window before
//          starting to recycle buffers.
//
//  Arguments:
//      HWND hWnd:  Handle to window.
//
//  Return (DWORD):
//      Size (in bytes) of buffer size limit.
//
//  History:
//      11/28/94    Fwong       Adding query flexibility.
//
//--------------------------------------------------------------------------;

DWORD GetTextSizeLimit
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    return (TEXT_BUFFER_SIZE * ptwi->uMaxBuffers);
} // GetTextSizeLimit()


//--------------------------------------------------------------------------;
//
//  DWORD SetTextSizeLimit
//
//  Description:
//      Sets the size limit (in bytes) for text before starting to
//          recycle buffers.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      DWORD cbSize: Size (in bytes) of desired memory.
//
//      UINT uFlags: Flags for function (if you want to truncate).
//
//  Return (DWORD):
//      Actual maximum size (may be little more than requested).
//
//  History:
//      10/25/94    Fwong       Adding flexibility.
//
//--------------------------------------------------------------------------;

DWORD SetTextSizeLimit
(
    HWND    hWnd,
    DWORD   cbSize,
    UINT    uFlags
)
{
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    HGLOBAL             hMem;
    UINT                u;

    if(0 == cbSize)
    {
        cbSize++;
    }

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    u = (UINT)(cbSize / TEXT_BUFFER_SIZE + ((cbSize % TEXT_BUFFER_SIZE)?1:0));

    ptwi->uMaxBuffers = u;

    if(u < ptwi->uBuffers)
    {
        if(uFlags & SETSIZEFLAG_TRUNCATE)
        {
            u   = ptwi->uBuffers - ptwi->uMaxBuffers;
            ptb = ptwi->ptbFirst;

            for(;u;u--)
            {
                ptwi->ptbFirst = ptwi->ptbFirst->pNext;
            }

            ptwi->ptbLast->pNext  = ptwi->ptbFirst;
            ptwi->ptbFirst->pPrev = ptwi->ptbLast;

            u = ptwi->uBuffers - ptwi->uMaxBuffers;

            for(;u;u--)
            {
                ptwi->dwLines -= ptb->uLines;

                if(!(ptwi->fdwFlags & TEXTFLAG_END))
                {
                    if(ptwi->dwCurLine < ptb->uLines)
                    {
                        ptwi->dwCurLine  = 0;
                    }
                    else
                    {
                        ptwi->dwCurLine -= ptb->uLines;
                    }
                }

                hMem = ptb->hText;

                //
                //  Freeing memory for actual text.
                //

                GlobalUnlock(hMem);
                GlobalFree(hMem);

                hMem = ptb->hmem;
                ptb  = ptb->pNext;

                //
                //  Freeing memory for this (TEXTBUFFER) structure...
                //

                GlobalUnlock(hMem);
                GlobalFree(hMem);
            }
        }
        else
        {
            //
            //  Not truncating buffer to so setting max to current number...
            //

            ptwi->uMaxBuffers = ptwi->uBuffers;
        }
    }

    return (TEXT_BUFFER_SIZE * (ptwi->uMaxBuffers));
} // SetTextSizeLimit()


//--------------------------------------------------------------------------;
//
//  LPTEXTBUFFER GotoTextLine
//
//  Description:
//      Goes to specific text line.
//
//  Arguments:
//      LPTEXTWINDOWINFO ptwi: Pointer to TEXTWINDOWINFO structure.
//
//      LPUINT puOffset: Offset into TEXTBUFFER (returned).
//
//      DWORD dwLine: Destination line.
//
//  Return (LPTEXTBUFFER):
//      Pointer to text buffer containing line.
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

LPTEXTBUFFER GotoTextLine
(
    LPTEXTWINDOWINFO    ptwi,
    LPUINT              puOffset,
    DWORD               dwLine
)
{
    LPTEXTBUFFER    ptb;
    UINT            uOffset;

    //
    //  Walking list of TextBuffers.
    //

    for(ptb = ptwi->ptbFirst;
        (dwLine && (dwLine >= ptb->uLines));
        ptb = ptb->pNext)
    {
        dwLine -= ptb->uLines;
    }

    //
    //  Getting to particular line...
    //

    for(uOffset = 0;dwLine;dwLine--,uOffset++)
    {                            
        uOffset += lstrlen(&(ptb->pText[uOffset]));
    }

    *puOffset = uOffset;

    return ptb;
} // GotoTextLine()


//--------------------------------------------------------------------------;
//
//  BOOL TextSearch
//
//  Description:
//      Searches for given text in buffer starting from either:
//          Top of current text OR immediately following current
//          hilight (if text is selected).
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      LPSTR pszSearch: String to search for.
//
//      UINT uFlags: Flags for searching (case sensitivity).
//
//  Return (BOOL):
//      TRUE if found, FALSE otherwise.
//
//  History:
//      11/22/94    Fwong       Additional functionality to text class.
//
//--------------------------------------------------------------------------;

BOOL TextSearch
(
    HWND    hWnd,
    LPSTR   pszSearch,
    UINT    uFlags
)
{
    LPTEXTWINDOWINFO    ptwi;
    DWORD               dwLine,dwOldLine;
    UINT                uOffset,len;
    UINT                u,i,j,k,uMargin;
    LPTEXTBUFFER        ptb;
    LPSTR               pText;
    char                achTable[256];

    ptwi  = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    len   = lstrlen(pszSearch);

    if(TEXTFLAG_SELECT & ptwi->fdwFlags)
    {
        //
        //  Text is selected.  Start search immediately after start of
        //  selection.
        //

        dwLine = min((ptwi->locStart.dwRow),(ptwi->locEnd.dwRow));
        
        if(ptwi->locStart.dwRow == ptwi->locEnd.dwRow)
        {
            u = min((ptwi->locStart.uCol),(ptwi->locEnd.uCol));
        }
        else
        {
            if(ptwi->locStart.dwRow < ptwi->locEnd.dwRow)
            {
                u = ptwi->locStart.uCol;
            }
            else
            {
                u = ptwi->locEnd.uCol;
            }
        }

        u++;

        //
        //  Just in case you have multiple finds on one line...
        //

        dwOldLine = dwLine;
        uMargin   = u;

        ptb      = GotoTextLine(ptwi,&uOffset,dwLine);

        pText    = &(ptb->pText[uOffset]);
        i        = lstrlen(pText);
        u        = min(u,i);
        pText   += u;
        uOffset += u;
    }
    else
    {
        //
        //  No text is selected.  Start search from top of window.
        //

        ptb    = GotoTextLine(ptwi,&uOffset,ptwi->dwCurLine);
        pText  = &(ptb->pText[uOffset]);

        dwLine = ptwi->dwCurLine;
    }

    //
    //  Note: The following "for" and "if" are _VERY_ ANSI depedented!!
    //

    for(u = 256;u;u--)
    {
        achTable[u - 1] = (BYTE)(u - 1);
    }

    if(!(SEARCHFLAG_MATCHCASE & uFlags))
    {
        for(u = 26; u; u--)
        {
            achTable['A' + u - 1] = 'a' + u - 1;
        }
    }

    for(;;dwLine++)
    {
        u = lstrlen(pText);

        if(u >= len)
        {
            i = u - len;

            for(j = 0;j < i;j++)
            {
                for(k = len; k; k--)
                {
                    if(achTable[pszSearch[k-1]] != achTable[pText[k+j-1]])
                    {
                        break;
                    }
                }

                if(0 == k)
                {
                    //
                    //  FOUND!!  WAY COOL!!
                    //

                    ptwi->locStart.dwRow = dwLine;
                    ptwi->locStart.uCol  = j;

                    ptwi->locEnd.dwRow   = dwLine;
                    ptwi->locEnd.uCol    = j+len;

                    if ((TEXTFLAG_SELECT & ptwi->fdwFlags) &&
                        (dwLine == dwOldLine))
                    {
                        ptwi->locStart.uCol += uMargin;
                        ptwi->locEnd.uCol   += uMargin;
                    }

                    u = GetTextLines(hWnd);

                    if(dwLine >= (ptwi->dwCurLine + u))
                    {
                        //
                        //  We fell outside of the window; update viewport.
                        //

                        ptwi->dwCurLine = dwLine;

                        if(ptwi->dwLines <= (dwLine + u))
                        {
                            SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
                        }
                    }

                    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
                    InvalidateRect(hWnd,NULL,TRUE);

                    return TRUE;
                }
            }
        }

        uOffset += (u + 1);

        if(uOffset == ptb->uOffset)
        {
            ptb        = ptb->pNext;
            pText      = ptb->pText;
            uOffset    = 0;

            if(ptb == ptwi->ptbFirst)
            {
                //
                //  Hmm... we're wrapping around?!
                //

                return FALSE;
            }
        }
        else
        {
            pText = &(pText[u+1]);
        }
    }
} // TextSearch()


//--------------------------------------------------------------------------;
//
//  void TextCopy
//
//  Description:
//      Copies "high-lighted" text to clipboard.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Adding copy to clipboard functionality.
//
//--------------------------------------------------------------------------;

void TextCopy
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    DWORD               dw,cbBuffer;
    LPSTR               pText;
    HGLOBAL             hMem;
    LPSTR               pDest;
    UINT                u,uAdd;
    UINT                uOffset;
    LOCATION            loc1,loc2;

    ptwi  = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    
    if((ptwi->locStart.dwRow == ptwi->locEnd.dwRow) &&
        (ptwi->locStart.uCol == ptwi->locEnd.uCol))
    {
        return;
    }

    if(!(ptwi->fdwFlags & TEXTFLAG_SELECT))
    {
        return;
    }

    //
    //  Sorting locations...
    //

    loc1.dwRow = min(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);
    loc2.dwRow = max(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);

    if(loc1.dwRow == loc2.dwRow)
    {
        loc1.uCol = min(ptwi->locStart.uCol,ptwi->locEnd.uCol);
        loc2.uCol = max(ptwi->locStart.uCol,ptwi->locEnd.uCol);
    }
    else
    {
        if(loc1.dwRow == ptwi->locStart.dwRow)
        {
            loc1.uCol = ptwi->locStart.uCol;
            loc2.uCol = ptwi->locEnd.uCol;
        }
        else
        {
            loc2.uCol = ptwi->locStart.uCol;
            loc1.uCol = ptwi->locEnd.uCol;
        }
    }
    
    ptb = GotoTextLine(ptwi,&uOffset,loc1.dwRow);

    cbBuffer = 0;
    pText    = &(ptb->pText[uOffset]);

    for(dw = loc1.dwRow;dw <= loc2.dwRow;dw++)
    {
        u = lstrlen(pText);

        uAdd = (dw == loc2.dwRow)?(min(loc2.uCol,u)):u;
        uAdd = (dw == loc1.dwRow)?(uAdd - min(uAdd,loc1.uCol)):uAdd;

        cbBuffer += uAdd;
        uOffset  += (u + 1);

        if(uOffset == ptb->uOffset)
        {
            ptb        = ptb->pNext;
            pText      = ptb->pText;
            uOffset    = 0;

            if(ptb == ptwi->ptbFirst)
            {
                //
                //  Hmm... we're wrapping around?!
                //

                break;
            }
        }
        else
        {
            pText = &(pText[u+1]);
        }
    }

    cbBuffer += (2*(dw - loc1.dwRow) + 1);
    dw        = loc1.dwRow;

    //
    //  Note: GHND includes GMEM_ZEROINIT, no need to add '\0' to end.
    //

    hMem = GlobalAlloc(GHND,cbBuffer);

    if(NULL == hMem)
    {
        return;
    }

    pDest = GlobalLock(hMem);

    if(NULL == pDest)
    {
        GlobalFree(hMem);
        return;
    }

    ptb = GotoTextLine(ptwi,&uOffset,loc1.dwRow);
 
    pText = &(ptb->pText[uOffset]);

    for(dw = loc1.dwRow;dw <= loc2.dwRow;dw++)
    {
        u = lstrlen(pText);

        uAdd = (dw == loc1.dwRow)?(min(u,loc1.uCol)):0;

        if(dw == loc2.dwRow)
        {
            lstrcpyn(pDest,&(pText[uAdd]),min(u,loc2.uCol) - uAdd + 1);
        }
        else
        {
            lstrcpy(pDest,&(pText[uAdd]));
            pDest    += lstrlen(pDest);
            pDest[0]  = '\r';
            pDest[1]  = '\n';
            pDest    += 2;
        }

        uOffset  += (u + 1);

        if(uOffset == ptb->uOffset)
        {
            ptb        = ptb->pNext;
            pText      = ptb->pText;
            uOffset    = 0;

            if(ptb == ptwi->ptbFirst)
            {
                //
                //  Hmm... we're wrapping around?!
                //

                break;
            }
        }
        else
        {
            pText = &(pText[u+1]);
        }
    }

    GlobalUnlock(hMem);

    OpenClipboard(hWnd);
    EmptyClipboard();
    
    SetClipboardData(CF_TEXT,hMem);
    CloseClipboard();

} // TextCopy()


//--------------------------------------------------------------------------;
//
//  void DrawVScroll
//
//  Description:
//      Draws the vertical scroll bar.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

void DrawVScroll
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;
    DWORD               dw;

    ptwi  = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        SetScrollPos(hWnd,SB_VERT,VSCROLL_RANGE,TRUE);
    }
    else
    {
        dw = ptwi->dwLines - GetTextLines(hWnd);
        dw = ((ptwi->dwCurLine)*VSCROLL_RANGE)/(dw) + 1;

        SetScrollPos(hWnd,SB_VERT,(int)dw,TRUE);
    }

} // DrawVScroll()


//--------------------------------------------------------------------------;
//
//  void TextUp
//
//  Description:
//      "Scrolls" text up by dwDelta amount.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      DWORD dwDelta: Number of lines to scroll up.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

void TextUp
(
    HWND    hWnd,
    DWORD   dwDelta
)
{
    LPTEXTWINDOWINFO    ptwi;
    UINT                i,j;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    if(0 == ptwi->dwCurLine)
    {
        //
        //  We're already on first line.
        //

        return;
    }

    GetScrollRange(hWnd,SB_VERT,&i,&j);

    if(0 == j)
    {
        //
        //  Scrollbar not enabled.  Nothing to scroll.
        //

        return;
    }

    i     = GetTextLines(hWnd);

    if(dwDelta > ptwi->dwCurLine)
    {
        //
        //  Scrolling up more than number of lines?
        //

        ptwi->dwCurLine = 0;
    }
    else
    {
        ptwi->dwCurLine -= dwDelta;
    }
    
    InvalidateRect(hWnd,NULL,TRUE);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
} // TextUp()


//--------------------------------------------------------------------------;
//
//  void TextDown
//
//  Description:
//      "Scrolls" text down by dwDelta amount.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      DWORD dwDelta: Number of lines to scroll down.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Helper function.
//
//--------------------------------------------------------------------------;

void TextDown
(
    HWND    hWnd,
    DWORD   dwDelta
)
{
    LPTEXTWINDOWINFO    ptwi;
    UINT                i,j;
    DWORD               dwEnd;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        //
        //  We're already on last line.
        //

        return;
    }

    GetScrollRange(hWnd,SB_VERT,&i,&j);

    if(0 == j)
    {
        //
        //  Scrollbar not enabled.  Nothing to scroll.
        //

        return;
    }

    i     = GetTextLines(hWnd);
    dwEnd = ptwi->dwLines - i;
    
    ptwi->dwCurLine += dwDelta;

    if(ptwi->dwCurLine >= dwEnd)
    {
        ptwi->dwCurLine = dwEnd;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
    }

    InvalidateRect(hWnd,NULL,TRUE);
} // TextDown()


//--------------------------------------------------------------------------;
//
//  void TextPaint
//
//  Description:
//      Handles WM_PAINT messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextPaint
(
    HWND    hWnd
)
{
    HDC                 hDC;
    PAINTSTRUCT         ps;
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    COLORREF            crText,crBackGnd;
    HPEN                hPen;
    HBRUSH              hBrush;
    RECT                r,r2;
    LOCATION            loc1,loc2;
    UINT                nLines;
    UINT                uOffset;
    UINT                nPos;
    UINT                u,i;
    UINT                nLen,nStart;
    LPSTR               pText;
    HFONT               hFont;
    DWORD               dw;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    hDC    = BeginPaint(hWnd,&ps);
    hFont  = SelectFont(hDC,ptwi->hFont);

    nLines = GetTextLines(hWnd);
    nLines = (UINT)min((DWORD)nLines,(ptwi->dwLines));

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        ptwi->dwCurLine = ptwi->dwLines - nLines;
    }

    if(nLines != ptwi->dwLines)
    {
        SetScrollRange(hWnd,SB_VERT,1,VSCROLL_RANGE,FALSE);
        DrawVScroll(hWnd);
    }
    else
    {
        SetScrollRange(hWnd,SB_VERT,0,0,TRUE);
    }

    //
    //  Sorting locations...
    //

    if(ptwi->fdwFlags & TEXTFLAG_SELECT)
    {
        loc1.dwRow = min(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);
        loc2.dwRow = max(ptwi->locStart.dwRow,ptwi->locEnd.dwRow);

        if(loc1.dwRow == loc2.dwRow)
        {
            loc1.uCol = min(ptwi->locStart.uCol,ptwi->locEnd.uCol);
            loc2.uCol = max(ptwi->locStart.uCol,ptwi->locEnd.uCol);
        }
        else
        {
            if(loc1.dwRow == ptwi->locStart.dwRow)
            {
                loc1.uCol = ptwi->locStart.uCol;
                loc2.uCol = ptwi->locEnd.uCol;
            }
            else
            {
                loc2.uCol = ptwi->locStart.uCol;
                loc1.uCol = ptwi->locEnd.uCol;
            }
        }
    }
    else
    {
        //
        //  This way nothing will be selected.  Will do more elegant fix
        //  later.
        //

        loc1.dwRow = (DWORD)(-1);
        loc1.dwRow = (DWORD)(-1);
        loc2.uCol  = (UINT)(-1);
        loc2.uCol  = (UINT)(-1);
    }

    //
    //  Horizontal Scroll Bar?!
    //

    GetWindowRect(hWnd,&r);

    u = (r.bottom - r.top - GetSystemMetrics(SM_CYHSCROLL)) / ptwi->uTextHeight;

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        dw = (UINT)min((DWORD)u,(ptwi->dwLines));
        dw = ptwi->dwLines - dw;
    }
    else
    {
        dw = ptwi->dwCurLine;
    }

    //
    //  Finding maximume line length in lines to be displayed.
    //

    ptb   = GotoTextLine(ptwi,&uOffset,dw);
    pText = &(ptb->pText[uOffset]);

    u = min(u,nLines);

    for(dw = u,u = 0;dw;dw--)
    {
        i = lstrlen(pText);
        u = max(i,u);

        uOffset += (i + 1);

        if(uOffset == ptb->uOffset)
        {
            ptb     = ptb->pNext;
            pText   = ptb->pText;
            uOffset = 0;
        }
        else
        {
            pText = &(pText[i+1]);
        }
    }

    GetClientRect(hWnd,&r);

    nPos = r.right / ptwi->uTextWidth;

    if(u > nPos)
    {
        u -= nPos;

        SetScrollRange(hWnd,SB_HORZ,0,u,FALSE);
        SetScrollPos(hWnd,SB_HORZ,ptwi->uCurCol,TRUE);
    }
    else
    {
        ptwi->uCurCol = 0;
        SetScrollRange(hWnd,SB_HORZ,0,0,TRUE);
    }

    ptb   = GotoTextLine(ptwi,&uOffset,ptwi->dwCurLine);
    pText = &(ptb->pText[uOffset]);

    crText    = SetTextColor(hDC,ptwi->crText);
    crBackGnd = SetBkColor(hDC,ptwi->crBackGnd);

    GetClientRect(hWnd,&r);
    dw = ptwi->dwCurLine;

    //
    //  Offsetting locations by current horizontal position.
    //

    loc1.uCol = (ptwi->uCurCol > loc1.uCol)?0:(loc1.uCol - ptwi->uCurCol);
    loc2.uCol = (ptwi->uCurCol > loc2.uCol)?0:(loc2.uCol - ptwi->uCurCol);

    for(nPos = 0;nLines;nLines--,nPos += ptwi->uTextHeight,dw++)
    {
        i = lstrlen(pText);

        u = min(ptwi->uCurCol,((UINT)i));
        pText = &(pText[u]);
        i -= u;

        r.top    = nPos;
        r.bottom = nPos + ptwi->uTextHeight;

        if((dw < loc1.dwRow) || (dw > loc2.dwRow))
        {
            ExtTextOut(hDC,0,nPos,ETO_OPAQUE,&r,pText,i,NULL);
        }
        else
        {
            nLen = min(((UINT)i),loc2.uCol);
            nLen = (dw == loc2.dwRow)?nLen:i;

            nStart = min(((UINT)i),loc1.uCol);
            nStart = (dw == loc1.dwRow)?nStart:0;

            r2.top    = nPos;
            r2.bottom = r.bottom;
            r2.left   = nStart * ptwi->uTextWidth;
            r2.right  = nLen * ptwi->uTextWidth;

            SetTextColor(hDC,ptwi->crHiLiteText);
            SetBkColor(hDC,ptwi->crHiLiteBackGnd);

            ExtTextOut(hDC,r2.left,nPos,ETO_OPAQUE,&r2,&(pText[nStart]),nLen-nStart,NULL);

            SetTextColor(hDC,ptwi->crText);
            SetBkColor(hDC,ptwi->crBackGnd);

            r2.right = r2.left;
            r2.left  = 0;

            if(0 != r2.right)
            {
                ExtTextOut(hDC,0,nPos,ETO_OPAQUE,&r2,pText,nStart,NULL);
            }

            r2.right = r.right;
            r2.left  = nLen * ptwi->uTextWidth;

            ExtTextOut(hDC,r2.left,nPos,ETO_OPAQUE,&r2,&(pText[nLen]),i-nLen,NULL);
        }

        uOffset += (i + 1);

        if(uOffset == ptb->uOffset)
        {
            ptb     = ptb->pNext;
            pText   = ptb->pText;
            uOffset = 0;
        }
        else
        {
            pText = &(pText[i+1]);
        }
    }

    hBrush = CreateSolidBrush(ptwi->crBackGnd);
    hPen   = GetStockObject(NULL_PEN);

    //
    //  Drawing remainder of window (rectange)...
    //

    if(NULL == hBrush)
    {
        hBrush = GetStockObject(NULL_BRUSH);
    }

    hBrush = SelectObject(hDC,hBrush);
    hPen   = SelectObject(hDC,hPen);
    GetClientRect(hWnd,&r);
    Rectangle(hDC,0,nPos,r.right+1,r.bottom+1);
    hPen   = SelectObject(hDC,hPen);
    hBrush = SelectObject(hDC,hBrush);
    DeleteObject(hBrush);

    SetBkColor(hDC,crBackGnd);
    SetTextColor(hDC,crText);

    SelectFont(hDC,hFont);

    EndPaint(hWnd,&ps);

    //
    //  Are we scrolling?
    //

    if(TEXTFLAG_SCROLLUP & ptwi->fdwFlags)
    {
        if(0 != ptwi->dwCurLine)
        {
            TextUp(hWnd,1);
            ptwi->locEnd.dwRow = ptwi->dwCurLine;
        }
    }

    if(TEXTFLAG_SCROLLDOWN & ptwi->fdwFlags)
    {
        if(!(ptwi->fdwFlags & TEXTFLAG_END))
        {
            TextDown(hWnd,1);
            ptwi->locEnd.dwRow++;
        }
    }

    if(TEXTFLAG_SCROLLLEFT & ptwi->fdwFlags)
    {
        if(0 != ptwi->uCurCol)
        {
            ptwi->uCurCol--;
            ptwi->locEnd.uCol--;
            InvalidateRect(hWnd,NULL,TRUE);
        }
    }

    if(TEXTFLAG_SCROLLRIGHT & ptwi->fdwFlags)
    {
        GetScrollRange(hWnd,SB_HORZ,&i,&u);
        if(u > ptwi->uCurCol)
        {
            ptwi->uCurCol++;
            ptwi->locEnd.uCol++;
            InvalidateRect(hWnd,NULL,TRUE);
        }
    }

} // TextPaint()


//--------------------------------------------------------------------------;
//
//  void TextSetFont
//
//  Description:
//      Sets the font in window.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      HFONT hFont: Handle to font.
//
//      BOOL fRedraw: TRUE if window is to be redrawn.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Adding flexibility.
//
//--------------------------------------------------------------------------;

void TextSetFont
(
    HWND    hWnd,
    HFONT   hFont,
    BOOL    fRedraw
)
{
    LPTEXTWINDOWINFO    ptwi;
    TEXTMETRIC          tm;
    HDC                 hDC;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    if(NULL == hFont)
    {
        hFont = GetStockFont(ANSI_FIXED_FONT);
    }

    ptwi->hFont = hFont;

    hDC   = GetDC(hWnd);
    hFont = SelectFont(hDC,hFont);

    GetTextMetrics(hDC,&tm);
    ptwi->uTextHeight = tm.tmHeight + tm.tmExternalLeading;
    ptwi->uTextWidth  = tm.tmAveCharWidth;

    SelectFont(hDC,hFont);
    ReleaseDC(hWnd,hDC);

    if(fRedraw)
    {
        InvalidateRect(hWnd,NULL,TRUE);
    }
} // TextSetFont()


//--------------------------------------------------------------------------;
//
//  HFONT TextGetFont
//
//  Description:
//      Gets the current HFONT used for window.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (HFONT):
//      Handle to font.
//
//  History:
//      10/25/94    Fwong       Adding flexibility.
//
//--------------------------------------------------------------------------;

HFONT TextGetFont
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    return (ptwi->hFont);
} // TextGetFont()


//--------------------------------------------------------------------------;
//
//  void TextClose
//
//  Description:
//      Handles WM_CLOSE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextClose
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO    ptwi;
    LPTEXTBUFFER        ptb;
    HGLOBAL             hMem;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    ptwi->ptbLast->pNext = NULL;

    for(ptb = ptwi->ptbFirst;NULL != ptb;)
    {
        //
        //  Freeing memory for actual text.
        //

        hMem = ptb->hText;

        GlobalUnlock(hMem);
        GlobalFree(hMem);

        //
        //  Freeing memory for this (TEXTBUFFER) structure...
        //

        hMem = ptb->hmem;
        ptb  = ptb->pNext;

        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }

    //
    //  Freeing memory for this (TEXTWINDOWINFO) structure...
    //

    hMem = ptwi->hmem;

    GlobalUnlock(hMem);
    GlobalFree(hMem);
} // TextClose()


//--------------------------------------------------------------------------;
//
//  void TextVScroll
//
//  Description:
//      Handles WM_VSCROLL messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      HWND hWndVScroll: Handle to Scroll bar.
//
//      UINT uScrollCode: Scroll code.
//
//      int nPos: Scroll Position.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextVScroll
(
    HWND    hWnd,
    HWND    hWndVScroll,
    UINT    uScrollCode,
    int     nPos
)
{
    LPTEXTWINDOWINFO    ptwi;
    UINT                nLines;
    int                 i;
    DWORD               dwEnd;
    DWORD               dwDelta;

    //
    //  Is the scroll bar enabled?
    //

    GetScrollRange(hWnd,SB_VERT,&i,&nLines);

    if(0 == nLines)
    {
        //
        //  No?  We're getting this message?
        //

        return;
    }

    ptwi    = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    nLines  = GetTextLines(hWnd);
    dwDelta = nLines;

    switch(uScrollCode)
    {
        case SB_LINEUP:
            //
            //  Note: Purposely falling through.
            //

            dwDelta = 1;

        case SB_PAGEUP:
            TextUp(hWnd,dwDelta);
            break;

        case SB_LINEDOWN:
            //
            //  Note: Purposely falling through.
            //

            dwDelta = 1;

        case SB_PAGEDOWN:
            TextDown(hWnd,dwDelta);
            break;

        case SB_THUMBPOSITION:

            dwEnd = ptwi->dwLines - nLines;

            ptwi->dwCurLine = (dwEnd * nPos)/VSCROLL_RANGE;
            
            CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_END);

            if(ptwi->dwCurLine >= dwEnd)
            {
                ptwi->dwCurLine  = dwEnd;
                SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
            }

            if(1 == nPos)
            {
                ptwi->dwCurLine = 0;
            }

            InvalidateRect(hWnd,NULL,TRUE);

            break;
    }

    DrawVScroll(hWnd);
} // TextVScroll()


//--------------------------------------------------------------------------;
//
//  void TextHScroll
//
//  Description:
//      Handle WM_HSCROLL messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      HWND hWndVScroll: Handle to Scroll bar.
//
//      UINT uScrollCode: Scroll code.
//
//      int nPos: Scroll Position.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextHScroll
(
    HWND    hWnd,
    HWND    hWndHScroll,
    UINT    uScrollCode,
    int     nPos
)
{
    LPTEXTWINDOWINFO    ptwi;
    UINT                u,uDelta;
    RECT                r;

    //
    //  Is the scroll bar enabled?
    //

    GetScrollRange(hWnd,SB_HORZ,&uDelta,&u);

    if(0 == u)
    {
        //
        //  No?  We're getting this message?
        //

        return;
    }

    ptwi    = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    GetClientRect(hWnd,&r);

    uDelta = r.right / ptwi->uTextWidth;

    switch(uScrollCode)
    {
        case SB_LINELEFT:
            //
            //  Note: Purposely falling through.
            //

            uDelta = 1;

        case SB_PAGELEFT:
            if(ptwi->uCurCol > uDelta)
            {
                ptwi->uCurCol -= uDelta;
            }
            else
            {
                ptwi->uCurCol = 0;
            }

            break;

        case SB_LINERIGHT:
            //
            //  Note: Purposely falling through.
            //

            uDelta = 1;

        case SB_PAGERIGHT:
            ptwi->uCurCol += uDelta;

            if(ptwi->uCurCol > u)
            {
                ptwi->uCurCol = u;
            }

            break;

        case SB_THUMBPOSITION:
            ptwi->uCurCol = nPos;
    }

    InvalidateRect(hWnd,NULL,TRUE);
    SetScrollPos(hWnd,SB_HORZ,ptwi->uCurCol,TRUE);
} // TextHScroll()


//--------------------------------------------------------------------------;
//
//  void TextSize
//
//  Description:
//      Handles WM_SIZE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uSizeType: How we're being sized.
//
//      int nWidth: New Width.
//
//      int nHeight: New Height.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextSize
(
    HWND    hWnd,
    UINT    uSizeType,
    int     nWidth,
    int     nHeight
)
{
    LPTEXTWINDOWINFO    ptwi;
    UINT                uLines;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    if(IsBadWritePtr(ptwi,sizeof(TEXTWINDOWINFO)))
    {
        return;
    }

    if(ptwi->fdwFlags & TEXTFLAG_END)
    {
        //
        //  We don't recalculate the current line.  It will be done
        //  on the WM_PAINT message.
        //

        return;
    }

    uLines = (nHeight / ptwi->uTextHeight);
    
    if(ptwi->dwCurLine + uLines >= ptwi->dwLines)
    {
        //
        //  If end of buffer is displayable, then mark text as "end".
        //

        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
    }

} // TextSize()


//--------------------------------------------------------------------------;
//
//  void TextSetRedraw
//
//  Description:
//      Handles WM_SETREDRAW messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      BOOL fRedraw: TRUE if redraw should be enabled.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextSetRedraw
(
    HWND    hWnd,
    BOOL    fRedraw
)
{
    LPTEXTWINDOWINFO    ptwi;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);

    if(fRedraw)
    {
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_REDRAW);
    }
    else
    {
        CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_REDRAW);
    }
} // TextSetRedraw()


//--------------------------------------------------------------------------;
//
//  void TextColorChange
//
//  Description:
//      Handles WM_SYSCOLORCHANGE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextColorChange
(
    HWND    hWnd
)
{
    LPTEXTWINDOWINFO ptwi;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    
    ptwi->crText          = GetSysColor(COLOR_WINDOWTEXT);
    ptwi->crBackGnd       = GetSysColor(COLOR_WINDOW);
    ptwi->crHiLiteText    = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ptwi->crHiLiteBackGnd = GetSysColor(COLOR_HIGHLIGHT);

    InvalidateRect(hWnd,NULL,TRUE);
} // TextColorChange()


//--------------------------------------------------------------------------;
//
//  void TextLButtonDown
//
//  Description:
//      Handles WM_LBUTTONDOWN messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      BOOL fDoubleClick: TRUE if double-clicked.
//
//      int x: x Position.
//
//      int y: y Position.
//
//      UINT keyFlags: Key flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextLButtonDown
(
    HWND    hWnd,
    BOOL    fDoubleClick,
    int     x,
    int     y,
    UINT    keyFlags
)
{
    LPTEXTWINDOWINFO    ptwi;
    DWORD               dw;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    
    x  = (x < 0)?0:x;

    x = x / ptwi->uTextWidth;
    y = y / ptwi->uTextHeight;

    //
    //  Setting up this window to capture mouse messages.
    //

    SetCapture(hWnd);

    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_CLICK);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);

    //
    //  Storing location.
    //

    if(ptwi->dwLines == 0)
    {
        ptwi->locStart.dwRow = 0;
        ptwi->locStart.uCol  = 0;
    }
    else
    {
        dw = y + ptwi->dwCurLine;

        if(dw > ptwi->dwLines)
        {
            ptwi->locStart.dwRow = ptwi->dwLines - 1;
            ptwi->locStart.uCol  = (UINT)(-1);
        }
        else
        {
            ptwi->locStart.dwRow = dw;
            ptwi->locStart.uCol  = x + ptwi->uCurCol;
        }
    }
} // TextLButtonDown()


//--------------------------------------------------------------------------;
//
//  void TextLButtonUp
//
//  Description:
//      Handles WM_LBUTTONUP messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      int x: x Position.
//
//      int y: y Position.
//
//      UINT keyFlags: Key flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextLButtonUp
(
    HWND    hWnd,
    int     x,
    int     y,
    UINT    keyFlags
)
{
    LPTEXTWINDOWINFO    ptwi;
    DWORD               dw;
    RECT                r;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    
    if(!(ptwi->fdwFlags & TEXTFLAG_CLICK))
    {
        return;
    }

    GetWindowRect(hWnd,&r);
    r.right  = r.right - r.left;
    r.bottom = r.bottom - r.top;

    x = (x < 0)?0:x;
    x = (x > r.right )?r.right :x;

    y = (y < 0)?0:y;
    y = (y > r.bottom)?r.bottom:y;

    x = x / ptwi->uTextWidth;
    y = y / ptwi->uTextHeight;

    dw = y + ptwi->dwCurLine;

    //
    //  Releasing this window from capturing mouse messages.
    //

    ReleaseCapture();

    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_CLICK);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLUP);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLDOWN);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLLEFT);
    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLRIGHT);

    //
    //  Storing location.
    //

    if(ptwi->dwLines == 0)
    {
        ptwi->locEnd.dwRow = 0;
        ptwi->locEnd.uCol  = 0;
    }
    else
    {
        if(dw > ptwi->dwLines)
        {
            ptwi->locEnd.dwRow = ptwi->dwLines - 1;
            ptwi->locEnd.uCol  = (UINT)(-1);
        }
        else
        {
            ptwi->locEnd.dwRow = dw;
            ptwi->locEnd.uCol  = x + ptwi->uCurCol;
        }
    }

    if ((ptwi->locEnd.dwRow == ptwi->locStart.dwRow) &&
        (ptwi->locEnd.uCol  == ptwi->locStart.uCol))
    {
        CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }
    else
    {
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }

    InvalidateRect(hWnd,NULL,TRUE);
} // TextLButtonUp()


//--------------------------------------------------------------------------;
//
//  void TextMouseMove
//
//  Description:
//      Handles WM_MOUSEMOVE messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      int x: x Position.
//
//      int y: y Position.
//
//      UINT keyFlags: Key flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextMouseMove
(
    HWND    hWnd,
    int     x,
    int     y,
    UINT    keyFlags
)
{
    LPTEXTWINDOWINFO    ptwi;
    DWORD               dw;
    RECT                r;

    ptwi = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    
    if(!(ptwi->fdwFlags & TEXTFLAG_CLICK))
    {
        return;
    }

    GetWindowRect(hWnd,&r);
    r.right  = r.right - r.left;
    r.bottom = r.bottom - r.top;

    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_DIRMASK);

    if(x < 0)
    {
        x = 0;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLLEFT);
    }

    if(x > r.right)
    {
        x = r.right;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLRIGHT);
    }

    if(y < 0)
    {
        y = 0;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLUP);
    }

    if(y > r.bottom)
    {
        y = r.bottom;
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SCROLLDOWN);
    }

    x = x / ptwi->uTextWidth;
    y = y / ptwi->uTextHeight;

    dw = y + ptwi->dwCurLine;

    //
    //  Storing location.
    //

    if(ptwi->dwLines == 0)
    {
        ptwi->locEnd.dwRow = 0;
        ptwi->locEnd.uCol  = 0;
    }
    else
    {
        if(dw > ptwi->dwLines)
        {
            ptwi->locEnd.dwRow = ptwi->dwLines - 1;
            ptwi->locEnd.uCol  = (UINT)(-1);
        }
        else
        {
            ptwi->locEnd.dwRow = dw;
            ptwi->locEnd.uCol  = x + ptwi->uCurCol;
        }
    }

    if ((ptwi->locEnd.dwRow == ptwi->locStart.dwRow) &&
        (ptwi->locEnd.uCol  == ptwi->locStart.uCol))
    {
        CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }
    else
    {
        SET_FLAG(ptwi->fdwFlags,TEXTFLAG_SELECT);
    }

    InvalidateRect(hWnd,NULL,TRUE);
} // TextMouseMove()


//--------------------------------------------------------------------------;
//
//  void TextKey
//
//  Description:
//      Handles both WM_KEYDOWN and WM_KEYUP messages.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT vk: Virtual Key.
//
//      BOOL fDown: TRUE if key is down.
//
//      int cRepeat: Number of repetitions.
//
//      UINT flags: Flags.
//
//  Return (void):
//
//  History:
//      10/25/94    Fwong       Using message "cracker".
//
//--------------------------------------------------------------------------;

void TextKey
(
    HWND    hWnd,
    UINT    vk,
    BOOL    fDown,
    int     cRepeat,
    UINT    flags
)
{
    LPTEXTWINDOWINFO    ptwi;
    DWORD               dwDelta;
    DWORD               dwMask;
    UINT                u1,u2;

    ptwi    = (LPTEXTWINDOWINFO)GetWindowLong(hWnd,0);
    dwDelta = GetTextLines(hWnd);

    dwMask  = ((DWORD)(-1) - 1);

    switch(vk)
    {
        case VK_UP:
            TextUp(hWnd,1);
            break;

        case VK_PRIOR:
            if(dwMask & GetKeyState(VK_CONTROL))
            {
                if(0 != ptwi->dwCurLine)
                {
                    ptwi->dwCurLine = 0L;
                    CLEAR_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
                    InvalidateRect(hWnd,NULL,TRUE);
                }
            }
            else
            {
                TextUp(hWnd,dwDelta);
            }
            break;

        case VK_DOWN:
            TextDown(hWnd,1);
            break;

        case VK_NEXT:
            if(dwMask & GetKeyState(VK_CONTROL))
            {
                if(!(ptwi->fdwFlags & TEXTFLAG_END))
                {
                    SET_FLAG(ptwi->fdwFlags,TEXTFLAG_END);
                    InvalidateRect(hWnd,NULL,TRUE);
                }
            }
            else
            {
                TextDown(hWnd,dwDelta);
            }
            break;

        case VK_HOME:
            ptwi->uCurCol = 0;
            InvalidateRect(hWnd,NULL,TRUE);
            break;

        case VK_LEFT:
            if(ptwi->uCurCol != 0)
            {
                ptwi->uCurCol--;
                InvalidateRect(hWnd,NULL,TRUE);
            }
            break;

        case VK_END:
            GetScrollRange(hWnd,SB_HORZ,&u1,&u2);
            ptwi->uCurCol = u2;
            InvalidateRect(hWnd,NULL,TRUE);
            break;

        case VK_RIGHT:
            GetScrollRange(hWnd,SB_HORZ,&u1,&u2);
            if(ptwi->uCurCol < u2)
            {
                ptwi->uCurCol++;
                InvalidateRect(hWnd,NULL,TRUE);
            }
            break;

        case VK_INSERT:
            if(dwMask & GetKeyState(VK_CONTROL))
            {
                TextCopy(hWnd);
            }
            break;

        default:
            break;
    }
} // TextKey()


//--------------------------------------------------------------------------;
//
//  LRESULT TextFocusProc
//
//  Description:
//      This is similar to a DefMDIChildProc (but for Text windows).
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uMessage: Message.
//
//      WPARAM wParam: Message dependent.
//
//      LPARAM lParam: Message dependent.
//
//  Return (LRESULT):
//      Message dependent.
//
//  History:
//      10/25/94    Fwong       Adding "focus" functionality.
//
//--------------------------------------------------------------------------;

LRESULT TextFocusProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lr;

    switch(uMessage)
    {
        case WM_SYSCOLORCHANGE:
            lr = HANDLE_WM_SYSCOLORCHANGE(hWnd,wParam,lParam,TextColorChange);
            return lr;

        case WM_KEYDOWN:
            lr = HANDLE_WM_KEYDOWN(hWnd,wParam,lParam,TextKey);
            return lr;
    }
} // TextFocusProc()   


//--------------------------------------------------------------------------;
//
//  LRESULT TextWndProc
//
//  Description:
//      Main WNDPROC for text window class.
//
//  Arguments:
//      HWND hWnd: Handle to window.
//
//      UINT uMessage: Message.
//
//      WPARAM wParam: Message depedent.
//
//      LPARAM lParam: Message depedent.
//
//  Return (LRESULT):
//      Message depedent.
//
//  History:
//      10/25/94    Fwong       Main WndProc.  Cheers!!
//
//--------------------------------------------------------------------------;

LRESULT CALLBACK EXPORT TextWndProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lr;

    switch(uMessage)
    {
        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_PAINT:
            lr = HANDLE_WM_PAINT(hWnd,wParam,lParam,TextPaint);
            return lr;

        case WM_CLOSE:
            lr = HANDLE_WM_CLOSE(hWnd,wParam,lParam,TextClose);
            return lr;

        case WM_VSCROLL:
            lr = HANDLE_WM_VSCROLL(hWnd,wParam,lParam,TextVScroll);
            return lr;

        case WM_HSCROLL:
            lr = HANDLE_WM_HSCROLL(hWnd,wParam,lParam,TextHScroll);
            return lr;

        case WM_SIZE:
            lr = HANDLE_WM_SIZE(hWnd,wParam,lParam,TextSize);
            return lr;

        case WM_LBUTTONDOWN:
            lr = HANDLE_WM_LBUTTONDOWN(hWnd,wParam,lParam,TextLButtonDown);
            return lr;

        case WM_LBUTTONUP:
            lr = HANDLE_WM_LBUTTONUP(hWnd,wParam,lParam,TextLButtonUp);
            return lr;

        case WM_MOUSEMOVE:
            lr = HANDLE_WM_MOUSEMOVE(hWnd,wParam,lParam,TextMouseMove);
            return lr;

        case WM_SETREDRAW:
            lr = HANDLE_WM_SETREDRAW(hWnd,wParam,lParam,TextSetRedraw);
            return lr;

        case WM_COPY:
            lr = HANDLE_WM_COPY(hWnd,wParam,lParam,TextCopy);
            return lr;

        case WM_SETFONT:
            lr = HANDLE_WM_SETFONT(hWnd,wParam,lParam,TextSetFont);
            return lr;

        case WM_GETFONT:
            lr = HANDLE_WM_GETFONT(hWnd,wParam,lParam,TextGetFont);
            return lr;

        //
        //  Special Messages defined for _this_ window class.
        //

        case TM_PROPAGATE:
            PropagateDraw(hWnd);
            return 0L;

        case TM_DELETETEXT:
            DeleteText(hWnd);
            return 0L;

        case TM_GETSIZELIMIT:
            return (LRESULT)((DWORD)GetTextSizeLimit(hWnd));

        case TM_SETSIZELIMIT:
            return (LRESULT)((DWORD)SetTextSizeLimit(
                hWnd,
                (DWORD)lParam,
                (UINT)wParam));

        case TM_SEARCH:
            return (LRESULT)((BOOL)TextSearch(
                hWnd,
                (LPSTR)lParam,
                (UINT)wParam));

        default:
            break;
    }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
} // TextWndProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\text.h ===
//--------------------------------------------------------------------------;
//
//  File: Text.h
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  History:
//      08/28/94    Fwong
//
//--------------------------------------------------------------------------;

//==========================================================================;
//
//                             Messages...
//
//==========================================================================;

#define TM_DELETETEXT       WM_USER + 1
#define TM_SETSIZELIMIT     WM_USER + 2
#define TM_GETSIZELIMIT     WM_USER + 3
#define TM_SEARCH           WM_USER + 4


//==========================================================================;
//
//                               Flags...
//
//==========================================================================;

#define SETSIZEFLAG_TRUNCATE    0x0001

#define SEARCHFLAG_MATCHCASE    0x0001

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#define Text_Copy(hWnd)             SendMessage(hWnd,WM_COPY,0,0L)
#define Text_Delete(hWnd)           SendMessage(hWnd,TM_DELETETEXT,0,0L)
#define Text_GetBufferLimit(hWnd)   SendMessage(hWnd,TM_GETSIZELIMIT,0,0L)

#define Text_SetBufferLimit(hWnd,cbSize,uFlags)  \
            SendMessage(hWnd,TM_SETSIZELIMIT,(WPARAM)(uFlags),(LPARAM)(cbSize))

#define Text_SearchString(hWnd,pszString,uFlags)  \
            (BOOL)(SendMessage(hWnd,TM_SEARCH,(WPARAM)(uFlags), \
            (LPARAM)(LPSTR)(pszString)))


//==========================================================================;
//
//                            Prototypes...
//
//==========================================================================;

extern BOOL TextInit
(
    HINSTANCE   hInstance
);

extern void TextEnd
(
    HINSTANCE   hInstance
);

extern HWND TextCreateWindow
(
    DWORD       dwStyle,
    int         x,
    int         y,
    int         nWidth,
    int         nHeight,
    HWND        hWndParent,
    HMENU       hMenu,
    HINSTANCE   hInstance
);

extern void TextOutputString
(
    HWND    hWnd,
    LPSTR   pText
);

extern int _cdecl TextPrintf
(
    HWND    hWnd,
    LPSTR   pszFormat,
    ...
);

extern LRESULT TextFocusProc
(
    HWND    hWnd,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tsrunset.c ===
/***************************************************************************\
*                                                                           *
*   File: Tsrunset.c                                                        *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This module handles the run parameters dialog box.                  *
*                                                                           *
*   Contents:                                                               *
*       setRunSetupBttns()                                                  *
*       setRunParms()                                                       *
*       RunSetupDlgProc()                                                   *
*       RunSetup()                                                          *
*                                                                           *
*   History:                                                                *
*       02/17/91    prestonb    Created from tst.c                          *                
*       07/06/93    T-OriG      Reformatted and added screen saver stuff    *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>
// EVIL, EVIL, EVIL!!!!
// #include "mprt1632.h"  
#include "support.h"
#include "tsglobal.h"
#include "tsextern.h"
#include "tsdlg.h"

/* Internal Functions */
void setRunParms(HWND);
void setRunSetupBttns(HWND);


/***************************************************************************\
*                                                                           *
*   void setRunSetupBttns                                                   *
*                                                                           *
*   Description:                                                            *
*       This function sets the verification mode buttons for message boxes. *
*                                                                           *
*                                                                           *
*   Arguments:                                                              *
*       HWND hdlg:                                                          *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/06/93    T-OriG (Added this header and screen saver stuff)       *
*                                                                           *
\***************************************************************************/

void setRunSetupBttns
(
    HWND    hdlg
)
{
    switch (gwTSVerification)
    {
        case LOG_MANUAL:
            CheckRadioButton(hdlg,TS_AUTOMATIC,TS_MANUAL,TS_MANUAL);
            break;
        case LOG_AUTO:
            CheckRadioButton (hdlg,TS_AUTOMATIC,TS_MANUAL,TS_AUTOMATIC);
            break;
    }

    switch (gwTSScreenSaver)
    {
        case SSAVER_ENABLED:
            CheckRadioButton(hdlg,TS_SSAVEREN,TS_SSAVERDIS,TS_SSAVEREN);
            break;
        case SSAVER_DISABLED:
            CheckRadioButton(hdlg,TS_SSAVEREN,TS_SSAVERDIS,TS_SSAVERDIS);
            break;
    }

    CheckDlgButton(hdlg,TS_STEP,gwTSStepMode);
    CheckDlgButton(hdlg,TS_RANDOM,gwTSRandomMode);
    SetDlgItemInt (hdlg, TS_RUNCOUNT, giTSRunCount, FALSE);
  
} /* end of setRunSetupBttns */



/***************************************************************************\
*                                                                           *
*   void setRunParms                                                        *
*                                                                           *
*   Description:                                                            *
*       This function sets the verification global variables for message    *
*       boxes.                                                              *
*                                                                           *
*   Arguments:                                                              *
*       HWND hdlg:                                                          *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/06/93    T-OriG (Added this header and screen saver stuff)       *
*                                                                           *
\***************************************************************************/

void setRunParms
(
    HWND    hdlg
)
{
    int  iTmp;
    int  iError;

    gwTSVerification = (IsDlgButtonChecked(hdlg,TS_MANUAL) ?
        LOG_MANUAL :
        LOG_AUTO);
    gwTSScreenSaver = (IsDlgButtonChecked (hdlg, TS_SSAVERDIS) ?
        SSAVER_DISABLED :
        SSAVER_ENABLED);

    gwTSStepMode = IsDlgButtonChecked(hdlg,TS_STEP);
    gwTSRandomMode = IsDlgButtonChecked(hdlg,TS_RANDOM);

    iTmp = GetDlgItemInt(hdlg,TS_RUNCOUNT,&iError,FALSE);
    if (iError)
    {
        giTSRunCount = iTmp;
    }
 
} /* end of setRunParms */




/***************************************************************************\
*                                                                           *
*   int RunSetupDlgProc                                                     *
*                                                                           *
*   Description:                                                            *
*       This function handle the run setup dialog.                          *
*                                                                           *
*   Arguments:                                                              *
*       HWND hdlg:                                                          *
*                                                                           *
*       UINT msg:                                                           *
*                                                                           *
*       WPARAM wParam:                                                      *
*                                                                           *
*       LPARAM lParam:                                                      *
*                                                                           *
*   Return (int):                                                           *
*                                                                           *
*   History:                                                                *
*       07/06/93    T-OriG (Added this header and screen saver stuff)       *
*                                                                           *
\***************************************************************************/

int FAR PASCAL RunSetupDlgProc
(
    HWND    hdlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UINT  wNotifyCode;
    UINT  wID;
    HWND  hwndCtl;

    switch (msg)
    {
        case WM_INITDIALOG:
            setRunSetupBttns(hdlg);
            SetFocus(GetDlgItem(hdlg,TS_RUNCOUNT));
            break;

        case WM_COMMAND:
            wNotifyCode=GET_WM_COMMAND_CMD(wParam,lParam);
            wID=GET_WM_COMMAND_ID(wParam,lParam);
            hwndCtl=GET_WM_COMMAND_HWND(wParam,lParam);

            switch (wID)
            {
                case TS_AUTOMATIC:
                case TS_MANUAL:
                    CheckRadioButton(hdlg,TS_AUTOMATIC,TS_MANUAL,wID);
                    break;

                case TS_SSAVEREN:
                case TS_SSAVERDIS:
                    CheckRadioButton(hdlg,TS_SSAVEREN,TS_SSAVERDIS,wID);
                    break;                    

                case TS_STEP:
                case TS_RANDOM:
                    CheckDlgButton(hdlg,wID,
                                   !(IsDlgButtonChecked(hdlg,wID)));
                    break;
                case TS_RSCANCEL:
                    EndDialog (hdlg, FALSE);
                    break;
                case TS_RSOK:
                    setRunParms(hdlg);
                    EndDialog (hdlg, TRUE);
                    break;
            }
            break;

    }
    return FALSE;
} /* end of RunSetupDlgProc */


/***************************************************************************\
*                                                                           *
*   void RunSetup                                                           *
*                                                                           *
*   Description:                                                            *
*       This function invokes the run setup dialog box.                     *
*                                                                           *
*   Arguments:                                                              *
*       HWND hWnd:                                                          *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/06/93    T-OriG (Added this header)                              *
*                                                                           *
\***************************************************************************/

void RunSetup
(
    HWND    hWnd
)
{
    FARPROC fpDlg;

    fpDlg = MakeProcInstance((FARPROC)RunSetupDlgProc, ghTSInstApp);
    DialogBox(ghTSInstApp, (LPCSTR) "runsetup", hWnd, (DLGPROC) fpDlg);
    FreeProcInstance(fpDlg);
} /* end of RunSetup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\toolbar.c ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/*
	toolbar.c

	Program Description: 

	Revision History:

*/

#include <string.h>

#include <windows.h>
#include <windowsx.h>
#include "toolbar.h"		// use this for generic app
#include "tstshell.h"
#include "tsmain.h"

/************************************************************************/

/* work for win3.0 */
#ifndef COLOR_BTNHIGHLIGHT
#define COLOR_BTNHIGHLIGHT 20
#endif

char	szToolBarClass[] = "ToolBarClass";
HBRUSH	ghbrToolbar;		// brush for toolbar background

//
// Window proc for buttons, THIS FUNCTION MUST BE EXPORTED
//
LONG FAR PASCAL EXPORT toolbarWndProc(HWND, unsigned, WPARAM, LPARAM);

typedef long (FAR PASCAL *LPWNDPROC)();

/*
	Defines
*/

#ifdef WIN32


#define GETARRAYBUTT(hwnd)	((HANDLE)GetWindowLong(hwnd,GWW_ARRAYBUTT))
#define GETNUMBUTTONS(hwnd)	((int)GetWindowLong(hwnd,GWW_NUMBUTTONS))
#define GETPRESSED(hwnd)	((BOOL)GetWindowLong(hwnd,GWW_PRESSED))
#define GETKEYPRESSED(hwnd)	((BOOL)GetWindowLong(hwnd,GWW_KEYPRESSED))
#define GETWHICH(hwnd)		((int)GetWindowLong(hwnd,GWW_WHICH))
#define GETSHIFTED(hwnd)	((BOOL)GetWindowLong(hwnd,GWW_SHIFTED))
#define GETBMPHANDLE(hwnd)	((HANDLE)GetWindowLong(hwnd,GWW_BMPHANDLE))
#define GETBMPINT(hwnd)		((int)GetWindowLong(hwnd,GWW_BMPINT))
#define GETBUTTONSIZE(hwnd)	GetWindowLong(hwnd,GWL_BUTTONSIZE)
#define GETHINST(hwnd)		((HANDLE)GetWindowLong(hwnd,GWW_HINST))

#define SETARRAYBUTT(hwnd, h) SetWindowLong(hwnd, GWW_ARRAYBUTT, (LONG)h)
#define SETNUMBUTTONS(hwnd, wNumButtons) \
			SetWindowLong(hwnd, GWW_NUMBUTTONS, (LONG)wNumButtons)
#define SETPRESSED(hwnd, f)	SetWindowLong(hwnd, GWW_PRESSED, (LONG)f)
#define SETKEYPRESSED(hwnd, f)	SetWindowLong(hwnd, GWW_KEYPRESSED, (LONG)f)
#define SETWHICH(hwnd, i)	SetWindowLong(hwnd, GWW_WHICH, (LONG)i)
#define SETSHIFTED(hwnd, i)	SetWindowLong(hwnd, GWW_SHIFTED, (LONG)i)
#define SETBMPHANDLE(hwnd, h)	SetWindowLong(hwnd, GWW_BMPHANDLE, (LONG)h)
#define SETBMPINT(hwnd, i)	SetWindowLong(hwnd, GWW_BMPINT, (LONG)i)
#define SETBUTTONSIZE(hwnd, l)	SetWindowLong(hwnd, GWL_BUTTONSIZE, l)
#define SETHINST(hwnd, h)	SetWindowLong(hwnd, GWW_HINST, (LONG)h)

#else

#define GETARRAYBUTT(hwnd)	((HANDLE)GetWindowWord(hwnd,GWW_ARRAYBUTT))
#define GETNUMBUTTONS(hwnd)	((int)GetWindowWord(hwnd,GWW_NUMBUTTONS))
#define GETPRESSED(hwnd)	((BOOL)GetWindowWord(hwnd,GWW_PRESSED))
#define GETKEYPRESSED(hwnd)	((BOOL)GetWindowWord(hwnd,GWW_KEYPRESSED))
#define GETWHICH(hwnd)		((int)GetWindowWord(hwnd,GWW_WHICH))
#define GETSHIFTED(hwnd)	((BOOL)GetWindowWord(hwnd,GWW_SHIFTED))
#define GETBMPHANDLE(hwnd)	((HANDLE)GetWindowWord(hwnd,GWW_BMPHANDLE))
#define GETBMPINT(hwnd)		((int)GetWindowWord(hwnd,GWW_BMPINT))
#define GETBUTTONSIZE(hwnd)	GetWindowLong(hwnd,GWL_BUTTONSIZE)
#define GETHINST(hwnd)		((HANDLE)GetWindowWord(hwnd,GWW_HINST))

#define SETARRAYBUTT(hwnd, h) SetWindowWord(hwnd, GWW_ARRAYBUTT, (WORD)h)
#define SETNUMBUTTONS(hwnd, wNumButtons) \
			SetWindowWord(hwnd, GWW_NUMBUTTONS, wNumButtons)
#define SETPRESSED(hwnd, f)	SetWindowWord(hwnd, GWW_PRESSED, (WORD)f)
#define SETKEYPRESSED(hwnd, f)	SetWindowWord(hwnd, GWW_KEYPRESSED, (WORD)f)
#define SETWHICH(hwnd, i)	SetWindowWord(hwnd, GWW_WHICH, (WORD)i)
#define SETSHIFTED(hwnd, i)	SetWindowWord(hwnd, GWW_SHIFTED, (WORD)i)
#define SETBMPHANDLE(hwnd, h)	SetWindowWord(hwnd, GWW_BMPHANDLE, (WORD)h)
#define SETBMPINT(hwnd, i)	SetWindowWord(hwnd, GWW_BMPINT, (WORD)i)
#define SETBUTTONSIZE(hwnd, l)	SetWindowLong(hwnd, GWL_BUTTONSIZE, l)
#define SETHINST(hwnd, h)	SetWindowWord(hwnd, GWW_HINST, (WORD)h)

#endif


#define lpCreate ((LPCREATESTRUCT)lParam)

/* Prototypes */

static void NEAR PASCAL NotifyParent(HWND, int);



/**************************************************************************
	toolbarInit( hInst, hPrev )

	Call this routine to initialize the toolbar code.

	Arguments:
		hPrev	instance handle of previous instance
		hInst	instance handle of current instance

	Returns:
		TRUE if successful, FALSE if not
***************************************************************************/

BOOL FAR PASCAL toolbarInit(HANDLE hInst, HANDLE hPrev)
{
	WNDCLASS	cls;
	
	/* Register the tool bar window class */
	if (!hPrev) {

	    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
	    cls.hIcon          = NULL;
	    cls.lpszMenuName   = NULL;
	    cls.lpszClassName  = (LPSTR)szToolBarClass;

	    cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
//	    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);

	    cls.hInstance      = hInst;
	    cls.style          = CS_DBLCLKS;

//      Removed a Warning:
//	    cls.lpfnWndProc    = (LPWNDPROC)toolbarWndProc;
        cls.lpfnWndProc    = (WNDPROC)toolbarWndProc;

	    cls.cbClsExtra     = 0;
	    cls.cbWndExtra     = TOOLBAR_EXTRABYTES;
	    if (!RegisterClass(&cls))
		return FALSE;
	}

	return TRUE;
}


/***************************************************************************/
/* toolbarSetBitmap:  takes a resource ID and associates that bitmap with  */
/*                    a given toolbar.  Also takes the instance handle and */
/*                    the size of the buttons on the toolbar.              */
/***************************************************************************/
BOOL FAR PASCAL toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp, POINT ptSize)
{
	SETHINST(hwnd, hInst);
	SETBMPHANDLE(hwnd, NULL);
	SETBMPINT(hwnd, ibmp);
	SETBUTTONSIZE(hwnd, MAKELONG(ptSize.y, ptSize.x));
	return (BOOL)SendMessage(hwnd, WM_SYSCOLORCHANGE, 0, 0L); // do the work
}

/***************************************************************************/
/* toolbarGetNumButtons:  return the number of buttons registered on a     */
/*                        given toolbar window.                            */
/***************************************************************************/
int FAR PASCAL toolbarGetNumButtons(HWND hwnd)
{
    return GETNUMBUTTONS(hwnd);
}


/***************************************************************************/
/* toolbarButtonFromIndex:  Given an index into the array of buttons on    */
/*                          this toolbar, return which button is there.    */
/*                          Returns -1 for an error code.                  */
/***************************************************************************/
int FAR PASCAL toolbarButtonFromIndex(HWND hwnd, int iBtnPos)
{
	int		iButton;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the array of buttons on this toolbar */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	
	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the answer */
	iButton = lpaButtons[iBtnPos].iButton;

	GlobalUnlock(h);
	return iButton;
}


/***************************************************************************/
/* toolbarIndexFromButton:  Given a button ID, return the position in the  */
/*                          array that it appears at.                      */
/*                          Returns -1 for an error code.                  */
/***************************************************************************/
int FAR PASCAL toolbarIndexFromButton(HWND hwnd, int iButton)
{
	int		i, iBtnPos = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through until you find it */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++) 
		if (lpButton->iButton == iButton) {
			iBtnPos = i;
			break;
		}

	GlobalUnlock(h);
	return iBtnPos;
}



/***************************************************************************/
/* toolbarPrevStateFromButton:  Given a button ID, return the state that   */
/*                              the button was in before it was pressed    */
/*                              all the way down (for non-push buttons).   */
/*                              Return -1 for an error code.               */
/***************************************************************************/
int FAR PASCAL toolbarPrevStateFromButton(HWND hwnd, int iButton)
{
	int		i, iPrevState = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* look for what we need */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (lpButton->iButton == iButton) {
			iPrevState = lpButton->iPrevState;
			break;
		}

	GlobalUnlock(h);
	return iPrevState;
}



/***************************************************************************/
/* toolbarActivityFromButton:   Given a button ID, return the most recent  */
/*                              activity that happened to it. (eg DBLCLK)  */
/*                              Return -1 for an error code.               */
/***************************************************************************/
int FAR PASCAL toolbarActivityFromButton(HWND hwnd, int iButton)
{
	int		i, iActivity = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through until you find it */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (lpButton->iButton == iButton)
			iActivity = lpButton->iActivity;

	GlobalUnlock(h);
	return iActivity;
}



/***************************************************************************/
/* toolbarIndexFromPoint:  Given a point in the toolbar window, return the */
/*                         index of the button beneath that point.         */
/*                         Return -1 for an error code.                    */
/***************************************************************************/
int FAR PASCAL toolbarIndexFromPoint(HWND hwnd, POINT pt)
{
	int		i, iBtnPos = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through until we find an intersection */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (PtInRect(&lpButton->rc, pt)) {
			iBtnPos = i;
			break;
		}

	GlobalUnlock(h);
	return iBtnPos;
}



/***************************************************************************/
/* toolbarRectFromIndex:   Given an index into our array of buttons, return*/
/*                         the rect occupied by that button.               */
/*                         Return a NULL rect for an error.                */
/***************************************************************************/
BOOL FAR PASCAL toolbarRectFromIndex(HWND hwnd, int iBtnPos, LPRECT lprc)
{
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;
	
	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
	    return FALSE;

	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
	    return FALSE;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the rect */
	*lprc = lpaButtons[iBtnPos].rc;

	GlobalUnlock(h);
}



/***************************************************************************/
/* toolbarFullStateFromButton: Given a button in our array of buttons,     */
/*                             return the state of that button.            */
/*                             (including the wierd state FULLDOWN). For   */
/*                             just UP or DOWN or GRAYED,                  */
/*                             call toolbarStateFromButton.		   */
/*                             Return -1 for an error.                     */
/***************************************************************************/
int FAR PASCAL toolbarFullStateFromButton(HWND hwnd, int iButton)
{
	int		iState, iBtnPos;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	iBtnPos = toolbarIndexFromButton(hwnd, iButton);
	if (iBtnPos == -1)
		return -1;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the state */
	iState = lpaButtons[iBtnPos].iState;

	GlobalUnlock(h);
	return iState;
}	



/***************************************************************************/
/* toolbarStateFromButton: This fn is called by the parent application     */
/*                         to get the state of a button.  It will only     */
/*                         return DOWN, or UP or GRAYED as opposed to      */
/*                         toolbarFullStateFromButton which could return   */
/*                         FULLDOWN.                                       */
/***************************************************************************/
int FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton)
{
	int	iState;

	/* If a checkbox button is all the way down, it's previous state is */
	/* the one we want.						    */
	if ((iState = toolbarFullStateFromButton(hwnd, iButton))
							== BTNST_FULLDOWN) {
	    iState = toolbarPrevStateFromButton(hwnd, iButton);
	    return iState;
	} else
	    return iState;
}



/***************************************************************************/
/* toolbarStringFromIndex: Given an index into our array of buttons, return*/
/*                         the string resource associated with it.         */
/*                         Return -1 for an error.                         */
/***************************************************************************/
int FAR PASCAL toolbarStringFromIndex(HWND hwnd, int iBtnPos)
{
	int		iString;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;

	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the ID */
	iString = lpaButtons[iBtnPos].iString;	

	GlobalUnlock(h);
	return iString;
}



/***************************************************************************/
/* toolbarTypeFromIndex:   Given an index into our array of buttons, return*/
/*                         the type of button it is (PUSH, RADIO, etc.)    */
/*                         Return -1 for an error.                         */
/***************************************************************************/
int FAR PASCAL toolbarTypeFromIndex(HWND hwnd, int iBtnPos)
{
	int		iType;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the Array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;

	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the type */
	iType = lpaButtons[iBtnPos].iType;

	GlobalUnlock(h);
	return iType;
}


/***************************************************************************/
/* toolbarAddTool:  Add a button to this toolbar.  Sort them by leftmost   */
/*                  position in the window (for tabbing order).            */
/*                  Return FALSE for an error.                             */
/***************************************************************************/
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, TOOLBUTTON tb)
{
	HANDLE		h;
	TOOLBUTTON far  *lpaButtons;
	int		cButtons, i, j;
	BOOL		fInsert = FALSE;

	/* We better not have this button on the toolbar already */
	if (toolbarIndexFromButton(hwnd, tb.iButton) != -1)
		return FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons are there already? */
	cButtons = GETNUMBUTTONS(hwnd);

	/* If we have filled our alloced memory for this array already, we */
	/* need to re-alloc some more memory				   */
	if ( ((cButtons & (TOOLGROW - 1)) == 0) && (cButtons > 0) ) {

		/* Re-alloc it bigger */
		h = GlobalReAlloc(h,
			GlobalSize(h) + TOOLGROW * sizeof(TOOLBUTTON),
			GMEM_MOVEABLE | GMEM_SHARE);
		if (!h)
		    return FALSE;
	}

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Look for the spot we need to insert this new guy at.	*/
 	/* Remember, we sort by left x position	breaking ties   */
 	/* with top y position.					*/
	for (i = 0; i < cButtons; i++) {
						// Here it goes
 	    if (lpaButtons[i].rc.left > tb.rc.left ||
 			(lpaButtons[i].rc.left == tb.rc.left &&
 				lpaButtons[i].rc.top > tb.rc.top)) {
		fInsert = TRUE;
		/* Open up a spot in the array */
		for (j = cButtons; j > i; j--)
		    lpaButtons[j] = lpaButtons[j-1];
		/* Add our new guy */
		lpaButtons[i] = tb;		// redraw now
		InvalidateRect(hwnd, &(lpaButtons[i].rc), FALSE);
		break;
	    }
	}

	/* If our loop didn't insert it, we need to add it to the end */
	if (!fInsert)
	    lpaButtons[i] = tb;

	/* If we are told that this button has the focus, we better	*/
	/* change the focus to it.  Then use the normal state.          */
	if (tb.iState == BTNST_FOCUSUP) {
	    tb.iState = BTNST_UP;
	    SETWHICH(hwnd, i);
	} else if (tb.iState == BTNST_FOCUSDOWN || tb.iState == BTNST_FULLDOWN){
	    tb.iState = BTNST_DOWN;	// nonsense to init to FULLDOWN
	    SETWHICH(hwnd, i);
	}

	cButtons++;		// one more button now.
	GlobalUnlock(h);

	SETNUMBUTTONS(hwnd, (WORD) cButtons);	// new count
	SETARRAYBUTT(hwnd, h);		// re-alloc might have changed it

	/* Just in case no one else makes this new button draw */
	InvalidateRect(hwnd, &(tb.rc), FALSE);

	return TRUE;
}


 /***************************************************************************/
 /* toolbarRetrieveTool:  Get the TOOLBUTTON struct for the given button.   */
 /*                       Return FALSE for an error.                        */
 /***************************************************************************/
 BOOL FAR PASCAL toolbarRetrieveTool(HWND hwnd, int iButton, LPTOOLBUTTON lptb)
 {
 	int		i;
 	HANDLE		h;
 	TOOLBUTTON	far *lpButton;
 	BOOL		fFound = FALSE;
 	
 	/* Get the array of buttons */
 	h = GETARRAYBUTT(hwnd);
 	if (!h)
 		return FALSE;
 	lpButton = (TOOLBUTTON far *)GlobalLock(h);
 
 	/* look for what we need */
 	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
 		if (lpButton->iButton == iButton) {
 			*lptb = *lpButton;
 			fFound = TRUE;
 			break;
 		}
 
 	GlobalUnlock(h);
 	return fFound;
 }
 
 

/***************************************************************************/
/* toolbarRemoveTool:  Remove this button ID from our array of buttons on  */
/*                    the toolbar.  (only 1 of each button ID allowed).   */
/*                     Return FALSE for an error.                          */
/***************************************************************************/
BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton)
{
	HANDLE		h;
	TOOLBUTTON far  *lpaButtons;
	int		cButtons, i, j;
	BOOL		fFound = FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons are on there now? */
	cButtons = GETNUMBUTTONS(hwnd);

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Find a match, remove it, and close the array around it. */
	for (i = 0; i < cButtons; i++)
		if (lpaButtons[i].iButton == iButton) {	
			fFound = TRUE;
						// redraw now
			InvalidateRect(hwnd, &(lpaButtons[i].rc), FALSE);
			if (i != cButtons - 1)	// Last button? Don't bother!
				for (j = i; j < cButtons; j++)
					lpaButtons[j] = lpaButtons[j + 1];
			break;
		}

	GlobalUnlock(h);

	/* Didn't find it! */
	if (!fFound)
	    return FALSE;

	/* One less button */
	cButtons--;

	/* Every once in a while, re-alloc a smaller array chunk to	*/
	/* save memory.							*/
	if ( ((cButtons & (TOOLGROW - 1)) == 0) && (cButtons > 0) ) {

		/* Re-alloc it smaller */
		h = GlobalReAlloc(h,
			GlobalSize(h) - TOOLGROW * sizeof(TOOLBUTTON),
			GMEM_MOVEABLE | GMEM_SHARE);
		if (!h)
		    return FALSE;
	}

	SETNUMBUTTONS(hwnd, (WORD) cButtons);	// new count
	SETARRAYBUTT(hwnd, h);		// re-alloc could have changed it

	return TRUE;
}

/***************************************************************************/
/* toolbarModifyString: Given a button ID on the toolbar, change it's      */
/*                      string resource associated with it.                */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyString(HWND hwnd, int iButton, int iString)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;
	BOOL		fFound = FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons? */
	cButtons = GETNUMBUTTONS(hwnd);
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* Find that button, and change it's state */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			lpButton->iString = iString;
			fFound = TRUE;			// redraw now
			break;
		}

	GlobalUnlock(h);
	return fFound;
}

/***************************************************************************/
/* toolbarModifyState:  Given a button ID on the toolbar, change it's      */
/*                      state.                                             */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int iState)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;
	BOOL		fFound = FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons? */
	cButtons = GETNUMBUTTONS(hwnd);
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* Find that button, and change it's state */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			if (lpButton->iState != iState) {
				lpButton->iState = iState;
				InvalidateRect(hwnd, &(lpButton->rc), FALSE);
			}
			fFound = TRUE;			// redraw now

			/* if we're pushing a radio button down, bring */
			/* all others in its group up */
			if (lpButton->iType >= BTNTYPE_RADIO &&
					iState == BTNST_DOWN)
			    toolbarExclusiveRadio(hwnd, lpButton->iType,
								iButton);
			break;
		}

	GlobalUnlock(h);
	return fFound;
}


/***************************************************************************/
/* toolbarModifyPrevState: Given a button on the toolbar, change it's prev-*/
/*                      ious state. Used for non-PUSH buttons to remember  */
/*                      what state a button was in before pressed all the  */
/*                      way down, so that when you let go, you know what   */
/*                      state to set it to (the opposite of what it was).  */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyPrevState(HWND hwnd, int iButton, int iPrevState)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;

	/* Get button array */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons? */
	cButtons = GETNUMBUTTONS(hwnd);

	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* Find the button, change the state */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			lpButton->iPrevState = iPrevState;
			break;
		}

	GlobalUnlock(h);
	return TRUE;
}


/***************************************************************************/
/* toolbarModifyActivity: Given a button ID on the toolbar, change it's    */
/*                        activity.  This tells the app what just happened */
/*                        to the button (ie. KEYUP, MOUSEDBLCLK, etc.)     */
/*                        returns FALSE for an error or if no such button  */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyActivity(HWND hwnd, int iButton, int iActivity)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;

	/* Get the button array */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons */
	cButtons = GETNUMBUTTONS(hwnd);

	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through and change the right one */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			lpButton->iActivity = iActivity;
			break;
		}

	GlobalUnlock(h);
	return TRUE;
}



/***************************************************************************/
/* toolbarFixFocus:  SETWHICH() has been called to tell us which button    */
/*                   has the focus, but the states of all the buttons are  */
/*                   not updated (ie. take focus away from the old button) */
/*                   This routine is called from the Paint routine to fix  */
/*                   the states of all the buttons before drawing them.    */
/*                   Returns FALSE for an error.                           */
/***************************************************************************/
BOOL FAR PASCAL toolbarFixFocus(HWND hwnd)
{
	int		iFocus;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;
	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

        /* if focus is on an illegal button, default to the first one */
	iFocus = GETWHICH(hwnd);
	if (iFocus < 0 || iFocus >= GETNUMBUTTONS(hwnd))
	    SETWHICH(hwnd, 0);

	/* First of all, make sure that the focus in not on a grayed button. */
	/* if so, we advance focus.  If it runs out of buttons without       */
	/* finding a non-gray one, we start back at the beginning and start  */
	/* looking for a non-gray one from there.  If every button is grayed,*/
	/* we leave no focus anywhere.					     */
	if (lpaButtons[GETWHICH(hwnd)].iState == BTNST_GRAYED) {
	    if (!toolbarMoveFocus(hwnd, FALSE)) {
		SETWHICH(hwnd, -1);
		toolbarMoveFocus(hwnd, FALSE);
	    }
	}

	GlobalUnlock(h);
	return TRUE;
}



/***************************************************************************/
/* toolbarExclusiveRadio:  For radio buttons, we need to pop all others    */
/*                         in the group up when one goes down.  Pass the   */
/*                         button that is going down, and its group, and   */
/*                         this routine will pop all others up.            */
/*                         Returns FALSE for an error.                     */
/***************************************************************************/
BOOL FAR PASCAL toolbarExclusiveRadio(HWND hwnd, int iType, int iButton)
{
	int		i;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* all buttons with this type that aren't this button come up	*/
	/* if they are not grayed					*/
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
	    if (lpButton->iType == iType)
		if (lpButton->iButton != iButton &&
				lpButton->iState != BTNST_GRAYED) {
		    toolbarModifyState(hwnd, lpButton->iButton,	BTNST_UP);
		}

	GlobalUnlock(h);
	return TRUE;
}


/*	NotifyParent()  of activity to a button  */

static void NEAR PASCAL NotifyParent(HWND hwnd, int iButton)
{
#ifndef WIN32
	PostMessage(GetParent(hwnd),WM_COMMAND,
			GetWindowWord(hwnd,GWW_ID),MAKELONG(hwnd,iButton));
#else
	PostMessage(GetParent(hwnd),WM_COMMAND,
			GetWindowLong(hwnd,GWL_ID),MAKELONG(hwnd,iButton));
#endif
}


/***************************************************************************/
/* toolbarPaintControl:  Handles paint messages by blitting each bitmap    */
/*                       that is on the toolbar to its rect.               */
/*                       First, it fixes the states of the buttons to give */
/*                       the focus to the proper button.                   */
/*                       Returns FALSE for an error.                       */
/***************************************************************************/
static BOOL NEAR PASCAL toolbarPaintControl(HWND hwnd, HDC hdc)
{
    int		iBtnPos;	/* 0 to toolbarGetNumButtons inclusive	*/
    int		iButton;	/* 0 to NUMBUTTONS-1 inclusive		*/
    int		iState;		/* 0 to NUMSTATES-1 inclusive		*/
    HDC		hdcBtn;		/* DC onto button bitmap		*/
    
    RECT	rcDest;
    POINT	pt;
    long	l;
    HANDLE	hbm;

    /* Make a source HDC for the button pictures, and select the button */
    /* bitmap into it.							*/
    hdcBtn = CreateCompatibleDC(hdc);
    if (!hdcBtn)
	return FALSE;
    hbm = GETBMPHANDLE(hwnd);
    if (hbm) {
	if (!SelectObject(hdcBtn, GETBMPHANDLE(hwnd))) {
	    DeleteDC(hdcBtn);
	    return FALSE;
	}
    }
    
    toolbarFixFocus(hwnd);	// set the focus field correctly

    /* Go through all buttons on the toolbar */
    for (iBtnPos = 0; iBtnPos < toolbarGetNumButtons(hwnd); iBtnPos++) {

	iButton = toolbarButtonFromIndex(hwnd, iBtnPos);	// button
	iState = toolbarFullStateFromButton(hwnd, iButton);	// state
	toolbarRectFromIndex(hwnd, iBtnPos, &rcDest);		// Dest Rect
	
	/* If we have the focus, we should draw it that way */
        if (GetFocus() == hwnd && GETWHICH(hwnd) == iBtnPos
						&& iState == BTNST_UP)
	    iState = BTNST_FOCUSUP;
        if (GetFocus() == hwnd && GETWHICH(hwnd) == iBtnPos
						&& iState == BTNST_DOWN)
	    iState = BTNST_FOCUSDOWN;

	/* If we don't have the focus, we should take it away */
        if ((GetFocus() != hwnd || GETWHICH(hwnd) != iBtnPos)
						&& iState == BTNST_FOCUSUP)
	    iState = BTNST_UP;
        if ((GetFocus() != hwnd || GETWHICH(hwnd) == iBtnPos)
						&& iState == BTNST_FOCUSDOWN)
	    iState = BTNST_DOWN;

	/* The size of each button */
	l = GETBUTTONSIZE(hwnd);
	pt.x = HIWORD(l);
	pt.y = LOWORD(l);

	/* Blit from the button picture to the toolbar window */
	BitBlt(hdc, rcDest.left, rcDest.top,
	    rcDest.right - rcDest.left, rcDest.bottom - rcDest.top,
	    hdcBtn, pt.x * iButton, pt.y * iState,
	    SRCCOPY);
    }

    DeleteDC(hdcBtn);

    return TRUE;
}




/***************************************************************************/
/* toolbarMoveFocus:  Move Focus forward or backward one button.  You give */
/*                    it the direction to move the focus.  The routine will*/
/*                    stop at the end of the button list without wrapping  */
/*                    around.                                              */
/*                    Returns TRUE if focus moved, or FALSE if it ran out  */
/*                    of buttons before finding a non-grayed one.          */
/***************************************************************************/
BOOL FAR PASCAL toolbarMoveFocus(HWND hwnd, BOOL fBackward)
{
	int 	iBtnPos, iButton, nOffset, nStopAt;
	RECT	rc;
	int iPrevPos = GETWHICH(hwnd); 	/* Who used to have focus? */

	/* Fix illegal value.  It's OK to be one less or greater than range */
	if (iPrevPos < -1 || iPrevPos > GETNUMBUTTONS(hwnd))
	    SETWHICH(hwnd, 0);	// good a default as any

	if (fBackward) {
	    nOffset = -1;
	    nStopAt = -1;
	} else {
	    nOffset = 1;
	    nStopAt = GETNUMBUTTONS(hwnd);
	}
			
	/* look for next button that isn't grayed    */
	/* DON'T wrap around - future code will pass */
	/* the focus to another window (???)         */
	for (iBtnPos = GETWHICH(hwnd) + nOffset; 
		    iBtnPos != nStopAt;
		    iBtnPos += nOffset) {
	    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
	    if (toolbarStateFromButton(hwnd, iButton) != 
				    BTNST_GRAYED) {
		SETWHICH(hwnd, iBtnPos);	// set focus

		/* Redraw both old and new focused button */
		toolbarRectFromIndex(hwnd, iPrevPos, &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		break;

	    }
	}

	if (GETWHICH(hwnd) != iPrevPos)
	    return TRUE;
	else
	    return FALSE;
}

/***************************************************************************/
/* toolbarSetFocus :  Set the focus in the toolbar to the specified button.*/
/*                    If it's gray, it'll set focus to next ungrayed btn.  */
/*                    Returns TRUE if focus set, or FALSE if the button    */
/*                    doesn't exist or if it and all buttons after it were */
/*                    grayed...       You can use TB_FIRST or TB_LAST in   */
/*                    place of a button ID.  This uses the first or last   */
/*                    un-grayed button.                                    */
/***************************************************************************/
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton)
{
    int iBtnPos;
    RECT rc;

    /* Don't move focus while a button is down */
    if (GetCapture() != hwnd && !GETKEYPRESSED(hwnd)) {

	/* redraw button with focus in case focus moves */
	toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
	InvalidateRect(hwnd, &rc, FALSE);

	if (iButton == TB_FIRST) {
	    SETWHICH(hwnd, -1); // move forward to 1st button 
	    return toolbarMoveFocus(hwnd, FALSE);
	} else if (iButton == TB_LAST) {
	    SETWHICH(hwnd, GETNUMBUTTONS(hwnd));
	    return toolbarMoveFocus(hwnd, TRUE);
	} else {
	    iBtnPos = toolbarIndexFromButton(hwnd, iButton);
	    if (iBtnPos != -1) {
		SETWHICH(hwnd, --iBtnPos);
		return toolbarMoveFocus(hwnd, FALSE);
	    } else
		return FALSE;
	}
	return TRUE;

    } else
	return FALSE;
}

//
//  LoadUIBitmap() - load a bitmap resource
//
//      load a bitmap resource from a resource file, converting all
//      the standard UI colors to the current user specifed ones.
//
//      this code is designed to load bitmaps used in "gray ui" or
//      "toolbar" code.
//
//      the bitmap must be a 4bpp windows 3.0 DIB, with the standard
//      VGA 16 colors.
//
//      the bitmap must be authored with the following colors
//
//          Button Text        Black        (index 0)
//          Button Face        lt gray      (index 7)
//          Button Shadow      gray         (index 8)
//          Button Highlight   white        (index 15)
//          Window Color       yellow       (index 11)
//          Window Frame       green        (index 10)
//
//      Example:
//
//          hbm = LoadUIBitmap(hInstance, "TestBmp",
//              GetSysColor(COLOR_BTNTEXT),
//              GetSysColor(COLOR_BTNFACE),
//              GetSysColor(COLOR_BTNSHADOW),
//              GetSysColor(COLOR_BTNHIGHLIGHT),
//              GetSysColor(COLOR_WINDOW),
//              GetSysColor(COLOR_WINDOWFRAME));
//
//      Author:     JimBov, ToddLa
//
//

HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCSTR      szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame)           // color to use for "Window Frame"
{
    LPBYTE              lpb;
    HBITMAP             hbm;
    LPBITMAPINFOHEADER  lpbi;
    HANDLE              h;
    HDC                 hdc;
    LPDWORD             lprgb;
    struct
    {
        BITMAPINFOHEADER    bi;
        DWORD               adw[16];
    } dib4;

    // convert a RGB into a RGBQ
    #define RGBQ(dw) RGB(GetBValue(dw),GetGValue(dw),GetRValue(dw))

    h = LoadResource (hInstance,FindResource(hInstance, szName, RT_BITMAP));

    lpbi = (LPBITMAPINFOHEADER)LockResource(h);

    if (!lpbi)
        return(NULL);

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return NULL;

    if (lpbi->biBitCount != 4)
        return NULL;

    /* Calcluate the pointer to the Bits information */
    /* First skip over the header structure */
    lprgb = (LPDWORD)((LPBYTE)(lpbi) + lpbi->biSize);


    /* Skip the color table entries, if any */
    lpb = (LPBYTE)lprgb + ((int)lpbi->biClrUsed ? (int)lpbi->biClrUsed :
        (1 << (int)lpbi->biBitCount)) * sizeof(RGBQUAD);


    hmemcpy(&dib4, lpbi, sizeof(BITMAPINFOHEADER) + 16*sizeof(DWORD));
    lpbi = (LPBITMAPINFOHEADER) &dib4.bi;
    lprgb = (LPDWORD) &dib4.adw;


    lprgb[0]  = RGBQ(rgbText);          // Black
    lprgb[7]  = RGBQ(rgbFace);          // lt gray
    lprgb[8]  = RGBQ(rgbShadow);        // gray
    lprgb[15] = RGBQ(rgbHighlight);     // white
    lprgb[11] = RGBQ(rgbWindow);        // yellow
    lprgb[10] = RGBQ(rgbFrame);         // green

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap (hdc, lpbi, CBM_INIT, (LPVOID)lpb,
        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);
    UnlockResource(h);
    FreeResource(h);

    return(hbm);
}

/****************************************************************************
	toolbarWndProc()

	Window proc for toolbar.

	Arguments:
		Standard window proc
****************************************************************************/

LONG FAR PASCAL EXPORT toolbarWndProc(HWND hwnd, unsigned message,
						WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT	ps;
    POINT		pt;
#ifdef WIN32
	 POINTS		pts;
	 POINT		pt1;
#endif	 
    RECT		rc;
    int			iBtnPos, iButton, ibmp;
    HANDLE		lpaButtons, hbm, hInst;
	 HDC			hDC;

    switch (message) {
        
        case WM_CREATE:			// do all initialization
		
		/* What do these do? */
		SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
		    			SWP_NOZORDER | SWP_NOSIZE |
					SWP_NOMOVE | SWP_NOACTIVATE);
		SetWindowLong(hwnd,GWL_STYLE,lpCreate->style & 0xFFFF00FF);
		
		/* Alloc some space for the array of buttons on this bar */
		lpaButtons = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
					TOOLGROW * sizeof(TOOLBUTTON));

		SETARRAYBUTT(hwnd, lpaButtons);	// list of buttons on toolbar
		SETNUMBUTTONS(hwnd, 0);		// # buttons in toolbar
		SETPRESSED(hwnd, FALSE);	// mouse button being pressed?
		SETKEYPRESSED(hwnd, FALSE);	// is a key being pressed?
		SETWHICH(hwnd, -1);		// which button has the focus?
		SETSHIFTED(hwnd, FALSE);	// shift-click or right-click?

		/* This wParam will be sent to the parent window to indentify */
		/* that the toolbar sent the WM_COMMAND msg.  The hwnd of the */
		/* toolbar that sent the msg will be in the lParam.	      */
#ifndef WIN32
		SetWindowWord(hwnd, GWW_ID, (WORD)IDC_TOOLBAR);
#else
		SetWindowLong(hwnd, GWL_ID, (LONG)IDC_TOOLBAR);
#endif
		/* later on, someone will set the bmp handle of the buttons */
		SETBMPHANDLE(hwnd, NULL);

		break;

        case WM_LBUTTONDOWN:	// button goes down on a toolbar button
        case WM_RBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:

		/* If we don't give ourself focus, we'll never get KEYDOWN */
		/* or KEYUP messages.					   */
		/* Get the focus only if we're a TABSTOP and the app wants */
		/* us to take focus.					   */
		if ( (GetWindowLong(hwnd, GWL_STYLE) & WS_TABSTOP)
						&& GetFocus() != hwnd)
		    SetFocus(hwnd);

		/* ignore messages if window is disabled */
		if (!IsWindowEnabled(hwnd))
		    return 0L;

		/* ignore multiple down messages (we set Capture here) */
		/* also ignore if a key is down                        */
		if (GetCapture() == hwnd || GETPRESSED(hwnd))
		    return 0L;
		
		/* Where did the mouse go down? */
#ifdef WIN32
		pts = MAKEPOINTS (lParam);
		pt.x = pts.x;
		pt.y = pts.y;
#else
		pt = MAKEPOINT(lParam);
#endif
		/* which button was pressed? */
		iBtnPos = toolbarIndexFromPoint(hwnd, pt);

		/* If it was a valid button... */
		if (iBtnPos >= 0) {
		    int		iOldPos;
		    int		iState, iType, iButton;

		    /* Everything you wanted to know about this button */
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iState = toolbarFullStateFromButton(hwnd, iButton);

		    /* ignore downs on a grayed button, unless it's a	*/
		    /* custom button, then tell them anyway		*/
		    if (iType != BTNTYPE_CUSTOM && iState == BTNST_GRAYED)
			return 0;

		    /* We better get all mouse messages from now on */
		    SetCapture(hwnd);

		    /* Shift key or right button indicates a SHIFT down */
		    SETSHIFTED(hwnd, 
				(WORD) ((message == WM_RBUTTONDOWN)||(wParam & MK_SHIFT)));

		    /* Yes, we've pressed the button down */
		    SETPRESSED(hwnd, TRUE);

		    /* Remember who used to have the focus, and we get it now */
		    iOldPos = GETWHICH(hwnd);
		    SETWHICH(hwnd, iBtnPos);

		    /* For a push button, send it down */
		    if (iType == BTNTYPE_PUSH)
			toolbarModifyState(hwnd, iButton, BTNST_DOWN);

		    /* for a checkbox or radio button (of any group),       */
		    /* remember what state it was in, and send it FULL down */
		    /* (with focus).					    */
		    if (iType == BTNTYPE_CHECKBOX || iType >= BTNTYPE_RADIO) {
			toolbarModifyPrevState(hwnd, iButton, iState);
			toolbarModifyState(hwnd,iButton,BTNST_FULLDOWN);
		    }

		    toolbarModifyActivity(hwnd, iButton, BTNACT_MOUSEDOWN);

		    /* Set Double click flag appropriately */
//		    if (message == WM_LBUTTONDBLCLK ||
//						message == WM_RBUTTONDBLCLK)
//			NotifyParent(hwnd, (GETSHIFTED(hwnd) ? BTN_SHIFT : 0)
//						 + BTN_DBLCLICK + iButton);
//		    else
//			NotifyParent(hwnd, (GETSHIFTED(hwnd) ? BTN_SHIFT : 0)
//						 + iButton);

            helpToolBar(iButton);

		    /* Invalidate the Rect of the button being pressed */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    InvalidateRect(hwnd, &rc, FALSE);

		    /* Invalidate the Rect of the button losing focus */
		    toolbarRectFromIndex(hwnd, iOldPos, &rc);
		    InvalidateRect(hwnd, &rc, FALSE);

		    /* Force re-paint now */
		    UpdateWindow(hwnd);

		    /* Set a timer for repeated mouse downs */
//		    SetTimer(hwnd, TIMER_BUTTONREPEAT,
//				 MSEC_BUTTONREPEAT, NULL);
//          SendMessage (hwnd, WM_RBUTTONUP, wParam, lParam);
		}
		    
		return 0L;

        case WM_MOUSEMOVE:

#if 0
		/* This should be impossible - it means that the system lost */
		/* a mouse up (maybe codeview is up?) We need to force a     */
		/* mouse up at this point.				     */
		if (GetCapture() == hwnd &&
			(wParam & (MK_LBUTTON | MK_RBUTTON) == 0))
		    SendMessage(hwnd, WM_LBUTTONUP, 0, lParam);
#endif

		/* Mouse moving while pressing a button?  If not, ignore. */
		if (GetCapture() == hwnd) {
		    int		iPrevState, iState, iButton, iType;
		    BOOL	fPressed;
		
		    /* Which button is being pressed down? */
		    iBtnPos = GETWHICH(hwnd);

		    /* Where is mouse cursor now? */
#ifdef WIN32
			pts = MAKEPOINTS (lParam);
			pt.x = pts.x;
			pt.y = pts.y;
#else
			pt = MAKEPOINT(lParam);
#endif

		    /* where is button being pressed? Are we still on */
		    /* top of that button or have we moved?	      */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    fPressed = PtInRect(&rc, pt);

		    /* Let go if we move off of the button, but don't */
		    /* act like it was pressed.                       */
		    /* Also, push it back down if we move back on top */
		    /* of it (while the mouse button is STILL down).  */
		    if (fPressed != GETPRESSED(hwnd)) {

			/* update: is this button pressed anymore? */
			SETPRESSED(hwnd, fPressed);

			iType = toolbarTypeFromIndex(hwnd, iBtnPos);
			iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
			iState = toolbarFullStateFromButton(hwnd, iButton);

			/* The mouse moved back onto the button while */
			/* the mouse button was still pressed.	      */
			if (fPressed) {

			    /* Push the push button back down again */
	 		    if (iType == BTNTYPE_PUSH)
				toolbarModifyState(hwnd, iButton,
							BTNST_DOWN);

			    /* Push the radio or checkbox button ALL the */
			    /* way down again.				 */
			    if (iType >= BTNTYPE_RADIO ||
						iType == BTNTYPE_CHECKBOX)
				toolbarModifyState(hwnd, iButton,
							BTNST_FULLDOWN);

			    toolbarModifyActivity(hwnd, iButton,
							BTNACT_MOUSEMOVEON);
//			    NotifyParent(hwnd,
//					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
//					iButton);

			/* We moved the mouse off of the toolbar button */
			/* while still holding the mouse button down.   */
			} else {

			    /* lift the push button up */
	 		    if (iType == BTNTYPE_PUSH)
				toolbarModifyState(hwnd, iButton,
							BTNST_UP);

			    /* Restore radio button or checkbox button to */
			    /* where it was before pressed		  */
			    if (iType >= BTNTYPE_RADIO ||
						iType == BTNTYPE_CHECKBOX) {
				iPrevState = toolbarPrevStateFromButton(hwnd,
							iButton);
				toolbarModifyState(hwnd, iButton, iPrevState);
			    }

			    toolbarModifyActivity(hwnd, iButton,
							BTNACT_MOUSEMOVEOFF);
//			    NotifyParent(hwnd,
//					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
//					toolbarButtonFromIndex(hwnd, iBtnPos));
			}
		    }
		}
		return 0L;

        case WM_LBUTTONUP:	
        case WM_RBUTTONUP:

		/* If we don't have capture, we aren't expecting this. Ignore */
		if (GetCapture() == hwnd) {
		    int		iPrevState, iState, iButton, iType;
		    
		    /* Who has the focus? */
		    iBtnPos = GETWHICH(hwnd);

		    /* Release the mouse */
		    ReleaseCapture();
		    
		    /* No more repeats of the mouse button downs */
//		    KillTimer(hwnd, TIMER_BUTTONREPEAT);
		    
		    /* Everything you wanted to know about the button */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iState = toolbarFullStateFromButton(hwnd, iButton);

		    /* Don't do anything if we've moved off the button */
		    if (GETPRESSED(hwnd)) 
            {

    			/* No longer down */
	    		SETPRESSED(hwnd, FALSE);
            
			    /* Bring the push button up */
    			if (iType == BTNTYPE_PUSH)
	    		    toolbarModifyState(hwnd, iButton, BTNST_UP);

		    	/* Bring the checkbox to the opposite state it was in */
			    if (iType == BTNTYPE_CHECKBOX) 
                {
			        iPrevState = toolbarPrevStateFromButton(hwnd,
						iButton);
    			    if (iPrevState == BTNST_DOWN)
	    			toolbarModifyState(hwnd, iButton, BTNST_UP);
		    	    if (iPrevState == BTNST_UP)
			    	toolbarModifyState(hwnd, iButton, BTNST_DOWN);
    			}

    			/* Force a radio button down, and bring all   */
	    		/* other radio buttons of this type up	      */
		    	if (iType >= BTNTYPE_RADIO) 
                {
			        toolbarModifyState(hwnd, iButton, BTNST_DOWN);
			        toolbarExclusiveRadio(hwnd, iType, iButton);
    			}

    			/* Notify the parent that the mouse button came up */
	    		/* on this button so the app can do something.     */
		    	/* Every button should notify the app, not just a  */
			   /* custom button.				   */
    			toolbarModifyActivity(hwnd, iButton, BTNACT_MOUSEUP);
#ifdef WIN32
				pts = MAKEPOINTS (lParam);
				pt1.x = pts.x;
				pt1.y = pts.y;
            if (iBtnPos == toolbarIndexFromPoint (hwnd, pt1))
#else
            if (iBtnPos == toolbarIndexFromPoint (hwnd, MAKEPOINT (lParam)))
#endif
            {
    		    	NotifyParent(hwnd, 
	    		        (GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + iButton);
            }

		    }
            else
            {
                restoreStatusBar();
            }
        }

		return 0L;

		
	case WM_TIMER:

		/* If we have a tool button down, send a repeat message */
		if (GETPRESSED(hwnd)) {
		    int		iButton, iType;

		    iBtnPos = GETWHICH(hwnd);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);

		    NotifyParent(hwnd, BTN_REPEAT + 
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					toolbarButtonFromIndex(hwnd, iBtnPos));
		}
		break;
		

        case WM_DESTROY:
/*********************************************************************/
#ifdef _AVIEDIT
		if (hwnd == hwndTransport)
		    hwndTransport = NULL;
#endif
/*********************************************************************/
		if (GETBMPHANDLE(hwnd))
		    DeleteObject(GETBMPHANDLE(hwnd));
		SETBMPHANDLE(hwnd, NULL);
		if (GETARRAYBUTT(hwnd))
		    GlobalFree(GETARRAYBUTT(hwnd));
		SETARRAYBUTT(hwnd, NULL);
		break;

        case WM_SETTEXT:
		break;
		
/* MANY, MANY cases deleted */

	case WM_SETFOCUS:		// focus comes to toolbar window
	    {
		/* Remember who had the focus and give it back.  Of course, */
		/* if by some wierdness that button is now grayed, give it  */
		/* to the next person in line.				    */
		iBtnPos = GETWHICH(hwnd); 
		if (iBtnPos < 0 || iBtnPos >= toolbarGetNumButtons(hwnd)) {
		    iBtnPos = 0;
		    SETWHICH(hwnd, 0);
		}

		do {
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    if (toolbarFullStateFromButton(hwnd, iButton)
							!= BTNST_GRAYED)
			break;			// give it here
		    iBtnPos++;
		    if (iBtnPos >= toolbarGetNumButtons(hwnd))
			iBtnPos = 0;		// wrap around
		    if (iBtnPos == GETWHICH(hwnd))
			return 0L;		// uh-oh! They're all gray!
		} while (iBtnPos != GETWHICH(hwnd));
			
		SETWHICH(hwnd, iBtnPos);	// give focus here
		
		/* And redraw! */
		toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		UpdateWindow(hwnd);
		return 0;
	    }
	    
	case WM_KILLFOCUS:

		/* Send a KEYUP if one is pending */
		if (GETKEYPRESSED(hwnd))
		    SendMessage(hwnd, WM_KEYUP, VK_SPACE, 0L);

		/* Redraw the focused button, because now that focus is gone */
		/* from our toolbar window, the focused button won't be      */
		/* focused anymore, although we remember which one it was.   */
		toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		UpdateWindow(hwnd);
		return 0;

	case WM_SYSKEYDOWN:
		/* Send a KEYUP if one is pending */
		if (GETKEYPRESSED(hwnd))
		    SendMessage(hwnd, WM_KEYUP, VK_SPACE, 0L);
		break;	// MUST LET DEFWNDPROC RUN!!! (to handle the key)

        case WM_GETDLGCODE:
		return DLGC_WANTARROWS | DLGC_WANTTAB;

	case WM_KEYDOWN:

		/* Window disabled or a key is already down */
		if (IsWindowEnabled(hwnd) && !GETPRESSED(hwnd)) {

		    /* Tab forward to next button and move focus there */
		    if (wParam == VK_TAB && GetKeyState(VK_SHIFT) >= 0 ) {

			/* Move Focus forward one.  If */
			/* we've tabbed off of the toolbar, it's time */
			/* to go on to the next control. We need to invldte */
			/* because we might be the only control and we need */
			/* to repaint to show the new button with highlight */
			/* after it wrapped around the end of the toolbar.  */
			if (!toolbarMoveFocus(hwnd, FALSE)) {
			    PostMessage(GetParent(hwnd), WM_NEXTDLGCTL, 0, 0L);
			    toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
			    InvalidateRect(hwnd, &rc, FALSE);
			}

			return 0L;
		    }
		    if (wParam == VK_TAB && GetKeyState(VK_SHIFT) < 0 ) {

			/* Move focus backward one.  If */
			/* We've tabbed off of the toolbar, it's time    */
			/* to go on to the next control. We need to invldte */
			/* because we might be the only control and we need */
			/* to repaint to show the new button with highlight */
			/* after it wrapped around the end of the toolbar.  */
			if (!toolbarMoveFocus(hwnd, TRUE)) {
			    PostMessage(GetParent(hwnd), WM_NEXTDLGCTL, 1, 0L);
			    toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
			    InvalidateRect(hwnd, &rc, FALSE);
			}

			return 0L;
		    }
		    if ((wParam == VK_SPACE) && (GetCapture() != hwnd)) {

			int	iButton, iType, iState;

			/* Same as mouse button down -- Press the button! */
			iBtnPos = GETWHICH(hwnd);
			iType = toolbarTypeFromIndex(hwnd, iBtnPos);
			iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
			iState = toolbarFullStateFromButton(hwnd, iButton);

			/* ignore multiple key downs */
			if (!GETKEYPRESSED(hwnd)) {

			    SETKEYPRESSED(hwnd, TRUE);	// a key is pressed

			    SETSHIFTED(hwnd, FALSE);	// NEVER shifted
			    SETPRESSED(hwnd, TRUE);	// a button is pressed

			    /* Push button goes down - with focus */
			    if (iType == BTNTYPE_PUSH)
				toolbarModifyState(hwnd, iButton, BTNST_DOWN);

			    /* Radio or checkbox button goes full down */
			    /* with focus - and remember previous state*/
			    if (iType >= BTNTYPE_RADIO ||
						iType == BTNTYPE_CHECKBOX) {
				toolbarModifyPrevState(hwnd, iButton, iState);
				toolbarModifyState(hwnd, iButton,
							BTNST_FULLDOWN);
			    }

			    toolbarModifyActivity(hwnd, iButton,
								BTNACT_KEYDOWN);
			    NotifyParent(hwnd, (GETSHIFTED(hwnd)
						? BTN_SHIFT : 0) + iButton);

			    return 0L;
			}
		    
			/* If this is another KEYDOWN msg, it's a REPEAT */
			/* Notify parent.                                */
			NotifyParent(hwnd, BTN_REPEAT + 
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					toolbarButtonFromIndex(hwnd, 
							GETWHICH(hwnd)));
		    }
		}
		break;
	
	case WM_KEYUP:

		/* A button was pressed and should come up now */
		if ((wParam == VK_SPACE) && (GETKEYPRESSED(hwnd))) {
		    int		iButton, iState, iType, iPrevState;

		    iBtnPos = GETWHICH(hwnd);		// which button?
		    SETKEYPRESSED(hwnd, FALSE);		// let go
		    SETPRESSED(hwnd, FALSE);

		    /* Everything about this button */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iState = toolbarFullStateFromButton(hwnd, iButton);

		    /* Bring a push button up */
		    if (iType == BTNTYPE_PUSH)
			toolbarModifyState(hwnd, iButton, BTNST_UP);

		    /* Bring a checkbox to the opposite state it was in */
		    if (iType == BTNTYPE_CHECKBOX) {
			iPrevState = toolbarPrevStateFromButton(hwnd, iButton);
			if (iPrevState == BTNST_DOWN)
			    toolbarModifyState(hwnd, iButton, BTNST_UP);
			if (iPrevState == BTNST_UP)
			    toolbarModifyState(hwnd, iButton, BTNST_DOWN);
		    }

		    /* Bring a radio button down, and bring all others in */
		    /* its group up.					  */
		    if (iType >= BTNTYPE_RADIO) {
			toolbarModifyState(hwnd, iButton, BTNST_DOWN);
			toolbarExclusiveRadio(hwnd, iType, iButton);
		    }

		    toolbarModifyActivity(hwnd, iButton, BTNACT_KEYUP);
		    NotifyParent(hwnd, toolbarButtonFromIndex(hwnd, 
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					GETWHICH(hwnd)));
		}
		break;
	    
	case WM_SYSCOLORCHANGE:
		/* load the bitmap of what all the buttons look like */
		/* and change the colours to the system colours.     */
		hInst = GETHINST(hwnd);
		ibmp = GETBMPINT(hwnd);
		hbm = GETBMPHANDLE(hwnd);
		if (hbm)
		    DeleteObject(hbm);
		hbm = LoadUIBitmap(hInst, MAKEINTRESOURCE(ibmp),
		    GetSysColor(COLOR_BTNTEXT),
		    GetSysColor(COLOR_BTNFACE),
		    GetSysColor(COLOR_BTNSHADOW),

//          gfWin31 is not defined anywhere.  I have no clue what it's for...
//		    (gfWin31 ? GetSysColor(COLOR_BTNHIGHLIGHT) :
//						RGB(255,255,255)),
            GetSysColor (COLOR_BTNHIGHLIGHT),

		    GetSysColor(COLOR_BTNFACE),
		    GetSysColor(COLOR_WINDOWFRAME));
		SETBMPHANDLE(hwnd, hbm);
		return MAKELONG(hbm, 0);

//        case WM_ERASEBKGND:
//		break;

/************************************************************************/
/***********  REMOVE to make generic code  ******************************/
/************************************************************************/
/* Disable everything during a crop */
#ifdef _AVIEDIT
	case WM_NCHITTEST:
		if (gfInCrop)
		    return HTNOWHERE;
		break;
#endif
/************************************************************************/

        case WM_PAINT:

		/* Call our paint code */
		hDC = BeginPaint(hwnd, &ps);
		toolbarPaintControl(hwnd, hDC);
		EndPaint(hwnd, &ps);

		return 0L;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tslog.c ===
/***************************************************************************\
*                                                                           *
*   File: Tslog.c                                                           *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This code handles the logging selection and implementation          *
*                                                                           *
*   Contents:                                                               *
*       SetLogfileName()                                                    *
*       doIndent()                                                          *
*       doFileIndent()                                                      *
*       logCaseStatus()                                                     *
*       logDateTimeBuild()                                                  *
*       Log()                                                               *
*       setFileModeBttns()                                                  *
*       setLogFileMode()                                                    *
*       setLogOutDest()                                                     *
*       setLogOutLvl()                                                      *
*       setLogFileLvl()                                                     *
*       setLogBttns()                                                       *
*       LoggingDlgProc()                                                    *
*       Logging()                                                           *
*       tstLogFlush()                                                       *
*       tstLogEnableFastLogging()                                           *
*       tstLog()                                                            *
*       tstLogFn()                                                          *
*       tstBeginSection()                                                   *
*       tstEndSection()                                                     *
*                                                                           *
*   History:                                                                *
*       02/18/91    prestonb    Created from tst.c                          *
*                                                                           *
*       07/14/93    T-OriG      Added functionality and this header         *
*       08/13/94    t-rajr      Modified tstLogFlush and tstLog for thread  *
*                               support                                     *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include <mmsystem.h>
//#include "mprt1632.h"
#include "support.h"
#include <gmem.h>
#include <defdlg.h>
#include <time.h>
#include "tsdlg.h"
#include "tsglobal.h"
#include "tsstats.h"
#include "tsextern.h"
#include "text.h"
#include <stdarg.h>
#include <commdlg.h>
#include "toolbar.h"

#ifdef  HCT
#include <hctlib.h>
#endif  // HCT

#define LOG_BUFFER_LENGTH  255
#define EXTRA_BUFFER       25

#define NUM_SPACES_INDENT  4

/* Internal Functions */
void doIndent(void);
void doFileIndent(void);
void Log(LPSTR,UINT);
void setFileModeBttns(HWND);
void setLogFileMode(HWND);
void setLogOutDest(HWND);
void setLogOutLvl(HWND);
void setLogFileLvl(HWND);
void setLogBttns(HWND);
void setRunParms(HWND);
void setRunSetupBttns(HWND);
void writeFilePrompt(HFILE,LPSTR);
void writeLogLvl(HFILE,int);



/*----------------------------------------------------------------------------
This funtion creates and sets the logfile name to the specified string.
----------------------------------------------------------------------------*/
void SetLogfileName
(
    LPSTR   lpszName
)
{
    HFILE hFile;
    char  szTmpStr[BUFFER_LENGTH+EXTRA_BUFFER];

//    hFile = OpenFile(lpszName,&ofGlobRec,OF_PARSE);
//    if (gwTSFileMode == LOG_OVERWRITE)
//        hFile = OpenFile(lpszName,&ofGlobRec,OF_CREATE | OF_EXIST);
//    else
//        hFile = OpenFile(lpszName,&ofGlobRec,OF_READWRITE | OF_EXIST);

    hFile = OpenFile(lpszName,&ofGlobRec,OF_EXIST);

    if(HFILE_ERROR == hFile)
    {
        //
        //  Hmm... File does not exist.
        //  Let's try to create (shouldn't hurt anything...)
        //

        hFile = OpenFile(lpszName,&ofGlobRec,OF_CREATE|OF_EXIST);

        if(HFILE_ERROR != hFile)
        {
            //
            //  No Error!  ...we created a garbage file.  Let's clean up.
            //  We were able to create it, we should be able to delete it.
            //

            OpenFile(lpszName,&ofGlobRec,OF_DELETE);
        }
    }
    else
    {
        //
        //  Hmm... File _does_ exist.
        //  Let's try to open it for r/w.
        //

        hFile = OpenFile(lpszName,&ofGlobRec,OF_READWRITE|OF_EXIST);
    }

    if (hFile == HFILE_ERROR)
    {
        wsprintf (szTmpStr, "Could not open %s", lpszName);
        MessageBox (ghwndTSMain, szTmpStr, szTSTestName, MB_ICONEXCLAMATION | MB_OK);
    }
    else
    {
        lstrcpy (szTSLogfile, lpszName);
        if (hwndEditLogFile)
        {
            SendMessage (hwndEditLogFile, WM_SETTEXT, 0, (LPARAM) (LPCSTR) szTSLogfile);
        }
        ghTSLogfile = 0;
    }
} /* end of SetLogfileName */


/*----------------------------------------------------------------------------
This function logs the test case status information.
----------------------------------------------------------------------------*/
void logCaseStatus
(
    int     iResult,
    int     iCaseNum,
    UINT    wStrID,
    UINT    wGroupId
)
{
    char  szOut[BUFFER_LENGTH];
    int   iWritten;
    LPTS_STAT_STRUCT  lpNode;

    lpNode = tsUpdateGrpNodes(tsPrStatHdr,iResult,(UINT)SUMMARY_STAT_GROUP);

    lpNode = tsUpdateGrpNodes(tsPrStatHdr,iResult,wGroupId);

    switch (iResult) {
        case TST_ABORT:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("ABRT"));
            break;
        case TST_PASS:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("PASS"));
            break;
        case TST_FAIL:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("FAIL"));
            break;
        case TST_TRAN:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("TRAN"));
            break;
        case TST_TERR:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("TERR"));
            break;
        case TST_TNYI:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("TNYI"));
            break;
        case TST_STOP:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("STOP"));
            break;
        default:
            iWritten = wsprintf (szOut,"Case %d: %s:", iCaseNum,
                                 (LPSTR)("OTHR"));
            break;
    }
    //
    // append ? to the case status string
    //
    tstLoadString (ghTSInstApp, wStrID,
                szOut + iWritten, sizeof(szOut) - iWritten);
    Log(szOut, TERSE);

} /* end of logCaseStatus */


/*----------------------------------------------------------------------------
This function logs the current date, time, and build.
----------------------------------------------------------------------------*/
void logDateTimeBuild
(
    LPSTR   lpstrPrompt
)
{
    time_t tTime;
    char  szTime[80];

    time(&tTime);
    lstrcpy (szTime,ctime(&tTime));
    szTime [lstrlen(szTime) - 1] = (char) 0;    // Gets rid of the '\n'
    tstLog(TERSE,lpstrPrompt);
    tstLog(TERSE,szTime);

    tstLogFlush();
} /* end of logDateTimeBuild */


/*----------------------------------------------------------------------------
This function logs the specified string if the specified level is high
enough compared to the set logging levels.
----------------------------------------------------------------------------*/
void Log
(
    LPSTR   lpszOutput,
    UINT    wThisLevel
)
{
    LPSTR   pszRaw;
    int     i,j,k;
    char    ach[2*MAXERRORLENGTH];

    //
    //  Note: copying string backwards.
    //

    i        = lstrlen(lpszOutput);
    j        = sizeof(ach) - 1;
    ach[j--] = 0;
    ach[j--] = '\n';
    ach[j--] = '\r';

    for(;i;i--,j--)
    {
        if('\n' == lpszOutput[i-1])
        {
            //
            //  Hit '\n'.  Doing indentation for next line.
            //

            for(k = giTSIndenting * NUM_SPACES_INDENT;k;k--,j--)
            {
                ach[j] = ' ';
            }

            //
            //  Turning '\n' to "\r\n".
            //

            ach[j--] = '\n';
            ach[j]   = '\r';

            //
            //  If it already had a '\r' ignore it.
            //

            if((i > 1) && ('\r' == lpszOutput[i-2]))
            {
                i--;
            }

            continue;
        }

        //
        //  Just copy character over.
        //

        ach[j] = lpszOutput[i-1];
    }

    //
    //  Indenting for first line.
    //

    for(k = giTSIndenting * NUM_SPACES_INDENT;k;k--,j--)
    {
        ach[j] = ' ';
    }

    pszRaw = (LPSTR)(&ach[j+1]);

    //
    //  Logging to file.
    //

    if ((ghTSLogfile != TST_NOLOGFILE) && (wThisLevel <= gwTSFileLogLevel))
    {
        ghTSLogfile = OpenFile(szTSLogfile,&ofGlobRec,OF_READWRITE);

        if (HFILE_ERROR != ghTSLogfile)
        {
            _llseek(ghTSLogfile,0L,2);
            _lwrite(ghTSLogfile,pszRaw,lstrlen(pszRaw));

#ifdef  HCT
            HctRawLog(pszRaw);
#endif  // HCT

            _lclose(ghTSLogfile);
        }

        ghTSLogfile = FALSE;
    }

    //
    //  Logging to window.
    //

    if ((gwTSLogLevel != LOG_NOLOG) && (wThisLevel <= gwTSLogLevel))
    {
        if(LOG_WINDOW == gwTSLogOut)
        {
            //
            //  Logging to Window.  Note: Chunking off the \r\n from
            //  end of string.
            //

            ach[sizeof(ach) - 3] = 0;

            TextOutputString(ghTSWndLog,pszRaw);
        }
        else
        {
            //
            //  Note: File Handle 3 is stdaux... COM1
            //

            _lwrite((3),pszRaw,lstrlen(pszRaw));
        }

//        LPSTR   pszMiddle;
//
//        //
//        //  Turning "\r\n" to "\n\0".
//        //
//
//        while(0 != *pszRaw)
//        {
//            pszMiddle = pszRaw;
//
//            while('\r' != *pszMiddle)
//            {
//                pszMiddle++;
//            }
//
//            pszMiddle[0] = '\n';
//            pszMiddle[1] = 0;
//
//            wpfOut(ghTSWndLog,pszRaw);
//
//            //
//            //  Adding 1 for '\n' and 1 for '\0'.
//            //
//
//            pszRaw = pszMiddle + 2;
//        }
    }
} /* end of log */




/*----------------------------------------------------------------------------
This function sets the logging file mode buttons that correspond to the
set logging file mode.
----------------------------------------------------------------------------*/
void setFileModeBttns
(
    HWND    hdlg
)
{
    switch (gwTSFileMode) {
        case LOG_OVERWRITE:
            CheckRadioButton(hdlg,TSLOG_OVERWRITE,TSLOG_APPEND,
                             TSLOG_OVERWRITE);
            break;
        case LOG_APPEND:
            CheckRadioButton(hdlg,TSLOG_OVERWRITE,TSLOG_APPEND,
                             TSLOG_APPEND);
            break;
    }

} /* end of setFileModeBttns */


/*----------------------------------------------------------------------------
This function sets the file logging mode.
----------------------------------------------------------------------------*/
void setLogFileMode
(
    HWND    hdlg
)
{
    gwTSFileMode = (IsDlgButtonChecked(hdlg,TSLOG_APPEND) ?
                                      LOG_APPEND : LOG_OVERWRITE);
} /* end of setLogFileMode */


/*----------------------------------------------------------------------------
This function sets the destination of the logging output.
----------------------------------------------------------------------------*/
void setLogOutDest
(
    HWND    hdlg
)
{
    if (IsDlgButtonChecked(hdlg,TSLOG_WINDOW)) {
        gwTSLogOut = LOG_WINDOW;
    } else if (IsDlgButtonChecked(hdlg,TSLOG_COM1)) {
        gwTSLogOut = LOG_COM1;
    } else {
        gwTSLogOut = LOG_NOLOG;
    }
} /* end of setLogOutDest */


/*----------------------------------------------------------------------------
This function sets the logging level.
----------------------------------------------------------------------------*/
void setLogOutLvl
(
    HWND    hdlg
)
{
    if (IsDlgButtonChecked(hdlg,TSLOG_OFF)) {
        gwTSLogLevel = LOG_NOLOG;
    //
        toolbarModifyState (hwndToolBar, BTN_WPFOFF, BTNST_DOWN);
    } else if (IsDlgButtonChecked(hdlg,TSLOG_TERSE)) {
        gwTSLogLevel = TERSE;
        toolbarModifyState (hwndToolBar, BTN_WPFTERSE, BTNST_DOWN);
    } else if (IsDlgButtonChecked(hdlg,TSLOG_VERBOSE)) {
        gwTSLogLevel = VERBOSE;
      toolbarModifyState (hwndToolBar, BTN_WPFVERBOSE, BTNST_DOWN);
    }
} /* end of setLogLvl */


/*----------------------------------------------------------------------------
This function sets the logging level for the logfile.
----------------------------------------------------------------------------*/
void setLogFileLvl
(
    HWND    hdlg
)
{
    if (IsDlgButtonChecked(hdlg,TSLOG_FOFF)) {
        gwTSFileLogLevel = LOG_NOLOG;
        toolbarModifyState (hwndToolBar, BTN_FILEOFF, BTNST_DOWN);
    } else if (IsDlgButtonChecked(hdlg,TSLOG_FTERSE)) {
        gwTSFileLogLevel = TERSE;
      toolbarModifyState (hwndToolBar, BTN_FILETERSE, BTNST_DOWN);
    } else if (IsDlgButtonChecked(hdlg,TSLOG_FVERBOSE)) {
        gwTSFileLogLevel = VERBOSE;
      toolbarModifyState (hwndToolBar, BTN_FILEVERBOSE, BTNST_DOWN);
    }
} /* end of setLogFileLvl */



/*----------------------------------------------------------------------------
This function sets the logging buttons for the logging dialog box based
on the global values.
----------------------------------------------------------------------------*/
void setLogBttns
(
    HWND    hdlg
)
{
    switch (gwTSLogLevel)
    {
        case LOG_NOLOG:
             CheckRadioButton(hdlg,TSLOG_OFF,TSLOG_VERBOSE,TSLOG_OFF);
             break;
        case TERSE:
             CheckRadioButton(hdlg,TSLOG_OFF,TSLOG_VERBOSE,TSLOG_TERSE);
             break;
        case VERBOSE:
             CheckRadioButton(hdlg,TSLOG_OFF,TSLOG_VERBOSE,TSLOG_VERBOSE);
             break;
    }

    switch (gwTSFileLogLevel)
    {
        case LOG_NOLOG:
             CheckRadioButton(hdlg,TSLOG_FOFF,TSLOG_FVERBOSE,TSLOG_FOFF);
             break;
        case TERSE:
             CheckRadioButton(hdlg,TSLOG_FOFF,TSLOG_FVERBOSE,TSLOG_FTERSE);
             break;
        case VERBOSE:
             CheckRadioButton(hdlg,TSLOG_FOFF,TSLOG_FVERBOSE,TSLOG_FVERBOSE);
             break;
    }

    switch (gwTSLogOut)
    {
        case LOG_WINDOW:
            SetFocus(GetDlgItem(hdlg,TSLOG_WINDOW));
            break;
        case LOG_COM1:
            SetFocus(GetDlgItem(hdlg,TSLOG_COM1));
            break;
    }


} /* end of setLogBttns */




/*----------------------------------------------------------------------------
This function handles the dialog box that sets the logging levels.
----------------------------------------------------------------------------*/
int EXPORT FAR PASCAL LoggingDlgProc
(
    HWND    hdlg,
    UINT    msg,
    UINT    wParam,
    LONG    lParam
)
{
    char  szTSLogfileTemp[BUFFER_LENGTH],FileTitle[255];
    UINT  wNotifyCode;
    UINT  wID;
    HWND  hwndCtl;
    OPENFILENAME of;



    switch (msg)
    {
        case WM_INITDIALOG:
            setFileModeBttns(hdlg);
            SetDlgItemText(hdlg, TS_LOGFILE, szTSLogfile);
            setLogBttns(hdlg);
            SetFocus (GetDlgItem (hdlg, TS_LOGFILE));
            break;

        case WM_COMMAND:
            wNotifyCode=GET_WM_COMMAND_CMD(wParam,lParam);
            wID=GET_WM_COMMAND_ID(wParam,lParam);
            hwndCtl=GET_WM_COMMAND_HWND(wParam,lParam);
            switch (wID)
            {
                case TSLOG_WINDOW:
                case TSLOG_COM1:
                    CheckRadioButton(hdlg,TSLOG_WINDOW,TSLOG_COM1,wID);
                    break;
                case TSLOG_OFF:
                case TSLOG_TERSE:
                case TSLOG_VERBOSE:
                    CheckRadioButton(hdlg,TSLOG_OFF,TSLOG_VERBOSE,wID);
                    break;
                case TSLOG_FOFF:
                case TSLOG_FTERSE:
                case TSLOG_FVERBOSE:
                    CheckRadioButton(hdlg,TSLOG_FOFF,TSLOG_FVERBOSE,wID);
                    break;
                case TSLOG_OVERWRITE:
                case TSLOG_APPEND:
                    CheckRadioButton(hdlg,TSLOG_OVERWRITE,TSLOG_APPEND,wID);
                    break;
                case TS_FILEHELP:
                    lstrcpy(szTSLogfileTemp,"*.log");
                    of.lStructSize	=sizeof(OPENFILENAME);
                    of.hwndOwner	=ghwndTSMain;
                    of.hInstance	=ghTSInstApp;
                    of.lpstrFilter	="Log Filed (*.log)\0*.log\0All Files (*.*)\0*.*\0";
                    of.lpstrCustomFilter=NULL;
                    of.nMaxCustFilter=0;
                    of.nFilterIndex	=1;
                    of.lpstrFile	=szTSLogfileTemp;
                    of.nMaxFile	=255;
                    of.lpstrFileTitle=FileTitle;
                    of.nMaxFileTitle=255;
                    of.lpstrInitialDir=".";
                    of.lpstrTitle	="Log File";
                    of.Flags	=0;
                    of.lpstrDefExt	="log";
                    of.lpfnHook	=NULL;

                    if (GetOpenFileName(&of)) {
                        SetDlgItemText(hdlg, TS_LOGFILE, szTSLogfileTemp);
                    }
                    SetFocus(GetDlgItem(hdlg,TS_LOGFILE));
                    break;
                case TSLOG_OK:
                    setLogOutDest(hdlg);
                    setLogOutLvl(hdlg);
                    setLogFileLvl(hdlg);
                    setLogFileMode(hdlg);
                    if (GetDlgItemText(hdlg,
                        TS_LOGFILE,
                        szTSLogfileTemp,
                        sizeof(szTSLogfileTemp)))
                    {
                        SetLogfileName(szTSLogfileTemp);
                    }
                    EndDialog (hdlg, TRUE);
                    return TRUE;
                    break;
                case TSLOG_CANCEL:
                    EndDialog (hdlg, FALSE);
                    return TRUE;
            }
            break;

    }
    return FALSE;
} /* end of LoggingDlgProc */

/*----------------------------------------------------------------------------
This function invokes the dialog box that allows the setting of logging
levels.
----------------------------------------------------------------------------*/
void Logging
(
    void
)
{
    FARPROC         fpfn;
    
    fpfn = MakeProcInstance((FARPROC)LoggingDlgProc,ghTSInstApp);

    DialogBox (ghTSInstApp, "logging", ghwndTSMain,(DLGPROC)fpfn);

    FreeProcInstance(fpfn);
} /* end of Logging */


/*
@doc INTERNAL TESTBED
@api BOOL | tstLogFlush | flushes the logging ring buffer

@rdesc TRUE if the logging buffer was flushed

@comm the first time this function is called, it creates the logging
      ring buffer.   If it fails to allocate memory at this time
      the function returns FALSE.  at all other times the function
      returns TRUE

      this function is intended to be called at the beginning
      and end of each test case
*/

#define RING_LIMIT    1000
#define RING_ELM_SIZE 10

#define TSLOG_FORMATMASK   0xF000
#define TSLOG_FORMATPRINTF 0x0000
#define TSLOG_FORMATFN     0x1000

// this structure contains global variables used by
// tstLog and tstLogFlush do fast,deferred logging
//
static TST_LOGRING tl = {FALSE, RING_ELM_SIZE -2 };

LPTST_LOGRING GetLogRingAddress
(
    void
)
{
    return ((LPTST_LOGRING)(&tl));
}

BOOL tstLogFlush ()
{
    // update the log level that tstLog uses to quickly skip
    // log events that will never be written. we set it to
    // the higher of either the file log level or the screen
    // log level.
    //
    // we do this here just because it is a convenient place.
    // we expect that tstLogFlush will be called at the
    // beginning and end of each test case.
    //
    tl.nCompositeLogLevel = max (gwTSLogLevel, gwTSFileLogLevel);

#if defined(WIN32) && !defined(_ALPHA_)
    // if we have not yet allocated a ring buffer, do that now
    //
    if ( ! tl.lpdwRingBase)
    {
        tl.lpdwRingBase = GlobalAllocPtr (GPTR, sizeof(DWORD) * RING_ELM_SIZE * RING_LIMIT);
        if ( ! tl.lpdwRingBase)
        {
            tl.bFastLogging = FALSE;
            return FALSE;
        }

        tl.lpdwRingNext = tl.lpdwRingBase;
        tl.lpdwRingLimit = tl.lpdwRingBase + RING_ELM_SIZE * RING_LIMIT;
        tl.cdwRing = RING_ELM_SIZE * RING_LIMIT;
        InitializeCriticalSection (&tl.cs);
        InitializeCriticalSection (&tl.csId);
        InitializeCriticalSection (&tl.csFlush);
    }
    //
    // we already have a ring buffer, so here we will be flushing it.
    //
    else
    {
        char    sz[2*MAXERRORLENGTH];
        char    szFormat[2*MAXERRORLENGTH];
        LPDWORD lpdw;
        UINT    iIndent;

/**** Added by t-rajr for thread support *****/
/* The old flush code is now in the else part*/

        DWORD   dwCurThreadId;

        //
        // This is needed to synchronize use of dwCurThreadId
        //

        EnterCriticalSection(&tl.csId);

        //
        // Get the current thread ID
        //

        dwCurThreadId = GetCurrentThreadId();

        //
        // If this thread is not the Main thread
        // post a message to the main thread
        //

        if(dwCurThreadId != gdwMainThreadId)
        {

            LeaveCriticalSection(&tl.csId);

            //
            //  Only ONE thread should be waiting for
            //  the main thread to do tstLogFlush
            //

            EnterCriticalSection (&tl.cs);

            //
            //  This event is signalled by the main thread
            //  when it handles message WM_USER+45  
            //

            ResetEvent(ghFlushEvent);

            PostMessage(ghwndTSMain, TSTMSG_TSTLOGFLUSH, 0, 0L);

            // WAIT FOR MAIN TO RETURN from tstLogFlush
            WaitForSingleObject(ghFlushEvent, 5000);

            LeaveCriticalSection (&tl.cs);
        }
        else
        {
            LeaveCriticalSection(&tl.csId);

            //
            // The following flush code is executed ONLY by
            // the main thread. We DONT need a critical section
            // here because the if(dwCurThreadId != gdwMainThreadId) check
            // above guarantees that the following code will be executed
            // only by the main thread. BUT just to be paranoid...
            //

            EnterCriticalSection(&tl.csFlush);

            // save current indent level, we will need to muck
            // with this while interpreting the ring buffer.
            //
            iIndent = giTSIndenting;
        
            // turn off redraw on the testlog window until
            // we have added ALL of the lines that we will
            // be adding.
            //
            SetWindowRedraw (ghTSWndLog, FALSE);
        
            __try
            {
                // walk the ring buffer and convert the saved information
                // to ASCII and the print/file it
                //
                for (lpdw = tl.lpdwRingBase; lpdw < tl.lpdwRingNext; lpdw += RING_ELM_SIZE)
                {
                    UINT   iLogLevel = ((LPWORD)lpdw)[1] & ~TSLOG_FORMATMASK;
                    UINT   iFmtType  = ((LPWORD)lpdw)[1] & TSLOG_FORMATMASK;
                    LPVOID lpFormat = (LPVOID)lpdw[1];
                    struct {
                        DWORD dw[RING_ELM_SIZE -2];
                        } * pArgs = (LPVOID)&lpdw[2];
        
                    __try
                    {
                        switch (iFmtType)
                        {
                            case TSLOG_FORMATPRINTF:
                                if ( ! HIWORD (lpFormat))
                                {
                                    LoadString (ghTSInstApp, LOWORD(lpFormat), szFormat, sizeof(szFormat));
                                    lpFormat = szFormat;
                                }
                                wvsprintf (sz, lpFormat, (LPVOID)pArgs);
                                break;
        
                            case TSLOG_FORMATFN:
                                {
                                UINT (_cdecl FAR * pfnFormat)(LPSTR lpsz, ...) = lpFormat;
                                pfnFormat (sz, *pArgs);
                                }
                                break;
        
                            default:
                                lstrcpy (sz, "tstLog buffer is corrupted!");
                                break;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        lstrcpy (sz,"BAD ARGS TO tstLog()");
                    }
        
                    // turn redraw back on for the last line in
                    // the buffer.
                    //
                    if (lpdw + RING_ELM_SIZE >= tl.lpdwRingNext)
                        SetWindowRedraw (ghTSWndLog, TRUE);
        
                    giTSIndenting = ((LPWORD)lpdw)[0];
                    Log (sz, iLogLevel);
                }
            }
            __finally
            {
                // put global indent flag back and empty the ring buffer
                //
                giTSIndenting = iIndent;
                tl.lpdwRingNext = tl.lpdwRingBase;
        
                // just to be careful...
                //
                SetWindowRedraw (ghTSWndLog, TRUE);
            }
        
            // turn redraw back on for the tstlog window and
            // scroll down by 3fff (a large number) lines
            // so that we are displaying the last lines output
            //

            LeaveCriticalSection(&tl.csFlush);

        }
    }
#endif

    return TRUE;
}


///*
//@doc INTERNAL TESTBED
//@api BOOL | tstLogEnableFastLogging | Enables or disables fast logging mode
//
//@parm BOOL | bEnable | TRUE to enable fast logging, FALSE to disable it
//
//@rdesc the previous state of the bFastLogging flag
//
//@comm Called by the tested program
//*/
//
//BOOL tstLogEnableFastLogging
//(
//    BOOL bEnable
//)
//{
//    BOOL bRet;
//
//    if ( ! bEnable)
//       tstLogFlush ();
//
//    bRet = tl.bFastLogging;
//    tl.bFastLogging = bEnable;
//
//    return bRet;
//}


/*
@doc INTERNAL TESTBED
@api BOOL _cdecl | tstLog | Sends a string to the current logging devices

@parm int | nLogLevel | The logging level of the string

@parm LPSTR | lpszFormat | Formmating information for the string.

@parm LPSTR | ... | The remaining parameters as used by wsprintf

@rdesc TRUE if the string was successfully logged

@comm Called by the tested program
*/

BOOL _cdecl tstLog
(
    UINT    iLogLevel,
    LPSTR   lpszFormat,
    ...
)
{
    va_list va;

#ifdef WIN32

    //
    // Only one thread should execute the following part
    // Added by t-rajr. NOTE: Before any return there is
    // a call to LeaveCriticalSection
    //

    EnterCriticalSection(&gCSLog);

#endif

    // dont even bother to format the log info if we are never going
    // to write it anywhere
    //
    if ((iLogLevel & 0xFF) > tl.nCompositeLogLevel)
    {

#ifdef WIN32
        LeaveCriticalSection(&gCSLog);
#endif

        return TRUE;
    }
        

    // note, we have chosen speed over code size here in the implementation
    // of tstLog.  remember this function is called A LOT, and the faster
    // it is, the less it throws off the timing
    //
#if defined(WIN32) && !defined(_ALPHA_)
    if (tl.bFastLogging)
    {
        LPDWORD lpdw;

        // increment lpdwRingNext in an interlocked fashion.  if
        // the result is not what we expected, someone else must
        // have been incrementing at the same time, so we loop
        // back to try again.
        //
        lpdw = tl.lpdwRingNext;
        while (lpdw >= tl.lpdwRingLimit ||
               lpdw != (LPDWORD)InterlockedExchange ((LPLONG)&tl.lpdwRingNext,
                                                     (LONG)(lpdw + RING_ELM_SIZE))
              )
        {
            // if we get to here, we have either failed to increment
            // lpdwRingNext or we have run off the end of the ring
            // buffer. (maybe because the buffer doesnt exist yet?).
            //
            // what we want to do now get lpdwRingNext again,
            // check to see if we are out of space and if so,
            // flush the ring buffer and loop back to try again.
            //
            lpdw = tl.lpdwRingNext;
            if (lpdw >= tl.lpdwRingLimit)
            {
                // if tstLogFlush fails, the only thing we can
                // do is return failure to the caller.
                //
                if (tstLogFlush ())
                {
                    #ifdef WIN32
                            LeaveCriticalSection(&gCSLog);
                    #endif

                    return FALSE;
                }
                    
                lpdw = tl.lpdwRingNext;
            }
        }

        // save enough information into the ring buffer so that
        // we can later do the wvsprintf & log calls
        //
        va_start (va, lpszFormat);

        ((LPWORD)lpdw)[0] = (WORD)giTSIndenting;
        ((LPWORD)lpdw)[1] = (WORD)((iLogLevel & 0xFF) | TSLOG_FORMATPRINTF);
        lpdw[1] = (DWORD)lpszFormat;
        // CopyMemory (&lpdw[2], va, sizeof(DWORD) * 6);
        memcpy (&lpdw[2], va, sizeof(DWORD) * 6);

        va_end (va);

        if (iLogLevel & FLUSH)
            tstLogFlush();
    }
    else
   #endif
    {
       #if defined(WIN32) && !defined(_ALPHA_)
        char  sz[2*MAXERRORLENGTH];
        char  szFormat[2*MAXERRORLENGTH];
       #else
        static char  sz[2*MAXERRORLENGTH];
        static char  szFormat[2*MAXERRORLENGTH];
       #endif
        LPSTR lpFormat;
        UINT  cb;

        // if the hiword of lpszFormat is not set, assume
        // that it is a string id
        //
        lpFormat = lpszFormat;
        if ( ! HIWORD (lpFormat))
        {
            LoadString (ghTSInstApp, LOWORD(lpFormat), szFormat, sizeof(szFormat));
            lpFormat = szFormat;
        }

        // do immediate, slow, logging
        //
        va_start (va, lpszFormat);
        cb = wvsprintf (sz, lpFormat, va);
        va_end (va);
        Log (sz, iLogLevel & 0xFF);

        #ifdef WIN32
                LeaveCriticalSection(&gCSLog);
        #endif

        return (cb != 0);
    }

    #ifdef WIN32
            LeaveCriticalSection(&gCSLog);
    #endif

    return TRUE;

}

/*
@doc INTERNAL TESTBED
@api BOOL _cdecl | tstLogFn | Sends a string to the current logging devices

@parm int | nLogLevel | The logging level of the string

@parm LPSTR | lpszFormat | Formmating information for the string.

@parm LPSTR | ... | The remaining parameters as used by wsprintf

@rdesc TRUE if the string was successfully logged

@comm Called by the tested program
*/

BOOL _cdecl tstLogFn
(
    UINT    iLogLevel,
    UINT (_cdecl FAR * pfnFormat)(LPSTR lpszOutBuffer, ...),
    ...
)
{
    va_list va;

    // dont even bother to format the log info if we are never going
    // to write it anywhere
    //
    if ((iLogLevel & 0xFF) > tl.nCompositeLogLevel)
        return TRUE;

#if defined(WIN32) && !defined(_ALPHA_)

    // note, we have chosen speed over code size here in the implementation
    // of tstLog.  remember this function is called A LOT, and the faster
    // it is, the less it throws off the timing
    //
    //
    if (tl.bFastLogging)
    {
        LPDWORD lpdw;

        // increment lpdwRingNext in an interlocked fashion.  if
        // the result is not what we expected, someone else must
        // have been incrementing at the same time, so we loop
        // back to try again.
        //
        lpdw = tl.lpdwRingNext;
        while (lpdw >= tl.lpdwRingLimit ||
               lpdw != (LPDWORD)InterlockedExchange ((LPLONG)&tl.lpdwRingNext,
                                                     (LONG)(lpdw + RING_ELM_SIZE))
              )
        {
            // if we get to here, we have either failed to increment
            // lpdwRingNext or we have run off the end of the ring
            // buffer. (maybe because the buffer doesnt exist yet?).
            //
            // what we want to do now get lpdwRingNext again,
            // check to see if we are out of space and if so,
            // flush the ring buffer and loop back to try again.
            //
            lpdw = tl.lpdwRingNext;
            if (lpdw >= tl.lpdwRingLimit)
            {
                // if tstLogFlush fails, the only thing we can
                // do is return failure to the caller.
                //
                if (tstLogFlush ())
                    return FALSE;
                lpdw = tl.lpdwRingNext;
            }
        }

        // save enough information into the ring buffer so that
        // we can later call the formatting functions
        //
        va_start (va, pfnFormat);

        ((LPWORD)lpdw)[0] = (WORD)giTSIndenting;
        ((LPWORD)lpdw)[1] = (WORD)((iLogLevel & 0xFF) | TSLOG_FORMATFN);
        lpdw[1] = (DWORD)pfnFormat;
        // CopyMemory (&lpdw[2], va, sizeof(DWORD) * 6);

        memcpy (&lpdw[2], va, sizeof(DWORD) * 6);

        if (iLogLevel & FLUSH)
            tstLogFlush();

        va_end (va);
    }
    else
#endif
    {
        char    sz[2*MAXERRORLENGTH];
        UINT    cb;
//        struct  {
//            UINT ui[RING_ELM_SIZE -2];
//            } * pArgs;

        // do immediate, slow, logging
        //
        va_start (va, pfnFormat);
//        pArgs = (void *)va;
        cb = pfnFormat (sz, va);
        va_end (va);
        Log (sz, iLogLevel & 0xFF);
        return (cb != 0);
    }

    return TRUE;

}

/*
@doc INTERNAL TESTBED
@api void | tstBeginSection | Tells the logging functions to increase the
    indent level by one

@parm LPSTR | lpszTitle | The test title which is logged (preceeded
    by the string "BEGIN SECTION".  May be NULL.

@rdesc The new indent nesting level

*/
void tstBeginSection
(
    LPSTR   lpszTitle
)
{
    if (lpszTitle != NULL)
    {
        tstLog (TERSE, lpszTitle);
    }

    ++giTSIndenting;

} /* end of tstBeginSection */

/*
@doc INTERNAL TESTBED
@api void | tstEndSection | Tells the logging functions to decrease the
    indent level by one

@rdesc The new indent nesting level

 @comm Logs the string "END SECTION"
*/
void tstEndSection
(
    void
)
{
    if (--giTSIndenting < 0)
        giTSIndenting = 0;

} /* end of tstEndSection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tsmain.c ===
/***************************************************************************\
*                                                                           *
*   File: Tsmain.c                                                          *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       The main code module for the test shell.                            *
*                                                                           *
*   Contents:                                                               *
*       tsAmInAuto()                                                        *
*       calcLogSize()                                                       *
*       recWMSIZEMessage()                                                  *
*       tstSetOptions()                                                     *
*       addToolbarTools()                                                   *
*       updateEditVariable()                                                *
*       NewEditProc()                                                       *
*       saveApplicationSettings()                                           *
*       editLogFile()                                                       *
*       tsStartWait()                                                       *
*       tsEndWait()                                                         *
*       tstWinYield()                                                       *
*       getTstIDListRes()                                                   *
*       getNumRunCases()                                                    *
*       displayTest()                                                       *
*       RunCases()                                                          *
*       getTSRandWord()                                                     *
*       RunRandomCases()                                                    *
*       statBarWndProc()                                                    *
*       PickFont()                                                          *
*       tstMainWndProc()                                                    *
*       removeWhiteSpace()                                                  *
*       getToken()                                                          *
*       ValidFileNameChar()                                                 *
*       ParseCmdLine()                                                      *
*       getIniStrings()                                                     *
*       setLogFileDefs()                                                    *
*       ParseNumber()                                                       *
*       RestoreFont()                                                       *
*       AppInit()                                                           *
*       tstInitHelpMenu()                                                   *
*       GetIniName()                                                        *
*       getDefaultProfile()                                                 *
*       WinMain()                                                           *
*       tstYesNoBox()                                                       *
*       tstInstallCustomTest()                                              *
*       tstCheckRunStop()                                                   *
*       FindProc()                                                          *
*       Find()                                                              *
*       AppAboutDlgProc()                                                   *
*       About()                                                             *
*       helpToolBar()                                                       *
*       restoreStatusBar()                                                  *
*       tstInstallDefWindowProc()                                           *
*       tstLogStatusBar()                                                   *
*       tstGetStatusBar()                                                   *
*       tstDisplayCurrentTest()                                             *
*       tstChangeStopVKey()                                                 *
*       tstGetProfileString()                                               *
*       tstWriteProfileString()                                             *
*       tstDummyFn()                                                        *
*       tstInstallReadCustomInfo()                                          *
*       tstInstallWriteCustomInfo()                                         *
*                                                                           *
*   History:                                                                *
*       11-20-92    Prestonb    Modified to conform to NTMMT coding specs   *
*                                                                           *
*       04-27-93    Prestonb    Nuked the prepending of the input path to   *
*                   the profile.  The input path is for test resources,     *
*                   not profiles.                                           *
*                                                                           *
*       07/14/93    T-OriG      Added functionality and this header         *
*       08/13/94    t-rajr      Added code to WinMain, tstMainWndProc for   *
*                               thread support.                             *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commdlg.h>
#include <memory.h>
// #include "mprt1632.h"
#include "support.h"
#include <gmem.h>
#include <defdlg.h>
//#include <ctype.h>

#include <stdlib.h>

#include "tsrunset.h"
#include "tsseltst.h"
#include "tsstep.h"
#include "tslog.h"
#include "tsglobal.h"
#include "tsdlg.h"
#include "tsstats.h"
#include "tssetpth.h"
#include "tsextern.h"
#include "text.h"
#include <mmtstver.h>
#include "toolbar.h"
#include "tsmain.h"

#ifdef  HCT
#include <hctlib.h>
#endif  // HCT

#define CUSTOM_MENU_START       2

#define MAX_CUSTOM_MENU_ITEMS   40
#define MAX_PATH_INDEX          3

#define DEFAULT_MAXLINES        500

#define TST_LOGWINDOW           500

//==========================================================================;
//
//                        Flags for fdwTstsHell.
//
//==========================================================================;

#define TSTSHELLFLAG_HANDLEEXCEPTION    0x00000001
#define TSTSHELLFLAG_SEARCHMATCHCASE    0x00000002

struct
{
    UINT               wID;
    DECLARE_TS_MENU_PTR(fpTest);
} CustomMenuItems[MAX_CUSTOM_MENU_ITEMS];


// The default window procedure
LRESULT (CALLBACK* tstDefWindowProc) (HWND, UINT, WPARAM, LPARAM);

// Custom profile info read/write fns & default handler (empty) -- AlokC (06/30/94)
VOID CALLBACK tstDummyFn(LPCSTR) ;   // default dummy handler fn.

// Getting address of static in tslog.c
LPTST_LOGRING GetLogRingAddress(void);

UINT        wNextCustomMenuItem = 0;

int         giTSCasesRes;

char        szTSTestName[BUFFER_LENGTH];
char        szAppClass[BUFFER_LENGTH];
char        szTSPathSection[BUFFER_LENGTH]="TstShellPath";
char        szTSClass[] = "MainTestShell";
char        szProfileName[BUFFER_LENGTH];
char        szTstsHellIni[BUFFER_LENGTH];
char        szSearchString[BUFFER_LENGTH];
char        szTSDefProfKey[] = "DefaultProfileName";

HCURSOR     ghTSwaitCur;
int         giTSWait;

// Added by t-rajr
#ifdef WIN32
DWORD       gdwMainThreadId;
HANDLE      ghFlushEvent;
CRITICAL_SECTION gCSLog;
#endif

HINSTANCE   ghTSInstApp;
HWND        ghwndTSMain;
HWND        hwndToolBar;
HWND        hwndEditLogFile=NULL;
HWND        hwndStatusBar=NULL;
HMENU       ghTSMainMenu;
HMENU       ghSystemMenu;
HANDLE      hAccel;

BOOL        gbFileNamed;  // LoadCmdLine found a file name
BOOL        gbAllTestsPassed = TRUE;
BOOL        gbTestListExpanded = FALSE;
BOOL        gbGotWM_CLOSE = FALSE;

// Print Status Header
LPTS_STAT_STRUCT  tsPrStatHdr;

// Test case selection info
HWND    ghTSWndSelList;
HWND    ghTSWndAllList;

// Run setup info
TST_RUN_HDR  tstRunHdr;

int     giTSRunCount;
int     gwTSStepMode;
int     gwTSRandomMode;

// Logging info
OFSTRUCT    ofGlobRec;

int     giTSIndenting;
HWND    ghTSWndLog;

BOOL    gbTSAuto = FALSE;

UINT    gwTSLogOut;
UINT    gwTSLogLevel;
UINT    gwTSFileLogLevel;
UINT    gwTSFileMode;
UINT    gwTSVerification;
UINT    gwTSScreenSaver;

BOOL    fShowStatusBar = TRUE;
BOOL    fShowToolBar = TRUE;
BOOL    fDisplayCurrentTest;

int     iStopVKey = VK_ESCAPE;

char    szTSLogfile[BUFFER_LENGTH];
HFILE   ghTSLogfile;

// Profile info
char    szTSProfile[BUFFER_LENGTH];

char    szInPath [BUFFER_LENGTH];
char    szOutPath [BUFFER_LENGTH];

char    szTSInPathKey[]= "InPath";
char    szTSOutPathKey[] = "OutPath";

WORD    wPlatform;

WNDPROC lpfnOldEditProc;

char    szTstShell[] = "Test Shell";
char    szStatusBarClass[] = "StatusBarClass";
char    szStatusText[BUFFER_LENGTH];
char    lpszPrevContent [BUFFER_LENGTH];

// Exception handling disabled.
DWORD   fdwTstsHell = 0x00000000;

// Internal Functions

HANDLE  getTstIDListRes(void);
int     getNumRunCases(void);
void    RunCases(void);
void    RunRandomCases(void);
LRESULT EXPORT FAR PASCAL tstMainWndProc(HWND,UINT,UINT,LONG);
BOOL    AppInit(HANDLE,HANDLE,UINT,LPSTR);
int     Find(void);
void    About (void);
BOOL EXPORT FAR PASCAL AppAboutDlgProc(HWND hDlg, unsigned uiMessage, UINT wParam,long lParam);
void    getIniStrings();
void    setLogFileDefs(void);
void    PrintRunList (void);
void    addToolbarTools (void);

/***************************************************************************\
*                                                                           *
*   int tsAmInAuto                                                          *
*                                                                           *
*   Description:                                                            *
*       Tells whether testing is manual or automatic.                       *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (int):                                                           *
*                                                                           *
*   History:                                                                *
*       07/19/93    T-OriG  Added this header.                              *
*                                                                           *
\***************************************************************************/

int tsAmInAuto
(
    void
)
{
    return (gbTSAuto || gwTSVerification);
}



/***************************************************************************\
*                                                                           *
*   void calcLogSize                                                        *
*                                                                           *
*   Description:                                                            *
*       Calculates the size of the logging window                           *
*                                                                           *
*   Arguments:                                                              *
*       LPRECT rect:                                                        *
*                                                                           *
*   Return (int):  The height of a letter                                   *
*                                                                           *
*   History:                                                                *
*       07/09/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

int calcLogSize (LPRECT rect)
{
    HDC hDC;
    RECT r;
    TEXTMETRIC tm;

    hDC = GetDC (ghwndTSMain);
    GetTextMetrics (hDC, (LPTEXTMETRIC) &tm);
    ReleaseDC (ghwndTSMain, hDC);

    GetClientRect (ghwndTSMain, (LPRECT) &r);
    rect->left = 0;
    rect->right = r.right;

    if (fShowToolBar)
    {
    rect->top = tm.tmHeight + 16;
    }
    else
    {
    rect->top = 0;
    }

    if (fShowStatusBar)
    {
    rect->bottom = r.bottom - tm.tmHeight-4;
    }
    else
    {
    rect->bottom = r.bottom;
    }
    return (tm.tmHeight);
}




/***************************************************************************\
*                                                                           *
*   void recWMSIZEMessage                                                   *
*                                                                           *
*   Description:                                                            *
*       This function handles the WM_SIZE message.                          *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/09/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void recWMSIZEMessage(void)
{
    RECT rect;
    int tmHeight;
    InvalidateRect (ghwndTSMain, NULL, TRUE);
    tmHeight = calcLogSize((LPRECT)&rect);

    if (ghTSWndLog)
    {
    MoveWindow(ghTSWndLog,rect.left,rect.top,rect.right,rect.bottom-rect.top,TRUE);
    }
    if (hwndToolBar)
    {
    InvalidateRect (hwndToolBar, NULL, TRUE);
    MoveWindow(hwndToolBar, 0, 0, rect.right, rect.top - 2, TRUE);
    }
    if (hwndStatusBar)
    {
    MoveWindow(hwndStatusBar, rect.left, rect.bottom + 2, rect.right, tmHeight+2, TRUE);
    InvalidateRect (hwndStatusBar, NULL, TRUE);
    }

    UpdateWindow (ghwndTSMain);
    return;
}


/***************************************************************************\
*                                                                           *
*   DWORD tstSetOptions                                                     *
*                                                                           *
*   Description:                                                            *
*       Sets different options for tstshell.                                *
*                                                                           *
*   Arguments:                                                              *
*       UINT uType:  Type of option to modify.                              *
*                                                                           *
*       DWORD dwValue:  Value to change to (Type dependent).                *
*                                                                           *
*   Return (DWORD):                                                         *
*       Old value.                                                          *
*                                                                           *
*   History:                                                                *
*       08/04/94    Fwong       Breaking people forwards and backwards.     *
*       11/28/94    Fwong       Adding option to set log buffer limit.      *
*                                                                           *
\***************************************************************************/

DWORD tstSetOptions
(
    UINT    uType,
    DWORD   dwValue
)
{
    DWORD           dwRet;
    LPTST_LOGRING   ptl;

    switch (uType)
    {
        case TST_ENABLEFASTLOGGING:
            ptl = GetLogRingAddress();

            dwRet = (DWORD)((ptl->bFastLogging)?1:0);

            if(0 == dwValue)
            {
                tstLogFlush();
                ptl->bFastLogging = FALSE;
            }
            else
            {
                ptl->bFastLogging = TRUE;
            }

            break;

        case TST_ENABLEEXCEPTIONHANDLING:
            dwRet = (DWORD)((fdwTstsHell & TSTSHELLFLAG_HANDLEEXCEPTION)?1:0);

            if(0 != dwValue)
            {
                fdwTstsHell |= TSTSHELLFLAG_HANDLEEXCEPTION;
            }
            else
            {
                fdwTstsHell &= (~TSTSHELLFLAG_HANDLEEXCEPTION);
            }

            break;

        case TST_SETLOGBUFFERLIMIT:
            dwRet = Text_GetBufferLimit(ghTSWndLog);

            Text_SetBufferLimit(ghTSWndLog,dwValue,SETSIZEFLAG_TRUNCATE);

            break;
    }

    return dwRet;
}


/***************************************************************************\
*                                                                           *
*   void addToolbarTools                                                    *
*                                                                           *
*   Description:                                                            *
*       Adds all the tools to the toolbar                                   *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/25/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void addToolbarTools
(
    void
)
{
    TOOLBUTTON  tb;

    // Common to all tools
    tb.rc.top  = 3;  tb.rc.bottom = 25;
    tb.iState  = BTNST_UP;
    tb.iString = 0;

    //
    // Some Push Buttons:
    //
    tb.iType   = BTNTYPE_PUSH;

    // Open
    tb.rc.left  = TOOLBEGIN + 0*TOOLLENGTH + 0*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 1*TOOLLENGTH + 0*TOOLSPACE;
    tb.iButton  = BTN_OPEN;
    toolbarAddTool (hwndToolBar, tb);

    // Save
    tb.rc.left  = TOOLBEGIN + 1*TOOLLENGTH + 0*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 2*TOOLLENGTH + 0*TOOLSPACE;
    tb.iButton  = BTN_SAVE;
    toolbarAddTool (hwndToolBar, tb);

    // Run
    tb.rc.left  = TOOLBEGIN + 2*TOOLLENGTH + 1*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 3*TOOLLENGTH + 1*TOOLSPACE;
    tb.iButton  = BTN_RUN;
    toolbarAddTool (hwndToolBar, tb);

    // Run Minimized
    tb.rc.left  = TOOLBEGIN + 3*TOOLLENGTH + 1*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 4*TOOLLENGTH + 1*TOOLSPACE;
    tb.iButton  = BTN_RUNMIN;
    toolbarAddTool (hwndToolBar, tb);

    // Run All Tests
    tb.rc.left  = TOOLBEGIN + 4*TOOLLENGTH + 1*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 5*TOOLLENGTH + 1*TOOLSPACE;
    tb.iButton = BTN_RUNALL;
    toolbarAddTool (hwndToolBar, tb);

    // Edit
    tb.rc.left  = TOOLBEGIN + 5*TOOLLENGTH + 2*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 6*TOOLLENGTH + 2*TOOLSPACE;
    tb.iButton  = BTN_EDIT;
    toolbarAddTool (hwndToolBar, tb);

    // Clear
    tb.rc.left  = TOOLBEGIN + 6*TOOLLENGTH + 2*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 7*TOOLLENGTH + 2*TOOLSPACE;
    tb.iButton  = BTN_CLEAR;
    toolbarAddTool (hwndToolBar, tb);

    // Select
    tb.rc.left  = TOOLBEGIN + 7*TOOLLENGTH + 3*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 8*TOOLLENGTH + 3*TOOLSPACE;
    tb.iButton  = BTN_SELECT;
    toolbarAddTool (hwndToolBar, tb);

    // Set Logging
    tb.rc.left  = TOOLBEGIN + 8*TOOLLENGTH + 3*TOOLSPACE;
    tb.rc.right = TOOLBEGIN + 9*TOOLLENGTH + 3*TOOLSPACE;
    tb.iButton  = BTN_SETLOGGING;
    toolbarAddTool (hwndToolBar, tb);

    //
    // Now some radio buttons:
    //
    tb.iType   = BTNTYPE_RADIO;

    // File logging = OFF
    tb.rc.left  = EDITEND + TOOLSPACE;
    tb.rc.right = EDITEND + TOOLSPACE + TOOLLENGTH;
    tb.iButton  = BTN_FILEOFF;
    toolbarAddTool (hwndToolBar, tb);

    // File logging = TERSE
    tb.rc.left  = EDITEND + TOOLSPACE + TOOLLENGTH;
    tb.rc.right = EDITEND + TOOLSPACE + 2*TOOLLENGTH;
    tb.iButton  = BTN_FILETERSE;
    toolbarAddTool (hwndToolBar, tb);

    // File logging = VERBOSE
    tb.rc.left  = EDITEND + TOOLSPACE + 2*TOOLLENGTH;
    tb.rc.right = EDITEND + TOOLSPACE + 3*TOOLLENGTH;
    tb.iButton  = BTN_FILEVERBOSE;
    toolbarAddTool (hwndToolBar, tb);

    //
    // Some more radio buttons...
    tb.iType   = BTNTYPE_RADIO+1;

    // Wpf logging = OFF
    tb.rc.left  = EDITEND + TOOLSPACE + 3*TOOLLENGTH + LARGESPACE;
    tb.rc.right = EDITEND + TOOLSPACE + 4*TOOLLENGTH + LARGESPACE;
    tb.iButton  = BTN_WPFOFF;
    toolbarAddTool (hwndToolBar, tb);

    // Wpf logging = TERSE
    tb.rc.left  = EDITEND + TOOLSPACE + 4*TOOLLENGTH + LARGESPACE;
    tb.rc.right = EDITEND + TOOLSPACE + 5*TOOLLENGTH + LARGESPACE;
    tb.iButton  = BTN_WPFTERSE;
    toolbarAddTool (hwndToolBar, tb);

    // Wpf logging = VERBOSE
    tb.rc.left  = EDITEND + TOOLSPACE + 5*TOOLLENGTH + LARGESPACE;
    tb.rc.right = EDITEND + TOOLSPACE + 6*TOOLLENGTH + LARGESPACE;
    tb.iButton  = BTN_WPFVERBOSE;
    toolbarAddTool (hwndToolBar, tb);

    return;
}



/***************************************************************************\
*                                                                           *
*   void updateEditVariable                                                 *
*                                                                           *
*   Description:                                                            *
*       Changes the log file name in response to an ENTER keypress          *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/26/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void updateEditVariable
(
    void
)
{
    char szLogFile [BUFFER_LENGTH];
    SendMessage (hwndEditLogFile,
    WM_GETTEXT,
    BUFFER_LENGTH,
    (LONG) (LPSTR) szLogFile);
    SetLogfileName (szLogFile);

    // In case it's not a valid file name
    SendMessage (hwndEditLogFile,
    WM_SETTEXT,
    0,
    (LPARAM) (LPCSTR) szTSLogfile);
    return;
}




/***************************************************************************\
*                                                                           *
*   long NewEditProc                                                        *
*                                                                           *
*   Description:                                                            *
*       Subclassing of the windows procedure for the edit log file control  *
*                                                                           *
*   Arguments:                                                              *
*       HWND hwnd:                                                          *
*                                                                           *
*       UINT message:                                                       *
*                                                                           *
*       UINT wParam:                                                        *
*                                                                           *
*       LONG lParam:                                                        *
*                                                                           *
*   Return (long):                                                          *
*                                                                           *
*   History:                                                                *
*       07/26/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

long FAR PASCAL EXPORT NewEditProc
(
    HWND    hwnd,
    UINT    message,
    UINT    wParam,
    LONG    lParam
)
{
    switch (message)
    {
    case WM_KILLFOCUS:
        SendMessage (hwndEditLogFile,
        WM_SETTEXT,
        0,
        (LPARAM) (LPCSTR) szTSLogfile);
        break;

    case WM_CHAR:
        switch (wParam)
        {
        case VK_RETURN:
            updateEditVariable();
            SetFocus (ghwndTSMain);
            return TRUE;
        case VK_ESCAPE:
            SendMessage (hwndEditLogFile,
            WM_SETTEXT,
            0,
            (LPARAM) (LPCSTR) szTSLogfile);
            SetFocus (ghwndTSMain);
            return TRUE;
        }
        break;
    }

    return (CallWindowProc (lpfnOldEditProc,
    hwnd,
    message,
    wParam,
    lParam));
}




/***************************************************************************\
*                                                                           *
*   void saveApplicationSettings                                            *
*                                                                           *
*   Description:                                                            *
*       Saves the window's coordinates in win.ini                           *
*                                                                           *
*   Arguments:                                                              *
*       HWND hWnd: Handle to window.                                        *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/26/93    T-OriG                                                  *
*       11/23/94    Fwong       Corrected (Uses GetWindowPlacement now...)  *
*       11/23/94    Fwong       Explanded to include fonts.                 *
*                                                                           *
\***************************************************************************/

void saveApplicationSettings
(
    HWND    hWnd
)
{
    WINDOWPLACEMENT wndpl;
    LOGFONT         lf;
    HFONT           hFont;
    DWORD           dw1,dw2;
    char            szNum[BUFFER_LENGTH];

    //
    //  Saving Window Position...
    //

    wndpl.length = sizeof(WINDOWPLACEMENT);

    if(GetWindowPlacement(hWnd,&wndpl))
    {
        wndpl.rcNormalPosition.right  -= wndpl.rcNormalPosition.left;
        wndpl.rcNormalPosition.bottom -= wndpl.rcNormalPosition.top;

        wsprintf (szNum, "%i", (int) wndpl.rcNormalPosition.left);
        tstWriteProfileString("x",szNum);

        wsprintf (szNum, "%i", (int) wndpl.rcNormalPosition.right);
        tstWriteProfileString("xw",szNum);

        wsprintf (szNum, "%i", (int) wndpl.rcNormalPosition.top);
        tstWriteProfileString("y",szNum);

        wsprintf (szNum, "%i", (int) wndpl.rcNormalPosition.bottom);
        tstWriteProfileString("yw",szNum);
    }

    //
    //  Saving status bar state...
    //

    if (fShowStatusBar)
    {
        tstWriteProfileString("ShowStatusBar","Yes");
    }
    else
    {
        tstWriteProfileString("ShowStatusBar","No");
    }

    //
    //  Saving tool bar state...
    //

    if (fShowToolBar)
    {
        tstWriteProfileString("ShowToolBar","Yes");
    }
    else
    {
        tstWriteProfileString("ShowToolBar","No");
    }

    //
    //  Saving search string...
    //

    if(0 == lstrlen(szSearchString))
    {
        tstWriteProfileString("SearchString",NULL);
    }
    else
    {
        dw1 = (fdwTstsHell & TSTSHELLFLAG_SEARCHMATCHCASE)?1:0;
        wsprintf(szNum,"%lu,%s",dw1,(LPSTR)szSearchString);
        tstWriteProfileString("SearchString",szNum);
    }

    //
    //  Saving window font...
    //

    hFont = GetWindowFont(ghTSWndLog);

    if(GetObject(hFont,sizeof(LOGFONT),(LPLOGFONT)&lf))
    {
        tstWriteProfileString("FontName",(LPSTR)(&lf.lfFaceName[0]));

        dw1 = MAKELONG(
                ((lf.lfStrikeOut << 8) + lf.lfCharSet  ),
                ((lf.lfItalic    << 8) + lf.lfUnderline));

        dw2 = MAKELONG(
                ((lf.lfQuality      << 8) + lf.lfPitchAndFamily),
                ((lf.lfOutPrecision << 8) + lf.lfClipPrecision ));

        wsprintf(
            szNum,
            "%i %i %lu %lu",
            lf.lfHeight,
            lf.lfWeight,
            dw1,
            dw2);

        tstWriteProfileString("FontAttr",szNum);
    }

    //
    //  Note:  Assuming this is on a WM_CLOSE message...
    //

    SetWindowFont(ghTSWndLog,NULL,FALSE);
    DeleteObject(hFont);

    return;
} // saveApplicationSettings()





/***************************************************************************\
*                                                                           *
*   void editLogFile                                                        *
*                                                                           *
*   Description:                                                            *
*       Executes the log file (runs whatever is associated with its         *
*       extension.  This code is highly platform dependent...               *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/27/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void editLogFile
(
    void
)
{
    HMODULE     hShell;
    HINSTANCE   (FAR PASCAL *lpfn_ShellExecute)(HWND, LPCSTR, LPCSTR, LPCSTR, LPCSTR, int);
    HINSTANCE   hError;

#ifdef WIN32
    hShell = LoadLibrary ("shell32.dll");
#ifdef UNICODE
    (FARPROC) lpfn_ShellExecute = GetProcAddress (hShell, "ShellExecuteW");
#else
    (FARPROC) lpfn_ShellExecute = GetProcAddress (hShell, "ShellExecuteA");
#endif
    hError = lpfn_ShellExecute (ghwndTSMain, NULL, szTSLogfile, "", ".", SW_SHOWNORMAL);
    FreeLibrary (hShell);
#else
    hShell = GetModuleHandle ("shell.dll");
    (FARPROC) lpfn_ShellExecute = GetProcAddress (hShell, "ShellExecute");
    hError = lpfn_ShellExecute (ghwndTSMain, NULL, szTSLogfile, "", ".", SW_SHOWNORMAL);
#endif

    // Message box if nothing associated with .log
    if (hError == ((HINSTANCE) 31))
    {
    MessageBox (NULL,
        "You must associate an editor with your log file's extension before trying to edit it",
        "Error:  cannot edit log file",
        MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
    }
    return;
}








/*------------------------------------------------------------------------------
                 Yield functions
----------------------------------------------------------------------------*/

void tsStartWait
(
    void
)
{
    HMENU     hMenu;
    int       iCount,ii;

    if (giTSWait++ == 0)
    {
    hMenu = GetMenu(ghwndTSMain);
    iCount = (int)GetMenuItemCount(hMenu);
    for (ii = 0; ii < iCount; ii++)
    {
        EnableMenuItem(hMenu,ii,MF_GRAYED | MF_BYPOSITION);
    }
    SetCursor(ghTSwaitCur);
    EnableMenuItem (ghSystemMenu, MENU_RUN, MF_BYCOMMAND | MF_GRAYED);
    DrawMenuBar(ghwndTSMain);

    for (ii=0; ii<=BTN_LAST; ii++)
    {
        toolbarModifyState (hwndToolBar, ii, BTNST_GRAYED);
    }
    SendMessage (hwndEditLogFile, EM_SETREADONLY, TRUE, 0L);

    UpdateWindow (hwndToolBar);
    }
}


void tsEndWait
(
    void
)
{
    HMENU     hMenu;
    int       iCount,ii;

    if (--giTSWait == 0)
    {
    hMenu = GetMenu(ghwndTSMain);
    iCount = (int) GetMenuItemCount(hMenu);
    for (ii = 0; ii < iCount; ii++)
    {
        EnableMenuItem(hMenu,ii,MF_ENABLED | MF_BYPOSITION);
    }
    SetCursor(LoadCursor(NULL,IDC_ARROW));
    EnableMenuItem (ghSystemMenu, MENU_RUN, MF_BYCOMMAND | MF_ENABLED);
    DrawMenuBar(ghwndTSMain);

    for (ii=0; ii<=BTN_LAST; ii++)
    {
        toolbarModifyState (hwndToolBar, ii, BTNST_UP);
    }
    switch (gwTSLogLevel)
    {
        case LOG_NOLOG:
        toolbarModifyState (hwndToolBar, BTN_WPFOFF, BTNST_DOWN);
        break;
        case TERSE:
        toolbarModifyState (hwndToolBar, BTN_WPFTERSE, BTNST_DOWN);
        break;
        case VERBOSE:
        toolbarModifyState (hwndToolBar, BTN_WPFVERBOSE, BTNST_DOWN);
        break;
    }
    switch (gwTSFileLogLevel)
    {
        case LOG_NOLOG:
        toolbarModifyState (hwndToolBar, BTN_FILEOFF, BTNST_DOWN);
        break;
        case TERSE:
        toolbarModifyState (hwndToolBar, BTN_FILETERSE, BTNST_DOWN);
        break;
        case VERBOSE:
        toolbarModifyState (hwndToolBar, BTN_FILEVERBOSE, BTNST_DOWN);
        break;
    }

    SendMessage (hwndEditLogFile, EM_SETREADONLY, FALSE, 0L);

    UpdateWindow (hwndToolBar);
    }
}


void tstWinYield
(
    void
)
{
    MSG msg;

    while(giTSWait > 0 && PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    }
}



/*----------------------------------------------------------------------------
This function returns the handle to the test cases resource.
----------------------------------------------------------------------------*/
HANDLE getTstIDListRes
(
    void
)
{
    return VLoadListResource(ghTSInstApp,
        FindResource(ghTSInstApp,MAKEINTRESOURCE(giTSCasesRes),RT_RCDATA));

} /* end of getTstIDListRes */



/*----------------------------------------------------------------------------
This function returns the number of selected test cases.
----------------------------------------------------------------------------*/
int getNumRunCases
(
    void
)
{
    int               iNumCases=0;
    LPTST_RUN_STRUCT  lpTraverse;

    lpTraverse = tstRunHdr.lpFirst;

    /* Traverse the list to get the number of selected cases */
    while (lpTraverse != NULL) {
    iNumCases++;
    lpTraverse = lpTraverse->lpNext;
    }
    return (iNumCases);
} /* end of getNumRunCases */




/***************************************************************************\
*                                                                           *
*   void displayTest                                                        *
*                                                                           *
*   Description:                                                            *
*       Displays the tests name on the status bar.                          *
*                                                                           *
*   Arguments:                                                              *
*       WORD wStrID:                                                        *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/09/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void displayTest
(
    WORD    wStrID,
    int     iCase
)
{
    char pszDesc[100];
    char pszDesc1[100];
    if (!fDisplayCurrentTest)
    {
    return;
    }
    if (!tstLoadString (ghTSInstApp, wStrID, pszDesc, 100))
    {
    return;
    }
    tstGetStatusBar (lpszPrevContent, BUFFER_LENGTH);
    wsprintf (pszDesc1, "Case %i: %s", iCase, (LPSTR) pszDesc);
    tstLogStatusBar (pszDesc1);
    return;
}


/*----------------------------------------------------------------------------
This function runs the test cases that were selected from the selection
listbox.
----------------------------------------------------------------------------*/
void RunCases
(
    void
)
{
    int               iCaseNum;
    HANDLE            hListRes;
    LPTST_ITEM_STRUCT lpBegCaseData;
    LPTST_ITEM_STRUCT lpCaseData;
    LPTST_RUN_STRUCT  lpTraverse;
    int               iRepeat = giTSRunCount;
    int               iResult,iTmpResult;
    int               iNumTimes=1;
    BOOL              runStopped = FALSE;

    tstLogFlush();
    hListRes = getTstIDListRes();
    lpBegCaseData = (LPTST_ITEM_STRUCT)VLockListResource(hListRes);
    if (tstRunHdr.lpFirst != NULL)
    {
        tsStartWait();

#ifdef  HCT
        tstLog(TERSE,"Starting Test Program: %s",(LPSTR)szTSTestName);
#endif  //  HCT

        logDateTimeBuild("Starting Time");

        // Execute all the selected cases by the specified number of cycles
        while ((iRepeat-- > 0) && (!runStopped))
        {
            //
            // set to FALSE if any test returns a code other than TST_PASS
            // or TST_TRAN in updateGrpNode, and used by tsPrfinalStatus()
            //
            gbAllTestsPassed = TRUE;

            lpTraverse = tstRunHdr.lpFirst;

            // Execute every test case in the list
            while ((lpTraverse != NULL) && (!runStopped))
            {
                iCaseNum = lpTraverse->iCaseNum;
                lpCaseData = lpBegCaseData + (iCaseNum - 1);
                displayTest (lpCaseData->wStrID, iCaseNum);
                GetAsyncKeyState (iStopVKey);
                tstLogFlush();

                if(fdwTstsHell & TSTSHELLFLAG_HANDLEEXCEPTION)
                {
                    __try
                    {
                        iResult = execTest(lpCaseData->iFxID,
                            iCaseNum,
                            lpCaseData->wStrID,
                            lpCaseData->wGroupId);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        DWORD   dwCode;

                        dwCode=GetExceptionCode();

                        tstLog(
                            TERSE,
                            "\r\nException 0x%08x in test case %d\r\n",
                            dwCode,
                            iCaseNum);
                        iResult=TST_OTHER;
                    }
                }
                else
                {
                    iResult = execTest(lpCaseData->iFxID,
                        iCaseNum,
                        lpCaseData->wStrID,
                        lpCaseData->wGroupId);
                }

                tstLogFlush();

                if (fDisplayCurrentTest)
                {
                    tstLogStatusBar (lpszPrevContent);
                }

                // If test application returned TST_STOP or TST_ABORT, then abort all tests
                if ((iResult == TST_STOP) || (iResult == TST_ABORT))
                {
                    runStopped = TRUE;
                }

                // If the current step mode is active, then step through the results
                if (gwTSStepMode)
                {
                    iTmpResult = StepMode(ghwndTSMain);
                }

                logCaseStatus(iResult,
                    iCaseNum,
                    lpCaseData->wStrID,
                    lpCaseData->wGroupId);

                tstWinYield();
                // Allow user to abort between tests
                if (tstCheckRunStop (iStopVKey))
                {
                    runStopped = TRUE;
                    tstLog (TERSE, "******************************");
                    tstLog (TERSE, "Aborting tests by user request");
                    tstLog (TERSE, "******************************");
                }

                if (lpTraverse != NULL)
                    lpTraverse = lpTraverse->lpNext;
                tstWinYield();
            }
            tstLog(TERSE,"Cycles Executed: %d",iNumTimes++);
            tsPrAllGroups();
            tsPrFinalStatus();
        }
        tsEndWait();
        logDateTimeBuild("Ending Time");

#ifdef  HCT
        tstLog(TERSE,"Ending Test Program: %s",(LPSTR)szTSTestName);
#endif  //  HCT

        VUnlockListResource(hListRes);
        VFreeListResource(hListRes);
        if (gbGotWM_CLOSE)
        {
            PostMessage (ghwndTSMain, WM_CLOSE, 0, 0L);
        }
    }
    else
    {
        MessageBox (NULL,"No selected cases to run", szTSTestName,
                MB_ICONEXCLAMATION | MB_OK);
    }
} /* end of RunCases */



/*----------------------------------------------------------------------------
This function returns a randomized number based on the specified seed and
upper limit.
----------------------------------------------------------------------------*/
UINT getTSRandWord
(
    DWORD   dwSeed,
    UINT    wModulus,
    DWORD   *dwRetNewSeed
)
{
    DWORD  dwNewSeed;

    dwNewSeed = dwSeed * 214013L + 2531011L;
    *dwRetNewSeed = dwNewSeed;
    return ((UINT) ((dwNewSeed >> 16) & 0xffffu) % wModulus);

} /* end of getTSRandWord */



/*----------------------------------------------------------------------------
This function runs the test cases that were selected from the selection
listbox in a random order.
----------------------------------------------------------------------------*/
void RunRandomCases
(
    void
)
{
    int               iCaseNum;
    HANDLE            hListRes;
    LPTST_ITEM_STRUCT lpBegCaseData;
    LPTST_ITEM_STRUCT lpCaseData;
    LPTST_RUN_STRUCT  lpTraverse;
    int               iRepeat = giTSRunCount;
    int               iResult,iTmpResult;
    int               iNumRun;
    int               iNumCases;
    DWORD             dwSeed = GetCurrentTime();
    int               iRandNum;
    int               iNumTimes=1;
    BOOL              runStopped = FALSE;

    tstLogFlush();
    hListRes = getTstIDListRes();
    lpBegCaseData = (LPTST_ITEM_STRUCT)VLockListResource(hListRes);
    if (tstRunHdr.lpFirst != NULL)
    {
        tsStartWait();
        iNumCases = getNumRunCases();

        // Execute the random cases by the specified number of
        // cycles - iRepeat
        while ((iRepeat-- > 0) && (!runStopped))
        {
            iNumRun = 0;

            /* Execute random cases until the number executed equals the
            number of cases in the list, which is a cycle of cases */

            while ((iNumRun++ < iNumCases) && (!runStopped))
            {
                iRandNum = (int)getTSRandWord(dwSeed,(UINT)iNumCases,&dwSeed);
                    lpTraverse = tstRunHdr.lpFirst;
                while (iRandNum-- > 0)
                {
                    lpTraverse = lpTraverse->lpNext;
                }
                iCaseNum = lpTraverse->iCaseNum;
                lpCaseData = lpBegCaseData + (iCaseNum - 1);
                displayTest (lpCaseData->wStrID, iCaseNum);
                GetAsyncKeyState (iStopVKey);
                tstLogFlush();

                if(fdwTstsHell & TSTSHELLFLAG_HANDLEEXCEPTION)
                {
                    __try
                    {
                        iResult = execTest(lpCaseData->iFxID,
                            iCaseNum,
                            lpCaseData->wStrID,
                            lpCaseData->wGroupId);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        DWORD   dwCode;

                        dwCode=GetExceptionCode();

                        tstLog(
                            TERSE,
                            "\r\nException 0x%08x in test case %d\r\n",
                            dwCode,
                            iCaseNum);
                        iResult=TST_OTHER;
                    }
                }
                else
                {
                    iResult = execTest(lpCaseData->iFxID,
                        iCaseNum,
                        lpCaseData->wStrID,
                        lpCaseData->wGroupId);
                }

                tstLogFlush();

                if (fDisplayCurrentTest)
                {
                    tstLogStatusBar (lpszPrevContent);
                }

                // If test application returned TST_STOP or TST_ABORT, then abort all tests
                if ((iResult == TST_STOP) || (iResult == TST_ABORT))
                {
                    runStopped = TRUE;
                }

                // Step through the results if in step mode
                if (gwTSStepMode)
                {
                    iTmpResult = StepMode(ghwndTSMain);
                }
                logCaseStatus(iResult,
                    iCaseNum,
                    lpCaseData->wStrID,
                    lpCaseData->wGroupId);

                // Allow user to abort between tests
                if (tstCheckRunStop (iStopVKey))
                {
                    runStopped = TRUE;
                    tstLog (TERSE, "******************************");
                    tstLog (TERSE, "Aborting tests by user request");
                    tstLog (TERSE, "******************************");
                }

                tstWinYield();
            }
            tstLog(TERSE,"Cycles Executed: %d",iNumTimes++);
            tsPrAllGroups();
        }
        tsEndWait();
        VUnlockListResource(hListRes);
        VFreeListResource(hListRes);
        if (gbGotWM_CLOSE)
        {
            PostMessage (ghwndTSMain, WM_CLOSE, 0, 0L);
        }
    }
    else
    {
    MessageBox (NULL,"No selected cases to run", szTSTestName,
            MB_ICONEXCLAMATION | MB_OK);
    }
} /* end of RunRandomCases */





/***************************************************************************\
*                                                                           *
*   LRESULT statBarWndProc                                                  *
*                                                                           *
*   Description:                                                            *
*       Window procedure for the status bar.                                *
*                                                                           *
*   Arguments:                                                              *
*       HWND hWnd:                                                          *
*                                                                           *
*       UINT msg:                                                           *
*                                                                           *
*       WPARAM wParam:                                                      *
*                                                                           *
*       LPARAM lParam:                                                      *
*                                                                           *
*   Return (LRESULT):                                                       *
*                                                                           *
*   History:                                                                *
*       07/28/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

LRESULT EXPORT FAR PASCAL statBarWndProc
(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    HDC         hDC;
    PAINTSTRUCT ps;
    RECT        rect;
    int         tmHeight;
    HPEN        hPen1, hPen2, hOldPen;

    switch (msg)
    {
    case WM_PAINT:
        hDC = BeginPaint (hWnd, (LPPAINTSTRUCT) &ps);
        tmHeight = calcLogSize (&rect);
        SetBkMode (hDC, TRANSPARENT);
        TextOut (hDC, 4, 0, szStatusText, lstrlen (szStatusText));

        hPen1 = CreatePen (PS_SOLID, 0, RGB (150,150,150));
        hPen2 = CreatePen (PS_SOLID, 0, RGB (255,255,255));

        hOldPen = SelectObject (hDC, hPen1);
        MoveToEx (hDC, rect.left, 0, NULL);
        LineTo (hDC, rect.right, 0);
        MoveToEx (hDC, rect.left, 1, NULL);
        LineTo (hDC,rect.right, 1);
        MoveToEx (hDC, rect.left, 0, NULL);
        LineTo (hDC,rect.left, tmHeight + 2);
        MoveToEx (hDC, rect.left+1, 0, NULL);
        LineTo (hDC,rect.left+1, tmHeight + 2);

        SelectObject (hDC, hPen2);
        MoveToEx (hDC, rect.left, tmHeight, NULL);
        LineTo (hDC,rect.right, tmHeight);
        MoveToEx (hDC, rect.left, tmHeight+1, NULL);
        LineTo (hDC,rect.right, tmHeight+1);
        MoveToEx (hDC, rect.right-2, 0, NULL);
        LineTo (hDC,rect.right-2, tmHeight + 2);
        MoveToEx (hDC, rect.right-1, 0, NULL);
        LineTo (hDC, rect.right-1, tmHeight + 2);

        SelectObject (hDC, hOldPen);
        DeleteObject (hPen1);
        DeleteObject (hPen2);
        EndPaint (hWnd, (LPPAINTSTRUCT) &ps);
        break;

    case WM_DESTROY:
        PostQuitMessage (0);
        return 0;
    }
    return DefWindowProc (hWnd, msg, wParam, lParam);
}


/***************************************************************************\
*                                                                           *
*   void PickFont                                                           *
*                                                                           *
*   Description:                                                            *
*       Picks a new font.                                                   *
*                                                                           *
*   Arguments:                                                              *
*       HWND hWndOwner: Handle to parent window.                            *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       11/23/94    Fwong       Expanding functionality.                    *
*                                                                           *
\***************************************************************************/

void PickFont
(
    HWND    hWndOwner
)
{
    LOGFONT     lf;
    CHOOSEFONT  cf;
    HFONT       hFont,hFontOld;

    hFontOld = GetWindowFont(ghTSWndLog);

    GetObject(hFontOld,sizeof(LOGFONT),(LPLOGFONT)&lf);

    _fmemset(&cf,0,sizeof(CHOOSEFONT));

    cf.lStructSize = sizeof(CHOOSEFONT);
    cf.hwndOwner   = hWndOwner;
    cf.lpLogFont   = &lf;
    cf.Flags       = CF_SCREENFONTS|CF_ANSIONLY|CF_FIXEDPITCHONLY|
                     CF_LIMITSIZE|CF_INITTOLOGFONTSTRUCT;
    cf.nSizeMin    = 8;
    cf.nSizeMax    = 20;
    cf.nFontType   = SCREEN_FONTTYPE;

    if(0 == ChooseFont(&cf))
    {
        return;
    }

    hFont    = CreateFontIndirect(&lf);

    SetWindowFont(ghTSWndLog,hFont,TRUE);

    DeleteObject(hFontOld);
} // PickFont()


/***************************************************************************\
*                                                                           *
*   LRESULT tstMainWndProc                                                  *
*                                                                           *
*   Description:                                                            *
*       TestShell's main window procedure.                                  *
*                                                                           *
*   Arguments:                                                              *
*       HWND hTstMain:                                                      *
*                                                                           *
*       UINT msg:                                                           *
*                                                                           *
*       WPARAM wParam:                                                      *
*                                                                           *
*       LPARAM lParam:                                                      *
*                                                                           *
*   Return (LRESULT):                                                       *
*                                                                           *
*   History:                                                                *
*       07/28/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

LRESULT EXPORT FAR PASCAL tstMainWndProc
(
    HWND    hTstMain,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    UINT        wIndex;
    RECT        rect;
    HFILE       hFile;
    UINT        wNotifyCode;
    UINT        wID;
    HWND        hwndCtl;
    PAINTSTRUCT ps;
    HDC         hDC;
    int         iHeight;

    switch (msg) {
    case WM_PAINT:
        hDC = BeginPaint (hTstMain, (LPPAINTSTRUCT) &ps);
        iHeight = calcLogSize ((LPRECT) &rect);

        if (fShowStatusBar)
        {
        MoveToEx (hDC, rect.left, rect.bottom, NULL);
        LineTo (hDC, rect.right, rect.bottom);
        MoveToEx (hDC, rect.left, rect.bottom + 1, NULL);
        LineTo (hDC, rect.right, rect.bottom + 1);
        }

        if (fShowToolBar)
        {
        MoveToEx (hDC, rect.left, rect.top-2 , NULL);
        LineTo (hDC, rect.right, rect.top-2);
        MoveToEx (hDC, rect.left, rect.top-1, NULL);
        LineTo (hDC, rect.right, rect.top-1);
        }

        EndPaint (hTstMain, (LPPAINTSTRUCT) &ps);
        break;
    case WM_SIZE:
        recWMSIZEMessage();
//        if (wParam == SIZE_RESTORED)
//        {
//        GetWindowRect (ghwndTSMain, (RECT FAR *) &WindowRect);
//        }
        break;

//    case WM_MOVE:
//        if (!IsIconic (hTstMain))
//        {
//        GetWindowRect (ghwndTSMain, (RECT FAR *) &WindowRect);
//        }
//        break;

    case WM_SETCURSOR:
        if (giTSWait) {
        SetCursor(ghTSwaitCur);
        }
        break;

    case WM_SYSCOMMAND:
        switch (wParam)
        {
        case SC_SCREENSAVE:
            if (gwTSScreenSaver == SSAVER_DISABLED)
            {
            return 1;   // Screen saver is disabled
            }
            break;
        case MENU_RUN:

            //
            //  Someone wants to reset the log file (if appropriate) and
            //  calling this function (since bad functionality was added).
            //
            //  -Fwong.
            //

//            /* Open the log file */
//            SetLogfileName (szTSLogfile);

            if (LOG_OVERWRITE == gwTSFileMode)
            {
                OpenFile(szTSLogfile,&ofGlobRec,OF_CREATE|OF_EXIST);
            }

            if (gwTSRandomMode)
            RunRandomCases();
            else
            RunCases();
            break;
        }
        break;

    case WM_COMMAND:
        wNotifyCode=GET_WM_COMMAND_CMD(wParam,lParam);
        wID=GET_WM_COMMAND_ID(wParam,lParam);
        hwndCtl=GET_WM_COMMAND_HWND(wParam,lParam);
        switch (wID)
        {
        case IDC_TOOLBAR:
            // Restore content of status bar.
            restoreStatusBar();

            switch (HIWORD(lParam) & 0xFF)
            {
            case BTN_OPEN:
                PostMessage (hTstMain, WM_COMMAND, MENU_LOAD, 0L);
                return 0;
            case BTN_SAVE:
                PostMessage (hTstMain, WM_COMMAND, MENU_SAVE, 0L);
                return 0;
            case BTN_RUN:
                PostMessage (hTstMain, WM_COMMAND, MENU_RUN, 0L);
                return 0;
            case BTN_RUNMIN:
                ShowWindow (ghwndTSMain, SW_MINIMIZE);
                PostMessage (hTstMain, WM_COMMAND, MENU_RUN, 0L);
                return 0;
            case BTN_RUNALL:
                placeAllCases();
                PostMessage (hTstMain, WM_COMMAND, MENU_RUN, 0L);
                break;
            case BTN_EDIT:
                PostMessage (hTstMain, WM_COMMAND, MENU_EDITOR, 0L);
                return 0;
            case BTN_CLEAR:
                PostMessage (hTstMain, WM_COMMAND, MENU_CLS, 0L);
                return 0;
            case BTN_SELECT:
                PostMessage (hTstMain, WM_COMMAND, MENU_SELECT, 0L);
                return 0;
            case BTN_SETLOGGING:
                PostMessage (hTstMain, WM_COMMAND, MENU_LOGGING, 0L);
                return 0;

            case BTN_FILEOFF:
                gwTSFileLogLevel = LOG_NOLOG;
                break;
            case BTN_FILETERSE:
                gwTSFileLogLevel = TERSE;
                break;
            case BTN_FILEVERBOSE:
                gwTSFileLogLevel = VERBOSE;
                break;
            case BTN_WPFOFF:
                gwTSLogLevel = LOG_NOLOG;
                break;
            case BTN_WPFTERSE:
                gwTSLogLevel = TERSE;
                break;
            case BTN_WPFVERBOSE:
                gwTSLogLevel = VERBOSE;
                break;
             }
//                    bToolBarUsed = FALSE;
            break;
        case MENU_TOOLBAR:
            fShowToolBar = !fShowToolBar;
            if (fShowToolBar)
            {
                CheckMenuItem (
                    GetMenu(hTstMain),
                    (UINT)(MENU_TOOLBAR),
                    MF_CHECKED);

                ShowWindow (hwndToolBar, SW_SHOW);
            }
            else
            {
                CheckMenuItem (
                    GetMenu(hTstMain),
                    (UINT)(MENU_TOOLBAR),
                    MF_UNCHECKED);

                ShowWindow (hwndToolBar, SW_HIDE);
            }
            recWMSIZEMessage();
            break;
        case MENU_STATUSBAR:
            fShowStatusBar = !fShowStatusBar;
            if (fShowStatusBar)
            {
                CheckMenuItem (
                    GetMenu(hTstMain),
                    MENU_STATUSBAR,
                    MF_CHECKED);

                ShowWindow (hwndStatusBar, SW_SHOW);
            }
            else
            {
                CheckMenuItem (
                    GetMenu(hTstMain),
                    MENU_STATUSBAR,
                    MF_UNCHECKED);

                ShowWindow (hwndStatusBar, SW_HIDE);
            }
            recWMSIZEMessage();
            break;

        case MENU_EDITOR:
            editLogFile();
            break;

        case MENU_CLS:
            Text_Delete(ghTSWndLog);
            break;

        case MENU_COPY:
            Text_Copy(ghTSWndLog);
            break;

        case MENU_FIND:
            if(!Find())
            {
                break;
            }

        case MENU_FINDNEXT:
            if(0 == lstrlen(szSearchString))
            {
                MessageBox(
                    hTstMain,
                    "No string specified on search.",
                    "Error!",
                    MB_OK | MB_ICONSTOP);

                break;
            }

            if(!Text_SearchString(
                    ghTSWndLog,
                    szSearchString,
                    ((fdwTstsHell & TSTSHELLFLAG_SEARCHMATCHCASE)?
                        SEARCHFLAG_MATCHCASE:0)))
            {
                MessageBox(
                    hTstMain,
                    "String not found.",
                    "Find...",
                    MB_OK | MB_ICONINFORMATION);
            }

            break;

        case MENU_FONT:
            PickFont(hTstMain);
            break;

        case MENU_RUN:

            //
            //  Someone wants to reset the log file (if appropriate) and
            //  calling this function (since bad functionality was added).
            //
            //  -Fwong.
            //

//            /* Open the log file */
//            SetLogfileName (szTSLogfile);

            if (LOG_OVERWRITE == gwTSFileMode)
            {
                OpenFile(szTSLogfile,&ofGlobRec,OF_CREATE|OF_EXIST);
            }

            if (gwTSRandomMode)
            RunRandomCases();
            else
            RunCases();
            break;
        case MENU_SELECT:
            Select();
            break;
        case MENU_LOGGING:
            Logging();
            break;
        case MENU_DEFPROF:
            if (*szTSProfile)
            {
            tstWriteProfileString (szTSDefProfKey, szTSProfile);
            }
            break;
        case MENU_LOAD:
            LoadProfile(TRUE);
            break;
        case MENU_SAVEAS:
        case MENU_SAVE:
            SaveProfile (wID);
            break;
        case MENU_RUNSETUP:
            RunSetup(hTstMain);
            break;
        case MENU_SETPATHS:
            SetInOutPaths();
            break;
        case MENU_RESETLOGFILE:
            if (ghTSLogfile != TST_NOLOGFILE)
            hFile = OpenFile(szTSLogfile,
                 &ofGlobRec,OF_CREATE | OF_EXIST);
            break;
        case MENU_RESETENVT:
            getIniStrings();
            setLogFileDefs();
            resetEnvt();

            removeRunCases();
            tsRemovePrStats();

            lstrcpy (szTSProfile, "");
            ghTSLogfile = TST_NOLOGFILE;

            break;

        case MENU_ABOUT:
            About();
            break;
        case MENU_HELPINDEX:
            if (!WinHelp(hTstMain,"tstshell.hlp",HELP_INDEX,0)) {
            MessageBox(hTstMain,"Unable to load help.",
                   "Help Error",
                   MB_APPLMODAL|MB_ICONEXCLAMATION);
            }
            break;

        case MENU_EXIT:
            PostMessage (hTstMain, WM_CLOSE, 0, 0L);
            break;
        default:
            for (wIndex = 0; wIndex < wNextCustomMenuItem; ++wIndex) {
            if (CustomMenuItems[wIndex].wID == wID) {
#ifdef WIN32
            DECLARE_TS_MENU_PTR(tsProcPtr);

                tsProcPtr = CustomMenuItems[wIndex].fpTest;
                tsProcPtr(hTstMain,msg,wParam,lParam);
#else
                (CustomMenuItems[wIndex].fpTest)(hTstMain,msg,wParam,lParam);
#endif
            }
            }
            break;
        } // end of WM_COMMAND
    case WM_KEYDOWN:

        switch (wParam)
        {
            case 0x39:  // '9' virtual key code
                PrintRunList();
                break;
        }
        break;

//Added by t-rajr
#ifdef WIN32

    case TSTMSG_TSTLOGFLUSH:

        //
        //  This message is sent by a thread (that is NOT the main thread)
        //  executing tstLogFlush. ONLY the main thread can actually flush
        //  to the window. After executing tstLogFlush, signal the event.
        //

        tstLogFlush();
        SetEvent(ghFlushEvent);
        break;

#endif

    case WM_CLOSE:
        if (giTSWait)
        {
            gbGotWM_CLOSE = TRUE;
            return 0L;
        }
        else
        {
            saveApplicationSettings(hTstMain);
        }
        break;

    case WM_DESTROY:
        PostQuitMessage (0);
        break;
    }

    //
    //  This was added to handle things like color chance and VK processing.
    //

    TextFocusProc(ghTSWndLog,msg,wParam,lParam);
    return tstDefWindowProc (hTstMain, msg, wParam, lParam);
} /* end of tstMainWndProc */


/*----------------------------------------------------------------------------
This function removes white space from the specified string and returns the
resulting string.
----------------------------------------------------------------------------*/
LPSTR removeWhiteSpace
(
    LPSTR   lpstrCmdLine
)
{
    int ii=0;

    while (lpstrCmdLine[ii++] == ' ')
    {
    lpstrCmdLine++;
    }
    return lpstrCmdLine;
}



/*----------------------------------------------------------------------------
This function extracts a token string delimited by either a space or end of
string character.
----------------------------------------------------------------------------*/
LPSTR getToken
(
    LPSTR   lpsz,
    LPSTR   lpszToken
)
{
    // skip leading whitespace
    //
    while (*lpsz == ' ' || *lpsz == '\t')
        ++lpsz;

    // copy token characters to lpszToken and null terminate it
    //
    while (*lpsz && *lpsz != ' ' && *lpsz != '\t' && *lpsz != '/')
        *lpszToken++ = *lpsz++;
    *lpszToken = 0;

    // return pointer to first character after the token
    //
    return lpsz;
}


/*==========================================================================

check that passed char is a valid file name char.  return TRUE if it is,
else return FALSE.

============================================================================*/

BOOL ValidFileNameChar (char it)
{

   if (IsCharAlpha (it) || it == '.')
      return TRUE;
   else
      return FALSE;

}

#define INLINE_BREAK DebugBreak();
#define BOUND(a,min,max)  ((a) <= (min) ? (min) : ((a) >= (max) ? (max) : (a)))
#define assert(cond) if (!(cond)) INLINE_BREAK

/*----------------------------------------------------------------------------
This function parses the command line and executes accordingly.
----------------------------------------------------------------------------*/
BOOL ParseCmdLine
(
    LPSTR   lpszCmdLine    // LPSTR because cmd line is always ANSI
)
{
    BOOL   bRet = FALSE;
    LPSTR  lpsz = lpszCmdLine;

    szTSProfile[0] = 0;

    assert (lpsz);

    while (*lpsz)
    {
        // remove leading whitespace
        //
        while (*lpsz == ' ' || *lpsz == '\t')
            ++lpsz;

        // is this a command line switch?
        //
        if (*lpsz == '-' || *lpsz == '/')
        {
            do
            {
                char ch = *++lpsz;

                switch (ch | 0x20) // convert alpha to lower, mangle non alpha.
                {
                    case 'a':
                       gbTSAuto = TRUE;
                       addModeTstCases (TST_AUTOMATIC);
                       break;

                    case 'g':
                        gbTSAuto = TRUE;
                        bRet = TRUE;
                        break;

                    case 'x':
                        bRet = TRUE;
                        break;

                    case 'p':
                        // remove leading whitespace
                        //
                        lpsz = getToken (++lpsz, szTSProfile);
                        gbFileNamed = TRUE;
                        break;

                    // log level
                    //
                    case 'l':
                    {
                        char sz[MAX_PATH];
                        int  iLevel;

                        lpsz = getToken (++lpsz, sz);
                        iLevel = atoi (sz);
                        gwTSFileLogLevel = BOUND(iLevel, LOG_NOLOG, VERBOSE);
                        break;
                    }

                    // verbosity level
                    //
                    case 'v':
                    {
                        char sz[MAX_PATH];
                        int  iLevel;

                        lpsz = getToken (++lpsz, sz);
                        iLevel = atoi (sz);
                        gwTSLogLevel = BOUND(iLevel, LOG_NOLOG, VERBOSE);
                        break;
                    }

                    // initial test case
                    //
                    case 'c':
                    {
                        extern void addRunCase (int); // from tsseltst.c
                        char sz[MAX_PATH];
                        int  iCase;

                        lpsz = getToken (++lpsz, sz);
                        iCase = atoi (sz);
                        if (iCase > 0)
                            addRunCase (iCase);
                        break;
                    }

                    default:
                        break;
                }

            // loop back to get the next 'key' letter if there
            // are any more in this stream.  this looping allows
            // us to support cmd lines like '/abc' as well as
            // '/a /b /c'
            //
            } while (*lpsz         &&
                     *lpsz != ' '  &&
                     *lpsz != '\t' &&
                     *lpsz != '-'  &&
                     *lpsz != '/');
        }
        else
        {
            char szDummy[MAX_PATH * 2];

            // wow! this was unexpected! non-whitespace characters
            // in the command line without any preceeding '-' or '/'
            // what could this mean?
            //

            // manufacture an error message containing  the invalid
            // token and go on.
            //
            lstrcpy (szDummy, "Unexpected characters in command line\r\n");
            lpsz = getToken (lpsz, szDummy + lstrlen(szDummy));
            lstrcat (szDummy, "'\r\nis not a valid command");

            MessageBox (NULL, szDummy, "TstShell - Error", MB_ICONHAND | MB_OK);
        }
    }

    return bRet;
}

/*==========================================================================

retrieve strings from the Win.ini file, and store them in global char arrays.

===========================================================================*/

void getIniStrings
(
    void
)
{
   //
   // get the input and output paths from Win.ini, and
   // prepend the output path to the log file name.
   //

   GetPrivateProfileString((LPSTR)szTSPathSection, szTSInPathKey,
    "no entry",szInPath, sizeof (szInPath), szTstsHellIni);
   GetPrivateProfileString((LPSTR)szTSPathSection, szTSOutPathKey,
    "no entry",szOutPath, sizeof (szOutPath), szTstsHellIni);

   //
   // szIn/OutPath==(the default) indicates that no entry was found in Win.ini
   //

   if (!lstrcmpi(szOutPath, "no entry") || (!lstrcmpi(szOutPath, "")))
      lstrcpy (szOutPath, ".");   // put the log file in the current dir

   if (!lstrcmpi(szInPath, "no entry") || (!lstrcmpi(szInPath, "")))
      lstrcpy (szInPath, ".");

}


/*=========================================================================

construct the default log file name, and set the default log file level
and mode.

==========================================================================*/

void setLogFileDefs
(
    void
)
{
    char  szLogName[BUFFER_LENGTH];
    char  szLogFile[BUFFER_LENGTH];

    gwTSFileMode = LOG_OVERWRITE;
    gwTSFileLogLevel = VERBOSE;

    MakeDefaultLogName (szLogName);

    // Gets the current working directory
    GetCWD (szLogFile, BUFFER_LENGTH);

    lstrcat (szLogFile, "\\");
    lstrcat (szLogFile, szLogName);
    AnsiLower ((LPSTR) szLogFile);

    SetLogfileName (szLogFile);
    return;
}


/***************************************************************************\
*                                                                           *
*   LPSTR ParseNumber                                                       *
*                                                                           *
*   Description:                                                            *
*       Helper parser function for RestoreFont().                           *
*                                                                           *
*   Arguments:                                                              *
*       LPSTR pszNumber: Pointer to string containing unsigned number.      *
*                                                                           *
*       LPDWORD pdw: Pointer to DWORD to store unsigned number.             *
*                                                                           *
*   Return (LPSTR):                                                         *
*       Pointer to middle of string from which to continue.                 *
*                                                                           *
*   History:                                                                *
*       11/28/94    Fwong       Helper function for RestoreFont().          *
*                                                                           *
\***************************************************************************/

LPSTR ParseNumber
(
    LPSTR   pszNumber,
    LPDWORD pdw
)
{
    DWORD   dw;

    dw = 0;

    for(;(('0' <= *pszNumber) && ('9' >= *pszNumber));pszNumber++)
    {
        dw = dw * 10 + ((*pszNumber) - '0');
    }

    *pdw = dw;
    return pszNumber;
} // ParseNumber()


/***************************************************************************\
*                                                                           *
*   void RestoreFont                                                        *
*                                                                           *
*   Description:                                                            *
*       Restores the font from previous instance of application.            *
*                                                                           *
*   Arguments:                                                              *
*       HWND hWnd: Handle to window to set font.                            *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       11/28/94    Fwong       Adding functionality to tstshell.           *
*                                                                           *
\***************************************************************************/

void RestoreFont
(
    HWND    hWnd
)
{
    LOGFONT lf;
    DWORD   dw;
    LPSTR   psz;
    HFONT   hFont;
    char    szString[BUFFER_LENGTH];

    tstGetProfileString("FontName","",szString,sizeof(szString));

    if(0 == lstrcmp(szString,""))
    {
        SetWindowFont(ghTSWndLog,NULL,TRUE);
        return;
    }

    lstrcpy((&lf.lfFaceName[0]),szString);

    tstGetProfileString(
        "FontAttr",
        "-13 400 0 16908593",
        szString,
        sizeof(szString));

    psz = &szString[1];

    psz         = ParseNumber(psz,&dw) + 1;
    lf.lfHeight = -1 * ((int)dw);

    lf.lfWidth       = 0;
    lf.lfEscapement  = 0;
    lf.lfOrientation = 0;

    psz         = ParseNumber(psz,&dw) + 1;
    lf.lfWeight = (int)dw;

    psz                 = ParseNumber(psz,&dw) + 1;
    lf.lfCharSet        = LOBYTE(LOWORD(dw));
    lf.lfStrikeOut      = HIBYTE(LOWORD(dw));
    lf.lfUnderline      = LOBYTE(HIWORD(dw));
    lf.lfItalic         = HIBYTE(HIWORD(dw));

    psz         = ParseNumber(psz,&dw) + 1;
    lf.lfPitchAndFamily = LOBYTE(LOWORD(dw));
    lf.lfQuality        = HIBYTE(LOWORD(dw));
    lf.lfClipPrecision  = LOBYTE(HIWORD(dw));
    lf.lfOutPrecision   = HIBYTE(HIWORD(dw));

    hFont = CreateFontIndirect(&lf);

    if(NULL != hFont)
    {
        SetWindowFont(hWnd,hFont,TRUE);
    }
} // RestoreFont()


/***************************************************************************\
*                                                                           *
*   BOOL AppInit                                                            *
*                                                                           *
*   Description:                                                            *
*      This is called when the application is first loaded into             *
*      memory.  It performs all initialization that doesn't need to be done *
*      once per instance.                                                   *
*                                                                           *
*                                                                           *
*   Arguments:                                                              *
*       HINSTANCE hInst: Instance handle of current instance                *
*                                                                           *
*       HINSTANCE hPrev: Instance handle of previous instance               *
*                                                                           *
*       UINT sw:                                                            *
*                                                                           *
*       LPSTR szCmdLine:                                                    *
*                                                                           *
*   Return (BOOL): TRUE if successful, FALSE if not.                        *
*                                                                           *
*   History:                                                                *
*       07/19/93    T-OriG  Added functionality and this header             *
*                                                                           *
\***************************************************************************/

BOOL AppInit
(
    HINSTANCE   hInst,
    HINSTANCE   hPrev,
    UINT        sw,
    LPSTR       szCmdLine
)
{
    WNDCLASS    wc;
    RECT            rect;
    POINT       point;
    DWORD       dw;
    int         tmHeight;
    char        szBuffer[BUFFER_LENGTH];
    int         xw, yw;

    // kfs 2/15/93 when call to AppInit moved to after getLoad CmdLine
    // this hoses the -g cnd line option.
    // gbTSAuto = FALSE;

    szStatusText[0] = 0;
    lpszPrevContent[0] = 0;

    // default messages should go to DefWindowProc, unless someone
    // has provided a custom message handler.
    tstDefWindowProc = DefWindowProc;

    // by default Custom Read and Write handlers are not supposed to do
    // anything.  --- AlokC (06/30/94)
    tstReadCustomInfo = tstDummyFn ;   // so that in general it doesn't do anything
    tstWriteCustomInfo = tstDummyFn ;  //    ......

    //
    // Calling this now to get szTSTestName.  Note that it will be called
    // again later to pass the hInst to the test app.
    //
    giTSCasesRes = tstGetTestInfo (hInst,
    (LPSTR)szTSTestName,
    (LPSTR)szTSPathSection,
    &wPlatform);

#ifdef  HCT
    HctTestBegin(ghTSInstApp,szTSTestName);
#endif  //  HCT

    GetPrivateProfileString(
        szTSTestName,
        "ClassName",
        szTSTestName,
        szAppClass,
        sizeof(szAppClass),
        szTstsHellIni);

    if (!hPrev)
    {
        // Main Window
        wc.style         = (UINT) CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = tstMainWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInst;
        wc.hIcon         = LoadIcon(hInst,"APPICON");
        wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
        wc.hbrBackground = NULL;
        wc.lpszMenuName  = (LPSTR)NULL;
        wc.lpszClassName = szAppClass;
//        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
//        wc.lpszClassName = szTSClass;

        if (!RegisterClass(&wc))
        {
            return FALSE;
        }

        // Status Bar
        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = statBarWndProc;
        wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
        wc.lpszClassName = szStatusBarClass;

        if (!RegisterClass (&wc))
        {
            return FALSE;
        }
    }

    ghTSMainMenu = LoadMenu (ghTSInstApp, "TstMenu");

    if (ghTSMainMenu == NULL)
    {
    MessageBox (NULL, "Cannot Load TstMenu", "Test Shell",
            MB_ICONHAND | MB_SYSTEMMODAL);
    return FALSE;
    }


    //
    //  The following is a workaround for an apparent bug in Chicago's
    //  GetProfileInt().  It seems to lop off the upper two bytes of
    //  CW_USEDEFAULT ((int) 0x80000000) and return 0 under Win32c.
    //  This was causing 32 bit apps build to draw very small in the upper
    //  left corner.
    //
    //  I'll remove the hack after I enter the bug and it get's fixed, or
    //  we figure out that we're doing something wrong.
    //  RickB - 11/11/93.

    xw = GetPrivateProfileInt (szTSTestName, "xw", CW_USEDEFAULT, szTstsHellIni);
    if (0 == xw)
    {
        xw = CW_USEDEFAULT;
    }

    yw = GetPrivateProfileInt (szTSTestName, "yw", CW_USEDEFAULT, szTstsHellIni);
    if (0 == yw)
    {
        yw = CW_USEDEFAULT;
    }

//    ghwndTSMain = CreateWindow(szTSClass,
//    szTSTestName,
//    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
//    GetPrivateProfileInt (szTSTestName, "x", CW_USEDEFAULT, szTstsHellIni),
//    GetPrivateProfileInt (szTSTestName, "y", CW_USEDEFAULT, szTstsHellIni),
//    xw,
//    yw,
//    NULL,
//    ghTSMainMenu,
//        hInst,
//    NULL);

    ghwndTSMain = CreateWindow(szAppClass,
    szTSTestName,
    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
    GetPrivateProfileInt (szTSTestName, "x", CW_USEDEFAULT, szTstsHellIni),
    GetPrivateProfileInt (szTSTestName, "y", CW_USEDEFAULT, szTstsHellIni),
    xw,
    yw,
    NULL,
    ghTSMainMenu,
        hInst,
    NULL);

    if (ghwndTSMain == NULL)
    {
    MessageBox (NULL, "Cannot open main window", "Test Shell",
            MB_ICONHAND | MB_SYSTEMMODAL);
    return FALSE;
    }

    tmHeight = calcLogSize ((LPRECT)&rect);

    // Install Toolbar

    toolbarInit (hInst, hPrev);
    hwndToolBar = CreateWindow (szToolBarClass,
    "",
    WS_CHILD,
    0,
    0,
    rect.right,
    26,
    ghwndTSMain,
    NULL,
    hInst,
    NULL);
    point.x = 24;
    point.y = 22;
    toolbarSetBitmap (hwndToolBar, hInst, IDBMP_TBAR, point);
    addToolbarTools();

    // Install edit control
    hwndEditLogFile = CreateWindow ("edit",
    "",
    ES_LEFT | ES_AUTOHSCROLL | WS_BORDER | WS_CHILD | ES_LOWERCASE,
    EDITSTART,
    2,
    EDITLENGTH,
    tmHeight+10,
    hwndToolBar,
    (HMENU) ID_EDITLOGFILE,
    hInst,
    NULL);

    lpfnOldEditProc = (WNDPROC) GetWindowLong (hwndEditLogFile, GWL_WNDPROC);
    SetWindowLong (hwndEditLogFile,
    GWL_WNDPROC,
    (LONG) MakeProcInstance ((FARPROC) NewEditProc, hInst));

    // Create Status Bar Window:
    hwndStatusBar = CreateWindow (szStatusBarClass,
    "",
    WS_CHILD,
    rect.left,
    rect.bottom + 2,
    rect.right,
    tmHeight,
    ghwndTSMain,
    (HMENU) ID_STATUSBAR,
    hInst,
    NULL);

    ShowWindow (hwndEditLogFile, SW_SHOW);

    // Load Keyboard Accelerators
    hAccel = LoadAccelerators (hInst, "TstAccelerators");

    // Install Run Tests as an option in the system menu
    ghSystemMenu = GetSystemMenu (ghwndTSMain, FALSE);
    AppendMenu(ghSystemMenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(ghSystemMenu, MF_STRING, MENU_RUN, "Run Tests\tCtrl+R");

    ghTSWndLog = TextCreateWindow(
        WS_VISIBLE | WS_CHILDWINDOW | WS_VSCROLL | WS_HSCROLL,
        rect.left,
        rect.top,
        rect.right,
        rect.bottom - rect.top,
        ghwndTSMain,
        (HMENU)(TST_LOGWINDOW),
        ghTSInstApp);

    if (ghTSWndLog == NULL)
    {
    MessageBox (NULL, "Cannot open logging window", "Test Shell",
            MB_ICONHAND | MB_SYSTEMMODAL);
    return FALSE;
    }

    //
    //  Setting defaults for log window...
    //

    SetWindowRedraw(ghTSWndLog, TRUE);
    RestoreFont(ghTSWndLog);

    tstGetProfileString("BufferLimit","1048576",szBuffer,sizeof(szBuffer));
    ParseNumber((LPSTR)(&szBuffer[0]),&dw);
    Text_SetBufferLimit(ghTSWndLog,dw,0);

    tstRunHdr.lpFirst = NULL;
    tstRunHdr.lpLast = NULL;

    tsPrStatHdr = NULL;

    // moved to WinMain() before cmd line loaded
    // resetEnvt();

    //
    // Set the font in the listbox to a fixed font
    //
//    SendMessage(ghTSWndLog,
//    WM_SETFONT,
//    (UINT) GetStockObject(SYSTEM_FIXED_FONT),
//    0L);

//    //
//    // Calling this now to get szTSTestName.  Note that it will be called
//    // again later to pass the hInst to the test app.
//    //
//    giTSCasesRes = tstGetTestInfo (hInst,
//    (LPSTR)szTSTestName,
//    (LPSTR)szTSPathSection,
//    &wPlatform);

    //
    // Calculate the number of tests in the resource
    //
    calculateNumResourceTests();


    //
    // Appropriate States for menu items
    //

    //
    //  Search String...
    //

    tstGetProfileString("SearchString","0,",szBuffer,sizeof(szBuffer));
    fdwTstsHell |= (('0' == szBuffer[0])?0:TSTSHELLFLAG_SEARCHMATCHCASE);
    lstrcpy(szSearchString,(LPSTR)&(szBuffer[2]));

    // Toolbar
    GetPrivateProfileString (szTSTestName, "ShowToolBar", "Yes", szBuffer,
        BUFFER_LENGTH, szTstsHellIni);
    if (lstrcmp (szBuffer, "No")==0)
    {
        fShowToolBar = FALSE;
    }
    else
    {
        CheckMenuItem (
            GetMenu(ghwndTSMain),
            MENU_TOOLBAR,
            MF_CHECKED);

        ShowWindow (hwndToolBar, SW_SHOW);
    }

    // Statusbar
    GetPrivateProfileString (szTSTestName, "ShowStatusBar", "Yes", szBuffer,
        BUFFER_LENGTH, szTstsHellIni);
    if (lstrcmp (szBuffer, "No")==0)
    {
        fShowStatusBar = FALSE;
    }
    else
    {
        CheckMenuItem (
            GetMenu(ghwndTSMain),
            MENU_STATUSBAR,
            MF_CHECKED);

        ShowWindow (hwndStatusBar, SW_SHOW);
    }

    //
    // Set a default caption if the test application hasn't already done so.
    //
    if(!GetWindowTextLength(ghwndTSMain))
    {
    SetWindowText(ghwndTSMain,szTSTestName);
    }

    //
    // fetch any strings in Win.ini
    //
    getIniStrings();   // assigns szInPath, szOutPath

    ghTSwaitCur = LoadCursor(NULL,IDC_ARROW);
    recWMSIZEMessage();
    ShowWindow(ghwndTSMain,sw);

    return TRUE;
    szCmdLine;      // Use formal parameter

} // end of AppInit


void tstInitHelpMenu
(
    void
)
{
    static BOOL bFirstTime = TRUE;
    HMENU       hmenu;

    if(TRUE != bFirstTime)
    {
        return;
    }

    //
    //  Adding help menu.
    //

    hmenu = CreatePopupMenu();
    AppendMenu (hmenu, MF_ENABLED | MF_STRING, MENU_HELPINDEX, "&Index");
    AppendMenu (hmenu, MF_SEPARATOR, 0, 0);
    AppendMenu (hmenu, MF_ENABLED | MF_STRING, MENU_ABOUT, "&About");
    AppendMenu (ghTSMainMenu, MF_ENABLED | MF_POPUP, (UINT) hmenu, "&Help");

    DrawMenuBar (ghwndTSMain);

    bFirstTime = FALSE;
}

// manufacture a full path name for the ini file by appending
// the ini file name to the full path name of the exe
//
static void GetIniName
(
    LPSTR szIni,
    UINT  cbIni
)
{
    UINT cb;

    cb = GetModuleFileName (ghTSInstApp, szIni, cbIni);

    if (cb)
    {
        while (--cb)
            if ('\\' == szTstsHellIni[cb-1])
                break;
    }
    lstrcpy (&szIni[cb], "TstShell.ini");

    return;
}



/***************************************************************************\
*                                                                           *
*   void getDefaultProfile                                                  *
*                                                                           *
*   Description:                                                            *
*       Gets default profile name.  Completely ignores it if a profile      *
*         was already loaded on command line.                               *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       04/14/94    Fwong       Fixing yet another TstsHell bug.            *
*                                                                           *
\***************************************************************************/

void getDefaultProfile
(
    void
)
{
    if(gbFileNamed)
    {
        //
        //  Hmm... if file was named at command line, don't load default
        //  profile.
        //

        return;
    }

    tstGetProfileString(szTSDefProfKey,"",szTSProfile,sizeof(szTSProfile));

    if(0 != szTSProfile[0])
    {
        //
        //  There is actually an entry!!
        //

        gbFileNamed = TRUE;
    }
} // getDefaultProfile()


/***************************************************************************\
*                                                                           *
*   int WinMain                                                             *
*                                                                           *
*   Description:                                                            *
*       The main procedure for the App.  After initializing, it just goes   *
*       into a message-processing loop until it gets a WM_QUIT message      *
*       (meaning the app was closed).                                       *
*                                                                           *
*                                                                           *
*   Arguments:                                                              *
*       HINSTANCE hInst: Instance handle of this instance of the app        *
*                                                                           *
*       HINSTANCE hPrev: Instance handle of previous instance, NULL if first*
*                                                                           *
*       LPSTR szCmdLine: ->null-terminated command line                     *
*                                                                           *
*       int sw: Specifies how the window is initially dispalyed             *
*                                                                           *
*   Return (int): The exit code as specified in the WM_QUIT message         *
*                                                                           *
*   History:                                                                *
*       07/19/93    T-OriG  Added this header and some functionality        *
*                                                                           *
\***************************************************************************/

// exit code values

#define SUCCESS 0
#define PROFILE_NOT_FOUND 1


int PASCAL WinMain
(
    HINSTANCE   hInst,
    HINSTANCE   hPrev,
    LPSTR       szCmdLine,
    int         sw
)
{

    MSG         msg;
    BOOL        bTSExit=FALSE;
    WNDCLASS    wc;
    int         iExitCode = SUCCESS;

//Added by t-rajr
#ifdef WIN32

    //
    // Save main thread ID
    //

    gdwMainThreadId = GetCurrentThreadId();

    //
    // Create an event for tstLogFlush synchronization
    //

    ghFlushEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // Initialize any critical sections used
    //

    InitializeCriticalSection(&gCSLog);

#endif

    //
    // Save instance handle for DialogBoxes
    //
    ghTSInstApp = hInst;

    //
    //  Getting full path for TstsHell.ini...
    //
    GetIniName (szTstsHellIni, sizeof(szTstsHellIni));

    //
    //  Calling init function for Text Window class.
    //

    TextInit(ghTSInstApp);

    //
    // Call initialization procedure
    //
    if ( ! AppInit (hInst, hPrev, sw, szCmdLine))
        return FALSE;

    //
    // set various logging levels, verification modes, etc.  This will
    // be over-ridden by anything specified in a profile on the cmd line.
    //
    resetEnvt();

    //
    // assign log file name and attributes. this does NOT open the log file.
    //
    setLogFileDefs();

    //
    // getLCL() also sets gbFileNamed if it finds a profile name on the
    // cmd line.
    //
    bTSExit = ParseCmdLine (szCmdLine);

    //
    //  Right here...  If there's a default profile, we're going to fool
    //  LoadProfile into thinking it was named on the command line.
    //

    getDefaultProfile();

    //
    // if a profile file was named on the cmd line, and it doesn't open
    // successfully, exit tstshell with an error code.
    //
    if (gbFileNamed && !LoadProfile(FALSE))
    {
       iExitCode = PROFILE_NOT_FOUND;
       tstLog (TERSE, "Profile %s did not open.", (LPSTR) szTSProfile);
    }

    //  Need to call the API before tstInit in case an app wants to log
    //  any thing before running test cases.
    //
    //  - RickB

    tstLogFlush();

    //
    // tstshell apps must have a tstInit(), in which they create windows, load
    // custom menu items, etc.
    //
    if (!tstInit (ghwndTSMain))
    {
        // If bTSExit is set, we are going to just exit after running the tests
        // so if tstInit failed, skip the message box.  This will help us
        // work with LOR.
        if (!bTSExit)
        {
            MessageBox (ghwndTSMain, "Test run aborted by test app during initialization",
                szTSTestName, MB_ICONEXCLAMATION | MB_OK);
        }

#ifdef  HCT
        return RS_CANT_RUN;
#else
        return FALSE;
#endif  //  HCT

    }

    //
    //  Note: Moving the addition of help menu from AppInit to WinMain...
    //  The help menu was not the last one on menu bar if applications
    //  added menu items in tstInit.
    //
    //  -Fwong.
    //

    tstInitHelpMenu();

    // init toolbar to reflect the state of the app
    {
    static UINT uLogID[] = { BTN_WPFOFF, BTN_WPFTERSE, BTN_WPFVERBOSE };
    static UINT uFileID[] = { BTN_FILEOFF, BTN_FILETERSE, BTN_FILEVERBOSE };

    toolbarModifyState (hwndToolBar, uLogID[gwTSLogLevel], BTNST_DOWN);
    toolbarModifyState (hwndToolBar, uFileID[gwTSFileLogLevel], BTNST_DOWN);
    }

    if (!gbTSAuto)
    {
        //
        // Poll messages from the event queue
        //
        while (GetMessage(&msg,NULL,0,0))
        {
            if (!TranslateAccelerator (ghwndTSMain, hAccel, &msg))
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }
        }
    }
    else
    {

        //
        // Run all the tests in the profile or in auto mode and scram
        //

        if (tstRunHdr.lpFirst != NULL) {
            SendMessage (ghwndTSMain, WM_COMMAND, MENU_RUN, 0L);
        }
    }

    tstTerminate ();
    removeRunCases();
    freeDynamicTests();

    //
    //  Calling End function for Text window class.
    //

    TextEnd(ghTSInstApp);

    //
    //  Fixing possible rips with different applications..
    //
//    if(GetClassInfo(hInst,szTSTestName,&wc))
//       UnregisterClass(szTSClass,hInst);
    if(GetClassInfo(hInst,szTSTestName,&wc))
    {
        UnregisterClass(szAppClass,hInst);
    }

    // The following code is strange.  Why post a message at this point, you
    // won't process it anyway 'cause you're about to exit...

    // if (bTSExit)
    // {
//#ifdef WIN32
    //     PostMessage(ghwndTSMain, WM_CLOSE, iExitCode, 0L);
//#else
//  ExitWindows(0,iExitCode);
//#endif
    // }

//Added by t-rajr
#ifdef WIN32
    DeleteCriticalSection(&gCSLog);
#endif


#ifdef  HCT
    if(gbAllTestsPassed)
    {
        return RS_PASSED;
    }
    else
    {
        return RS_FAILED;
    }
#else
    return msg.wParam;
#endif

} // end of WinMain



/*
@doc INTERNAL TESTBED
@api int | tstYesNoBox | Sends a string to a yesno dialog box

@parm LPSTR | lpszQuestion | The question to put in the box

@parm UINT | wDefault | The default answer to use if the dialog box
is suppressed.  Eg: IDYES, IDNO

@rdesc TST_PASS if the user's answer matched the default,
       TST_FAIL if the user's answer did not match,
       TST_OTHER if the the dialog box was supressed.

@comm Called by the tested program.  Logs result.
*/
int tstYesNoBox (
LPSTR lpszQuestion,
int   wDefault)
{
    if (gwTSVerification == LOG_MANUAL)
    return (MessageBox (ghwndTSMain, lpszQuestion, "Verify Test",
                MB_YESNO | MB_ICONQUESTION |
                (wDefault == IDYES ? MB_DEFBUTTON1 :
                         MB_DEFBUTTON2))
        == wDefault ? TST_PASS : TST_FAIL );
    else
    return TST_OTHER;

} /* end of tstYesNoBox */

/*
@doc INTERNAL TESTBED
@api HMENU | tstInstallCustomTest | Installs a custom menu item to the UI

@parm LPSTR | lspzMenuName | The name of the menu on which the item appears.
    This name must include an & characters that were in the original
    menu name.

@parm LPSTR | lpszMenuItem | The name of the menu item line.  If the
    name is "separator" then a horizontal dividing line is added instead.

@parm UINT | wID | The menu item ID.

@parm FARPROC | fpTest | A procedure to call when the menu item is
selected.  The procedure takes the same parameters as a window procedure

@rdesc The menu handle the item was added to or, if lpszMenuItem
       if NULL then the handle to the top level manu.
       Returns NULL on error.

@comm Called by the tested program.  If the menu name already exists,
    this item will be added to it.  If the item name is blank then
    selecting the menu will cause <p fpTest> to be called.  If the item
    name is blank then no other call to this function can specify the
    corresponding menu name.
*/
HMENU tstInstallCustomTest (
LPSTR lpszMenuName,
LPSTR lpszMenuItem,
UINT  wID,
DECLARE_TS_MENU_PTR(fpTest))
{
    int iCount = GetMenuItemCount (ghTSMainMenu);
    int ii;
    HMENU hMenu = NULL;
    BOOL bNewMenu = FALSE;
    char szBuf[40];

    if (wNextCustomMenuItem >= MAX_CUSTOM_MENU_ITEMS)
    return NULL;

    /* Does this menu exist already? */
    for (ii = CUSTOM_MENU_START; ii < iCount; ++ii)
    {
    szBuf[0] = '\0';
    GetMenuString (ghTSMainMenu, ii, szBuf, sizeof(szBuf), MF_BYPOSITION);
    if (lstrcmpi (szBuf, lpszMenuName) == 0) {
        hMenu = GetSubMenu (ghTSMainMenu, ii);
        break;
    }
    }

    /* No, so add a new menu */
    if (hMenu == NULL)
    {
    if (lpszMenuItem != NULL)
        if ((hMenu = CreatePopupMenu ()) == NULL)
        return NULL;

    if (!AppendMenu (ghTSMainMenu,
             MF_STRING | (lpszMenuItem == NULL ? 0 : MF_POPUP),
             (lpszMenuItem == NULL ? (UINT) wID : (UINT) hMenu),
             lpszMenuName))
        return NULL;

    DrawMenuBar (ghwndTSMain);
    if (lpszMenuItem == NULL)
    {
        CustomMenuItems[wNextCustomMenuItem].wID = wID;
        CustomMenuItems[wNextCustomMenuItem++].fpTest = fpTest;
        return ghTSMainMenu;
    }

    bNewMenu = TRUE;
    }

    /* Add the menu item */
    if (!AppendMenu (hMenu, MF_STRING |
             (lstrcmpi (lpszMenuItem, "separator") == 0 ?
             MF_SEPARATOR : 0)
             , wID, lpszMenuItem))
    {
    if (bNewMenu)
        DeleteMenu (hMenu, ii, MF_BYPOSITION);
    return NULL;
    }
    CustomMenuItems[wNextCustomMenuItem].wID = wID;
    CustomMenuItems[wNextCustomMenuItem++].fpTest = fpTest;
    return hMenu;
} /* end of tstInstallCustomTest */

/*
@doc INTERNAL TESTBED
@api BOOL | tstCheckRunStop | Called periodically by lengthy tests to allow the
operator to kill the test by pressing the specified virtual key

@rdesc TRUE if the test should be terminated
*/
BOOL tstCheckRunStop (
UINT  wVirtKey)
{

    return ((GetActiveWindow() == ghwndTSMain &&
        GetAsyncKeyState (wVirtKey) & 0x0001) ||
        gbGotWM_CLOSE);


}


/***************************************************************************\
*                                                                           *
*   LRESULT FindProc                                                        *
*                                                                           *
*   Description:                                                            *
*       This function handles message belonging to the "Find" dialog for    *
*       searching.                                                          *
*                                                                           *
*   Arguments:                                                              *
*       HWND hDlg:      window handle of about dialog window                *
*                                                                           *
*       UINT uiMessage: message number                                      *
*                                                                           *
*       UINT wParam:    message-dependent                                   *
*                                                                           *
*       long lParam:    message-dependent                                   *
*                                                                           *
*   Return (BOOL):      TRUE if message has been processed, else FALSE.     *
*                                                                           *
*   History:                                                                *
*       11/23/94    Fwong       Adding "find" capabilities.                 *
*                                                                           *
\***************************************************************************/


LRESULT CALLBACK FindProc
(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            Edit_SetText(GetDlgItem(hDlg,TS_FINDEDIT),szSearchString);

            if(fdwTstsHell & TSTSHELLFLAG_SEARCHMATCHCASE)
            {
                //
                //  Checked!
                //

                CheckDlgButton(hDlg,TS_FINDCASE,1);
            }
            else
            {
                //
                //  Unchecked!
                //

                CheckDlgButton(hDlg,TS_FINDCASE,0);
            }

            return TRUE;

        case WM_SYSCOMMAND:
            switch (wParam)
            {
                case SC_CLOSE:
                    EndDialog(hDlg,0);

                default:
                    break;
            }

        case WM_COMMAND:
            switch (wParam)
            {
                case TS_FINDOK:
                    Edit_GetText(
                        GetDlgItem(hDlg,TS_FINDEDIT),
                        szSearchString,
                        sizeof(szSearchString));

                    if(IsDlgButtonChecked(hDlg,TS_FINDCASE))
                    {
                        fdwTstsHell |= TSTSHELLFLAG_SEARCHMATCHCASE;
                    }
                    else
                    {
                        fdwTstsHell &= (~TSTSHELLFLAG_SEARCHMATCHCASE);
                    }

                    EndDialog(hDlg,1);
                    break;

                case IDCANCEL:
                case TS_FINDCANCEL:
                    EndDialog(hDlg,0);

                default:
                    break;
            }
        break;
    }
    return FALSE;
} // FindProc()


/***************************************************************************\
*                                                                           *
*   int Find                                                                *
*                                                                           *
*   Description:                                                            *
*       Invokes the find dialog box.                                        *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (int):                                                           *
*       Return value from DialogBox                                         *
*                                                                           *
*   History:                                                                *
*       11/23/94    Fwong       Adding "find" capabilities.                 *
*                                                                           *
\***************************************************************************/

int Find
(
    void
)
{
    FARPROC         fpfn;
    int             iReturn;
    
    fpfn = MakeProcInstance ((FARPROC)FindProc,ghTSInstApp);
    iReturn = DialogBox (ghTSInstApp, "FindDlg", ghwndTSMain,(DLGPROC)fpfn);
    FreeProcInstance(fpfn);

    return iReturn;
} // Find()


/***************************************************************************\
*                                                                           *
*   BOOL AppAboutDlgProc                                                    *
*                                                                           *
*   Description:                                                            *
*       This function handles messages belonging to the "About" dialog box. *
*       The only message that it looks for is WM_COMMAND, indicating the use*
*       has pressed the "OK" button.  When this happens, it takes down      *
*       the dialog box.                                                     *
*                                                                           *
*                                                                           *
*   Arguments:                                                              *
*       HWND hDlg:      window handle of about dialog window                *
*                                                                           *
*       UINT uiMessage: message number                                      *
*                                                                           *
*       UINT wParam:    message-dependent                                   *
*                                                                           *
*       long lParam:    message-dependent                                   *
*                                                                           *
*   Return (BOOL):      TRUE if message has been processed, else FALSE.     *
*                                                                           *
*   History:                                                                *
*       07/29/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL FAR PASCAL EXPORT AppAboutDlgProc
(
    HWND    hDlg,
    UINT    uiMessage,
    UINT    wParam,
    long    lParam
)
{
    char szBuf[320];
    UINT wID;

    switch (uiMessage)
    {
    case WM_COMMAND:
        wID=GET_WM_COMMAND_ID(wParam,lParam);
        if (wID == IDOK)
        {
        EndDialog(hDlg,TRUE);
        }
        break;

    case WM_INITDIALOG:

        //
        //  Hmm.. You may not like my fix... but it compiles cleanly...
        //
        //  -Fwong.
        //

        wsprintf(szBuf,
        (LPSTR)"%s %d.%02d\n\n%s",
        (LPSTR)szTSTestName,
        HIBYTE(MMTST_VERSION),
        (MMTST_VERSION & 0xff),
//        LOBYTE(MMTST_VERSION),
        (LPSTR)"(c) Copyright Microsoft Corp. 1994 All Rights Reserved");

        SetDlgItemText(hDlg, TS_ABOUTTEXT, (LPSTR)szBuf);


        return TRUE;
    }
    return FALSE;
    lParam;     // Use formal parameter
}

/***************************************************************************\
*                                                                           *
*   void About                                                              *
*                                                                           *
*   Description:                                                            *
*       Invokes the about idalog box.                                                                    *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/29/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void About
(
    void
)
{
    FARPROC         fpfn = MakeProcInstance ((FARPROC)AppAboutDlgProc,
                         ghTSInstApp);

    DialogBox (ghTSInstApp, "AboutBox", ghwndTSMain,(DLGPROC)fpfn);
    FreeProcInstance(fpfn);
} /* end of about box */



/***************************************************************************\
*                                                                           *
*   void helpToolBar                                                        *
*                                                                           *
*   Description:                                                            *
*       Explains the ToolBar items.                                         *
*                                                                           *
*   Arguments:                                                              *
*       int iButton:                                                        *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/27/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void helpToolBar
(
    int iButton
)
{
    tstGetStatusBar (lpszPrevContent, BUFFER_LENGTH);

    switch (iButton)
    {
    case BTN_OPEN:
        tstLogStatusBar ("Load a profile");
        break;
    case BTN_SAVE:
        tstLogStatusBar ("Save current settings as a profile");
        break;
    case BTN_RUN:
        tstLogStatusBar ("Run all selected test cases");
        break;
    case BTN_RUNMIN:
        tstLogStatusBar ("Minimize and run all selected test cases");
        break;
    case BTN_RUNALL:
        tstLogStatusBar ("Select all test cases and run them");
        break;
    case BTN_EDIT:
        tstLogStatusBar ("Edit the log file");
        break;
    case BTN_CLEAR:
        tstLogStatusBar ("Clear the logging window");
        break;
    case BTN_SELECT:
        tstLogStatusBar ("Invoke the select test cases dialog box");
        break;
    case BTN_SETLOGGING:
        tstLogStatusBar ("Invoke the set logging dialog box");
        break;
    case BTN_FILEOFF:
        tstLogStatusBar ("Disables file logging");
        break;
    case BTN_FILETERSE:
        tstLogStatusBar ("Enables terse file logging");
        break;
    case BTN_FILEVERBOSE:
        tstLogStatusBar ("Enables verbose file logging");
        break;
    case BTN_WPFOFF:
        tstLogStatusBar ("Disables window logging");
        break;
    case BTN_WPFTERSE:
        tstLogStatusBar ("Enables terse window logging");
        break;
    case BTN_WPFVERBOSE:
        tstLogStatusBar ("Enables verbose window logging");
        break;
    }
}




/***************************************************************************\
*                                                                           *
*   void restoreStatusBar                                                   *
*                                                                           *
*   Description:                                                            *
*       Restores the content of the status bar.                             *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/27/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void restoreStatusBar
(
    void
)
{
    tstLogStatusBar (lpszPrevContent);
}






/***************************************************************************\
*                                                                           *
*   void tstInstallDefWindowProc                                            *
*                                                                           *
*   Description:                                                            *
*       Install the default window procedure and replaces the default       *
*       DefWindowProc.                                                      *
*                                                                           *
*   Arguments:                                                              *
*       LRESULT (CALLBACK* tstDWP) (HWND, UINT, WPARAM, LPARAM):            *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/05/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void tstInstallDefWindowProc
(
    LRESULT (CALLBACK* tstDWP) (HWND, UINT, WPARAM, LPARAM)
)
{
    tstDefWindowProc = tstDWP;
    return;
}




/***************************************************************************\
*                                                                           *
*   BOOL tstLogStatusBar                                                    *
*                                                                           *
*   Description:                                                            *
*       Logs a line to the status bar                                       *
*                                                                           *
*   Arguments:                                                              *
*       LPSTR lpszLogData:  The text to log                                 *
*                                                                           *
*   Return (BOOL):  TRUE if succeeded, FALSE if failed.                     *
*                                                                           *
*   History:                                                                *
*       07/09/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL tstLogStatusBar
(
    LPSTR   lpszLogData
)
{
    if (lpszLogData == NULL)
    {
    lpszLogData = (LPSTR) "";
    }

    lstrcpy (szStatusText, lpszLogData);

    InvalidateRect (hwndStatusBar, NULL, TRUE);
    UpdateWindow (hwndStatusBar);
    tstWinYield();
    return TRUE;
}



/***************************************************************************\
*                                                                           *
*   void tstGetStatusBar                                                    *
*                                                                           *
*   Description:                                                            *
*       Gets the content of the status bar.                                 *
*                                                                           *
*   Arguments:                                                              *
*       LPSTR lpszLogData:                                                  *
*                                                                           *
*       int cbMax:                                                          *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/27/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

int tstGetStatusBar
(
    LPSTR   lpszLogData,
    int     cbMax
)
{
    int i=0;

    while (i<cbMax)
    {
    lpszLogData[i] = szStatusText[i];
    if (!((char) szStatusText[i]))
    {
        break;
    }
    i++;
    }
    return i;
}



/***************************************************************************\
*                                                                           *
*   int tstDisplayCurrentTest                                               *
*                                                                           *
*   Description:                                                            *
*       Displays the current running test on the status bar.                *
*                                                                           *
*   Arguments:                                                              *
*       None:                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/09/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void tstDisplayCurrentTest
(
    void
)
{
    fDisplayCurrentTest = TRUE;
    return;
}








/***************************************************************************\
*                                                                           *
*   void tstChangeStopVKey                                                  *
*                                                                           *
*   Description:                                                            *
*       Change the virtual key which stops the tests                        *
*                                                                           *
*   Arguments:                                                              *
*       int vKey:                                                           *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/12/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void tstChangeStopVKey
(
    int vKey
)
{
    iStopVKey = vKey;
    return;
}





/***************************************************************************\
*                                                                           *
*   int tstGetProfileString                                                 *
*                                                                           *
*   Description:                                                            *
*       Gets application-specific profile information                       *
*                                                                           *
*   Arguments:                                                              *
*       LPCSTR lpszEntry:                                                   *
*                                                                           *
*       LPCSTR lpszDefault:                                                 *
*                                                                           *
*       LPSTR lpszReturnBuffer:                                             *
*                                                                           *
*       int cbReturnBuffer:                                                 *
*                                                                           *
*   Return (int):                                                           *
*                                                                           *
*   History:                                                                *
*       07/12/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

int tstGetProfileString
(
    LPCSTR  lpszEntry,
    LPCSTR  lpszDefault,
    LPSTR   lpszReturnBuffer,
    int     cbReturnBuffer
)
{
    return (GetPrivateProfileString (szTSTestName,
    lpszEntry,
    lpszDefault,
    lpszReturnBuffer,
    cbReturnBuffer,
    szTstsHellIni));
}





/***************************************************************************\
*                                                                           *
*   BOOL tstWriteProfileString                                              *
*                                                                           *
*   Description:                                                            *
*       Writes application-specific profile information                     *
*                                                                           *
*   Arguments:                                                              *
*       LPCSTR lpszSection:                                                 *
*                                                                           *
*       LPCSTR lpszEntry:                                                   *
*                                                                           *
*       LPCSTR lpszString:                                                  *
*                                                                           *
*   Return (BOOL):                                                          *
*                                                                           *
*   History:                                                                *
*       07/12/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL tstWriteProfileString
(
    LPCSTR  lpszEntry,
    LPCSTR  lpszString
)
{
    return (WritePrivateProfileString(szTSTestName,
    lpszEntry,
    lpszString,
    szTstsHellIni));
}

/***************************************************************************\
*                                                                           *
*   int tstDummyFn                                                          *
*                                                                           *
*   Description:                                                            *
*       Just a blank fn as default custom info read/write handler           *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       06/30/94    AlokC  Added this function.                             *
*                                                                           *
\***************************************************************************/

VOID CALLBACK tstDummyFn
(
    LPCSTR lpszFile
)
{
    return ;
}


/***************************************************************************\
*                                                                           *
*   void tstInstallReadCustomInfo                                           *
*                                                                           *
*   Description:                                                            *
*       Install the Custom read handler and replace the default             *
*       handler (tstDummyFn).                                               *
*                                                                           *
*   Arguments:                                                              *
*       VOID (CALLBACK* tstReadCI) (LPCSTR):                                *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       06/30/94    AlokC                                                   *
*                                                                           *
\***************************************************************************/

void tstInstallReadCustomInfo
(
    void (CALLBACK* tstReadCI) (LPCSTR)
)
{
    tstReadCustomInfo = tstReadCI;
    return;
}


/***************************************************************************\
*                                                                           *
*   void tstInstallWriteCustomInfo                                          *
*                                                                           *
*   Description:                                                            *
*       Install the Custom write handler and replace the default            *
*       handler (tstDummyFn).                                               *
*                                                                           *
*   Arguments:                                                              *
*       VOID (CALLBACK* tstWriteCI) (LPCSTR):                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       06/30/94    AlokC                                                   *
*                                                                           *
\***************************************************************************/

void tstInstallWriteCustomInfo
(
    void (CALLBACK* tstWriteCI) (LPCSTR)
)
{
    tstWriteCustomInfo = tstWriteCI;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tsseltst.c ===
/***************************************************************************\
*                                                                           *
*   File: Tsseltst.c                                                        *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:  This module deals with the selection of tests.               *
*                                                                           *
*                                                                           *
*   Contents:                                                               *
*       calculateNumResourceTests()                                         *
*       tstAddTestCase()                                                    *
*       VLoadListResource()                                                 *
*       VFreeListResource()                                                 *
*       VLockListResource()                                                 *
*       VUnlockListResource()                                               *
*       freeDynamicTests()                                                  *
*       tstAddNewString()                                                   *
*       tstLoadString()                                                     *
*       placeAllCases()                                                     *
*       addRunCase()                                                        *
*       removeRunCases()                                                    *
*       MakeDefaultLogName()                                                *
*       resetEnvt()                                                         *
*       sendLBSetData()                                                     *
*       getLBSetData()                                                      *
*       incTstCasePtr()                                                     *
*       MeasureItem()                                                       *
*       DrawItem()                                                          *
*       writeFilePrompt()                                                   *
*       writeLogLvl()                                                       *
*       LoadProfile()                                                       *
*       SaveProfile()                                                       *
*       addTstCaseEntry()                                                   *
*       addItemSel()                                                        *
*       addItemSelFromRes()                                                 *
*       addGroupSel()                                                       *
*       addGroupImodeSel()                                                  *
*       delItemSel()                                                        *
*       PrintRunList()                                                      *
*       initEnterTstList()                                                  *
*       addModeTstCases()                                                   *
*       SelectDlgProc()                                                     *
*       Select()                                                            *
*                                                                           *
*   History:                                                                *
*       02/18/91    prestonb   Created from tst.c                           *
*       07/11/93    T-OriG     Added new functionality and this header      *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>
// #include "mprt1632.h"
#include "support.h"
#include <gmem.h>
#include <stdio.h>
#include <defdlg.h>
#include "tsdlg.h"
#include "tsglobal.h"
#include "tsstats.h"
#include <tsextern.h>
#include "tslog.h"
#include "tsmain.h"
#include "text.h"
#include <commdlg.h>
#include <dlgs.h>
#include "toolbar.h"
#include "tsseltst.h"

#define write(a,b) _lwrite(a,b,lstrlen(b))

#define writeln(hFile, string) (write (hFile, string), \
                                write (hFile, "\015\012"))
/* Internal Functions */
HGLOBAL VLoadListResource(HINSTANCE hInst, HRSRC hrsrc);
BOOL VFreeListResource(HGLOBAL hglbResource);
void FAR* VLockListResource(HGLOBAL hglb);
BOOL VUnlockListResource(HGLOBAL hglb);
void addRunCase(int);
void sendLBSetData(HWND, int, int, int);
void getLBSetData(HWND, int, PINT, PINT);
LPWORD incTstCasePtr(LPWORD);
void initEnterTstList(int ListMode,BOOL bToggle);
void incItemSel(HWND,int);
void decItemSel(HWND,int);
void writeFilePrompt(HFILE,LPSTR);
void writeLogLvl(HFILE,int);
// kfs void MakeDefaultLogName(LPSTR szTSLogfile);
void addGroupSel(int Selection, LPTST_ITEM_STRUCT CaseSearchPtr);



// Module Global Variables
int                 iNumResourceTests = 0;
int                 iNumDynamicTests  = 0;
HGLOBAL             hDynamicTests = NULL;

int                 iNumStrRes = 0;
HGLOBAL             hStrRes = NULL;


/***************************************************************************\
*                                                                           *
*   void calculateNumResourceTests                                          *
*                                                                           *
*   Description:                                                            *
*       Calculates the number of tests in the resource file                 *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/10/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void calculateNumResourceTests
(
    void
)
{
    HANDLE               hListRes;
    LPTST_ITEM_RC_STRUCT lpCaseData;

    hListRes = LoadResource(ghTSInstApp,
        FindResource(ghTSInstApp,MAKEINTRESOURCE(giTSCasesRes),RT_RCDATA));
    lpCaseData = (LPTST_ITEM_RC_STRUCT) LockResource(hListRes);

    for (iNumResourceTests=0; lpCaseData->wStrID != (WORD) TST_LISTEND; lpCaseData++)
    {
        if ((lpCaseData->wPlatformId & wPlatform) == wPlatform)
        {        
            iNumResourceTests++;
        }
    }

    UnlockResource(hListRes);
    FreeResource(hListRes);
    return;
}




/***************************************************************************\
*                                                                           *
*   void tstAddTestCase                                                     *
*                                                                           *
*   Description:                                                            *
*       Dynamically adds a new test case to the execution list.  It MUST be *
*       called during TstInit.                                              *
*                                                                           *
*   Arguments:                                                              *
*       WORD wStrID:                                                        *
*                                                                           *
*       WORD iMode:                                                         *
*                                                                           *
*       WORD iFxID:                                                         *
*                                                                           *
*       WORD wGroupId:                                                      *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/10/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void tstAddTestCase
(
    WORD    wStrID,
    WORD    iMode,
    WORD    iFxID,
    WORD    wGroupId
)
{
    LPTST_ITEM_STRUCT   lpDynamicTests;

    iNumDynamicTests++;    

    if (iNumDynamicTests == 1)
    {
        hDynamicTests = GlobalAlloc (GMEM_MOVEABLE,
            iNumDynamicTests * sizeof (TST_ITEM_STRUCT));
    }
    else
    {
        hDynamicTests = GlobalReAlloc (hDynamicTests,
            iNumDynamicTests * sizeof (TST_ITEM_STRUCT),
            GMEM_MOVEABLE);
    }

    lpDynamicTests = GlobalLock (hDynamicTests);

    lpDynamicTests += (iNumDynamicTests - 1);
    lpDynamicTests -> wStrID = wStrID;
    lpDynamicTests -> iMode  = iMode;
    lpDynamicTests -> iFxID  = iFxID;
    lpDynamicTests -> wGroupId = wGroupId;

    GlobalUnlock (hDynamicTests);
    return;
}



/***************************************************************************\
*                                                                           *
*   HGLOBAL VLoadListResource                                               *
*                                                                           *
*   Description:                                                            *
*       Emulates the loading of the list resource                           *
*                                                                           *
*   Arguments:                                                              *
*       HINSTANCE hInst:                                                    *
*                                                                           *
*       HRSRC hrsrc:                                                        *
*                                                                           *
*   Return (HGLOBAL):                                                       *
*                                                                           *
*   History:                                                                *
*       07/10/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

HGLOBAL VLoadListResource
(
    HINSTANCE   hInst,
    HRSRC       hrsrc
)
{
    HGLOBAL              hList, hResource;    
    LPTST_ITEM_RC_STRUCT lpResource;
    LPTST_ITEM_STRUCT    lpList, lpDynamicTests;

    hList = GlobalAlloc (GMEM_MOVEABLE, 
        (iNumResourceTests + iNumDynamicTests + 1) * sizeof (TST_ITEM_STRUCT));
    lpList = GlobalLock (hList);
    hResource = LoadResource (hInst, hrsrc);
    lpResource = LockResource (hResource);
    if (hDynamicTests)
    {
        lpDynamicTests = GlobalLock (hDynamicTests);
    }

    // Copy appropriate static tests
    while (lpResource->wStrID != (WORD) TST_LISTEND)
    {
        //
        // The following statement determines which test will be show in
        // the list box and which will not.  Also look at counting logic
        // in calculateNumResourceTests.
        //
        if ((lpResource->wPlatformId & wPlatform) == wPlatform)
        {
            lpList->wStrID   = lpResource->wStrID;
            lpList->iMode    = lpResource->iMode;
            lpList->iFxID    = lpResource->iFxID;
            lpList->wGroupId = lpResource->wGroupId;
            lpList++;
        }
        lpResource++;
    }

    // Copy dynamic tests
    if (hDynamicTests)
    {
#ifdef WIN32
        memcpy (lpList,
            lpDynamicTests,
            iNumDynamicTests * sizeof (TST_ITEM_STRUCT));
#else
        hmemcpy (lpList,
            lpDynamicTests,
            iNumDynamicTests * sizeof (TST_ITEM_STRUCT));
#endif  //  WIN32
    }


    (lpList + iNumDynamicTests)->wStrID = (WORD) TST_LISTEND;

    if (hDynamicTests)
    {
        GlobalUnlock (hDynamicTests);
    }
    UnlockResource (hResource);
    FreeResource (hResource);
    GlobalUnlock (hList);
    return hList;
}






/***************************************************************************\
*                                                                           *
*   BOOL VFreeListResource                                                  *
*                                                                           *
*   Description:                                                            *
*       Emulates freeing a test list resource                               *
*                                                                           *
*   Arguments:                                                              *
*       HGLOBAL hglbResource:                                               *
*                                                                           *
*   Return (BOOL):                                                          *
*                                                                           *
*   History:                                                                *
*       07/10/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL VFreeListResource
(
    HGLOBAL hglbResource
)
{
    return (GlobalFree (hglbResource) != NULL);
}




/***************************************************************************\
*                                                                           *
*   void VLockListResource                                                  *
*                                                                           *
*   Description:                                                            *
*       Emulates locking of a resource                                      *
*                                                                           *
*   Arguments:                                                              *
*       HGLOBAL hglb:                                                       *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/10/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void FAR* VLockListResource
(
    HGLOBAL hglb
)
{
    return (GlobalLock (hglb));
}



/***************************************************************************\
*                                                                           *
*   BOOL VUnlockListResource                                                *
*                                                                           *
*   Description:                                                            *
*       Emulates unlocking of a resource                                    *
*                                                                           *
*   Arguments:                                                              *
*       HGLOBAL hglb:                                                       *
*                                                                           *
*   Return (BOOL):                                                          *
*                                                                           *
*   History:                                                                *
*       07/10/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL VUnlockListResource
(
    HGLOBAL hglb
)
{
    return (GlobalUnlock (hglb));
}







/***************************************************************************\
*                                                                           *
*   void freeDynamicTests                                                   *
*                                                                           *
*   Description:                                                            *
*       Frees global memory allocated by this module                        *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/11/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void freeDynamicTests
(
    void
)
{
    if (hDynamicTests)
    {
        GlobalFree (hDynamicTests);
    }

    if (hStrRes)
    {
        GlobalFree (hStrRes);
    }

    return;
}




/***************************************************************************\
*                                                                           *
*   BOOL tstAddNewString                                                    *
*                                                                           *
*   Description:                                                            *
*       Adds a new string to the virual string table                        *
*                                                                           *
*   Arguments:                                                              *
*       WORD wStrID:                                                        *
*                                                                           *
*       LPSTR lpszData:                                                     *
*                                                                           *
*   Return (BOOL):                                                          *
*                                                                           *
*   History:                                                                *
*       07/11/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL tstAddNewString
(
    WORD    wStrID,
    LPSTR   lpszData
)
{
    LPTST_STR_STRUCT    lpStrRes;

    if (lstrlen (lpszData) > MAXRESOURCESTRINGSIZE)
    {
        return FALSE;
    }

    iNumStrRes++;
        if (iNumStrRes==1)
    {
        hStrRes = GlobalAlloc (GMEM_MOVEABLE,
            (iNumStrRes * sizeof(TST_STR_STRUCT)));            
    }
    else
    {
        hStrRes = GlobalReAlloc (hStrRes,
            (iNumStrRes * sizeof(TST_STR_STRUCT)),
            GMEM_MOVEABLE);
    }

    lpStrRes = GlobalLock (hStrRes);
    lpStrRes += iNumStrRes - 1;    
    lpStrRes->wStrID = wStrID;
    lstrcpy (lpStrRes->lpszData, lpszData);
    GlobalUnlock (hStrRes);

    return TRUE;
}





/***************************************************************************\
*                                                                           *
*   int tstLoadString                                                       *
*                                                                           *
*   Description:                                                            *
*       Loads string from the virtual string table.                         *
*                                                                           *
*   Arguments:                                                              *
*       HINSTANCE hInst:                                                    *
*                                                                           *
*       UINT idResource:                                                    *
*                                                                           *
*       LPSTR lpszBuffer:                                                   *
*                                                                           *
*       int cbBuffer:                                                       *
*                                                                           *
*   Return (int):                                                           *
*                                                                           *
*   History:                                                                *
*       07/11/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

int tstLoadString
(
    HINSTANCE   hInst,
    UINT        idResource,
    LPSTR       lpszBuffer,
    int         cbBuffer
)
{
    LPTST_STR_STRUCT    lpStrRes;
    int                 i, j;

    if (iNumStrRes > 0)
    {
        lpStrRes = GlobalLock (hStrRes);
        for (i=0; i<iNumStrRes; i++)
        {
            if (lpStrRes->wStrID == idResource)
            {
                if (lstrlen(lpStrRes->lpszData) > (cbBuffer-1))
                {
                    for (j=0; j<(cbBuffer-1); j++)
                    {
                        lpszBuffer[j] = lpStrRes->lpszData[j];
                    }

                    //lstrcpyn (lpszBuffer, lpStrRes->lpszData, (cbBuffer-1));
                    lpszBuffer[cbBuffer-1] = 0;
                    GlobalUnlock (hStrRes);
                    return cbBuffer;
                }
                else
                {
                    lstrcpy (lpszBuffer, lpStrRes->lpszData);
                    GlobalUnlock (hStrRes);
                    return lstrlen (lpszBuffer);
                }
            }
            lpStrRes++;
        }
        GlobalUnlock (hStrRes);
    }

    return (LoadString (hInst, idResource, lpszBuffer, cbBuffer));
}




/***************************************************************************\
*                                                                           *
*   void placeAllCases                                                      *
*                                                                           *
*   Description:                                                            *
*       Places all the cases in the run list.                               *
*                                                                           *
*   Arguments:                                                              *
*       None.                                                               *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/27/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void placeAllCases
(
    void
)
{
    int i;

    removeRunCases();
    for (i=1; i<=(iNumResourceTests + iNumDynamicTests); i++)
    {
        addRunCase (i);
    }
    return;
}



/*----------------------------------------------------------------------------
This function adds a test case number to a list of test case numbers to be
executed.
----------------------------------------------------------------------------*/
void addRunCase
(
    int iCaseNum
)
{
    LPTST_RUN_STRUCT   lpNewCase;
    HGLOBAL hMem;

    hMem = GlobalAlloc(GHND,sizeof(TST_RUN_STRUCT));
    lpNewCase = (LPTST_RUN_STRUCT)GlobalLock(hMem);
    lpNewCase->iCaseNum = iCaseNum;
    lpNewCase->lpNext = NULL;

    /* Add the test case element to the list of test case elements */
    if (tstRunHdr.lpFirst == NULL) {
        tstRunHdr.lpFirst = lpNewCase;
        tstRunHdr.lpLast = lpNewCase;
    } else {
        tstRunHdr.lpLast->lpNext = lpNewCase;
        tstRunHdr.lpLast = lpNewCase;
    }
} /* end of addRunCase */


/*----------------------------------------------------------------------------
This function frees the memory allocated for the test cases run list and
reinitializes the header pointers to NULL.
----------------------------------------------------------------------------*/
void removeRunCases
(
    void
)
{
    LPTST_RUN_STRUCT  lpTraverse;

    while (tstRunHdr.lpFirst != NULL) 
    {
        lpTraverse = tstRunHdr.lpFirst;
        tstRunHdr.lpFirst = lpTraverse->lpNext;
//        GFreePtr(lpTraverse);
        GlobalFreePtr(lpTraverse);
    }

    /* Reinitialize the pointers for the test cases run list */

    tstRunHdr.lpFirst = NULL;
    tstRunHdr.lpLast = NULL;

} /* end of removeRunCases */


void MakeDefaultLogName
(
    LPSTR   lpName
)
{
    char szModule[BUFFER_LENGTH];
    int i,j,iNameLen;

    if (!GetModuleFileName(ghTSInstApp,szModule,BUFFER_LENGTH)) 
    {
        lstrcpy(szModule,"c:\\TstShell.log");
    }

    iNameLen=lstrlen(szModule);
    for(i=iNameLen;i>0;i--) 
    {
        if (szModule[i] == '\\') 
        {
            break;
        }
    }

    for(j=0;j<(iNameLen-i);j++) 
    {
        szModule[j] = szModule[j+i+1];
    }

    iNameLen -= (i+1) ;  // w/o +1 it takes 1 more char: AlokC--03/02/94
    for(i=iNameLen;i>=0;i--) 
    {
        if (szModule[i] == '.') 
        {
            break;
        }
    }

    if (i) 
    {
        lstrcpy(&szModule[i+1],"LOG");
    } 
    else 
    {
        lstrcat(szModule,".LOG");
    }

    lstrcpy(lpName,szModule);
}

/*----------------------------------------------------------------------------
This function resets the environment variables for executing test cases.
----------------------------------------------------------------------------*/
void resetEnvt
(
    void
)
{
    gwTSLogOut = LOG_WINDOW;
    gwTSLogLevel = TERSE;
    gwTSFileLogLevel = VERBOSE;
    toolbarModifyState (hwndToolBar, BTN_WPFTERSE, BTNST_DOWN);
    toolbarModifyState (hwndToolBar, BTN_FILEVERBOSE, BTNST_DOWN);
    gwTSFileMode = LOG_OVERWRITE;
    gwTSVerification = LOG_AUTO;
    giTSRunCount = 1;
    gwTSStepMode = FALSE;
    gwTSRandomMode = FALSE;
    gwTSScreenSaver = SSAVER_DISABLED;

// kfs 2/17/93   getIniStrings();
//               setLogFileDefs();

    giTSIndenting = 0;

} /* end of resetEnvt */


/*----------------------------------------------------------------------------
This function creates the item data and sets it in the listbox.
----------------------------------------------------------------------------*/
void sendLBSetData
(
    HWND    hwndList,
    int     iItem,
    int     iCaseNum,
    int     iNumSelected
)
{
    DWORD  dwSetData;

    /* Store the case number in the low word and the selection boolean
       in the high word */

    dwSetData = MAKELONG(iCaseNum,iNumSelected);
    SendMessage (hwndList, LB_SETITEMDATA, iItem, dwSetData);
} /* end of sendLBSetData */



/*----------------------------------------------------------------------------
This function gets data associated with an item in the listbox and returns
the data.
----------------------------------------------------------------------------*/
void getLBSetData
(
    HWND    hwndList,
    int     iItem,
    PINT    iCaseNum,
    PINT    iNumSelected
)
{
    DWORD  dwSetData;

    /* Get the data for the item specified and return it */

    dwSetData = SendMessage (hwndList, LB_GETITEMDATA, iItem, 0L);
    *iCaseNum = LOWORD(dwSetData);
    *iNumSelected = HIWORD(dwSetData);
} /* end of getLBSetData */


/*----------------------------------------------------------------------------
This function increments a test case resource pointer to the next user
defined test case resource.
----------------------------------------------------------------------------*/
LPWORD incTstCasePtr
(
    LPWORD  lpTstCasePtr
)
{
    LPTST_ITEM_STRUCT  lpCaseData;

    lpCaseData = (LPTST_ITEM_STRUCT)lpTstCasePtr;
    return((LPWORD)(++lpCaseData));
} /* end of incTstCasePtr */



/*----------------------------------------------------------------------------
This function handles the WM_MEASUREITEM message, calculating the item 
height using the current font of the listbox.
----------------------------------------------------------------------------*/
void NEAR PASCAL MeasureItem
(
    HWND                hwnd,
    LPMEASUREITEMSTRUCT lpms
)
{
    TEXTMETRIC   tm;
    HFONT        hFont;
    HFONT        hFontPrev;
    HDC          hdc;

    hdc = GetDC(hwnd);

    hFont = (HFONT) SendDlgItemMessage(hwnd, lpms->CtlID, WM_GETFONT, 0, 0L);
    if (hFont == NULL) {
        hFont = GetStockObject(SYSTEM_FONT);
    }
  
    hFontPrev = SelectObject(hdc, hFont);
    GetTextMetrics(hdc, &tm);
    SelectObject(hdc, hFontPrev);
    ReleaseDC(hwnd, hdc);
  
    lpms->itemWidth = 0;                // not used value

    /*  Select either text height, or the size of the bitmap, whichever
        is larger, as the size of the item */
    lpms->itemHeight = tm.tmHeight;
} /* end of MeasureItem */


/*----------------------------------------------------------------------------
This function draws an item into a listbox.
----------------------------------------------------------------------------*/
void DrawItem
(
    HWND                hwnd,
    LPDRAWITEMSTRUCT    lpds
)
{
    RECT   rc;         /* item rect */
    char          ach[150];
    LPSTR  lpText;     /* floating ptr to text string */
    int    ItemLen;
    DWORD  dwTextPrev; /* previous HDC text color */
    DWORD  dwBkPrev;   /* previous HDC bkgnd color      */
    BOOL   bSelect;
    int    ii;
    int    iNumSelected;

    if (lpds->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {
        rc = lpds->rcItem;
  
    //
    //  Is the item selected?  
    //
        bSelect = lpds->itemState & ODS_SELECTED;

    //
    //  Deal with the Selection rectangle. Fix colors in hDC 
    //  depending on selection mode
    //
        getLBSetData(lpds->hwndItem,lpds->itemID,&ii,&iNumSelected);
        if (bSelect) 
        {
            dwBkPrev = SetBkColor(lpds->hDC, GetSysColor(COLOR_HIGHLIGHT));
            dwTextPrev = SetTextColor (lpds->hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
        } 
        else 
        {
            dwBkPrev = SetBkColor(lpds->hDC, GetSysColor(COLOR_WINDOW));
            dwTextPrev = SetTextColor (lpds->hDC,GetSysColor(COLOR_WINDOWTEXT));
        }

    //
    // Get the text to write 
    //
        SendMessage(lpds->hwndItem, 
            LB_GETTEXT, 
            lpds->itemID,
            (LONG)(LPSTR) ach);
        ItemLen = lstrlen(ach);
        lpText = ach;
        
    //
    // Draw the text and background rectangle 
    //
        ExtTextOut(lpds->hDC, 
            rc.left, 
            rc.top,
            ETO_OPAQUE, 
            &rc, 
            lpText, 
            ItemLen, 
            NULL);

    //
    // restore old hDC colors if changed them 
    //
        SetBkColor(lpds->hDC, dwBkPrev);
        SetTextColor(lpds->hDC, dwTextPrev);

    }

    hwnd; //Reference formal parameter
} /* end of DrawItem */


/*----------------------------------------------------------------------------
This function writes a prompt string and "=" into a profile file. 
----------------------------------------------------------------------------*/
void writeFilePrompt
(
    HFILE   hFile,
    LPSTR   lpszStrPrompt
)
{
    write(hFile,lpszStrPrompt);
    write(hFile,"=");

} /* end of writeFilePrompt */


/*----------------------------------------------------------------------------
This function writes the log level string into a profile. 
----------------------------------------------------------------------------*/
void writeLogLvl
(
    HFILE   hFile,
    int     iLogLvl
)
{
    switch (iLogLvl)
    {
        case (LOG_NOLOG):
            writeln (hFile, "off");
            break;
        case (TERSE):
            writeln (hFile, "terse");
            break;
        case (VERBOSE):
            writeln (hFile, "verbose");
            break;
    }
} /* end of writeLogLvl */

 
#define GetItem(item) GetPrivateProfileString("settings", item, "", szBuf,\
                                              sizeof (szBuf), szTSProfile)





/***************************************************************************\
*                                                                           *
*   void addTestCase                                                        *
*                                                                           *
*   Description:                                                            *
*       Adds a test case to the run list if it may be run                   *
*                                                                           *
*   Arguments:                                                              *
*       LPTST_ITEM_STRUCT lpBegCaseData:                                    *
*                                                                           *
*       int iTmp:                                                           *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       07/28/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void addTestCase
(
    LPTST_ITEM_STRUCT   lpBegCaseData,
    int                 iTmp
)
{
    char    Buffer[BUFFER_LENGTH], str[BUFFER_LENGTH];
    int     i;

    for (i=0; i<iNumResourceTests; i++)
    {
        if (((int) lpBegCaseData[i].wStrID) == iTmp)
        {
            addRunCase (i+1);
            return;
        }
    }
    Buffer[0]=0;
    LoadString (ghTSInstApp, iTmp, Buffer, BUFFER_LENGTH);
    wsprintf (str,  "Error:  Test %s does not run on this platform", (LPSTR) Buffer);

    TextOutputString(ghTSWndLog,(LPSTR)str);
//    wpfOut (ghTSWndLog, (LPSTR) str);

    return;
}




/***************************************************************************\
*                                                                           *
*   BOOL LoadProfile                                                        *
*                                                                           *
*   Description:                                                            *
*       This function loads the settings from a profile that is selected.   *
*                                                                           *
*                                                                           *
*   Arguments:                                                              *
*       BOOL bMode:                                                         *
*                                                                           *
*   Return (BOOL):                                                          *
*                                                                           *
*   History:                                                                *
*       02/18/91    prestonB                                                *
*       07/12/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

BOOL LoadProfile
(
    BOOL    bMode
)
{
    char                szBuf[BUFFER_LENGTH+EXTRA_BUFFER],  FileTitle[255];
    int                 ii, iTmp;
    HFILE               hProfile;
    OPENFILENAME        of;
    HANDLE              hListRes;
    LPTST_ITEM_STRUCT   lpBegCaseData;



    if (bMode)
    {
        lstrcpy(szBuf,"*.pro");
        of.lStructSize  =sizeof(OPENFILENAME);
        of.hwndOwner    =ghwndTSMain;
        of.hInstance    = ghTSInstApp;
        of.lpstrFilter  ="Test Profiles (*.pro)\0*.pro\0All Files (*.*)\0*.*\0";
        of.lpstrCustomFilter=NULL;
        of.nMaxCustFilter=0;
        of.nFilterIndex =1;
        of.lpstrFile    =szBuf;
        of.nMaxFile     =255;
        of.lpstrFileTitle=FileTitle;
        of.nMaxFileTitle=255;
        of.lpstrInitialDir=".";
        of.lpstrTitle   ="Open Profile";
        of.Flags        =OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
        of.lpstrDefExt  ="pro";
        of.lpfnHook     =NULL;

        if (!GetOpenFileName(&of)) {
            return FALSE;
        }
        lstrcpy (szTSProfile, szBuf);
    }

    /* Cannot use OpenFile with OF_EXISTS because it will search the path */

    if ((hProfile = _lopen (szTSProfile, OF_READ)) == TST_NOLOGFILE)
    {
        wsprintf (szBuf, "Cannot open profile %s", (LPSTR)szTSProfile);
        MessageBox (ghwndTSMain, szBuf, szTSTestName, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    _lclose (hProfile);

    if (GetItem ("AppName"))
    {
        if (lstrcmpi (szBuf, szTSTestName) != 0)
        {
            wsprintf (szBuf, "Error: profile %s was not made by this test application!", (LPSTR)szTSProfile);
            MessageBox (ghwndTSMain, szBuf, szTSTestName, MB_ICONEXCLAMATION | MB_OK);
            return FALSE;
        }
    }
    else
    {
        wsprintf (szBuf, "Error: profile %s does not contain an AppName!", (LPSTR)szTSProfile);
        MessageBox (ghwndTSMain, szBuf, szTSTestName, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    if (GetPrivateProfileString ("settings", 
        "logfile", 
        "", 
        szBuf,
        sizeof(szBuf), 
        szTSProfile))
    {
        SetLogfileName (szBuf);
    }        

    if (GetItem ("filemode"))
    {
        if (lstrcmpi (szBuf, "append") == 0)
        {
            gwTSFileMode = LOG_APPEND;
        }
        else if (lstrcmpi (szBuf, "overwrite") == 0)
        {
            gwTSFileMode = LOG_OVERWRITE;
        }
    }

    if (GetItem ("logging"))
    {
        if (lstrcmpi (szBuf, "window") == 0)
        {
            gwTSLogOut = LOG_WINDOW;
        }
        else if (lstrcmpi (szBuf, "com1") == 0)
        {
            gwTSLogOut = LOG_COM1;
        }
        else if (lstrcmpi (szBuf, "off") == 0)
            gwTSLogOut = LOG_NOLOG;
    }

    if (GetItem ("logginglevel"))
    {
        if (lstrcmpi (szBuf, "off") == 0)
        {
            gwTSLogLevel = LOG_NOLOG;
            toolbarModifyState (hwndToolBar, BTN_WPFOFF, BTNST_DOWN);
        }
        else if (lstrcmpi (szBuf, "terse") == 0)
        {
            gwTSLogLevel = TERSE;
            toolbarModifyState (hwndToolBar, BTN_WPFTERSE, BTNST_DOWN);
        }
        else if (lstrcmpi (szBuf, "verbose") == 0)
        {
            gwTSLogLevel = VERBOSE;
          toolbarModifyState (hwndToolBar, BTN_WPFVERBOSE, BTNST_DOWN);
        }
    }

    if (GetItem ("filelogginglevel"))
    {
        if (lstrcmpi (szBuf, "off") == 0)
        {
            gwTSFileLogLevel = LOG_NOLOG;
            toolbarModifyState (hwndToolBar, BTN_FILEOFF, BTNST_DOWN);
        }
        else if (lstrcmpi (szBuf, "terse") == 0)
        {
            gwTSFileLogLevel = TERSE;
            toolbarModifyState (hwndToolBar, BTN_FILETERSE, BTNST_DOWN);
        }
        else if (lstrcmpi (szBuf, "verbose") == 0)
        {
            gwTSFileLogLevel = VERBOSE;
            toolbarModifyState (hwndToolBar, BTN_FILEVERBOSE, BTNST_DOWN);
        }
    }

    if (GetItem ("verification"))
    {
        if (lstrcmpi (szBuf, "manual") == 0)
            gwTSVerification = LOG_MANUAL;
        else if (lstrcmpi (szBuf, "automatic") == 0)
            gwTSVerification == LOG_AUTO;
    }

#pragma message("Remove this once Chicago's GetPrivateProfileInt works...")
#if 0
    if ((iTmp = GetPrivateProfileInt ("settings", "runcount", -1, szTSProfile))
        != -1)
        giTSRunCount = iTmp;
#else
    if ((iTmp = GetPrivateProfileInt ("settings", "runcount", ((WORD)-1), szTSProfile))
        != ((WORD)-1))
        giTSRunCount = iTmp;
#endif

    //
    // Get the test cases that are selected to run
    //
    removeRunCases();
    ii = 1;
    wsprintf(szBuf,"%d",ii++);

    hListRes = getTstIDListRes();
    lpBegCaseData = (LPTST_ITEM_STRUCT)VLockListResource(hListRes);

#pragma message("Remove this once Chicago's GetPrivateProfileInt works...")
#if 0
    while ((iTmp = GetPrivateProfileInt("tests",szBuf,-1,szTSProfile))
        != -1)
    {
        addTestCase(lpBegCaseData, iTmp);
        wsprintf(szBuf,"%d",ii++);
    }
#else
    while ((iTmp = GetPrivateProfileInt("tests",szBuf,((WORD)-1),szTSProfile))
        != ((WORD)-1))
    {
        addTestCase(lpBegCaseData, iTmp);
        wsprintf(szBuf,"%d",ii++);
    }
#endif

    VUnlockListResource(hListRes);
    VFreeListResource(hListRes);


    wsprintf (szBuf, "%s-%s", (LPSTR)szTSTestName, (LPSTR)szTSProfile);
    SetWindowText (ghwndTSMain, szBuf);

    //
    // Everything done?  Now call the custom read handler to do its work...
    //     -- AlokC (06/30/94)
    tstReadCustomInfo(szTSProfile) ;  // pass just the .pro file name

    return TRUE;

} /* end of LoadProfile */
    



/***************************************************************************\
*                                                                           *
*   void SaveProfile                                                        *
*                                                                           *
*   Description:                                                            *
*       This function saves the current environment into a profile.         *
*                                                                           *
*   Arguments:                                                              *
*       UINT wMode:                                                         *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       02/18/91    prestonB                                                *                                        
*       07/12/93    T-OriG (Added hook and this header)                     *
*                                                                           *
\***************************************************************************/

void SaveProfile
(
    UINT    wMode
)
{
    HFILE              hProfile;
    char               szLine[BUFFER_LENGTH],FileTitle[255];
    char               szBuf[BUFFER_LENGTH+EXTRA_BUFFER];
    int                ii;
    LPTST_RUN_STRUCT   lpTraverse;
    OPENFILENAME       of;
    HANDLE              hListRes;
    LPTST_ITEM_STRUCT   lpBegCaseData;

    if ((wMode == MENU_SAVEAS) || (lstrcmp (szTSProfile, "") == 0))
    {
        of.lStructSize      = sizeof(OPENFILENAME);
        of.hwndOwner        = ghwndTSMain;
        of.hInstance        = 0;
        of.lpstrFilter      = "Test Profiles (*.pro)\0*.pro\0All Files (*.*)\0*.*\0";
        of.lpstrCustomFilter= NULL;
        of.nMaxCustFilter   = 0;
        of.nFilterIndex     = 1;
        of.lpstrFile        = szTSProfile;
        of.nMaxFile             = 255;
        of.lpstrFileTitle   = FileTitle;
        of.nMaxFileTitle    = 255;
        of.lpstrInitialDir  = ".";
        of.lpstrTitle       = "Save Profile";
        of.Flags            = 0;
        of.lpstrDefExt      = "pro";
        of.lpfnHook             = 0;

        if (!GetOpenFileName(&of))
        {
            return;
        }
    }

    if ((hProfile = _lcreat(szTSProfile, 0)) == HFILE_ERROR)
    {
        wsprintf (szLine, "Cannot write to %s", (LPSTR)szTSProfile);
        MessageBox (ghwndTSMain, szLine, szTSTestName, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    writeln (hProfile, "[settings]");

    writeFilePrompt(hProfile, "AppName");
    writeln (hProfile, szTSTestName);

    if (lstrcmp(szTSLogfile,"") != 0)
    {
        writeFilePrompt(hProfile,"logfile");
        writeln (hProfile, szTSLogfile);
    }


    writeFilePrompt(hProfile, "filemode");
    switch (gwTSFileMode)
    {
        case LOG_OVERWRITE:
            writeln (hProfile, "overwrite");
            break;
        default:
            writeln (hProfile, "append");
            break;
    }

    writeFilePrompt(hProfile, "logging");
    switch (gwTSLogOut)
    {
        case (LOG_WINDOW):
            writeln (hProfile, "window");
            break;
        case (LOG_COM1):
            writeln (hProfile, "com1");
            break;
        case (LOG_NOLOG):
            writeln (hProfile, "off");
            break;
    }

    writeFilePrompt(hProfile, "logginglevel");
    writeLogLvl(hProfile,gwTSLogLevel);

    writeFilePrompt(hProfile, "filelogginglevel");
    writeLogLvl(hProfile,gwTSFileLogLevel);

    writeFilePrompt(hProfile, "verification");
    switch (gwTSVerification)
    {
        case (LOG_AUTO):

            writeln (hProfile, "automatic");
            break;

        case (LOG_MANUAL):

            writeln (hProfile, "manual");
            break;
    }

    wsprintf (szLine, "runcount=%d", giTSRunCount);
    writeln (hProfile, szLine);

    hListRes = getTstIDListRes();
    lpBegCaseData = (LPTST_ITEM_STRUCT)VLockListResource(hListRes);
    writeln (hProfile, "[tests]");
    if (tstRunHdr.lpFirst != NULL) 
    {
        lpTraverse = tstRunHdr.lpFirst;
        ii = 1;
        while (lpTraverse != NULL) 
        {
            // Save only static cases in profile
            if ((int) lpTraverse->iCaseNum <= iNumResourceTests)
            {
                wsprintf(szLine,"%d=%d",ii,lpBegCaseData[lpTraverse->iCaseNum-1].wStrID);
                writeln(hProfile,szLine);
                ii++;
            }
            lpTraverse = lpTraverse->lpNext;
        }
    }
    VUnlockListResource(hListRes);
    VFreeListResource(hListRes);

    _lclose (hProfile);
    // Put the profile's name in the caption
    wsprintf (szBuf, "%s-%s", (LPSTR)szTSTestName, (LPSTR)szTSProfile);
    SetWindowText (ghwndTSMain, szBuf);

    //
    // Everything done?  Now call the custom write handler to do its work...
    //     -- AlokC (06/30/94)
    tstWriteCustomInfo(szTSProfile) ;  // pass just the .pro file name

    return;

} /* end of Save */

/*----------------------------------------------------------------------------
This function enters a test case string into a listbox, but not to the run list.
----------------------------------------------------------------------------*/
void addTstCaseEntry
(
    HWND    hwndList,
    WORD    wStrID,
    int     iCaseNum,
    int     iNumSelected
)
{           
    int                iItem, iWritten;
    char               szName[BUFFER_LENGTH];

    //
    // Don't put group ID in the list box
    //

    if (iCaseNum != -1)
    {
        iWritten = wsprintf (szName, "%d:", iCaseNum);
    }
    else
    {
        iWritten = 0;
        iCaseNum = wStrID;  // The group's string identifier
    }

    tstLoadString (ghTSInstApp,wStrID,szName + iWritten,sizeof(szName) - iWritten);
    iItem = (int) SendMessage (hwndList, LB_ADDSTRING, (WPARAM) NULL, (LONG)(LPSTR)szName);

    /* Create the item data associated with the string and set it
       in the list box. */
    sendLBSetData(hwndList,iItem,iCaseNum,iNumSelected);

} /* end of addTstCaseEntry */

/*----------------------------------------------------------------------------

This function increments the selection count for an item in the list of
selected test cases and adds the test case to the selection listbox.

----------------------------------------------------------------------------*/

void addItemSel
(
    int iItem
)
{
    int  iSelItem,iCaseNum,iNumSelected;
    char szName[BUFFER_LENGTH];

    SendMessage(ghTSWndAllList,LB_GETTEXT,iItem,(LONG)(LPSTR)szName);

    iSelItem = (int) SendMessage(ghTSWndSelList,LB_ADDSTRING,(WPARAM)NULL,(LONG)(LPSTR)szName);

    getLBSetData(ghTSWndAllList,iItem,&iCaseNum,&iNumSelected);
// DEBUG tstLog (TERSE, "addItem: iCaseNum = %d, iNumSelected = %d, %s", iCaseNum, iNumSelected, szName);
    sendLBSetData(ghTSWndSelList,iSelItem,iCaseNum,++iNumSelected);
    sendLBSetData(ghTSWndAllList,iItem,iCaseNum,iNumSelected);

} /* end of addItemSel */

/*----------------------------------------------------------------------------

This function increments the selection count for an item in the list of
selected test cases and adds the test case to the selection listbox.

modified 12/31/92 to get text from resource, not All list box, since groups,
not cases, may be there.

----------------------------------------------------------------------------*/

void addItemSelFromRes
(
    int                 iItem,
    LPTST_ITEM_STRUCT   ResPtr
)
{
//    int  iSelItem,iCaseNum,iNumSelected;
    int  iSelItem;
    char szName[BUFFER_LENGTH];
    char szCaseNumAndDesc[BUFFER_LENGTH];

    //
    // use the passed resource ptr's wStrID to load it's text from the
    // stringtable resource
    //
// debug    tstLog (TERSE, "ResPtr = 0x%x, ResPtr->wStrID = %d, szName = %s", ResPtr, ResPtr->wStrID, szName);

    tstLoadString (ghTSInstApp,ResPtr->wStrID, szName, sizeof(szName));

    //
    // concatenate the resource string and the case number string, and send
    // the result to the list box.
    //
    sprintf (szCaseNumAndDesc, "%d:", iItem);
    lstrcat (szCaseNumAndDesc, szName);

    iSelItem = (int) SendMessage(ghTSWndSelList,LB_ADDSTRING,(WPARAM)NULL,(LONG)(LPSTR)szCaseNumAndDesc);

    //
    // store the resource pos + 1 in the Sel box data field for this case
    //

// DEBUG tstLog (TERSE, "addFromRes: iSelItem = %d, iItem = %d, ResPtr = 0x%x, %s", iSelItem, iItem, ResPtr, szName);
    sendLBSetData(ghTSWndSelList,iSelItem,iItem,1);

} /* end of addItemSelFromRes */

/*----------------------------------------------------------------------------

The resource id of a selected group is passed in, and the entire case list
resource is searched for cases with a matching group id.

----------------------------------------------------------------------------*/

void addGroupSel
(
    int                 Selection,
    LPTST_ITEM_STRUCT   CaseSearchPtr
)
{
    long  GroupId;
//    char  szName [BUFFER_LENGTH];
//    int   iSelIndex, ResourcePos;
    int   ResourcePos;

    GroupId = SendMessage(ghTSWndAllList, LB_GETITEMDATA, (WPARAM) Selection, (LPARAM) NULL);

    //
    // search the resource for entries (cases) with the passed group id.
    //

    ResourcePos = 0;
    while (CaseSearchPtr->wStrID != (WORD) TST_LISTEND)
    {
//        if (CaseSearchPtr->wGroupId == (int) GroupId)
        if (CaseSearchPtr->wGroupId == (WORD) GroupId)

           addItemSelFromRes (ResourcePos+1, CaseSearchPtr); // the +1 gives 1-based case numers in the box

        ++ResourcePos;
        ++CaseSearchPtr;
    }

} /* end of addGroupSel */

/*----------------------------------------------------------------------------

The resource id of a selected group is passed in, and the entire case list
resource is searched for cases with a matching group id.

----------------------------------------------------------------------------*/

void addGroupImodeSel
(
    int                 Selection,
    LPTST_ITEM_STRUCT   CaseSearchPtr,
    int                 InteractionMode
)
{
    long  GroupId;
    int   ResourcePos;

    GroupId = SendMessage(ghTSWndAllList, LB_GETITEMDATA, (WPARAM) Selection, (LPARAM) NULL);

// tstLog (TERSE, "Selection = %d, CSP = 0x%x, Interactionmode = %d, GroupId = %d", Selection, CaseSearchPtr, InteractionMode, GroupId);
    //
    // search the resource for entries (cases) with the passed group id.
    //

    ResourcePos = 0;
    while (CaseSearchPtr->wStrID != (WORD) TST_LISTEND)
    {

// tstLog (TERSE, " CSP = 0x%x, iMode = %d, GroupId = %d", CaseSearchPtr, CaseSearchPtr->iMode, CaseSearchPtr->wGroupId);

        if (CaseSearchPtr->wGroupId == (WORD) GroupId
            &&
            (int) CaseSearchPtr->iMode == InteractionMode)

           addItemSelFromRes (ResourcePos+1, CaseSearchPtr); // the +1 gives 1-based case numbers in the box

        ++ResourcePos;
        ++CaseSearchPtr;
    }

} /* end of addGroupImodeSel */

/*----------------------------------------------------------------------------
This function removes a test case from the list of selected test cases.
The selection count corresponding to the test case is decremented in the
list of possible test cases.
----------------------------------------------------------------------------*/

void delItemSel
(
    int iItem
)
{
    int  iSelItem,iCaseNum,iNumSelected;
//    int  iAllListItem;
//    LPTST_RUN_STRUCT   lpTraverse;

    getLBSetData(ghTSWndSelList,iItem,&iCaseNum,&iNumSelected);

    if (iSelItem = (int) SendMessage(ghTSWndSelList,LB_DELETESTRING,iItem,(LPARAM)NULL) == LB_ERR)
       tstLog (TERSE, "ListBox Error in delItemSel()");

} /* end of delItemSel */


/*--------------------------------------------------------------------------

debug: print out the Run list, followed by '##' seperators.

--------------------------------------------------------------------------*/
void PrintRunList
(
    void
)
{
    LPTST_RUN_STRUCT   lpTraverse;

    //
    // search the runlist for the current case number, and remove it from
    // the list if found.  we have to examine the record ahead of the current
    // record so that pointers can be adjusted.
    //
    lpTraverse = tstRunHdr.lpFirst;

    while (lpTraverse != NULL)
    {
       tstLog (TERSE,
           "PRL(): iCaseNum = %d, lpTraverse = 0x%x, lpTraverse-lpNext = 0x%x", lpTraverse->iCaseNum, lpTraverse, lpTraverse->lpNext);
       lpTraverse = lpTraverse->lpNext;
    }

    tstLog (TERSE, "##\n##");
}

/*----------------------------------------------------------------------------
This function enters the test case or group strings into the list box with all
strings deselected.

if groups are listed, then the 32 bit value associated with the item in the
list box is the group id instead of the position in the box that it occupies.
----------------------------------------------------------------------------*/
void initEnterTstList
(
    int     ListMode,
    BOOL    bToggle
)
{
    int                ii, j, iItem, CurrentGroupId;
    int                iNumGroups = 0;
    HANDLE             hListRes;
    LPWORD             lpTstIDsRes;
    LPTST_ITEM_STRUCT  lpCaseData;
    LPTST_RUN_STRUCT   lpTraverse;
    int                GroupsListed[100]; // these are the ids of groups already found
    BOOL               bAlreadyListed;
    WORD               WOldStrID=0;       // Don't list the same case twice

    /* Remove all the strings from the listbox and don't redraw
       until all strings for output are processed. */

    SendMessage (ghTSWndAllList, LB_RESETCONTENT, 0, 0L);
    SendMessage (ghTSWndAllList, WM_SETREDRAW, FALSE, 0L);

    hListRes = getTstIDListRes();
    lpTstIDsRes = (LPWORD)VLockListResource(hListRes);
    ii = 0;

    if (ListMode == LIST_BY_CASE)
    {
    /* Add the test case strings and their case numbers to the list
       of test cases to select from */

       while (*lpTstIDsRes != (WORD) TST_LISTEND)
       {
           lpCaseData = (LPTST_ITEM_STRUCT)lpTstIDsRes;
           ii++;
           if (lpCaseData->wStrID != WOldStrID)
           {
               addTstCaseEntry(ghTSWndAllList, lpCaseData->wStrID,ii,(int) FALSE);
           }
           WOldStrID = lpCaseData->wStrID;    
           lpTstIDsRes = incTstCasePtr(lpTstIDsRes);
       }
    }
    else  /* list 'em by group */
    {
       while (*lpTstIDsRes != (WORD) TST_LISTEND)
       {
           lpCaseData = (LPTST_ITEM_STRUCT)lpTstIDsRes;
           CurrentGroupId = lpCaseData->wGroupId;  // save on ptr derefs

           //
           // see if this group id has already been found.  if not, add it
           // to the All list box.
           //
           bAlreadyListed = FALSE;

           for (j=0; j<iNumGroups; j++)
              if (CurrentGroupId == GroupsListed[j])
              {
                  bAlreadyListed = TRUE;
                  break;
              }

           if (!bAlreadyListed)  // add the new group id
           {
              GroupsListed[j] = CurrentGroupId;
              iNumGroups++;
              addTstCaseEntry((HWND) ghTSWndAllList, (WORD) CurrentGroupId, (int) -1,(int) FALSE);
           }

           lpTstIDsRes = incTstCasePtr(lpTstIDsRes);
       }
    }

    //
    //  Ori, I should kill you.  How dare you lock a handle twice to get the
    //  same pointer w/out unlocking it!
    //  
    //  -Fwong.
    //

    VUnlockListResource(hListRes);

    /* If there are previous selections, then list them in the Select box */

    if ((!bToggle) && (tstRunHdr.lpFirst != NULL))
    {
        SendMessage (ghTSWndSelList, LB_RESETCONTENT, 0, 0L);
        SendMessage (ghTSWndSelList, WM_SETREDRAW, FALSE, 0L);

        lpTraverse = tstRunHdr.lpFirst;
        lpTstIDsRes = (LPWORD)VLockListResource(hListRes);

        while (lpTraverse != NULL)
        {
            //
            // inc the ptr into the resource according to the case number
            //
            lpCaseData = (LPTST_ITEM_STRUCT)lpTstIDsRes + lpTraverse->iCaseNum - 1;

            addItemSelFromRes(lpTraverse->iCaseNum, lpCaseData);
            lpTraverse = lpTraverse->lpNext;
        }
        iItem = (int) SendMessage (ghTSWndSelList,LB_ADDSTRING,(WPARAM) NULL,(LONG)(LPSTR)"\0");

        if (lpTraverse != NULL)
           tstLog (TERSE, "initEnterTstList: Uh-oh the run list is not grounded.");

        SendMessage (ghTSWndSelList, WM_SETREDRAW, TRUE, 0L);
        SendMessage (ghTSWndSelList, LB_DELETESTRING, iItem, 0L);
    }

    VUnlockListResource(hListRes);
    VFreeListResource(hListRes);
 
    iItem = (int) SendMessage (ghTSWndAllList, LB_ADDSTRING,(WPARAM) NULL, (LONG)(LPSTR)"\0");
    SendMessage (ghTSWndAllList, WM_SETREDRAW, TRUE, 0L);
    SendMessage (ghTSWndAllList, LB_DELETESTRING, iItem, 0L);

} /* end of initEnterTstList */



/*----------------------------------------------------------------------------
This function adds test cases that match the specified mode.
----------------------------------------------------------------------------*/
void addModeTstCases
(
    WORD    wMode
)
{
    HANDLE             hListRes;
    LPWORD                 lpTstIDs;
    LPTST_ITEM_STRUCT  lpCaseData;
    int                iCaseNum=1;
    WORD               wOldStrID=0;

    SendMessage (ghTSWndSelList, WM_SETREDRAW, FALSE, 0L);
    hListRes = getTstIDListRes();
    lpTstIDs = (LPWORD)VLockListResource(hListRes);
    while (*lpTstIDs != (WORD)TST_LISTEND) 
    {
        lpCaseData = (LPTST_ITEM_STRUCT)lpTstIDs;
        if ((wMode == lpCaseData->iMode) && (wOldStrID != lpCaseData->wStrID))
        {
            addItemSelFromRes(iCaseNum,lpCaseData);
            wOldStrID = lpCaseData->wStrID;
        }
        lpTstIDs = incTstCasePtr(lpTstIDs);
        iCaseNum++;
    }
    VUnlockListResource(hListRes);
    VFreeListResource(hListRes);
    SendMessage (ghTSWndSelList, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(ghTSWndSelList,NULL,TRUE);
} /* end of addModeTstCases */



/*----------------------------------------------------------------------------
This function handles the selection of test cases.
----------------------------------------------------------------------------*/
int FAR PASCAL EXPORT SelectDlgProc
(
    HWND    hdlg,
    UINT    msg,
    UINT    wParam,
    LONG    lParam
)
{
    int                iCaseNum, iNumSelected;
//    int                GroupId;
    int                ii, iItem;

    HANDLE                 hListRes;
    LPWORD             lpTstIDs;
    LPTST_ITEM_STRUCT  lpCaseData, CaseSearchPtr;
    LPINT               lpItems;
    int                iCount;
    UINT  wNotifyCode;
    UINT  wID;
    HWND  hwndCtl;
    HGLOBAL hMem;

    switch (msg) 
    {
        case WM_INITDIALOG:
            ghTSWndAllList = GetDlgItem(hdlg,TS_ALLLIST);
            ghTSWndSelList = GetDlgItem(hdlg, TS_SELLIST);

            // Set the font in the listbox to a fixed font
            SendMessage(hdlg,WM_SETFONT,(UINT) GetStockObject(SYSTEM_FIXED_FONT),0L);

            //
            // List the test cases by either group or each individual case
            // dependant upon the current state.
            //
            if (!gbTestListExpanded) {
                initEnterTstList (LIST_BY_GROUP,FALSE);
                SetDlgItemText (hdlg, TS_SELEXPAND, "&List All Cases");
            } else {
                initEnterTstList (LIST_BY_CASE,FALSE);
                SetDlgItemText (hdlg, TS_SELEXPAND, "&List All Groups");
            }

            //
            //  Just Testing something out...
            //

            SendDlgItemMessage(hdlg,TS_ALLLIST,LB_SETSEL,TRUE,0L);

            SetWindowText (hdlg, szTSTestName);
            SetFocus(GetDlgItem(hdlg,TS_ALLLIST));
            return TRUE;
            break;

        case WM_COMMAND:
            wNotifyCode=GET_WM_COMMAND_CMD(wParam,lParam);
            wID=GET_WM_COMMAND_ID(wParam,lParam);
            hwndCtl=GET_WM_COMMAND_HWND(wParam,lParam);
            switch (wID) {
                 case IDCANCEL:
                     EndDialog(hdlg,TRUE);
                     break;

                 case TS_ALLLIST:
                     if (wNotifyCode == LBN_DBLCLK)
                         SendMessage(hdlg,WM_COMMAND,TS_SELECT,0L);
                     break;
                
                 case TS_SELLIST:
                     if (wNotifyCode == LBN_DBLCLK)
                         SendMessage(hdlg,WM_COMMAND,TS_REMOVE,0L);
                     break;
                
                 case TS_SELECT:
                     ii = (int) SendMessage (ghTSWndAllList, LB_GETSELCOUNT, 0, 0L);

                     //
                     //  NOTE:  Fixing Rip.  Pressing Select when nothing is
                     //  selected.
                     //
                     //  -Fwong.
                     //
                     //  Fixing Fwong's fix as listboxes remain in no-redraw mode
                     //  -- Ori
                    
                     if (!ii)
                         break;

                     SendMessage (ghTSWndAllList, WM_SETREDRAW, FALSE, 0L);
                     SendMessage (ghTSWndSelList, WM_SETREDRAW, FALSE, 0L);

                     hMem = GlobalAlloc(GHND,ii*sizeof(int));
                     lpItems = GlobalLock(hMem);

                     // Get an array of integers (lpItems) specifying the
                     // list box indices of selected items in the
                     // multiselection list box.  For each item number,
                     // select or deselect the item.
 
                     SendMessage (ghTSWndAllList, LB_GETSELITEMS, ii, (LONG)lpItems);
                     hListRes = getTstIDListRes();
                     lpTstIDs = (LPWORD)VLockListResource(hListRes);
                     CaseSearchPtr = lpCaseData = (LPTST_ITEM_STRUCT)lpTstIDs;

                     for (iItem = 0; iItem < ii; iItem++)
                     {
                         if (gbTestListExpanded)
                             addItemSel (lpItems[iItem]);
                         else
                             addGroupSel (lpItems[iItem], CaseSearchPtr);
                     }

                     // Remove the gray hilite of the items selected

                     SendMessage (ghTSWndAllList, LB_SETSEL, 0, -1);

                     SendMessage (ghTSWndAllList, WM_SETREDRAW, TRUE, 0L);
                     SendMessage (ghTSWndSelList, WM_SETREDRAW, TRUE, 0L);
                     InvalidateRect(ghTSWndAllList,NULL,TRUE);
                     InvalidateRect(ghTSWndSelList,NULL,TRUE);

                     GlobalUnlock(hMem);
                     GlobalFree(hMem);
                     break;

                case TS_SELEXPAND:

                    if (!gbTestListExpanded)
                    {
                       initEnterTstList (LIST_BY_CASE,TRUE);
                       SetDlgItemText (hdlg, TS_SELEXPAND, "&List All Groups");
                       gbTestListExpanded = TRUE;
                    }
                    else
                    {
                       initEnterTstList (LIST_BY_GROUP,TRUE);
                       SetDlgItemText (hdlg, TS_SELEXPAND, "&List All Cases");
                       gbTestListExpanded = FALSE;
                    }
                    break;

                case TS_REMOVE: 
                    SendMessage (ghTSWndAllList, WM_SETREDRAW, FALSE, 0L);
                    SendMessage (ghTSWndSelList, WM_SETREDRAW, FALSE, 0L);

                    ii = (int) SendMessage (ghTSWndSelList, LB_GETSELCOUNT, 0, 0L);

                    //
                    //  NOTE:  Fixing Rip.  Pressing Select when nothing is
                    //  selected.
                    //
                    //  -Fwong.
                    //

                    if(!ii)
                        break;

                    hMem = GlobalAlloc(GHND,ii*sizeof(int));
                    lpItems = GlobalLock(hMem);

                    // Get an array of integers (lpItems) specifying the item
                    // numbers of selected items in the mulitselection list
                    // box.  For each item number, select or deselect the
                    // item.
 
                    SendMessage (ghTSWndSelList, LB_GETSELITEMS, ii, (LONG)lpItems);
                    while (--ii >= 0) {
                        delItemSel(lpItems[ii]);
                    }

                    // Remove the gray hilite of the items selected

                    SendMessage (ghTSWndSelList, LB_SETSEL, 0, -1);

                    SendMessage (ghTSWndAllList, WM_SETREDRAW, TRUE, 0L);
                    SendMessage (ghTSWndSelList, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(ghTSWndAllList,NULL,TRUE);
                    InvalidateRect(ghTSWndSelList,NULL,TRUE);
                    GlobalUnlock(hMem);
                    GlobalFree(hMem);
                    break;
                
                case TS_SELECTALL:
                    SendMessage (ghTSWndSelList, WM_SETREDRAW, FALSE, 0L);

                    iCount = (int)SendMessage(ghTSWndAllList,LB_GETCOUNT,0,0L);

                    if (gbTestListExpanded)
                    {
                       for (ii = 0; ii < iCount; ii++) 
                       {
                           addItemSel(ii);
                       }
                    }
                    else
                    {
                       hListRes = getTstIDListRes();
                       lpTstIDs = (LPWORD)VLockListResource(hListRes);
                       CaseSearchPtr = (LPTST_ITEM_STRUCT)lpTstIDs;

                    // For each group in the All list box, call addGroupSel()
                    // to fetch that group's id, and put that it's cases in
                    // the Selected list box. 

                       for (ii=0; ii < iCount; ii++)
                          addGroupSel (ii, CaseSearchPtr);

                       VUnlockListResource(hListRes);
                       VFreeListResource(hListRes);
                    }

                    iItem = (int) SendMessage (ghTSWndSelList, LB_ADDSTRING,
                                            (WPARAM) NULL, (LONG)(LPSTR)"\0");

                    SendMessage (ghTSWndSelList, LB_DELETESTRING, iItem, 0L);
                    SendMessage (ghTSWndSelList, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(ghTSWndSelList,NULL,TRUE);
                    break;

                case TS_CLEARALL:
                    SendMessage (ghTSWndSelList, WM_SETREDRAW, FALSE, 0L);
                    iCount = (int)SendMessage(ghTSWndSelList,LB_GETCOUNT,0,0L);

                    // Must delete the items in the listbox from the bottom 
                    // to the top

                    while (--iCount >= 0) 
                    {
                         delItemSel(iCount);
                    }

                    //
                    // the Sel list box may be updated from the Run list
                    // before the dlg box is exited, so the Run list needs
                    // to be cleared as well as the Sel box.
                    //
                    removeRunCases();

                    SendMessage (ghTSWndSelList, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(ghTSWndSelList,NULL,TRUE);
                    break;

                case TS_INT_REQUIRED:
                    addModeTstCases(TST_MANUAL);
                    break;
//                case TS_INT_OPTIONAL:
//                    addModeTstCases(TST_IOPTIONAL);
//                    break;
                case TS_INT_NO:
                    addModeTstCases(TST_AUTOMATIC);
                    break;
                case TS_SELCANCEL:
                    EndDialog (hdlg, FALSE);
                    break;

                case TS_SELOK:

                    removeRunCases();
                    tsRemovePrStats();
                    iCount = (int)SendMessage(ghTSWndSelList,LB_GETCOUNT,0,0L);

                    for (ii = 0;  ii < iCount; ii++) 
                    {

                        getLBSetData(ghTSWndSelList,ii,&iCaseNum,&iNumSelected);

                        if (iNumSelected > 0) 
                        {
                           addRunCase(iCaseNum);
                        }                            
                    }
                    EndDialog (hdlg, TRUE);
                    break;
            }
            break;

        case WM_MEASUREITEM:
            MeasureItem(hdlg, (LPMEASUREITEMSTRUCT) lParam);
            break;

        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT lpDraw = (LPDRAWITEMSTRUCT)lParam;

            if (lpDraw->CtlType == ODT_LISTBOX)
                DrawItem (hdlg, lpDraw);
            break;
        }

    }
    return FALSE;
} /* end of SelectDlgProc */

/*----------------------------------------------------------------------------
This function invokes the test case selection dialog box.
----------------------------------------------------------------------------*/
void Select
(
    void
)
{
    BOOL        bOldExpanded=gbTestListExpanded;
    FARPROC     lpfp;

    /* Put up main dialog box */
    lpfp = MakeProcInstance ((FARPROC)SelectDlgProc, ghTSInstApp);
    if (!(DialogBox (ghTSInstApp, "SelectTsts", ghwndTSMain, (DLGPROC)lpfp)))
        gbTestListExpanded = bOldExpanded;
    FreeProcInstance(lpfp);
} /* end of Select */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tssetpth.c ===
/***************************************************************************\
*                                                                           *
*   File: Tssetpth.c                                                        *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This module handles the run parameters dialog box.                  *
*                                                                           *
*   Contents:                                                               *
*       GetCWD()                                                            *
*       StripTrailingBackwhacks()                                           *
*       SetInOutPathsDlgProc()                                              *
*       SetInOutPaths()                                                     *
*       getTSInOutPaths()                                                   *
*                                                                           *
*   History:                                                                *
*       02/17/91    prestonB    Created from tst.c                          *
*                                                                           *
*       07/14/93    T-OriG      Added functionality and this header         *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>
// #include "mprt1632.h"
#include "support.h"
#include "tsglobal.h"
#include "tsextern.h"
#include "tsdlg.h"


/***************************************************************************\
*                                                                           *
*   void GetCWD                                                             *
*                                                                           *
*   Description:                                                            *
*       Gets the current working directory in both 16 and 32 bit platforms  *
*                                                                           *
*   Arguments:                                                              *
*       LPSTR lpstrPath:                                                    *
*           A string in which the CWD will be placed                        *
*       UINT uSize:                                                         *
*           The maximum size of the string                                  *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       06/07/93    T-OriG (actual code written by fwong)                   *
*                                                                           *
\***************************************************************************/

#ifndef WIN32
#pragma optimize("",off)
#endif

void FAR PASCAL GetCWD
(
    LPSTR   lpstrPath,
    UINT    uSize
)
{
#ifdef WIN32
    GetCurrentDirectory(uSize,lpstrPath);
#else
    _asm
    {
        pusha
        push ds

        mov     ax, 1900h           ; get number corresponding to the drive letter
        int     21h                 ; 1=a, 2=b, 3=c...
//        jc      error
        add     al,'A'              ; set the drive letter

        lds     si, lpstrPath
        mov     ds:[si], al
        mov     ds:[si+1], ':'
        mov     ds:[si+2], '\\'
        add     si, 3

        xor     dl, dl              ; dl=0 ==> default drive
        mov     ax, 4700h           ; get directory in DS:SI
        int     21h
        jnc     xexit

//error:
        lds     si, lpstrPath
        mov     ds:[si],0
        int 3
xexit:
        pop     ds
        popa
    }
#endif

    AnsiLowerBuff(lpstrPath,uSize);
    //tstLog(VERBOSE,"GetCWD [%s]",lpstrPath);
} // GetCWD()

#ifndef WIN32
#pragma optimize("",on)
#endif

/****************************************************************************/

void  StripTrailingBackwhacks (LPSTR szPathString)
{
   LPSTR ptr;

   ptr = szPathString + lstrlen (szPathString);

   while (*(--ptr) == '\\')
      *ptr = '\0';
}

/*----------------------------------------------------------------------------
This function handles the setting of the input and output path for running 
tests.
----------------------------------------------------------------------------*/
int FAR PASCAL SetInOutPathsDlgProc(
HWND     hdlg, 
UINT     msg,
WPARAM   wParam,
LPARAM   lParam)
{

    UINT  wNotifyCode;
    UINT  wID;
    HWND  hwndCtl;

    switch (msg) {
        case WM_INITDIALOG:

            SetDlgItemText(hdlg,TS_OUTPATH,szOutPath);
            SetDlgItemText(hdlg,TS_INPATH,szInPath);

            SetFocus(GetDlgItem(hdlg,TS_INPATH));
            break;

        case WM_COMMAND:
            wNotifyCode=GET_WM_COMMAND_CMD(wParam,lParam);
            wID=GET_WM_COMMAND_ID(wParam,lParam);
            hwndCtl=GET_WM_COMMAND_HWND(wParam,lParam);
            switch (wID)
            {
                case IDOK:

                    GetDlgItemText(hdlg,TS_INPATH,szInPath,BUFFER_LENGTH);
                    StripTrailingBackwhacks (szInPath);
                    WritePrivateProfileString(szTSPathSection,szTSInPathKey,
                        szInPath, szTstsHellIni);

                    GetDlgItemText(hdlg,TS_OUTPATH,szOutPath,BUFFER_LENGTH);
                    StripTrailingBackwhacks (szOutPath);
                    WritePrivateProfileString(szTSPathSection,szTSOutPathKey,
                        szOutPath, szTstsHellIni);

                    EndDialog (hdlg, FALSE);
                    break;

                case IDCANCEL:
                    EndDialog (hdlg, TRUE);
                    break;
            }
            break;

    }
    return FALSE;

} /* end of SetInOutPathsDlgProc */

/*----------------------------------------------------------------------------
This function invokes the set input output paths dialog box.
----------------------------------------------------------------------------*/
void SetInOutPaths (void)
{
    FARPROC lpfp = MakeProcInstance ((FARPROC)SetInOutPathsDlgProc, ghTSInstApp);

    DialogBox (ghTSInstApp, "setpaths", ghwndTSMain, (DLGPROC)lpfp);
    FreeProcInstance(lpfp);
} /* end of SetInOutPaths */
            

/***************************************************************************\
*                                                                           *
*   void getTSInOutPaths                                                    *
*                                                                           *
*   Description:                                                            *
*       This function returns the input and output paths for test cases.    *
*                                                                           *
*                                                                           *
*   Arguments:                                                              *
*       int iPathId:                                                        *
*                                                                           *
*       LPSTR lpstrPath:                                                    *
*                                                                           *
*   Return (void):                                                          *
*                                                                           *
*   History:                                                                *
*       08/05/93    T-OriG                                                  *
*                                                                           *
\***************************************************************************/

void getTSInOutPaths
(
    int     iPathId,
    LPSTR   lpstrPath,
    int     cbBufferSize
)
{
    if (iPathId == TS_INPATH_ID)
    {
        GetPrivateProfileString(szTSPathSection,
            szTSInPathKey,
            szInPath,
            lpstrPath,
            cbBufferSize,
            szTstsHellIni);
    }
    else
    {
        GetPrivateProfileString(szTSPathSection,
            szTSOutPathKey,
            szOutPath,
            lpstrPath,
            cbBufferSize,
            szTstsHellIni);
    }

} /* end of getTSInOutPaths */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tsstats.c ===
/***************************************************************************\
*                                                                           *
*   File: Tsstats.c                                                         *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This module handles the structures and printing of test case        *
*       statistics.                                                         *
*                                                                           *
*   Contents:                                                               *
*       addGrpInfoNode()                                                    *
*       removePrStatNodes()                                                 *
*       tsRemovePrStats()                                                   *
*       tsAddGrpInfo()                                                      *
*       updateGrpNode()                                                     *
*       tsUpdateGrpNodes()                                                  *
*       tstPrintStats()                                                     *
*       printGrpNodes()                                                     *
*       tsPrAllGroups()                                                     *
*       tsPrFinalStatus()                                                   *
*                                                                           *
*   History:                                                                *
*       02/18/91    prestonB    Created from tst.c                          *
*                                                                           *
*       07/14/93    T-OriG      Added functionality and this header         *
*                                                                           *
\***************************************************************************/

#include <windows.h>
// #include "mprt1632.h"
#include <windowsx.h>
#include "support.h"
#include <gmem.h>
#include <time.h>               //added for mmtest NT logging
#include <string.h>             //added for mmtest NT logging
#include "tsglobal.h"
#include "tsextern.h"


/*----------------------------------------------------------------------------
This function adds a group info structure for printing statistics.
----------------------------------------------------------------------------*/
LPTS_STAT_STRUCT addGrpInfoNode
(
    UINT    wGroupId
)
{
    LPTS_STAT_STRUCT   lpNewGroup;
    HGLOBAL hMem;

    hMem = GlobalAlloc(GHND,sizeof(TS_STAT_STRUCT));
    lpNewGroup = (LPTS_STAT_STRUCT)GlobalLock(hMem);
    lpNewGroup->tsPrStats.wGroupId = wGroupId;
    lpNewGroup->tsPrStats.iNumPass = 0;
    lpNewGroup->tsPrStats.iNumFail = 0;
    lpNewGroup->tsPrStats.iNumOther = 0;
    lpNewGroup->tsPrStats.iNumAbort = 0;
    lpNewGroup->tsPrStats.iNumNYI = 0;
    lpNewGroup->tsPrStats.iNumRan = 0;
    lpNewGroup->tsPrStats.iNumErr = 0;
    lpNewGroup->tsPrStats.iNumStop = 0;
    lpNewGroup->lpRight = lpNewGroup->lpLeft = NULL;
    return(lpNewGroup);
} /* end of addGrpInfoNode */



/*----------------------------------------------------------------------------
This function frees the memory allocated for the print nodes from the root
down.
----------------------------------------------------------------------------*/
void removePrStatNodes
(
    LPTS_STAT_STRUCT    lpRoot
)
{
    HGLOBAL hMem;

    if (lpRoot != NULL) {
        removePrStatNodes(lpRoot->lpLeft);
        removePrStatNodes(lpRoot->lpRight);

        // GFreePtr (lpRoot); // YOU WHO USES THIS TO FREE LOCKED PTR:
        //                    // CHANGE IT BACK AND YOU ARE DEAD.
        hMem = (HGLOBAL) GlobalPtrHandle(lpRoot);
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
} /* end of removePrStatNodes */



/*----------------------------------------------------------------------------
This function frees the memory allocated for the print statistic group nodes.
----------------------------------------------------------------------------*/
void tsRemovePrStats
(
    void
)
{
    removePrStatNodes(tsPrStatHdr);
    tsPrStatHdr = NULL;
} /* end of tsRemovePrStats */



/*----------------------------------------------------------------------------
This function adds a group info structure for printing statistics.
----------------------------------------------------------------------------*/
LPTS_STAT_STRUCT tsAddGrpInfo
(
    UINT    wGroupId
)
{
    LPTS_STAT_STRUCT   lpNewGroup;

    lpNewGroup = addGrpInfoNode(wGroupId);
    if (tsPrStatHdr == NULL)
        tsPrStatHdr = lpNewGroup;
    return(lpNewGroup);
} /* end of tsAddGrpInfo */



/*----------------------------------------------------------------------------
This function increments the specified result in the specified node.
----------------------------------------------------------------------------*/
void updateGrpNode
(
    LPTS_STAT_STRUCT    lpNode,
    int                 iResult
)
{
    switch (iResult)
    {
        case TST_ABORT:
            lpNode->tsPrStats.iNumAbort += 1;
            gbAllTestsPassed = FALSE;
            break;
        case TST_PASS:
            lpNode->tsPrStats.iNumPass += 1;
            break;
        case TST_FAIL:
            lpNode->tsPrStats.iNumFail += 1;
            gbAllTestsPassed = FALSE;
            break;
        case TST_TRAN:
            lpNode->tsPrStats.iNumRan += 1;
            break;
        case TST_TERR:
            lpNode->tsPrStats.iNumErr += 1;
            gbAllTestsPassed = FALSE;
            break;
        case TST_TNYI:
            lpNode->tsPrStats.iNumNYI += 1;
            gbAllTestsPassed = FALSE;
            break;
        case TST_STOP:
            lpNode->tsPrStats.iNumStop += 1;
            gbAllTestsPassed = FALSE;
            break;
        default:
            lpNode->tsPrStats.iNumOther += 1;
            gbAllTestsPassed = FALSE;
            break;
    }
} /* end of tsGetUpdateNode */



/*----------------------------------------------------------------------------
This function increments the specified result in the node identified by the
group id.
----------------------------------------------------------------------------*/
LPTS_STAT_STRUCT tsUpdateGrpNodes
(
    LPTS_STAT_STRUCT    lpRoot,
    int                 iResult,
    UINT                wGroupId
)
{
    if (lpRoot == NULL)
    {
        lpRoot = tsAddGrpInfo(wGroupId);
        updateGrpNode(lpRoot,iResult);
    }
    else
    {
        if (lpRoot->tsPrStats.wGroupId < wGroupId)
        {
            lpRoot->lpRight = tsUpdateGrpNodes(lpRoot->lpRight,iResult,wGroupId);
        }
        else
        {
            if (lpRoot->tsPrStats.wGroupId > wGroupId)
            {
                lpRoot->lpLeft = tsUpdateGrpNodes(lpRoot->lpLeft,iResult,wGroupId);
            }
            else
            {
                updateGrpNode(lpRoot,iResult);
            }
        }
    }
    return(lpRoot);

} /* end of tsUpdateGrpNodes */



/*----------------------------------------------------------------------------
This function prints the statistics associated with the specified group id.
----------------------------------------------------------------------------*/
void tstPrintStats
(
    LPTS_PR_STATS_STRUCT    lpPrStats
)
{
    // Add definition for 16bit build
    #ifndef WIN32
      #define FILE_END 2
    #endif
    
    
    char    szGroup[BUFFER_LENGTH];

    tstLoadString(ghTSInstApp,lpPrStats->wGroupId,szGroup,BUFFER_LENGTH);
    tstBeginSection (szGroup);
    tstLog(TERSE,"");
    tstLog(TERSE,"====================================================================");
    tstLog(TERSE,"TOTALS:");
    tstLog(TERSE,"                              Test      Test      Not Yet          ");
    tstLog(TERSE,"Passed    Failed    Blocked   Ran       Other     Implem.   Stopped");
    tstLog(TERSE,"--------------------------------------------------------------------");
    tstLog(TERSE,
        "%8d  %8d  %8d  %8d  %8d  %8d  %8d",
        lpPrStats->iNumPass,
        lpPrStats->iNumFail,
        lpPrStats->iNumErr+lpPrStats->iNumAbort,
        lpPrStats->iNumRan,
        lpPrStats->iNumOther,
        lpPrStats->iNumNYI,
        lpPrStats->iNumStop);

    tstLog(TERSE,"====================================================================");




 /***********************************************************************************/
 /* START MMTEST NT Specific Logging                                                                                            */
 /* Log the Summary Statistics from the test to a log file in the \mmtest dir       */

 #ifdef MMTESTNT_LOG
     if (strcmp("Summary of All Groups",szGroup) == 0)    /* If this is the Summary Info then Do This */
     {

         LPSTR szStatsLog = "\\mmtest\\StatsLog.log";
         HFILE  hFile;
         OFSTRUCT OfStruct;
         char szTmpStr[BUFFER_LENGTH+EXTRA_BUFFER];
         char szTimeStr[BUFFER_LENGTH];

         time_t  Time;                    /* Get info for time stamp */
         time( &Time );
         strftime( szTimeStr, BUFFER_LENGTH, "%m/%d %H:%M:%S %a", localtime( &Time ));


         hFile = OpenFile(szStatsLog, &OfStruct, OF_EXIST);

         if (hFile >= 0)  /* file exists so append */
         {
         	hFile = OpenFile(szStatsLog, &OfStruct, OF_READWRITE);

         }
         else      /* create the file */
         {
            hFile = OpenFile(szStatsLog, &OfStruct, OF_READWRITE | OF_CREATE);
         }

         if (hFile != -1)   /* file handle is good so write to it */
         {
             _llseek(hFile,0L,FILE_END);


             wsprintf(szTmpStr,"TOTALS Summary From %s\r\n", (LPSTR)szTSLogfile);
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));

             wsprintf(szTmpStr,"Time  %s\r\n", (LPSTR)szTimeStr);
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));


             wsprintf(szTmpStr,"==========================================================\r\n");
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));
             wsprintf(szTmpStr,"TOTALS:\r\n");
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));
             wsprintf(szTmpStr,"                              Test      Test      Not Yet\r\n");
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));
             wsprintf(szTmpStr,"Passed    Failed    Blocked   Ran       Other     Implem.\r\n");
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));
             wsprintf(szTmpStr,"----------------------------------------------------------\r\n");
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));
             wsprintf(szTmpStr, "%8d  %8d  %8d  %8d  %8d  %8d\r\n",
                lpPrStats->iNumPass,lpPrStats->iNumFail,
                lpPrStats->iNumErr+lpPrStats->iNumAbort,
                lpPrStats->iNumRan,lpPrStats->iNumOther,lpPrStats->iNumNYI);
             _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));
              wsprintf(szTmpStr,"==========================================================\r\n\r\n\r\n");
               _lwrite(hFile,szTmpStr, lstrlen(szTmpStr));

             _lclose(hFile);
              tstLog(TERSE,"\r\nTOTALS Summary Appended to %s",szStatsLog);
           }
        }

 #endif  //MMTESTNT_LOG

 /* END MMTESTNT  Logging Code                            */
 /*********************************************************/


    tstEndSection();
    tstLogFlush();
} /* end of tstPrintStats */


/*----------------------------------------------------------------------------
This function prints a tree of group info nodes from the root down.
----------------------------------------------------------------------------*/
void printGrpNodes
(
    LPTS_STAT_STRUCT    lpRoot
)
{
    if (lpRoot != NULL) {
        printGrpNodes(lpRoot->lpLeft);
        tstPrintStats((LPTS_PR_STATS_STRUCT)(lpRoot));
        printGrpNodes(lpRoot->lpRight);
    }

} /* end of printGrpNodes */



/*----------------------------------------------------------------------------
This function prints all the groups that have been executed.
----------------------------------------------------------------------------*/
void tsPrAllGroups
(
    void
)
{
    printGrpNodes(tsPrStatHdr);

} /* end of tsPrAllGroups */

/*----------------------------------------------------------------------------
Print the final status line, which indicates whether the test suite passed
or failed based on the gbAllTestsPassed flag.
----------------------------------------------------------------------------*/

void tsPrFinalStatus
(
    void
)
{
    //
    // if any test case returns a status other than TST_PASS or TST_TRAN,
    // this flag gets cleared.
    //
    if (!gbAllTestsPassed)
        tstLog (TERSE, "\r\nStatus:     FAIL\r\n");
    else
        tstLog (TERSE, "\r\nStatus:     PASS\r\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\wpf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       wpf.h
//
//--------------------------------------------------------------------------


/*
 *  WPF OUTPUT WINDOW
 */

#define WPF_CHARINPUT   0x00000001L

#if defined(_ALPHA_)
int  FAR cdecl wpfVprintf(HWND hwnd, LPSTR lpszFormat, va_list pargs);
#else
int  FAR cdecl wpfVprintf(HWND hwnd, LPSTR lpszFormat, LPSTR pargs);
#endif
int  FAR cdecl wpfPrintf(HWND hwnd, LPSTR lpszFormat, ...);
void FAR PASCAL wpfOut(HWND hwnd, LPSTR lpsz);
BOOL FAR PASCAL wpfSetRedraw (HWND hwnd, BOOL bRedraw);
void FAR PASCAL wpfScrollByLines (HWND hwnd, int nLines);
HWND FAR PASCAL wpfCreateWindow(HWND hwndParent,
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR lpszTitle,
    DWORD dwStyle,
    UINT x,
    UINT y,
    UINT dx,
    UINT dy,
    int iMaxLines,
    UINT wID);

/*  Control messages sent to WPF window  */

//#define WPF_SETNLINES (WM_USER + 1)
#define WPF_GETNLINES   (WM_USER + 2)
#define WPF_SETTABSTOPS (WM_USER + 4)
#define WPF_GETTABSTOPS (WM_USER + 5)
#define WPF_GETNUMTABS  (WM_USER + 6)
#define WPF_SETOUTPUT   (WM_USER + 7)
#define WPF_GETOUTPUT   (WM_USER + 8)
#define WPF_CLEARWINDOW (WM_USER + 9)
#define WPF_TSTLOGFLUSH (WM_USER + 10)

/*  Flags for WPF_SET/GETOUTPUT  */
#define WPFOUT_WINDOW           1
#define WPFOUT_COM1             2
#define WPFOUT_NEWFILE          3
#define WPFOUT_APPENDFILE       4
#define WPFOUT_DISABLED         5

/*  Messages sent to owner of window  */
#define WPF_NTEXT       (0xbff0)
#define WPF_NCHAR       (0xbff1)


/**********************************
 *
 *      DEBUGGING SUPPORT
 *
 **********************************/

BOOL    FAR PASCAL        wpfDbgSetLocation(UINT wLoc, LPSTR lpszFile);
int     FAR cdecl       wpfDbgOut(LPSTR lpszFormat, ...);
BOOL    FAR PASCAL        wpfSetDbgWindow(HWND hwnd, BOOL fDestroyOld);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\tsstep.c ===
/***************************************************************************\
*                                                                           *
*   File: Tsstep.c                                                          *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This code handles the step mode dialog box                          *
*                                                                           *
*   Contents:                                                               *
*       StepModeDlgProc()                                                   *
*       StepMode()                                                          *
*                                                                           *
*   History:                                                                *
*       02/17/91    prestonB    Created                                     *
*                                                                           *
*       07/14/93    T-OriG      Added this header                           *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>
// #include "mprt1632.h"
#include "support.h"
#include "tsglobal.h"
#include "tsextern.h"
#include "tsdlg.h"


/*----------------------------------------------------------------------------
This function handle the step mode dialog.
----------------------------------------------------------------------------*/
int FAR PASCAL StepModeDlgProc
(
        HWND    hdlg,
        UINT    msg,
        UINT    wParam,
        long    lParam
)
{
    UINT  wNotifyCode;
    UINT  wID;
    HWND  hwndCtl;

    switch (msg) 
    {
        case WM_COMMAND:
            wNotifyCode=GET_WM_COMMAND_CMD(wParam,lParam);
            wID=GET_WM_COMMAND_ID(wParam,lParam);
            hwndCtl=GET_WM_COMMAND_HWND(wParam,lParam);
            switch (wID)
            {
                case TS_SPCONT:
                    EndDialog (hdlg, TST_TRAN);
                    break;
                case TS_SPPASS:
                    EndDialog (hdlg, TST_PASS);
                    break;
                case TS_SPFAIL:
                    EndDialog (hdlg, TST_FAIL);
                    break;
                case TS_SPABORT:
                    EndDialog (hdlg, TST_ABORT);
                    break;
            }
            break;

    }
    return FALSE;
} /* end of StepModeDlgProc */

/*----------------------------------------------------------------------------
This function invokes the step mode dialog box. 
----------------------------------------------------------------------------*/
int StepMode
(
    HWND    hWnd
)
{
    int iResult;
    FARPROC fpDlg;

    fpDlg = MakeProcInstance((FARPROC)StepModeDlgProc, ghTSInstApp);
    iResult = DialogBox(ghTSInstApp, (LPCSTR) "stepmode", hWnd, (DLGPROC) fpDlg);
    FreeProcInstance(fpDlg);
    return (iResult);

} /* end of StepMode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\tstshell\wpf.c ===
/***************************************************************************\
*                                                                           *
*   File: Wpf.c                                                             *
*                                                                           *
*   Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved          *
*                                                                           *
*   Abstract:                                                               *
*       This code handles line output.  It was originally taken from        *
*       wpf.dll.                                                            *
*                                                                           *
*   Contents:                                                               *
*       WpfInit()                                                           *
*       wpfCreateWindow()                                                   *
*       WpfSetFont()                                                        *
*       WpfClear()                                                          *
*       WpfSetTabs()                                                        *
*       WpfGetTabs()                                                        *
*       WpfPaint()                                                          *
*       PrintfWndProc()                                                     *
*       WpfVScroll()                                                        *
*       WpfHScroll()                                                        *
*       LinesInWpfWindow()                                                  *
*       CharsInWpfWindow()                                                  *
*       WpfMaxLen()                                                         *
*       WpfSetScrollRange()                                                 *
*       NewLine()                                                           *
*       ChangeLine()                                                        *
*       InsertString()                                                      *
*       EnQueChar()                                                         *
*       UpdateCursorPos()                                                   *
*       SetOutput()                                                         *
*       GetOutput()                                                         *
*       wpfPrintf()                                                         *
*       wpfWrtTTY()                                                         *
*       wpfVprintf()                                                        *
*       wpfOut()                                                            *
*       Dup()                                                               *
*       wpfWrtFile()                                                        *
*                                                                           *
*   History:                                                                *
*	    10/02/86	Todd Laney	Created                                     *
*                                                                           *
*	    04/14/87	toddla	    Added new function CreateDebugWin           *
*                                                                           *
*	    07/08/87	brianc	    added iMaxLines parm to CreateDebugWin[dow] *
*                                                                           *
*	    2/90		russellw	moved into Wincom and cleaned up.           *
*                                                                           *
*	    4/14/92 	JohnMil     Corrected memory usage, changed LINE        *
*                               structure                                   *
*                                                                           *
*       07/14/93    T-OriG      Added this header and code to run multiple  *
*                               instances simultaneously                    *
*                                                                           *
\***************************************************************************/

#include <windows.h>
#include <windowsx.h>
// #include "mprt1632.h"
#include "support.h"
#include "wpf.h"
#include "TstsHell.h"
#include <gmem.h>

#ifndef WIN32
#include <malloc.h>
#endif


/* 
 * This code appears to make use of the fact that a local handle can be
 * double de-referenced to get the actual pointer that the local handle
 * refers to.  This is a somewhat shady practice.. maybe eliminate it?
 *
 */

/*********
 * The local memory dereferencing MUST be eliminated for WIN32.
 *********/


HINSTANCE ghInst;

/*--------------------------------------------------------------------------*\
|                                                                            |
|   g e n e r a l   c o n s t a n t s                                        |
|                                                                            |
\*--------------------------------------------------------------------------*/

#define MAXBUFLEN 200         /* Maximum string length for wprintf */

/*  Macros to manipulate the printf window array of lines.  This array
 *  wraps around, thus the need for the modulo arithmetic
 */
#define FIRST(pTxt) ((pTxt)->iFirst)
#define TOP(pTxt)   (((pTxt)->iFirst + (pTxt)->iTop) % (pTxt)->iMaxLines)
#define LAST(pTxt)  (((pTxt)->iFirst + (pTxt)->iCount-1) % (pTxt)->iMaxLines)
#define INC(pTxt,x) ((x) = ++(x) % (pTxt)->iMaxLines)
#define DEC(pTxt,x) ((x) = --(x) % (pTxt)->iMaxLines)

#define HWinInfo(hwnd)	     ((HTXT)GETWINDOWUINT((hwnd),0))
#define PWinInfo(hwnd)	     ((PTXT)HWinInfo(hwnd))
#define LOCKWININFO(hwnd)    ((PTXT)((hwnd != NULL) ? LocalLock((HANDLE)HWinInfo(hwnd)) : NULL))
#define UNLOCKWININFO(hwnd)  if (hwnd != NULL) LocalUnlock((HANDLE)HWinInfo(hwnd));

#define VK(vk)  ((vk) | 0x0100)

/*  The pad values used between the edge of the window and the text.
 *  x = 1/2 ave char width, y = 1 pixel
 */
#define OFFSETX (pTxt->Tdx/2)
#define OFFSETY 1
#define VARSIZE 1
#define MAX_SCROLL_LINES 5000

#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))



#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/*--------------------------------------------------------------------------*\
|                                                                            |
|   g l o b a l   v a r i a b l e s                                          |
|									     |
\*--------------------------------------------------------------------------*/
#define QUESIZE   128


#ifndef WIN32
typedef int      *PINT;
typedef int FAR *LPINT;
#endif

/*
 *   QUEUE STRUCTURE:   Support queuing of input characters.
 *
 */
typedef struct {
    int     iLen;
    char    ach[QUESIZE];
}   QUE;
typedef QUE		       *PQUE; /* pointer to a char que */
typedef PQUE		   *HQUE; /* handle (**) to a char que */


/*
 *  WPF WINDOW INSTANCE DATA STRUCTURE
 *
 */
typedef struct {
    int     iLen;
    LPSTR   cText;	// Changed from **hText to *cText to correct memory,
                    // and to LPSTR to change code to use global memory
}   LINE;

struct TEXT_STRUCT {
	HWND	hwnd;		// Window displaying the text
	UINT	wID;		// window ID code, for WM_COMMAND messages
	BOOL	fScrollSemaphore;
	UINT	wOutputLocation;    // This is set to a	wParam sometimes.
	int	iFile;
	int	iFirst;		// First line in que
	int	iCount;		// Number of lines in que
	int	iTop;		// Line at top of window
	int	iLeft;		// X offset of the window
	int	MaxLen;		// length of longest string currently stored.
	int	iMaxLines;	// max number of LINEs
	int	iRangeH;
	int	iRangeV;
	HFONT	hFont;		// Font to draw with
	int	Tdx,Tdy;	// Font Size
	HQUE	hQue;
	int	nTabs;
	PINT	pTabs;
	LINE	arLines[VARSIZE];	// array of iMaxLines LINEs
};
typedef struct TEXT_STRUCT *PTXT; /* pointer to a text struct */
typedef HANDLE		    HTXT; /* Handle to a text struct */

static int  iSem=0;
static BOOL gbRedraw=TRUE;

static HWND   hwndLast = NULL;

/*  External buffer for scratch space  */
char   bufTmp[MAXBUFLEN];        /* intermediate buffer */

static char     szClass[] = "WPFWIN";
static BOOL     fInit = FALSE;

/*--------------------------------------------------------------------------*\
|                                                                            |
|   f u n c t i o n   d e f i n i t i o n s                                  |
|                                                                            |
\*--------------------------------------------------------------------------*/

LONG EXPORT FAR PASCAL PrintfWndProc(HWND, UINT, UINT, LONG);
void NEAR PASCAL WpfSetFont(HWND hWnd, HFONT hFont);
void NEAR PASCAL WpfClear(HWND hWnd);
void NEAR PASCAL WpfSetTabs(HWND hwnd, int nTabs, LPINT pTabs);
BOOL NEAR PASCAL WpfGetTabs(HWND hwnd, LPINT pTabs);
void NEAR PASCAL WpfPaint(HWND hwnd, HDC hdc);

void NEAR PASCAL WpfVScroll(HWND hWnd, PTXT pTxt, int n);
void NEAR PASCAL WpfHScroll(HWND hWnd, PTXT pTxt, int n);
int  NEAR PASCAL LinesInWpfWindow(HWND hWnd);
int  NEAR PASCAL CharsInWpfWindow(HWND hWnd);
void NEAR PASCAL WpfMaxLen(PTXT pTxt);
void NEAR PASCAL WpfSetScrollRange(HWND hWnd, BOOL bRedraw);

void NEAR PASCAL NewLine(PTXT pTxt);
int  NEAR PASCAL ChangeLine(PTXT pTxt, int iLine, LPSTR lpch);
int  NEAR PASCAL InsertString(PTXT pTxt,  LPSTR lpstr);

BOOL NEAR PASCAL EnQueChar(HTXT hTxt, UINT vk);
void NEAR PASCAL UpdateCursorPos(PTXT pTxt);

UINT NEAR PASCAL SetOutput(HWND hwnd, UINT wParam, LONG lParam);
UINT NEAR PASCAL GetOutput(HWND hwnd);

BOOL NEAR PASCAL wpfWrtTTY(HWND hWnd, LPSTR sz);

//BOOL FAR PASCAL DbgDestroy(HWND hwnd);

void wpfWrtFile(int fh, LPSTR sz);

/* 
 * fSuccess = WpfInit(hInst)
 * 
 * Register the WinPrintf window class.
 * 
 */
BOOL FAR PASCAL WpfInit(HINSTANCE hInstance, HINSTANCE hPrev);


//***************************************************************************
// Memory allocation macros:
//***************************************************************************
#ifdef WIN32
#define     strAlloc(x)     GlobalLock (GlobalAlloc (GMEM_FIXED, x))
#define     strFree(x)      GFreePtr(x)
#define     freeAll()       NULL
#else
#define     strAlloc(x)     _fmalloc(x)      
#define     strFree(x)      _ffree(x)
#define     freeAll()       _heapmin()
#endif






#pragma alloc_text(init, WpfInit)

BOOL FAR PASCAL WpfInit
(
    HINSTANCE   hInstance,
    HINSTANCE   hPrev
)
{
    WNDCLASS rClass;

    if (!fInit) {
	    //
	    // TODO -- hack to let registerclass succeed
        // This is a test code for reference only.
	    //
	
        // 
        //  Commented out the UnregisterClass because it was causing a debug rip
        //  This doesn't seem to affect anything, so I don't know why the hack
        //  was here in the first place.
        //  RickB = 04-16-93.
        //UnregisterClass(szClass,hInstance);


	    rClass.hCursor	      = LoadCursor(NULL,IDC_ARROW);
        rClass.hIcon          = (HICON)NULL;
        rClass.lpszMenuName   = (LPSTR)NULL;
        rClass.lpszClassName  = szClass;
    	rClass.hbrBackground  = (HBRUSH) (COLOR_WINDOW + 1);
        rClass.hInstance      = hInstance;
        //rClass.style          = CS_GLOBALCLASS;
        rClass.style          = 0;
        rClass.lpfnWndProc    = PrintfWndProc;
        rClass.cbWndExtra     = sizeof (HTXT);
        rClass.cbClsExtra     = 0;

        if (!hPrev)
        {
    	    if (!RegisterClass(&rClass))
            {
    	        return FALSE;
            }
        }

        //RegisterClass (&rClass);

        fInit++;
    }

    return TRUE;
}





/* 
 * @doc	EXTERNAL WINCOM WPFWINDOW
 * 
 * @api	HWND | wpfCreateWindow | This function creates a
 * text output window.  WPF windows allow <f printf> style output
 * and line oriented input.  WPF windows also remember a fixed number of
 * lines of previous output for scrolling back.
 * 
 * @parm	HWND | hwndParent | Specifies the parent window.
 * 
 * @parm	HANDLE | hInst | Specifies the module instance handle of the
 * DLL owner.  If the parameter is NULL, the module instance handle of
 * the WINCOM DLL is used.
 * 
 * @parm	LPSTR | lpszTitle | Points to the window title.  This
 * information is ignored when the style specified by <p dwStyle> does
 * not create a title bar for the window.
 * 
 * @parm	DWORD | dwStyle | Specifies the window style flags.  All
 * standard window style flags are valid.  The WPF window class also defines
 * the following additional flags:
 * 
 * @flag	WPF_CHARINPUT | The WPF window allows the user to input
 * characters and sends its parent <m WPF_NCHAR> and <m WPF_NTEXT> messages.
 *
 ***		    in WIN32, these can be 32-bits.
 * @parm	UINT | x | Specifies the x position of the window.
 * @parm	UINT | y | Specifies the y position of the window.
 * @parm	UINT | dx | Specifies the width of the window.
 * @parm	UINT | dy | Specifies the height of the window.
 * 
 * @parm	int | iMaxLines | Specifies the maximum number of lines that
 * the WPF window remembers for scrolling purposes.  If this
 * parameter is zero, a default value of 100 is supplied.
 * 
 * @parm	UINT | wID | Specifies the window ID of the WPF window.	This
 * code is used in WM_COMMAND message to notify the owner of the WPF
 * window when key events have occurred.
 * 
 * @rdesc	Returns the window handle of the new WPF window, or NULL if
 * an error occurs.  The returned window handle may be used with the
 * normal Windows window-management APIs.
 * 
 * @comm	A WPF window behaves like a partial Windows control.  The
 * owner may change the parameters of a WPF window by sending control
 * messages (including WM_SETFONT, WM_GETFONT, and the WPF messages
 * documented with the WINCOM DLL).  The WPF window notifies its owner
 * of state changes by sending the owner WM_COMMAND messages with a
 * control ID of <p wID>.  WPF windows are not full controls, however,
 * as they cannot be used in dialog boxes.  WPF windows also do not
 * respond to WM_GETTEXT and WM_SETTEXT messages.
 * 
 */
HWND FAR PASCAL wpfCreateWindow
(
    HWND        hwndParent,
    HINSTANCE   hInst,
    HINSTANCE   hPrev,
    LPSTR       lpszTitle,
    DWORD       dwStyle,
    UINT        x,
    UINT        y,
    UINT        dx,
    UINT        dy,
    int         iMaxLines,
    UINT        wID
)
{
  HWND   hWnd;


  if (!fInit)
    if (!WpfInit(hInst, hPrev)) {
	/*  Return NULL if the class could not be registered  */
	MessageBox(NULL,"Unable to Register wpfWindow Class",
		   "wpfCreateWindow",MB_ICONEXCLAMATION|MB_APPLMODAL);
	return NULL;
	}

  if (iMaxLines == 0)
	  iMaxLines = 100;
//
//  if (hInst == NULL)
//	  hInst = ghInst;
  
  hWnd = CreateWindow((LPSTR)szClass,
			(LPSTR)lpszTitle,
                        dwStyle,
                        x,y,
                        dx,dy,
                        (HWND) hwndParent,
                        (HMENU) NULL,
                        (HANDLE) hInst,
			(LPSTR) MAKELONG(iMaxLines, wID)
                       );
  if (hWnd == NULL) {
	MessageBox(NULL,"Unable to Create wpfWindow",
		   "wpfCreateWindow",MB_APPLMODAL);
	}


  return (hWnd);
}


/*****************************************************
 *
 *		UTILITY PROCEDURES
 *
 *****************************************************/

/* 
 * WpfSetFont(hwnd, hfont)
 * 
 * Changes the font of a winprintf window to be the specified handle.
 * Rebuilds the internal character size measurements, and causes the
 * window to repaint.
 * 
 * Is there a problem with scroll ranges changing here?
 * 
 */
void NEAR PASCAL WpfSetFont
(
    HWND    hWnd,
    HFONT   hFont
)
{
    PTXT       pTxt;
    HDC        hDC;
    TEXTMETRIC tm;

    pTxt = LOCKWININFO(hWnd);
    
    pTxt->hFont = hFont;
    
    /* Find out the size of a Char in the font */
    hDC = GetDC(hWnd);
    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, (LPTEXTMETRIC) &tm);
    pTxt->Tdy = tm.tmHeight;
    pTxt->Tdx = tm.tmAveCharWidth;
    ReleaseDC (hWnd, hDC);
    InvalidateRect(hWnd, NULL, TRUE);
    UNLOCKWININFO(hWnd)
}


/* 
 * WpfClear(hwnd)
 * 
 * Clears all text from the window.  Frees all allocated memory.  The
 * current queue is not modified?
 * 
 */
void NEAR PASCAL WpfClear
(
    HWND    hWnd
)
{
    int   i,iQue;
    PTXT  pTxt;

    pTxt = LOCKWININFO(hWnd);

    iQue = FIRST(pTxt);
    for (i=0; i < pTxt->iCount; i++, INC(pTxt,iQue))
      if (pTxt->arLines[iQue].cText != NULL)
	strFree(pTxt->arLines[iQue].cText);

    pTxt->iFirst            = 0;    /* Set the que up to have 1 NULL line */
    pTxt->iCount            = 1;
    pTxt->iTop              = 0;
    pTxt->iLeft             = 0;
    pTxt->MaxLen            = 0;
    pTxt->arLines[0].cText  = NULL;
    pTxt->arLines[0].iLen   = 0;

    UNLOCKWININFO(hWnd)

    InvalidateRect(hWnd,NULL,TRUE);
    WpfSetScrollRange(hWnd,TRUE);
    UpdateWindow(hWnd);
}

/* 
 * WpfSetTabs(hwnd, nTabs, pTabs)
 * 
 * Sets up hwnd to use the tabs stops specified by pTabs.  Copies these
 * tabs into a local-alloc'ed buffer.  Any pre-existing tab stops are
 * deallocated.
 * 
 */
void NEAR PASCAL WpfSetTabs
(
    HWND    hwnd,
    int     nTabs,
    LPINT   pTabs
)
{
    PTXT  pTxt;
    int   i;

    pTxt = LOCKWININFO(hwnd);

    /*  Discard old tabs, allocate space for new tab settings  */
    if (pTxt->pTabs)
        LocalFree((HANDLE)pTxt->pTabs);

    if (pTabs == NULL || nTabs == 0) {
        pTxt->pTabs = NULL;
        pTxt->nTabs = 0;
    } else {
        pTxt->pTabs = (PINT)LocalAlloc(LPTR, nTabs * sizeof(int));
        pTxt->nTabs = nTabs;

        /*  Copy caller's tab settings into the current tab table  */
        if (pTxt->pTabs) {
            for (i=0; i < nTabs; i++)
                pTxt->pTabs[i] = *pTabs++;
        }
    }

    InvalidateRect(hwnd,NULL,TRUE);
    UNLOCKWININFO(hwnd)
}

/* 
 * fIsTabs = WpfGetTabs(hwnd, pTabs)
 * 
 * Responds to a WPF_GETTABSTOPS message by filling in the supplied
 * buffer with the current tab settings.  Returns TRUE if there are tabs
 * stops, or FALSE if there aren't any tab stops in use.
 * 
 */
BOOL NEAR PASCAL WpfGetTabs
(
    HWND    hwnd,
    LPINT   pTabs
)
{
    PTXT  pTxt;
    int   i;

    pTxt = LOCKWININFO(hwnd);

    /*  If there are no current tabs, return FALSE  */
    if (pTxt->nTabs == 0 || pTxt->pTabs == NULL)
	    return FALSE;
    
    /*  Otherwise, copy my tabs into the caller's buffer.  Assume
     *  that the caller's buffer is large enough.
     */
    for (i=0; i < pTxt->nTabs; i++) {
            *pTabs++ = pTxt->pTabs[i];
    }

    UNLOCKWININFO(hwnd)

    return TRUE;
}

/***********************************
 *
 *	WINDOW PROCEDURE
 *
 ***********************************/

/*--------------------------------------------------------------------------*\
|   WpfPaint(hWnd, hDC )                                                     |
|                                                                            |
|   Description:                                                             |
|       The paint function.                                                  |
|                                                                            |
|   Arguments:                                                               |
|       hWnd            Window to paint to.                                  |
|       hDC             handle to update region's display context            |
|                                                                            |
|   Returns:                                                                 |
|       nothing                                                              |
|                                                                            |
\*--------------------------------------------------------------------------*/
void NEAR PASCAL WpfPaint
(
    HWND    hwnd,
    HDC     hdc
)
{
    PTXT   pTxt;
    int    iQue;
    int    xco;
    int    yco;
    int    iLast;
    RECT   rc;
    RECT   rcClip;
    HFONT	hfontOld;
    
    MLockData(0);    /* need from spy DS not locked! */

    pTxt = LOCKWININFO(hwnd);

    GetClientRect(hwnd, &rc);
    rc.left += OFFSETX;
    rc.top  += OFFSETY;
    IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

    /*  If a font (other than the system font) has been specified, use it  */
    if (pTxt->hFont)
        hfontOld = SelectObject(hdc, pTxt->hFont);

    /*  Setup counters as appropriate.  Get indexes of first and last
     *  lines visible within the window.
     */
    iLast = LAST(pTxt);
    iQue  = TOP(pTxt);
    /*  The x and y initial points for the text line.
     *  xco is shifted left to account for any horizonal scrolling
     *  that may be going on
     */
    xco   = OFFSETX - pTxt->iLeft * pTxt->Tdx;	// shifted for h-scrolling
    yco   = OFFSETY;		// starting y pix value

    /*  RC is the bounding rect for the current line.
     *
     *  Calc initial line bounding rect.. top = top of window (padded),
     *  bottom = top + height of one line.
     */
    rc.left   = xco;
    rc.top    = yco;
    rc.bottom = yco + pTxt->Tdy;

    /*  Get the clipping rectangle  */
    GetClipBox(hdc, &rcClip);

    /*  Iter over all lines that are visible - if the bounding rect
     *  for the current line intersects the clip rect, draw the line.
     */
    for (;;) {
        if (rc.bottom >= rcClip.top) {
	    /*  If we're using tabs, then tab out the text.
	     */
        if (pTxt->nTabs > 0) {
		/*  Erase the background  */
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
		    
            TabbedTextOut(hdc, xco, yco,
                          (pTxt->arLines[iQue].cText),
                           pTxt->arLines[iQue].iLen,
                           pTxt->nTabs, pTxt->pTabs, xco);
        } else {
		/*  Otherwise, blow it out using ExtTextOut  */
            ExtTextOut(hdc, xco, yco, ETO_OPAQUE, &rc,
                       (pTxt->arLines[iQue].cText),
                       pTxt->arLines[iQue].iLen, NULL);
        }
    }

	/*  Bail out when finished printing window contents  */
    if (iQue == iLast)
        break;

    INC(pTxt, iQue);
	/*  Advance the boundry rect & char positions down one line  */
    yco = rc.top = rc.bottom;
    rc.bottom += pTxt->Tdy;

    if (yco > rcClip.bottom)
	     break;
    }

    /*  Restore the old font  */
    if (hfontOld)
	    SelectObject(hdc, hfontOld);

    MUnlockData(0);
    UNLOCKWININFO(hwnd)
}




LONG EXPORT FAR PASCAL PrintfWndProc
(
    HWND    hWnd,
    UINT    uiMessage,
    UINT    wParam,
    LONG    lParam
)
{
    PAINTSTRUCT rPS;
    PTXT	pTxt;
    HTXT        hTxt;
    int		i;
    int		iQue;
    UINT	wScrollCode, nPos;
    HANDLE	hwndCtl;

    if ( uiMessage != WM_NCCREATE ) {
        hTxt  = (HTXT)GETWINDOWUINT(hWnd,0);
        pTxt  = LOCKWININFO(hWnd);
    }

    #define lpCreate ((LPCREATESTRUCT)lParam)

    switch (uiMessage) {
        case WM_NCCREATE:

            i = LOWORD((DWORD)lpCreate->lpCreateParams);

            // i = MAX_SCROLL_LINES;

	    /*  Allocate and initialize the window instance structure
	     *  The storage for the current lines is placed at the end
	     *  end of the instance data structure. allocate room for it.
	     */
            hTxt = (HTXT) LocalAlloc(LHND, sizeof(struct TEXT_STRUCT) + 
                                     (i - VARSIZE) * sizeof(LINE));

            if (hTxt == NULL)
                return -1L;

            pTxt = (PTXT)LocalLock((HANDLE)hTxt);

            if (pTxt == NULL) {
                LocalFree(hTxt);
                return -1L;
            }
	    
            pTxt->hwnd		    = hWnd;
            pTxt->wID		= HIWORD(lpCreate->lpCreateParams);
            pTxt->iFile		= -1;
            pTxt->wOutputLocation = WPFOUT_WINDOW;
            pTxt->iFirst	    = 0;	// initially 1 null line
            pTxt->iCount	    = 1;
            pTxt->iTop		    = 0;
            pTxt->iLeft 	    = 0;	// no initial hscroll offset
            pTxt->MaxLen	    = 0;
            pTxt->iMaxLines	    = i;
            pTxt->nTabs 	    = 0;
	    /*  If user specified character input, allocate a buffer  */
            if (lpCreate->style & WPF_CHARINPUT)
                pTxt->hQue	    = (HQUE) LocalAlloc(LHND | LMEM_ZEROINIT,
                                                   sizeof(QUE));
            else
                pTxt->hQue	    = NULL;
            	
	    /*  Null initial first line  */
            pTxt->arLines[0].cText  = NULL;
            pTxt->arLines[0].iLen   = 0;
            
	    /*  Store the structure pointer onto the window  */
            SETWINDOWUINT(hWnd, 0, hTxt);
            
	    /*  Setup to use the system font by default  */
            WpfSetFont(hWnd, GetStockObject(SYSTEM_FONT));
	    
            LocalUnlock((HANDLE) hTxt);
            return DefWindowProc(hWnd,uiMessage,wParam,lParam);
//          return 0L;

        case WM_DESTROY:
//	     DbgDestroy(hWnd);

            //  Flush any files in use by the window 
            SetOutput(hWnd, WPFOUT_DISABLED, 0L);
	    
	        //  Blow away all lines held by the window
            iQue = FIRST(pTxt);
            for (i=0; i < pTxt->iCount; i++, INC(pTxt,iQue))
                if (pTxt->arLines[iQue].cText != NULL)
                    strFree(pTxt->arLines[iQue].cText);
            
	        //  And kill char input and tab stop storage
            if (pTxt->hQue)
                LocalFree ((HANDLE) pTxt->hQue);
            if (pTxt->pTabs)
                LocalFree ((HANDLE) pTxt->pTabs);

            // Free all memory used to store lines
            freeAll();
            

            //
            //  I commented out the following line to kill a debug rip.  This probablyneeds
            //  more investigation....
            //  RickB - 04-16-93
	        
           // LocalUnlock((HANDLE)hTxt);
           // LocalFree((HANDLE)hTxt);
            break;

//	case WPF_SETNLINES:
//	    return 0L;

        case WPF_GETNLINES:
            UNLOCKWININFO(hWnd)
            return pTxt->iMaxLines;

        case WM_GETFONT:
            UNLOCKWININFO(hWnd)
            return (LONG)(UINT)pTxt->hFont;

        case WM_SETFONT:
            WpfSetFont(hWnd, (HANDLE) wParam);
            UNLOCKWININFO(hWnd)
            return 0L;

	/*  Tab stop stuff  */
        case WPF_SETTABSTOPS:
            WpfSetTabs(hWnd, wParam, (LPINT) lParam);
                       UNLOCKWININFO(hWnd)
            return 0L;

        case WPF_GETNUMTABS:
            UNLOCKWININFO(hWnd)
            return (pTxt->pTabs ? pTxt->nTabs : 0);
		
        case WPF_GETTABSTOPS:
            UNLOCKWININFO(hWnd)
            return (LONG) WpfGetTabs(hWnd, (LPINT) lParam);

        case WPF_SETOUTPUT:
            UNLOCKWININFO(hWnd);
            return (LONG) SetOutput(hWnd, wParam, lParam);
		
        case WPF_GETOUTPUT:
            UNLOCKWININFO(hWnd)
            return (LONG) GetOutput(hWnd);

        case WPF_CLEARWINDOW:
            WpfClear(hWnd);
            UNLOCKWININFO(hWnd)
            return 0L;
		
        case WM_SIZE:
	    /*  It is possible to get WM_SIZEs as a result of
	     *  dicking with scrollbars..  Avoid race conditions
	     */
            if (!pTxt->fScrollSemaphore) {
                pTxt->fScrollSemaphore++;
                WpfSetScrollRange(hWnd, TRUE);
                UpdateCursorPos(pTxt);
                pTxt->fScrollSemaphore--;
            }
            break;

        case WM_VSCROLL:
            wScrollCode = GET_WM_VSCROLL_CODE(wParam,lParam);
            nPos = GET_WM_VSCROLL_POS(wParam,lParam);
            hwndCtl = GET_WM_VSCROLL_HWND(wParam,lParam);

            switch (wScrollCode) {
                case SB_LINEDOWN:
                    WpfVScroll (hWnd,pTxt,1);
                    break;
                case SB_LINEUP:
                    WpfVScroll (hWnd,pTxt,-1);
                    break;
                case SB_PAGEUP:
                    WpfVScroll (hWnd,pTxt,-LinesInWpfWindow(hWnd));
                    break;
                case SB_PAGEDOWN:
                    WpfVScroll (hWnd,pTxt,LinesInWpfWindow(hWnd));
                    break;
                case SB_THUMBTRACK:
                    WpfVScroll (hWnd,pTxt,nPos - pTxt->iTop);
                    break;

                case SB_THUMBPOSITION:
                    WpfVScroll (hWnd,pTxt,nPos - pTxt->iTop);
		  /*  Fall through  */
		  
                case SB_ENDSCROLL:
                    WpfSetScrollRange(hWnd,TRUE);
                    UpdateCursorPos(pTxt);
                    break;
            }
            break;

        case WM_HSCROLL:
            wScrollCode = GET_WM_VSCROLL_CODE(wParam,lParam);
            nPos = GET_WM_VSCROLL_POS(wParam,lParam);
            hwndCtl = GET_WM_VSCROLL_HWND(wParam,lParam);
            switch (wScrollCode) {
                case SB_LINEDOWN:
                    WpfHScroll (hWnd, pTxt, 1);
                    break;
                case SB_LINEUP:
                    WpfHScroll (hWnd, pTxt, -1);
                    break;
                case SB_PAGEUP:
                    WpfHScroll (hWnd, pTxt, -CharsInWpfWindow(hWnd));
                    break;
                case SB_PAGEDOWN:
                    WpfHScroll (hWnd, pTxt, CharsInWpfWindow(hWnd));
                    break;
                case SB_THUMBTRACK:
                    WpfHScroll (hWnd, pTxt, nPos - pTxt->iLeft);
                    break;

                case SB_THUMBPOSITION:
                    WpfHScroll (hWnd, pTxt, nPos - pTxt->iLeft);
		  /*  Fall through  */
		  
                case SB_ENDSCROLL:
                    WpfSetScrollRange(hWnd,TRUE);
                    UpdateCursorPos(pTxt);
                    break;
            }
            break;

        case WM_PAINT:
            BeginPaint(hWnd,&rPS);
            WpfPaint (hWnd,rPS.hdc);
            EndPaint(hWnd,&rPS);
            break;

	/*  Allow keyboard scrolling  */
        case WM_KEYDOWN:
            switch (wParam) {
                case VK_UP:
                    PostMessage (hWnd,WM_VSCROLL,SB_LINEUP,0L);
                    break;
                case VK_DOWN:
                    PostMessage (hWnd,WM_VSCROLL,SB_LINEDOWN,0L); 
                    break;
                case VK_PRIOR:
                    PostMessage (hWnd,WM_VSCROLL,SB_PAGEUP,0L);   
                    break;
                case VK_NEXT:
                    PostMessage (hWnd,WM_VSCROLL,SB_PAGEDOWN,0L); 
                    break;
                case VK_HOME:
                    PostMessage (hWnd,WM_HSCROLL,SB_PAGEUP,0L);
                    break;
                case VK_END:
                    PostMessage (hWnd,WM_HSCROLL,SB_PAGEDOWN,0L); 
                    break;
                case VK_LEFT:
                    PostMessage (hWnd,WM_HSCROLL,SB_LINEUP,0L);   
                    break;
                case VK_RIGHT:
                    PostMessage (hWnd,WM_HSCROLL,SB_LINEDOWN,0L); 
                    break;
            }
            break;

	/*  Handle focus messages to hide and show the caret
	 *  if the WPF window allows for character input.
	 */
        case WM_SETFOCUS:
            if (pTxt->hQue) {
                CreateCaret(hWnd,0,1,pTxt->Tdy);
                UpdateCursorPos(pTxt);
                ShowCaret(hWnd);
            }
            UNLOCKWININFO(hWnd)
            return 0L;

        case WM_KILLFOCUS:
	         if (pTxt->hQue)
                DestroyCaret();
            UNLOCKWININFO(hWnd)
            return 0L;

        case WM_CHAR:
            EnQueChar(hTxt,wParam);
            break;

        case WM_KEYUP:
            switch (wParam) {
                case VK_F3:
                    EnQueChar(hTxt,VK(wParam));
                    break;

		/*  Send endscroll when the key goes up - allows for
		 *  type-a-matic action.
		 */
                case VK_UP:
                case VK_DOWN:
                case VK_PRIOR:
                case VK_NEXT:
                    PostMessage (hWnd,WM_VSCROLL,SB_ENDSCROLL,0L);
                    break;

                case VK_HOME:
                case VK_END:
                case VK_LEFT: 
                case VK_RIGHT:
                    PostMessage (hWnd,WM_HSCROLL,SB_ENDSCROLL,0L);
                    break;

            }
            break;

        default:
            if ( uiMessage != WM_NCCREATE ) {
                UNLOCKWININFO(hWnd)
            }
            return DefWindowProc(hWnd,uiMessage,wParam,lParam);
    }
//    if ( (uiMessage != WM_NCCREATE) & (hTxt != NULL)) {
    if ( (uiMessage != WM_NCCREATE) ) {
       UNLOCKWININFO(hWnd)
    }
    return 0L;
}


/***********************************************
 *
 *		SCROLLING STUFF
 *
 ***********************************************/

/* 
 * WpfVScroll(hwnd, pTxt, n)
 * 
 * Vertical scroll the window by n number of lines.
 * 
 */
void NEAR PASCAL WpfVScroll
(
    HWND    hWnd,
    PTXT    pTxt,
    int     n
)
{
    RECT rect;
    int  iRange;

    /* GetScrollRange (hWnd,SB_VERT,&iMinPos,&iMaxPos); */
    iRange = pTxt->iRangeV;		// where did this come from?
    GetClientRect(hWnd, &rect);
    rect.left += OFFSETX;		// adjust for pad boundry
    rect.top  += OFFSETY;

    n = BOUND(pTxt->iTop + n, 0, iRange) - pTxt->iTop;
    pTxt->iTop += n;
    ScrollWindow(hWnd, 0, -n * pTxt->Tdy, &rect, &rect);
    SetScrollPos(hWnd, SB_VERT, pTxt->iTop, gbRedraw);
    if (gbRedraw)
        UpdateWindow(hWnd);
}


/* 
 * WpfHScroll(hwnd, ptxt, n)
 * 
 * Horizontally scrolls the window by n number of character widths.
 * 
 */
void NEAR PASCAL WpfHScroll
(
    HWND    hWnd,
    PTXT    pTxt,
    int     n
)
{
    RECT rect;
    int  iRange;

    /* GetScrollRange (hWnd,SB_HORZ,&iMinPos,&iMaxPos); */
    iRange = pTxt->iRangeH;
    GetClientRect (hWnd,&rect);
    rect.left += OFFSETX;
    rect.top  += OFFSETY;

    n = BOUND(pTxt->iLeft + n, 0, iRange) - pTxt->iLeft;
    pTxt->iLeft += n;
    ScrollWindow(hWnd, -n * pTxt->Tdx, 0, &rect, &rect);
    SetScrollPos(hWnd, SB_HORZ, pTxt->iLeft, gbRedraw);
    if (gbRedraw)
       UpdateWindow(hWnd);
}


/* 
 * nLines = LinesInWpfWindow(hwnd)
 * 
 * Returns the height in lines of the window.
 * 
 */
int NEAR PASCAL LinesInWpfWindow
(
    HWND    hWnd
)
{
    RECT rRect;
    PTXT pTxt;
    int  iLines;

    pTxt = LOCKWININFO(hWnd);
    GetClientRect(hWnd, &rRect);
    iLines = 0;
    if (pTxt) {
       iLines = (rRect.bottom - rRect.top - OFFSETY) / pTxt->Tdy;
       iLines = min(iLines, pTxt->iMaxLines);
    }
    UNLOCKWININFO(hWnd)
    return iLines;
}


/* 
 * nChars = CharsInWpfWindow(hwnd)
 * 
 * Returns the width in characters of the window.
 * 
 */
int NEAR PASCAL CharsInWpfWindow
(
    HWND    hWnd
)
{
    RECT rRect;
    PTXT pTxt;
    int iRet;

    pTxt = LOCKWININFO(hWnd);
    GetClientRect(hWnd,&rRect);

    iRet =  pTxt ? (rRect.right - rRect.left - OFFSETX) / pTxt->Tdx : 0;
    UNLOCKWININFO(hWnd)
    return(iRet);
}




/* 
 * WpfMaxLen(pTxt)
 * 
 * This function sets the pTxt->MaxLen field to be the length in
 * characters of the longest string currently being stored by the WPF
 * window.
 * 
 */
void NEAR PASCAL WpfMaxLen
(
    PTXT    pTxt
)
{
    int    iQue;
    int    iLast;
    int    iLen;

    iLast = LAST(pTxt);
    iQue  = TOP(pTxt);
    pTxt->MaxLen = 0;
    for (;;) {
        iLen = pTxt->arLines[iQue].iLen;

    if (iLen > pTxt->MaxLen)
        pTxt->MaxLen = iLen;
    if (iQue == iLast) break;
        INC(pTxt,iQue);
    }

//    ReleaseDC(NULL,hdc);

}



/* 
 * WpfSetScrollRange(hwnd, bRedraw)
 * 
 * This function sets the scrollbar ranges according to the current
 * character/line contents of the window.  Both the horizontal and
 * vertical scrollbars are adjusted.
 * 
 * This function then calls WpfVScroll/WpfHScroll to adjust the
 * scrollbar position accordingly.
 * 
 */
void NEAR PASCAL WpfSetScrollRange
(
    HWND    hWnd,
    BOOL    bRedraw
)
{
    PTXT pTxt;
    int  iRange;
    BOOL bRedrawT;

    if (pTxt = LOCKWININFO(hWnd)) {
        bRedrawT = gbRedraw;
        gbRedraw = bRedraw;
	/* Update the scroll bars */

        iRange = pTxt->iCount - LinesInWpfWindow (hWnd) + 1;

	/*  Adjust for blank last line?  */
        if (pTxt->arLines[LAST(pTxt)].iLen == 0);
            iRange -= 1;

        if (iRange < 0) 
            iRange = 0;
	
	/*  Set the scrollbar range to that calculated  */
        pTxt->iRangeV = iRange;
        SetScrollRange(hWnd, SB_VERT, 0, iRange, FALSE);
        WpfVScroll(hWnd, pTxt, 0);

	/*  Setup the horizontal scrollbar range  */
        WpfMaxLen(pTxt);
        iRange = pTxt->MaxLen - CharsInWpfWindow(hWnd) + 1;
        if (iRange < 0)  
            iRange = 0;
        pTxt->iRangeH = iRange;
        SetScrollRange(hWnd, SB_HORZ, 0, iRange, FALSE);
        WpfHScroll (hWnd, pTxt, 0);

        gbRedraw = bRedrawT;
    }
    UNLOCKWININFO(hWnd)
}


/* 
 * WpfSetRedraw (bRedraw)
 * 
 * This function sets or clears the global redraw flag for wpf
 * when the redraw flag is false, adding lines to the wpf window
 * will not cause it to redraw.
 * 
 */

BOOL FAR PASCAL wpfSetRedraw
(
    HWND hwnd,
    BOOL bRedraw
)
{
    BOOL bOld = gbRedraw;
    gbRedraw = bRedraw;
    return bOld;
}

/***********************************************************
 *
 *		STUFF TO ADD NEW TEXT LINES
 *
 ***********************************************************/

/* 
 * NewLine(pTxt)
 * 
 * Adjusts a WPF window when adding a line to the circular array.
 * iCount is the count of valid lines in the array.  If we
 * haven't yet filled up the array, the count is merely increased.
 * Otherwise, if the array is full and we're about to wrap around, fixup
 * the wrap-around.
 * 
 */
void NEAR PASCAL NewLine
(
    PTXT    pTxt
)
{
    int iLast = LAST(pTxt);
    RECT rect;

    if (pTxt->iCount == pTxt->iMaxLines) {
	/*  If the array is full, check for wrap-around  */
        strFree(pTxt->arLines[pTxt->iFirst].cText);
        pTxt->arLines[pTxt->iFirst].cText = NULL;
       
        INC(pTxt, pTxt->iFirst);
       
        if (pTxt->iTop > 0)
            pTxt->iTop--;
        else {
            GetClientRect (pTxt->hwnd,&rect);
            rect.left += OFFSETX;
            rect.top  += OFFSETY;
            ScrollWindow (pTxt->hwnd, 0, -pTxt->Tdy, &rect, &rect);
        }
    }
    else {
        pTxt->iCount++;
    }
    iLast = LAST(pTxt);
    pTxt->arLines[iLast].cText = NULL;
    pTxt->arLines[iLast].iLen  = 0;
}



/* 
 * fSuccess = ChangeLine(pTxt, iLine, lpsz)
 * 
 * Changes line number <iLine> to be the string pointed to by lpsz.
 * Frees any line currently occupying index <iLine>, and then alloc and
 * stores text lpsz.
 * 
 */
int NEAR PASCAL ChangeLine
(
    PTXT    pTxt,
    int     iLine,
    LPSTR   lpch
)
{
    int iLen;

    if (pTxt->arLines[iLine].cText != NULL)
       strFree(pTxt->arLines[iLine].cText);

    iLen = lstrlen(lpch);
    if ((pTxt->arLines[iLine].cText = (LPSTR) strAlloc(iLen+1)) == NULL)
        return FALSE;

    pTxt->arLines[iLine].iLen = iLen;
    lstrcpy(pTxt->arLines[iLine].cText, lpch);
    return TRUE;
}









int NEAR PASCAL InsertString
(
    PTXT    pTxt,
    LPSTR   lpstr
)
{
    int    iBuf;
    int    iLast = LAST(pTxt);
    int    cLine = 0;
    LPSTR  pch;
    char   buf[MAXBUFLEN];

    /*
     *	copy the string already there
     */
    if (pTxt->arLines[iLast].cText == NULL)
    {
        pTxt->arLines[iLast].cText = (LPSTR) (strAlloc(2*sizeof(char)));
        pTxt->arLines[iLast].cText[0] = '\0';
    }

    pch  = (pTxt->arLines[iLast].cText);
    iBuf = lstrlen(pch);
    lstrcpy(buf, pch);		// why?

    while (*lpstr != '\0') {
        while (*lpstr != '\n' && *lpstr != '\0' && iBuf < MAXBUFLEN-2) {
            switch (*lpstr) {
	    
                case '\b':
		/*  Backspace, blow away one character  */
                    iBuf--;
                    lpstr++;
                    break;
		
                case '\r':
		/*  Carriage return, go back to beginning of line  */
                    iBuf = 0;
                    lpstr++;
                    break;
		
                default:
		/*  Otherwise, add this char to line  */
                    buf[iBuf++] = *lpstr++;
                    break;
            }
        }
        buf[iBuf++] = 0;

	/*  Presto chango add the line  */
        ChangeLine(pTxt, iLast, buf);  /* buf must be a asciiz string */

        if (*lpstr == '\n') {   /* Now do the next string after the \n */
            lpstr++;
            iBuf = 0;
            cLine++;
            NewLine(pTxt);
            INC(pTxt, iLast);
        }
    }
    return cLine;   /* the number of new lines added to list */
}


/**********************************************************
 *
 *		CHARACTER INPUT STUFF
 *
 **********************************************************/

    
BOOL NEAR PASCAL EnQueChar
(
    HTXT    hTxt,
    UINT    vk
)
{
    PTXT pTxt;
    PQUE pQue;
    int  i;
    HWND hwndP;

    pTxt = (PTXT) LocalLock((HANDLE)hTxt);

    if (!pTxt->hQue)
        goto noque;

    pQue = (PQUE) LocalLock((HANDLE)pTxt->hQue);

    i = pQue->iLen;

    switch (vk)
    {
        case '\b':
            if (i > 0)
            {
                --i;
                wpfOut(pTxt->hwnd, "\b");
            }
            break;
	
        case VK(VK_F3):
            wpfOut(pTxt->hwnd, pQue->ach + i);
            i += lstrlen(pQue->ach + i);
            break;

        case '\r':
        case '\n':
            if (GetKeyState(VK_CONTROL) < 0)
            {
                wpfOut(pTxt->hwnd,"\\\n");
            } else {
                wpfOut(pTxt->hwnd, "\n");
                pQue->ach[i] = '\0';
                if (hwndP = GetParent(pTxt->hwnd))
                    SendMessage(hwndP, WPF_NTEXT, pTxt->wID,
                                (LONG)(LPSTR)pQue->ach);
                i = 0;
            }
            break;

        default:
            if (i < QUESIZE)
            {
                pQue->ach[i]   = (char)vk;
                wpfPrintf(pTxt->hwnd, "%c", vk);
                if (hwndP = GetParent(pTxt->hwnd))
                    SendMessage(hwndP, WPF_NCHAR, pTxt->wID, (LONG) vk);
                i++;
            } else {
            /*  Input que is full, beep to notify  */
                MessageBeep(0);
            }
            break;
    }

    pQue->iLen = i;
    LocalUnlock((HANDLE)pTxt->hQue);

noque:
    LocalUnlock((HANDLE)hTxt);
    return TRUE;
}



void NEAR PASCAL UpdateCursorPos
(
    PTXT    pTxt
)
{
    int    iLine;
    int    y,x;
    int    iLen;
    SIZE   p;
    HDC    hdc;
    LPSTR  h;

    /*  If I don't do char input, or don't have the focus, forget it  */
    if (!pTxt->hQue || GetFocus() != pTxt->hwnd)
        return;

    hdc   = GetDC(NULL);
    SelectObject(hdc, pTxt->hFont);
    iLen  = pTxt->arLines[LAST(pTxt)].iLen - pTxt->iLeft;
    h	  = pTxt->arLines[LAST(pTxt)].cText;
    
    //  HACK HACK Need to account for tabs?
    GetTextExtentPoint(hdc, h + pTxt->iLeft, iLen,&p);
    iLine = pTxt->iCount - pTxt->iTop;
    ReleaseDC(NULL,hdc);

    y = OFFSETY + (iLine - 1) * pTxt->Tdy;
    x = OFFSETX + p.cx;
    SetCaretPos(x,y);
}


/*************************************************
 *
 *		OUTPUT APIS
 *
 *************************************************/



/* 
 * fSuccess = SetOutput(hwnd, wCommand, lpszFile)
 * 
 * Changes the output location of the window to be the location
 * designated by wParam, one of the WPFOUT_ codes.  If this specifies a
 * file, lParam points to the filename.
 * 
 * If the new output location cannot be opened/used, the previous output
 * location is not altered and FALSE is returned.  Otherwise, the
 * previous output location is closed (for files) and TRUE is returned.
 * 
 */
UINT NEAR PASCAL SetOutput
(
    HWND    hwnd,
    UINT    wParam,
    LONG    lParam
)
{
  PTXT	pTxt;
  HFILE hFile;
  HFILE	fhOld = -1;
  
  #define COM1_FH	(3)		// stdaux

  /*  Check for invalid command code  */
    if (!(wParam == WPFOUT_WINDOW || wParam == WPFOUT_COM1 ||
          wParam == WPFOUT_NEWFILE || wParam == WPFOUT_APPENDFILE ||
          wParam == WPFOUT_DISABLED)) {
        return FALSE;
    }

    pTxt = LOCKWININFO(hwnd);

  /*  Save the old file handle  */
    fhOld = pTxt->iFile;

  /*  If I'm using a file output type, setup the file handle  */
    switch (wParam) {
        case WPFOUT_COM1:
            pTxt->iFile = COM1_FH;
            break;
	
        case WPFOUT_APPENDFILE:
	/*  Open file to see if it is there, then seek to end  */
            hFile = _lopen((LPSTR) lParam, OF_READWRITE);
            if (hFile == -1) {
		/*  File didn't exist, just create it  */
                hFile = _lcreat((LPSTR) lParam, 0);
                if (hFile == -1) {
			/*  Couldn't open, just return FALSE  */
                    UNLOCKWININFO(hwnd)
                    return FALSE;
                }
            } else {
		/*  Seek to the end of existing file  */
                _llseek(hFile, 0L, 2);
            }
	
            pTxt->iFile = hFile;
            break;
	
        case WPFOUT_NEWFILE:
            hFile = _lcreat((LPSTR) lParam, 0);
            if (hFile == -1) {
                UNLOCKWININFO(hwnd)
                return FALSE;
            }
            pTxt->iFile = hFile;
            break;
	
        case WPFOUT_DISABLED:
        case WPFOUT_WINDOW:
            pTxt->iFile = -1;
            break;
	
    }

  /*  Clear any existing open file handle by closing it  */
    if (fhOld != -1 && fhOld != COM1_FH) {
	/*  Close the file  */
        _lclose(fhOld);
    }
  
    pTxt->wOutputLocation = wParam;
    UNLOCKWININFO(hwnd)
    return TRUE;

}



/* 
 * wOutput = GetOutput(hwnd)
 * 
 * Returns the output location for window hwnd (one of the WPFOUT_ codes)
 * 
 */
UINT NEAR PASCAL GetOutput
(
    HWND    hwnd
)
{
  PTXT	pTxt;
  UINT	w;

  pTxt = LOCKWININFO(hwnd);

  w = pTxt->wOutputLocation;

  UNLOCKWININFO(hwnd)
  return w;
}

/* 
 * @doc	EXTERNAL WINCOM WPFWINDOW
 * 
 * @api	int | wpfPrintf | This function prints a string to a WPF window
 * (or redirected output device) using <f printf> style formatting
 * codes.  The output is placed at the end of the specified WPF window,
 * which is scrolled as required.  This function does not yield.
 * 
 * @parm	HWND | hwnd | Specifies the WPF window.  Output to the window
 * may be redirected to a file or COM1 by sending a WPF_SETOUTPUT window
 * message to <p hwnd>.  If output has been redirected, this parameter
 * is still required as the current output location is stored in the WPF
 * window instance data.
 * 
 * @parm	LPSTR | lpszFormat | Points to the output string format
 * specification.  This string uses the same formatting codes as the
 * Windows <f wsprintf> function.
 * 
 * @parm	argument | [ arguments, ...] | Extra parameters
 * as required by the
 * formatting string.  Note that these parameters are in the form
 * required by <p wsprintf>, so that all string arguments must be far
 * pointers (LPSTR) or be cast to be far pointers.
 * 
 * @rdesc	Returns the number of characters output.  If output to
 * the WPF window is disabled, zero is returned.  The returned count of
 * characters output does not include the translation of newline
 * characters into carriage return newline sequences.
 *
 * @xref	wpfVprintf
 *
 */
int FAR cdecl wpfPrintf
(
    HWND    hwnd,
    LPSTR   lpszFormat,
    ...
)
{

#if defined(_ALPHA_)
    va_list ap;
    int iRet;

    va_start(ap,lpszFormat);
	iRet = wpfVprintf(hwnd, lpszFormat, ap);
    va_end(ap);

    return iRet;
#else
    return wpfVprintf(hwnd, lpszFormat, (LPSTR)(&lpszFormat + 1));
#endif

}


/* wpfWrtTTY(hWnd, sz)
 *
 * Print <sz> to wprintf window <hWnd>.
 *
 */

BOOL NEAR PASCAL wpfWrtTTY
(
    HWND    hWnd,
    LPSTR   sz
)
{
    RECT  rect;
    int   iLine;
    PTXT  pTxt;
    HTXT  hTxt;

    if (!hWnd)
        hWnd = hwndLast;

    if (!hWnd || !IsWindow(hWnd))
        return FALSE;  /* fail if bad window handle */

    hwndLast = hWnd;

    hTxt = (HTXT)GETWINDOWUINT (hWnd,0);
    pTxt = (PTXT)LocalLock((HANDLE)hTxt);

    iLine   = pTxt->iCount - pTxt->iTop;

    /*
     *	invalidate the last line to the bottom of window so
     *	new text will be painted.
     */
    GetClientRect(hWnd,&rect);
    rect.top += (iLine-1) * pTxt->Tdy;
    InvalidateRect (hWnd,&rect,FALSE);

    InsertString (pTxt, sz);  /* Insert text in the que */
    iLine = (pTxt->iCount - pTxt->iTop) - iLine;

    if (gbRedraw)
    {
        if (iLine > 0) {
            WpfSetScrollRange (hWnd,FALSE);
            WpfVScroll (hWnd,pTxt,pTxt->iCount);/* scroll all the way to bottom */
        }
#if 0
        else {
            WpfSetScrollRange (hWnd,TRUE);
        }
#endif
        UpdateCursorPos(pTxt);
        LocalUnlock((HANDLE)hTxt);
        UpdateWindow (hWnd);
    }
    else
    {
        LocalUnlock((HANDLE)hTxt);
    }

    return TRUE;
}

/* wpfScrollByLines (int nLine)
 *
 *
 *
 */

void FAR PASCAL wpfScrollByLines
(
    HWND hWnd,
    int  nLines
)
{
    PTXT  pTxt;
    HTXT  hTxt;

    hTxt = (HTXT)GETWINDOWUINT (hWnd,0);
    pTxt = (PTXT)LocalLock((HANDLE)hTxt);

    // make sure scrollbars are correct and scroll to the
    // selected line
    //
    WpfSetScrollRange (hWnd, FALSE);
    WpfVScroll (hWnd, pTxt, min (nLines, pTxt->iCount));

    // cleanup & repaint the window
    //
    UpdateCursorPos (pTxt);
    LocalUnlock ((HANDLE)hTxt);
    UpdateWindow (hWnd);
}


/* 
 * @doc	EXTERNAL WINCOM WPFWINDOW
 * 
 * @api	int | wpfVprintf | This function prints a string to a WPF window
 * (or redirected output device) using <f printf> style formatting
 * codes.  This function is the same as the <f wpfOut> function, except
 * that arguments to the format string are placed in an array of UINTs
 * or DWORDs.
 * 
 * @parm	HWND | hwnd | Specifies the WPF window.  Output to the window
 * may be redirected to a file or COM1 by sending a WPF_SETOUTPUT window
 * message to <p hwnd>.  If output has been redirected, this parameter
 * is still required as the current output location is stored in the WPF
 * window instance data.
 * 
 * @parm	LPSTR | lpszFormat | Points to the output string format
 * specification.  This string uses the same formatting codes as the
 * Windows <f wsprintf> function.
 * 
 * @parm	LPSTR | pargs | Points to an array of UINTs, each of which
 * specifies an argument for the format string <p lspzFormat>.  The
 * number, type, and interpretation of the arguments depend on the
 * corresponding format control sequences in <p lpszFormat>.
 * 
 * @rdesc	Returns the number of characters output.  If output to the
 * WPF window is disabled, zero is returned.  The returned count of
 * characters output does not include the translation of newline
 * characters into carriage return newline sequences.
 * 
 * @xref	wpfPrintf
 *
 */
int FAR cdecl wpfVprintf
(
    HWND    hwnd,
    LPSTR   lpszFormat,
#if defined(_ALPHA_)
    va_list pargs
#else
    LPSTR   pargs
#endif
)
{
  int	i;

  i = wvsprintf(bufTmp, lpszFormat, pargs);
  wpfOut(hwnd, bufTmp);

  return i;
}

/* 
 * @doc	WINCOM EXTERNAL WPFWINDOW
 * 
 * @api	void | wpfOut | This function prints a string to a WPF window
 * or redirected output device.  No formatting is carried out upon the
 * string, it is printed verbatim.
 * 
 * @parm	HWND | hwnd | Specifies the WPF window.  Output to the window
 * may be redirected to a file or COM1 by sending a WPF_SETOUTPUT window
 * message to <p hwnd>.  If output has been redirected, this parameter
 * is still required as the current output location is stored in the WPF
 * window instance data.
 * 
 * @parm	LPSTR | lpsz | Points to the string to be output.
 * 
 * @rdesc	None.
 * 
 * @xref	wpfPrintf
 * 
 */
void FAR PASCAL wpfOut
(
    HWND    hwnd,
    LPSTR   lpsz
)
{
    PTXT	pTxt;
    HTXT  hTxt;

    if (!IsWindow(hwnd))
        return;
  
    hTxt = (HTXT) GETWINDOWUINT(hwnd, 0);
    pTxt = (PTXT) LocalLock((HANDLE) hTxt);
  
    if (pTxt->wOutputLocation != WPFOUT_DISABLED) {
        if (pTxt->wOutputLocation == WPFOUT_WINDOW) {
            wpfWrtTTY(hwnd, lpsz);
        } else {
          wpfWrtFile(pTxt->iFile, lpsz);
        }
    }

    LocalUnlock((HANDLE) hTxt);
}

int NEAR Dup
(
    HFILE   fh
)
{
    return fh;
//_asm {
//	 mov	 bx,fh
//	 mov	 ah,45h 	     ; DUP Handle MSDOS function
//	 int	 21h
//     }
}

void wpfWrtFile
(
    HFILE   fh,
    LPSTR   sz
)
{
    LPSTR p, q;
    char save;

    if (fh == -1)
        return;

    /* output to <fh>, but must convert \n's to \n\r's;
     * code below is designed to minimize calls to write()
     */
    for (p = q = sz; *p != 0; p++) {
            /* e.g. bufTmp="hello\nabc", q->'h', p->'\n' */
            if (*p == '\n') {
                    /* hack: temporarily replace next char by \r */
                    /* won't work if string is READ-ONLY!!! */
                    save = *++p;            /* remember it */
                    p[0] = '\n';              /* replace by \r */
                    p[-1]= '\r';              /* replace by \r */
		    _lwrite(fh, q, p - q + 1);
                    q = p;                  /* for next write() */
                    *p-- = save;            /* un-hack */
                    *p   = '\n';
            }
    }
    if (p > q)              /* any part of <bufTmp> left to write */
	    _lwrite(fh, q, p - q);

    //
    // flush the file, by closing a copy of the file
    //
    _lclose(Dup(fh));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\dll\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef _WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
    #define wsprintfA           wsprintf
    #define MessageBoxA         MessageBox
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef _WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

#ifndef _WIN32
#pragma warning(disable:4704)
#endif

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static char     ach[300];       // debug output (avoid stack overflow)
    int             id;
#ifndef _WIN32
    int             iExitCode;
#endif

    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

    switch (id)
    {

    case IDABORT:               // Kill the application.
#ifndef _WIN32
        iExitCode = 0;
        _asm
        {
            mov ah, 4Ch
            mov al, BYTE PTR iExitCode
            int     21h
        }
#else
        FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
        break;

    case IDRETRY:               // Break into the debugger.
        DebugBreak();
        break;

    case IDIGNORE:              // Ignore assertion, continue executing.
        break;
    }
} // _Assert

#ifndef _WIN32
#pragma warning(default:4704)
#endif

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\dll\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "WAVETEST"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\addbuffr.c ===
//--------------------------------------------------------------------------;
//
//  File: Addbuffr.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//       waveInDMABufferSize()
//      Test_waveInAddBuffer()
//      Test_waveInAddBuffer_LTDMABufferSize()
//      Test_waveInAddBuffer_EQDMABufferSize()
//      Test_waveInAddBuffer_GTDMABufferSize()
//
//  History:
//      07/18/94    Fwong
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include <memgr.h>
#include <inimgr.h>
#include <waveutil.h>
#include <TstsHell.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "Debug.h"


DWORD FNGLOBAL waveInDMABufferSize
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx
)
{
    HWAVEIN             hWaveIn;
    volatile LPWAVEHDR  pWaveHdr;
    volatile LPWAVEHDR  pWaveHdrStub;
    LPBYTE              pData,pDataStub;
    LPWAVEINFO          pwi;
    DWORD               cbSize,cbDelta;
    DWORD               nBlockAlign;
    DWORD               dwTimeBuf;
    DWORD               dw;
    MMRESULT            mmr;

//#if 1
//    return 0L;
//#endif

    if(((UINT)WAVE_MAPPER) == uDeviceID)
    {
        //
        //  Not valid to get DMA buffer for wave mapper.
        //

        return 0L;
    }

    nBlockAlign = (DWORD)pwfx->nBlockAlign;

    //
    //  Allocating memory for first wave header
    //

    pWaveHdr = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return 0L;
    }

    //
    //  Allocating memory for second wave header...
    //

    pWaveHdrStub = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,sizeof(WAVEHDR));

    if(NULL == pWaveHdrStub)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);

        return 0L;
    }

    //
    //  Allocating memory for second buffer.
    //

    pDataStub = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,nBlockAlign);

    if(NULL == pDataStub)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pWaveHdrStub);

        return 0L;
    }

    //
    //  Allocating memory for WAVEINFO structure.
    //

    pwi = ExactAllocPtr(
            GMEM_SHARE|GMEM_FIXED,
            sizeof(WAVEINFO) + 2*sizeof(DWORD));

    if(NULL == pwi)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pWaveHdrStub);
        ExactFreePtr(pDataStub);

        return 0L;
    }

    PageLock(pwi);

    pwi->fdwFlags   = 0L;
    pwi->dwInstance = 0L;
    pwi->dwCount    = 2;
    pwi->dwCurrent  = 0;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = waveInOpen(
        &hWaveIn,
        uDeviceID,
        (HACK)pwfx,
        (DWORD)(FARPROC)pfnCallBack,
        0L,
        CALLBACK_FUNCTION);

    if(MMSYSERR_NOERROR != mmr)
    {
        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);
        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pWaveHdrStub);
        ExactFreePtr(pDataStub);

        return 0L;
    }

    pWaveHdrStub->lpData          = pDataStub;
    pWaveHdrStub->dwBufferLength  = nBlockAlign;
    pWaveHdrStub->dwBytesRecorded = 0L;
    pWaveHdrStub->dwFlags         = 0L;

    mmr = waveInPrepareHeader(hWaveIn,pWaveHdrStub,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);
        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pWaveHdrStub);
        ExactFreePtr(pDataStub);

        return 0L;
    }

    pwi->dwCurrent = 0;

    waveInAddBuffer(hWaveIn,pWaveHdrStub,sizeof(WAVEHDR));

    dw = waveGetTime();
    waveInStart(hWaveIn);

    //
    //  Spinning on WHDR_DONE bit.
    //

    while(!(WHDR_DONE & pWaveHdrStub->dwFlags));

    dwTimeBuf = ((pwi->adwTime[0] - dw)*3)/2;
    cbSize    = (pwfx->nAvgBytesPerSec * (pwi->adwTime[0] - dw))/1000;

    DPF(1,"cbSize = %lu",cbSize);

    //
    //  Allocating memory for data (2 * estimated buffer size)
    //

    pData = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,2*cbSize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        waveInUnprepareHeader(hWaveIn,pWaveHdrStub,sizeof(WAVEHDR));
        waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);
        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pWaveHdrStub);
        ExactFreePtr(pDataStub);

        return 0L;
    }

    pWaveHdr->lpData         = pData;
    pWaveHdr->dwBufferLength = 2*cbSize;
    pWaveHdr->dwFlags        = 0L;

    mmr = waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
    
    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        waveInUnprepareHeader(hWaveIn,pWaveHdrStub,sizeof(WAVEHDR));
        waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);
        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pWaveHdrStub);
        ExactFreePtr(pData);
        ExactFreePtr(pDataStub);

        return 0L;
    }

    cbSize  = ROUNDUP_TO_BLOCK(cbSize,nBlockAlign);
    cbDelta = ROUNDUP_TO_BLOCK(cbSize/2,nBlockAlign);

    DPF(1,"cbSize[%lu]:cbDelta[%lu]:dwTimeBuf[%lu]",cbSize,cbDelta,dwTimeBuf);

    for(;;)
    {
        pwi->dwCurrent = 0;
        
        pWaveHdr->dwBufferLength  = cbSize;
        pWaveHdr->dwBytesRecorded = 0L;
        
        waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

        dw = waveGetTime();
        waveInStart(hWaveIn);

        //
        //  Spinning on WHDR_DONE bit.
        //

        while(!(WHDR_DONE & pWaveHdr->dwFlags));

        pwi->adwTime[0] = pwi->adwTime[0] - dw;
        
        DPF(1,"cbSize[%lu]:cbDelta[%lu]:dwTime[%lu]",cbSize,cbDelta,pwi->adwTime[0]);

        if(dwTimeBuf > pwi->adwTime[0])
        {
            cbSize += cbDelta;
        }
        else
        {
            cbSize -= cbDelta;
        }

        if(cbDelta == nBlockAlign)
        {
            break;
        }

        cbDelta = (cbDelta / 2) + (cbDelta % 2);
        cbDelta = ROUNDUP_TO_BLOCK(cbDelta,nBlockAlign);
    }

    for(dw = pwi->adwTime[0];;cbSize += nBlockAlign)
    {
        pwi->dwCurrent = 0;
        
        pWaveHdr->dwBufferLength  = cbSize;
        pWaveHdr->dwBytesRecorded = 0L;
        
        waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

        dw = waveGetTime();
        waveInStart(hWaveIn);

        //
        //  Spinning on WHDR_DONE bit.
        //

        while(!(WHDR_DONE & pWaveHdr->dwFlags));

        dw = pwi->adwTime[0] - dw;

        if(dw > dwTimeBuf)
        {
            break;
        }

        DPF(1,"Loop1:cbSize[%lu]:dwTime[%lu]",cbSize,dw);
    }

    for(;;cbSize -= nBlockAlign)
    {
        pwi->dwCurrent = 0;
        
        pWaveHdr->dwBufferLength  = cbSize;
        pWaveHdr->dwBytesRecorded = 0L;
        
        waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

        dw = waveGetTime();
        waveInStart(hWaveIn);

        //
        //  Spinning on WHDR_DONE bit.
        //

        while(!(WHDR_DONE & pWaveHdr->dwFlags));

        dw = pwi->adwTime[0] - dw;

        if(dw < dwTimeBuf)
        {
            break;
        }

        DPF(1,"Loop2:cbSize[%lu]:dwTime[%lu]",cbSize,dw);
    }

    DPF(1,"Loop3:cbSize[%lu]:dwTime[%lu]",cbSize,dw);

    waveInReset(hWaveIn);
    waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
    waveInUnprepareHeader(hWaveIn,pWaveHdrStub,sizeof(WAVEHDR));
    waveInClose(hWaveIn);

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);
    ExactFreePtr(pwi);
    ExactFreePtr(pWaveHdr);
    ExactFreePtr(pWaveHdrStub);
    ExactFreePtr(pData);
    ExactFreePtr(pDataStub);

    return cbSize;
} // waveInDMABufferSize()


//--------------------------------------------------------------------------;
//
//  int Test_waveInAddBuffer
//
//  Description:
//      Tests the driver functionality for waveInAddBuffer.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInAddBuffer
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh1;
    volatile LPWAVEHDR  pwh2;
    DWORD               dw,dw2;
    DWORD               dwTime;
    DWORD               cbSize;
    LPBYTE              pData1,pData2;
    HANDLE              hHeap;
    LPWAVEINFO          pwi;
    LPBYTE              pNothing;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInAddBuffer";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Getting a buffer for recording...
    //

    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pNothing = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,0);

    if(NULL == pNothing)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pData1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pData2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Opening device...
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Preparing headers...
    //

    pwh1->lpData          = pData1;
    pwh1->dwBufferLength  = cbSize;
    pwh1->dwBytesRecorded = 0L;
    pwh1->dwUser          = 0L;
    pwh1->dwFlags         = 0L;

    pwh2->lpData          = pData2;
    pwh2->dwBufferLength  = cbSize;
    pwh2->dwBytesRecorded = 0L;
    pwh2->dwUser          = 0L;
    pwh2->dwFlags         = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveInPrepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  verify WHDR_DONE bit gets set in WAVEHDR w/ NULL callback.
    //

    Log_TestCase("~Verifying WHDR_DONE bit gets set w/ CALLBACK_NULL");

    dw  = ((pwh2->dwBufferLength * 1500)/gti.pwfxInput->nAvgBytesPerSec);
    dw2 = waveGetTime();

    DisableThreadCalls();

    mmr = call_waveInAddBuffer(hWaveIn,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInAddBuffer?
        //

        LogFail("waveInAddBuffer failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);

        EnableThreadCalls();

        return TST_FAIL;
    }

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInAddBuffer?
        //

        LogFail("waveInStart failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);

        EnableThreadCalls();

        return TST_FAIL;
    }

    EnableThreadCalls();

    tstLog(VERBOSE,"<< Polling WHDR_DONE bit in header. >>");

    while(!(pwh2->dwFlags & WHDR_DONE))
    {
        dwTime = waveGetTime() - dw2;

        if(dwTime > dw)
        {
            //
            //  Over 1.5 times expected time?!
            //

            LogFail("Driver has not set bit after 1 1/2 length of buffer");

            //
            //  To log pass/fail...
            //

            dw = 0;

            iResult = TST_FAIL;

            break;
        }
    }

    if(0 != dw)
    {
        LogPass("Driver set bit within 1 1/2 length of buffer");
    }

    call_waveInReset(hWaveIn);

    //
    //  Verify that recording partial buffer works.
    //  Note: we should be able to change the dwBufferLength field as long
    //        as the new one is shorter.
    //

    Log_TestCase("~Verifying that recording partial buffer works");

#pragma message(REMIND("Add more to this test case..."))
    dw  = pwh1->dwBufferLength;
    dw2 = ROUNDUP_TO_BLOCK(dw/2,gti.pwfxInput->nBlockAlign);

    pwh1->dwBufferLength  = dw2;
    pwh1->dwFlags        &= ~(WHDR_DONE);

    mmr = call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInAddBuffer?
        //

        LogFail("waveInAddBuffer failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInAddBuffer?
        //

        LogFail("waveInAddBuffer failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));

    //
    //  verify that writing zero sized buffer works.
    //

//    Log_TestCase("Verifying writing zero sized buffer works");
//
//    pwh2->lpData            = pNothing;
//    pwh2->dwBufferLength    = 0L;
//    pwh2->dwBytesRecorded   = 0L;
//    pwh2->dwUser            = 0L;
//    pwh2->dwFlags           = 0L;
//
//    mmr = call_waveInPrepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailWOPrepare);
//
//        call_waveInReset(hWaveIn);
//        call_waveInClose(hWaveIn);
//
//        ExactHeapDestroy(hHeap);
//        return TST_FAIL;
//    }
//
//    mmr = call_waveInAddBuffer(hWaveIn,pwh2,sizeof(WAVEHDR));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        //
//        //  There's a problem with waveInAddBuffer?
//        //
//
//        LogFail("waveInAddBuffer failed");
//
//        call_waveInReset(hWaveIn);
//        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
//        call_waveInClose(hWaveIn);
//
//        ExactHeapDestroy(hHeap);
//
//        return TST_FAIL;
//    }
//    else
//    {
//        LogPass("waveInAddBuffer w/ a zero sized buffer succeeds");
//    }
//
//    call_waveInReset(hWaveIn);
//    call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);

    pwi = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEINFO));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    dw = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|WAVE_ALLOWSYNC|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Preparing headers...
    //

    pwh1->lpData             = pData1;
    pwh1->dwBufferLength     = cbSize;
    pwh1->dwBytesRecorded    = 0L;
    pwh1->dwUser             = 0L;
    pwh1->dwFlags            = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWOPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

#ifndef WIN32

    //
    //  verify that driver is in FIXED memory.
    //

    Log_TestCase("~Verifying driver is in FIXED memory");

    mmr = call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInAddBuffer?
        //

        LogFail("waveInAddBuffer failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }
    
    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInStart?
        //

        LogFail("waveInStart failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }
    
    GlobalCompact((DWORD)(-1));

    //
    //  Waiting for callback...
    //

    while(!(pwi->fdwFlags & WIM_DATA_FLAG))
    {
        SLEEP(0);
    }

    //
    //  Note: If driver is not FIXED GlobalCompact should have forced it
    //        out of memory ().
    //
    //  If it gets this far, it passes.
    //

    LogPass("Parts of driver properly marked as FIXED");

    waveInReset(hWaveIn);

    pwh1->dwFlags  &= ~(WHDR_DONE);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;

#endif  //  WIN32

    //
    //  verify that recording same buffer multiple times fails.
    //

    Log_TestCase("~Verifying recording same buffer fails");

    mmr = call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInAddBuffer?
        //

        LogFail("waveInAddBuffer failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        //
        //  There's a problem with waveInStart?
        //

        LogFail("waveInStart failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);
        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    mmr = call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(WAVERR_STILLPLAYING != mmr)
    {
        LogFail("waveInAddBuffer for 2nd buffer did not return "
            "WAVERR_STILLPLAYING");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveInAddBuffer returned WAVERR_STILLPLAYING for 2nd buffer");
    }

    //
    //  verify that WHDR_INQUEUE bit is set (before callback).
    //

    Log_TestCase("~Verifying WHDR_INQUEUE bit is set (before callback)");

    if(pwh1->dwFlags & WHDR_INQUEUE)
    {
        if(pwi->fdwFlags & WIM_DATA_FLAG)
        {
            LogFail("WIM_DATA callback occured.  Test inconclusive");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("WHDR_INQUEUE bit set before callback");
        }
    }
    else
    {
        if(pwi->fdwFlags & WIM_DATA_FLAG)
        {
            LogFail("WIM_DATA callback occured.  Test inconclusive");
        }
        else
        {
            LogFail("WHDR_INQUEUE bit not set before callback");
        }

        iResult = TST_FAIL;
    }

    //
    //  verify that WHDR_DONE bit is clear (before callback).
    //

    Log_TestCase("~Verifying that WHDR_DONE bit is clear (before callback)");

    if(pwh1->dwFlags & WHDR_DONE)
    {
        if(pwi->fdwFlags & WIM_DATA_FLAG)
        {
            LogFail("WIM_DATA callback occured.  Test inconclusive");
        }
        else
        {
            LogFail("WHDR_DONE bit set before callback");
        }

        iResult = TST_FAIL;
    }
    else
    {
        if(pwi->fdwFlags & WIM_DATA_FLAG)
        {
            LogFail("WIM_DATA callback occured.  Test inconclusive");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("WHDR_DONE bit not set before callback");
        }
    }

    //
    //  Waiting for callback...
    //

    while(!(pwi->fdwFlags & WIM_DATA_FLAG))
    {
        SLEEP(0);
    }

    //
    //  verify that WHDR_INQUEUE bit is clear (after callback).
    //

    Log_TestCase("~Verifying that WHDR_INQUEUE bit is clear (after callback)");

    if(pwh1->dwFlags & WHDR_INQUEUE)
    {
        LogFail("WHDR_INQUEUE bit set after callback");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("WHDR_INQUEUE bit not set after callback");
    }

    //
    //  verify that WHDR_DONE bit is set (after callback).
    //

    Log_TestCase("~Verifying that WHDR_DONE bit is set (after callback)");

    if(pwh1->dwFlags & WHDR_DONE)
    {
        LogPass("WHDR_DONE bit set after callback");
    }
    else
    {
        LogFail("WHDR_DONE bit not set after callback");

        iResult = TST_FAIL;
    }

    //
    //  verify callback returned correct dwInstance.
    //

    Log_TestCase("~Verifying that callback received correct dwInstance");

    if(dw == pwi->dwInstance)
    {
        LogPass("Callback received correct dwInstance");
    }
    else
    {
        LogFail("Callback received incorrect dwInstance");

        iResult = TST_FAIL;
    }

    //
    //  Cleaning up...
    //

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);
    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveInAddBuffer()


int FNGLOBAL Test_waveInAddBuffer_LTDMABufferSize
(
    void
)
{
    HWAVEIN                 hWaveIn;
    MMRESULT                mmr;
    DWORD                   cNumBuffers;
    DWORD                   cbBufferSize;
    DWORD                   dw;
    DWORD                   dwOffset;
    LPBYTE                  pData;
    volatile LPWAVEHDR FAR *apwh;
    HANDLE                  hHeap;
    int                     iResult = TST_PASS;
    static char             szTestName[] = "waveInAddBuffer (Less than DMA buffer size)";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Dealing with DMA buffer size.
    //

    cbBufferSize = waveInDMABufferSize(gti.uInputDevice,gti.pwfxInput);

    if(0 == cbBufferSize)
    {
        //
        //  Unable to determine DMA buffer size; using 1/16 second.
        //

        dw           = (gti.pwfxInput->nAvgBytesPerSec / 16);
        cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxInput->nBlockAlign);

        tstLog(
            TERSE,
            "Not able to ascertain DMA buffer size.  Using %lu bytes.",
            cbBufferSize);
    }
    else
    {
        tstLog(
            TERSE,
            "Estimated DMA buffer size is: %lu bytes.",
            cbBufferSize);
    }

    dw = GetIniDWORD(szTestName,gszRatio,0x0000c000);

    tstLog(VERBOSE,"Ratio to buffer size is " RATIO_FORMAT ".", RATIO(dw));

    if(0x10000 < dw)
    {
        LogFail("Ratio is not less than 1.00");

        return TST_FAIL;
    }

    dw = (cbBufferSize * dw) / 0x10000;

    cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxInput->nBlockAlign);

    tstLog(VERBOSE,"New buffer size is: %lu bytes",cbBufferSize);

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);
    dw          = cNumBuffers * sizeof(LPWAVEHDR);
    apwh        = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,dw);

    if(NULL == apwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == apwh[dw-1])
        {
            //
            //  Allocating memory failed.
            //

            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    pData = ExactHeapAllocPtr(
                hHeap,
                GMEM_MOVEABLE|GMEM_SHARE,
                cNumBuffers * cbBufferSize);

    if(NULL == pData)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        WAVE_ALLOWSYNC|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Setting up wave headers contents and preparing.
    //

    dwOffset = 0;
    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1]->lpData          = (LPBYTE)(&pData[dwOffset]);
        apwh[dw-1]->dwBufferLength  = cbBufferSize;
        apwh[dw-1]->dwBytesRecorded = 0L;
        apwh[dw-1]->dwUser          = 0L;
        apwh[dw-1]->dwFlags         = 0L;
        apwh[dw-1]->dwLoops         = 0L;
        apwh[dw-1]->lpNext          = NULL;
        apwh[dw-1]->reserved        = 0L;

        dwOffset += cbBufferSize;

        mmr = call_waveInPrepareHeader(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            for(;dw < cNumBuffers;dw++)
            {
                call_waveInUnprepareHeader(hWaveIn,apwh[dw],sizeof(WAVEHDR));
            }

            call_waveInClose(hWaveIn);

            LogFail(gszFailWIPrepare);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Recording...
    //

    for(dw = cNumBuffers; dw; dw--)
    {
        call_waveInAddBuffer(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));
    }

    call_waveInStart(hWaveIn);

    //
    //  Unpreparing...
    //

    tstLog(VERBOSE,"<< Polling WHDR_DONE bit in header(s). >>");

    for(dw = cNumBuffers; dw; dw--)
    {
        while(!(apwh[dw-1]->dwFlags & WHDR_DONE));

        call_waveInUnprepareHeader(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));
    }

    //
    //  Verify that driver uses entire (block aligned) buffer.
    //

    Log_TestCase("~Verifying driver used entire (block aligned) buffer");

    for(dw = cNumBuffers; dw; dw--)
    {
        if(apwh[dw-1]->dwBufferLength != apwh[dw-1]->dwBytesRecorded)
        {
            LogFail("~Driver didn't use full buffer "
                "(dwBufferLength != dwBytesRecorded)");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("~Driver used entire buffer");
        }
    }

    //
    //  Cleaning up...
    //

    call_waveInReset(hWaveIn);
    call_waveInClose(hWaveIn);

    //
    //  Playing recorded stuff...
    //

    PlayWaveResource(gti.pwfxInput, pData, cNumBuffers * cbBufferSize);

    //
    //  Freeing memory...
    //

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveInAddBuffer_LTDMABufferSize()


int FNGLOBAL Test_waveInAddBuffer_EQDMABufferSize
(
    void
)
{
    HWAVEIN                 hWaveIn;
    MMRESULT                mmr;
    DWORD                   cNumBuffers;
    DWORD                   cbBufferSize;
    DWORD                   dw;
    DWORD                   dwOffset;
    LPBYTE                  pData;
    volatile LPWAVEHDR FAR *apwh;
    HANDLE                  hHeap;
    int                     iResult = TST_PASS;
    static char             szTestName[] = "waveInAddBuffer (DMA buffer size)";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Dealing with DMA buffer size.
    //

    cbBufferSize = waveInDMABufferSize(gti.uInputDevice,gti.pwfxInput);

    if(0 == cbBufferSize)
    {
        //
        //  Unable to determine DMA buffer size; using 1/16 second.
        //

        dw           = (gti.pwfxInput->nAvgBytesPerSec / 16);
        cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxInput->nBlockAlign);

        tstLog(
            TERSE,
            "Not able to ascertain DMA buffer size.  Using %lu bytes.",
            cbBufferSize);
    }
    else
    {
        tstLog(
            TERSE,
            "Estimated DMA buffer size is: %lu bytes.",
            cbBufferSize);
    }

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);
    dw          = cNumBuffers * sizeof(LPWAVEHDR);
    apwh        = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,dw);

    if(NULL == apwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == apwh[dw-1])
        {
            //
            //  Allocating memory failed.
            //

            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    pData = ExactHeapAllocPtr(
                hHeap,
                GMEM_MOVEABLE|GMEM_SHARE,
                cNumBuffers * cbBufferSize);

    if(NULL == pData)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        WAVE_ALLOWSYNC|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Setting up wave headers contents and preparing.
    //

    dwOffset = 0;
    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1]->lpData          = (LPBYTE)(&pData[dwOffset]);
        apwh[dw-1]->dwBufferLength  = cbBufferSize;
        apwh[dw-1]->dwBytesRecorded = 0L;
        apwh[dw-1]->dwUser          = 0L;
        apwh[dw-1]->dwFlags         = 0L;
        apwh[dw-1]->dwLoops         = 0L;
        apwh[dw-1]->lpNext          = NULL;
        apwh[dw-1]->reserved        = 0L;

        dwOffset += cbBufferSize;

        mmr = call_waveInPrepareHeader(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            for(;dw < cNumBuffers;dw++)
            {
                call_waveInUnprepareHeader(hWaveIn,apwh[dw],sizeof(WAVEHDR));
            }

            call_waveInClose(hWaveIn);

            LogFail(gszFailWIPrepare);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Recording...
    //

    for(dw = cNumBuffers; dw; dw--)
    {
        call_waveInAddBuffer(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));
    }

    call_waveInStart(hWaveIn);

    //
    //  Unpreparing...
    //

    tstLog(VERBOSE,"<< Polling WHDR_DONE bit in header(s). >>");

    for(dw = cNumBuffers; dw; dw--)
    {
        while(!(apwh[dw-1]->dwFlags & WHDR_DONE));

        call_waveInUnprepareHeader(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));
    }

    //
    //  Verify that driver uses entire (block aligned) buffer.
    //

    Log_TestCase("~Verifying driver used entire (block aligned) buffer");

    for(dw = cNumBuffers; dw; dw--)
    {
        if(apwh[dw-1]->dwBufferLength != apwh[dw-1]->dwBytesRecorded)
        {
            LogFail("~Driver didn't use full buffer "
                "(dwBufferLength != dwBytesRecorded)");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("~Driver used entire buffer");
        }
    }

    //
    //  Cleaning up...
    //

    call_waveInReset(hWaveIn);
    call_waveInClose(hWaveIn);

    //
    //  Playing recorded stuff...
    //

    PlayWaveResource(gti.pwfxInput, pData, cNumBuffers * cbBufferSize);

    //
    //  Freeing memory...
    //

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveInAddBuffer_EQDMABufferSize()


int FNGLOBAL Test_waveInAddBuffer_GTDMABufferSize
(
    void
)
{
    HWAVEIN                 hWaveIn;
    MMRESULT                mmr;
    DWORD                   cNumBuffers;
    DWORD                   cbBufferSize;
    DWORD                   dw;
    DWORD                   dwOffset;
    LPBYTE                  pData;
    volatile LPWAVEHDR FAR *apwh;
    HANDLE                  hHeap;
    int                     iResult = TST_PASS;
    static char             szTestName[] = "waveInAddBuffer (Greater "
                                "than DMA buffer size)";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Dealing with DMA buffer size.
    //

    cbBufferSize = waveInDMABufferSize(gti.uInputDevice,gti.pwfxInput);

    if(0 == cbBufferSize)
    {
        //
        //  Unable to determine DMA buffer size; using 1/16 second.
        //

        dw           = (gti.pwfxInput->nAvgBytesPerSec / 16);
        cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxInput->nBlockAlign);

        tstLog(
            TERSE,
            "Not able to ascertain DMA buffer size.  Using %lu bytes.",
            cbBufferSize);
    }
    else
    {
        tstLog(
            TERSE,
            "Estimated DMA buffer size is: %lu bytes.",
            cbBufferSize);
    }

    dw = GetIniDWORD(szTestName,gszRatio,0x00014000);

    tstLog(VERBOSE,"Ratio to buffer size is " RATIO_FORMAT ".", RATIO(dw));

    if(0x10000 > dw)
    {
        LogFail("Ratio is not greater than 1.00");

        return TST_FAIL;
    }

    dw = (cbBufferSize * dw) / 0x10000;

    cbBufferSize = ROUNDUP_TO_BLOCK(dw,gti.pwfxInput->nBlockAlign);

    tstLog(VERBOSE,"New buffer size is: %lu bytes",cbBufferSize);

    //
    //  Allocating heap.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  Allocating memory for wave headers
    //

    cNumBuffers = GetIniDWORD(szTestName,gszBufferCount,32L);
    dw          = cNumBuffers * sizeof(LPWAVEHDR);
    apwh        = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,dw);

    if(NULL == apwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1] = ExactHeapAllocPtr(
                        hHeap,
                        GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR));

        if(NULL == apwh[dw-1])
        {
            //
            //  Allocating memory failed.
            //

            LogFail(gszFailNoMem);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    pData = ExactHeapAllocPtr(
                hHeap,
                GMEM_MOVEABLE|GMEM_SHARE,
                cNumBuffers * cbBufferSize);

    if(NULL == pData)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        WAVE_ALLOWSYNC|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Setting up wave headers contents and preparing.
    //

    dwOffset = 0;
    for(dw = cNumBuffers; dw; dw--)
    {
        apwh[dw-1]->lpData          = (LPBYTE)(&pData[dwOffset]);
        apwh[dw-1]->dwBufferLength  = cbBufferSize;
        apwh[dw-1]->dwBytesRecorded = 0L;
        apwh[dw-1]->dwUser          = 0L;
        apwh[dw-1]->dwFlags         = 0L;
        apwh[dw-1]->dwLoops         = 0L;
        apwh[dw-1]->lpNext          = NULL;
        apwh[dw-1]->reserved        = 0L;

        dwOffset += cbBufferSize;

        mmr = call_waveInPrepareHeader(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));

        if(MMSYSERR_NOERROR != mmr)
        {
            for(;dw < cNumBuffers;dw++)
            {
                call_waveInUnprepareHeader(hWaveIn,apwh[dw],sizeof(WAVEHDR));
            }

            call_waveInClose(hWaveIn);

            LogFail(gszFailWIPrepare);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }
    }

    //
    //  Recording...
    //

    for(dw = cNumBuffers; dw; dw--)
    {
        call_waveInAddBuffer(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));
    }

    call_waveInStart(hWaveIn);

    //
    //  Unpreparing...
    //

    tstLog(VERBOSE,"<< Polling WHDR_DONE bit in header(s). >>");

    for(dw = cNumBuffers; dw; dw--)
    {
        while(!(apwh[dw-1]->dwFlags & WHDR_DONE));

        call_waveInUnprepareHeader(hWaveIn,apwh[dw-1],sizeof(WAVEHDR));
    }

    //
    //  Verify that driver uses entire (block aligned) buffer.
    //

    Log_TestCase("~Verifying driver used entire (block aligned) buffer");

    for(dw = cNumBuffers; dw; dw--)
    {
        if(apwh[dw-1]->dwBufferLength != apwh[dw-1]->dwBytesRecorded)
        {
            LogFail("~Driver didn't use full buffer "
                "(dwBufferLength != dwBytesRecorded)");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("~Driver used entire buffer");
        }
    }

    //
    //  Cleaning up...
    //

    call_waveInReset(hWaveIn);
    call_waveInClose(hWaveIn);

    //
    //  Playing recorded stuff...
    //

    PlayWaveResource(gti.pwfxInput, pData, cNumBuffers * cbBufferSize);

    //
    //  Freeing memory...
    //

    ExactHeapDestroy(hHeap);

    return iResult;
} // Test_waveInAddBuffer_GTDMABufferSize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\dll\wavecb.c ===
//--------------------------------------------------------------------------;
//
//  File: Wavecb.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      WaveCallback()
//      WaveControl()
//
//  History:
//      03/14/94    Fwong
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "debug.h"

//==========================================================================;
//
//                              Globals...
//
//==========================================================================;

LPWAVEINFO  pwi     = NULL;

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;

#ifdef DEBUG
#define DBGOUT(a)   OutputDebugStr("WAVECB:" a "\r\n")
#else
#define DBGOUT(a)   // a
#endif

ULONG waveGetTime( VOID )
{
   LARGE_INTEGER  time, frequency ;

   QueryPerformanceCounter( &time ) ;
   QueryPerformanceFrequency( &frequency ) ;

   return (ULONG) (time.QuadPart * (LONGLONG) 1000 / frequency.QuadPart) ;
}

#if 0
ULONG waveGetTime( VOID )
{
   return timeGetTime() ;
}
#endif

//--------------------------------------------------------------------------;
//
//  void WaveCallback
//
//  Description:
//      Callback function for waveXOpen's.
//
//  Arguments:
//      HANDLE hWave: Handle to wave device.
//
//      UINT uMsg: Message type.
//
//      DWORD dwInstance: Instance passed to waveXOpen function.
//
//      DWORD dwParam1: Message dependent.
//
//      DWORD dwParam2: Message dependent.
//
//  Return (void):
//
//  History:
//      08/12/94    Fwong       Fat Birds Don't Fly.
//
//--------------------------------------------------------------------------;

void FNEXPORT WaveCallback
(
    HANDLE  hWave,
    UINT    uMsg,
    DWORD   dwInstance,
    DWORD   dwParam1,
    DWORD   dwParam2
)
{
    DWORD               dwTime ;
    volatile LPWAVEHDR  pwh;

    DBGOUT("WaveCallback");

    if(NULL == pwi)
    {
        return;
    }

    dwTime = waveGetTime();

    switch (uMsg)
    {
        case WOM_OPEN:
            pwi->fdwFlags   |= WOM_OPEN_FLAG;
            pwi->dwInstance  = dwInstance;
            break;

        case WOM_CLOSE:
            pwi->fdwFlags  |= WOM_CLOSE_FLAG;
            pwi->dwInstance = dwInstance;
            break;

        case WOM_DONE:
            pwi->fdwFlags  |= WOM_DONE_FLAG;
            pwi->dwInstance = dwInstance;

            if(pwi->dwCount > pwi->dwCurrent)
            {
                pwi->adwTime[pwi->dwCurrent++] = dwTime;
            }

            pwh = (LPWAVEHDR)dwParam1;

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                pwi->fdwFlags |= WHDR_DONE_ERROR;
            }

            break;

        case WIM_OPEN:
            pwi->fdwFlags |= WIM_OPEN_FLAG;
            pwi->dwInstance =  dwInstance;
            break;

        case WIM_CLOSE:
            pwi->fdwFlags |= WIM_CLOSE_FLAG;
            pwi->dwInstance =  dwInstance;
            break;

        case WIM_DATA:
            pwi->fdwFlags |= WIM_DATA_FLAG;
            pwi->dwInstance =  dwInstance;

            if(pwi->dwCount > pwi->dwCurrent)
            {
                pwi->adwTime[pwi->dwCurrent++] = dwTime;
            }

            pwh = (LPWAVEHDR)dwParam1;

            if(!(pwh->dwFlags & WHDR_DONE))
            {
                pwi->fdwFlags |= WHDR_DONE_ERROR;
            }

            break;
    }

    return;
} // WaveCallback()


//--------------------------------------------------------------------------;
//
//  DWORD WaveControl
//
//  Description:
//      Wave Control entry point to communicate better with application.
//
//  Arguments:
//      UINT uMsg: Type of message.
//
//      LPVOID pvoid: Message dependent.
//
//  Return (DWORD):
//      Currently unused.
//
//  History:
//      08/12/94    Fwong       Fat Birds Don't Fly.
//
//--------------------------------------------------------------------------;

DWORD FNEXPORT WaveControl
(
    UINT    uMsg,
    LPVOID  pvoid
)
{
    DBGOUT("WaveControl");

    switch (uMsg)
    {
        case DLL_INIT:
            pwi = (LPWAVEINFO)pvoid;
            DbgInitialize( TRUE ) ;
            return 0L;

        case DLL_END:
            pwi = NULL;
            return 0L;
    }
} // WaveControl()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\appport.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  appport.h
//
//  Description:
//      This file contains common macros to help with writing code that
//      cross compiles between Win 32 and Win 16. This file should be
//      included _after_ windows.h and windowsx.h.
//
//
//==========================================================================;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK
    #endif


    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif

    //
    //  win32 apps [usually] don't have to worry about 'huge' data
    //
    #ifndef hmemcpy
    #define hmemcpy     memcpy
    #endif

#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNCALLBACK  FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNCALLBACK  FAR PASCAL _export
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #ifndef _MMRESULT_
    #define _MMRESULT_
    typedef UINT        MMRESULT;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "WAVETEST"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1992, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef _WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
    #define wsprintfA           wsprintf
    #define MessageBoxA         MessageBox
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef _WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

#ifndef _WIN32
#pragma warning(disable:4704)
#endif

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static char     ach[300];       // debug output (avoid stack overflow)
    int             id;
#ifndef _WIN32
    int             iExitCode;
#endif

    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

    switch (id)
    {

    case IDABORT:               // Kill the application.
#ifndef _WIN32
        iExitCode = 0;
        _asm
        {
            mov ah, 4Ch
            mov al, BYTE PTR iExitCode
            int     21h
        }
#else
        FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
        break;

    case IDRETRY:               // Break into the debugger.
        DebugBreak();
        break;

    case IDIGNORE:              // Ignore assertion, continue executing.
        break;
    }
} // _Assert

#ifndef _WIN32
#pragma warning(default:4704)
#endif

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1992 - 1996  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\exectest.c ===
//--------------------------------------------------------------------------;
//
//  File: ExecTest.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Contains execTest and possible helper functions.
//
//  Contents:
//      AllFormats()
//      zyzSmag()
//      execTest()
//
//  History:
//      11/24/93    Fwong       Re-doing WaveTest.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memgr.h>
#include <waveutil.h>
#include "AppPort.h"
#include "WaveTest.h"
#include <TstsHell.h>
#include "Debug.h"

#include <conio.h>

//==========================================================================;
//
//                              Typedef's
//
//==========================================================================;

typedef int (FNGLOBAL* WAVETESTPROC)(void);


//--------------------------------------------------------------------------;
//
//  int AllFormats
//
//  Description:
//      This function runs test cases through all formats.
//
//  Arguments:
//      WAVETESTPROC pfnTestProc: Pointer to test function.
//
//      BOOL fOutput: TRUE if testing output function.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      06/30/94    Fwong       Getting better coverage.
//
//--------------------------------------------------------------------------;

int FNGLOBAL AllFormats
(
    WAVETESTPROC    pfnTestProc,
    BOOL            fOutput
)
{
    DWORD           dw;
    MMRESULT        mmr;
    LPWAVEFORMATEX  pwfx;
    LPWAVEFORMATEX  pwfxSave;
#ifdef DEBUG
    char            szFormat[MAXSTDSTR];
#endif
    int             iResult = TST_PASS;

    if(!(gti.fdwFlags & TESTINFOF_ALL_FMTS))
    {
        return (pfnTestProc());
    }

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,gti.cbMaxFormatSize);

    if(NULL == pwfx)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    if(fOutput)
    {
        pwfxSave = gti.pwfxOutput;
    }
    else
    {
        pwfxSave = gti.pwfxInput;
    }

    for(dw = tstGetNumFormats();dw;dw--)
    {
        if(!tstGetFormat(pwfx,gti.cbMaxFormatSize,dw-1))
        {
            DPF(1,"Couldn't get format #%d.",dw-1);

            continue;
        }

        if(fOutput)
        {
            mmr = waveOutOpen(
                NULL,
                gti.uOutputDevice,
                (HACK)pwfx,
                0L,
                0L,
                WAVE_ALLOWSYNC|WAVE_FORMAT_QUERY|OUTPUT_MAP(gti));

            if(MMSYSERR_NOERROR == mmr)
            {
                gti.pwfxOutput = pwfx;

                //
                //  Re-loading the resources for new format...
                //

                DPF(1,"Before loading resources: %lu",GetNumAllocations());

                LoadWaveResource(&gti.wrShort,WR_SHORT);
                LoadWaveResource(&gti.wrMedium,WR_MEDIUM);
                LoadWaveResource(&gti.wrLong,WR_LONG);

                DPF(1,"After loading resources: %lu",GetNumAllocations());
#ifdef DEBUG
                GetFormatName(szFormat,pwfx,sizeof(szFormat));

                DPF(1,"Format for test: %s",(LPSTR)szFormat);
#endif

                iResult &= (pfnTestProc());
            }
        }
        else
        {
            mmr = waveInOpen(
                NULL,
                gti.uInputDevice,
                (HACK)pwfx,
                0L,
                0L,
                WAVE_FORMAT_QUERY|INPUT_MAP(gti));

            if(MMSYSERR_NOERROR == mmr)
            {
                gti.pwfxInput = pwfx;

                iResult &= (pfnTestProc());
            }
        }

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            //
            //  Aborted!!!  Cleaning up...
            //

            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            iResult = TST_FAIL;

            break;
        }
    }

    if(fOutput)
    {
        gti.pwfxOutput = pwfxSave;

        //
        //  Reverting resources to old format...
        //

        LoadWaveResource(&gti.wrShort,WR_SHORT);
        LoadWaveResource(&gti.wrMedium,WR_MEDIUM);
        LoadWaveResource(&gti.wrLong,WR_LONG);
    }
    else
    {
        gti.pwfxInput = pwfxSave;
    }

    ExactFreePtr(pwfx);

    return iResult;
} // AllFormats()

//--------------------------------------------------------------------------;
//
//  int zyzSmag
//
//  Description:
//      Temporary Test function...  In the honor of CurtisP
//
//  Arguments:
//      None.
//
//  Return (int):
//
//  History:
//      02/21/94    Fwong       Random Thing.
//
//--------------------------------------------------------------------------;

int zyzSmag()
{
    HWAVEOUT            hwo;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    int                 iResult = TST_PASS;
    BYTE                bIn;

    return iResult;

} // zyzSmag()


//--------------------------------------------------------------------------;
//
//  int execTest
//
//  Description:
//      This functions executes the tests on a per test case basis
//
//  Arguments:
//      int nFxID: Test case number.
//
//      int nCase: Required by TstsHell.  Not really used in WaveTest
//
//      WORD nID: Required by TstsHell.  Not really used in WaveTest
//
//      WORD wGroupID: Required by TstsHell.  Not really used in WaveTest
//
//  Return (int):
//      The actual results from the individual test.
//
//  History:
//      11/24/93    Fwong       Called by TstsHell...  How it works is
//                              Black Magic! (TstsHell that is...)
//
//--------------------------------------------------------------------------;

int execTest
(
    int     nFxID,
    int     nCase,
    UINT    nID,
    UINT    wGroupID
)
{
    int     ret = TST_FAIL;
    DWORD   cAllocBefore,cAllocAfter;
   
    GetAsyncKeyState(VK_ESCAPE);

//    log_formats();

    tstBeginSection(NULL);
    tstLog(VERBOSE,"");

    cAllocBefore = GetNumAllocations();
    DPF(3,"cAllocBefore: %lu",cAllocBefore);

    switch(nFxID)
    {

        //
        //  Device Info tests
        //
      
        case FN_IDEVCAPS:
            ret = Test_waveInGetDevCaps();
            break;

        case FN_ODEVCAPS:
            ret = Test_waveOutGetDevCaps();
            break;

        //
        //  Open/Close tests
        //

        case FN_IOPEN:
            ret = Test_waveInOpen();
            break;

        case FN_ICLOSE:
            ret = Test_waveInClose();
            break;

        case FN_OOPEN:
            ret = Test_waveOutOpen();
            break;

        case FN_OCLOSE:
            ret = Test_waveOutClose();
            break;

        //
        //  Wave Out tests
        //

        case FN_OGETPOS:
            ret = AllFormats(Test_waveOutGetPosition,TRUE);
            break;

        case FN_OPREPHDR:
            ret = Test_waveOutPrepareHeader();
            break;

        case FN_OUNPREPHDR:
            ret = Test_waveOutUnprepareHeader();
            break;

        case FN_OBRKLOOP:
            ret = Test_waveOutBreakLoop();
            break;

        case FN_OPAUSE:
            ret = Test_waveOutPause();
            break;

        case FN_ORESTART:
            ret = Test_waveOutRestart();
            break;

        case FN_ORESET:
            ret = Test_waveOutReset();
            break;

        //
        //  Wave In tests
        //

        case FN_IGETPOS:
            ret = AllFormats(Test_waveInGetPosition,FALSE);
            break;

        case FN_IPREPHDR:
            ret = Test_waveInPrepareHeader();
            break;

        case FN_IUNPREPHDR:
            ret = Test_waveInUnprepareHeader();
            break;

        case FN_ISTART:
            ret = Test_waveInStart();
            break;

        case FN_ISTOP:
            ret = Test_waveInStop();
            break;

        case FN_IRESET:
            ret = Test_waveInReset();
            break;

        //
        //  Wave Out Options
        //

        case FN_OGETPITCH:
            ret = Test_waveOutGetPitch();
            break;

        case FN_OGETRATE:
            ret = Test_waveOutGetPlaybackRate();
            break;

        case FN_OSETPITCH:
            ret = Test_waveOutSetPitch();
            break;

        case FN_OSETRATE:
            ret = Test_waveOutSetPlaybackRate();
            break;

        case FN_OGETVOL:
            ret = Test_waveOutGetVolume();
            break;

        case FN_OSETVOL:
            ret = Test_waveOutSetVolume();
            break;

        //
        //  waveOutWrite tests
        //

        case FN_OWRITE:
            ret = AllFormats(Test_waveOutWrite,TRUE);
            break;

        case FN_OW_LTBUF:
            ret = AllFormats(Test_waveOutWrite_LTDMABufferSize,TRUE);
            break;

        case FN_OW_EQBUF:
            ret = AllFormats(Test_waveOutWrite_EQDMABufferSize,TRUE);
            break;

        case FN_OW_GTBUF:
            ret = AllFormats(Test_waveOutWrite_GTDMABufferSize,TRUE);
            break;

        case FN_OW_LOOP:
            ret = AllFormats(Test_waveOutWrite_Loop,TRUE);
            break;

        case FN_OW_STARVE:
            ret = AllFormats(Test_waveOutWrite_Starve,TRUE);
            break;

        //
        //  waveInAddBuffer tests
        //

        case FN_IADDBUFFER:
            ret = AllFormats(Test_waveInAddBuffer,FALSE);
            break;

        case FN_IAB_LTBUF:
            ret = AllFormats(Test_waveInAddBuffer_LTDMABufferSize,FALSE);
            break;

        case FN_IAB_EQBUF:
            ret = AllFormats(Test_waveInAddBuffer_EQDMABufferSize,FALSE);
            break;

        case FN_IAB_GTBUF:
            ret = AllFormats(Test_waveInAddBuffer_GTDMABufferSize,FALSE);
            break;

        //
        //  Performance tests
        //

        case FN_IGETPOS_ACC:
            ret = AllFormats(Test_waveInGetPosition_Accuracy,FALSE);
            break;

        case FN_OGETPOS_ACC:
            ret = AllFormats(Test_waveOutGetPosition_Accuracy,TRUE);
            break;

        case FN_OW_TIME:
            ret = AllFormats(Test_waveOutWrite_TimeAccuracy,TRUE);
            break;

        case FN_IAB_TIME:
            ret = AllFormats(Test_waveInAddBuffer_TimeAccuracy,FALSE);
            break;

        case FN_IPOS_PERF:
            ret = Test_waveInGetPosition_Performance();
            break;

        case FN_OPOS_PERF:
            ret = Test_waveOutGetPosition_Performance();
//            ret = Test_waveOutStreaming();
            break;

        default:
            tstLog(TERSE,"Unknown Test Case..");    
            break;
    }

    tstLog(VERBOSE,"\n");

    cAllocAfter = GetNumAllocations();
    DPF(3,"cAllocAfter: %lu",cAllocAfter);

    if(cAllocBefore != cAllocAfter)
    {
        tstLog(
            TERSE,
            "Warning: Possible memory leak\nBefore:%lu\nAfter:%lu",
            cAllocBefore,
            cAllocAfter);
    }

    tstEndSection();

    if(tstCheckRunStop(VK_ESCAPE))
    {
        return(TST_FAIL);
    }
   
    return(ret);
} // execTest()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\log.c ===
//--------------------------------------------------------------------------;
//
//  File: Log.c
//
//  Copyright (C) Microsoft Corporation, 1993 - 1996  All rights reserved
//
//  Abstract:
//      Contains basic logging functions and application .ini file
//          support.
//
//  Contents:
//      Log_TestName()
//      Log_TestCase()
//      LogPercentOff()
//      LogPass()
//      LogFail()
//      GetErrorText()
//      GetTimeTypeText()
//      IdiotBox()
//      Log_Error()
//      DebugLog_Error()
//      HexDump()
//      StringToDWORD()
//      EnumPid()
//      EnumMid()
//      Log_FormatTag()
//      Enum_WAVECAPS_Formats()
//      Enum_WAVEOUTCAPS_Support()
//      Enum_waveOpen_Flags()
//      Log_WAVEFORMATEX()
//      Log_MMTIME()
//      Log_WAVEHDR()
//      Log_WAVEINCAPS()
//      Log_WAVEOUTCAPS()
//
//  History:
//      11/24/93    Fwong       Re-doing WaveTest.
//
//--------------------------------------------------------------------------;

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <TstsHell.h>
#include <inimgr.h>
#include <waveutil.h>
#include "MulDiv32.h"
#include "AppPort.h"
#include "WaveTest.h"
#include "Debug.h"


//--------------------------------------------------------------------------;
//
//  void Log_TestName
//
//  Description:
//      Logs the test name (typically at the beginning of test).
//
//  Arguments:
//      LPSTR pszTestName: Buffer w/ test name.
//
//  Return (void):
//
//  History:
//      08/11/93    Fwong       For ACM driver testing.
//
//--------------------------------------------------------------------------;

void FNGLOBAL Log_TestName
(
    LPSTR   pszTestName
)
{
    tstLog(TERSE,"%s Tests:",(LPSTR)pszTestName);
    tstLogStatusBar(pszTestName);
    DPF(1,"Running %s tests...",(LPSTR)pszTestName);
} // Log_TestName()


//--------------------------------------------------------------------------;
//
//  void Log_FunctionName
//
//  Description:
//      Logs the function name.
//
//  Arguments:
//      LPSTR pszFnName: String with function name.
//
//  Return (void):
//
//  History:
//      12/03/93    Fwong       For API wrappers.
//
//--------------------------------------------------------------------------;

//void FNGLOBAL Log_FunctionName
//(
//    LPSTR   pszFnName
//)
//{
//    tstLog(VERBOSE,"\n*** %s ***",pszFnName);
//} // Log_FunctionName()


//--------------------------------------------------------------------------;
//
//  void Log_TestCase
//
//  Description:
//      Logs the test case.
//
//  Arguments:
//      LPSTR pszTestCase: String with test case.
//
//  Return (void):
//
//  History:
//      03/28/94    Fwong       For test case management.
//
//--------------------------------------------------------------------------;

void FNGLOBAL Log_TestCase
(
    LPSTR   pszTestCase
)
{
    if('~' == pszTestCase[0])
    {
        pszTestCase++;
        tstLog(VERBOSE,"\nTESTCASE: %s.",pszTestCase);
    }
    else
    {
        tstLog(VERBOSE,"\nTESTCASE: %s.\n",pszTestCase);
    }

    tstLogStatusBar(pszTestCase);
} // Log_TestCase()


//--------------------------------------------------------------------------;
//
//  DWORD LogPercentOff
//
//  Description:
//      Logs the percent deviation from ideal.
//
//  Arguments:
//      DWORD dwActual: Actual value.
//
//      DWORD dwIdeal: Ideal value.
//
//  Return (DWORD):
//      Returns the percentage in fixed point format.
//
//  History:
//      03/15/95    Fwong       Hmmm....  Pizza.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL LogPercentOff
(
    DWORD   dwActual,
    DWORD   dwIdeal
)
{
    DWORD   dwDelta;

    if(dwActual < dwIdeal)
    {
//        dwDelta = (dwIdeal - dwActual) * (100 * 0x10000) / dwIdeal;

        dwDelta = MulDivRN(dwIdeal - dwActual, 100 * 0x10000, dwIdeal);

        tstLog(
            VERBOSE,
            "Percent off: -%u.%04u %%",
            (UINT)(dwDelta / 0x10000),
            (UINT)((dwDelta & 0xffff) * 10000 / 0x10000));
    }
    else
    {
//        dwDelta = (dwActual - dwIdeal) * (100 * 0x10000) / dwIdeal;

        dwDelta = MulDivRN(dwActual - dwIdeal, 100 * 0x10000, dwIdeal);

        tstLog(
            VERBOSE,
            "Percent off: %u.%04u %%",
            (UINT)(dwDelta / 0x10000),
            (UINT)((dwDelta & 0xffff) * 10000 / 0x10000));
    }

    return dwDelta;
} // LogPercentOff()


//--------------------------------------------------------------------------;
//
//  void LogPass
//
//  Description:
//      Logs a PASS message.
//
//  Arguments:
//      LPSTR szMsg: Message to include.
//
//  Return (void):
//
//  History:
//      07/01/94    Fwong       To make everything more consistent.
//
//--------------------------------------------------------------------------;

void FNGLOBAL LogPass
(
    LPSTR   pszMsg
)
{
    if('~' == pszMsg[0])
    {
        pszMsg++;
        tstLog(VERBOSE,"    PASS: %s.",pszMsg);
    }
    else
    {
        tstLog(VERBOSE,"\n    PASS: %s.",pszMsg);
    }

} // LogPass()


//--------------------------------------------------------------------------;
//
//  void LogFail
//
//  Description:
//      Logs a FAIL message.
//
//  Arguments:
//      LPSTR szMsg: Message to include.
//
//  Return (void):
//
//  History:
//      07/01/94    Fwong       To make everything more consistent.
//
//--------------------------------------------------------------------------;

void FNGLOBAL LogFail
(
    LPSTR   pszMsg
)
{
    if('~' == pszMsg[0])
    {
        pszMsg++;
        tstLog(TERSE,"    FAIL: %s.",pszMsg);
    }
    else
    {
        tstLog(TERSE,"\n    FAIL: %s.",pszMsg);
    }

} // LogFail()


//--------------------------------------------------------------------------;
//
//  LPSTR GetErrorText
//
//  Description:
//      Gets the text for the given error.
//
//  Arguments:
//      MMRESULT mmr:  Error Value.
//
//  Return LPSTR:
//      Pointer to error string.
//
//  History:
//      12/03/93    Fwong       For API wrappers.
//
//--------------------------------------------------------------------------;

LPSTR GetErrorText
(
    MMRESULT    mmrError
)
{
    switch (mmrError)
    {
        case MMSYSERR_NOERROR:
            return ((LPSTR)(&"MMSYSERR_NOERROR"));

        case MMSYSERR_ERROR:
            return ((LPSTR)(&"MMSYSERR_ERROR"));

        case MMSYSERR_BADDEVICEID:
            return ((LPSTR)(&"MMSYSERR_BADDEVICEID"));

        case MMSYSERR_NOTENABLED:
            return ((LPSTR)(&"MMSYSERR_NOTENABLED"));

        case MMSYSERR_ALLOCATED:
            return ((LPSTR)(&"MMSYSERR_ALLOCATED"));

        case MMSYSERR_INVALHANDLE:
            return ((LPSTR)(&"MMSYSERR_INVALHANDLE"));

        case MMSYSERR_NODRIVER:
            return ((LPSTR)(&"MMSYSERR_NODRIVER"));

        case MMSYSERR_NOMEM:
            return ((LPSTR)(&"MMSYSERR_NOMEM"));

        case MMSYSERR_NOTSUPPORTED:
            return ((LPSTR)(&"MMSYSERR_NOTSUPPORTED"));

        case MMSYSERR_BADERRNUM:
            return ((LPSTR)(&"MMSYSERR_BADERRNUM"));

        case MMSYSERR_INVALFLAG:
            return ((LPSTR)(&"MMSYSERR_INVALFLAG"));

        case MMSYSERR_INVALPARAM:
            return ((LPSTR)(&"MMSYSERR_INVALPARAM"));

        case WAVERR_BADFORMAT:
            return ((LPSTR)(&"WAVERR_BADFORMAT"));

        case WAVERR_STILLPLAYING:
            return ((LPSTR)(&"WAVERR_STILLPLAYING"));

        case WAVERR_UNPREPARED:
            return ((LPSTR)(&"WAVERR_UNPREPARED"));

        case WAVERR_SYNC:
            return ((LPSTR)(&"WAVERR_SYNC"));

        default:
            return ((LPSTR)(&"Undefined Error"));
    }
} // GetErrorText()


//--------------------------------------------------------------------------;
//
//  LPSTR GetTimeTypeText
//
//  Description:
//      Gets the text for the given time type.
//
//  Arguments:
//      UINT uTimeType:  Time type.
//
//  Return (LPSTR):
//      Pointer to string.
//
//  History:
//      09/30/94    Fwong       For waveXGetPosition stuff.
//
//--------------------------------------------------------------------------;

LPSTR GetTimeTypeText
(
    UINT    uTimeType
)
{
    switch (uTimeType)
    {
        case TIME_MS:
            return ((LPSTR)(&"TIME_MS"));

        case TIME_SAMPLES:
            return ((LPSTR)(&"TIME_SAMPLES"));

        case TIME_BYTES:
            return ((LPSTR)(&"TIME_BYTES"));

        case TIME_SMPTE:
            return ((LPSTR)(&"TIME_SMPTE"));

        case TIME_MIDI:
            return ((LPSTR)(&"TIME_MIDI"));

        case TIME_TICKS:
            return ((LPSTR)(&"TIME_TICKS"));
    }
}


//--------------------------------------------------------------------------;
//
//  void IdiotBox
//
//  Description:
//      Displays a message box with an "Idiot!" caption.
//
//  Arguments:
//      LPSTR pszMessage:  Message to display.
//
//  Return (void):
//
//  History:
//      02/14/94    Fwong       I'll be calling this quite a bit.
//
//--------------------------------------------------------------------------;

void IdiotBox
(
    LPSTR   pszMessage
)
{
#ifdef DEBUG
    MessageBox(ghwndTstsHell,pszMessage,"Idiot!!",MB_OK|MB_ICONINFORMATION);
#else
    MessageBox(ghwndTstsHell,pszMessage,"Error!!",MB_OK|MB_ICONINFORMATION);
#endif
} // IdiotBox()


//--------------------------------------------------------------------------;
//
//  void Log_Error
//
//  Description:
//      Logs the function name, error return value, and time interval.
//
//  Arguments:
//      LPSTR pszFnName: Buffer to function name.
//
//      MMRESULT mmrError: Error code.
//
//      DWORD dwTime:  Time interval.
//
//  Return (void):
//
//  History:
//      12/03/93    Fwong       For API wrappers.
//
//--------------------------------------------------------------------------;

void FNGLOBAL Log_Error
(
    LPSTR       pszFnName,
    MMRESULT    mmrError,
    DWORD       dwTime
)
{
    tstLog(VERBOSE,"");

    if(dwTime >= gti.cMaxTimeThreshold)
    {
        tstLog(VERBOSE,"WARNING: %s took %lu ms.",pszFnName,dwTime);
    }
    else
    {
        if(gti.fdwFlags & TESTINFOF_LOG_TIME)
        {
            tstLog(VERBOSE,"%s took %lu ms.",pszFnName,dwTime);
        }
    }
         
    tstLog(
        VERBOSE,
        "%s returned: %s (0x%08lx).",
        pszFnName,
        GetErrorText(mmrError),
        (DWORD)mmrError);

} // Log_Error()


#ifdef DEBUG

//--------------------------------------------------------------------------;
//
//  void DebugLog_Error
//
//  Description:
//      Logs error string and value to debug.
//
//  Arguments:
//      MMRESULT mmrError:  Error value.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       For debugging purposes.
//
//--------------------------------------------------------------------------;

void FNGLOBAL DebugLog_Error
(
    MMRESULT    mmrError
)
{
    DPF(1,"%s (0x%08lx)",GetErrorText(mmrError),(DWORD)mmrError);
} // DebugLog_Error()

#endif


//--------------------------------------------------------------------------;
//
//  void HexDump
//
//  Description:
//      Hex dumps the contents of a buffer.
//
//  Arguments:
//      LPBYTE lpData: Data to hexdump.
//
//      DWORD cbSize: Amount of bytes to hexdump.
//
//      DWORD nBytesPerLine: Number of bytes displayed per line.
//
//      UINT nSpaces: Column number for alignment.
//
//  Return (void):
//
//  History:
//      08/12/93    Fwong       For ACM driver testing.
//
//--------------------------------------------------------------------------;

void HexDump
(
    LPBYTE  lpData,
    DWORD   cbSize,
    DWORD   nBytesPerLine,
    UINT    nSpaces
)
{
    char    szOutput[MAXSTDSTR];
    char    szHexByte[4];
    DWORD   cbOutput;

    if(0 == cbSize)
    {
        return;
    }

    wsprintf(szOutput,"%sRemaining Bytes:",SPACES(nSpaces-15));

    do
    {
        cbOutput = min(cbSize,nBytesPerLine);
        cbSize -= cbOutput;

        for (;cbOutput;cbOutput--,lpData++)
        {
            wsprintf(szHexByte," %02x",(BYTE)(*lpData));
            lstrcat(szOutput,szHexByte);
        }

        tstLog(VERBOSE,szOutput);
        tstLogFlush();

        wsprintf(szOutput,"%s ",SPACES(nSpaces));
    }
    while (0 != cbSize);
} // HexDump()


//--------------------------------------------------------------------------;
//
//  BOOL StringToDWORD
//
//  Description:
//      Gets a DWORD value from a given string.
//
//  Arguments:
//      LPSTR pszNumber: Pointer to string.
//
//      LPDWORD pdw: Pointer to DWORD.
//
//  Return (BOOL):
//      TRUE if successful, FALSE if error occurs.
//
//  History:
//      11/24/93    Fwong       For dealing w/ dialogs.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL StringToDWORD
(
    LPSTR   pszNumber,
    LPDWORD pdw
)
{
    DWORD   dwValue;
    DWORD   dwDigit;

    for(;;pszNumber++)
    {
        if(10 > HexValue(pszNumber[0]))
        {
            break;
        }

        switch (pszNumber[0])
        {
            case ' ':
            case '\t':
            case '\n':
                break;

            case 0:
            default:
                return FALSE;
        }
    }

    for(dwValue = 0;;pszNumber++)
    {
        dwDigit = HexValue(pszNumber[0]);

        if(10 <= dwDigit)
        {
            break;
        }

        if(dwValue >= (DWORD)(((DWORD)(-1))/10))
        {
            return FALSE;
        }

        dwValue = 10*dwValue + dwDigit;
    }

    for(;pszNumber[0];pszNumber++)
    {
        switch (pszNumber[0])
        {
            case ' ':
            case '\t':
            case '\n':
                break;

            default:
                return FALSE;
        }
    }

    *pdw = dwValue;

    return TRUE;
} // StringToDWORD()


//--------------------------------------------------------------------------;
//
//  void EnumPid
//
//  Description:
//      Enumerates wPid from the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      WORD wMid: Manufacturer ID (Needed to determine wPid validity).
//
//      WORD wPid: Product ID.
//
//      UINT nSpaces: Column to align to.
//
//  Return (void):
//
//  History:
//      08/11/93    Fwong       For ACM driver testing.
//
//--------------------------------------------------------------------------;

void EnumPid
(
    WORD    wMid,
    WORD    wPid,
    UINT    nSpaces
)
{
    char    szName[MAXSTDSTR];
    char    szDesc[MAXSTDSTR];
    char    szManufacturer[MAXSTDSTR];

    if(GetRegInfo(
        (DWORD)wMid,
        "MM Manufacturer ID",
        szManufacturer,
        sizeof(szManufacturer),
        szDesc,
        sizeof(szDesc)))
    {
        if(GetRegInfo(
            (DWORD)wPid,
            szManufacturer,
            szName,
            sizeof(szName),
            szDesc,
            sizeof(szDesc)))
        {
            if(szDesc[0])
            {
                tstLog(
                    VERBOSE,
                    "%swPid: %s (%u) [%s]",
                    SPACES(nSpaces-4),
                    (LPSTR)szName,
                    wPid,
                    (LPSTR)szDesc);
            }
            else
            {
                tstLog(
                    VERBOSE,
                    "%swPid: %s (%u)",
                    SPACES(nSpaces-4),
                    (LPSTR)szName,
                    wPid);
            }

            tstLogFlush();
            return;
        }
    }

    tstLog(VERBOSE,"%swPid: %u",SPACES(nSpaces-4),wPid);

} // EnumPid()


//--------------------------------------------------------------------------;
//
//  void EnumMid
//
//  Description:
//      Enumerates wPid from the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      WORD wMid: Manufacturer ID.
//
//      UINT nSpaces: Column to align to.
//
//  Return (void):
//
//  History:
//      08/11/93    Fwong       For ACM driver testing.
//
//--------------------------------------------------------------------------;

void EnumMid
(
    WORD    wMid,
    UINT    nSpaces
)
{
    char    szName[MAXSTDSTR];
    char    szDesc[MAXSTDSTR];

    if(GetRegInfo(
        (DWORD)wMid,
        "MM Manufacturer ID",
        szName,
        sizeof(szName),
        szDesc,
        sizeof(szDesc)))
    {
        if(szDesc[0])
        {
            tstLog(
                VERBOSE,
                "%swMid: %s (%u) [%s]",
                SPACES(nSpaces-4),
                (LPSTR)szName,
                wMid,
                (LPSTR)szDesc);
        }
        else
        {
            tstLog(
                VERBOSE,
                "%swMid: %s (%u)",
                SPACES(nSpaces-4),
                (LPSTR)szName,
                wMid);
        }

        tstLogFlush();
    }
    else
    {
        tstLog(VERBOSE,"%swMid: %u",SPACES(nSpaces-4),wMid);
    }

    return;
} // EnumMid()


//--------------------------------------------------------------------------;
//
//  void Log_FormatTag
//
//  Description:
//      Logs format tag (also logs name and description if found in
//          mmreg.ini)
//
//  Arguments:
//      DWORD dwFormatTag: Format tag value.
//
//      UINT nSpaces: Column number to align.
//
//      BOOL fLogAsWord: TRUE if label for format tag should be WORD.
//
//  Return (void):
//
//  History:
//      08/12/93    Fwong       For ACM driver testing.
//
//--------------------------------------------------------------------------;

void Log_FormatTag
(
    DWORD   dwFormatTag,
    UINT    nSpaces,
    BOOL    fLogAsWord
)
{
    char    szName[MAXSTDSTR];
    char    szDesc[MAXSTDSTR];
    char    szLabel[MAXSTDSTR];

    if(fLogAsWord)
    {
        wsprintf(szLabel,"%s wFormatTag: ",SPACES(nSpaces-11));
    }
    else
    {
        wsprintf(szLabel,"%sdwFormatTag: ",SPACES(nSpaces-11));
    }

    if(GetRegInfo(
        dwFormatTag,
        "Wave Format Tag",
        szName,
        sizeof(szName),
        szDesc,
        sizeof(szDesc)))
    {
        if(szDesc[0])
        {
            tstLog(
                VERBOSE,
                "%s%s (%lu) [%s]",
                (LPSTR)szLabel,
                (LPSTR)szName,
                dwFormatTag,
                (LPSTR)szDesc);
        }
        else
        {
            tstLog(
                VERBOSE,
                "%s%s (%lu)",
                (LPSTR)szLabel,
                (LPSTR)szName,
                dwFormatTag);
        }
    }
    else
    {
        tstLog(VERBOSE,"%s%lu",(LPSTR)szLabel,dwFormatTag);
    }

    tstLogFlush();
} // Log_FormatTag()


//--------------------------------------------------------------------------;
//
//  void Enum_WAVECAPS_Formats
//
//  Description:
//      Logs the supported format based on the dwFormats from WAVEXCAPS
//          structures.
//
//  Arguments:
//      DWORD dwFormatFlags: dwFormats value.
//
//      UINT nSpaces: Column to align to.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       To log formats for both input and output.
//
//--------------------------------------------------------------------------;

void Enum_WAVECAPS_Formats
(
    DWORD   dwFormatFlags,
    UINT    nSpaces
)
{
    char            szFormat[MAXFMTSTR];
    DWORD           dwMask;
    PCMWAVEFORMAT   pcmwf;

    tstLog(VERBOSE,"%sdwFormats: 0x%08lx",SPACES(nSpaces-9),dwFormatFlags);

    //
    //  Note: This will break if MSB_FORMAT == 0x80000000!!!
    //

    for(dwMask = 1; MSB_FORMAT >= dwMask; dwMask *= 2)
    {
        if(0 == (dwMask & dwFormatFlags))
        {
            //
            //  This format not supported!!
            //

            continue;
        }

        //
        //  Format supported; let's log it.
        //

        FormatFlag_To_Format(dwMask,&pcmwf);

        GetFormatName(szFormat,(LPWAVEFORMATEX)&pcmwf,sizeof(szFormat));

        tstLog(
            VERBOSE,
            "%s  (0x%08lx) [%s]",
            SPACES(nSpaces),
            dwMask,
            (LPSTR)szFormat);

        tstLogFlush();
    }
} // Enum_WAVECAPS_Formats()


//--------------------------------------------------------------------------;
//
//  void Enum_WAVEOUTCAPS_Support
//
//  Description:
//      Logs the support flags for the dwSupport from the WAVEOUTCAPS
//          structure.
//
//  Arguments:
//      DWORD dwSupport: The value from the dwSupport flag.
//
//      UINT nSpaces: Column to align to.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       To make support logging easier.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL Enum_WAVEOUTCAPS_Support
(
    DWORD   dwSupport,
    UINT    nSpaces
)
{
    tstLog(VERBOSE,"%sdwSupport: 0x%08lx",SPACES(nSpaces-9),dwSupport);

    if((dwSupport)&(WAVECAPS_PITCH))
    {
        tstLog(
            VERBOSE,
            "%s  WAVECAPS_PITCH (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVECAPS_PITCH);
    }

    if((dwSupport)&(WAVECAPS_PLAYBACKRATE))
    {
        tstLog(
            VERBOSE,
            "%s  WAVECAPS_PLAYBACKRATE (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVECAPS_PLAYBACKRATE);
    }

    if((dwSupport)&(WAVECAPS_VOLUME))
    {
        tstLog(
            VERBOSE,
            "%s  WAVECAPS_VOLUME (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVECAPS_VOLUME);
    }

    if((dwSupport)&(WAVECAPS_LRVOLUME))
    {
        tstLog(
            VERBOSE,
            "%s  WAVECAPS_LRVOLUME (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVECAPS_LRVOLUME);
    }

    if((dwSupport)&(WAVECAPS_SYNC))
    {
        tstLog(
            VERBOSE,
            "%s  WAVECAPS_SYNC (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVECAPS_SYNC);
    }

#if (WINVER >= 0x0400)
    if((dwSupport) & (WAVECAPS_SAMPLEACCURATE))
    {
        tstLog(
            VERBOSE,
            "%s  WAVECAPS_SAMPLEACCURATE (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVECAPS_SAMPLEACCURATE);
    }
#endif

//#if (WINVER >= 0x0400)
//    if((dwSupport)&(WAVECAPS_INSTVOLUME))
//    {
//        tstLog(
//            VERBOSE,
//            "%s  WAVECAPS_INSTVOLUME (0x%08lx)",
//            SPACES(nSpaces),
//            (DWORD)WAVECAPS_INSTVOLUME);
//    }
//#endif

} // Enum_WAVEOUTCAPS_Support()


//--------------------------------------------------------------------------;
//
//  void Enum_waveOpen_Flags
//
//  Description:
//      Logs the waveXOpen's flags.
//
//  Arguments:
//      DWORD dwFlags: The value of the flags.
//
//      UINT nSpaces: Column to align to.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       Making flag logging easier.
//
//--------------------------------------------------------------------------;

void FNGLOBAL Enum_waveOpen_Flags
(
    DWORD   dwFlags,
    UINT    nSpaces
)
{
    tstLog(VERBOSE,"%sdwFlags: (0x%08lx)",SPACES(nSpaces-7),dwFlags);

    switch (dwFlags & CALLBACK_TYPEMASK)
    {
        case CALLBACK_NULL:
            tstLog(
                VERBOSE,
                "%s  CALLBACK_NULL (0x%08lx)",
                SPACES(nSpaces),
                (DWORD)CALLBACK_NULL);

            break;

        case CALLBACK_WINDOW:
            tstLog(
                VERBOSE,
                "%s  CALLBACK_WINDOW (0x%08lx)",
                SPACES(nSpaces),
                (DWORD)CALLBACK_WINDOW);

            break;

        case CALLBACK_TASK:
#ifdef WIN32
            tstLog(
                VERBOSE,
                "%s  CALLBACK_THREAD (0x%08lx)",
                SPACES(nSpaces),
                (DWORD)CALLBACK_THREAD);
#else
            tstLog(
                VERBOSE,
                "%s  CALLBACK_TASK (0x%08lx)",
                SPACES(nSpaces),
                (DWORD)CALLBACK_TASK);
#endif
            break;

        case CALLBACK_FUNCTION:
            tstLog(
                VERBOSE,
                "%s  CALLBACK_FUNCTION (0x%08lx)",
                SPACES(nSpaces),
                (DWORD)CALLBACK_FUNCTION);

            break;

#ifdef WIN32
        case CALLBACK_EVENT:
            tstLog(
                VERBOSE,
                "%s  CALLBACK_EVENT (0x%08lx)",
                SPACES(nSpaces),
                (DWORD)CALLBACK_EVENT);

            break;
#endif

    }

    if(0 != (WAVE_FORMAT_QUERY & dwFlags))
    {
        tstLog(
            VERBOSE,
            "%s  WAVE_FORMAT_QUERY (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVE_FORMAT_QUERY);
    }

    if(0 != (WAVE_ALLOWSYNC & dwFlags))
    {
        tstLog(
            VERBOSE,
            "%s  WAVE_ALLOWSYNC (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVE_ALLOWSYNC);
    }

#if (WINVER >= 0x0400)
    if(0 != (WAVE_MAPPED & dwFlags))
    {
        tstLog(
            VERBOSE,
            "%s  WAVE_MAPPED (0x%08lx)",
            SPACES(nSpaces),
            (DWORD)WAVE_MAPPED);
    }
#endif

} // Enum_waveOpen_Flags()


//--------------------------------------------------------------------------;
//
//  void Log_WAVEFORMATEX
//
//  Description:
//      Logs the contents of a WAVEFORMATEX structure.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to WAVEFORMATEX structure.
//
//  Return (void):
//
//  History:
//      08/12/93    Fwong       For ACM driver testing.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL Log_WAVEFORMATEX
(
    LPWAVEFORMATEX  pwfx
)
{
    LPBYTE  pwfxStub;

    tstLog(VERBOSE,"WAVEFORMATEX Structure:");
    Log_FormatTag((DWORD)pwfx->wFormatTag,16,TRUE);
//    tstLogFn(VERBOSE,Log_FormatTag,((DWORD)pwfx->wFormatTag),16,TRUE);

    tstLog(VERBOSE,"       nChannels: %u",pwfx->nChannels);
    tstLog(VERBOSE,"  nSamplesPerSec: %lu",pwfx->nSamplesPerSec);
    tstLog(VERBOSE," nAvgBytesPerSec: %lu",pwfx->nAvgBytesPerSec);
    tstLog(VERBOSE,"     nBlockAlign: %u",pwfx->nBlockAlign);
    tstLog(VERBOSE,"  wBitsPerSample: %u",pwfx->wBitsPerSample);

    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        tstLog(VERBOSE,"          cbSize: %u",pwfx->cbSize);

        if(0 != pwfx->cbSize)
        {
            pwfxStub = ((LPBYTE)(pwfx)) + sizeof(WAVEFORMATEX);
            HexDump(pwfxStub,(DWORD)pwfx->cbSize,8,16);
        }
    }
} // Log_WAVEFORMATEX()


//--------------------------------------------------------------------------;
//
//  void Log_MMTIME
//
//  Description:
//      Logs the contents of an MMTIME structure.
//
//  Arguments:
//      LPMMTIME pmmtime:  Pointer to MMTIME structure.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       To make logging easier.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL Log_MMTIME
(
    LPMMTIME    pmmtime
)
{
    tstLog(VERBOSE,"MMTIME Structure:");

    switch (pmmtime->wType)
    {
        case TIME_MS:
            tstLog(VERBOSE,"wType: TIME_MS (%u)",pmmtime->wType);
            tstLog(VERBOSE,"   ms: %lu",pmmtime->u.ms);
            break;

        case TIME_SAMPLES:
            tstLog(VERBOSE," wType: TIME_SAMPLES (%u)",pmmtime->wType);
            tstLog(VERBOSE,"sample: %lu",pmmtime->u.sample);
            break;

        case TIME_BYTES:
            tstLog(VERBOSE,"wType: TIME_BYTES (%u)",pmmtime->wType);
            tstLog(VERBOSE,"   cb: %lu",pmmtime->u.cb);
            break;

        case TIME_SMPTE:
            tstLog(VERBOSE,"    wType: TIME_SMPTE (%u)",pmmtime->wType);

            tstLog(
                VERBOSE,
                "[h:m:s:f]:%u:%u:%u:%u",
                pmmtime->u.smpte.hour,
                pmmtime->u.smpte.min,
                pmmtime->u.smpte.sec,
                pmmtime->u.smpte.frame);
            tstLog(VERBOSE,"      fps: %u",pmmtime->u.smpte.fps);
            break;

        case TIME_MIDI:
            tstLog(VERBOSE,"     wType: TIME_MIDI (%u)",pmmtime->wType);
            tstLog(VERBOSE,"songptrpos: %lu",pmmtime->u.midi.songptrpos);
            break;

        case TIME_TICKS:
            tstLog(VERBOSE,"wType: TIME_TICKS (%u)",pmmtime->wType);
            tstLog(VERBOSE,"ticks: %lu",pmmtime->u.ticks);
    }
} // Log_MMTIME()


//--------------------------------------------------------------------------;
//
//  void Log_WAVEHDR
//
//  Description:
//      Logs the contents of the WAVEHDR structure.
//
//  Arguments:
//      LPWAVEHDR pWaveHdr: Pointer to a WAVEHDR structure.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       To make logging easier.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL Log_WAVEHDR
(
    LPWAVEHDR   pWaveHdr
)
{
    tstLog(VERBOSE,"WAVEHDR Structure:");

    tstLog(VERBOSE,"         lpData: " PTR_FORMAT,MAKEPTR(pWaveHdr->lpData));

    tstLog(VERBOSE," dwBufferLength: %lu",pWaveHdr->dwBufferLength);
    tstLog(VERBOSE,"dwBytesRecorded: %lu",pWaveHdr->dwBytesRecorded);
    tstLog(VERBOSE,"         dwUser: 0x%08lx",pWaveHdr->dwUser);
    tstLog(VERBOSE,"        dwFlags: 0x%08lx",pWaveHdr->dwFlags);
    
    if((pWaveHdr->dwFlags)&(WHDR_DONE))
    {
        tstLog(
            VERBOSE,
            "                 WHDR_DONE (0x%08lx)",
            (DWORD)WHDR_DONE);
    }

    if((pWaveHdr->dwFlags)&(WHDR_PREPARED))
    {
        tstLog(
            VERBOSE,
            "                 WHDR_PREPARED (0x%08lx)",
            (DWORD)WHDR_PREPARED);
    }

    if((pWaveHdr->dwFlags)&(WHDR_BEGINLOOP))
    {
        tstLog(
            VERBOSE,
            "                 WHDR_BEGINLOOP (0x%08lx)",
            (DWORD)WHDR_BEGINLOOP);
    }

    if((pWaveHdr->dwFlags)&(WHDR_ENDLOOP))
    {
        tstLog(
            VERBOSE,
            "                 WHDR_ENDLOOP (0x%08lx)",
            (DWORD)WHDR_ENDLOOP);
    }

    if((pWaveHdr->dwFlags)&(WHDR_INQUEUE))
    {
        tstLog(
            VERBOSE,
            "                 WHDR_INQUEUE (0x%08lx)",
            (DWORD)WHDR_INQUEUE);
    }

    tstLog(VERBOSE,"        dwLoops: %lu",pWaveHdr->dwLoops);
    tstLog(VERBOSE,"         lpNext: " PTR_FORMAT,MAKEPTR(pWaveHdr->lpNext));
    tstLog(VERBOSE,"       reserved: %lu",pWaveHdr->reserved);
} // Log_WAVEHDR()


//--------------------------------------------------------------------------;
//
//  void Log_WAVEINCAPS
//
//  Description:
//      Logs the contents of the WAVEINCAPS structure.
//
//  Arguments:
//      LPWAVEINCAPS pwic: Pointer to a WAVEINCAPS structure.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       To make logging easier.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL Log_WAVEINCAPS
(
    LPWAVEINCAPS    pwic
)
{
    tstLog(VERBOSE,"WAVEINCAPS Structure:");

    EnumMid(pwic->wMid,14);
    EnumPid(pwic->wMid,pwic->wPid,14);

    tstLog(VERBOSE,"vDriverVersion: %d.%d",
        HIBYTE(pwic->vDriverVersion),
        LOBYTE(pwic->vDriverVersion));

    tstLog(VERBOSE,"       szPname: [%s]",(LPSTR)pwic->szPname);

    Enum_WAVECAPS_Formats(pwic->dwFormats,14);

    tstLog(VERBOSE,"     wChannels: %d",pwic->wChannels);

    tstLogFlush();
} // Log_WAVEINCAPS()


//--------------------------------------------------------------------------;
//
//  void Log_WAVEOUTCAPS
//
//  Description:
//      Logs the contents of the WAVEOUTCAPS structure.
//
//  Arguments:
//      LPWAVEOUTCAPS pwoc: Pointer to WAVEOUTCAPS structure.
//
//  Return (void):
//
//  History:
//      12/06/93    Fwong       To make logging easier.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL Log_WAVEOUTCAPS
(
    LPWAVEOUTCAPS   pwoc
)
{
    tstLog(VERBOSE,"WAVEOUTCAPS Structure:");

    EnumMid(pwoc->wMid,14);
    EnumPid(pwoc->wMid,pwoc->wPid,14);

    tstLog(VERBOSE,"vDriverVersion: %d.%d",
        HIBYTE(pwoc->vDriverVersion),
        LOBYTE(pwoc->vDriverVersion));

    tstLog(VERBOSE,"       szPname: [%s]",(LPSTR)pwoc->szPname);

    Enum_WAVECAPS_Formats(pwoc->dwFormats,14);

    tstLog(VERBOSE,"     wChannels: %d",pwoc->wChannels);

    Enum_WAVEOUTCAPS_Support(pwoc->dwSupport,14);

    tstLogFlush();
} // Log_WAVEOUTCAPS()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\thread.h ===
//--------------------------------------------------------------------------;
//
//  File: Thread.h
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//
//  History:
//      12/02/94    Fwong       Created to add some multithreaded support.
//
//--------------------------------------------------------------------------;

//==========================================================================;
//
//                             Contants...
//
//==========================================================================;

#define THREADFLAG_DONE     0x00000001
#define THREAD_DONE         0xdeadbeef

//==========================================================================;
//
//                             Type ID's...
//
//==========================================================================;

#define ID_WAVEOUTGETDEVCAPS         1
#define ID_WAVEOUTGETVOLUME          2
#define ID_WAVEOUTSETVOLUME          3
#define ID_WAVEOUTOPEN               4
#define ID_WAVEOUTCLOSE              5
#define ID_WAVEOUTPREPAREHEADER      6
#define ID_WAVEOUTUNPREPAREHEADER    7
#define ID_WAVEOUTWRITE              8
#define ID_WAVEOUTPAUSE              9
#define ID_WAVEOUTRESTART           10
#define ID_WAVEOUTRESET             11
#define ID_WAVEOUTBREAKLOOP         12
#define ID_WAVEOUTGETPOSITION       13
#define ID_WAVEOUTGETPITCH          14
#define ID_WAVEOUTSETPITCH          15
#define ID_WAVEOUTGETPLAYBACKRATE   16
#define ID_WAVEOUTSETPLAYBACKRATE   17
#define ID_WAVEOUTGETID             18
#define ID_WAVEINGETDEVCAPS         19
#define ID_WAVEINOPEN               20
#define ID_WAVEINCLOSE              21
#define ID_WAVEINPREPAREHEADER      22
#define ID_WAVEINUNPREPAREHEADER    23
#define ID_WAVEINADDBUFFER          24
#define ID_WAVEINSTART              25
#define ID_WAVEINSTOP               26
#define ID_WAVEINRESET              27
#define ID_WAVEINGETPOSITION        28
#define ID_WAVEINGETID              29

//==========================================================================;
//
//                              Macros...
//
//==========================================================================;


#define CreateWaveThread(fn,wt,dwID)    CreateThread(NULL,0,fn,\
                                            (LPWAVETHREADBASE)(&wt),0,&dwID)
#define WaitForAPI(wt)     while(!(wt.wtb.fdwFlags & THREADFLAG_DONE));


//==========================================================================;
//
//                          Structures...
//
//==========================================================================;

typedef struct WAVETHREADBASE_tag
{
    UINT        uType;
    MMRESULT    mmr;
    DWORD       dwTime;
    DWORD       fdwFlags;
} WAVETHREADBASE;
typedef WAVETHREADBASE       *PWAVETHREADBASE;
typedef WAVETHREADBASE NEAR *NPWAVETHREADBASE;
typedef WAVETHREADBASE FAR  *LPWAVETHREADBASE;


typedef struct WAVETHREADSTRUCT_tag
{
    WAVETHREADBASE  wtb;
    HWAVE           hWave;
    LPVOID          pStruct;
    UINT            cbSize;
} WAVETHREADSTRUCT;
typedef WAVETHREADSTRUCT       *PWAVETHREADSTRUCT;
typedef WAVETHREADSTRUCT NEAR *NPWAVETHREADSTRUCT;
typedef WAVETHREADSTRUCT FAR  *LPWAVETHREADSTRUCT;


typedef struct WAVETHREADATTR_tag
{
    WAVETHREADBASE  wtb;
    HWAVEOUT        hWave;
    DWORD           dw;
} WAVETHREADATTR;
typedef WAVETHREADATTR       *PWAVETHREADATTR;
typedef WAVETHREADATTR NEAR *NPWAVETHREADATTR;
typedef WAVETHREADATTR FAR  *LPWAVETHREADATTR;


typedef struct WAVETHREADOPEN_tag
{
    WAVETHREADBASE  wtb;
    LPHWAVEOUT      phWave;
    UINT            uDeviceID;
    LPWAVEFORMATEX  pwfx;
    DWORD           dwCallback;
    DWORD           dwInstance;
    DWORD           fdwFlags;
} WAVETHREADOPEN;
typedef WAVETHREADOPEN       *PWAVETHREADOPEN;
typedef WAVETHREADOPEN NEAR *NPWAVETHREADOPEN;
typedef WAVETHREADOPEN FAR  *LPWAVETHREADOPEN;


typedef struct WAVETHREADHANDLE_tag
{
    WAVETHREADBASE  wtb;
    HWAVE           hWave;
} WAVETHREADHANDLE;
typedef WAVETHREADHANDLE       *PWAVETHREADHANDLE;
typedef WAVETHREADHANDLE NEAR *NPWAVETHREADHANDLE;
typedef WAVETHREADHANDLE FAR  *LPWAVETHREADHANDLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\tests\wavetest\exe\wavein.c ===
//--------------------------------------------------------------------------;
//
//  File: WaveIn.c
//
//  Copyright (C) Microsoft Corporation, 1994 - 1996  All rights reserved
//
//  Abstract:
//
//
//  Contents:
//      AllocateInDevice()
//      Test_waveInOpen()
//      Test_waveInClose()
//      Test_waveInGetPosition()
//      Test_waveInPrepareHeader()
//      Test_waveInUnprepareHeader()
//      IsStopped()
//      Test_waveInStart()
//      Test_waveInStop()
//      Test_waveInReset()
//
//  History:
//      02/15/94    Fwong
//
//--------------------------------------------------------------------------;

#include <windows.h>
#ifdef WIN32
#include <windowsx.h>
#endif
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memgr.h>
#include <waveutil.h>
#include <inimgr.h>
#include <memory.h>
#include <TstsHell.h>
#include "AppPort.h"
#include "WaveTest.h"
#include "MulDiv32.h"
#include "Debug.h"


//--------------------------------------------------------------------------;
//
//  MMRESULT AllocateInDevice
//
//  Description:
//      Recursively continues to allocate devices until waveInOpen returns
//      an error.
//
//  Arguments:
//      UINT uDeviceID: Device ID to allocate.
//
//      LPWAVEFORMATEX pwfx: Format to allocate device with.
//
//      DWORD pdw: Pointer to DWORD to count recursion levels.
//
//  Return (MMRESULT):
//      The actual error value returned by waveInOpen.
//
//  History:
//      03/14/94    Fwong       Trying to cover MMSYSERR_ALLOCATED case.
//
//--------------------------------------------------------------------------;

MMRESULT AllocateInDevice
(
    UINT            uDeviceID,
    LPWAVEFORMATEX  pwfx,
    LPDWORD         pdw
)
{
    MMRESULT    mmr;
    HWAVEIN     hWaveIn;

    mmr = waveInOpen(
        &hWaveIn,
        uDeviceID,
        (HACK)pwfx,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        return mmr;
    }

    (*pdw)++;

    mmr = AllocateInDevice(uDeviceID,pwfx,pdw);

    waveInClose(hWaveIn);

    return mmr;
} // AllocateInDevice()


//--------------------------------------------------------------------------;
//
//  int Test_waveInOpen
//
//  Description:
//      Tests the driver functionality for waveInOpen.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInOpen
(
    void
)
{
    int             iResult = TST_PASS;
    HWAVEIN         hWaveIn;
    LPWAVEFORMATEX  pwfx;
    MMRESULT        mmr;
    MMRESULT        mmrQuery;
    WAVEINCAPS      wic;
    DWORD           dw;
    LPWAVEINFO      pwi;
    char            szFormat[MAXSTDSTR];
    static char     szTestName[] = "waveInOpen";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    pwfx = ExactAllocPtr(GMEM_SHARE|GMEM_MOVEABLE,gti.cbMaxFormatSize);

    if(NULL == pwfx)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    //
    //  First, verify consistency w/ dwFlags...
    //

    mmr = call_waveInGetDevCaps(gti.uInputDevice,&wic,sizeof(WAVEINCAPS));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailGetCaps);

        ExactFreePtr(pwfx);
        return TST_FAIL;
    }

    Log_TestCase("Verifying consistency with WAVEINCAPS.dwFormats");

    for(dw = MSB_FORMAT;dw;dw /= 2)
    {
        FormatFlag_To_Format(dw,(LPPCMWAVEFORMAT)pwfx);
        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveInOpen(
            &hWaveIn,
            gti.uInputDevice,
            (HACK)pwfx,
            0L,
            0L,
            INPUT_MAP(gti));

        mmrQuery = waveInOpen(
            NULL,
            gti.uInputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|INPUT_MAP(gti));

        if(MMSYSERR_NOERROR == mmr)
        {
            //
            //  No Error...  We should close the device...
            //

            waveInClose(hWaveIn);
        }

        if(wic.dwFormats & dw)
        {
            //
            //  Hmm... We're supposed to support it.
            //

            if(MMSYSERR_NOERROR == mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR == mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }
        else
        {
            //
            //  Hmm... We're NOT supposed to support it.
            //

            if(MMSYSERR_NOERROR != mmr)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }

            //
            //  And similarly for QUERY opens...
            //

            if(MMSYSERR_NOERROR != mmrQuery)
            {
                tstLog(
                    VERBOSE,
                    "    PASS: Format [%s] not (query) supported.",
                    (LPSTR)szFormat);
            }
            else
            {
                tstLog(
                    TERSE,
                    "    FAIL: Format [%s] (query) supported.",
                    (LPSTR)szFormat);

                iResult = TST_FAIL;
            }
        }

        mmr = waveInOpen(
            NULL,
            gti.uInputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|INPUT_MAP(gti));

        if(mmr != mmrQuery)
        {
            tstLog(
                VERBOSE,
                "    FAIL: Query open inconsistent w/ device allocated [%s].",
                (LPSTR)szFormat);

            iResult = TST_FAIL;
        }
        else
        {
            tstLog(
                VERBOSE,
                "    PASS: Query open consistent w/ device allocated [%s].",
                (LPSTR)szFormat);
        }

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            //
            //  Aborted!!!  Cleaning up...
            //

            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            ExactFreePtr(pwfx);
            return (TST_FAIL);
        }

        tstLogFlush();
    }

    //
    //  Second, verify consistency w/ QUERY flag
    //  across all formats (enumerated by ACM)...
    //

    Log_TestCase(
        "Verifying consistency w/ opens and query opens for all formats");

    for(dw = tstGetNumFormats();dw;dw--)
    {
        if(!tstGetFormat(pwfx,gti.cbMaxFormatSize,dw-1))
        {
            //
            //  Hmm... Couldn't get this format...
            //

            DPF(1,"Couldn't get format #%lu.",dw-1);

            continue;
        }

        GetFormatName(szFormat,pwfx,sizeof(szFormat));

        mmr = waveInOpen(
            &hWaveIn,
            gti.uInputDevice,
            (HACK)pwfx,
            0L,
            0L,
            INPUT_MAP(gti));

        mmrQuery = waveInOpen(
            NULL,
            gti.uInputDevice,
            (HACK)pwfx,
            0L,
            0L,
            WAVE_FORMAT_QUERY|INPUT_MAP(gti));

        //
        //  Checking _REAL_ open...
        //

        if(MMSYSERR_NOERROR == mmr)
        {
            //
            //  No Error...  We should close the device...
            //

            waveInClose(hWaveIn);

            tstLog(VERBOSE,"  Format [%s] supported on open.",(LPSTR)szFormat);
        }
        else
        {
            tstLog(
                VERBOSE,
                "  Format [%s] not supported on open.",
                (LPSTR)szFormat);
        }

        //
        //  Checking query open...
        //

        if(MMSYSERR_NOERROR == mmrQuery)
        {
            tstLog(
                VERBOSE,
                "  Format [%s] supported on query open.",
                (LPSTR)szFormat);
        }
        else
        {
            tstLog(
                VERBOSE,
                "  Format [%s] not supported on query open.",
                (LPSTR)szFormat);
        }

        //
        //  Checking consistency...
        //

        if(mmr != mmrQuery)
        {
            tstLog(TERSE,"    FAIL: Open inconsistent w/ query open.");

            tstLog(
                TERSE,
                "    Errors: %s (for open) and %s (for query open).",
                GetErrorText(mmr),
                GetErrorText(mmrQuery));

            iResult = TST_FAIL;
        }
        else
        {
            tstLog(VERBOSE,"    PASS: Open consistent w/ query open.");
        }

        //
        //  Does user want to abort?
        //

        TestYield();

        if(tstCheckRunStop(VK_ESCAPE))
        {
            //
            //  Aborted!!!  Cleaning up...
            //

            tstLog(TERSE,"\n*** Test Aborted!!! ***\n");
            tstLogFlush();

            ExactFreePtr(pwfx);
            return (TST_FAIL);
        }

        tstLogFlush();
    }

    //
    //  Third, verify MMSYSERR_ALLOCATED is (eventually) returned.
    //

    Log_TestCase("~Verifying MMSYSERR_ALLOCATED is (eventually) returned");

    dw = 0;

    mmr = AllocateInDevice(gti.uInputDevice,gti.pwfxInput,&dw);

    DPF(3,"Number of waveInOpen's: %lu",dw);

    if((MMSYSERR_NOMEM == mmr) && (dw >= 10))
    {
        tstLog(TERSE,"Device ran out of memory w/ too many opens.");
    }
    else
    {
        if(MMSYSERR_ALLOCATED != mmr)
        {
            LogFail("Device doesn't return MMSYSERR_ALLOCATED w/ "
                "multiple opens");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Device returns MMSYSERR_ALLOCATED w/ multiple opens");
        }
    }

    pwi = ExactAllocPtr(GMEM_SHARE|GMEM_FIXED,sizeof(WAVEINFO));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactFreePtr(pwfx);
        return TST_FAIL;
    }

    //
    //  Note: passing current time as dwInstance... unique for every
    //  execution.
    //

    dw  = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR == mmr)
    {
        //
        //  Fourth, verify driver posts a WIM_OPEN message.
        //

        Log_TestCase("~Verifying WIM_OPEN message was received");

        if(WIM_OPEN_FLAG & (pwi->fdwFlags))
        {
            LogPass("Callback received a WIM_OPEN message");
        }
        else
        {
            LogFail("WIM_OPEN message not received by callback");

            iResult = TST_FAIL;
        }

        //
        //  Fifth, verify dwCallbackInstance is passed back.
        //

        Log_TestCase("~Verifying dwInstance is consistent");

        if(dw == pwi->dwInstance)
        {
            LogPass("Callback function got correct dwInstance");
        }
        else
        {
            LogFail("Callback function got incorrect dwInstance");

            iResult = TST_FAIL;
        }

        call_waveInClose(hWaveIn);
    }
    else
    {
        LogFail("waveInOpen w/ CALLBACK_FUNCTION failed");

        iResult = TST_FAIL;
    }

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);

    ExactFreePtr(pwi);
    ExactFreePtr(pwfx);

    return (iResult);
} // Test_waveInOpen()


//--------------------------------------------------------------------------;
//
//  int Test_waveInClose
//
//  Description:
//      Tests the driver functionality for waveInClose.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInClose
(
    void
)
{
    int                 iResult = TST_PASS;
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pWaveHdr;
    LPWAVEINFO          pwi;
    DWORD               dw;
    DWORD               cbSize;
    LPBYTE              pData;
    static char         szTestName[] = "waveInClose";

    Log_TestName(szTestName);

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    pWaveHdr = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    //
    //  Getting a buffer for recording...
    //

    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    pData = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    //
    //  First, verify close before recording (w/out buffers) works.
    //

    Log_TestCase("~Verifying close before playing (w/out buffers) works");

    hWaveIn = NULL;

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);
        return TST_FAIL;
    }

    mmr = call_waveInClose(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("Device failed the close");

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device closed");
    }

    //
    //  Second, verify close after recording works.
    //

    Log_TestCase("~Verify close after recording works");

    pwi = ExactAllocPtr(GMEM_SHARE|GMEM_FIXED,sizeof(WAVEINFO));

    if(NULL == pwi)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    dw = waveGetTime();

    PageLock(pwi);

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        (DWORD)(FARPROC)pfnCallBack,
        dw,
        CALLBACK_FUNCTION|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);

        ExactFreePtr(pwi);
        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    pWaveHdr->lpData            = pData;
    pWaveHdr->dwBufferLength    = cbSize;
    pWaveHdr->dwBytesRecorded   = 0L;
    pWaveHdr->dwUser            = 0L;
    pWaveHdr->dwFlags           = 0L;
    pWaveHdr->dwLoops           = 0L;
    pWaveHdr->lpNext            = NULL;
    pWaveHdr->reserved          = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);

        PageUnlock(pwi);

        ExactFreePtr(pwi);
        ExactFreePtr(pData);
        ExactFreePtr(pWaveHdr);

        return TST_FAIL;
    }

    //
    //  Note: The following API's can only fail w/ invalid parameters
    //        or conditions.
    //

    call_waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
    call_waveInStart(hWaveIn);

    //
    //  Spinning on WHDR_DONE bit...
    //

#pragma message(REMIND("Check this later..."))
#ifdef WIN32
    while(!(pWaveHdr->dwFlags & WHDR_DONE))
    {
        Sleep(0);
    }
#else
    while(!(pWaveHdr->dwFlags & WHDR_DONE))
    {
        Yield();
    }
#endif

    call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    pwi->dwInstance = ~dw;
    pwi->fdwFlags   = 0L;

    mmr = call_waveInClose(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInClose after recording failed");

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveInClose successful after recording");
    }

    //
    //  Third, verify driver does a WIM_CLOSE callback.
    //

    Log_TestCase("~Verify driver does a WIM_CLOSE callback");

    if(pwi->fdwFlags & WIM_CLOSE_FLAG)
    {
        LogPass("Driver does WIM_CLOSE callback");
    }
    else
    {
        LogFail("Driver does not do WIM_CLOSE callback");

        iResult = TST_FAIL;
    }

    //
    //  Fourth, verify dwCallbackInstance is passed back.
    //

    Log_TestCase("~Verify dwCallbackInstance is passed back");

    if(dw == pwi->dwInstance)
    {
        LogPass("Correct dwInstance on callback");
    }
    else
    {
        LogFail("Incorrect dwInstance on callback");

        iResult = TST_FAIL;
    }

    DLL_WaveControl(DLL_END,NULL);

    PageUnlock(pwi);

    ExactFreePtr(pwi);

    //
    //  Fifth, verify close w/ prepared header fails.
    //

//    Log_TestCase("~Verifying close with prepared header fails");
//
//    mmr = call_waveInOpen(
//        &hWaveIn,
//        gti.uInputDevice,
//        gti.pwfxInput,
//        0L,
//        0L,
//        INPUT_MAP(gti));
//
//    if(MMSYSERR_NOERROR != mmr)
//    {
//        LogFail(gszFailOpen);
//
//        ExactFreePtr(pWaveHdr);
//        ExactFreePtr(pData);
//        return TST_FAIL;
//    }
//
//    pWaveHdr->dwBytesRecorded   = 0L;
//    pWaveHdr->dwUser            = 0L;
//    pWaveHdr->dwFlags           = 0L;
//    pWaveHdr->dwLoops           = 0L;
//
//    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
//
//    mmr = call_waveInClose(hWaveIn);
//
//    if(WAVERR_STILLPLAYING != mmr)
//    {
//        LogFail("Close did not fail w/ prepared header");
//
//        iResult = TST_FAIL;
//    }
//    else
//    {
//        LogPass("Close failed w/ prepared header");
//
//        call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
//        call_waveInClose(hWaveIn);
//    }

    //
    //  Sixth, verify close non-started device (w/ buffers) fails.
    //

    Log_TestCase("~Verifying close non-started device (w/ buffers) fails");

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    pWaveHdr->dwBytesRecorded   = 0L;
    pWaveHdr->dwUser            = 0L;
    pWaveHdr->dwFlags           = 0L;
    pWaveHdr->dwLoops           = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    //
    //  Note: The following API's can only fail w/ invalid parameters
    //        or conditions.
    //

    call_waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    mmr = call_waveInClose(hWaveIn);

    if(WAVERR_STILLPLAYING != mmr)
    {
        LogFail("Close did not fail w/ WAVERR_STILLPLAYING");

        iResult = TST_FAIL;

        if(MMSYSERR_NOERROR != mmr)
        {
            call_waveInReset(hWaveIn);
            call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
            call_waveInClose(hWaveIn);
        }
    }
    else
    {
        LogPass("Close failed w/ WAVERR_STILLPLAYING");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);
    }

    //
    //  Seventh, verify close while recording fails.
    //

    Log_TestCase("~Verifying close while recording fails");

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    pWaveHdr->dwBytesRecorded   = 0L;
    pWaveHdr->dwUser            = 0L;
    pWaveHdr->dwFlags           = 0L;
    pWaveHdr->dwLoops           = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    //
    //  Note: The following API's can only fail w/ invalid parameters
    //        or conditions.
    //

    call_waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
    call_waveInStart(hWaveIn);

    mmr = call_waveInClose(hWaveIn);

    if(WAVERR_STILLPLAYING != mmr)
    {
        iResult = TST_FAIL;

        if(MMSYSERR_NOERROR == mmr)
        {
            if(pWaveHdr->dwFlags & WHDR_DONE)
            {
                LogFail("WHDR_DONE bit set. Test inconclusive");
            }
            else
            {
                LogFail("waveInClose succeeds while WHDR_DONE bit clear");
            }
        }
        else
        {
            LogFail("Close did not fail w/ WAVERR_STILLPLAYING");

            call_waveInReset(hWaveIn);
            call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
            call_waveInClose(hWaveIn);
        }
    }
    else
    {
        LogPass("Close failed w/ WAVERR_STILLPLAYING");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);
    }

    ExactFreePtr(pWaveHdr);
    ExactFreePtr(pData);

    return (iResult);
} // Test_waveInClose()


//--------------------------------------------------------------------------;
//
//  int Test_waveInGetPosition
//
//  Description:
//      Tests the driver functionality for waveInGetPosition.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInGetPosition
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh;
    DWORD               dw;
    UINT                u;
    HANDLE              hHeap;
    MMTIME              mmt;
    LPBYTE              pData;
    DWORD               cbSize;
    DWORD               dwTime,dwTimebase;
//    DWORD               dwError,dwActual;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInGetPosition";

    Log_TestName(szTestName);

    //
    //  Are there any input devices?
    //

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Allocating memory...
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    pData = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Opening device...
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        WAVE_ALLOWSYNC|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        //
        //  Verify waveInGetPosition is zero when first opened.
        //

        Log_TestCase("~Verifying waveInGetPosition is zero when first opened");

        mmr = call_waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveInGetPosition failed");

            call_waveInReset(hWaveIn);
            call_waveInClose(hWaveIn);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(u != mmt.wType)
        {
            tstLog(
                VERBOSE,
                "Note: Time type [%s] is not supported.",
                GetTimeTypeText(u));
        }

        Log_MMTIME(&mmt);

        dw = GetMSFromMMTIME(gti.pwfxInput,&mmt);

        if(0 != dw)
        {
            LogFail("Time is not zero after open");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Time is zero after open");
        }
    }

    //
    //  Preparing header...
    //

    pwh->lpData             = pData;
    pwh->dwBufferLength     = cbSize;
    pwh->dwBytesRecorded    = 0L;
    pwh->dwUser             = 0L;
    pwh->dwFlags            = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        mmr = waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveInGetPosition failed");

            call_waveInReset(hWaveIn);
            call_waveInUnprepareHeader(hWaveIn,pwh,sizeof(WAVEHDR));
            call_waveInClose(hWaveIn);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        if(mmt.wType != u)
        {
            continue;
        }

        pwh->dwFlags &= ~(WHDR_DONE);

        call_waveInAddBuffer(hWaveIn,pwh,sizeof(WAVEHDR));
        call_waveInStart(hWaveIn);

        while(!(pwh->dwFlags & WHDR_DONE));

        //
        //  Verify position is non-zero after playing (w/out waveInReset)
        //

        Log_TestCase("~Verifying waveInGetPosition is not zero after playing");

        mmr = call_waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveInGetPosition failed");

            call_waveInReset(hWaveIn);
            call_waveInUnprepareHeader(hWaveIn,pwh,sizeof(WAVEHDR));
            call_waveInClose(hWaveIn);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        dw = GetMSFromMMTIME(gti.pwfxInput,&mmt);

        if(0 == dw)
        {
            LogFail("Position is zero after playing");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("Position is non-zero after playing");
        }

        call_waveInReset(hWaveIn);

        //
        //  Verify waveInGetPosition resets after waveInReset.
        //

        Log_TestCase("~Verifying waveInGetPosition is zero after reset");

        mmr = call_waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveInGetPosition failed");

            call_waveInReset(hWaveIn);
            call_waveInUnprepareHeader(hWaveIn,pwh,sizeof(WAVEHDR));
            call_waveInClose(hWaveIn);

            ExactHeapDestroy(hHeap);
            return TST_FAIL;
        }

        dw = GetMSFromMMTIME(gti.pwfxInput,&mmt);

        if(0 == dw)
        {
            LogPass("Position is zero after reset");
        }
        else
        {
            LogFail("Position is non-zero after playing");

            iResult = TST_FAIL;
        }
    }

    //
    //  Verify waveInGetPosition is not going backwards.
    //

    Log_TestCase("~Verifying waveInGetPosition is not going backwards");

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        pwh->dwFlags &= (~WHDR_DONE);

        call_waveInAddBuffer(hWaveIn,pwh,sizeof(WAVEHDR));

        tstLog(VERBOSE,"Note: Time type is [%s].",GetTimeTypeText(u));

        call_waveInStart(hWaveIn);

        dwTimebase = 0;
        dw         = 0;

        while(!(pwh->dwFlags & WHDR_DONE))
        {
            mmr = waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

            if(MMSYSERR_NOERROR != mmr)
            {
                LogFail("waveInGetPosition returned error");

                iResult = TST_FAIL;

                break;
            }

            if(u != mmt.wType)
            {
                //
                //  This time type is not supported by hardware.
                //

                dw = 2;

                break;
            }

            dwTime = GetValueFromMMTIME(&mmt);

            if(dwTime < dwTimebase)
            {
                tstLog(TERSE,
                    "    FAIL: waveInGetPosition went from %lu to %lu.",
                    dwTimebase,
                    dwTime);

                iResult = TST_FAIL;
                dw      = 1;
            }

            dwTimebase = dwTime;
        }

        call_waveInReset(hWaveIn);

        if(0 == dw)
        {
            LogPass("Position did not go backwards");
        }
    }

    //
    //  Verify waveInGetPosition reaches the end of buffer.
    //

    Log_TestCase("~Verifying waveInGetPosition reaches the end of buffer");

    pwh->dwFlags &= (~WHDR_DONE);
    
    call_waveInAddBuffer(hWaveIn,pwh,sizeof(WAVEHDR));
    call_waveInStart(hWaveIn);

    //
    //  Polling waiting for tests to get finished.
    //

    while(!(pwh->dwFlags & WHDR_DONE));

    dwTimebase = pwh->dwBufferLength * 1000 / gti.pwfxInput->nAvgBytesPerSec;

    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        mmr = call_waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

        if(MMSYSERR_NOERROR != mmr)
        {
            LogFail("waveInGetPosition returns error");

            break;
        }

        if(TIME_BYTES == mmt.wType)
        {
            if(mmt.u.cb != pwh->dwBufferLength)
            {
                tstLog(
                    TERSE,
                    "    FAIL:Buffer length is %lu bytes; position "
                        "is %lu bytes.",
                    pwh->dwBufferLength,
                    mmt.u.cb);

                iResult = TST_FAIL;
            }
            else
            {
                tstLog(
                    VERBOSE,
                    "    PASS:Both buffer length and position are %lu bytes.",
                    pwh->dwBufferLength);
            }
        }
        else
        {
            dw = GetMSFromMMTIME(gti.pwfxInput,&mmt);

            if(dwTimebase != dw)
            {
                tstLog(
                    TERSE,
                    "    FAIL:Buffer length is %lu ms; position is %lu ms.",
                    dwTimebase,
                    dw);

                iResult = TST_FAIL;
            }
            else
            {
                tstLog(
                    VERBOSE,
                    "    PASS:Both buffer length and position are %lu ms.",
                    dw);
            }
        }
    }

    //
    //  Verify waveInGetPosition is not "snapped" to DMA buffer size.
    //

#pragma message(REMIND("DMA buffer size thingy"))
    for(u = TIME_TICKS;u;u/=2)
    {
        mmt.wType = u;

        //
        //  Verify waveInGetPosition accuracy
        //
    }

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveInGetPosition()


//--------------------------------------------------------------------------;
//
//  int Test_waveInPrepareHeader
//
//  Description:
//      Tests the driver functionality for waveInPrepareHeader.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInPrepareHeader
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pWaveHdr;
    LPBYTE              pData;
    DWORD               cbSize;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInPrepareHeader";

    Log_TestName(szTestName);

    pWaveHdr = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    cbSize = gti.pwfxInput->nAvgBytesPerSec;

    pData = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        return TST_FAIL;
    }

    //
    //  First, verify prepare works...
    //

    Log_TestCase("~Verifying prepare after open works");

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData            = pData;
    pWaveHdr->dwBufferLength    = cbSize;

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);
        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        return TST_FAIL;
    }
    else
    {
        LogPass("waveInPrepareHeader succeeds");
    }

    //
    //  Second, verify WHDR_PREPARED bit is set.
    //

    Log_TestCase("~Verifying WHDR_PREPARED bit is set in WAVEHDR.dwFlags");

    if(pWaveHdr->dwFlags & WHDR_PREPARED)
    {
        LogPass("waveInPrepareHeader sets the WHDR_PREPARED bit");
    }
    else
    {
        LogFail("waveInPrepareHeader does not set WHDR_PREPARED bit");

        iResult = TST_FAIL;
    }

    //
    //  Third, verify preparing twice succeeds.
    //

    Log_TestCase("~Verifying preparing twice succeeds");

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveInPrepareHeader succeed");
    }

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);
    ExactFreePtr(pWaveHdr);
    ExactFreePtr(pData);

    return (iResult);
} // Test_waveInPrepareHeader()


//--------------------------------------------------------------------------;
//
//  int Test_waveInUnprepareHeader
//
//  Description:
//      Tests the driver functionality for waveInUnprepareHeader.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInUnprepareHeader
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pWaveHdr;
    LPBYTE              pData;
    DWORD               cbSize;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInUnprepareHeader";

    Log_TestName(szTestName);

    pWaveHdr = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pWaveHdr)
    {
        DPF(1,gszFailExactAlloc);

        return TST_FAIL;
    }

    cbSize = gti.pwfxInput->nAvgBytesPerSec;

    pData = ExactAllocPtr(GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData)
    {
        DPF(1,gszFailExactAlloc);

        ExactFreePtr(pWaveHdr);
        return TST_FAIL;
    }

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);
        return TST_FAIL;
    }

    //
    //  First, verify unprepare works...
    //

    Log_TestCase("~Verifying unprepare after prepare works");

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData            = pData;
    pWaveHdr->dwBufferLength    = cbSize;

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        return TST_FAIL;
    }

    if(!(WHDR_PREPARED & pWaveHdr->dwFlags))
    {
        LogFail("waveInPrepareHeader did not set WHDR_PREPARED bit");

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        return TST_FAIL;
    }

    mmr = call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        return TST_FAIL;
    }
    else
    {
        LogPass("waveInUnprepareHeader succeeds");
    }

    //
    //  Second, verify WHDR_PREPARED bit is cleared.
    //

    Log_TestCase("~Verifying WHDR_PREPARED bit is cleared in WAVEHDR.dwFlags");

    if(WHDR_PREPARED & pWaveHdr->dwFlags)
    {
        LogFail("waveInUnprepareHeader did not clear WHDR_PREPARED bit");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveInUnprepareHeader cleared WHDR_PREPARED bit");
    }

    //
    //  Third, verify unpreparing twice succeeds.
    //

    Log_TestCase("~Verify unpreparing header twice succeeds");

    mmr = call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInUnprepareHeader twice failed");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveInUnprepareHeader twice succeeds");
    }

    //
    //  Fourth, verify unpreparing queued buffer fails.
    //

    Log_TestCase("~Verify unpreparing queued buffer fails");

    _fmemset(pWaveHdr,0,sizeof(WAVEHDR));

    pWaveHdr->lpData            = pData;
    pWaveHdr->dwBufferLength    = cbSize;

    mmr = call_waveInPrepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        ExactFreePtr(pWaveHdr);
        ExactFreePtr(pData);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        return TST_FAIL;
    }

    call_waveInAddBuffer(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    mmr = call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(pWaveHdr->dwFlags & WHDR_INQUEUE)
    {
        if(WAVERR_STILLPLAYING == mmr)
        {
            LogPass("waveInUnpreparedHeader failed while playing");
        }
        else
        {
            LogFail("waveInPrepareHeader succeeds while playing");

            iResult = TST_FAIL;
        }
    }
    else
    {
        LogFail("Test inconclusive");

        iResult = TST_FAIL;
    }

    //
    //  Fifth, verify unpreparing after playback succeeds.
    //

    call_waveInReset(hWaveIn);
    
    mmr = call_waveInUnprepareHeader(hWaveIn,pWaveHdr,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInUnprepareHeader after playing fails");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("waveInUnprepareHeader after playing succeeds");
    }

    call_waveInClose(hWaveIn);
    ExactFreePtr(pWaveHdr);
    ExactFreePtr(pData);

    return (iResult);
} // Test_waveInUnprepareHeader()


//--------------------------------------------------------------------------;
//
//  BOOL IsStopped
//
//  Description:
//      Determines if a wave-in device is stopped by doing two successive
//          waveInGetPosition.
//
//  Arguments:
//      HWAVEIN hWaveIn: Handle to open instance.
//
//  Return (BOOL):
//      TRUE if stopped, FALSE otherwise.
//
//  History:
//      12/20/94    Fwong       for waveInStart tests.
//
//--------------------------------------------------------------------------;

BOOL IsStopped
(
    HWAVEIN hWaveIn
)
{
    MMTIME      mmt;
    MMRESULT    mmr;
    DWORD       dwTime;
    DWORD       dw;

    mmt.wType = TIME_BYTES;

    mmr = waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

    if(MMSYSERR_NOERROR != mmr)
    {
        return FALSE;
    }

    dwTime = mmt.u.cb;

    dw = waveGetTime();
    
    dw += gti.cMinStopThreshold;

    //
    //  Waiting for threshold number of milliseconds.
    //

    while(dw > (waveGetTime()));

    DPF(3,"Time: %lu ",waveGetTime());

    mmt.wType = TIME_BYTES;

    mmr = waveInGetPosition(hWaveIn,&mmt,sizeof(MMTIME));

    if(MMSYSERR_NOERROR != mmr)
    {
        return FALSE;
    }

    dw = mmt.u.cb;

    DPF(3,"IsStopped: dw = %lu, dwTime = %lu",dw,dwTime);

    return ((dw == dwTime)?TRUE:FALSE);
} // IsStopped()


//--------------------------------------------------------------------------;
//
//  int Test_waveInStart
//
//  Description:
//      Tests the driver functionality for waveInStart.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInStart
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh1;
    volatile LPWAVEHDR  pwh2;
    LPBYTE              pData1,pData2;
    HANDLE              hHeap;
    DWORD               cbSize;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInStart";

    //
    //  Are there any input devices?
    //

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    pData1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    pData2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    //
    //  Opening device.
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        0L,
        0L,
        INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh1->lpData            = pData1;
    pwh1->dwBufferLength    = cbSize;
    pwh1->dwBytesRecorded   = 0L;
    pwh1->dwUser            = 0L;
    pwh1->dwFlags           = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //
    //  Verify device is stopped when first openened.
    //

    Log_TestCase("Verifying device is stopped when first openened");

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogPass("Device is stopped immediately after open");
    }
    else
    {
        LogFail("Device is recording immediately after open");

        iResult = TST_FAIL;
    }

    //
    //  Verify device is recording after waveInStart.
    //

    Log_TestCase("Verifying device is recording after waveInStart");

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStart returned error");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    if(IsStopped(hWaveIn))
    {
        LogFail("Device is stopped");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not stopped");
    }

    //
    //  Verify waveInStart before waveInPrepareHeader works.
    //

    Log_TestCase("Verifying waveInStart before waveInPrepareHeader works");

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStart failed");

        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogFail("Device is stopped after waveInStart");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not stopped after waveInStart");
    }

    //
    //  Verify waveInStart before waveInAddBuffer works.
    //

    Log_TestCase("Verifying waveInStart before waveInAddBuffer works");

    call_waveInReset(hWaveIn);

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStart failed");

        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogFail("Device is stopped after waveInStart");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("Device is not stopped after waveInStart");
    }

    //
    //  Verify starting after waveInStop works.
    //

    Log_TestCase("Verifying starting after waveInStop works");

    pwh2->lpData            = pData2;
    pwh2->dwBufferLength    = cbSize;
    pwh2->dwBytesRecorded   = 0L;
    pwh2->dwUser            = 0L;
    pwh2->dwFlags           = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveInReset(hWaveIn);
    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInAddBuffer(hWaveIn,pwh2,sizeof(WAVEHDR));

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStart failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveInStop(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStop failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    if(IsStopped(hWaveIn))
    {
        mmr = call_waveInStart(hWaveIn);

        if(IsStopped(hWaveIn))
        {
            LogFail("waveInStart did not start device");

            iResult = TST_FAIL;
        }
        else
        {
            LogPass("waveInStart started device");
        }
    }
    else
    {
        LogFail("waveInStop did not stop device");

        iResult = TST_FAIL;
    }

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveInStart()


//--------------------------------------------------------------------------;
//
//  int Test_waveInStop
//
//  Description:
//      Tests the driver functionality for waveInStop.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInStop
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh1;
    volatile LPWAVEHDR  pwh2;
    LPBYTE              pData1,pData2;
    LPWAVEINFO          pwi;
    DWORD               cbSize;
    HANDLE              hHeap;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInStop";

    //
    //  Are there any input devices?
    //

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    pData1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pData2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,cbSize);

    if(NULL == pData2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwi = ExactHeapAllocPtr(
        hHeap,
        GMEM_MOVEABLE|GMEM_SHARE,
        sizeof(WAVEINFO) + 2*sizeof(DWORD));

    if(NULL == pwi)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    PageLock(pwi);

    pwi->dwInstance = 0L;
    pwi->fdwFlags   = 0L;
    pwi->dwCount    = 0L;
    pwi->dwCurrent  = 0L;

    DLL_WaveControl(DLL_INIT,pwi);

    //
    //  Opening device.
    //

    mmr = call_waveInOpen(
        &hWaveIn,
        gti.uInputDevice,
        gti.pwfxInput,
        (DWORD)(FARPROC)pfnCallBack,
        0L,
        CALLBACK_FUNCTION|INPUT_MAP(gti));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailOpen);

        return TST_FAIL;
    }

    pwh1->lpData             = pData1;
    pwh1->dwBufferLength     = cbSize;
    pwh1->dwBytesRecorded    = 0L;
    pwh1->dwUser             = 0L;
    pwh1->dwFlags            = 0L;

    pwh2->lpData             = pData2;
    pwh2->dwBufferLength     = cbSize;
    pwh2->dwBytesRecorded    = 0L;
    pwh2->dwUser             = 0L;
    pwh2->dwFlags            = 0L;

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    //
    //  Verify driver is stopped by default.
    //

    Log_TestCase("Verifying driver is stopped by default");

    if(IsStopped(hWaveIn))
    {
        LogPass("Device is stopped immediately after open");
    }
    else
    {
        LogFail("Device is not stopped after open");

        iResult = TST_FAIL;
    }

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    pwh1->dwFlags = 0L;

    //
    //  Verify stopping before waveInPrepareHeader buffer works.
    //

    Log_TestCase("Verifying stopping before waveInPrepareHeader buffer works");

    mmr = call_waveInStop(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStop failed");

        call_waveInClose(hWaveIn);
        
        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveInPrepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogPass("Device is stopped");
    }
    else
    {
        LogFail("Device is not stopped");

        iResult = TST_FAIL;
    }

    call_waveInStart(hWaveIn);
    call_waveInReset(hWaveIn);

    pwh1->dwFlags &= (~WHDR_DONE);

    //
    //  Verify stopping before waveInAddBuffer works.
    //

    Log_TestCase("Verifying stopping before waveInAddBuffer works");

    mmr = call_waveInStop(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStop failed");

        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);

        return TST_FAIL;
    }

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogPass("Device is stopped");
    }
    else
    {
        LogFail("Device is not stopped");

        iResult = TST_FAIL;
    }

    //
    //  Verify driver is stopped after waveInReset.
    //

    call_waveInReset(hWaveIn);

    pwi->dwCount   = 2;
    pwi->dwCurrent = 0L;

    pwh1->dwFlags &= (~WHDR_DONE);

    Log_TestCase("Verifying driver is stopped after waveInReset");

    call_waveInAddBuffer(hWaveIn,pwh1,sizeof(WAVEHDR));

    if(IsStopped(hWaveIn))
    {
        LogPass("Device is not stopped after waveInReset");
    }
    else
    {
        LogFail("Device is stopped after waveInReset");

        iResult = TST_FAIL;
    }

    //
    //  Verify stopping while recording works.
    //

    Log_TestCase("Verifying stopping while recording works");

    mmr = call_waveInPrepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail(gszFailWIPrepare);

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    //  Note: There is already a buffer in the queue...

    call_waveInAddBuffer(hWaveIn,pwh2,sizeof(WAVEHDR));

    mmr = call_waveInStart(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStart failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    mmr = call_waveInStop(hWaveIn);

    if(MMSYSERR_NOERROR != mmr)
    {
        LogFail("waveInStop failed");

        call_waveInReset(hWaveIn);
        call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
        call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
        call_waveInClose(hWaveIn);

        DLL_WaveControl(DLL_END,NULL);
        PageUnlock(pwi);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    if(IsStopped(hWaveIn))
    {
        LogPass("Device is stopped");
    }
    else
    {
        LogFail("Device is not stopped");

        iResult = TST_FAIL;
    }

    //
    //  Verify the immediate buffer is marked done on a waveInStop.
    //

    Log_TestCase("Verifying the immediate buffer is marked done on a "
        "waveInStop");

    if(pwh1->dwFlags & WHDR_DONE)
    {
        LogPass("Immediate buffer is done after waveInStop");
    }
    else
    {
        LogFail("Immediate buffer is not marked done after waveInStop");

        iResult = TST_FAIL;
    }

    //
    //  Verify additional buffers are not done.     
    //

    Log_TestCase("Verify additional buffers are not done");

    if(pwh2->dwFlags & WHDR_DONE)
    {
        LogFail("additional buffers are marked done");

        iResult = TST_FAIL;
    }
    else
    {
        LogPass("additional buffers are not marked done");
    }

    //
    //  Verify only one callback was made.
    //

    Log_TestCase("Verifying only one callback was made");

    if(1 == pwi->dwCurrent)
    {
        LogPass("Only one callback was made");
    }
    else
    {
        iResult = TST_FAIL;

        if(0 == pwi->dwCurrent)
        {
            LogFail("No callbacks were made");
        }
        else
        {
            LogFail("Too many callbacks were made");
        }
    }

    call_waveInReset(hWaveIn);
    call_waveInUnprepareHeader(hWaveIn,pwh1,sizeof(WAVEHDR));
    call_waveInUnprepareHeader(hWaveIn,pwh2,sizeof(WAVEHDR));
    call_waveInClose(hWaveIn);

    DLL_WaveControl(DLL_END,NULL);
    PageUnlock(pwi);

    ExactHeapDestroy(hHeap);

    return (iResult);
} // Test_waveInStop()


//--------------------------------------------------------------------------;
//
//  int Test_waveInReset
//
//  Description:
//      Tests the driver functionality for waveInReset.
//
//  Arguments:
//      None.
//
//  Return (int):
//      TST_PASS if behavior is bug-free, TST_FAIL otherwise.
//
//  History:
//      02/21/94    Fwong       Added to new WaveTest.
//
//--------------------------------------------------------------------------;

int FNGLOBAL Test_waveInReset
(
    void
)
{
    HWAVEIN             hWaveIn;
    MMRESULT            mmr;
    volatile LPWAVEHDR  pwh1;
    volatile LPWAVEHDR  pwh2;
    HANDLE              hHeap;
    LPBYTE              pData1,pData2;
    DWORD               cbSize;
    LPWAVEINFO          pwi;
    DWORD               dw;
    MMTIME              mmt;
    int                 iResult = TST_PASS;
    static char         szTestName[] = "waveInReset";

    //
    //  Are there any input devices?
    //

    if(0 == waveInGetNumDevs())
    {
        tstLog(TERSE,gszMsgNoInDevs);

        return iResult;
    }

    //
    //  Getting buffer length (defaults to 5 seconds)...
    //

    cbSize  = GetIniDWORD(szTestName,gszDataLength,5);
    cbSize *= gti.pwfxInput->nAvgBytesPerSec;
    cbSize  = ROUNDUP_TO_BLOCK(cbSize,gti.pwfxInput->nBlockAlign);

    //
    //  Allocating memory.
    //

    hHeap = ExactHeapCreate(0L);

    if(NULL == hHeap)
    {
        LogFail(gszFailNoMem);

        return TST_FAIL;
    }

    pwh1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh1)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pwh2 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHARE,sizeof(WAVEHDR));

    if(NULL == pwh2)
    {
        LogFail(gszFailNoMem);

        ExactHeapDestroy(hHeap);
        return TST_FAIL;
    }

    pData1 = ExactHeapAllocPtr(hHeap,GMEM_MOVEABLE|GMEM_SHA