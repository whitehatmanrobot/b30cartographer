           SiblingsList);

        Current = Current->Flink;

        ViDeadlockDeleteTree (Node);
    }

    ViDeadlockFree (Root);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\locktest.h ===
#ifndef _LOCKTEST_H_INCLUDED_
#define _LOCKTEST_H_INCLUDED_

VOID DeadlockPositiveTest (
    PVOID NotUsed
    );

VOID DeadlockNegativeTest (
    PVOID NotUsed
    );

VOID DeadlockStressTest (
    PVOID NotUsed
    );

#endif // #ifndef _LOCKTEST_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\contmem.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  contmem.h
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmAllocateContiguousMemorySpecifyCache.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

void
TdMmAllocateContiguousMemorySpecifyCacheTest(
    PVOID NotUsed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\locktest.c ===
#include <ntddk.h>

#include "active.h"
#include "locktest.h"

#if LOCKTEST_ACTIVE

//
// Real implementation if the module is active
//

VOID DeadlockPositiveTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: not implemented \n");
}


VOID DeadlockNegativeTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: not implemented \n");
}

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// Stress test
/////////////////////////////////////////////////////////////////////

VOID 
StressLockHierarchy (
    ULONG NumberOfIterations,
    ULONG NumberOfResources,
    ULONG Probability,
    ULONG Seed,
    BOOLEAN InjectDeadlocks
    );

NTSYSAPI                                            // ntifs
ULONG                                               // ntifs
NTAPI                                               // ntifs
RtlRandom (                                         // ntifs
    PULONG Seed                                     // ntifs
    );                                              // ntifs


ULONG InjectDeadlocks;

VOID 
DeadlockStressTest (
    PVOID NotUsed
    )
{
    StressLockHierarchy (128, 
                         64,
                         20,
                         0, 
                         InjectDeadlocks ? TRUE : FALSE);
}

#define LOCK_ACQUIRED 0x0001
#define LOCK_DELETED  0x0002
#define LOCK_RANDOM   0x0004

ULONG Finish;

VOID 
StressLockHierarchy (
    ULONG NumberOfIterations,
    ULONG NumberOfResources,
    ULONG Probability,
    ULONG Seed,
    BOOLEAN InjectDeadlocks
    )
{
    PFAST_MUTEX * Locks; 
    PULONG Flags;
    ULONG I, J, K, Ri;
    BOOLEAN ShouldAcquire;
    BOOLEAN ShouldDelete;

    Locks = NULL;
    Flags = NULL;

    Locks = (PFAST_MUTEX *) ExAllocatePool (NonPagedPool, NumberOfResources * sizeof (PFAST_MUTEX));

    if (! Locks) {
        goto Exit;
    }

    Flags = (PULONG) ExAllocatePool (NonPagedPool, NumberOfResources * sizeof (ULONG));

    if (! Flags) {
        goto Exit;
    }

    RtlZeroMemory (Locks, NumberOfResources * sizeof (PFAST_MUTEX));
    RtlZeroMemory (Flags, NumberOfResources * sizeof (ULONG));

    for (I = 0; I < NumberOfResources; I += 1) {

        Locks[I] = ExAllocatePool (NonPagedPool, sizeof (FAST_MUTEX));

        if (! (Locks[I])) {
            goto Exit;
        }

        ExInitializeFastMutex (Locks[I]);
    }

    DbgPrint ("Starting test iterations ... \n");

    KeEnterCriticalRegion ();

    for (I = 0; I < NumberOfIterations; I += 1) {

        BOOLEAN DeadlockInjected = FALSE;

        if (InjectDeadlocks) {
            
            Ri = RtlRandom(&Seed) % NumberOfResources;

            if (! (Flags[Ri] & LOCK_DELETED)) {

                ExAcquireFastMutexUnsafe (Locks[Ri]);
                Flags[Ri] |= LOCK_ACQUIRED;
                Flags[Ri] |= LOCK_RANDOM;
                DeadlockInjected = TRUE;
            }
        }

        for (J = 0; J < NumberOfResources; J += 1) {
            
            if (Finish) {
                return;
            }

            if ((Flags[J] & LOCK_DELETED)) {
                DbgPrint (".");
                continue;
            }

            if ((Flags[J] & LOCK_RANDOM)) {
                DbgPrint ("*");
                continue;
            }

            ShouldDelete = ((RtlRandom(&Seed) % 1000) < 10) ? TRUE : FALSE;

            if (ShouldDelete) {
                
                DbgPrint ("D");

                // mark block in a special way so verifier version of ExFreePool
                // will know we are deleting a resource.

                *((PULONG)(Locks[J])) = 0xABCDDCBA;
                ExFreePool (Locks[J]);
                Locks[J] = NULL;
                Flags[J] |= LOCK_DELETED;
            }

            if ((Flags[J] & LOCK_DELETED)) {
                continue;
            }

            ShouldAcquire = ((RtlRandom(&Seed) % 100) < Probability) ? TRUE : FALSE;

            if (ShouldAcquire) {
                
                DbgPrint ("A");
                ExAcquireFastMutexUnsafe (Locks[J]);
                Flags[J] |= LOCK_ACQUIRED;
            }
            else {
                DbgPrint ("-");
            }
        }

        for (J = 0; J < NumberOfResources; J += 1) {

            if (Finish) {
                return;
            }

            // K = NumberOfResources - J - 1;
            K = J; // release in reverse order

            if ((Flags[K] & LOCK_DELETED)) {
                continue;
            }
            
            if ((Flags[K] & LOCK_RANDOM)) {
                continue;
            }

            if ((Flags[K] & LOCK_ACQUIRED)) {
                // DbgPrint ("R");
                ExReleaseFastMutexUnsafe (Locks[K]);
                Flags[K] &= ~LOCK_ACQUIRED;
            }
            else {
                // DbgPrint ("-");
            }
        }
        
        if (DeadlockInjected) {

            ExReleaseFastMutexUnsafe (Locks[Ri]);
            Flags[Ri] &= ~LOCK_ACQUIRED;
            Flags[Ri] &= ~LOCK_RANDOM;
        }

        // if (I && I % 100 == 0) {
            DbgPrint ("\n");
        // }
    }

    DbgPrint ("\n");

    KeLeaveCriticalRegion ();

    Exit:

    for (I = 0; I < NumberOfResources; I += 1) {
        if (Locks[I]) {
            
            // mark block in a special way so verifier version of ExFreePool
            // will know we are deleting a resource.

            *((PULONG)(Locks[I])) = 0xABCDDCBA;
            ExFreePool (Locks[I]);
        }
    }
    
    if (Locks) {
        ExFreePool (Locks);
    }
    
    if (Flags) {
        ExFreePool (Flags);
    }
}


#else

//
// Dummy implementation if the module is inactive
//

VOID DeadlockPositiveTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: deadlock module is disabled \n");
}


VOID DeadlockNegativeTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: deadlock module is disabled \n");
}

VOID DeadlockStressTest (
    PVOID NotUsed
    )
{
	DbgPrint ("Buggy: deadlock module is disabled \n");
}

#endif // #if !NEWSTUFF_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\contmem.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  contmem.c
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmAllocateContiguousMemorySpecifyCache.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

#include <ntddk.h>

#include "active.h" 
#include "ContMem.h"

#if !CONTMEM_ACTIVE

VOID
TdMmAllocateContiguousMemorySpecifyCacheTest(
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: contmem test is disabled \n");
}

#else 

/////////////////////////////////////////////////////////////////////////
//
// data structures
//

typedef struct _tag_cont_mem_test_variation
{
    SIZE_T sizeChunk;
    PHYSICAL_ADDRESS phaLowestAcceptableAddress;
    PHYSICAL_ADDRESS phaHighestAcceptableAddress;
    PHYSICAL_ADDRESS phaBoundaryAddressMultiple;
    MEMORY_CACHING_TYPE CacheType;
} ContMemTestVariation, *PContMemTestVariation;

/////////////////////////////////////////////////////////////////////////
//
// test variations
//

// TEST TEST
ContMemTestVariation aTestVariations[ 864 ];
// ContMemTestVariation aTestVariations[ 54 ];
// TEST TEST

/////////////////////////////////////////////////////////////////////////
//
// private functions declaration
//

void
FillVariationsBuffer();

void
InitializeVariation(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType );
 
void
InitializeVariationBound1Page(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType );

void
InitializeVariationBoundFourthTimeSize(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType );


/////////////////////////////////////////////////////////////////////////
//
// public functions
//

void
TdMmAllocateContiguousMemorySpecifyCacheTest(
    PVOID NotUsed
    )
{
    int nVariations;
    int nCrtVariation;
    ULONG_PTR nNumPages;
    ULONG_PTR nCrtPage;
    PVOID pBuffer;
    PHYSICAL_ADDRESS phaCrtPage;
    PHYSICAL_ADDRESS phaPrevPage;
    PUCHAR pcCrtPage;

    //
    // setup the variations data
    //

    FillVariationsBuffer();

    //
    // loop fo every variation structure
    //

    nVariations = ARRAY_LENGTH( aTestVariations );

    //while( TRUE )
    {
        for( nCrtVariation = 0; nCrtVariation < nVariations; nCrtVariation++ )
        {
            //
            // output the current variation's parameters
            //

            DbgPrint( "Variation %d: (%p, %I64X, %I64X, %I64X, %s)\n",
                nCrtVariation,

                aTestVariations[ nCrtVariation ].sizeChunk,

                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart,
                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart,
                aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart,

                (aTestVariations[ nCrtVariation ].CacheType == MmCached) ? "MmCached" : "MmNonCached" );

            //
            // try to allocate the buffer
            //

            pBuffer = MmAllocateContiguousMemorySpecifyCache(
                aTestVariations[ nCrtVariation ].sizeChunk,
                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress,
                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress,
                aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple,
                aTestVariations[ nCrtVariation ].CacheType );

            //
            // output the returned address
            //

            DbgPrint( "MmAllocateContiguousMemorySpecifyCache returned %p\n",
                pBuffer );

            //
            // sanity checks
            //

            if( pBuffer != NULL )
            {
                nNumPages = aTestVariations[ nCrtVariation ].sizeChunk / PAGE_SIZE;

                pcCrtPage = (PUCHAR)pBuffer;
            
                phaPrevPage.QuadPart = 0;

                for( nCrtPage = 0; nCrtPage < nNumPages; nCrtPage++ )
                {
                    //
                    // get the physical address for this page
                    //

                    phaCrtPage = MmGetPhysicalAddress( pcCrtPage );

                    if( phaCrtPage.QuadPart == 0 )
                    {
                        DbgPrint( "MmGetPhysicalAddress( %p ) returned NULL!\n" );
                    
                        DbgBreakPoint();
                    }
                    else
                    {
                        //
                        // check LowestAcceptableAddress
                        //

                        if( phaCrtPage.QuadPart < aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart )
                        {
                            DbgPrint( "%p, physical %I64X, LowestAcceptableAddress = %I64X\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart );
                        
                            DbgBreakPoint();
                        }
                        /*
                        // TEST TEST
                        else
                        {
                            DbgPrint( "%p, physical %I64X, LowestAcceptableAddress = %I64X -> OK\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaLowestAcceptableAddress.QuadPart );
                        }
                        // TEST TEST
                        */

                        //
                        // check HighestAcceptableAddress
                        //

                        if( phaCrtPage.QuadPart > aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart )
                        {
                            DbgPrint( "%p, physical %I64X, HighestAcceptableAddress = %I64X\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart );
                        
                            DbgBreakPoint();
                        }
                        /*
                        // TEST TEST
                        else
                        {
                            DbgPrint( "%p, physical %I64X, HighestAcceptableAddress = %I64X -> OK\n",
                                pcCrtPage,
                                phaCrtPage.QuadPart,
                                aTestVariations[ nCrtVariation ].phaHighestAcceptableAddress.QuadPart );
                        }
                        // TEST TEST
                        */

                        //
                        // check BoundaryAddressMultiple
                        //

                        if( aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart != 0 )
                        {
                            if( pcCrtPage != pBuffer &&     // not the first page
                                ( phaCrtPage.QuadPart % aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart ) == 0 )
                            {
                                DbgPrint( "%p, physical %I64X, BoundaryAddressMultiple = %I64X\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart );
                        
                                DbgBreakPoint();
                            }
                            /*
                            // TEST TEST
                            else
                            {
                                DbgPrint( "%p, physical %I64X, BoundaryAddressMultiple = %I64X -> OK\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    aTestVariations[ nCrtVariation ].phaBoundaryAddressMultiple.QuadPart );
                            }
                            // TEST TEST
                            */
                        }

                        //
                        // verify that the pages are physically contiguous
                        //

                        if( phaPrevPage.QuadPart != 0 )
                        {
                            if( phaCrtPage.QuadPart - phaPrevPage.QuadPart != PAGE_SIZE )
                            {
                                DbgPrint( "%p, physical %I64X, previous physical page = %I64X\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    phaPrevPage.QuadPart );

                                DbgBreakPoint();
                            }
                            /*
                            // TEST TEST
                            else
                            {
                                DbgPrint( "%p, physical %I64X, previous physical page = %I64X -> OK\n",
                                    pcCrtPage,
                                    phaCrtPage.QuadPart,
                                    phaPrevPage.QuadPart );
                            }
                            // TEST TEST
                            */
                        }

                        //
                        // write something there
                        //

                        *pcCrtPage = 'x';

                        //
                        // keep track of the latest page
                        //

                        phaPrevPage = phaCrtPage;
                    }

                    //
                    // next page 
                    //

                    pcCrtPage += PAGE_SIZE;
                }
            
                //
                // free the buffer
                //

                MmFreeContiguousMemorySpecifyCache( 
                    pBuffer,
                    aTestVariations[ nCrtVariation ].sizeChunk,
                    aTestVariations[ nCrtVariation ].CacheType );
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////
//
// private functions
//

void
InitializeVariation(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType )
{
    pTestVar->sizeChunk = sizeChunk;
    pTestVar->phaLowestAcceptableAddress.QuadPart = phaLowestAcceptableAddress;
    pTestVar->phaHighestAcceptableAddress.QuadPart = phaHighestAcceptableAddress;
    pTestVar->phaBoundaryAddressMultiple.QuadPart = phaBoundaryAddressMultiple;
    pTestVar->CacheType = CacheType;
}

/////////////////////////////////////////////////////////////////////////

void
InitializeVariationBound1Page(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType )
{
    phaBoundaryAddressMultiple = (LONGLONG) sizeChunk + (LONGLONG) PAGE_SIZE;
    
    InitializeVariation(
        pTestVar,
        sizeChunk,
        phaLowestAcceptableAddress,
        phaHighestAcceptableAddress,
        phaBoundaryAddressMultiple,
        CacheType );
}

void
InitializeVariationBoundFourthTimeSize(
    PContMemTestVariation pTestVar,
    SIZE_T sizeChunk,
    LONGLONG phaLowestAcceptableAddress,
    LONGLONG phaHighestAcceptableAddress,
    LONGLONG phaBoundaryAddressMultiple,
    MEMORY_CACHING_TYPE CacheType )
{
    phaBoundaryAddressMultiple = (LONGLONG) sizeChunk * (LONGLONG) 4;
    
    InitializeVariation(
        pTestVar,
        sizeChunk,
        phaLowestAcceptableAddress,
        phaHighestAcceptableAddress,
        phaBoundaryAddressMultiple,
        CacheType );
}

/////////////////////////////////////////////////////////////////////////

void
FillVariationsBuffer()
{
    int nCrtVarIndex;

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-16 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 0 ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 1 ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 2 ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 3 ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 4 ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 5 ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 6 ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 7 ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 8 ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 9 ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 10 ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 11 ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 12 ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 13 ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 14 ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 15 ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 16 ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 17 ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-32 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 18 ], 
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 19 ],
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 20 ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 21 ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 22 ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 23 ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 24 ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 25 ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 26 ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 27 ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 28 ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 29 ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 30 ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 31 ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 32 ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 33 ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 34 ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 35 ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (2 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 36 ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 37 ],
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 38 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 39 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 40 ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 41 ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 42 ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 43 ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 44 ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 45 ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 46 ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 47 ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 48 ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 49 ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 50 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 51 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 52 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 53 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );


// TEST TEST
    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 54 ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 55 ],
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 56 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 57 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 58 ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 59 ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 60 ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 61 ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 62 ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 63 ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 64 ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 65 ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 66 ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 67 ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 68 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 69 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 70 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 71 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 72 ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 73 ],
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 74 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 75 ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 76 ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 77 ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 78 ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 79 ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 80 ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 81 ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 82 ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 83 ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 84 ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 85 ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 86 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 87 ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 88 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 89 ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////
    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8-16 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 90 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 91 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 92 ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 93 ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 94 ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 95 ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 96 ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 97 ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 98 ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 99 ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 100 ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 101 ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 102 ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 103 ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 104 ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 105 ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 106 ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 107 ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - 32 Mb limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 108 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 109 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 110 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 111 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 112 ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 113 ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 114 ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 115 ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 116 ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 117 ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 118 ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 119 ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 120 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 121 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 122 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 123 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 124 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 125 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (2 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 126 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 127 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 128 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 129 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 130 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 131 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 132 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 133 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 134 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 135 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 136 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 137 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 138 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 139 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 140 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 141 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 142 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 143 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 144 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 145 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 146 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 147 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 148 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 149 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 150 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 151 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 152 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 153 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 154 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 155 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 156 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 157 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 158 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 159 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 160 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 161 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 162 ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 163 ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 164 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 165 ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 166 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 167 ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 168 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 169 ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 170 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 171 ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 172 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 173 ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 174 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 175 ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 176 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 177 ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 178 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 179 ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (2 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 180 ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 181 ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 182 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 183 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 184 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 185 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 186 ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 187 ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 188 ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 189 ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 190 ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 191 ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 192 ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 193 ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 194 ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 195 ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 196 ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 197 ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 198 ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ 199 ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 200 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 201 ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 202 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 203 ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ 204 ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    //////////////////////////////////////////

    nCrtVarIndex = 205;

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 233
    //

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (4 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 269
    //

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 4 Gb - (8 Gb - 1 ) limits
    // - no boundaries
    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 287
    //

    InitializeVariation( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-16 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;
    
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-32 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (2 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8-16 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - 32 Mb limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (2 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (2 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 233
    //

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (4 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 269
    //

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 4 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 575
    //

    InitializeVariationBound1Page( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-16 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;
    
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex],
        16 * 1024 * 1024,
        0,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0-32 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (2 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 0 - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        0,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8-16 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        32 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached ); 

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        64 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        128 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        256 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        16 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - 32 Mb limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        32 * 1024 * 1024,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (2 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 8 Mb - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        8 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (2 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 1 Gb - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 233
    //

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        1024 * 1024 * 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (4 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 2 Gb - (8 Gb - 1 ) limits
    // - boundaries = size * 4
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 269
    //

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 2 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //////////////////////////////////////////
    // - variables: size & CacheType
    // - 4 Gb - (8 Gb - 1 ) limits
    // - boundaries = size + 1 page
    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ], 
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize(
        &aTestVariations[ nCrtVarIndex ],
        PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        2 * PAGE_SIZE,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        32 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        64 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );
    
    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        128 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        256 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        4 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmCached );

    nCrtVarIndex++;

    //////////////////////////////////////////

    //
    // nCrtVarIndex == 863
    //

    InitializeVariationBoundFourthTimeSize( 
        &aTestVariations[ nCrtVarIndex ], 
        16 * 1024 * 1024,
        (LONGLONG) 4 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024,
        (LONGLONG) 8 * (LONGLONG) 1024 * (LONGLONG) 1024 * (LONGLONG) 1024 - 1,
        0,
        MmNonCached );

    nCrtVarIndex++;

    //////////////////////////////////////////
    //////////////////////////////////////////
    //////////////////////////////////////////
// TEST TEST
}

#endif // #if !CONTMEM_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\funs.h ===
//
// Buggy function declarations
// Copyright (c) Microsoft Corporation, 1999.
//
// Header:  funs.h
// Author:  Silviu Calinoiu (SilviuC)
// Created: 8/14/1999 2:52pm
//

//
// PLEASE READ IF YOU MODIFY THIS FILE !
//
// This header represents the communication mechanism between
// the source code for the driver and the one for the user mode
// controller of the driver. If you have a new operation to add 
// to the driver you have to fulfill the following steps:
//
// (1) Update the `IOCTL' section.
// (2) Update the `Functions' section.
// (3) Update the `Control' section.
//

#ifndef _FUNS_H_INCLUDED_
#define _FUNS_H_INCLUDED_

typedef VOID (* BUGGY_FUNCTION) (PVOID);

typedef struct {

    ULONG Ioctl;
    LPCTSTR Message;
    LPCTSTR Command;
    BUGGY_FUNCTION Function;

} BUGGY_IOCTL_HANDLER_INFORMATION;

#ifndef FUNS_DEFINITION_MODULE
extern BUGGY_IOCTL_HANDLER_INFORMATION BuggyFuns [];
#else

VOID DoNothing (PVOID NotUsed) {}

//
// IOCTL section
//
// In order to add a new IOCTL just declare it at the end of the section incrementing by
// one the last TD_IOCTL declaration.
//

#define TD_IOCTL(n) CTL_CODE(FILE_DEVICE_UNKNOWN, (2048 + (n)), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define IOCTL_TD_NOTHING                                TD_IOCTL(0)
#define IOCTL_TD_BUGCHECK                               TD_IOCTL(1)
#define IOCTL_TD_POOL_STRESS                            TD_IOCTL(2)
#define IOCTL_TD_LOCK_SCENARIO                          TD_IOCTL(3)
#define IOCTL_BGCHK_PROCESS_HAS_LOCKED_PAGES            TD_IOCTL(4)
#define IOCTL_BGCHK_NO_MORE_SYSTEM_PTES                 TD_IOCTL(5)
#define IOCTL_BGCHK_BAD_POOL_HEADER                     TD_IOCTL(6)
#define IOCTL_BGCHK_DRIVER_CORRUPTED_SYSTEM_PTES        TD_IOCTL(7)
#define IOCTL_BGCHK_DRIVER_CORRUPTED_EXPOOL             TD_IOCTL(8)
#define IOCTL_BGCHK_DRIVER_CORRUPTED_MMPOOL             TD_IOCTL(9)
#define IOCTL_TD_IRQL_NOT_LESS_OR_EQUAL                 TD_IOCTL(10)
#define IOCTL_TD_PAGE_FAULT_BEYOND_END_OF_ALLOCATION    TD_IOCTL(11)
#define IOCTL_TD_DRIVER_VERIFIER_DETECTED_VIOLATION     TD_IOCTL(12)
#define IOCTL_TD_HANG_PROCESSOR                         TD_IOCTL(13)
#define IOCTL_TD_CORRUPT_SYSPTES                        TD_IOCTL(14)
#define IOCTL_TD_CONTIG_MEM_TEST                        TD_IOCTL(15)
#define IOCTL_TD_SECTION_MAP_TEST_PROCESS_SPACE         TD_IOCTL(16)
#define IOCTL_TD_SECTION_MAP_TEST_SYSTEM_SPACE          TD_IOCTL(17)
#define IOCTL_TD_COMMONBUFFER_STRESS                    TD_IOCTL(18)
#define IOCTL_TD_POOLFLAG_STRESS                        TD_IOCTL(19)
#define IOCTL_TD_ALLOCPCONTIG_STRESS                    TD_IOCTL(20)
#define IOCTL_TD_MMADDPMEM_STRESS                       TD_IOCTL(21)
#define IOCTL_TD_MMDELPMEM_STRESS                       TD_IOCTL(22)
#define IOCTL_TD_PMEM_SIMPLE_STRESS                     TD_IOCTL(23)
#define IOCTL_TEST_TRACEDB                              TD_IOCTL(24) 
#define IOCTL_TD_MMPROBELOCKFOREVER_STRESS              TD_IOCTL(25) 
#define IOCTL_TD_MMNAMETOADDR_STRESS                    TD_IOCTL(26) 
#define IOCTL_TD_MMECCBAD_STRESS                        TD_IOCTL(27) 
#define IOCTL_TD_MMMAPVSYSSPACE_LARGEST                 TD_IOCTL(28)
#define IOCTL_TD_MMMAPVSYSSPACE_TOTAL                   TD_IOCTL(29)
#define IOCTL_TD_MMMAPVSESSPACE_LARGEST                 TD_IOCTL(30)
#define IOCTL_TD_MMMAPVSESSPACE_TOTAL                   TD_IOCTL(31)
#define IOCTL_TD_SESSION_POOL_TEST                      TD_IOCTL(32)

#define IOCTL_TD_DEADLOCK_MECHANISM_POSITIVE_TEST       TD_IOCTL(33)
#define IOCTL_TD_DEADLOCK_MECHANISM_NEGATIVE_TEST       TD_IOCTL(34)
#define IOCTL_TD_DEADLOCK_STRESS_TEST                   TD_IOCTL(35)

#define IOCTL_TD_RESERVEDMAP_SET_SIZE                   TD_IOCTL(36)
#define IOCTL_TD_RESERVEDMAP_READ_OP                    TD_IOCTL(37)

#define IOCTL_TD_SYS_PAGED_POOL_MAX_SIZE                TD_IOCTL(38)
#define IOCTL_TD_SYS_PAGED_POOL_TOTAL_SIZE              TD_IOCTL(39)
#define IOCTL_TD_NONPAGED_POOL_MAX_SIZE					TD_IOCTL(40)
#define IOCTL_TD_NONPAGED_POOL_TOTAL_SIZE				TD_IOCTL(41)
#define IOCTL_TD_FREE_SYSTEM_PTES                       TD_IOCTL(42)

#define IOCTL_TD_NEWSTUFF                               TD_IOCTL(43)

//
// Functions section
//
// For a new operation declare the name of the function called
// when the new ioctl is dispatched to the driver. The declaration
// is needed for the user mode driver controller.
//

#ifdef NO_BUGGY_FUNCTIONS
#define BgChkForceCustomBugcheck                     DoNothing
#define StressAllocateContiguousMemory               DoNothing
#define StressAllocateCommonBuffer                   DoNothing
#define StressAddPhysicalMemory                      DoNothing
#define StressDeletePhysicalMemory                   DoNothing
#define StressPhysicalMemorySimple                   DoNothing
#define StressPoolFlag                               DoNothing
#define StressPoolTagTableExtension                  DoNothing
#define StressLockScenario                           DoNothing
#define BgChkProcessHasLockedPages                   DoNothing
#define BgChkNoMoreSystemPtes                        DoNothing
#define BgChkBadPoolHeader                           DoNothing
#define BgChkDriverCorruptedSystemPtes               DoNothing
#define BgChkDriverCorruptedExPool                   DoNothing
#define BgChkDriverCorruptedMmPool                   DoNothing
#define BgChkIrqlNotLessOrEqual                      DoNothing
#define BgChkPageFaultBeyondEndOfAllocation          DoNothing
#define BgChkDriverVerifierDetectedViolation         DoNothing
#define BgChkCorruptSystemPtes                       DoNothing
#define BgChkHangCurrentProcessor                    DoNothing
#define TdMmAllocateContiguousMemorySpecifyCacheTest DoNothing
#define TdSectionMapTestProcessSpace                 DoNothing
#define TdSectionMapTestSystemSpace                  DoNothing
#define TestTraceDatabase                            DoNothing
#define MmTestProbeLockForEverStress                 DoNothing
#define MmTestNameToAddressStress                    DoNothing
#define MmTestEccBadStress                           DoNothing
#define MmMapViewInSystemSpaceLargest                DoNothing
#define MmMapViewInSystemSpaceTotal                  DoNothing
#define MmMapViewInSessionSpaceLargest               DoNothing
#define MmMapViewInSessionSpaceTotal                 DoNothing
#define SessionPoolTest								 DoNothing
#define DeadlockPositiveTest                         DoNothing
#define DeadlockNegativeTest                         DoNothing
#define DeadlockStressTest                           DoNothing
#define TdReservedMappingSetSize                     DoNothing
#define TdReservedMappingDoRead						 DoNothing
#define TdSysPagedPoolMaxTest						 DoNothing
#define TdSysPagedPoolTotalTest						 DoNothing
#define TdNonPagedPoolMaxTest                        DoNothing
#define TdNonPagedPoolTotalTest                      DoNothing
#define TdFreeSystemPtesTest                         DoNothing

#define NewStuff                                     DoNothing
#endif // #ifdef NO_BUGGY_FUNCTIONS

//
// Control section
//
// For a new operation add a new structure at the end of
// BuggyFuns vector (but before the null termination structure).
// Each structure contains the following fields:
//
//     - IOCTL code
//     - short help text displayed when user mode controller
//       prints help information
//     - command line option for user mode controller
//     - Driver function called when IOCTL gets dispatched
//

BUGGY_IOCTL_HANDLER_INFORMATION BuggyFuns [] = {

    {IOCTL_TD_NOTHING, 
     TEXT("nothing"),
     TEXT ("/ioctlnothing"),
     DoNothing },

    {IOCTL_TD_BUGCHECK, 
     TEXT("custom bugcheck"),
     TEXT ("/ioctlbugcheck CODE PARAM1 PARAM2 PARAM3 PARAM4 (hex)"),
     BgChkForceCustomBugcheck },

    {IOCTL_TD_ALLOCPCONTIG_STRESS, 
     TEXT("allocate contiguous memory"), 
     TEXT ("/ioctlmmalloccontig"),
     StressAllocateContiguousMemory },

    {IOCTL_TD_COMMONBUFFER_STRESS, 
     TEXT("allocate common buffer"), 
     TEXT ("/ioctlcommonbuffer"),
     StressAllocateCommonBuffer },

    {IOCTL_TD_MMADDPMEM_STRESS, 
     TEXT("add physical memory"), 
     TEXT ("/ioctladdpmem"),
     StressAddPhysicalMemory },

    {IOCTL_TD_MMDELPMEM_STRESS, 
     TEXT("delete physical memory"), 
     TEXT ("/ioctldelpmem"),
     StressDeletePhysicalMemory },

    {IOCTL_TD_PMEM_SIMPLE_STRESS, 
     TEXT("physical memory simple stress"), 
     TEXT ("/ioctlpmemsimplestress"),
     StressPhysicalMemorySimple },

    {IOCTL_TD_POOLFLAG_STRESS, 
     TEXT("pool flag"), 
     TEXT ("/ioctlpoolflagstress"),
     StressPoolFlag },

    {IOCTL_TD_POOL_STRESS, 
     TEXT("pool tag table extension"), 
     TEXT ("/ioctlpooltagstress"),
     StressPoolTagTableExtension },

    {IOCTL_TD_LOCK_SCENARIO, 
     TEXT("lock scenario"), 
     TEXT ("/ioctllockscenario"),
     StressLockScenario },

    {IOCTL_BGCHK_PROCESS_HAS_LOCKED_PAGES, 
     TEXT("bgchk locked pages"), 
     TEXT ("/bgchkprocesshaslockedpages"),
     BgChkProcessHasLockedPages},

    {IOCTL_BGCHK_NO_MORE_SYSTEM_PTES, 
     TEXT("bgchk no more syptes"), 
     TEXT ("/bgchknomoresystemptes"),
     BgChkNoMoreSystemPtes},

    {IOCTL_BGCHK_BAD_POOL_HEADER, 
     TEXT("bgchk bad pool header"), 
     TEXT ("/bgchkbadpoolheader"),
     BgChkBadPoolHeader},

    {IOCTL_BGCHK_DRIVER_CORRUPTED_SYSTEM_PTES, 
     TEXT("bgchk drv corrupted sysptes"), 
     TEXT ("/bgchkdrivercorruptedsystemptes"),
     BgChkDriverCorruptedSystemPtes},

    {IOCTL_BGCHK_DRIVER_CORRUPTED_EXPOOL, 
     TEXT("bgchk drv corrupted expool"), 
     TEXT ("/bgchkdrivercorruptedexpool"),
     BgChkDriverCorruptedExPool},

    {IOCTL_BGCHK_DRIVER_CORRUPTED_MMPOOL, 
     TEXT("bgchk drv corrupted mmpool"), 
     TEXT ("/bgchkdrivercorruptedmmpool"),
     BgChkDriverCorruptedMmPool},

    {IOCTL_TD_IRQL_NOT_LESS_OR_EQUAL, 
     TEXT("bgchk irql not less or equal"), 
     TEXT ("/bgchkirqlnotlessorequal"),
     BgChkIrqlNotLessOrEqual},

    {IOCTL_TD_PAGE_FAULT_BEYOND_END_OF_ALLOCATION, 
     TEXT("bgchk pgfault beyond allocation"), 
     TEXT ("/bgchkpagefaultbeyondendofallocation"),
     BgChkPageFaultBeyondEndOfAllocation},

    {IOCTL_TD_DRIVER_VERIFIER_DETECTED_VIOLATION, 
     TEXT("bgchk drvvrf detected violation"), 
     TEXT ("/bgchkdriververifierdetectedviolation"),
     BgChkDriverVerifierDetectedViolation},

    {IOCTL_TD_CORRUPT_SYSPTES, 
     TEXT("corrupt system ptes"), 
     TEXT ("/corruptsysptes"),
     BgChkCorruptSystemPtes},

    {IOCTL_TD_HANG_PROCESSOR, 
     TEXT("hang processor"), 
     TEXT ("/hangprocessor"),
     BgChkHangCurrentProcessor},

    {IOCTL_TD_CONTIG_MEM_TEST, 
     TEXT("contiguous memory specify cache"), 
     TEXT ("/contigmemtest"),
     TdMmAllocateContiguousMemorySpecifyCacheTest},

    {IOCTL_TD_SECTION_MAP_TEST_PROCESS_SPACE, 
     TEXT("map test process space"), 
     TEXT ("/sectionmaptest"),
     TdSectionMapTestProcessSpace},

    {IOCTL_TD_SECTION_MAP_TEST_SYSTEM_SPACE, 
     TEXT("map test system space"), 
     TEXT ("/sectionmaptestsysspace"),
     TdSectionMapTestSystemSpace},

    {IOCTL_TEST_TRACEDB, 
     TEXT("test trace database"), 
     TEXT ("/tracedb"),
     TestTraceDatabase},

    {IOCTL_TD_MMPROBELOCKFOREVER_STRESS, 
     TEXT("MmProbeAndLockForEver stress"), 
     TEXT ("/ioctlprobelockforever"),
     MmTestProbeLockForEverStress},

    {IOCTL_TD_MMNAMETOADDR_STRESS, 
     TEXT("MmNameToAddress stress"), 
     TEXT ("/ioctlnametoaddr"),
     MmTestNameToAddressStress},

    {IOCTL_TD_MMECCBAD_STRESS, 
     TEXT("MmEccBad bad stress"), 
     TEXT ("/ioctleccbad"),
     MmTestEccBadStress},

    {IOCTL_TD_MMECCBAD_STRESS, 
     TEXT("MmEccBad good stress - not implemented!!!"), 
     TEXT ("/ioctleccgood"),
     DoNothing},

    {IOCTL_TD_MMMAPVSYSSPACE_LARGEST, 
     TEXT("Determine the max size that can be mapped using MmMapViewInSystemSpace"),
     TEXT ("/mapviewsyslargest"),
     MmMapViewInSystemSpaceLargest},

    {IOCTL_TD_MMMAPVSYSSPACE_TOTAL, 
     TEXT("Determine the total amount of memory that can be mapped using MmMapViewInSystemSpace"),
     TEXT ("/mapviewsystotal"),
     MmMapViewInSystemSpaceTotal},

    {IOCTL_TD_MMMAPVSESSPACE_LARGEST, 
     TEXT("Determine the max size that can be mapped using MmMapViewInSessionSpace"),
     TEXT ("/mapviewseslargest"),
     MmMapViewInSessionSpaceLargest},

    {IOCTL_TD_MMMAPVSESSPACE_TOTAL, 
     TEXT("Determine the total amount of memory that can be mapped using MmMapViewInSessionSpace"),
     TEXT ("/mapviewsestotal"),
     MmMapViewInSessionSpaceTotal},

    {IOCTL_TD_SESSION_POOL_TEST, 
     TEXT("Determine the total amount of pool that can be allocated with SESSION_POOL_MASK flag"),
     TEXT ("/sessionpooltest"),
     SessionPoolTest },


    {IOCTL_TD_DEADLOCK_MECHANISM_POSITIVE_TEST, 
     TEXT("Test the deadlock detection mechanism without actually causing deadlocks"),
     TEXT ("/deadlockpositive"),
     DeadlockPositiveTest },

    {IOCTL_TD_DEADLOCK_MECHANISM_NEGATIVE_TEST, 
     TEXT("Test the deadlock detection mechanism by causing deadlocks"),
     TEXT ("/deadlocknegative"),
     DeadlockNegativeTest },

    {IOCTL_TD_DEADLOCK_STRESS_TEST, 
     TEXT("Stress test for the deadlock detection mechanism"),
     TEXT ("/deadlockstress"),
     DeadlockStressTest },

    {IOCTL_TD_RESERVEDMAP_SET_SIZE, 
     TEXT("Set the size of the reserved mapping address (MmMapLockedPagesWithReservedMapping tests)"),
     TEXT ("/ReservedMapSetSize"),
     TdReservedMappingSetSize },

    {IOCTL_TD_RESERVEDMAP_READ_OP, 
     TEXT("Execute a \"read\" (MmMapLockedPagesWithReservedMapping tests)"),
     TEXT ("/ReservedMapRead"),
     TdReservedMappingDoRead },
 
    {IOCTL_TD_SYS_PAGED_POOL_MAX_SIZE, 
     TEXT("Determine the maximum size of a block of paged pool currently available"),
     TEXT ("/SysPagedPoolMax"),
     TdSysPagedPoolMaxTest },

    {IOCTL_TD_SYS_PAGED_POOL_TOTAL_SIZE, 
     TEXT("Determine the total size of the paged pool currently available (64 Kb - 32 bytes blocks)"),
     TEXT ("/SysPagedPoolTotal"),
     TdSysPagedPoolTotalTest },

    {IOCTL_TD_NONPAGED_POOL_MAX_SIZE, 
     TEXT("Determine the maximum size of a block of non-paged pool currently available"),
     TEXT ("/NonPagedPoolMax"),
     TdNonPagedPoolMaxTest },

    {IOCTL_TD_NONPAGED_POOL_TOTAL_SIZE, 
     TEXT("Determine the total size of the non-paged pool currently available (64 Kb - 32 bytes blocks)"),
     TEXT ("/NonPagedPoolTotal"),
     TdNonPagedPoolTotalTest },

    {IOCTL_TD_FREE_SYSTEM_PTES, 
     TEXT("Determine the total amount of memory that can be mapped using system PTEs (1 Mb chunks)"),
     TEXT ("/FreeSystemPtes"),
     TdFreeSystemPtesTest },

    {IOCTL_TD_NEWSTUFF, 
     TEXT("new stuff ioctl"), 
     TEXT ("/newstuff"),
     NewStuff},
    
    {0, NULL, NULL, NULL} // termination
};
    
#endif // #ifndef FUNS_DEFINITION_MODULE

#endif // #ifndef _FUNS_H_INCLUDED_

//
// End of header: funs.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\newstuff.h ===
#ifndef _NEWSTUFF_H_INCLUDED_
#define _NEWSTUFF_H_INCLUDED_

VOID NewStuff (
    PVOID NotUsed
    );

#endif // #ifndef _NEWSTUFF_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\mapview.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 2000.
//
// Module:  MapView.h
// Author:  Daniel Mihai (DMihai)
// Created: 4/6/2000
//
// This module contains tests for MmMapViewInSystemSpace & MmMapViewInSessionSpace.
//
// --- History ---
//
// 4/6/2000 (DMihai): initial version.
//

#ifndef _MAPVIEW_H_INCLUDED_
#define _MAPVIEW_H_INCLUDED_

VOID MmMapViewInSystemSpaceLargest (
    PVOID NotUsed
    );

VOID MmMapViewInSystemSpaceTotal (
    PVOID NotUsed
    );

VOID MmMapViewInSessionSpaceLargest (
    PVOID NotUsed
    );

VOID MmMapViewInSessionSpaceTotal (
    PVOID NotUsed
    );

VOID SessionPoolTest (
    PVOID NotUsed
    );

#endif // #ifndef _MAPVIEW_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\newstuff.c ===
#include <ntddk.h>

#include "active.h"
#include "newstuff.h"

#if !NEWSTUFF_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID NewStuff (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: newstuff module is disabled \n");
}

#else

//
// Real implementation if the module is active
//

VOID NewStuff (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: newstuff module is enabled \n");
}

#endif // #if !NEWSTUFF_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\mmtests.h ===
#ifndef _MMTESTS_H_INCLUDED_
#define _MMTESTS_H_INCLUDED_

VOID MmTestProbeLockForEverStress (
    IN PVOID IrpAddress
    );

VOID MmTestNameToAddressStress (
    IN PVOID IrpAddress
    );

VOID MmTestEccBadStress (
    IN PVOID IrpAddress
    );

VOID
TdSysPagedPoolMaxTest(
    IN PVOID IrpAddress
    );

VOID
TdSysPagedPoolTotalTest(
    IN PVOID IrpAddress
    );

VOID
TdNonPagedPoolMaxTest(
    IN PVOID IrpAddress
    );

VOID
TdNonPagedPoolTotalTest(
    IN PVOID IrpAddress
    );

VOID
TdFreeSystemPtesTest(
    IN PVOID IrpAddress
    );

VOID
StressPoolFlag (
    PVOID NotUsed
    );

VOID 
StressPoolTagTableExtension (
    PVOID NotUsed
    );

#endif // #ifndef _MMTESTS_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\mapview.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 2000.
//
// Module:  MapView.c
// Author:  Daniel Mihai (DMihai)
// Created: 4/6/2000
//
// This module contains tests for MmMapViewInSystemSpace & MmMapViewInSessionSpace.
// Note that SystemViewSize & SessionViewSize are configurable using the registry.
//
// SessionPoolTest is exercising the paged pool allocated with SESSION_POOL_MASK.
// The size of this pool can be also configured using the SsessionViewSize registry
// value.
//
// --- History ---
//
// 4/6/2000 (DMihai): initial version.
//

#include <ntddk.h>

#include "active.h"
#include "MapView.h"
#include "tdriver.h"

#if !MAPVIEW_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID MmMapViewInSystemSpaceLargest (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID MmMapViewInSystemSpaceTotal (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID MmMapViewInSessionSpaceLargest (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID MmMapViewInSessionSpaceTotal (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

VOID SessionPoolTest (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: MapView module is disabled from active.h\n");
}

#else

const LARGE_INTEGER BuggyFiveSeconds = {(ULONG)(-5 * 1000 * 1000 * 10), -1};


//
// Real implementation if the module is active
//

#ifndef SESSION_POOL_MASK
#define SESSION_POOL_MASK 32
#endif //#ifndef SESSION_POOL_MASK

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000    
#endif  //#ifndef SEC_COMMIT

#ifndef ZwDeleteFile

NTSYSCALLAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    ); //#ifndef ZwDeleteFile

#endif


#ifndef MmCreateSection


NTKERNELAPI
NTSTATUS
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT File OPTIONAL
    );

NTKERNELAPI
NTSTATUS
MmMapViewInSystemSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSystemSpace (
    IN PVOID MappedBase
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
MmMapViewInSessionSpace (
    IN PVOID Section,
    OUT PVOID *MappedBase,
    IN OUT PSIZE_T ViewSize
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewInSessionSpace (
    IN PVOID MappedBase
    );

#endif //#ifndef MmCreateSection

#define BUGGY_TEMPORARY_FILE1 L"\\SystemRoot\\Buggy1.tmp"
#define BUGGY_TEMPORARY_FILE2 L"\\SystemRoot\\Buggy2.tmp"
#define BUGGY_TEMPORARY_FILE3 L"\\SystemRoot\\Buggy3.tmp"
#define BUGGY_TEMPORARY_FILE4 L"\\SystemRoot\\Buggy4.tmp"

#define BUGGY_MAX_SECTIONS_TO_MAP   ( 8 * 1024 )

//
// global array for mapped sections
//

/////////////////////////////////////////////////////////////////////////////
//
// verify a mapping
//

VOID VerifyMapping( PVOID pBase, SIZE_T uSize )
{
    SIZE_T *puCrtPage;
    SIZE_T uCrtPageIndex;
    SIZE_T uPages;

    if( uSize > 100 * 1024 * 1024 )
    {
        DbgPrint ( "Buggy: VerifyMapping: don't try to touch all the %p size to avoid deadlock\n",
            uSize );

        return;
    }

    /*
    DbgPrint ( "\nBuggy: Verifying mapping at address %p, size %p...\n",
        pBase,
        (PVOID) uSize );
    */

    uPages = uSize / PAGE_SIZE;

    puCrtPage = (SIZE_T *)pBase;

    for( uCrtPageIndex = 0; uCrtPageIndex < uPages; uCrtPageIndex++ )
    {
        *puCrtPage = uCrtPageIndex;

        puCrtPage = (SIZE_T *) ( ( (CHAR*) puCrtPage ) + PAGE_SIZE );
    }

    while( uCrtPageIndex > 0 )
    {
        uCrtPageIndex --;
        puCrtPage = (SIZE_T *) ( ( (CHAR*) puCrtPage ) - PAGE_SIZE );

        if( *puCrtPage != uCrtPageIndex )
        {
            DbgPrint ( "\nBuggy: Wrong mapping at address %p\n",
                puCrtPage );

            DbgBreakPoint();
        }
    }

    //DbgPrint ( "done\n" );
}

/////////////////////////////////////////////////////////////////////////////

VOID MmMapViewInSystemSpaceLargest (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    SIZE_T SizeToGrow;
    PVOID pMappedBase = NULL;
    PVOID pSection = NULL;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Create BUGGY_TEMPORARY_FILE1
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE1
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE ,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

  /*
    Status = ZwCreateFile(
            &hFile,
            GENERIC_READ | GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
                FILE_NO_INTERMEDIATE_BUFFERING |
                FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
        */

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );

        goto cleanup;
    }
    else
    {
        DbgPrint ( "Buggy: created file, handle %p\n",
            hFile ); 
    }

    //
    // Create a section for the temp file
    //

#ifdef _WIN64
    MaxSectionSize.QuadPart = (LONGLONG)0x40000000 * PAGE_SIZE;
#else
    MaxSectionSize.QuadPart = 0xFFFFFFFF;
#endif //#ifdef _WIN64
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL  )
            {
                MaxSectionSize.QuadPart /= 2;
                
                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
    
                goto cleanup;
            }
        }
        else
        {
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

	SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    while( SizeToMap > PAGE_SIZE )
    {
        Status = MmMapViewInSystemSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSystemSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );

            SizeToMap /= 2;
        }
        else
        {
            DbgPrint ( "\n\nFirst result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSystemSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );

            break;
        }
    }

    //
    // try to grow the size
    //

    while( pMappedBase != NULL )
    {
        //
        // unmap the old one
        //

        Status = MmUnmapViewInSystemSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSystemSpace failed, status %X\n",
                Status );

            DbgBreakPoint();

            break;
        }

        pMappedBase = NULL;

        //
        // grow the size
        //

        SizeToGrow = SizeToMap / 10;

        if( SizeToGrow < 10 * PAGE_SIZE )
        {
            //
            // don't bother
            //

            break;
        }

        SizeToMap += SizeToGrow;

        //
        // try to use this bigger size
        //

        Status = MmMapViewInSystemSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            /*
            DbgPrint ( "Buggy: MmMapViewInSystemSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );
            */

            //
            // can't grow the size anymore
            //

            break;
        }
        else
        {
            DbgPrint ( "\n\nBetter result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSystemSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );
        }
    }

    //
    // clean-up
    //

cleanup:

    if( pMappedBase != NULL )
    {
        Status = MmUnmapViewInSystemSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSystemSpace failed, status %X\n",
                Status );

            DbgBreakPoint();
        }
    }

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            // DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }
}

///////////////////////////////////////////////////////////////////////////

PVOID *MappedSections;

VOID MmMapViewInSystemSpaceTotal (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    PVOID pSection = NULL;
    SIZE_T CrtMap;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    MappedSections = ExAllocatePoolWithTag(
        NonPagedPool,
        BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ),
        TD_POOL_TAG );

    if( MappedSections == NULL )
    {
        DbgPrint ("Buggy: ExAllocatePoolWithTag failed - bail\n" );
        
        return;
    }

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    //
    // Create BUGGY_TEMPORARY_FILE2
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE2
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

    if( ! NT_SUCCESS( Status ) )
    {
        /*
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );
        */

        goto cleanup;
    }
    else
    {
        //DbgPrint ( "Buggy: created file\n" ); 
    }

    //
    // Create a section for the temp file
    //

    MaxSectionSize.QuadPart = 1024 * 1024;
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL )
            {
                MaxSectionSize.QuadPart /= 2;

                /*
                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
                */
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
        
                goto cleanup;
            }
        }
        else
        {
            /*
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 
            */

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    //
    // get a pointer to the section
    //

    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

    SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        Status = MmMapViewInSystemSpace(
            pSection,
            &MappedSections[ CrtMap ],
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            /*
            DbgPrint ( "Buggy: MmMapViewInSystemSpace failed for size %p, status %X, chunk %p\n",
                SizeToMap,
                Status
                );
            */

            break;
        }
        else
        {
            if( CrtMap <= 100 )
            {
                VerifyMapping( MappedSections[ CrtMap ], SizeToMap );
            }
        }
    }

    DbgPrint ( "\n\nBuggy: Result of the test:\n\n" );

    DbgPrint ( "Buggy: mapped %u sections with size %p, total %p\n",
        CrtMap,
        SizeToMap,
        SizeToMap * (SIZE_T)CrtMap );

    //DbgPrint ( "\n\n" );

    //
    // clean-up
    //

cleanup:

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        if( MappedSections[ CrtMap ] == NULL )
        {
            break;
        }

        Status = MmUnmapViewInSystemSpace( 
            MappedSections[ CrtMap ] );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSystemSpace failed for %p, status %X\n",
                MappedSections[ CrtMap ],
                Status );

            DbgBreakPoint();
        }
    }

    DbgPrint ( "Buggy: unmapped %p sections\n",
        CrtMap );

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );

        DbgPrint ( "Buggy: dereferenced section at %p\n",
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        DbgPrint ( "Buggy: calling ZwDeleteFile\n" );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }

    ExFreePool( MappedSections );
}

/////////////////////////////////////////////////////////////////////////////

VOID MmMapViewInSessionSpaceLargest (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    SIZE_T SizeToGrow;
    PVOID pMappedBase = NULL;
    PVOID pSection = NULL;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    // Create BUGGY_TEMPORARY_FILE3
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE3
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

    if( ! NT_SUCCESS( Status ) )
    {
        /*
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );
        */

        goto cleanup;
    }
    else
    {
        //DbgPrint ( "Buggy: created file\n" ); 
    }

    //
    // Create a section for the temp file
    //

#ifdef _WIN64
    MaxSectionSize.QuadPart = (LONGLONG)0x40000000 * PAGE_SIZE;
#else
    MaxSectionSize.QuadPart = 0xFFFFFFFF;
#endif //#ifdef _WIN64
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL )
            {
                MaxSectionSize.QuadPart /= 2;

                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
        
                goto cleanup;
            }
        }
        else
        {
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

    SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    while( SizeToMap > PAGE_SIZE )
    {
        Status = MmMapViewInSessionSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSessionSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );

            SizeToMap /= 2;
        }
        else
        {
            DbgPrint ( "\n\nFirst result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSessionSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );

            break;
        }
    }

    //
    // try to grow the size
    //

    while( pMappedBase != NULL )
    {
        //
        // unmap the old one
        //

        Status = MmUnmapViewInSessionSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSessionSpace failed, status %X\n",
                Status );

            DbgBreakPoint();

            break;
        }

        pMappedBase = NULL;

        //
        // grow the size
        //

        SizeToGrow = SizeToMap / 10;

        if( SizeToGrow < 10 * PAGE_SIZE )
        {
            //
            // don't bother
            //

            break;
        }

        SizeToMap += SizeToGrow;

        //
        // try to use this bigger size
        //

        Status = MmMapViewInSessionSpace(
            pSection,
            &pMappedBase,
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmMapViewInSessionSpace failed for size %p, status %X\n",
                SizeToMap,
                Status );

            //
            // can't grow the size anymore
            //

            break;
        }
        else
        {
            DbgPrint ( "\n\nBetter result of the test:\n\n" );
            
            DbgPrint ( "Buggy: MmMapViewInSessionSpace succeeded for size %p, mapped base %p\n",
                SizeToMap,
                pMappedBase );

            //DbgPrint ( "\n\n" );

            VerifyMapping( pMappedBase, SizeToMap );
        }
    }

    //
    // clean-up
    //

cleanup:

    if( pMappedBase != NULL )
    {
        Status = MmUnmapViewInSessionSpace( 
            pMappedBase );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSessionSpace failed, status %X\n",
                Status );

            DbgBreakPoint();
        }
    }

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            //DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }
}

///////////////////////////////////////////////////////////////////////////

VOID MmMapViewInSessionSpaceTotal (
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    HANDLE hFile = NULL;
    SIZE_T SizeToMap;
    PVOID pSection = NULL;
    SIZE_T CrtMap;
    LARGE_INTEGER MaxSectionSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID *MappedSections;

    MappedSections = ExAllocatePoolWithTag(
        NonPagedPool,
        BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ),
        TD_POOL_TAG );

    if( MappedSections == NULL )
    {
        DbgPrint ("Buggy: ExAllocatePoolWithTag failed - bail\n" );
        
        return;
    }

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );


    //
    // Create BUGGY_TEMPORARY_FILE3
    //

    RtlInitUnicodeString(
        &FileName,
        BUGGY_TEMPORARY_FILE3
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        0,
        FILE_OVERWRITE_IF,
        FILE_NON_DIRECTORY_FILE,
        NULL,
        0 );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint ("Buggy: ZwCreateFile failed - status %X\n",
            Status );

        goto cleanup;
    }
    else
    {
        //DbgPrint ( "Buggy: created file\n" ); 
    }

    //
    // Create a section for the temp file
    //

    MaxSectionSize.QuadPart = 1024 * 1024;
    
    do
    {
        Status = MmCreateSection(
            &pSection,
            STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
            NULL,
            &MaxSectionSize,
            PAGE_READWRITE,
            SEC_COMMIT,
            hFile,
            NULL );

        if( ! NT_SUCCESS( Status ) )
        {
            if( Status == STATUS_DISK_FULL )
            {
                MaxSectionSize.QuadPart /= 2;

                /*
                DbgPrint ("Buggy: MmCreateSection returned STATUS_DISK_FULL, re-trying with max section size = %I64X\n",
                    MaxSectionSize.QuadPart );
                */
            }
            else
            {
                DbgPrint ("Buggy: MmCreateSection failed - status %X\n",
                    Status );
        
                goto cleanup;
            }
        }
        else
        {
            /*
            DbgPrint ( "Buggy: created section with max size %I64X\n",
                MaxSectionSize.QuadPart ); 
            */

            break;
        }

    } while( MaxSectionSize.QuadPart > PAGE_SIZE );


    DbgPrint ( "Buggy: Using section at %p\n",
        pSection );

    //
    // try to map the max size section
    //

    SizeToMap = (SIZE_T) MaxSectionSize.QuadPart;

    RtlZeroMemory( MappedSections, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        Status = MmMapViewInSessionSpace(
            pSection,
            &MappedSections[ CrtMap ],
            &SizeToMap );
    
        if( ! NT_SUCCESS( Status ) )
        {
            /*
            DbgPrint ( "Buggy: MmMapViewInSessionSpace failed for size %p, status %X, chunk %p\n",
                SizeToMap,
                Status
                );
            */

            break;
        }
        else
        {
            if( CrtMap <= 100 )
            {
                VerifyMapping( MappedSections[ CrtMap ], SizeToMap );
            }
        }
    }

    DbgPrint ( "\n\nBuggy: Result of the test:\n\n" );

    DbgPrint ( "Buggy: mapped %u sections with size %p, total %p\n",
        CrtMap,
        SizeToMap,
        SizeToMap * (SIZE_T)CrtMap );

    //DbgPrint ( "\n\n" );

    //
    // clean-up
    //

cleanup:

    for( CrtMap = 0; CrtMap < BUGGY_MAX_SECTIONS_TO_MAP; CrtMap++ )
    {
        if( MappedSections[ CrtMap ] == NULL )
        {
            break;
        }

        Status = MmUnmapViewInSessionSpace( 
            MappedSections[ CrtMap ] );

        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ( "Buggy: MmUnmapViewInSessionSpace failed for %p, status %X\n",
                MappedSections[ CrtMap ],
                Status );

            DbgBreakPoint();
        }
    }

    if( pSection != NULL )
    {
        ObDereferenceObject( 
            pSection );
    }

    if( hFile != NULL )
    {
        ZwClose( hFile );

        Status = ZwDeleteFile(
            &ObjectAttributes );
    
        if( ! NT_SUCCESS( Status ) )
        {
            DbgPrint ("Buggy: ZwDeleteFile failed - status %X\n",
                Status );
        }
        else
        {
            //DbgPrint ("Buggy: temporary file deleted\n" );
        }
    }

    ExFreePool( MappedSections );
}

///////////////////////////////////////////////////////////////////////////

VOID SessionPoolTest (
    PVOID NotUsed
    )
{
    PVOID *SessionPoolChunks;
    ULONG uCrtPoolChunk;

    SessionPoolChunks = ExAllocatePoolWithTag(
        NonPagedPool,
        BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ),
        TD_POOL_TAG );

    if( SessionPoolChunks == NULL )
    {
        DbgPrint ("Buggy: ExAllocatePoolWithTag failed - bail\n" );
        
        return;
    }

    RtlZeroMemory( SessionPoolChunks, BUGGY_MAX_SECTIONS_TO_MAP * sizeof( PVOID ) );

    for( uCrtPoolChunk = 0; uCrtPoolChunk < BUGGY_MAX_SECTIONS_TO_MAP; uCrtPoolChunk++ )
    {
        SessionPoolChunks[ uCrtPoolChunk ] = ExAllocatePoolWithTag(
            PagedPool | SESSION_POOL_MASK,
            1024 * 1024,
            TD_POOL_TAG );

        if( SessionPoolChunks[ uCrtPoolChunk ] == NULL )
        {
            DbgPrint ("\n\nBuggy: Result of the test allocated %u chunks with size 1 Mb in the session pool\n\n",
                uCrtPoolChunk );
            break;
        }
    }

    DbgPrint ( "Buggy: Touching all these pool chuncks...\n" );

    while( uCrtPoolChunk > 0 )
    {
        uCrtPoolChunk--;

        if( uCrtPoolChunk <= 100 )
        {
            VerifyMapping( SessionPoolChunks[ uCrtPoolChunk ], 1024 * 1024 );
        }

        ExFreePool( SessionPoolChunks[ uCrtPoolChunk ] );
    }

    DbgPrint ( "Done\n" );

    ExFreePool( SessionPoolChunks );
}

#endif // #if !MAPVIEW_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\physmem.h ===
#ifndef _PHYSMEM_H_INCLUDED_
#define _PHYSMEM_H_INCLUDED_

VOID
StressAllocateContiguousMemory (
    PVOID NotUsed
    );

VOID
StressAllocateCommonBuffer (
    PVOID NotUsed
    );

VOID 
EditPhysicalMemoryParameters (
    );

VOID
StressAddPhysicalMemory (
    PVOID NotUsed
    );

VOID
StressDeletePhysicalMemory (
    PVOID NotUsed
    );

VOID
StressLockScenario (
    PVOID NotUsed
    );

VOID
StressPhysicalMemorySimple (
    PVOID NotUsed
    );

extern LARGE_INTEGER BuggyOneSecond;

#endif // #ifndef _PHYSMEM_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\physmem.c ===
//
// Buggy.sys
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  physmem.c
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 2:39pm
//
// This module contains stress functions for physical memory
// manipulation routines and also some pool allocaiton routines.
//
// --- History ---
//
// 08/14/99 (SilviuC): initial version (integrating code got from LandyW).
//

#include <ntddk.h>

#include "active.h"
#include "physmem.h"

#if !PHYSMEM_ACTIVE

//
// Dummy implementation if the module is inactive
//

LARGE_INTEGER BuggyOneSecond = {(ULONG)(-10 * 1000 * 1000 * 1), -1};

VOID PhysmemDisabled (VOID)
{
    DbgPrint ("Buggy: physmem module is disabled (check \\driver\\active.h header) \n");
}

VOID
StressAllocateContiguousMemory (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressAllocateCommonBuffer (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressAddPhysicalMemory (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressDeletePhysicalMemory (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressLockScenario (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

VOID
StressPhysicalMemorySimple (
    PVOID NotUsed
    )
{
    PhysmemDisabled ();
}

#else

//
// Real implementation if the module is active
//


//////////////////////////

#define MAX_BUFFER_SIZE     (2 * 1024 * 1024)

// #define BUFFER_SIZE         (32 * 1024)

// ULONG uBufferSize = (64 * 1024);
ULONG uBufferSize = (4 * 1024);

int zlw = 3;

LARGE_INTEGER BuggyTenSeconds = {(ULONG)(-10 * 1000 * 1000 * 10), -1};
LARGE_INTEGER BuggyOneSecond = {(ULONG)(-10 * 1000 * 1000 * 1), -1};




VOID
StressAllocateContiguousMemory (
    PVOID NotUsed
    )
/*++

Routine Description:

Arguments:

Return Value:

Environment:

--*/
{
    PHYSICAL_ADDRESS LogicalAddress;
    PVOID VirtualAddress;
    ULONG j;
    ULONG i;
    ULONG k;
    PULONG_PTR p;
    PVOID MyVirtualAddress[16];
    PHYSICAL_ADDRESS MyLogicalAddress[16];
    ULONG MySize[16];
    PHYSICAL_ADDRESS LowestAcceptableAddress;
    PHYSICAL_ADDRESS HighestAcceptableAddress;
    PHYSICAL_ADDRESS BoundaryAddressMultiple;
    MEMORY_CACHING_TYPE CacheType;

    DbgPrint ("Buggy: MmAllocateContiguousMemorySpecifyCache stress ioctl \n");

    //
    // allocate the buffer
    //

    uBufferSize = (64 * 1024);

    LowestAcceptableAddress.QuadPart = 0;
    HighestAcceptableAddress.QuadPart = 0x100000;
    BoundaryAddressMultiple.QuadPart = 0;
    LogicalAddress.QuadPart = 0;

    for (k = 0; k <= 12; k += 1) {

        if (k < 4) {
            LowestAcceptableAddress.QuadPart = 0;
            HighestAcceptableAddress.QuadPart = 0x1000000;
            BoundaryAddressMultiple.QuadPart = 0x10000;
        }
        else if (k < 4) {
            LowestAcceptableAddress.QuadPart = 0x1000000;
            HighestAcceptableAddress.QuadPart = 0x2000000;
            BoundaryAddressMultiple.QuadPart = 0;
        }
        else {
            LowestAcceptableAddress.QuadPart = 0x1800000;
            HighestAcceptableAddress.QuadPart = 0x4000000;
            BoundaryAddressMultiple.QuadPart = 0x30000;
        }

        for (CacheType = MmCached; CacheType <= MmWriteCombined; CacheType += 1) {

            for (i = 0; i < 16; i += 1) {

                DbgPrint( "buffer size = %08X\n", uBufferSize );
                if (uBufferSize == 0) {
                    MyVirtualAddress[i] = NULL;
                    continue;
                }

                VirtualAddress = MmAllocateContiguousMemorySpecifyCache (
                    uBufferSize,
                    LowestAcceptableAddress,
                    HighestAcceptableAddress,
                    BoundaryAddressMultiple,
                    CacheType);

                if (VirtualAddress == NULL) {
                    DbgPrint( "buggy: MmAllocateContiguousMemSpecifyCache( %08X ) failed\n",
                        (ULONG) uBufferSize );

                    // Status = STATUS_DRIVER_INTERNAL_ERROR;
                    MyVirtualAddress[i] = NULL;
                }
                else {

                    DbgPrint( "buggy: MmAllocateContiguousMemSpecifyCache( %p %08X ) - success\n",
                        VirtualAddress, (ULONG) uBufferSize);

                    MyVirtualAddress[i] = VirtualAddress;
                    MyLogicalAddress[i] = LogicalAddress;
                    MySize[i] = uBufferSize;

                    p = VirtualAddress;

                    for (j = 0; j < uBufferSize / sizeof(ULONG_PTR); j += 1) {
                        *p = ((ULONG_PTR)VirtualAddress + j);
                        p += 1;
                    }
                }
                uBufferSize -= PAGE_SIZE;
            }

            for (i = 0; i < 16; i += 1) {
                if (MyVirtualAddress[i]) {
                    DbgPrint( "buggy: MmFreeContiguousMemorySpecifyCache( %x %08X )\n",
                        MyVirtualAddress[i], (ULONG) MySize[i]);

                    MmFreeContiguousMemorySpecifyCache (MyVirtualAddress[i],
                        MySize[i],
                        CacheType);
                }
            }
        }
    }
    DbgPrint ("Buggy: MmAllocateContiguousMemSpecifyCache test finished\n");
}



VOID
StressAllocateCommonBuffer (
    PVOID NotUsed
    )
/*++

Routine Description:

Arguments:

Return Value:

Environment:

--*/
{
    DEVICE_DESCRIPTION DeviceDescription;      // DMA adapter object description
    PADAPTER_OBJECT pAdapterObject;            // DMA adapter object 
    ULONG NumberOfMapRegisters;
    PHYSICAL_ADDRESS LogicalAddress;
    PVOID VirtualAddress;
    ULONG j;
    ULONG i;
    PULONG_PTR p;
    PVOID MyVirtualAddress[16];
    PHYSICAL_ADDRESS MyLogicalAddress[16];
    ULONG MySize[16];

    DbgPrint ("Buggy: HalAllocateCommonBuffer stress ioctl \n");

    //
    // Zero the device description structure.
    //

    RtlZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));

    //
    // Get the adapter object for this card.
    //

    DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    DeviceDescription.DmaChannel = 0;
    DeviceDescription.InterfaceType = Internal;
    DeviceDescription.DmaWidth = Width8Bits;
    DeviceDescription.DmaSpeed = Compatible;
    DeviceDescription.MaximumLength = MAX_BUFFER_SIZE;
    DeviceDescription.BusNumber = 0;

    pAdapterObject = HalGetAdapter (&DeviceDescription,
        &NumberOfMapRegisters);

    if ( pAdapterObject == NULL ) {
        DbgPrint( "buggy: HalGetAdapter - failed\n" );
        // return STATUS_DRIVER_INTERNAL_ERROR;
        return;
    }

    DbgPrint( "buggy: HalGetAdapter - success\n" );

    //
    // allocate the buffer
    //

    uBufferSize = (64 * 1024);

    for (i = 0; i < 16; i += 1) {

        DbgPrint( "buffer size = %08X\n", uBufferSize );

        VirtualAddress = HalAllocateCommonBuffer (pAdapterObject,
            uBufferSize,
            &LogicalAddress,
            FALSE );

        if (VirtualAddress == NULL) {
            DbgPrint( "buggy: HalAllocateCommonBuffer( %08X ) failed\n",
                (ULONG) uBufferSize );

            // Status = STATUS_DRIVER_INTERNAL_ERROR;
            MyVirtualAddress[i] = NULL;
        }
        else {

            DbgPrint( "buggy: HalAllocateCommonBuffer( %p %08X ) - success\n",
                VirtualAddress, (ULONG) uBufferSize);

            MyVirtualAddress[i] = VirtualAddress;
            MyLogicalAddress[i] = LogicalAddress;
            MySize[i] = uBufferSize;

            p = VirtualAddress;

            for (j = 0; j < uBufferSize / sizeof(ULONG_PTR); j += 1) {
                *p = ((ULONG_PTR)VirtualAddress + j);
                p += 1;
            }
        }
        uBufferSize -= PAGE_SIZE;
    }

    for (i = 0; i < 16; i += 1) {
        if (MyVirtualAddress[i]) {
            DbgPrint( "buggy: HalFreeCommonBuffer( %x %08X )\n",
                MyVirtualAddress[i], (ULONG) MySize[i]);
            HalFreeCommonBuffer(
                pAdapterObject,
                MySize[i],
                MyLogicalAddress[i],
                MyVirtualAddress[i],
                FALSE );
        }
    }
    
    DbgPrint ("Buggy: HalAllocateCommonBuffer test finished\n");
    // LWFIX: Halfreeadapter needed ?
}



LOGICAL StopToEdit = TRUE;
PFN_NUMBER TestBasePage;
PFN_NUMBER TestPageCount; 

VOID 
EditPhysicalMemoryParameters (
    )
/*++

Routine Description:

    This function is called from StressAdd/DeletePhysicalMemory
    to allow user to set the parameters for stress (what region should
    be used for add/remove ?).

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    DbgPrint ("`dd nt!mmphysicalmemoryblock l1' should give the address of memory descriptor\n");
    DbgPrint ("`dd ADDRESS' (first dword displayed by previous command) gives description\n");
    DbgPrint ("The structure of the memory descriptor is presented below: \n");
    DbgPrint ("(4) NoOfRuns                                               \n");
    DbgPrint ("(4) NoOfPages                                              \n");
    DbgPrint ("(4) Run[0]: BasePage                                       \n");
    DbgPrint ("(4) Run[0]: PageCount                                      \n");
    DbgPrint ("(4) Run[1]: ...                                            \n");
    DbgPrint ("(4) ...                                                    \n");
    DbgPrint ("                                                           \n");
    DbgPrint ("When you decide on values you should edit the following:   \n");
    DbgPrint ("buggy!StopToEdit       <- 0                                \n");
    DbgPrint ("buggy!TestBasePage     <- decided value                    \n");
    DbgPrint ("buggy!TestPageCount    <- decided value                    \n");
    DbgPrint ("                                                           \n");

    DbgBreakPoint ();
}


VOID
StressAddPhysicalMemory (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function regresses the MmAddPhysicalMemory kernel API.
    It does not really stress it but rather iterate through some
    possible combinations.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    NTSTATUS Status;
    ULONG i;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    DbgPrint ("Buggy: add physical memory stress ioctl \n");

    //
    // (SilviuC): We need an automatic way to figure out memory runs.
    //

    if (StopToEdit) {
        EditPhysicalMemoryParameters ();
    }

    StartAddress.QuadPart =  (LONGLONG)TestBasePage * PAGE_SIZE;
    NumberOfBytes.QuadPart = (LONGLONG)TestPageCount * PAGE_SIZE;

    i = 0;
    do {

        i += 1;
        DbgPrint ("buggy: MmAddPhysicalMemory0 %x %x %x %x\n",
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        Status = MmAddPhysicalMemory (
            &StartAddress,
            &NumberOfBytes);

        DbgPrint ("buggy: MmAddPhysicalMemory %x %x %x %x %x\n",
            Status,
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        if ((i % 8) == 0) {
            KeDelayExecutionThread (KernelMode, FALSE, &BuggyTenSeconds);
        }

        StartAddress.QuadPart -= NumberOfBytes.QuadPart;
    } while (StartAddress.QuadPart > 0);
    
    DbgPrint ("Buggy: MmAddPhysicalMemory test finished\n");
}



VOID
StressDeletePhysicalMemory (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function regresses the MmRemovePhysicalMemory kernel API.
    It does not really stress the function but rather iterate
    throughout the physical memory and attempt to remove chunks of it.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    NTSTATUS Status;
    ULONG i;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    //
    // SilviuC: we need an automatic way to figure out memory runs.
    //

    if (StopToEdit) {
        EditPhysicalMemoryParameters ();
    }

    StartAddress.QuadPart =  (LONGLONG)TestBasePage * PAGE_SIZE;
    NumberOfBytes.QuadPart = (LONGLONG)TestPageCount * PAGE_SIZE;


    for (i = 0; i < (0xf0000000 / NumberOfBytes.LowPart); i += 1) {

        DbgPrint ("buggy: MmRemovePhysicalMemory0 %x %x %x %x\n",
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        Status = MmRemovePhysicalMemory (
            &StartAddress,
            &NumberOfBytes);

        DbgPrint ("buggy: MmRemovePhysicalMemory %x %x %x %x %x\n",
            Status,
            StartAddress.HighPart,
            StartAddress.LowPart,
            NumberOfBytes.HighPart,
            NumberOfBytes.LowPart);

        StartAddress.QuadPart += NumberOfBytes.QuadPart;

        if ((i % 8) == 0) {
            KeDelayExecutionThread (KernelMode, FALSE, &BuggyTenSeconds);
        }
    }
    
    DbgPrint ("Buggy: MmRemovePhysicalMemory test finished\n");
}


//
// Global:
//
//     BigData
//
// Description:
//
//     Dummy pageable array needed to test lock/unlock scenarios.
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma data_seg("BDAT")
ULONG BigData [0x10000];
#pragma data_seg()
#endif // #ifdef ALLOC_PRAGMA

VOID
StressLockScenario (
    PVOID NotUsed
    )
/*++

Routine Description:

Arguments:

Return Value:

Environment:

--*/
{
    ULONG I;
    PVOID Handle;

#if 0
    for (I = 0; I < 16; I++) {

        Handle = MmLockPagableDataSection (BigData);
        DbgPrint ("Buggy: lock handle %p \n", Handle);
        MmUnlockPagableImageSection (Handle);
    }
#else
    for (I = 0; I < 16; I++) {

        MmPageEntireDriver (DriverEntry);
        MmResetDriverPaging (BigData);
    }
#endif
}



VOID
StressPhysicalMemorySimple (
    PVOID NotUsed
    )
/*++

Routine Description:

    This routine exercises add/remove physical memory functions
    using a simple remove scenario.
    
    Note. This function contributed by LandyW.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
#if 0
    ULONG i;
    PPHYSICAL_MEMORY_RANGE Ranges;
    PPHYSICAL_MEMORY_RANGE p;

    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    PHYSICAL_ADDRESS InputAddress;
    LARGE_INTEGER InputBytes;

    Ranges = MmGetPhysicalMemoryRanges ();

    if (Ranges == NULL) {
        DbgPrint ("Buggy: MmRemovePhysicalMemory cannot get ranges\n");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    p = Ranges;
    while (p->BaseAddress.QuadPart != 0 && p->NumberOfBytes.QuadPart != 0) {

        StartAddress.QuadPart = p->BaseAddress.QuadPart;
        NumberOfBytes.QuadPart = p->NumberOfBytes.QuadPart;

        InputAddress.QuadPart = StartAddress.QuadPart;
        InputBytes.QuadPart = NumberOfBytes.QuadPart;

        if (InputBytes.QuadPart > (128 * 1024 * 1024)) {
            InputBytes.QuadPart = (128 * 1024 * 1024);
        }

        while (InputAddress.QuadPart + InputBytes.QuadPart <=
            StartAddress.QuadPart + NumberOfBytes.QuadPart) {

            DbgPrint ("buggy: MmRemovePhysicalMemory0 %x %x %x %x\n",
                InputAddress.HighPart,
                InputAddress.LowPart,
                InputBytes.HighPart,
                InputBytes.LowPart);

            Status = MmRemovePhysicalMemory (&InputAddress,
                &InputBytes);

            DbgPrint ("buggy: MmRemovePhysicalMemory %x %x %x %x %x\n\n",
                Status,
                InputAddress.HighPart,
                InputAddress.LowPart,
                InputBytes.HighPart,
                InputBytes.LowPart);

            KeDelayExecutionThread (KernelMode, FALSE, &BuggyOneSecond);

            if (NT_SUCCESS(Status)) {

                DbgPrint ("buggy: MmAddPhysicalMemory0 %x %x %x %x\n",
                    InputAddress.HighPart,
                    InputAddress.LowPart,
                    InputBytes.HighPart,
                    InputBytes.LowPart);

                Status = MmAddPhysicalMemory (
                    &InputAddress,
                    &InputBytes);

                if (NT_SUCCESS(Status)) {
                    DbgPrint ("\n\n***************\nbuggy: MmAddPhysicalMemory WORKED %x %x %x %x %x\n****************\n",
                        Status,
                        InputAddress.HighPart,
                        InputAddress.LowPart,
                        InputBytes.HighPart,
                        InputBytes.LowPart);
                }
                else {
                    DbgPrint ("buggy: MmAddPhysicalMemory FAILED %x %x %x %x %x\n\n",
                        Status,
                        InputAddress.HighPart,
                        InputAddress.LowPart,
                        InputBytes.HighPart,
                        InputBytes.LowPart);
                    DbgBreakPoint ();
                }
            }

            if (InputAddress.QuadPart + InputBytes.QuadPart ==
                StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                break;
            }

            InputAddress.QuadPart += InputBytes.QuadPart;

            if (InputAddress.QuadPart + InputBytes.QuadPart >
                StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                InputBytes.QuadPart = StartAddress.QuadPart + NumberOfBytes.QuadPart - InputAddress.QuadPart;
            }
        }

        p += 1;
    }

    ExFreePool (Ranges);
    DbgPrint ("Buggy: Add/remove physical memory simple stress finished\n");
#endif // #if 0
}


#endif // #if !PHYSMEM_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\mmtests.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  tdriver.c
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 2:39pm
//
// This module contains a template driver.
//
// --- History ---
//
// 4/20/1999 (SilviuC): initial version.
//
// 10/25/1999 (DMihai): Aded tests for:
//  - paged pool size
//  - non paged pool size
//  - number of free system PTEs 
//

#include <ntddk.h>

#include "active.h"
#include "mmtests.h"
#include "physmem.h"
#include "tdriver.h"

#if !MMTESTS_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID MmTestDisabled (VOID)
{
    DbgPrint ("Buggy: mmtests module is disabled (check \\driver\\active.h header) \n");
}

VOID MmTestProbeLockForEverStress (
    IN PVOID NotUsed
    )
{
    MmTestDisabled ();    
}

VOID MmTestNameToAddressStress (
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID MmTestEccBadStress (
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdSysPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdSysPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdNonPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdNonPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
TdFreeSystemPtesTest(
    IN PVOID IrpAddress
    )
{
    MmTestDisabled ();    
}

VOID
StressPoolFlag (
    PVOID NotUsed
    )
{
    MmTestDisabled ();    
}

VOID 
StressPoolTagTableExtension (
    PVOID NotUsed
    )
{
    MmTestDisabled ();    
}

#else

//
// Real implementation if the module is active
//


ULONG BuggyPP = (96 * 1024 * 1024);
PVOID BuggyOld;
SIZE_T UserVaSize = (50 * 1024 * 1024);
ULONG BuggyHold = 1;

ULONG OverrideStart;
ULONG OverrideSize;
ULONG OverrideCount;

#define VERBOSITY_PRINT         0x0001
#define VERBOSITY_BREAK         0x0002

ULONG Verbosity = 0x0003;


NTSYSCALLAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


VOID MmTestProbeLockForEverStress (
    IN PVOID IrpAddress
    )
{
    PIRP Irp = (PIRP) IrpAddress;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    {
        SIZE_T RegionSize;
        PVOID UserVa;
        PMDL Mdl;

        UserVa = NULL;
        RegionSize = UserVaSize;

        Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
            (PVOID *)&UserVa,
            0,
            &RegionSize,
            MEM_COMMIT,
            PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {

            Mdl = IoAllocateMdl (
                UserVa,
                (ULONG)RegionSize,
                FALSE,             // not secondary buffer
                FALSE,             // do not charge quota          
                NULL);             // no irp

            if (Mdl != NULL) {

                try {
                    MmProbeAndLockPages (Mdl,
                        KernelMode,
                        IoReadAccess);

                    DbgPrint ("Buggy: locked pages in MDL %p\n", Mdl);
                    DbgBreakPoint ();

                    //
                    // Don't exit now without unlocking !
                    //

                    while (BuggyHold != 0) {
                        KeDelayExecutionThread (KernelMode, FALSE, &BuggyOneSecond);
                    }
                    MmUnlockPages (Mdl);
                    IoFreeMdl (Mdl);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {

                    DbgPrint ("Buggy: exception raised while locking %p\n", Mdl);
                    DbgBreakPoint ();
                }
            }
        }
    }

    DbgPrint ("Buggy: finish with probe-and-lock forever ioctl \n");
    Status = STATUS_SUCCESS;
}


VOID MmTestNameToAddressStress (
    IN PVOID IrpAddress
    )
{
    PIRP Irp = (PIRP) IrpAddress;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    {

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }

        const UNICODE_STRING RoutineA = CONSTANT_UNICODE_STRING( L"KfRaiseIrql" );

        const UNICODE_STRING RoutineList[] = {

            CONSTANT_UNICODE_STRING( L"KeBugCheckEx" ),
            CONSTANT_UNICODE_STRING( L"KiBugCheckData" ),
            CONSTANT_UNICODE_STRING( L"KeWaitForSingleObject" ),
            CONSTANT_UNICODE_STRING( L"KeWaitForMutexObject" ),
            CONSTANT_UNICODE_STRING( L"Junk1" ),
            CONSTANT_UNICODE_STRING( L"CcCanIWrite" ),
            CONSTANT_UNICODE_STRING( L"Junk" ),

        };

        PVOID Addr;
        ULONG i;

        Addr = MmGetSystemRoutineAddress ((PUNICODE_STRING)&RoutineA);

        DbgPrint ("Addr is %p\n", Addr);

        for (i = 0; i < sizeof (RoutineList) / sizeof (UNICODE_STRING); i += 1) {

            Addr = MmGetSystemRoutineAddress ((PUNICODE_STRING)&RoutineList[i]);

            DbgPrint ("Addr0 is %p\n", Addr);
        }
    }
}


VOID MmTestEccBadStress (
    IN PVOID IrpAddress
    )
{
    PIRP Irp = (PIRP) IrpAddress;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;


    DbgPrint ("Buggy: mark physical memory ECC bad ioctl \n");

    {
        ULONG i;
        PPHYSICAL_MEMORY_RANGE Ranges;
        PPHYSICAL_MEMORY_RANGE p;

        PHYSICAL_ADDRESS StartAddress;
        LARGE_INTEGER NumberOfBytes;

        PHYSICAL_ADDRESS InputAddress;
        LARGE_INTEGER InputBytes;

        Ranges = MmGetPhysicalMemoryRanges ();
        if (Ranges == NULL) {
            DbgPrint ("Buggy: MmRemovePhysicalMemory cannot get ranges\n");
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return;
        }

        i = 0;
        DbgPrint("StartAddress @ %p, OverrideSize @ %p, OverrideCount @ %p\n", &OverrideStart, &OverrideSize, &OverrideCount);
        DbgBreakPoint();

        p = Ranges;
        while (p->BaseAddress.QuadPart != 0 && p->NumberOfBytes.QuadPart != 0) {
            StartAddress.QuadPart = p->BaseAddress.QuadPart;
            NumberOfBytes.QuadPart = p->NumberOfBytes.QuadPart;

            if (OverrideStart != 0) {
                StartAddress.LowPart = OverrideStart;
            }

            InputAddress.QuadPart = StartAddress.QuadPart;
            InputBytes.QuadPart = NumberOfBytes.QuadPart;

#ifdef BIG_REMOVES
            if (InputBytes.QuadPart > (64 * 1024)) {
                InputBytes.QuadPart = (64 * 1024);
            }
#else
            if (InputBytes.QuadPart > (4 * 1024)) {
                InputBytes.QuadPart = (4 * 1024);
            }
#endif

            if (OverrideSize != 0) {
                InputBytes.LowPart = OverrideSize;
            }

            while (InputAddress.QuadPart + InputBytes.QuadPart <=
                StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                if (OverrideCount != 0 && i > OverrideCount) {
                    break;
                }

                i += 1;

                DbgPrint ("buggy: MmMarkPhysicalMemoryAsBad %x %x %x %x\n",
                    InputAddress.HighPart,
                    InputAddress.LowPart,
                    InputBytes.HighPart,
                    InputBytes.LowPart);

                Status = MmMarkPhysicalMemoryAsBad (&InputAddress,
                    &InputBytes);

                DbgPrint ("buggy: MmMarkPhysicalMemoryAsBad %x %x %x %x %x\n\n",
                    Status,
                    InputAddress.HighPart,
                    InputAddress.LowPart,
                    InputBytes.HighPart,
                    InputBytes.LowPart);

                KeDelayExecutionThread (KernelMode, FALSE, &BuggyOneSecond);

                if (NT_SUCCESS(Status)) {

                    DbgPrint ("buggy: MmMarkPhysicalMemoryAsGood %x %x %x %x\n",
                        InputAddress.HighPart,
                        InputAddress.LowPart,
                        InputBytes.HighPart,
                        InputBytes.LowPart);

                    Status = MmMarkPhysicalMemoryAsGood (&InputAddress,
                        &InputBytes);

                    if (NT_SUCCESS(Status)) {
                        DbgPrint ("\n\n***************\nbuggy: MmMarkPhysicalMemoryAsGood WORKED %x %x %x %x %x\n****************\n",
                            Status,
                            InputAddress.HighPart,
                            InputAddress.LowPart,
                            InputBytes.HighPart,
                            InputBytes.LowPart);
                    }
                    else {
                        DbgPrint ("buggy: MmMarkPhysicalMemoryAsGood FAILED %x %x %x %x %x\n\n",
                            Status,
                            InputAddress.HighPart,
                            InputAddress.LowPart,
                            InputBytes.HighPart,
                            InputBytes.LowPart);
                        DbgBreakPoint ();
                    }
                }

                if (InputAddress.QuadPart + InputBytes.QuadPart ==
                    StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                    break;
                }

                InputAddress.QuadPart += InputBytes.QuadPart;

                if (InputAddress.QuadPart + InputBytes.QuadPart >
                    StartAddress.QuadPart + NumberOfBytes.QuadPart) {

                    InputBytes.QuadPart = StartAddress.QuadPart + NumberOfBytes.QuadPart - InputAddress.QuadPart;
                }
            }

            if (OverrideCount != 0 && i > OverrideCount) {
                break;
            }

            p += 1;
        }
        ExFreePool (Ranges);
        DbgPrint ("Buggy: MmMarkPhysicalMemory Ecc BAD test finished\n");
    }
}

////////////////////////////////////////////////////////////////////////////

typedef struct 
{
    LIST_ENTRY List;
    PVOID ChunkPointers[ ( 63 * 1024 ) / sizeof( PVOID ) ];
} ALLOCATION_TABLE, *PALLOCATION_TABLE;

LIST_ENTRY PagedPoolAllocationListHead;
LIST_ENTRY NonPagedPoolAllocationListHead;

const SIZE_T PoolChunkSize = 64 * 1024 - 32;


//
// 
//

VOID
TdpWriteSignature(
    PVOID Allocation,
    SIZE_T CurrentSize 
    )
{
    PSIZE_T CrtSignature;
    SIZE_T CrtSignatureValue;

    CrtSignature  = (PSIZE_T)Allocation;
    CrtSignatureValue = ( (SIZE_T)Allocation ) ^ CurrentSize;

    /*
    DbgPrint( "Buggy: Writing signature %p from address %p, size %p\n",
        CrtSignatureValue,
        CrtSignature,
        CurrentSize );
    */

    while( sizeof( SIZE_T ) <= CurrentSize )
    {
        *CrtSignature = CrtSignatureValue;

        CrtSignatureValue +=1;
        CrtSignature = (PSIZE_T)( (PCHAR)CrtSignature + sizeof( SIZE_T ) );
        CurrentSize -= sizeof( SIZE_T );
    }
}


//
//
// 

VOID
TdpVerifySignature(
    PVOID Allocation,
    SIZE_T CurrentSize )
{
    PSIZE_T CrtSignature;
    SIZE_T CrtSignatureValue;

    CrtSignature  = (PSIZE_T)Allocation;
    CrtSignatureValue = ( (SIZE_T)Allocation ) ^ CurrentSize;

    /*
    DbgPrint( "Buggy: Verifying signature %p from address %p, size %p\n",
        CrtSignatureValue,
        CrtSignature,
        CurrentSize );
    */

    while( sizeof( SIZE_T ) <= CurrentSize )
    {
        if( *CrtSignature != CrtSignatureValue )
        {
            DbgPrint ("Buggy: Signature at %p is incorrect, expected %p, base allocation %p\n",
                CrtSignature,
                CrtSignatureValue, 
                Allocation );
        }

        CrtSignatureValue +=1;
        CrtSignature = (PSIZE_T)( (PCHAR)CrtSignature + sizeof( SIZE_T ) );
        CurrentSize -= sizeof( SIZE_T );
    }
}


//
// 
//

VOID
TdpCleanupPoolAllocationTable(
    PLIST_ENTRY ListHead,
    SIZE_T Allocations
    )
{
    PLIST_ENTRY NextEntry;
    PALLOCATION_TABLE AllocationTable;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T CrtChunksIndex;

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationTable->ChunkPointers );

    NextEntry = ListHead->Flink;

    while( NextEntry != ListHead )
    {
        RemoveEntryList( NextEntry );

        AllocationTable = CONTAINING_RECORD( NextEntry, ALLOCATION_TABLE, List );

        DbgPrint( "Buggy: Current allocation table = %p\n",
            AllocationTable );

        for( CrtChunksIndex = 0; CrtChunksIndex < ChunksPerAllocationEntry; CrtChunksIndex++ )
        {
            if( 0 == Allocations )
            {
                //
                // Freed them all
                //

                break;
            }
            else
            {
                Allocations -= 1;

                if( 0 == Allocations % 0x100 )
                {
                    //
                    // Let the user know that we are still working on something
                    //

                    DbgPrint( "Buggy: cleaning up allocation index %p\n",
                        Allocations );
                }

                /*
                DbgPrint( "Buggy: Verify and free chunk index %p (from the end) at address %p\n",
                    Allocations,
                    AllocationTable->ChunkPointers[ CrtChunksIndex ] );
                */

                TdpVerifySignature(
                    AllocationTable->ChunkPointers[ CrtChunksIndex ],
                    PoolChunkSize );

                ExFreePoolWithTag(
                    AllocationTable->ChunkPointers[ CrtChunksIndex ],
                    TD_POOL_TAG );
            }
        }

        //
        // Free the table as well
        //

        ExFreePoolWithTag(
            AllocationTable,
            TD_POOL_TAG );

        //
        // Go to the next allocations table
        //

        NextEntry = ListHead->Flink;
    }

    //
    // At this point, Allocations should be zero and the
    // list should be empty
    //

    if( 0 != Allocations )
    {
        DbgPrint ("Buggy: Emptied the allocation table list but still have %p allocations - this is a bug\n",
            Allocations );

        DbgBreakPoint();
    }

    if( ! IsListEmpty( ListHead ) )
    {
        DbgPrint ("Buggy: No allocations left but the list at %p is not empty yet - this is a bug\n",
            ListHead );

        DbgBreakPoint();
    }
}


//
// Determine the maximum size of a block of paged pool currently available
//

VOID
TdSysPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentSize;
    SIZE_T SizeIncrement;
    ULONG Increment;
    PVOID Allocation;

#ifdef _WIN64

    CurrentSize = 0xFFFFFFFF00000000;

#else

    CurrentSize = 0xFFFFFFFF;

#endif //#ifdef _WIN64

    do
    {
        DbgPrint ("Buggy: Trying to allocate %p bytes paged pool\n",
            CurrentSize );

        Allocation = ExAllocatePoolWithTag(
            PagedPool,
            CurrentSize,
            TD_POOL_TAG );

        if( NULL != Allocation )
        {
            DbgPrint ("Buggy: allocated %p bytes paged pool\n",
                CurrentSize );

            TdpWriteSignature(
                Allocation,
                CurrentSize );

            ExFreePoolWithTag(
                Allocation,
                TD_POOL_TAG );
        }
        else
        {
            CurrentSize /= 2;
        }
    }
    while( NULL == Allocation && PAGE_SIZE <= CurrentSize );

    if( NULL != Allocation )
    {
        //
        // Try to find an even bigger size in 10% increments
        //

        SizeIncrement = CurrentSize / 10;

        if( PAGE_SIZE <= SizeIncrement )
        {
            for( Increment = 0; Increment < 10; Increment += 1 )
            {
                CurrentSize += SizeIncrement;

                DbgPrint ("Buggy: Trying to allocate %p bytes paged pool\n",
                    CurrentSize );

                Allocation = ExAllocatePoolWithTag(
                    PagedPool,
                    CurrentSize,
                    TD_POOL_TAG );

                if( NULL != Allocation )
                {
                    DbgPrint ("Buggy: Better result of the test: allocated %p bytes paged pool\n",
                        CurrentSize );

                    TdpWriteSignature(
                        Allocation,
                        CurrentSize );

                    ExFreePoolWithTag(
                        Allocation,
                        TD_POOL_TAG );
                }
                else
                {
                    DbgPrint ("Buggy: could not allocate %p bytes paged pool - done\n",
                        CurrentSize );

                    break;
                }
            }
        }
    }
}


//
// Determine the total size of the paged pool currently available (64 Kb - 32 bytes blocks)
//

VOID
TdSysPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentChunkIndex;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T TotalBytes;
    PALLOCATION_TABLE AllocationListEntry;
    PVOID Allocation;

    //
    // No allocations yet
    //

    InitializeListHead( 
        &PagedPoolAllocationListHead );

    //
    // We want to allocate 64 k chunks but leave space for the pool block header
    //

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationListEntry->ChunkPointers );

    CurrentChunkIndex = 0;

    do
    {
        if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
        {
            //
            // Need a new allocation entry structure
            //

            AllocationListEntry = (PALLOCATION_TABLE) ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof( ALLOCATION_TABLE ),
                TD_POOL_TAG );

            if( NULL == AllocationListEntry )
            {
                DbgPrint ("Buggy: could not allocate new ALLOCATION_TABLE - aborting test here\n" );
                break;
            }

            RtlZeroMemory( 
                AllocationListEntry,
                sizeof( ALLOCATION_TABLE ) );

            DbgPrint( "Buggy: New allocation table = %p\n",
                AllocationListEntry );
        }
        
        //
        // Try to allocate a new chunk
        //

        Allocation = ExAllocatePoolWithTag(
            PagedPool,
            PoolChunkSize,
            TD_POOL_TAG );

        if( NULL == Allocation )
        {
            DbgPrint ("Buggy: could not allocate paged pool chunk index %p - done\n",
                CurrentChunkIndex );

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //

                ExFreePoolWithTag( 
                    AllocationListEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            if( 0 == CurrentChunkIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: Allocated pool chunk index = %p\n",
                    CurrentChunkIndex );
            }

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &PagedPoolAllocationListHead,
                    &AllocationListEntry->List );
            }

            AllocationListEntry->ChunkPointers[ CurrentChunkIndex % ChunksPerAllocationEntry ] = Allocation;

            TdpWriteSignature(
                Allocation,
                PoolChunkSize );

            /*
            DbgPrint( "Buggy: Written signature to chunk index %p at address %p\n",
                CurrentChunkIndex,
                Allocation );
            */

            CurrentChunkIndex += 1;
        }    
    }
    while( NULL != Allocation );

    TotalBytes = CurrentChunkIndex * 64 * 1024;

    DbgPrint ("Buggy: Result of the test: approx. %p total bytes of paged pool allocated\n",
        TotalBytes );

    //
    // Clean-up what we have allocated
    //

    TdpCleanupPoolAllocationTable( 
        &PagedPoolAllocationListHead,
        CurrentChunkIndex );
}


VOID
TdNonPagedPoolMaxTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentSize;
    SIZE_T SizeIncrement;
    ULONG Increment;
    PVOID Allocation;

#ifdef _WIN64

    CurrentSize = 0xFFFFFFFF00000000;

#else

    CurrentSize = 0xFFFFFFFF;

#endif //#ifdef _WIN64

    do
    {
        DbgPrint ("Buggy: Trying to allocate %p bytes non-paged pool\n",
            CurrentSize );

        Allocation = ExAllocatePoolWithTag(
            NonPagedPool,
            CurrentSize,
            TD_POOL_TAG );

        if( NULL != Allocation )
        {
            DbgPrint ("Buggy: allocated %p bytes non-paged pool\n",
                CurrentSize );

            TdpWriteSignature(
                Allocation,
                CurrentSize );

            ExFreePoolWithTag(
                Allocation,
                TD_POOL_TAG );
        }
        else
        {
            CurrentSize /= 2;
        }
    }
    while( NULL == Allocation && PAGE_SIZE <= CurrentSize );

    if( NULL != Allocation )
    {
        //
        // Try to find an even bigger size in 10% increments
        //

        SizeIncrement = CurrentSize / 10;

        if( PAGE_SIZE <= SizeIncrement )
        {
            for( Increment = 0; Increment < 10; Increment += 1 )
            {
                CurrentSize += SizeIncrement;

                DbgPrint ("Buggy: Trying to allocate %p bytes non-paged pool\n",
                    CurrentSize );

                Allocation = ExAllocatePoolWithTag(
                    NonPagedPool,
                    CurrentSize,
                    TD_POOL_TAG );

                if( NULL != Allocation )
                {
                    DbgPrint ("Buggy: Better result of the test: allocated %p bytes non-paged pool\n",
                        CurrentSize );

                    TdpWriteSignature(
                        Allocation,
                        CurrentSize );

                    ExFreePoolWithTag(
                        Allocation,
                        TD_POOL_TAG );
                }
                else
                {
                    DbgPrint ("Buggy: could not allocate %p bytes non-paged pool - done\n",
                        CurrentSize );

                    break;
                }
            }
        }
    }
}


//
// Determine the total size of the non-paged pool currently available (64 Kb - 32 bytes blocks)
//

VOID
TdNonPagedPoolTotalTest(
    IN PVOID IrpAddress
    )
{
    SIZE_T CurrentChunkIndex;
    SIZE_T ChunksPerAllocationEntry;
    SIZE_T TotalBytes;
    PALLOCATION_TABLE AllocationListEntry;
    PVOID Allocation;

    //
    // No allocations yet
    //

    InitializeListHead( 
        &NonPagedPoolAllocationListHead );

    //
    // We want to allocate 64 k chunks but leave space for the pool block header
    //

    ChunksPerAllocationEntry = ARRAY_LENGTH( AllocationListEntry->ChunkPointers );

    CurrentChunkIndex = 0;

    do
    {
        if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
        {
            //
            // Need a new allocation entry structure
            //

            AllocationListEntry = (PALLOCATION_TABLE) ExAllocatePoolWithTag(
                PagedPool,
                sizeof( ALLOCATION_TABLE ),
                TD_POOL_TAG );

            if( NULL == AllocationListEntry )
            {
                DbgPrint ("Buggy: could not allocate new ALLOCATION_TABLE - aborting test here\n" );
                break;
            }
        }
        
        //
        // Try to allocate a new chunk
        //

        Allocation = ExAllocatePoolWithTag(
            NonPagedPool,
            PoolChunkSize,
            TD_POOL_TAG );

        if( NULL == Allocation )
        {
            DbgPrint ("Buggy: could not allocate non-paged pool chunk index %p - done\n",
                CurrentChunkIndex );

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //

                ExFreePoolWithTag( 
                    AllocationListEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            if( 0 == CurrentChunkIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: Allocated pool chunk index = %p\n",
                    CurrentChunkIndex );
            }

            if( 0 == CurrentChunkIndex % ChunksPerAllocationEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &NonPagedPoolAllocationListHead,
                    &AllocationListEntry->List );
            }

            AllocationListEntry->ChunkPointers[ CurrentChunkIndex % ChunksPerAllocationEntry ] = Allocation;

            TdpWriteSignature(
                Allocation,
                PoolChunkSize );

            CurrentChunkIndex += 1;
        }    
    }
    while( NULL != Allocation );

    TotalBytes = CurrentChunkIndex * 64 * 1024;

    DbgPrint ("Buggy: Result of the test: approx. %p total bytes of non-paged pool allocated\n",
        TotalBytes );

    //
    // Clean-up what we have allocated
    //

    TdpCleanupPoolAllocationTable( 
        &NonPagedPoolAllocationListHead,
        CurrentChunkIndex );
}

/////////////////////////////////////////////////////////////////////////////////////


typedef struct 
{
    LIST_ENTRY List;
    PMDL Mappings[ ( 63 * 1024 ) / sizeof( PMDL ) ];
} MAPPING_TABLE_ENTRY, *PMAPPING_TABLE_ENTRY;

LIST_ENTRY IoMappingsListHead;

ULONG BytesPerIoMapping = 1024 * 1024;


//
// 
//

VOID
TdpCleanupMappingsAllocationTable(
    PLIST_ENTRY ListHead,
    SIZE_T Mappings
    )
{
    PLIST_ENTRY NextEntry;
    PMAPPING_TABLE_ENTRY MappingTableEntry;
    SIZE_T MappingsPerMappingTableEntry;
    SIZE_T CrtMappingIndex;

    MappingsPerMappingTableEntry = ARRAY_LENGTH( MappingTableEntry->Mappings );

    NextEntry = ListHead->Flink;

    while( NextEntry != ListHead )
    {
        RemoveEntryList( NextEntry );

        MappingTableEntry = CONTAINING_RECORD( NextEntry, MAPPING_TABLE_ENTRY, List );

        for( CrtMappingIndex = 0; CrtMappingIndex < MappingsPerMappingTableEntry; CrtMappingIndex++ )
        {
            if( 0 == Mappings )
            {
                //
                // Freed them all
                //

                break;
            }
            else
            {
                Mappings -= 1;

                if( 0 == Mappings % 0x100 )
                {
                    //
                    // Let the user know that we are still working on something
                    //

                    DbgPrint( "Buggy: cleaning up mapping index %p\n",
                        Mappings );
                }

                //
                // Unmap
                //

                MmUnmapIoSpace(
                    MappingTableEntry->Mappings[ CrtMappingIndex ],
                    BytesPerIoMapping );
            }
        }

        //
        // Free the table as well
        //

        ExFreePoolWithTag(
            MappingTableEntry,
            TD_POOL_TAG );

        //
        // Go to the next allocations table
        //

        NextEntry = ListHead->Flink;
    }

    //
    // At this point, Mappings should be zero and the
    // list should be empty
    //

    if( 0 != Mappings )
    {
        DbgPrint ("Buggy: Emptied the mappings table list but still have %p allocations - this is a bug\n",
            Mappings );

        DbgBreakPoint();
    }

    if( ! IsListEmpty( ListHead ) )
    {
        DbgPrint ("Buggy: No mappings left but the list at %p is not empty yet - this is a bug\n",
            ListHead );

        DbgBreakPoint();
    }
}


//
// Determine the total amount of memory that can be mapped using system PTEs (1 Mb chunks)
//

VOID
TdFreeSystemPtesTest(
    IN PVOID IrpAddress
    )
{
    ULONG MemType;
    PHYSICAL_ADDRESS PortAddress;
    PHYSICAL_ADDRESS MyPhysicalAddress;
    SIZE_T CurrentMappingIndex;
    SIZE_T MappingsPerMappingTableEntry;
    SIZE_T TotalBytes;
    PVOID NewMapping;
    PMAPPING_TABLE_ENTRY MappingTableEntry;
    PMDL NewMdl;
    NTSTATUS Status;

    //
    // Use some joystick port address
    //

    MemType = 1;                 // IO space
    PortAddress.LowPart = 0x200;
    PortAddress.HighPart = 0;

    HalTranslateBusAddress(
                Isa,
                0,
                PortAddress,
                &MemType,
                &MyPhysicalAddress);

    //
    // No Mappings allocated yet
    //

    InitializeListHead( 
        &IoMappingsListHead );

    //
    // Map a ~64 Kb chunk over and over again to consume system PTEs
    //

    MappingsPerMappingTableEntry = ARRAY_LENGTH( MappingTableEntry->Mappings );

    CurrentMappingIndex = 0;

    do
    {
        if( 0 == CurrentMappingIndex % MappingsPerMappingTableEntry )
        {
            //
            // Need a new allocation entry structure
            //

            MappingTableEntry = (PMAPPING_TABLE_ENTRY) ExAllocatePoolWithTag(
                PagedPool,
                sizeof( MAPPING_TABLE_ENTRY ),
                TD_POOL_TAG );

            if( NULL == MappingTableEntry )
            {
                DbgPrint ("Buggy: could not allocate new MAPPING_TABLE_ENTRY - aborting test here\n" );
                break;
            }
        }

        NewMapping = MmMapIoSpace(
            MyPhysicalAddress,
            BytesPerIoMapping,
            MmNonCached );

        if( NULL == NewMapping )
        {
            DbgPrint ("Buggy: could not create mapping index %p\n",
                CurrentMappingIndex );

            if( 0 == CurrentMappingIndex % MappingsPerMappingTableEntry )
            {
                //
                // We are using a new list entry - free it now because
                // we don't want to have empty tables in the list so we didn't insert it yet so we didn't insert it yet
                //
                
                ExFreePoolWithTag(
                    MappingTableEntry,
                    TD_POOL_TAG );
            }
        }
        else
        {
            //DbgPrint ("Buggy: created Mapping index %p at address %p\n",
            //    CurrentMappingIndex,
            //    NewMapping );

            if( 0 == CurrentMappingIndex % 0x100 )
            {
                //
                // Let the user know that we are still working on something
                //

                DbgPrint( "Buggy: mapped chunk index = %p\n",
                    CurrentMappingIndex );
            }

            if( 0 == CurrentMappingIndex % MappingsPerMappingTableEntry )
            {
                //
                // We are using a new list entry - add it to our list only now because
                // we don't want to have empty tables in the list so we didn't insert it yet
                //

                InsertTailList(
                    &IoMappingsListHead,
                    &MappingTableEntry->List );
            }

            MappingTableEntry->Mappings[ CurrentMappingIndex % MappingsPerMappingTableEntry ] = NewMapping;

            CurrentMappingIndex += 1;
         }
    }
    while( NULL != NewMapping );

    TotalBytes = CurrentMappingIndex * BytesPerIoMapping;

    DbgPrint( "Buggy: Result of the test: %p total bytes mapped\n",
        TotalBytes );

    //
    // Clean-up what we have allocated and locked
    //

    TdpCleanupMappingsAllocationTable( 
        &IoMappingsListHead,
        CurrentMappingIndex );
}


//
// Function:
//
//     GetTag
//
// Description:
//
//     This function transforms an integer into a four letter
//     string. This is useful for the pool tag dynamic table
//     in order to populate it with many different tags.
//

ULONG
    GetTag (
    ULONG Index
    )
{
    UCHAR Value[4];

    Value[0] = (UCHAR)(((Index & 0x000F) >> 0 )) + 'A';
    Value[1] = (UCHAR)(((Index & 0x00F0) >> 4 )) + 'A';
    Value[2] = (UCHAR)(((Index & 0x0F00) >> 8 )) + 'A';
    Value[3] = (UCHAR)(((Index & 0xF000) >> 12)) + 'A';

    return *((PULONG)Value);
}



VOID
StressPoolFlag (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function iterates through all the pool types, pool flags
    and pool sizes (1 .. 8 * PAGE_SIZE).

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    POOL_TYPE PoolType;
    SIZE_T NumberOfBytes;
    EX_POOL_PRIORITY Priority;
    PVOID Va;
    ULONG i;

    for (PoolType = NonPagedPool; PoolType < 0xff; PoolType += 1) {
        for (Priority = LowPoolPriority; Priority < LowPoolPriority + 2; Priority += 1) {
            for (i = 1; i < 8 * PAGE_SIZE; i += 1) {

                NumberOfBytes = i;

                if (PoolType & 0x40) { 
                    break;
                }

                if ((NumberOfBytes > PAGE_SIZE) && (PoolType & 0x2)) {
                    break;
                }

                try {
                    Va = ExAllocatePoolWithTagPriority (
                        PoolType,
                        NumberOfBytes,
                        'ZXCV',
                        Priority);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {

                    if (Verbosity & VERBOSITY_PRINT) {
                        DbgPrint( "buggy: ExAllocatePool exceptioned %x %x %x\n",
                            PoolType, NumberOfBytes, Priority);
                    }

                    if (Verbosity & VERBOSITY_BREAK) {
                        DbgBreakPoint ();
                    }

                    Va = NULL;
                }

                if (Va) {
                    ExFreePool (Va);
                }
                else {
                    
                    if (Verbosity & VERBOSITY_PRINT) {
                        DbgPrint( "buggy: ExAllocatePool failed %x %x %x\n",
                            PoolType, NumberOfBytes, Priority);
                    }
                    
                    if (Verbosity & VERBOSITY_BREAK) {
                        DbgBreakPoint ();
                    }
                }
            }
        }
    }

    DbgPrint ("Buggy: ExAllocatePoolFlag test finished\n");
}



VOID 
StressPoolTagTableExtension (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function stresses the pool tag table dynamic extension.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    PVOID * Blocks;
    ULONG Index;

    Blocks = ExAllocatePoolWithTag (
        NonPagedPool,
        16384 * sizeof(PVOID),
        'tguB');

    if (Blocks == NULL) {
        DbgPrint ("Buggy: cannot allocate pool buffer\n");
    }
    else {

        //
        // Loop with 8 byte size.
        //

        for (Index = 0; Index < 10000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(a): %u \n", Index);
            }

            Blocks[Index] = ExAllocatePoolWithTag (
                NonPagedPool,
                8,
                GetTag(Index));
        }

        for (Index = 0; Index < 10000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(f): %u \n", Index);
            }

            if (Blocks[Index]) {
                ExFreePool (Blocks[Index]);
            }
        }

        //
        // Loop with PAGE_SIZE byte size.
        //

        for (Index = 0; Index < 4000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(A): %u \n", Index);
            }

            Blocks[Index] = ExAllocatePoolWithTag (
                NonPagedPool,
                PAGE_SIZE,
                GetTag(Index + 16384));
        }

        for (Index = 0; Index < 4000; Index++) {

            if (Index && Index % 100 == 0) {
                DbgPrint ("Index(F): %u \n", Index);
            }

            if (Blocks[Index]) {
                ExFreePool (Blocks[Index]);
            }
        }

        //
        // Free block info.
        //

        ExFreePool (Blocks);
    }
}

#endif // #if !MMTESTS_ACTIVE

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\resrvmap.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  SectMap.h
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmMapViewOfSection & MmMapViewInSystemSpace.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

#ifndef __BUGGY_RESRVMAP_H__
#define __BUGGY_RESRVMAP_H__

VOID
TdReservedMappingCleanup( 
	VOID 
	);

VOID
TdReservedMappingSetSize(
    IN PVOID Irp
    );

VOID
TdReservedMappingDoRead(
    IN PVOID Irp
    );

#endif //#ifndef __BUGGY_RESRVMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\resrvmap.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 2000.
//
// Module:  ResrvMap.c
// Author:  Daniel Mihai (DMihai)
// Created: 10/18/2000 
//
// This module contains tests for Mm APIs for reserved mapping addresses
//
//	MmAllocateMappingAddress
//	MmFreeMappingAddress
//	MmMapLockedPagesWithReservedMapping
//	MmUnmapReservedMapping
//
// --- History ---
//
// 10/18/2000 (DMihai): initial version.
//

#include <ntddk.h>
#include <wchar.h>

#include "active.h"
#include "tdriver.h"
#include "ResrvMap.h"

#if !RESRVMAP_ACTIVE

//
// Dummy stubs in case this module is disabled
//

VOID
TdReservedMappingSetSize(
    IN PVOID Irp
    )
{
    DbgPrint( "Buggy: ReservedMapping module is disabled (check \\driver\\active.h header)\n");
}

#else	//#if !RESRVMAP_ACTIVE

//
// This is the real stuff
//

//////////////////////////////////////////////////////////
//
// Global data
//

//
// Size of the current reserved mapping address
//

SIZE_T CrtReservedSize;

//
// Current reserved mapping address
//

PVOID CrtReservedAddress;

/////////////////////////////////////////////////////////////////////
//
// Clean-up a possible currently reserved buffer
// Called for IRP_MJ_CLEANUP
//

VOID
TdReservedMappingCleanup( 
	VOID 
	)
{
	if( NULL != CrtReservedAddress )
	{
		DbgPrint( "Buggy: TdReservedMappingCleanup: free reserved mapping address %p\n",
			CrtReservedAddress );

		MmFreeMappingAddress(
			CrtReservedAddress,
			TD_POOL_TAG );
	}
	else
	{
		ASSERT( 0 == CrtReservedSize );
	}
}

/////////////////////////////////////////////////////////////////////
//
// Set the current reserved size and address as asked by the user
//

VOID
TdReservedMappingSetSize(
    IN PVOID Irp
    )
{
    PIO_STACK_LOCATION IrpStack;
	ULONG InputBufferLength;
	SIZE_T NewReservedSize;
	PVOID NewReservedAddress;

    IrpStack = IoGetCurrentIrpStackLocation ( (PIRP)Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

	if( InputBufferLength != sizeof( SIZE_T ) )
	{
		//
		// The user should send us the new size of the buffer
		//

		DbgPrint( "Buggy: TdReservedMappingSetSize: invalid buffer length %p\n",
			InputBufferLength );

		DbgBreakPoint();

		return;
	}

	//
	// This will be our new reserved mapping address size 
	//

	NewReservedSize = *(PSIZE_T) ( (PIRP) Irp )->AssociatedIrp.SystemBuffer;

	if( NewReservedSize < PAGE_SIZE )
	{
		NewReservedSize = PAGE_SIZE;
	}
	else
	{
		NewReservedSize = ROUND_TO_PAGES( NewReservedSize );
	}

	//DbgPrint( "Buggy: TdReservedMappingSetSize: new reserved mapping address size %p\n",
	// NewReservedSize );

	if( 0 != NewReservedSize )
	{
		//
		// Try to reserve NewReservedSize bytes
		//

		NewReservedAddress = MmAllocateMappingAddress(
			NewReservedSize,
			TD_POOL_TAG );

		if( NULL == NewReservedAddress )
		{
			DbgPrint(
				"Buggy: TdReservedMappingSetSize: MmAllocateMappingAddress returned NULL, keeping old reserved address %p, size = %p\n",
				CrtReservedAddress,
				CrtReservedSize );

			return;
		}
	}
	else
	{
		//
		// Just release the old reserved address and set the size to 0
		//

		NewReservedAddress = NULL;
	}

	//
	// We have a new buffer, release the old one
	//

	TdReservedMappingCleanup();

	CrtReservedSize = NewReservedSize;
	CrtReservedAddress = NewReservedAddress;

	/*
	DbgPrint(
		"Buggy: TdReservedMappingSetSize: new reserved address %p, size = %p\n",
		CrtReservedAddress,
		CrtReservedSize );
	*/
}

////////////////////////////////////////////////////////////////////////
//
// Simulate a "read" operation in a user-supplied buffer
//

VOID
TdReservedMappingDoRead(
    IN PVOID Irp
    )
{
	PVOID UserBuffer;
	PVOID MappedAddress;
	PSIZE_T CrtPageAdddress;
	SIZE_T UserBufferSize;
	SIZE_T CrtPageIndex;
	SIZE_T CrtCycleSize;
	SIZE_T CrtCyclePages;
	PMDL Mdl;
    PIO_STACK_LOCATION IrpStack;
	ULONG InputBufferLength;
	PUSER_READ_BUFFER UserReadBufferStruct;
	BOOLEAN Locked;

	//
	// If we don't have a reserved address for mapping currently we cannot 
	// execute the operation
	//

	if( NULL == CrtReservedAddress )
	{
		ASSERT( 0 == CrtReservedSize );

		DbgPrint( "Buggy: TdReservedMappingDoRead: no buffer available - rejecting request\n" );

		return;
	}

	//
	// Make a copy of the user-supplied buffer address and size
	//

    IrpStack = IoGetCurrentIrpStackLocation ( (PIRP)Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

	if( InputBufferLength != sizeof( USER_READ_BUFFER ) )
	{
		//
		// The user should have sent us a USER_READ_BUFFER
		//

		DbgPrint( "Buggy: TdReservedMappingDoRead: invalid user buffer length %p, expected %p\n",
			InputBufferLength,
			(SIZE_T)sizeof( USER_READ_BUFFER ) );

		DbgBreakPoint();

		return;
	}

	UserReadBufferStruct = (PUSER_READ_BUFFER) ( (PIRP) Irp )->AssociatedIrp.SystemBuffer ;

	UserBuffer = UserReadBufferStruct->UserBuffer;
	UserBufferSize = UserReadBufferStruct->UserBufferSize;


	//
	// Map CrtReservedSize bytes at most
	//

	CrtPageIndex = 1;

	while( UserBufferSize >= PAGE_SIZE )
	{
		//DbgPrint( "Buggy: TdReservedMappingDoRead: %p bytes left to be read at adddress %p\n",
		//	UserBufferSize,
		//	UserBuffer );

		if( UserBufferSize > CrtReservedSize )
		{
			CrtCycleSize = CrtReservedSize;
		}
		else
		{
			CrtCycleSize = UserBufferSize;
		}

		//DbgPrint( "Buggy: TdReservedMappingDoRead: reading %p bytes this cycle\n",
		//	CrtCycleSize );

		//
		// Allocate an MDL
		//

		Mdl = IoAllocateMdl(
			UserBuffer,
			(ULONG)CrtCycleSize,
			FALSE,             // not secondary buffer
			FALSE,             // do not charge quota          
			NULL);             // no irp

		if( NULL != Mdl )
		{
			//
			// Try to lock the pages 
			//

			Locked = FALSE;

			try 
			{
				MmProbeAndLockPages(
					Mdl,
					KernelMode,
					IoWriteAccess);

				//DbgPrint( 
				//	"Buggy: locked pages in MDL %p\n", 
				//	Mdl);

				Locked = TRUE;
			}
			except (EXCEPTION_EXECUTE_HANDLER) 
			{
				DbgPrint( 
					"Buggy: MmProbeAndLockPages( %p ) raised exception %X\n", 
					Mdl,
					GetExceptionCode() );

				DbgBreakPoint();
			}

			if( TRUE == Locked )
			{
				//
				// Map them to our reserved address
				//

				MappedAddress = MmMapLockedPagesWithReservedMapping(
					CrtReservedAddress,
					TD_POOL_TAG,
					Mdl,
					MmCached );

				if( NULL == MappedAddress )
				{
					DbgPrint( 
						"Buggy: MmProbeAndLockPages( %p, MDL %p ) returned NULL. This API is almost guaranteed to succeed\n",
						CrtReservedAddress,
						Mdl );

					DbgBreakPoint();
				}
				else
				{
					//
					// Mapped successfully - execute the "read"
					//

					CrtCyclePages = CrtCycleSize / PAGE_SIZE;
					CrtPageAdddress = (PSIZE_T)MappedAddress;

					//
					// Stamp all the pages with their index, starting from 1
					//

					while( CrtCyclePages > 0 )
					{
						*CrtPageAdddress = CrtPageIndex;

						CrtPageIndex += 1;
						CrtCyclePages -= 1;
						CrtPageAdddress = (PSIZE_T)( (PCHAR)CrtPageAdddress + PAGE_SIZE );
					}

					//
					// Unmap
					//
					
					MmUnmapReservedMapping(
						MappedAddress,
						TD_POOL_TAG,
						Mdl );
				}

				//
				// Unlock
				//

                MmUnlockPages (Mdl);
			}

			//
			// Free MDL
			//

			IoFreeMdl (Mdl);
		}
		else
		{
			//
			// Bad luck - couldn't allocate the MDL
			//

			DbgPrint( "Buggy: TdReservedMappingDoRead: IoAllocateMdl( %p, %p ) returned NULL\n",
				UserBuffer,
				UserBufferSize );
		}
	
		//
		// How many bytes left to be read and to what address?
		//

		UserBufferSize -= CrtCycleSize;
		UserBuffer = (PVOID)( (PCHAR)UserBuffer + CrtCycleSize );
	}
}


#endif	//#if !RESRVMAP_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\tdriver.h ===
//
// Template driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Header:  tdriver.h
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 3:04pm
//

#ifndef _TDRIVER_H_INCLUDED_
#define _TDRIVER_H_INCLUDED_

//
// Structure received from user-mode with the
// bugcheck number and parameters
//

typedef struct _tag_BUGCHECK_PARAMS
{
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParameters[ 4 ];
} BUGCHECK_PARAMS, *PBUGCHECK_PARAMS;

//
// Structure receoved from user mode with the parameters
// for a "read" operation in TdReservedMappingDoRead
//

typedef struct _tag_USER_READ_BUFFER
{
	PVOID UserBuffer;
	SIZE_T UserBufferSize;
} USER_READ_BUFFER, *PUSER_READ_BUFFER;

//
// Device name. This should end in the of the driver.
//

#define TD_NT_DEVICE_NAME      L"\\Device\\buggy"
#define TD_DOS_DEVICE_NAME     L"\\DosDevices\\buggy"

#define TD_POOL_TAG            '_guB' // Bug_

//
// Constants used in the user-mode driver controller.
//

#define TD_DRIVER_NAME     TEXT("buggydriver")

//
// Array length macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array ) ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH


//
// Local function used inside the driver. They are enclosed
// in #ifdef _NTDDK_ so that user mode program including the header
// are not affected by this.
//

#ifdef _NTDDK_

NTSTATUS
TdDeviceCreate (

    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
TdDeviceClose (

    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
TdDeviceCleanup (

    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
TdDeviceControl (

    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
TdDeviceUnload (

    IN PDRIVER_OBJECT DriverObject);

NTSTATUS
TdInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#endif // #ifdef _NTDDK_


//
// Type:
//
//     TD_DRIVER_INFO
//
// Description:
//
//     This is the driver device extension structure.
//

typedef struct {

    ULONG Dummy;

} TD_DRIVER_INFO, * PTD_DRIVER_INFO;


#endif // #ifndef _TDRIVER_H_INCLUDED_

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\sectmap.c ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  SectMap.c
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmMapViewOfSection & MmMapViewInSystemSpace.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

#include <ntddk.h>
#include <wchar.h>

#include "active.h"
#include "ContMem.h"


#if !SECTMAP_ACTIVE

void
TdSectionMapTestProcessSpace(
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: sectmap test is disabled \n");
}

void
TdSectionMapTestSystemSpace(
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: sectmap test is disabled \n");
}

#else


NTKERNELAPI
NTSTATUS
MmCreateSection (
    OUT PVOID *SectionObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT File OPTIONAL
    );

NTKERNELAPI
NTSTATUS
MmMapViewOfSection(
    IN PVOID SectionToMap,
    IN PEPROCESS Process,
    IN OUT PVOID *CapturedBase,
    IN ULONG_PTR ZeroBits,
    IN SIZE_T CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset,
    IN OUT PSIZE_T CapturedViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection(
    IN PEPROCESS Process,
    IN PVOID BaseAddress
     );

/////////////////////////////////////////////////////////////////////////
//
// macros
//

#define SECTMAP_TEST_FILE_SIZE  (4 * 1024 * 1024)

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000    
#endif

/////////////////////////////////////////////////////////////////////////
//
// test variations
//

void
TdSectionMapTestProcessSpace(
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    ULONG uCrtThreadId;
    ULONG uPagesNo;
    PULONG puCrtUlong;
    PEPROCESS pEProcess;
    PVOID pSectionObject;
    PVOID pViewBase;
    PVOID pAfterLastValidPage;
    HANDLE hFile;
    SIZE_T sizeView;
    LARGE_INTEGER liMaxSize;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER liSectionOffset;
    UNICODE_STRING ustrFileName;
    OBJECT_ATTRIBUTES ObjAttrib;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR strFileName[ 64 ] = L"\\DosDevices\\c:\\maptest";
    WCHAR strThreadId[ 16 ];

    uCrtThreadId = PtrToUlong( PsGetCurrentThreadId() );

    //
    // generate the file name
    //

    swprintf( strThreadId, L"%u", uCrtThreadId );
    wcscat( strFileName, strThreadId );

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, using file %ws\n",
        uCrtThreadId,
        strFileName );
    */
    
    //
    // make it a UNICODE_STRING
    //

    RtlInitUnicodeString(
        &ustrFileName,
        strFileName
        );

    InitializeObjectAttributes(
        &ObjAttrib,
        &ustrFileName,
        OBJ_CASE_INSENSITIVE,
        0,
        0
        );

    //
    // open the file
    //

    liMaxSize.QuadPart = SECTMAP_TEST_FILE_SIZE;

    Status = ZwCreateFile(
            &hFile,
            GENERIC_READ | GENERIC_WRITE,
            &ObjAttrib,
            &IoStatusBlock,
            &liMaxSize,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
                FILE_NO_INTERMEDIATE_BUFFERING |
                FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, ZwCreateFile failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, file opened\n",
        uCrtThreadId );
    */

    ASSERT( IoStatusBlock.Information == FILE_CREATED || IoStatusBlock.Information == FILE_OPENED );
    ASSERT( hFile != (HANDLE)-1 );
    ASSERT( liMaxSize.QuadPart == SECTMAP_TEST_FILE_SIZE );

    //
    // create the section
    //

    Status = MmCreateSection(
        &pSectionObject,
        STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
        0,
        &liMaxSize,
        PAGE_READWRITE,
        SEC_COMMIT,
        hFile,
        NULL
        );

    ZwClose(hFile);

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmCreateSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, section %p created\n",
        uCrtThreadId,
        pSectionObject );
    */

    //
    // map the section
    //

    sizeView = (SIZE_T)liMaxSize.LowPart;
    liSectionOffset.QuadPart = 0;

    pEProcess = PsGetCurrentProcess();

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, mapping section %p in process %p\n",
        uCrtThreadId,
        pSectionObject,
        pEProcess );
    */

    pViewBase = NULL;

    Status = MmMapViewOfSection(
        pSectionObject,
        pEProcess,
        &pViewBase,
        0,
        0,
        &liSectionOffset,
        &sizeView,
        ViewUnmap,
        0,              // allocation type 
        PAGE_READWRITE
        );

    if( ! NT_SUCCESS( Status ) )
    {
        //
        // dereference the section object 
        //

        ObDereferenceObject( pSectionObject );

        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmMapViewOfSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, section mapped, pViewBase = %p\n",
        uCrtThreadId,
        pViewBase );
    */

    // DbgBreakPoint();

    ASSERT( liSectionOffset.QuadPart == 0 );
    ASSERT( sizeView == SECTMAP_TEST_FILE_SIZE );
    ASSERT( pViewBase != NULL );

    //
    // touch some of the pages
    //

    uPagesNo = (ULONG)sizeView / PAGE_SIZE;
    pAfterLastValidPage = (PVOID)( (ULONG_PTR)pViewBase + uPagesNo * PAGE_SIZE );

    KeQuerySystemTime (&CurrentTime);
    puCrtUlong = (PULONG)( (ULONG_PTR)pViewBase + (CurrentTime.LowPart % 5) * PAGE_SIZE );

    while( (ULONG_PTR)puCrtUlong < (ULONG_PTR)pAfterLastValidPage )
    {
        /*
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, touching page %p\n",
            uCrtThreadId,
            puCrtUlong );
        */

        *puCrtUlong = CurrentTime.LowPart;

        KeQuerySystemTime (&CurrentTime);
        puCrtUlong = (PULONG)( (ULONG_PTR)puCrtUlong + (CurrentTime.LowPart % 5 + 1) * PAGE_SIZE );
    }
    
    //
    // clean-up
    //

    //
    // un-map the section
    //

    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmUnmapViewOfSection process %p, pViewBase = %p\n",
        uCrtThreadId,
        pEProcess,
        pViewBase );
    */

    Status = MmUnmapViewOfSection(
        pEProcess,
        pViewBase );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, MmUnmapViewOfSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();
    }

    //
    // dereference the section object 
    //
    
    /*
    DbgPrint( "buggy: TdSectionMapTestProcessSpace: thread %u, dereference section at %p\n",
        uCrtThreadId,
        pSectionObject );
    */

    ObDereferenceObject( pSectionObject );
}

/////////////////////////////////////////////////////////////////////////

void
TdSectionMapTestSystemSpace(
    PVOID NotUsed
    )
{
    NTSTATUS Status;
    ULONG uCrtThreadId;
    ULONG uPagesNo;
    PULONG puCrtUlong;
    PVOID pSectionObject;
    PVOID pViewBase;
    PVOID pAfterLastValidPage;
    HANDLE hFile;
    SIZE_T sizeView;
    LARGE_INTEGER liMaxSize;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER liSectionOffset;
    UNICODE_STRING ustrFileName;
    OBJECT_ATTRIBUTES ObjAttrib;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR strFileName[ 64 ] = L"\\DosDevices\\c:\\maptest";
    WCHAR strThreadId[ 16 ];

    uCrtThreadId = PtrToUlong( PsGetCurrentThreadId() );

    //
    // generate the file name
    //

    swprintf( strThreadId, L"%u", uCrtThreadId );
    wcscat( strFileName, strThreadId );

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, using file %ws\n",
        uCrtThreadId,
        strFileName );
    */
    
    //
    // make it a UNICODE_STRING
    //

    RtlInitUnicodeString(
        &ustrFileName,
        strFileName
        );

    InitializeObjectAttributes(
        &ObjAttrib,
        &ustrFileName,
        OBJ_CASE_INSENSITIVE,
        0,
        0
        );

    //
    // open the file
    //

    liMaxSize.QuadPart = SECTMAP_TEST_FILE_SIZE;

    Status = ZwCreateFile(
            &hFile,
            GENERIC_READ | GENERIC_WRITE,
            &ObjAttrib,
            &IoStatusBlock,
            &liMaxSize,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_WRITE_THROUGH |
                FILE_NO_INTERMEDIATE_BUFFERING |
                FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, ZwCreateFile failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, file opened\n",
        uCrtThreadId );
    */

    ASSERT( IoStatusBlock.Information == FILE_CREATED || IoStatusBlock.Information == FILE_OPENED );
    ASSERT( hFile != (HANDLE)-1 );
    ASSERT( liMaxSize.QuadPart == SECTMAP_TEST_FILE_SIZE );

    //
    // create the section
    //

    Status = MmCreateSection(
        &pSectionObject,
        STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
        0,
        &liMaxSize,
        PAGE_READWRITE,
        SEC_COMMIT,
        hFile,
        NULL
        );

    ZwClose(hFile);

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmCreateSection failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, section %p created\n",
        uCrtThreadId,
        pSectionObject );
    */

    //
    // map the section
    //

    sizeView = (SIZE_T)liMaxSize.LowPart;
    liSectionOffset.QuadPart = 0;

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, mapping section %p system space\n",
        uCrtThreadId,
        pSectionObject );
    */

    pViewBase = NULL;

    Status = MmMapViewInSystemSpace(
        pSectionObject,
        &pViewBase,
        &sizeView
        );

    if( ! NT_SUCCESS( Status ) )
    {
        //
        // dereference the section object 
        //

        ObDereferenceObject( pSectionObject );

        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmMapViewInSystemSpace failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();

        return;
    }

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, section mapped, pViewBase = %p\n",
        uCrtThreadId,
        pViewBase );
    */

    // DbgBreakPoint();

    ASSERT( liSectionOffset.QuadPart == 0 );
    ASSERT( sizeView == SECTMAP_TEST_FILE_SIZE );
    ASSERT( pViewBase != NULL );

    //
    // touch some of the pages
    //

    uPagesNo = (ULONG)sizeView / PAGE_SIZE;
    pAfterLastValidPage = (PVOID)( (ULONG_PTR)pViewBase + uPagesNo * PAGE_SIZE );

    KeQuerySystemTime (&CurrentTime);
    puCrtUlong = (PULONG)( (ULONG_PTR)pViewBase + (CurrentTime.LowPart % 5) * PAGE_SIZE );

    while( (ULONG_PTR)puCrtUlong < (ULONG_PTR)pAfterLastValidPage )
    {
        /*
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, touching page %p\n",
            uCrtThreadId,
            puCrtUlong );
        */ 

        *puCrtUlong = CurrentTime.LowPart;

        KeQuerySystemTime (&CurrentTime);
        puCrtUlong = (PULONG)( (ULONG_PTR)puCrtUlong + (CurrentTime.LowPart % 5 + 1) * PAGE_SIZE );
    }
    
    //
    // clean-up
    //

    //
    // un-map the section
    //

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmUnmapViewInSystemSpace pViewBase = %p\n",
        uCrtThreadId,
        pViewBase );
    */

    Status = MmUnmapViewInSystemSpace(
        pViewBase );

    if( ! NT_SUCCESS( Status ) )
    {
        DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, MmUnmapViewInSystemSpace failed %X\n",
            uCrtThreadId,
            (ULONG)Status );

        DbgBreakPoint();
    }

    //
    // dereference the section object 
    //

    /*
    DbgPrint( "buggy: TdSectionMapTestSystemSpace: thread %u, dereference section at %p\n",
        uCrtThreadId,
        pSectionObject );
    */

    ObDereferenceObject( pSectionObject );
}

#endif // #if !SECTMAP_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\tracedb.h ===
#ifndef _TRACEDB_H_INCLUDED_
#define _TRACEDB_H_INCLUDED_

VOID TestTraceDatabase (
    PVOID
    );

#endif // #ifndef _TRACEDB_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\sectmap.h ===
//
// Template Driver
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  SectMap.h
// Author:  Daniel Mihai (DMihai)
// Created: 6/19/1999 2:39pm
//
// This module contains tests for MmMapViewOfSection & MmMapViewInSystemSpace.
//
// --- History ---
//
// 6/19/1999 (DMihai): initial version.
//

void
TdSectionMapTestProcessSpace(
    PVOID
    );

void
TdSectionMapTestSystemSpace(
    PVOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\tracedb.c ===
#include <nt.h>
#include <ntrtl.h>
// #include <ntddk.h>

#include "active.h"
#include "tracedb.h"

#if !TRACEDB_ACTIVE

//
// Dummy implementation if the module is inactive
//

VOID TestTraceDatabase (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: tracedb module is disabled \n");
}

#else


#define assert_(Expr) {                                                     \
    if (!(Expr)) {                                                          \
        DbgPrint ("Test tracedb assert: (%s, %d): \" %s \" -- assertion failed \n", \
          __FILE__, __LINE__, #Expr);                                       \
        DbgBreakPoint ();                                                   \
        return;                                                             \
    }}

//
// Real implementation if the module is active
//

VOID
TestTraceDatabase (
    PVOID NotUsed
    )
{
    PRTL_TRACE_DATABASE Db;
    ULONG_PTR Trace [16];
    PRTL_TRACE_BLOCK Blk;
    PRTL_TRACE_BLOCK BlkX;
    ULONG Index, I;
    BOOLEAN Result; 
    ULONG Seed = 0xABCDDCBA;

    Db = RtlTraceDatabaseCreate (16, 
                                 0, 
                                 RTL_TRACE_USE_NONPAGED_POOL, 
                                 'bDrT', 
                                 0);

    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Db != NULL);

    for (Index = 0; Index < 16; Index++) {
        Trace[Index] = (ULONG_PTR)RtlRandom(&Seed);
    }

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 1);

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 2);
    assert_ (Blk == BlkX);

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 2);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    RtlTraceDatabaseDestroy (Db);


    //
    // Use paged pool also.
    //

    Db = RtlTraceDatabaseCreate (16, 
                                 0, 
                                 RTL_TRACE_USE_PAGED_POOL, 
                                 'bDrT', 
                                 0);

    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Db != NULL);

    for (Index = 0; Index < 16; Index++) {
        Trace[Index] = (ULONG_PTR)RtlRandom(&Seed);
    }

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 1);

    Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
    assert_ (RtlTraceDatabaseValidate (Db));

    assert_ (Result);
    assert_ (Blk->Size == 16);
    assert_ (Blk->Count == 2);
    assert_ (Blk == BlkX);

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    //
    // Stress a little bit the whole thing
    //

    Seed = 0xABCDDCBA;

    for (I = 0; I < 10000; I++) {
        
        for (Index = 0; Index < 16; Index++) {
            RtlRandom(&Seed);
            Trace[Index] = (ULONG_PTR)Seed;
        }

        Result = RtlTraceDatabaseFind (Db, 16, (PVOID *)Trace, &Blk);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 1);

        Result = RtlTraceDatabaseAdd (Db, 16, (PVOID *)Trace, &BlkX);
        assert_ (RtlTraceDatabaseValidate (Db));

        assert_ (Result);
        assert_ (Blk->Size == 16);
        assert_ (Blk->Count >= 2);
        assert_ (Blk == BlkX);

        if (I % 512 == 0) {
            DbgPrint(".");
        }
    }

    DbgPrint("\n");

    RtlTraceDatabaseDestroy (Db);

}

#endif // #if !TRACEDB_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\tdriver.c ===
//
// Buggy - Template Test Driver
// Copyright (c) Microsoft Corporation, 1999, 2000.
//
// Module:  tdriver.c
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 2:39pm
//
// This module contains a template driver.
//
// --- History ---
//
// 4/20/1999 (SilviuC): initial version.
//
// 1/19/2000 (SilviuC): make it really extensible.
//

//
// PLEASE READ IF YOU MODIFY THIS FILE !
//
// The only modification needed in this module is an include
// statement for the header of the module implementing the new
// test in the section `Test specific headers'. That's all.
//

#include <ntddk.h>

//
// Test specific headers.
//

#include "active.h"

#include "bugcheck.h"
#include "ContMem.h"
#include "SectMap.h"
#include "tracedb.h"
#include "physmem.h"
#include "mmtests.h"
#include "MapView.h"
#include "locktest.h"
#include "ResrvMap.h"

#include "newstuff.h"

//
// Standard tdriver headers.
//

#define FUNS_DEFINITION_MODULE
#include "tdriver.h"
#include "funs.h"

//
// Driver implementation
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtName;
    UNICODE_STRING Win32Name;
    ULONG Index;    
    PDEVICE_OBJECT Device;

    DbgPrint ("Buggy: DriverEntry() \n");

    //
    // Create Unicode NT name for the device.

    RtlInitUnicodeString (

        &NtName, 
        TD_NT_DEVICE_NAME);

    //
    // Create NT device
    //

    Status = IoCreateDevice (

        DriverObject,             // pointer to driver object
        sizeof (TD_DRIVER_INFO),  // device extension
        &NtName,                  // device name
        FILE_DEVICE_UNKNOWN,      // device type
        0,                        // device characteristics
        FALSE,                    // not exclusive
        &Device);                 // returned device object pointer

    if (! NT_SUCCESS(Status)) {

        return Status;
    }

    //
    // Create dispatch points
    //

    for (Index = 0; Index < IRP_MJ_MAXIMUM_FUNCTION; Index++) {
        DriverObject->MajorFunction[Index] = TdInvalidDeviceRequest;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = TdDeviceCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = TdDeviceClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = TdDeviceCleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = TdDeviceControl;
    DriverObject->DriverUnload                         = TdDeviceUnload;

    //
    // Create counted string version of our Win32 device name.
    //

    RtlInitUnicodeString (

        &Win32Name, 
        TD_DOS_DEVICE_NAME);

    //
    // Create a link from our device name to a name in the Win32 namespace.
    //

    Status = IoCreateSymbolicLink (

        &Win32Name, 
        &NtName);

    if (! NT_SUCCESS(Status)) {

        IoDeleteDevice (DriverObject->DeviceObject);
        return Status;
    }

    return Status;
}


NTSTATUS
TdDeviceCreate (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
//
// Handles create IRP.
//

{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
TdDeviceClose (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
//
// Handles close IRP.
//
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
TdDeviceCleanup (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
//
// Handles cleanup IRP.
//
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
TdDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
//
// Handles control IRP.
//
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG Ioctl;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG ReturnedSize;
    KIRQL irql;
    ULONG Index;
    LOGICAL IoctlFound = FALSE;

    Status = STATUS_SUCCESS;

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

    if( Ioctl == IOCTL_TD_BUGCHECK )
    {
        if( InputBufferLength == sizeof( BUGCHECK_PARAMS ) )
        {
            PBUGCHECK_PARAMS pBugcheckParams = (PBUGCHECK_PARAMS)(Irp->AssociatedIrp.SystemBuffer);

            DbgPrint( "Buggy: calling KeBugCheckEx( %X, %p, %p, %p, %p )\n",
                pBugcheckParams->BugCheckCode,
                pBugcheckParams->BugCheckParameters[ 0 ],
                pBugcheckParams->BugCheckParameters[ 1 ],
                pBugcheckParams->BugCheckParameters[ 2 ],
                pBugcheckParams->BugCheckParameters[ 3 ] );

            KeBugCheckEx(
                pBugcheckParams->BugCheckCode,
                pBugcheckParams->BugCheckParameters[ 0 ],
                pBugcheckParams->BugCheckParameters[ 1 ],
                pBugcheckParams->BugCheckParameters[ 2 ],
                pBugcheckParams->BugCheckParameters[ 3 ] );
        }
        else
        {
            DbgPrint( "Buggy: cannot read bugcheck data, expected data length %u, IrpStack->Parameters.DeviceIoControl.InputBufferLength = %u\n",
                sizeof( BUGCHECK_PARAMS ),
                InputBufferLength );
        }

        goto Done;

    }

    //
    // (SilviuC): maybe we should do parameter checking on the info buffer.
    // Not really important since this is not a production driver.
    //

    for (Index = 0; BuggyFuns[Index].Ioctl != 0; Index++) {
        if (Ioctl == BuggyFuns[Index].Ioctl) {
            DbgPrint ("Buggy: %s ioctl \n", BuggyFuns[Index].Message);
            (BuggyFuns[Index].Function)((PVOID)Irp);
            DbgPrint ("Buggy: done with %s. \n", BuggyFuns[Index].Message);
            IoctlFound = TRUE;
            break;
        }
    }

    //
    // Complain if Ioctl code not found.
    //

    if (! IoctlFound) {
        DbgPrint ("Buggy: unrecognized ioctl code %u \n", Ioctl);
    }

    //
    // Complete the irp and return.
    //
Done:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return Status;
}


VOID
TdDeviceUnload (
    IN PDRIVER_OBJECT DriverObject
    )
//
// This function handles driver unloading. All this driver needs to do 
// is to delete the device object and the symbolic link between our 
// device name and the Win32 visible name.
//
{
    UNICODE_STRING  Win32Name;

    DbgPrint ("Buggy: unload \n");

#if RESRVMAP_ACTIVE

	//
	// Clean-up a possible currently reserved buffer
	//

	TdReservedMappingCleanup();

#endif //#if RESRVMAP_ACTIVE

    //
    //
    //
    // Create counted string version of our Win32 device name.
    //

    RtlInitUnicodeString (

        &Win32Name, 
        TD_DOS_DEVICE_NAME );

    //
    // Delete the link from our device name to a name in the Win32 namespace.
    //

    IoDeleteSymbolicLink (&Win32Name);

    //
    // Finally delete our device object
    //

    IoDeleteDevice (DriverObject->DeviceObject);

}


NTSTATUS
TdInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is the default dispatch routine for all driver entries
    not implemented by drivers that have been loaded into the system.  Its
    responsibility is simply to set the status in the packet to indicate
    that the operation requested is invalid for this device type, and then
    complete the packet.

Arguments:

    DeviceObject - Specifies the device object for which this request is
        bound.  Ignored by this routine.

    Irp - Specifies the address of the I/O Request Packet (IRP) for this
        request.

Return Value:

    The final status is always STATUS_INVALID_DEVICE_REQUEST.


--*/    
{
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Simply store the appropriate status, complete the request, and return
    // the same status stored in the packet.
    //

    if ((IoGetCurrentIrpStackLocation(Irp))->MajorFunction == IRP_MJ_POWER) {
        PoStartNextPowerIrp(Irp);
    }
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_INVALID_DEVICE_REQUEST;
}

//
// End of module: tdriver.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\build.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       build.c
//
//  Contents:   Parameter processing and main entry point for Build.exe
//
//  History:    16-May-89      SteveWo         Created
//              ...   See SLM log
//              26-Jul-94      LyleC           Cleanup/Add Pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"

#include <ntverp.h>

//
// Increase critical section timeout so people don't get
// frightened when the CRT takes a long time to acquire
// its critical section.
//
IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    1000 * 60 * 60 * 24,        // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    0,                          // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0         // Reserved
};

//
// Target machine info:
//
//  SourceSubDirMask, Description, Switch, MakeVariable,
//  SourceVariable, ObjectVariable, AssociateDirectory,
//  SourceDirectory, ObjectDirectory
//

TARGET_MACHINE_INFO i386TargetMachine = {
    TMIDIR_I386, "i386", "-386", "-x86", "386=1",
    "i386_SOURCES", "386_OBJECTS", "i386",
    "i386", "i386dirs", { "i386" },
    DIR_INCLUDE_X86 | DIR_INCLUDE_WIN32
};

TARGET_MACHINE_INFO ia64TargetMachine = {
    TMIDIR_IA64, "IA64", "-ia64", "-merced", "IA64=1",
    "IA64_SOURCES", "IA64_OBJECTS", "ia64",
    "ia64", "ia64dirs", { "ia64" },
    DIR_INCLUDE_IA64 | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN64
};

TARGET_MACHINE_INFO Amd64TargetMachine = {
    TMIDIR_AMD64, "AMD64", "-amd64", "-amd64", "AMD64=1",
    "AMD64_SOURCES", "AMD64_OBJECTS", "amd64",
    "amd64", "amd64dirs", { "amd64" },
    DIR_INCLUDE_AMD64 | DIR_INCLUDE_RISC | DIR_INCLUDE_WIN64
};

TARGET_MACHINE_INFO *PossibleTargetMachines[MAX_TARGET_MACHINES] = {
    &i386TargetMachine,
    &ia64TargetMachine,
    &Amd64TargetMachine
};

UINT NumberCompileWarnings;
UINT NumberCompileErrors;
UINT NumberCompiles;
UINT NumberLibraries;
UINT NumberLibraryWarnings;
UINT NumberLibraryErrors;
UINT NumberLinks;
UINT NumberLinkWarnings;
UINT NumberLinkErrors;
UINT NumberBinplaces;
UINT NumberBinplaceWarnings;
UINT NumberBinplaceErrors;

//
// Machine specific target dirs default. If one there is only one build
// target and a target specific dirs file is selected, then this gets
// filled with a pointer to the target specific dirs filename.
//

LPSTR pszTargetDirs = "";

#define AltDirMaxSize 10            // Maximum size for alternate obj dir name

CHAR LogDirectory[DB_MAX_PATH_LENGTH] = ".";
CHAR LogFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR WrnFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR ErrFileName[DB_MAX_PATH_LENGTH] = "build";
CHAR IncFileName[DB_MAX_PATH_LENGTH] = "build";

CHAR szObjRoot[DB_MAX_PATH_LENGTH];
CHAR *pszObjRoot;

CHAR szBuildAltDir[DB_MAX_PATH_LENGTH];
CHAR *pszBuildAltDir = NULL;

CHAR szObjDir[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlash[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlashStar[DB_MAX_PATH_LENGTH];

CHAR szObjDirD[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlashD[DB_MAX_PATH_LENGTH];
CHAR szObjDirSlashStarD[DB_MAX_PATH_LENGTH];

CHAR *pszObjDir = szObjDir;
CHAR *pszObjDirSlash = szObjDirSlash;
CHAR *pszObjDirSlashStar = szObjDirSlashStar;
CHAR *pszObjDirD = szObjDirD;

BOOL fCheckedBuild = TRUE;
ULONG iObjectDir = 0;
BOOL fDependencySwitchUsed;
BOOL fCmdLineDependencySwitchUsed;
BOOL fCmdLineQuicky;
BOOL fCmdLineSemiQuicky;
BOOL fCmdLineQuickZero;
CHAR *BuildProduct;

ULONG DefaultProcesses = 0;
CHAR *szBuildTag;

#define MAX_ENV_ARG 512

const char szNewLine[] = "\n";
const char szUsage[] =
    "Usage: BUILD [-?] display this message\n"
    "\t[-#] force _objects.mac to be regenerated\n"
    "\t[-0] pass 0 generation only, no compile, no link\n"
    "\t[-2] same as old -Z (only do a 2 pass build - no pass 0)\n"
    "\t[-3] same as -Z\n"
    "\t[-a] allows synchronized blocks and drains during link pass\n"
    "\t[-b] displays full error message text (doesn't truncate)\n"
    "\t[-c] deletes all object files\n"
    "\t[-C] deletes all .lib files only\n"
#if DBG
    "\t[-d] display debug information\n"
#endif
    "\t[-D] check dependencies before building (on by default if BUILD_PRODUCT != NT)\n"
    "\t[-e] generates build.log, build.wrn & build.err files\n"
    "\t[-E] always keep the log/wrn/err files (use with -z)\n"
    "\t[-f] force rescan of all source and include files\n"
    "\t[-F] when displaying errors/warnings to stdout, print the full path\n"
    "\t[-G] enables target specific dirs files iff one target\n"
    "\t[-i] ignore extraneous compiler warning messages\n"
    "\t[-I] do not display thread index if multiprocessor build\n"
    "\t[-k] keep (don't delete) out-of-date targets\n"
    "\t[-l] link only, no compiles\n"
    "\t[-L] compile only, no link phase\n"
    "\t[-m] run build in the idle priority class\n"
    "\t[-M [n]] Multiprocessor build (for MP machines)\n"
    "\t[-o] display out-of-date files\n"
    "\t[-O] generate obj\\_objects.mac file for current directory\n"
    "\t[-p] pause' before compile and link phases\n"
    "\t[-P] Print elapsed time after every directory\n"
    "\t[-q] query only, don't run NMAKE\n"
    "\t[-r dirPath] restarts clean build at specified directory path\n"
    "\t[-s] display status line at top of display\n"
    "\t[-S] display status line with include file line counts\n"
    "\t[-t] display the first level of the dependency tree\n"
    "\t[-T] display the complete dependency tree\n"
    "\t[-$] display the complete dependency tree hierarchically\n"
    "\t[-u] display unused BUILD_OPTIONS\n"
    "\t[-v] enable include file version checking\n"
    "\t[-w] show warnings on screen\n"
    "\t[-y] show files scanned\n"
    "\t[-z] no dependency checking or scanning of source files -\n"
        "\t\tone pass compile/link\n"
    "\t[-Z] no dependency checking or scanning of source files -\n"
        "\t\tthree passes\n"
    "\t[-why] list reasons for building targets\n"
    "\n"
    "\t[-386] build targets for 32-bit Intel\n"
    "\t[-x86] Same as -i386\n"
    "\t[-ia64] build targets for IA64\n"
    "\t[-amd64] build targets for AMD64\n"
    "\n"
    "\t[-x filename] exclude include file from dependency checks\n"
    "\t[-j filename] use 'filename' as the name for log files\n"
    "\t[-jpath pathname] use 'pathname' as the path for log files instead of \".\"\n"
    "\t[-nmake arg] argument to pass to NMAKE\n"
    "\t[-clean] equivalent to '-nmake clean'\n"
    "\tNon-switch parameters specify additional source directories\n"
    "\t* builds all optional source directories\n";


BOOL
ProcessParameters(int argc, LPSTR argv[], BOOL SkipFirst);

VOID
GetEnvParameters(
    LPSTR EnvVarName,
    LPSTR DefaultValue,
    int *pargc,
    int maxArgc,
    LPSTR argv[]);

VOID
FreeEnvParameters(int argc, LPSTR argv[]);

VOID
FreeCmdStrings(VOID);

VOID
MungePossibleTarget(
    PTARGET_MACHINE_INFO pti
    );

VOID
GetIncludePatterns(
    LPSTR EnvVarName,
    int maxArgc,
    LPSTR argv[]);

VOID
FreeIncludePatterns(
    int argc,
    LPSTR argv[]);


//+---------------------------------------------------------------------------
//
//  Function:   main
//
//----------------------------------------------------------------------------

int
__cdecl main(
    int argc,
    LPSTR argv[]
    )
{
    char c;
    PDIRREC DirDB;
    UINT i;
    int EnvArgc = 0;
    LPSTR EnvArgv[ MAX_ENV_ARG ] = {0};
    LPSTR s, s1;
    LPSTR PostBuildCmd;
    BOOL  fPauseDone = FALSE;
#if DBG
    BOOL fDebugSave;

    fDebug = 0;
#endif

    if ( getenv("NTMAKEENV") == NULL ) {
        printf("environment variable NTMAKEENV must be defined\n");
        exit(1);
    }
    strcpy(szObjDir, "obj");
    strcpy(szObjDirSlash, "obj\\");
    strcpy(szObjDirSlashStar, "obj\\*");
    strcpy(szObjDirD, "objd");
    strcpy(szObjDirSlashD, "objd\\");
    strcpy(szObjDirSlashStarD, "objd\\*");

    for (i=3; i<_NFILE; i++) {
        _close( i );
    }

    pGetFileAttributesExA = (BOOL (WINAPI *)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID))
                                GetProcAddress(GetModuleHandle("kernel32.dll"), "GetFileAttributesExA");

    if (pGetFileAttributesExA) {
        pDateTimeFile = DateTimeFile2;
    } else {
        pDateTimeFile = DateTimeFile;
    }

    InitializeCriticalSection(&TTYCriticalSection);

    s1 = getenv("COMSPEC");
    if (s1) {
        cmdexe = s1;
    } else {
        cmdexe = ( _osver & 0x8000 ) ? "command.com" : "cmd.exe";
    }

    {
        SYSTEMTIME st;
        FILETIME   ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        FileTimeToDosDateTime( &ft,
                               ((LPWORD)&BuildStartTime)+1,
                               (LPWORD)&BuildStartTime
                             );
    }

    BigBufSize = 0xFFF0;
    AllocMem(BigBufSize, &BigBuf, MT_IOBUFFER);

    // All env parsing should happen here (after the cmd line is processed)

    s = getenv("BASEDIR");
    if (s)
    {
        strcpy(NtRoot, s);
    }
    else
    {
        s = getenv("_NTROOT");
        if (!s)
            s = "\\nt";

        s1 = getenv("_NTDRIVE");
        if (!s1)
            s1 = "";

        sprintf(NtRoot, "%s%s", s1, s);
    }
    sprintf(DbMasterName, "%s\\%s", NtRoot, DBMASTER_NAME);


    s = getenv("_OBJ_ROOT");
    if (s) {
        pszObjRoot = strcpy(szObjRoot, s);
    }

    s = getenv("BUILD_ALT_DIR");
    if (s) {
        if (strlen(s) > sizeof(szObjDir) - strlen(szObjDir) - 1) {
            BuildError("environment variable BUILD_ALT_DIR may not be longer than %d characters.\n",
                    sizeof(szObjDir) - strlen(szObjDir) - 1);
            exit(1);
        }
        strcat(szObjDir, s);
        strcpy(szObjDirSlash, szObjDir);
        strcpy(szObjDirSlashStar, szObjDir);
        strcat(szObjDirSlash, "\\");
        strcat(szObjDirSlashStar, "\\*");
        strcat(LogFileName, s);
        strcat(WrnFileName, s);
        strcat(ErrFileName, s);
        strcat(IncFileName, s);
        BuildMsg("Object root set to: ==> obj%s\n", s);
    }

    s = getenv("NTDEBUG");
    if (!s || *s == '\0' || strcmp(s, "retail") == 0 || strcmp(s, "ntsdnodbg") == 0) {
        fCheckedBuild = FALSE;
    }

    s = getenv("OS2_INC_PATH");
    if (s) {
        MakeString(&pszIncOs2, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncOs2, "\\public\\sdk\\inc\\os2");
    }
    s = getenv("POSIX_INC_PATH");
    if (s) {
        MakeString(&pszIncPosix, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncPosix, "\\public\\sdk\\inc\\posix");
    }
    s = getenv("CHICAGO_INC_PATH");
    if (s) {
        MakeString(&pszIncChicago, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncChicago, "\\public\\sdk\\inc\\chicago");
    }
    s = getenv("CRT_INC_PATH");
    if (s) {
        MakeString(&pszIncCrt, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncCrt, "\\public\\sdk\\inc\\crt");
    }
    s = getenv("SDK_INC_PATH");
    if (s) {
        MakeString(&pszIncSdk, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncSdk, "\\public\\sdk\\inc");
    }
    s = getenv("OAK_INC_PATH");
    if (s) {
        MakeString(&pszIncOak, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncOak, "\\public\\oak\\inc");
    }
    s = getenv("DDK_INC_PATH");
    if (s) {
        MakeString(&pszIncDdk, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncDdk, "\\public\\ddk\\inc");
    }
    s = getenv("WDM_INC_PATH");
    if (s) {
        MakeString(&pszIncWdm, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncWdm, "\\public\\ddk\\inc\\wdm");
    }
    s = getenv("PRIVATE_INC_PATH");
    if (s) {
        MakeString(&pszIncPri, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncPri, "\\private\\inc");
    }
    s = getenv("MFC_INCLUDES");
    if (s) {
        MakeString(&pszIncMfc, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszIncMfc, "\\public\\sdk\\inc\\mfc42");
    }
    s = getenv("SDK_LIB_DEST");
    if (s) {
        MakeString(&pszSdkLibDest, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszSdkLibDest, "\\public\\sdk\\lib");
    }
    s = getenv("DDK_LIB_DEST");
    if (s) {
        MakeString(&pszDdkLibDest, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszDdkLibDest, "\\public\\sdk\\lib");
    }

    s = getenv("PUBLIC_INTERNAL_PATH");
    if (s) {
        MakeString(&pszPublicInternalPath, s, TRUE, MT_DIRSTRING);
    } else {
        MakeExpandedString(&pszPublicInternalPath, "\\public\\internal");
    }


    szBuildTag = getenv("BUILD_TAG");

    strcpy( MakeParameters, "" );
    MakeParametersTail = AppendString( MakeParameters,
                                       "/c BUILDMSG=Stop.",
                                       FALSE);

    RecurseLevel = 0;

#if DBG
    if ((s = getenv("BUILD_DEBUG_FLAG")) != NULL) {
        i = atoi(s);
        if (!isdigit(*s)) {
            i = 1;
        }
        BuildMsg("Debug Output Enabled: %u ==> %u\n", fDebug, fDebug | i);
        fDebug |= i;
    }
#endif

    if (!(MakeProgram = getenv( "BUILD_MAKE_PROGRAM" ))) {
        MakeProgram = "NMAKE.EXE";
    }

    if (s = getenv("BUILD_PATH")) {
        SetEnvironmentVariable("PATH", s);
    }

    if (s = getenv("COPYCMD")) {
        if (!strchr(s, 'y') && !strchr(s, 'Y')) {
            // COPYCMD is set, but /y isn't a part of it.  Add /Y.
            BuildMsg("Adding /Y to COPYCMD so xcopy ops won't hang.\n");
            s1 = malloc(strlen(s) + sizeof(" /Y") + 1);
            if (s1) {
                strcpy(s1, s);
                strcat(s1, " /Y");
                SetEnvironmentVariable("COPYCMD", s1);
            }
        }
    } else {
        // COPYCMD not set.  Do so.
        BuildMsg("Adding /Y to COPYCMD so xcopy ops won't hang.\n");
        SetEnvironmentVariable("COPYCMD", "/Y");
    }

    PostBuildCmd = getenv("BUILD_POST_PROCESS");

    SystemIncludeEnv = getenv( "INCLUDE" );
    GetCurrentDirectory( sizeof( CurrentDirectory ), CurrentDirectory );

    for (i = 0; i < MAX_TARGET_MACHINES; i++) {
        TargetMachines[i] = NULL;
        TargetToPossibleTarget[i] = 0;
        MungePossibleTarget(PossibleTargetMachines[i]);
    }

    if (!(BuildProduct = getenv("BUILD_PRODUCT"))) {
        BuildProduct = "";
    }

    if (!ProcessParameters( argc, argv, TRUE )) {
        fUsage = TRUE;
    } else {
        fCmdLineDependencySwitchUsed = fDependencySwitchUsed;
        fCmdLineQuicky = fQuicky;
        fCmdLineSemiQuicky = fSemiQuicky;
        fCmdLineQuickZero = fQuickZero;
        GetEnvParameters( "BUILD_DEFAULT", NULL, &EnvArgc, MAX_ENV_ARG, EnvArgv );
        GetEnvParameters( "BUILD_OPTIONS", NULL, &EnvArgc, MAX_ENV_ARG, EnvArgv );
        if (CountTargetMachines == 0) {
            if ( getenv("PROCESSOR_ARCHITECTURE") == NULL ) {
                BuildError("environment variable PROCESSOR_ARCHITECTURE must be defined\n");
                exit(1);
            }

            if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "IA64"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-ia64", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
            if (!strcmp(getenv("PROCESSOR_ARCHITECTURE"), "AMD64"))
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-amd64", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            else
                GetEnvParameters( "BUILD_DEFAULT_TARGETS", "-386", &EnvArgc, MAX_ENV_ARG, EnvArgv );
            }
        if (!ProcessParameters( EnvArgc, EnvArgv, FALSE )) {
            fUsage = TRUE;
        }
    }
    FreeEnvParameters(EnvArgc, EnvArgv);

    if (!fUsage && !fGenerateObjectsDotMacOnly) {
        if (!_stricmp(BuildProduct, "NT")) {
            if (fCmdLineDependencySwitchUsed) {
                fDependencySwitchUsed = fCmdLineDependencySwitchUsed;
                fQuicky = fCmdLineQuicky;
                fSemiQuicky = fCmdLineSemiQuicky;
                fQuickZero = fCmdLineQuickZero;
            }
            if (!fDependencySwitchUsed) {
                BuildError("(Fatal Error) One of either /D, /Z, /z, or /3 is required for NT builds\n");
                exit( 1 );
            } else {
                if (fDependencySwitchUsed == 1) {
                    if (fQuicky) {
                        BuildError("(Fatal Error) switch can not be used with /Z, /z, or /3\n");
                        exit( 1 );
                    }
                BuildMsgRaw( "BUILD: /D specified - The NT build lab will not accept build requests using this switch\n");
                }
                if (fDependencySwitchUsed == 2){
                    if (fStopAfterPassZero) {
                        BuildError("(Fatal Error) switch /0 can not be used with /z\n");
                        exit( 1 );
                    }
                }
            }
        }
    }

    GetIncludePatterns( "BUILD_ACCEPTABLE_INCLUDES", MAX_INCLUDE_PATTERNS, AcceptableIncludePatternList );
    GetIncludePatterns( "BUILD_UNACCEPTABLE_INCLUDES", MAX_INCLUDE_PATTERNS, UnacceptableIncludePatternList );

    if (( fCheckIncludePaths ) &&
        ( AcceptableIncludePatternList[ 0 ] == NULL ) &&
        ( UnacceptableIncludePatternList[ 0 ] == NULL )) {

        BuildMsgRaw( "WARNING: -# specified without BUILD_[UN]ACCEPTABLE_INCLUDES set\n" );
    }


    if (fCleanRestart) {
        if (fClean) {
            fClean = FALSE;
            fRestartClean = TRUE;
        }
        else
        if (fCleanLibs) {
            fCleanLibs = FALSE;
            fRestartCleanLibs = TRUE;
        }
        else {
            BuildError("/R switch only valid with /c or /C switch.\n");
            fUsage = TRUE;
        }
    }

    NumberProcesses = 1;
    if (fParallel || getenv("BUILD_MULTIPROCESSOR")) {
        SYSTEM_INFO SystemInfo;

        if (DefaultProcesses == 0) {
            GetSystemInfo(&SystemInfo);
            NumberProcesses = SystemInfo.dwNumberOfProcessors;
        } else {
            NumberProcesses = DefaultProcesses;
        }
        if (NumberProcesses == 1) {
            fParallel = FALSE;
        } else {
            if (NumberProcesses > 32) {
                BuildError("(Fatal Error) Number of Processes: %d exceeds max (32)\n", NumberProcesses);
                exit(1);
            }
            fParallel = TRUE;
            BuildMsg("Using %d child processes\n", NumberProcesses);
        }
    }

    if (fUsage) {
        BuildMsgRaw(
            "\nBUILD: Version %x.%02x.%04d\n\n",
            BUILD_VERSION >> 8,
            BUILD_VERSION & 0xFF,
            VER_PRODUCTBUILD);
        BuildMsgRaw(szUsage);
    }
    else
    if (CountTargetMachines != 0) {
        BuildError(
            "%s for ",
            fLinkOnly? "Link" : (fCompileOnly? "Compile" : "Compile and Link"));
        for (i = 0; i < CountTargetMachines; i++) {
            BuildErrorRaw(i==0? "%s" : ", %s", TargetMachines[i]->Description);
            AppendString(
                MakeTargets,
                TargetMachines[i]->MakeVariable,
                TRUE);

        }

        BuildErrorRaw(szNewLine);

        //
        // If there is one and only one build target and target dirs has
        // been enabled, then fill in the appropriate target dirs name.
        //

        if (CountTargetMachines == 1) {
            if (fTargetDirs == TRUE) {
                pszTargetDirs = TargetMachines[0]->TargetDirs;
                FileDesc[0].pszPattern = TargetMachines[0]->TargetDirs;
            }
        }

        if (DEBUG_1) {
            if (CountExcludeIncs) {
                BuildError("Include files that will be excluded:");
                for (i = 0; i < CountExcludeIncs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", ExcludeIncs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            if (CountOptionalDirs) {
                BuildError("Optional Directories that will be built:");
                for (i = 0; i < CountOptionalDirs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", OptionalDirs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            if (CountExcludeDirs) {
                BuildError("Directories that will be NOT be built:");
                for (i = 0; i < CountExcludeDirs; i++) {
                    BuildErrorRaw(i == 0? " %s" : ", %s", ExcludeDirs[i]);
                }
                BuildErrorRaw(szNewLine);
            }
            BuildMsg("MakeParameters == %s\n", MakeParameters);
            BuildMsg("MakeTargets == %s\n", MakeTargets);
        }

#if DBG
        fDebugSave = fDebug;
        // fDebug = 0;
#endif

        //
        // Generate the _objects.mac file if requested
        //

        if (fGenerateObjectsDotMacOnly) {
            DIRSUP DirSup;
            ULONG DateTimeSources;

            DirDB = ScanDirectory( CurrentDirectory );

            if (DirDB && (DirDB->DirFlags & (DIRDB_DIRS | DIRDB_SOURCES))) {
                if (!ReadSourcesFile(DirDB, &DirSup, &DateTimeSources)) {
                    BuildError("Current directory not a SOURCES directory.\n");
                    return( 1 );
                }

                GenerateObjectsDotMac(DirDB, &DirSup, DateTimeSources);

                FreeDirSupData(&DirSup);
                ReportDirsUsage();
                FreeCmdStrings();
                ReportMemoryUsage();
                return(0);
            }
        }

        if (!fQuery && fErrorLog) {
            strcat(LogFileName, ".log");
            if (!MyOpenFile(LogDirectory, LogFileName, "wb", &LogFile, TRUE)) {
                BuildError("(Fatal Error) Unable to open log file\n");
                exit( 1 );
            }
            CreatedBuildFile(LogDirectory, LogFileName);

            strcat(WrnFileName, ".wrn");
            if (!MyOpenFile(LogDirectory, WrnFileName, "wb", &WrnFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open warning file\n");
                exit( 1 );
            }
            CreatedBuildFile(LogDirectory, WrnFileName);

            strcat(ErrFileName, ".err");
            if (!MyOpenFile(LogDirectory, ErrFileName, "wb", &ErrFile, FALSE)) {
                BuildError("(Fatal Error) Unable to open error file\n");
                exit( 1 );
            }
            CreatedBuildFile(LogDirectory, ErrFileName);

            if ( fCheckIncludePaths ) {

                strcat( IncFileName, ".inc");
                if (!MyOpenFile( LogDirectory, IncFileName, "wb", &IncFile, FALSE ) ) {
                    BuildError( "(Fatal Error) Unable to open include log file\n");
                    exit( 1 );
                }
                CreatedBuildFile( LogDirectory, IncFileName );
            }
        }
        else {
            LogFile = NULL;
            WrnFile = NULL;
            ErrFile = NULL;
            IncFile = NULL;
        }

        s = getenv("__MTSCRIPT_ENV_ID");
        if (s) {

            if (fDependencySwitchUsed == 2 && fPause)
            {
                BuildError("Cannot combine -z (or -2) and -p switches under MTScript");
                exit(1);
            }

            // Make sure any other build.exe's that get launched as child
            // processes don't try to connect to the script engine.
            SetEnvironmentVariable("__MTSCRIPT_ENV_ID", NULL);

            g_hMTEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (g_hMTEvent != NULL)
            {
                g_hMTThread = CreateThread(NULL,
                                           0,
                                           (LPTHREAD_START_ROUTINE)MTScriptThread,
                                           NULL,
                                           0,
                                           &g_dwMTThreadId);

                if (g_hMTThread)
                {
                    // Wait for the thread to tell us it's ready.
                    WaitForSingleObject(g_hMTEvent, INFINITE);

                    ResetEvent(g_hMTEvent);

                    if (!g_hMTThread)
                    {
                        // An error occurred connecting to the script engine.
                        // We can't continue.
                        BuildError("Unable to connect to script engine. Exiting.");
                        exit(2);
                    }

                    fMTScriptSync = TRUE;
                }
                else
                {
                    BuildError("Failed to launch script handling thread! (%d)", GetLastError());

                    CloseHandle(g_hMTEvent);
                    g_hMTEvent = NULL;
                    fPause = FALSE;
                }
            }
            else
            {
                BuildError("Failed to create script communication event! (%d)", GetLastError());
                fPause = FALSE;
            }
        }

        //
        // The user should not have CHICAGO_PRODUCT in
        // their environment, as it can cause problems on other machines with
        // other users that don't have them set.  The following warning
        // messages are intended to alert the user to the presence of these
        // environment variables.
        //

        if (getenv("CHICAGO_PRODUCT") != NULL) {
            BuildError("CHICAGO_PRODUCT was detected in the environment.\n" );
            BuildMsg("   ALL directories will be built targeting Chicago!\n" );
            fChicagoProduct = TRUE;
        }

        if (!fQuicky) {
            LoadMasterDB();

            BuildError("Computing Include file dependencies:\n");

            ScanIncludeEnv(SystemIncludeEnv);
            ScanGlobalIncludeDirectory(pszIncMfc);
            ScanGlobalIncludeDirectory(pszIncOak);
            ScanGlobalIncludeDirectory(pszIncDdk);
            ScanGlobalIncludeDirectory(pszIncWdm);
            ScanGlobalIncludeDirectory(pszIncSdk);
            ScanGlobalIncludeDirectory(pszIncPri);
            CountSystemIncludeDirs = CountIncludeDirs;
        }

#if DBG
        fDebug = fDebugSave;
#endif
        fFirstScan = TRUE;
        fPassZero  = FALSE;
        ScanSourceDirectories( CurrentDirectory );

        if (!fQuicky) {
            if (SaveMasterDB() == FALSE) {
                BuildError("Unable to save the dependency database: %s\n", DbMasterName);
            }
        }

        c = '\n';
        if (!fLinkOnly && CountPassZeroDirs) {
            if (!fQuicky) {
                TotalFilesToCompile = 0;
                TotalLinesToCompile = 0L;

                for (i=0; i<CountPassZeroDirs; i++) {
                    DirDB = PassZeroDirs[ i ];

                    TotalFilesToCompile += DirDB->CountOfPassZeroFiles;
                    TotalLinesToCompile += DirDB->PassZeroLines;
                    }

                if (CountPassZeroDirs > 1 &&
                    TotalFilesToCompile != 0 &&
                    TotalLinesToCompile != 0L) {

                    BuildMsgRaw(
                        "Total of %d pass zero files (%s lines) to compile in %d directories\n\n",
                         TotalFilesToCompile,
                         FormatNumber( TotalLinesToCompile ),
                         CountPassZeroDirs);
                }
            }

            TotalFilesCompiled    = 0;
            TotalLinesCompiled    = 0L;
            ElapsedCompileTime    = 0L;

            if (fPause && !fMTScriptSync) {
                BuildMsg("Press enter to continue with compilations (or 'q' to quit)...");
                c = (char)getchar();
            }

            if ((CountPassZeroDirs > 0) && (c == '\n')) {
                CompilePassZeroDirectories();
                WaitForParallelThreads();

                //
                // Rescan now that we've generated all the generated files
                //
                CountPassZeroDirs = 0;
                CountCompileDirs = 0;
                CountLinkDirs = 0;

                UnsnapAllDirectories();

                fPassZero = FALSE;
                fFirstScan = FALSE;
                RecurseLevel = 0;

                if (fMTScriptSync) {
                    WaitForResume(fPause, PE_PASS0_COMPLETE);

                    fPauseDone = TRUE;
                }

                // This will compile directories if fQuicky is TRUE
                if (!fStopAfterPassZero) {
                    ScanSourceDirectories( CurrentDirectory );
                    }

                if (!fQuicky) {
                    if (SaveMasterDB() == FALSE) {
                        BuildError("Unable to save the dependency database: %s\n", DbMasterName);
                    }
                }
            }
        }

        if (fMTScriptSync && !fPauseDone) {
            WaitForResume(fPause, PE_PASS0_COMPLETE);
        }

        if (fStopAfterPassZero) {
            BuildError("Stopping after pass zero requested: Pass0 done.\n");
        }

        if (!fStopAfterPassZero && !fLinkOnly && (c == '\n')) {
            if (!fQuicky) {
                TotalFilesToCompile = 0;
                TotalLinesToCompile = 0L;

                for (i=0; i<CountCompileDirs; i++) {
                    DirDB = CompileDirs[ i ];

                    TotalFilesToCompile += DirDB->CountOfFilesToCompile;
                    TotalLinesToCompile += DirDB->SourceLinesToCompile;
                    }

                if (CountCompileDirs > 1 &&
                    TotalFilesToCompile != 0 &&
                    TotalLinesToCompile != 0L) {

                    BuildMsgRaw(
                        "Total of %d source files (%s lines) to compile in %d directories\n\n",
                         TotalFilesToCompile,
                         FormatNumber( TotalLinesToCompile ),
                         CountCompileDirs);
                }
            }

            TotalFilesCompiled    = 0;
            TotalLinesCompiled    = 0L;
            ElapsedCompileTime    = 0L;

            if (fPause && !fMTScriptSync) {
                BuildMsg("Press enter to continue with compilations (or 'q' to quit)...");
                c = (char)getchar();
            }

            if (c == '\n') {
                // Does nothing if fQuicky is TRUE
                CompileSourceDirectories();
                WaitForParallelThreads();
            }
        }

        if (fMTScriptSync) {
            WaitForResume(fPause, PE_PASS1_COMPLETE);
        }

        if (!fStopAfterPassZero && !fCompileOnly && (c == '\n')) {
            LinkSourceDirectories();
            WaitForParallelThreads();
        }

        if (!fStopAfterPassZero && PostBuildCmd && !fMTScriptSync) {
            // If there's a post build process to invoke, do so but only if
            // not running under the buildcon.

            // PostBuildCmd is of the form <message to display><command to execute>
            // The Message is delimiated with curly brackets.  ie:
            // POST_BUILD_PROCESS={Do randomness}randomness.cmd

            // would display:
            //
            //     BUILD: Do randomness
            //
            // while randomness.cmd was running.  The process is run synchronously and
            // we've still got the i/o pipes setup so any output will be logged to
            // build.log (and wrn/err if formated correctly)

            if (*PostBuildCmd == '{') {
                LPSTR PostBuildMessage = PostBuildCmd+1;
                LogMsg("Executing post build scripts %s\n", szAsterisks);
                while (*PostBuildCmd && *PostBuildCmd != '}')
                    PostBuildCmd++;

                if (*PostBuildCmd == '}') {
                    *PostBuildCmd = '\0';
                    PostBuildCmd++;
                    BuildMsg("%s\n", PostBuildMessage);
                    LogMsg("%s\n", PostBuildMessage);
                    ExecuteProgram(PostBuildCmd, "", "", TRUE);
                }
            } else {
                ExecuteProgram(PostBuildCmd, "", "", TRUE);
            }
        }

        if (fShowTree) {
            for (i = 0; i < CountShowDirs; i++) {
                PrintDirDB(ShowDirs[i], 1|4);
            }
        }
    }
    else {
        BuildError("No target machine specified\n");
    }

    if (!fUsage && !fQuery && fErrorLog) {
        ULONG cbLogMin = 32;
        ULONG cbWarnMin = 0;

        if (!fAlwaysKeepLogfile) {
            if (fQuicky && !fSemiQuicky && ftell(ErrFile) == 0) {
                cbLogMin = cbWarnMin = ULONG_MAX;
            }
        }
        CloseOrDeleteFile(&LogFile, LogDirectory, LogFileName, cbLogMin);
        CloseOrDeleteFile(&WrnFile, LogDirectory, WrnFileName, cbWarnMin);
        CloseOrDeleteFile(&ErrFile, LogDirectory, ErrFileName, 0L);
        if ( fCheckIncludePaths ) {
            CloseOrDeleteFile(&IncFile, LogDirectory, IncFileName, cbLogMin);
        }
    }
    BuildError("Done\n\n");

    if (fMTScriptSync) {
        WaitForResume(FALSE, PE_PASS2_COMPLETE);
    }

    if (NumberCompiles) {
        BuildMsgRaw("    %d file%s compiled", NumberCompiles, NumberCompiles == 1 ? "" : "s");
        if (NumberCompileWarnings) {
            BuildMsgRaw(" - %d Warning%s", NumberCompileWarnings, NumberCompileWarnings == 1 ? "" : "s");
        }
        if (NumberCompileErrors) {
            BuildMsgRaw(" - %d Error%s", NumberCompileErrors, NumberCompileErrors == 1 ? "" : "s");
        }

        if (ElapsedCompileTime) {
            BuildMsgRaw(" - %5ld LPS", TotalLinesCompiled / ElapsedCompileTime);
        }

        BuildMsgRaw(szNewLine);
    }

    if (NumberLibraries) {
        BuildMsgRaw("    %d librar%s built", NumberLibraries, NumberLibraries == 1 ? "y" : "ies");
        if (NumberLibraryWarnings) {
            BuildMsgRaw(" - %d Warning%s", NumberLibraryWarnings, NumberLibraryWarnings == 1 ? "" : "s");
        }
        if (NumberLibraryErrors) {
            BuildMsgRaw(" - %d Error%s", NumberLibraryErrors, NumberLibraryErrors == 1 ? "" : "s");
        }
        BuildMsgRaw(szNewLine);
    }

    if (NumberLinks) {
        BuildMsgRaw("    %d executable%sbuilt", NumberLinks, NumberLinks == 1 ? " " : "s ");
        if (NumberLinkWarnings) {
            BuildMsgRaw(" - %d Warning%s", NumberLinkWarnings, NumberLinkWarnings == 1 ? "" : "s");
        }
        if (NumberLinkErrors) {
            BuildMsgRaw(" - %d Error%s", NumberLinkErrors, NumberLinkErrors == 1 ? "" : "s");
        }
        BuildMsgRaw(szNewLine);
    }

    if (NumberBinplaces) {
        BuildMsgRaw("    %d file%sbinplaced", NumberBinplaces, NumberBinplaces == 1 ? " " : "s ");
        if (NumberBinplaceWarnings) {
            BuildMsgRaw(" - %d Warning%s", NumberBinplaceWarnings, NumberBinplaceWarnings == 1 ? "" : "s");
        }
        if (NumberBinplaceErrors) {
            BuildMsgRaw(" - %d Error%s", NumberBinplaceErrors, NumberBinplaceErrors == 1 ? "" : "s");
        }
        BuildMsgRaw(szNewLine);
    }

    ReportDirsUsage();
    FreeCmdStrings();
    FreeIncludePatterns( MAX_INCLUDE_PATTERNS, AcceptableIncludePatternList );
    FreeIncludePatterns( MAX_INCLUDE_PATTERNS, UnacceptableIncludePatternList );
    ReportMemoryUsage();

    ExitMTScriptThread();

    if (NumberCompileErrors || NumberLibraryErrors || NumberLinkErrors || NumberBinplaceErrors || fUsage) {
        return 1;
    }
    else {
        return( 0 );
    }
}


VOID
ReportDirsUsage( VOID )
{
    ULONG i;
    BOOLEAN fHeaderPrinted;

    if (!fShowUnusedDirs) {
        return;
    }

    fHeaderPrinted = FALSE;
    for (i=0; i<CountOptionalDirs; i++) {
        if (!OptionalDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_OPTIONS:" );
                fHeaderPrinted = TRUE;
            }
            printf( " %s", OptionalDirs[i] );
        }
    }

    for (i=0; i<CountExcludeDirs; i++) {
        if (!ExcludeDirsUsed[i]) {
            if (!fHeaderPrinted) {
                printf( "Unused BUILD_OPTIONS:" );
                fHeaderPrinted = TRUE;
            }
            printf( " ~%s", ExcludeDirs[i] );
        }
    }

    if (fHeaderPrinted) {
        printf( "\n" );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetObjDir
//
//----------------------------------------------------------------------------

VOID
SetObjDir(BOOL fAlternate)
{
    iObjectDir = 0;
    if (fCheckedBuild) {
        if (fAlternate) {
            pszObjDir = szObjDirD;
            pszObjDirSlash = szObjDirSlashD;
            pszObjDirSlashStar = szObjDirSlashStarD;
            iObjectDir = 1;
        } else {
            pszObjDir = szObjDir;
            pszObjDirSlash = szObjDirSlash;
            pszObjDirSlashStar = szObjDirSlashStar;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   AddTargetMachine
//
//----------------------------------------------------------------------------

VOID
AddTargetMachine(UINT iTarget)
{
    UINT i;

    for (i = 0; i < CountTargetMachines; i++) {
        if (TargetMachines[i] == PossibleTargetMachines[iTarget]) {
            assert(TargetToPossibleTarget[i] == iTarget);
            return;
        }
    }
    assert(CountTargetMachines < MAX_TARGET_MACHINES);
    TargetToPossibleTarget[CountTargetMachines] = iTarget;
    TargetMachines[CountTargetMachines++] = PossibleTargetMachines[iTarget];
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessParameters
//
//----------------------------------------------------------------------------

BOOL
ProcessParameters(
    int argc,
    LPSTR argv[],
    BOOL SkipFirst
    )
{
    char c, *p;
    int i;
    BOOL Result;

    if (DEBUG_1) {
        BuildMsg("Parsing:");
        for (i=1; i<argc; i++) {
            BuildMsgRaw(" %s", argv[i]);
        }
        BuildMsgRaw(szNewLine);
    }

    Result = TRUE;
    if (SkipFirst) {
        --argc;
        ++argv;
    }
    while (argc) {
        p = *argv;
        if (*p == '/' || *p == '-') {
            if (DEBUG_1) {
                BuildMsg("Processing \"-%s\" switch\n", p+1);
            }

            for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                if (!_stricmp(p, PossibleTargetMachines[i]->Switch) ||
                    !_stricmp(p, PossibleTargetMachines[i]->Switch2)) {
                    AddTargetMachine(i);
                    break;
                }
            }

            if (i < MAX_TARGET_MACHINES) {
            }
            else
            if (!_stricmp(p + 1, "all")) {
                for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                    AddTargetMachine(i);
                }
            }
            else
            if (!_stricmp(p + 1, "why")) {
                fWhyBuild = TRUE;
            }
            else
            while (c = *++p)
                switch (toupper( c )) {
            case '?':
                fUsage = TRUE;
                break;

            case '$':
                fDebug += 2;    // yes, I want to *add* 2.
                break;

            case '#':
                fCheckIncludePaths = TRUE;
                fForce = TRUE;
                break;

            case '0':
                fStopAfterPassZero = TRUE;
                if (!fDependencySwitchUsed)
                    fDependencySwitchUsed = 3;
                break;

            case '1':
                fQuicky = TRUE;
                if (!fDependencySwitchUsed)
                    fDependencySwitchUsed = 2;
                break;

            case '2':
                fSemiQuicky = TRUE;
                fQuicky = TRUE;
                if (!fDependencySwitchUsed)
                    fDependencySwitchUsed = 2;
                break;

            case '3':
                fQuickZero = TRUE;
                fSemiQuicky = TRUE;
                fQuicky = TRUE;
                if (!fDependencySwitchUsed)
                    fDependencySwitchUsed = 3;
                break;

            case 'A':
                fSyncLink = TRUE;
                break;

            case 'B':
                fFullErrors = TRUE;
                break;

            case 'C':
                if (!_stricmp( p, "clean" )) {
                        MakeParametersTail = AppendString( MakeParametersTail,
                                                           "clean",
                                                           TRUE);
                        *p-- = '\0';
                }
                else
                if (c == 'C') {
                    fCleanLibs = TRUE;
                }
                else {
                    fClean = TRUE;
                }
                break;

            case 'D':
                if (c == 'D') {
                    fDependencySwitchUsed = 1;
                }
#if DBG
                else {
                    fDebug |= 1;
                }
                break;
#endif
            case 'E':
                if (c == 'E') {
                    fAlwaysKeepLogfile = TRUE;
                }
                fErrorLog = TRUE;
                break;

            case 'F':
                if (c == 'F') {
                    fAlwaysPrintFullPath = TRUE;
                } else {
                    fForce = TRUE;
                }
                break;

            case 'G':
                fTargetDirs = TRUE;
                break;

            case 'I':
                if (c == 'I') {
                   fNoThreadIndex = TRUE;
                }
                else  {
                   BuildMsgRaw( "BUILD: /i switch ignored\n");
                }
                break;

            case 'J': {

                argc--, argv++;

                if (!_stricmp( p, "jpath" )) {
                    // Allow BuildConsole to redirect the logfiles
                    strncpy(LogDirectory, *argv, sizeof(LogDirectory) - 1);
                    *p-- = '\0';
                }
                else
                {
                    // Clear it out
                    memset(LogFileName, 0, sizeof(LogFileName));
                    memset(WrnFileName, 0, sizeof(WrnFileName));
                    memset(ErrFileName, 0, sizeof(ErrFileName));
                    memset(IncFileName, 0, sizeof(IncFileName));

                    // And set it to the arg passed in.
                    strncpy(LogFileName, *argv, sizeof(LogFileName) - 4);
                    strncpy(WrnFileName, *argv, sizeof(WrnFileName) - 4);
                    strncpy(ErrFileName, *argv, sizeof(ErrFileName) - 4);
                    strncpy(IncFileName, *argv, sizeof(IncFileName) - 4);
                }
                break;
            }

            case 'K':
                fKeep = TRUE;
                break;

            case 'L':
                if (c == 'L') {
                    fCompileOnly = TRUE;
                }
                else {
                    fLinkOnly = TRUE;
                }
                break;

            case 'M':
                if (c == 'M') {
                    fParallel = TRUE;
                    if (--argc) {
                        DefaultProcesses = atoi(*++argv);
                        if (DefaultProcesses == 0) {
                            --argv;
                            ++argc;
                        }
                    } else {
                        ++argc;
                    }
                } else {
                    SetPriorityClass(GetCurrentProcess(),IDLE_PRIORITY_CLASS);
                }
                break;

            case 'N':
                if (_stricmp( p, "nmake") == 0) {
                    if (--argc) {
                        ++argv;
                        MakeParametersTail = AppendString( MakeParametersTail,
                                                           *argv,
                                                           TRUE);
                    }
                    else {
                        argc++;
                        BuildError("Argument to /NMAKE switch missing\n");
                        Result = FALSE;
                    }
                    *p-- = '\0';
                    break;
                }

            case 'O':
                if (c == 'O') {
                    fGenerateObjectsDotMacOnly = TRUE;
                }
                else {
                    fShowOutOfDateFiles = TRUE;
                }
                break;

            case 'P':
                if (c == 'P') {
                    fPrintElapsed = TRUE;
                } else {
                    fPause = TRUE;
                }
                break;

            case 'Q':
                fQuery = TRUE;
                break;

            case 'R':
                if (--argc) {
                    fCleanRestart = TRUE;
                    ++argv;
                    CopyString(RestartDir, *argv, TRUE);
                }
                else {
                    argc++;
                    BuildError("Argument to /R switch missing\n");
                    Result = FALSE;
                }
                break;

            case 'S':
                fStatus = TRUE;
                if (c == 'S') {
                    fStatusTree = TRUE;
                }
                break;

            case 'T':
                fShowTree = TRUE;
                if (c == 'T') {
                    fShowTreeIncludes = TRUE;
                    }
                break;

            case 'U':
                fShowUnusedDirs = TRUE;
                break;

            case 'V':
                fEnableVersionCheck = TRUE;
                break;

            case 'W':
                fShowWarningsOnScreen = TRUE;
                break;

            case 'X':
                if (--argc) {
                    ++argv;
                    if (CountExcludeIncs >= MAX_EXCLUDE_INCS) {
                        static BOOL fError = FALSE;

                        if (!fError) {
                            BuildError(
                                "-x argument table overflow, using first %u entries\n",
                                MAX_EXCLUDE_INCS);
                            fError = TRUE;
                        }
                    }
                    else {
                        MakeString(
                            &ExcludeIncs[CountExcludeIncs++],
                            *argv,
                            TRUE,
                            MT_CMDSTRING);
                    }
                }
                else {
                    argc++;
                    BuildError("Argument to /X switch missing\n");
                    Result = FALSE;
                }
                break;

            case 'Y':
                fNoisyScan = TRUE;
                break;

            case 'Z':
                fQuickZero = TRUE;
                fSemiQuicky = TRUE;
                fQuicky = TRUE;
                if (!fDependencySwitchUsed)
                    fDependencySwitchUsed = 3;
                break;

            default:
                BuildError("Invalid switch - /%c\n", c);
                Result = FALSE;
                break;
            }
        }
        else
        if (*p == '~') {
            if (CountExcludeDirs >= MAX_EXCLUDE_DIRECTORIES) {
                static BOOL fError = FALSE;

                if (!fError) {
                    BuildError(
                        "Exclude directory table overflow, using first %u entries\n",
                        MAX_EXCLUDE_DIRECTORIES);
                    fError = TRUE;
                }
            }
            else {
                MakeString(
                    &ExcludeDirs[CountExcludeDirs++],
                    p + 1,
                    TRUE,
                    MT_CMDSTRING);
            }
        }
        else {
            for (i = 0; i < MAX_TARGET_MACHINES; i++) {
                if (!_stricmp(p, PossibleTargetMachines[i]->MakeVariable)) {
                    AddTargetMachine(i);
                    break;
                }
            }
            if (i >= MAX_TARGET_MACHINES) {
                if (iscsym(*p) || *p == '.') {
                    if (CountOptionalDirs >= MAX_OPTIONAL_DIRECTORIES) {
                        static BOOL fError = FALSE;

                        if (!fError) {
                            BuildError(
                                "Optional directory table overflow, using first %u entries\n",
                                MAX_OPTIONAL_DIRECTORIES);
                            fError = TRUE;
                        }
                    }
                    else {
                        MakeString(
                            &OptionalDirs[CountOptionalDirs++],
                            p,
                            TRUE,
                            MT_CMDSTRING);
                    }
                }
                else
                if (!strcmp(p, "*")) {
                    BuildAllOptionalDirs = TRUE;
                }
                else {
                    MakeParametersTail = AppendString(
                                            MakeParametersTail,
                                            p,
                                            TRUE);
                }
            }
        }
        --argc;
        ++argv;
    }
    return(Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetEnvParameters
//
//----------------------------------------------------------------------------

VOID
GetEnvParameters(
    LPSTR EnvVarName,
    LPSTR DefaultValue,
    int *pargc,
    int maxArgc,
    LPSTR argv[]
    )
{
    LPSTR p, p1, psz;

    if (!(p = getenv(EnvVarName))) {
        if (DefaultValue == NULL) {
            return;
        }
        else {
            p = DefaultValue;
        }
    }
    else {
        if (DEBUG_1) {
            BuildMsg("Using %s=%s\n", EnvVarName, p);
        }
    }

    MakeString(&psz, p, FALSE, MT_CMDSTRING);
    p1 = psz;
    while (*p1) {
        while (*p1 <= ' ') {
            if (!*p1) {
                break;
            }
            p1++;
        }
        p = p1;
        while (*p > ' ') {
            if (*p == '#') {
                *p = '=';
            }
            p++;
        }
        if (*p) {
            *p++ = '\0';
        }
        MakeString(&argv[*pargc], p1, FALSE, MT_CMDSTRING);
        if ((*pargc += 1) >= maxArgc) {
            BuildError("Too many parameters (> %d)\n", maxArgc);
            exit(1);
        }
        p1 = p;
    }
    FreeMem(&psz, MT_CMDSTRING);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeEnvParameters
//
//----------------------------------------------------------------------------

VOID
FreeEnvParameters(int argc, LPSTR argv[])
{
    while (--argc >= 0) {
        FreeMem(&argv[argc], MT_CMDSTRING);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeCmdStrings
//
//----------------------------------------------------------------------------

VOID
FreeCmdStrings(VOID)
{
#if DBG
    UINT i;

    for (i = 0; i < CountExcludeIncs; i++) {
        FreeMem(&ExcludeIncs[i], MT_CMDSTRING);
    }
    for (i = 0; i < CountOptionalDirs; i++) {
        FreeMem(&OptionalDirs[i], MT_CMDSTRING);
    }
    for (i = 0; i < CountExcludeDirs; i++) {
        FreeMem(&ExcludeDirs[i], MT_CMDSTRING);
    }
    // It's possible the user may have done:
    // <global macro> = <null>

    // in a sources file.  Don't free mem unless it's still set...

    if (pszSdkLibDest)
        FreeMem(&pszSdkLibDest, MT_DIRSTRING);
    if (pszDdkLibDest)
        FreeMem(&pszDdkLibDest, MT_DIRSTRING);
    if (pszPublicInternalPath)
        FreeMem(&pszPublicInternalPath, MT_DIRSTRING);
    if (pszIncOs2)
        FreeMem(&pszIncOs2, MT_DIRSTRING);
    if (pszIncPosix)
        FreeMem(&pszIncPosix, MT_DIRSTRING);
    if (pszIncChicago)
        FreeMem(&pszIncChicago, MT_DIRSTRING);
    if (pszIncMfc)
        FreeMem(&pszIncMfc, MT_DIRSTRING);
    if (pszIncSdk)
        FreeMem(&pszIncSdk, MT_DIRSTRING);
    if (pszIncCrt)
        FreeMem(&pszIncCrt, MT_DIRSTRING);
    if (pszIncOak)
        FreeMem(&pszIncOak, MT_DIRSTRING);
    if (pszIncDdk)
        FreeMem(&pszIncDdk, MT_DIRSTRING);
    if (pszIncWdm)
        FreeMem(&pszIncWdm, MT_DIRSTRING);
    if (pszIncPri)
        FreeMem(&pszIncPri, MT_DIRSTRING);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   MungePossibleTarget
//
//----------------------------------------------------------------------------

VOID
MungePossibleTarget(
    PTARGET_MACHINE_INFO pti
    )
{
    PCHAR s;
    char *pszDir;

    if (!pti) {
        return;
    }

    // save "i386" string

    pszDir = pti->ObjectDirectory[0];

    // Create "$(_OBJ_DIR)\i386" string

    s = malloc(12 + strlen(pszDir) + 1);
    if (!s)
        return;
    sprintf(s, "$(_OBJ_DIR)\\%s", pszDir);
    pti->ObjectMacro = s;

    // Create "obj$(BUILD_ALT_DIR)\i386" string for default obj dir

    s = malloc(strlen(szObjDir) + 1 + strlen(pszDir) + 1);
    if (!s)
        return;
    sprintf(s, "%s\\%s", szObjDir, pszDir);
    pti->ObjectDirectory[0] = s;

    // Create "objd\i386" string for alternate checked obj dir

    s = malloc(strlen(szObjDirD) + 1 + strlen(pszDir) + 1);
    if (!s)
        return;
    sprintf(s, "%s\\%s", szObjDirD, pszDir);
    pti->ObjectDirectory[1] = s;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIncludePatterns
//
//----------------------------------------------------------------------------

VOID
GetIncludePatterns(
    LPSTR EnvVarName,
    int maxArgc,
    LPSTR argv[]
    )
{
    LPSTR p, p1, psz;
    int argc;

    argc = 0;

    if ( ( p = getenv(EnvVarName ) ) == NULL ) {
        return;
    }

    MakeString( &psz, p, FALSE, MT_DIRSTRING );

    p1 = psz;
    while ( *p1 ) {
        while ( *p1 == ';' || *p1 == ' ' ) {
            p1++;
        }
        p = p1;
        while ( *p && *p != ';' ) {
            p++;
        }
            if ( *p ) {
            *p++ = '\0';
        }
        MakeString( &argv[argc], p1, FALSE, MT_DIRSTRING );
        if ( ( argc += 1 ) == maxArgc ) {
            BuildError( "Too many include patterns ( > %d)\n", maxArgc );
            exit( 1 );
        }

        p1 = p;
    }

    FreeMem(&psz, MT_DIRSTRING);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeIncludePatterns
//
//----------------------------------------------------------------------------

VOID
FreeIncludePatterns(int argc, LPSTR argv[])
{
    while ( argc ) {
        if ( argv[--argc] ) {
            FreeMem( &argv[argc], MT_DIRSTRING );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\build.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

--*/

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       build.h
//
//  Contents:   Main Include file for build.exe
//
//  History:    16-May-89     SteveWo  Created
//              26-Jul-94     LyleC    Cleanup/Add Support for Pass0
//
//----------------------------------------------------------------------------

#include <assert.h>
#include <process.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>

#define INC_OLE2

#include <windows.h>

#define UINT DWORD
#define HDIR HANDLE


VOID
ClearLine(VOID);


//
// Types and Constant Definitions
//

#if DBG
#define DEBUG_1 (fDebug & 1)
#else
#define DEBUG_1 FALSE
#endif

BOOL fDebug;
#define DEBUG_2 (fDebug & 3)
#define DEBUG_4 (fDebug & 4)

//
// Target specific dirs file name.
//

extern LPSTR pszTargetDirs;

#define MAX_TARGET_MACHINES 3

typedef struct _TARGET_MACHINE_INFO {
    UCHAR SourceSubDirMask;     // TMIDIR_I386
    LPSTR Description;          // "i386"
    LPSTR Switch;               // "-386"
    LPSTR Switch2;              // "-x86"
    LPSTR MakeVariable;         // "386=1"
    LPSTR SourceVariable;       // "i386_SOURCES"
    LPSTR ObjectVariable;       // "386_OBJECTS"
    LPSTR AssociateDirectory;   // "i386"
    LPSTR SourceDirectory;      // "i386"
    LPSTR TargetDirs;           // "i386dirs"
    LPSTR ObjectDirectory[2];   // "i386" -- initialize only first entry
    ULONG DirIncludeMask;       // Platform/Group/etc.
    LPSTR ObjectMacro;          // don't initialize

} TARGET_MACHINE_INFO, *PTARGET_MACHINE_INFO;

#define DIR_INCLUDE_NONE     0x00000000
#define DIR_INCLUDE_X86      0x00000001
//                           0x00000002
#define DIR_INCLUDE_IA64     0x00000004
//                           0x00000008
#define DIR_INCLUDE_WIN32    0x00000010
#define DIR_INCLUDE_WIN64    0x00000020
#define DIR_INCLUDE_RISC     0x00000040
#define DIR_INCLUDE_AMD64    0x00000080
#define DIR_INCLUDE_ALL      0xffffffff

// It's possible to have SOURCES= entries of the following forms:
//      entry           SourceSubDirMask
//      -----           ----------------
//      foo.c                    0
//      i386\foo.c               1
//      amd64\foo.c              2
//      ia64\foo.c               4
//      ..\foo.c                80
//      ..\i386\foo.c           81
//      ..\amd64\foo.c          82
//      ..\ia64\foo.c           84

#define TMIDIR_I386     0x0001
#define TMIDIR_AMD64    0x0002
#define TMIDIR_IA64     0x0004
#define TMIDIR_PARENT   0x0080  // or'd in with above bits


#define SIG_DIRREC      0x44644464      // "DdDd"

#ifdef SIG_DIRREC
#define SIG_FILEREC     0x46664666      // "FfFf"
#define SIG_INCLUDEREC  0x49694969      // "IiIi"
#define SIG_SOURCEREC   0x53735373      // "SsSs"
#define SigCheck(s)     s
#else
#define SigCheck(s)
#endif

#define AssertDir(pdr) \
        SigCheck(assert((pdr) != NULL && (pdr)->Sig == SIG_DIRREC))

#define AssertOptionalDir(pdr) \
        SigCheck(assert((pdr) == NULL || (pdr)->Sig == SIG_DIRREC))

#define AssertFile(pfr) \
        SigCheck(assert((pfr) != NULL && (pfr)->Sig == SIG_FILEREC))

#define AssertOptionalFile(pfr) \
        SigCheck(assert((pfr) == NULL || (pfr)->Sig == SIG_FILEREC))

#define AssertInclude(pir) \
        SigCheck(assert((pir) != NULL && (pir)->Sig == SIG_INCLUDEREC))

#define AssertOptionalInclude(pir) \
        SigCheck(assert((pir) == NULL || (pir)->Sig == SIG_INCLUDEREC))

#define AssertSource(psr) \
        SigCheck(assert((psr) != NULL && (psr)->Sig == SIG_SOURCEREC))

#define AssertOptionalSource(psr) \
        SigCheck(assert((psr) == NULL || (psr)->Sig == SIG_SOURCEREC))

//
// Information about source directories is stored an in-memory database.
// The information is saved on disk by writing the contents of the database
// to "build.dat".  It is reloaded from disk for subsequent invocations,
// and re-written only when it has been updated.
//


typedef struct _INCLUDEREC {
    SigCheck(ULONG Sig;)
    struct _INCLUDEREC *Next;     // static list describes original arcs
    struct _INCLUDEREC *NextTree; // dynamic list -- cycles are collapsed
    struct _FILEREC *pfrCycleRoot;
    struct _FILEREC *pfrInclude;
    USHORT Version;
    USHORT IncFlags;
    char Name[1];
} INCLUDEREC, *PINCLUDEREC;


#define INCLUDEDB_LOCAL         0x0001  // include "foo.h"
#define INCLUDEDB_POST_HDRSTOP  0x0002  // appears after #pragma hdrstop
#define INCLUDEDB_MISSING       0x0400  // include file was once missing
#define INCLUDEDB_GLOBAL        0x0800  // include file is in global directory
#define INCLUDEDB_SNAPPED       0x1000  // include file snapped
#define INCLUDEDB_CYCLEALLOC    0x2000  // allocated to flatten cycle
#define INCLUDEDB_CYCLEROOT     0x4000  // moved to root file to flatten cycle
#define INCLUDEDB_CYCLEORPHAN   0x8000  // orphaned to flatten cycle

// Flags preserved when loading build.dat:

#define INCLUDEDB_DBPRESERVE    (INCLUDEDB_LOCAL | INCLUDEDB_POST_HDRSTOP)



#define IsCleanTree(pir)        \
  ((pir)->NextTree == NULL &&   \
   ((pir)->IncFlags &           \
    (INCLUDEDB_CYCLEALLOC | INCLUDEDB_CYCLEROOT | INCLUDEDB_CYCLEORPHAN)) == 0)


#if DBG
VOID AssertCleanTree(INCLUDEREC *pir, OPTIONAL struct _FILEREC *pfr);
#else
#define AssertCleanTree(pir, pfr)       assert(IsCleanTree(pir))
#endif

//
// Make file description structure definition.
//

typedef struct _FILEDESC {
    LPSTR   pszPattern;         //  pattern to match file name
    LPSTR   pszCommentToEOL;    //  comment-to-eol string
    BOOL    fNeedFileRec;       //  TRUE => file needs a file record
    ULONG   FileFlags;          //  flags to be set in file record
    ULONG   DirFlags;           //  flags to be set in directory record
} FILEDESC;

extern FILEDESC FileDesc[];

typedef struct _FILEREC {
    SigCheck(ULONG Sig;)
    struct _FILEREC *Next;
    struct _DIRREC *Dir;
    INCLUDEREC *IncludeFiles;       // static list describes original arcs
    INCLUDEREC *IncludeFilesTree;   // dynamic list -- cycles are collapsed
    struct _FILEREC *NewestDependency;
    LPSTR  pszCommentToEOL;         // comment-to-eol string in source
    ULONG  DateTime;
    ULONG  DateTimeTree;            // Newest DateTime for included tree
    ULONG  TotalSourceLines;        // line count in all included files
    ULONG  FileFlags;
    ULONG  SourceLines;
    USHORT Attr;
    USHORT SubDirIndex;
    USHORT Version;
    USHORT GlobalSequence;          // Sequence number for dynamic include tree
    USHORT LocalSequence;           // Sequence number for dynamic include tree
    USHORT idScan;                  // id used for detecting multiple inclusion
    USHORT CheckSum;                // Name checksum
    UCHAR fDependActive;
    char Name[1];
} FILEREC, *PFILEREC;

#define MAKE_DATE_TIME( date, time )    \
    ((ULONG)(((USHORT)(time)) | ((ULONG)((USHORT)(date))) << 16))

#define FILEDB_SOURCE           0x00000001
#define FILEDB_DIR              0x00000002
#define FILEDB_HEADER           0x00000004
#define FILEDB_ASM              0x00000008
#define FILEDB_MASM             0x00000010
#define FILEDB_RC               0x00000020
#define FILEDB_C                0x00000040
#define FILEDB_MIDL             0x00000080
#define FILEDB_ASN              0x00000100
#define FILEDB_JAVA             0x00000200
#define FILEDB_MOF              0x00000400
#define FILEDB_CSHARP           0x00000800
#define FILEDB_SCANNED          0x00001000
#define FILEDB_OBJECTS_LIST     0x00002000
#define FILEDB_FILE_MISSING     0x00004000
#define FILEDB_MKTYPLIB         0x00008000
#define FILEDB_MULTIPLEPASS     0x00010000
#define FILEDB_PASS0            0x00020000
#define FILEDB_SOURCEREC_EXISTS 0x00040000

// Flags preserved when loading build.dat:

#define FILEDB_DBPRESERVE       (FILEDB_SOURCE |       \
                                 FILEDB_DIR |          \
                                 FILEDB_HEADER |       \
                                 FILEDB_ASM |          \
                                 FILEDB_MASM |         \
                                 FILEDB_RC |           \
                                 FILEDB_C |            \
                                 FILEDB_MIDL |         \
                                 FILEDB_ASN |          \
                                 FILEDB_JAVA |         \
                                 FILEDB_MOF |          \
                                 FILEDB_CSHARP |       \
                                 FILEDB_MKTYPLIB |     \
                                 FILEDB_MULTIPLEPASS | \
                                 FILEDB_PASS0)


typedef struct _SOURCEREC {
    SigCheck(ULONG Sig;)
    struct _SOURCEREC *psrNext;
    FILEREC *pfrSource;
    UCHAR SourceSubDirMask;
    UCHAR SrcFlags;
} SOURCEREC;

#define SOURCEDB_SOURCES_LIST           0x01
#define SOURCEDB_FILE_MISSING           0x02
#define SOURCEDB_PCH                    0x04
#define SOURCEDB_OUT_OF_DATE            0x08
#define SOURCEDB_COMPILE_NEEDED         0x10


typedef struct _DIRSUP {
    LPSTR TestType;
    LPSTR LocalIncludePath;
    LPSTR PchIncludeDir;
    LPSTR PchInclude;
    LPSTR PchTargetDir;
    LPSTR PchTarget;
    LPSTR PassZeroHdrDir;
    LPSTR PassZeroSrcDir1;
    LPSTR PassZeroSrcDir2;
    LPSTR ConditionalIncludes;
    ULONG DateTimeSources;
    ULONG IdlType;
    ULONG fNoTarget;
    LPSTR SourcesVariables[MAX_TARGET_MACHINES + 1];
    SOURCEREC *psrSourcesList[MAX_TARGET_MACHINES + 1];
} DIRSUP;


typedef struct _DIRREC {
    SigCheck(ULONG Sig;)
    struct _DIRREC *Next;
    DIRSUP *pds;                 // Used to preserve info from pass zero
    PFILEREC Files;
    LPSTR TargetPath;
    LPSTR TargetPathLib;
    LPSTR TargetName;
    LPSTR TargetExt;
    LPSTR KernelTest;
    LPSTR UserAppls;
    LPSTR UserTests;
    LPSTR NTTargetFile0;
    LPSTR Pch;
    LPSTR PchObj;
    LONG SourceLinesToCompile;
    LONG PassZeroLines;
    ULONG DirFlags;
    ULONG RecurseLevel;
    USHORT FindCount;
    USHORT CountSubDirs;
    SHORT CountOfFilesToCompile;
    SHORT CountOfPassZeroFiles;
    USHORT CheckSum;                // Name checksum
    char Name[1];
} DIRREC, *PDIRREC;


#define DIRDB_SOURCES           0x00000001
#define DIRDB_DIRS              0x00000002
#define DIRDB_MAKEFILE          0x00000004
#define DIRDB_MAKEFIL0          0x00000008
#define DIRDB_TARGETFILE0       0x00000010
#define DIRDB_TARGETFILES       0x00000020
#define DIRDB_RESOURCE          0x00000040
#define DIRDB_PASS0             0x00000080

#define DIRDB_SOURCES_SET       0x00000100

#define DIRDB_CHICAGO_INCLUDES  0x00000800

#define DIRDB_NEW               0x00001000
#define DIRDB_SCANNED           0x00002000
#define DIRDB_SHOWN             0x00004000
#define DIRDB_GLOBAL_INCLUDES   0x00008000

#define DIRDB_SYNCHRONIZE_BLOCK 0x00010000
#define DIRDB_SYNCHRONIZE_DRAIN 0x00020000
#define DIRDB_COMPILENEEDED     0x00040000
#define DIRDB_COMPILEERRORS     0x00080000

#define DIRDB_SOURCESREAD       0x00100000
#define DIRDB_DLLTARGET         0x00200000
#define DIRDB_LINKNEEDED        0x00400000
#define DIRDB_FORCELINK         0x00800000
#define DIRDB_PASS0NEEDED       0x01000000
#define DIRDB_MAKEFIL1          0x02000000
#define DIRDB_CHECKED_ALT_DIR   0x04000000

// Flags preserved when loading build.dat:

#define DIRDB_DBPRESERVE        0



typedef struct _TARGET {
    FILEREC *pfrCompiland;
    DIRREC *pdrBuild;
    LPSTR pszSourceDirectory;
    LPSTR ConditionalIncludes;
    ULONG DateTime;
    ULONG DirFlags;
    char Name[1];
} TARGET, *PTARGET;


#define BUILD_VERSION           0x0403
#define DBMASTER_NAME           "build.dat"
#define DB_MAX_PATH_LENGTH      256

// If you change or add any values to this enum,
// also fix MemTab in buildutl.c:

typedef enum _MemType {
    MT_TOTALS = 0,
    MT_UNKNOWN,

    MT_CHILDDATA,
    MT_CMDSTRING,
    MT_DIRDB,
    MT_DIRSUP,
    MT_DIRPATH,
    MT_DIRSTRING,
    MT_EVENTHANDLES,
    MT_FILEDB,
    MT_FILEREADBUF,
    MT_FRBSTRING,
    MT_INCLUDEDB,
    MT_IOBUFFER,
    MT_MACRO,
    MT_SOURCEDB,
    MT_TARGET,
    MT_THREADFILTER,
    MT_THREADHANDLES,
    MT_THREADSTATE,

    MT_INVALID = 255,
} MemType;

struct _THREADSTATE;

typedef BOOL (*FILTERPROC)(struct _THREADSTATE *ThreadState, LPSTR p);

typedef struct _THREADSTATE {
    USHORT cRowTotal;
    USHORT cColTotal;
    BOOL IsStdErrTty;
    FILE *ChildOutput;
    UINT ChildState;
    UINT ChildFlags;
    LPSTR ChildTarget;
    UINT LinesToIgnore;
    FILTERPROC FilterProc;
    ULONG ThreadIndex;
    CHAR UndefinedId[ DB_MAX_PATH_LENGTH ];
    CHAR ChildCurrentDirectory[ DB_MAX_PATH_LENGTH ];
    CHAR ChildCurrentFile[ DB_MAX_PATH_LENGTH ];
    DIRREC *CompileDirDB;
} THREADSTATE, *PTHREADSTATE;

//
// Global Data (uninit will always be FALSE)
//

BOOL fUsage;                     // Set when usage message is to be displayed
BOOL fStatus;                    // Set by -s and -S options
BOOL fStatusTree;                // Set by -S option
BOOL fShowTree;                  // Set by -t and -T options
BOOL fShowTreeIncludes;          // Set by -T option
BOOL fClean;                     // Set by -c option
BOOL fCleanLibs;                 // Set by -C option
BOOL fCleanRestart;              // Set by -r option
BOOL fRestartClean;              // Set if -c and -r were both given
BOOL fRestartCleanLibs;          // Set if -C and -r were both given
BOOL fPause;                     // Set by -p option
BOOL fParallel;                  // Set on a multiprocessor machine or by -M
BOOL fPrintElapsed;              // Set by -P option
BOOL fQuery;                     // Set by -q option
BOOL fStopAfterPassZero;         // Set by -0 option
BOOL fQuicky;                    // Set by -z and -Z options
BOOL fQuickZero;                 // Set by -3
BOOL fSemiQuicky;                // Set by -Z option
BOOL fShowOutOfDateFiles;        // Set by -o option
BOOL fSyncLink;                  // Set by -a option
BOOL fForce;                     // Set by -f option
BOOL fEnableVersionCheck;        // Set by -v option
BOOL fSilent;                    // Set by -i option
BOOL fKeep;                      // Set by -k option
BOOL fCompileOnly;               // Set by -L option
BOOL fLinkOnly;                  // Set by -l option
BOOL fErrorLog;                  // Set by -e option
BOOL fGenerateObjectsDotMacOnly; // Set by -O option
BOOL fShowWarningsOnScreen;      // Set by -w option
BOOL fNoisyScan;                 // Set by -y option
BOOL fFullErrors;                // Set by -b option
BOOL fWhyBuild;                  // Set by -why option
BOOL fChicagoProduct;            // Set if CHICAGO_PRODUCT is set in environment
BOOL fLineCleared;               // Current line on screen clear?
BOOL fPassZero;                  // Indicates we've found pass zero dirs
BOOL fFirstScan;                 // Indicates this is the first scan
BOOL fAlwaysPrintFullPath;       // Set by -F option
BOOL fTargetDirs;                // Set by -g option
BOOL fAlwaysKeepLogfile;         // Set by -E option
BOOL fShowUnusedDirs;            // Set by -u option
BOOL fCheckIncludePaths;         // Set by -# option
BOOL fNoThreadIndex;             // Set by -I option
BOOL fMTScriptSync;              // Set when communicating with the MTScript engine

#define MAX_INCLUDE_PATTERNS 32

LPSTR AcceptableIncludePatternList[ MAX_INCLUDE_PATTERNS + 1 ];
LPSTR UnacceptableIncludePatternList[ MAX_INCLUDE_PATTERNS + 1 ];

LPSTR MakeProgram;
char MakeParameters[ 512 ];
LPSTR MakeParametersTail;
char MakeTargets[ 256 ];
char RestartDir[ 256 ];
char NtRoot[ 256 ];
char DbMasterName[ 256 ];
extern const char szNewLine[];

char *pszSdkLibDest;
char *pszDdkLibDest;
char *pszPublicInternalPath;
char *pszIncOak;
char *pszIncDdk;
char *pszIncWdm;
char *pszIncSdk;
char *pszIncMfc;
char *pszIncCrt;
char *pszIncPri;
char *pszIncOs2;
char *pszIncPosix;
char *pszIncChicago;

char *szBuildTag;
char *pszObjDir;
char *pszObjDirSlash;
char *pszObjDirSlashStar;
BOOL fCheckedBuild;
ULONG iObjectDir;
extern ULONG NumberProcesses;
CRITICAL_SECTION TTYCriticalSection;

CHAR const *cmdexe;

LONG TotalFilesToCompile;
LONG TotalFilesCompiled;

LONG TotalLinesToCompile;
LONG TotalLinesCompiled;

ULONG ElapsedCompileTime;
DIRREC *CurrentCompileDirDB;

// Fixed length arrays...

UINT CountTargetMachines;
TARGET_MACHINE_INFO *TargetMachines[MAX_TARGET_MACHINES];
TARGET_MACHINE_INFO *PossibleTargetMachines[MAX_TARGET_MACHINES];
TARGET_MACHINE_INFO i386TargetMachine;
TARGET_MACHINE_INFO ia64TargetMachine;
TARGET_MACHINE_INFO Amd64TargetMachine;
UINT TargetToPossibleTarget[MAX_TARGET_MACHINES];


#define MAX_OPTIONAL_DIRECTORIES        256
UINT CountOptionalDirs;
LPSTR OptionalDirs[MAX_OPTIONAL_DIRECTORIES];
BOOLEAN OptionalDirsUsed[MAX_OPTIONAL_DIRECTORIES];
BOOL BuildAllOptionalDirs;


#define MAX_EXCLUDE_DIRECTORIES         MAX_OPTIONAL_DIRECTORIES
UINT CountExcludeDirs;
LPSTR ExcludeDirs[MAX_EXCLUDE_DIRECTORIES];
BOOLEAN ExcludeDirsUsed[MAX_OPTIONAL_DIRECTORIES];


#define MAX_EXCLUDE_INCS                128
UINT CountExcludeIncs;
LPSTR ExcludeIncs[MAX_EXCLUDE_INCS];


#define MAX_INCLUDE_DIRECTORIES         128
UINT CountIncludeDirs;
UINT CountSystemIncludeDirs;
DIRREC *IncludeDirs[MAX_INCLUDE_DIRECTORIES];



#define MAX_BUILD_DIRECTORIES           8192

UINT CountPassZeroDirs;
DIRREC *PassZeroDirs[MAX_BUILD_DIRECTORIES];

UINT CountCompileDirs;
DIRREC *CompileDirs[MAX_BUILD_DIRECTORIES];

UINT CountLinkDirs;
DIRREC *LinkDirs[MAX_BUILD_DIRECTORIES];

UINT CountShowDirs;
DIRREC *ShowDirs[MAX_BUILD_DIRECTORIES];



DIRREC *AllDirs;
CHAR CurrentDirectory[DB_MAX_PATH_LENGTH];

BOOL AllDirsInitialized;
BOOL AllDirsModified;

USHORT GlobalSequence;
USHORT LocalSequence;

BOOLEAN fConsoleInitialized;
DWORD NewConsoleMode;

LPSTR BuildDefault;
LPSTR BuildParameters;

LPSTR SystemIncludeEnv;
LPSTR LocalIncludeEnv;

LPSTR BigBuf;
UINT BigBufSize;

UINT RecurseLevel;

FILE *LogFile;
FILE *WrnFile;
FILE *ErrFile;
FILE *IPGScriptFile;
FILE *IncFile;

EXTERN_C UINT NumberCompileWarnings;
EXTERN_C UINT NumberCompileErrors;
EXTERN_C UINT NumberCompiles;
EXTERN_C UINT NumberLibraries;
EXTERN_C UINT NumberLibraryWarnings;
EXTERN_C UINT NumberLibraryErrors;
EXTERN_C UINT NumberLinks;
EXTERN_C UINT NumberLinkWarnings;
EXTERN_C UINT NumberLinkErrors;
EXTERN_C UINT NumberBinplaces;
EXTERN_C UINT NumberBinplaceWarnings;
EXTERN_C UINT NumberBinplaceErrors;

char szAsterisks[];
ULONG BuildStartTime;

VOID ReportDirsUsage(VOID);

VOID SetObjDir(BOOL fAlternate);

//
// Stuff defined in buildscr.cpp
//

typedef enum _PROC_EVENTS
{
    PE_PASS0_COMPLETE = WM_USER,
    PE_PASS1_COMPLETE,
    PE_PASS2_COMPLETE,
    PE_EXIT
} PROC_EVENTS;


EXTERN_C HANDLE g_hMTThread;
EXTERN_C HANDLE g_hMTEvent;
EXTERN_C DWORD  g_dwMTThreadId;

EXTERN_C DWORD WINAPI MTScriptThread(LPVOID pv);
EXTERN_C void WaitForResume(BOOL fPause, PROC_EVENTS pe);
EXTERN_C void ExitMTScriptThread();

//
// Data Base functions defined in builddb.c
//

PDIRREC
LoadDirDB(LPSTR DirName);

#if DBG
VOID
PrintAllDirs(VOID);
#endif

VOID
PrintSourceDBList(SOURCEREC *psr, int i);

VOID
PrintFileDB(FILE *pf, FILEREC *pfr, int DetailLevel);

VOID
PrintDirDB(DIRREC *pdr, int DetailLevel);

FILEREC *
FindSourceFileDB(DIRREC *pdr, LPSTR pszRelPath, DIRREC **ppdr);

DIRREC *
FindSourceDirDB(
    LPSTR pszDir,               // directory
    LPSTR pszRelPath,           // relative path
    BOOL fTruncateFileName);    // TRUE: drop last component of path

SOURCEREC *
FindSourceDB(
    SOURCEREC *psr,
    FILEREC *pfr);

SOURCEREC *
InsertSourceDB(
    SOURCEREC **ppsrNext,
    FILEREC *pfr,
    UCHAR SubDirMask,
    UCHAR SrcFlags);

VOID
FreeSourceDB(SOURCEREC **ppsr);

VOID
UnsnapIncludeFiles(FILEREC *pfr, BOOL fUnsnapGlobal);

VOID
UnsnapAllDirectories(VOID);

VOID
FreeAllDirs(VOID);

PFILEREC
LookupFileDB(
    PDIRREC DirDB,
    LPSTR FileName);


PFILEREC
InsertFileDB(
    PDIRREC DirDB,
    LPSTR FileName,
    ULONG DateTime,
    USHORT Attr,
    ULONG  FileFlags);

VOID
DeleteUnscannedFiles(PDIRREC DirDB);

PINCLUDEREC
InsertIncludeDB(
    PFILEREC FileDB,
    LPSTR IncludeFileName,
    USHORT IncFlags);

VOID
LinkToCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot);

VOID
RemoveFromCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot);

VOID
MergeIncludeFiles(FILEREC *pfr, INCLUDEREC *pirList, FILEREC *pfrRoot);

VOID
MarkIncludeFileRecords(PFILEREC FileDB);

VOID
DeleteIncludeFileRecords(PFILEREC FileDB);

PFILEREC
FindIncludeFileDB(
    FILEREC *pfrSource,
    FILEREC *pfrCompiland,
    DIRREC *pdrBuild,
    LPSTR pszSourceDirectory,
    INCLUDEREC *IncludeDB);

BOOL
SaveMasterDB(VOID);

void
LoadMasterDB(VOID);

PDIRREC
LoadMasterDirDB(LPSTR s);

PFILEREC
LoadMasterFileDB(LPSTR s);

PINCLUDEREC
LoadMasterIncludeDB(LPSTR s);


//
// Scanning functions defined in buildscn.c
//

VOID
AddIncludeDir(DIRREC *pdr, UINT *pui);

VOID
AddShowDir(DIRREC *pdr);

VOID
ScanGlobalIncludeDirectory(LPSTR path);

VOID
ScanIncludeEnv(LPSTR IncludeEnv);

PDIRREC
ScanDirectory(LPSTR DirName);

BOOL
ScanFile(PFILEREC FileDB);


//
// Functions defined in buildmak.c
//

VOID
ScanSourceDirectories(LPSTR DirName);

VOID
CompilePassZeroDirectories(VOID);

VOID
CompileSourceDirectories(VOID);

VOID
LinkSourceDirectories(VOID);


VOID
FreeDirSupData(DIRSUP *pds);

VOID
FreeDirData(DIRREC *pdr);

BOOL
CheckDependencies(
    PTARGET Target,
    FILEREC *FileDB,
    BOOL CheckDate,
    FILEREC **ppFileDBRoot);

BOOL
CreateBuildDirectory(LPSTR Name);

VOID
CreatedBuildFile(LPSTR DirName, LPSTR FileName);

VOID
GenerateObjectsDotMac(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources);

VOID
ExpandObjAsterisk(
    LPSTR pbuf,
    LPSTR pszpath,
    LPSTR *ppszObjectDirectory);

//
// Build -# functions defined in buildinc.c
//

LPCTSTR
FindCountedSequenceInString(
    IN LPCTSTR String,
    IN LPCTSTR Sequence,
    IN DWORD   Length);

BOOL
DoesInstanceMatchPattern(
    IN LPCTSTR Instance,
    IN LPCTSTR Pattern);

LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath);

VOID
CreateRelativePath(
    IN  LPCSTR SourceAbsName,
    IN  LPCSTR TargetAbsName,
    OUT LPSTR  RelativePath);

BOOL
ShouldWarnInclude(
    IN LPCSTR CompilandFullName,
    IN LPCSTR IncludeeFullName);

VOID
CheckIncludeForWarning(
    IN LPCSTR CompilandDir,
    IN LPCSTR CompilandName,
    IN LPCSTR IncluderDir,
    IN LPCSTR IncluderName,
    IN LPCSTR IncludeeDir,
    IN LPCSTR IncludeeName);

//
// Utility functions defined in buildutl.c
//

VOID
AllocMem(UINT cb, VOID **ppv, MemType mt);

VOID
FreeMem(VOID **ppv, MemType mt);

VOID
ReportMemoryUsage(VOID);


BOOL
MyOpenFile(
    LPSTR DirName,
    LPSTR FileName,
    LPSTR Access,
    FILE **Stream,
    BOOL fBufferedIO);

BOOL
OpenFilePush(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    );

BOOL
SetupReadFile(LPSTR pszdir, LPSTR pszfile, LPSTR pszCommentToEOL,
              FILE **ppf);

ULONG
CloseReadFile(UINT *pcline);

LPSTR
ReadLine(FILE *pf);

UINT
ProbeFile(
    LPSTR DirName,
    LPSTR FileName);

BOOL
EnsureDirectoriesExist(
    LPSTR DirName);

ULONG
DateTimeFile(
    LPSTR DirName,
    LPSTR FileName);

ULONG
DateTimeFile2(
    LPSTR DirName,
    LPSTR FileName);

ULONG (*pDateTimeFile)(LPSTR, LPSTR);

BOOL (WINAPI * pGetFileAttributesExA)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

BOOL
DeleteSingleFile(
    LPSTR DirName,
    LPSTR FileName,
    BOOL QuietFlag);

BOOL
DeleteMultipleFiles(
    LPSTR DirName,
    LPSTR FilePattern);

BOOL
CloseOrDeleteFile(
    FILE **Stream,
    LPSTR DirName,
    LPSTR FileName,
    ULONG SizeThreshold);

LPSTR
PushCurrentDirectory(LPSTR NewCurrentDirectory);

VOID
PopCurrentDirectory(LPSTR OldCurrentDirectory);

UINT
ExecuteProgram(
    LPSTR ProgramName,
    LPSTR CommandLine,
    LPSTR MoreCommandLine,
    BOOL MustBeSynchronous);

VOID
WaitForParallelThreads(VOID);


BOOL
CanonicalizePathName(
    LPSTR SourcePath,
    UINT Action,
    LPSTR FullPath);


#define CANONICALIZE_ONLY 0
#define CANONICALIZE_FILE 1
#define CANONICALIZE_DIR  2

LPSTR
FormatPathName(
    LPSTR DirName,
    LPSTR FileName);

#if DBG
VOID
AssertPathString(LPSTR pszPath);
#else
#define AssertPathString(p)
#endif

LPSTR
AppendString(
    LPSTR Destination,
    LPSTR Source,
    BOOL PrefixWithSpace);

LPSTR CopyString(LPSTR Destination, LPSTR Source, BOOL fPath);
VOID  MakeString(LPSTR *Destination, LPSTR Source, BOOL fPath, MemType mt);
VOID  MakeExpandedString(LPSTR *Destination, LPSTR Source);
VOID  FreeString(LPSTR *Source, MemType mt);
LPSTR FormatNumber(ULONG Number);
LPSTR FormatTime(ULONG Seconds);

BOOL AToX(LPSTR *pp, ULONG *pul);
BOOL AToD(LPSTR *pp, ULONG *pul);
EXTERN_C VOID __cdecl LogMsg(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildMsg(const char *pszfmt, ...);
VOID __cdecl BuildMsgRaw(const char *pszfmt, ...);
VOID __cdecl BuildError(const char *pszfmt, ...);
EXTERN_C VOID __cdecl BuildErrorRaw(const char *pszfmt, ...);

//
// Functions in buildsrc.c
//

VOID
StartElapsedTime(VOID);

VOID
PrintElapsedTime(VOID);

BOOL
ReadDirsFile(DIRREC *DirDB);


VOID
ProcessLinkTargets(PDIRREC DirDB, LPSTR CurrentDirectory);

BOOL
SplitToken(LPSTR pbuf, char chsep, LPSTR *ppstr);

BOOL
MakeMacroString(LPSTR *pp, LPSTR p);

VOID
SaveMacro(LPSTR pszName, LPSTR pszValue);

VOID
FormatLinkTarget(
    LPSTR path,
    LPSTR *ObjectDirectory,
    LPSTR TargetPath,
    LPSTR TargetName,
    LPSTR TargetExt);

BOOL
ReadSourcesFile(DIRREC *DirDB, DIRSUP *pds, ULONG *pDateTimeSources);

VOID
PostProcessSources(DIRREC *pdr, DIRSUP *pds);

VOID
PrintDirSupData(DIRSUP *pds);

//+---------------------------------------------------------------------------
//
//  Function:   IsFullPath
//
//----------------------------------------------------------------------------

__inline BOOL
IsFullPath(char *pszfile)
{
    return(pszfile[0] == '\\' || (isalpha(pszfile[0]) && pszfile[1] == ':'));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\builddb.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       builddb.c
//
//  Contents:   Contains the file and directory database manipulation
//              functions.
//
//  History:    16-May-94     SteveWo  Created
//                 ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add Pass0 Support
//
//----------------------------------------------------------------------------

#include "build.h"

BOOL fAssertCleanTree = FALSE;

typedef struct _FLAGSTRINGS {
    ULONG Mask;
    LPSTR pszName;
} FLAGSTRINGS;

FLAGSTRINGS DirFlags[] = {
    { DIRDB_SOURCES,          "Sources" },
    { DIRDB_DIRS,             "Dirs" },
    { DIRDB_MAKEFILE,         "Makefile" },
    { DIRDB_MAKEFIL0,           "Makefil0" },
    { DIRDB_TARGETFILE0,        "Targetfile0" },
    { DIRDB_TARGETFILES,        "Targetfiles" },
    { DIRDB_RESOURCE,           "Resource" },
    { DIRDB_PASS0,              "PassZero" },
    { DIRDB_SOURCES_SET,        "SourcesSet" },
    { DIRDB_CHICAGO_INCLUDES,   "ChicagoIncludes" },
    { DIRDB_NEW,                "New" },
    { DIRDB_SCANNED,            "Scanned" },
    { DIRDB_SHOWN,              "Shown" },
    { DIRDB_GLOBAL_INCLUDES,    "GlobalIncludes" },
    { DIRDB_SYNCHRONIZE_BLOCK,  "SynchronizeBlock" },
    { DIRDB_SYNCHRONIZE_DRAIN,  "SynchronizeDrain" },
    { DIRDB_COMPILENEEDED,      "CompileNeeded" },
    { DIRDB_COMPILEERRORS,      "CompileErrors" },
    { DIRDB_SOURCESREAD,        "SourcesRead" },
    { DIRDB_DLLTARGET,          "DllTarget" },
    { DIRDB_LINKNEEDED,         "LinkNeeded" },
    { DIRDB_FORCELINK,          "ForceLink" },
    { DIRDB_PASS0NEEDED,        "Pass0Needed" },
    { DIRDB_MAKEFIL1,           "Makefil1" },
    { DIRDB_CHECKED_ALT_DIR,    "CheckedAltDir" },
    { 0,                        NULL },
};

FLAGSTRINGS FileFlags[] = {
    { FILEDB_SOURCE,            "Source" },
    { FILEDB_DIR,               "Dir" },
    { FILEDB_HEADER,            "Header" },
    { FILEDB_ASM,               "Asm" },
    { FILEDB_MASM,              "Masm" },
    { FILEDB_RC,                "Rc" },
    { FILEDB_C,                 "C" },
    { FILEDB_MIDL,              "Midl" },
    { FILEDB_ASN,               "Asn" },
    { FILEDB_JAVA,              "Java" },
    { FILEDB_MOF,               "ManagedObjectFormat" },
    { FILEDB_CSHARP,            "C#"},
    { FILEDB_SCANNED,           "Scanned" },
    { FILEDB_OBJECTS_LIST,      "ObjectsList" },
    { FILEDB_FILE_MISSING,      "FileMissing" },
    { FILEDB_MKTYPLIB,          "MkTypeLib" },
    { FILEDB_MULTIPLEPASS,      "MultiplePass" },
    { FILEDB_PASS0,             "PassZero" },
    { 0,                        NULL },
};

FLAGSTRINGS IncludeFlags[] = {
    { INCLUDEDB_LOCAL,        "Local" },
    { INCLUDEDB_POST_HDRSTOP,   "PostHdrStop" },
    { INCLUDEDB_MISSING,        "Missing" },
    { INCLUDEDB_GLOBAL,         "Global" },
    { INCLUDEDB_SNAPPED,        "Snapped" },
    { INCLUDEDB_CYCLEALLOC,     "CycleAlloc" },
    { INCLUDEDB_CYCLEROOT,      "CycleRoot" },
    { INCLUDEDB_CYCLEORPHAN,    "CycleOrphan" },
    { 0,                        NULL },
};

FLAGSTRINGS SourceFlags[] = {
    { SOURCEDB_SOURCES_LIST,    "SourcesList" },
    { SOURCEDB_FILE_MISSING,    "FileMissing" },
    { SOURCEDB_PCH,             "Pch" },
    { SOURCEDB_OUT_OF_DATE,     "OutOfDate" },
    { SOURCEDB_COMPILE_NEEDED,  "CompileNeeded" },
    { 0,                        NULL },
};

//
// Function prototypes
//

VOID
FreeFileDB(PFILEREC *FileDB);

VOID
PrintFlags(FILE *pf, ULONG Flags, FLAGSTRINGS *pfs);


//+---------------------------------------------------------------------------
//
//  Function:   CheckSum
//
//  Synopsis:   Returns a checksum value for a string.
//
//----------------------------------------------------------------------------

USHORT
CheckSum(LPSTR psz)
{
    USHORT sum = 0;

    while (*psz != '\0') {
        if (sum & 0x8000) {
            sum = ((sum << 1) | 1) + *psz++;
        }
        else {
            sum = (sum << 1) + *psz++;
        }
    }
    return(sum);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceDirDB
//
//  Synopsis:   Builds a path from the two given components and returns
//              a filled DIRREC structure from it.
//
//  Arguments:  [pszDir]            -- Directory
//              [pszRelPath]        -- Path relative to [pszDir]
//              [fTruncateFileName] -- Remove a filename from [pszRelPath]
//
//  Returns:    A filled DIRREC structure for the given directory.
//
//  Notes:      If the directory does not exist in the data base, then a
//              DIRREC structure will be returned with the DIRDB_NEW flag
//              set and no other data (i.e.  the directory will not have
//              been scanned.)
//
//----------------------------------------------------------------------------

DIRREC *
FindSourceDirDB(
    LPSTR pszDir,               // directory
    LPSTR pszRelPath,           // relative path
    BOOL fTruncateFileName)     // TRUE: drop last component of path
{
    LPSTR pszFile;
    char path[DB_MAX_PATH_LENGTH];

    AssertPathString(pszDir);
    AssertPathString(pszRelPath);
    strcpy(path, pszDir);
    if (path[0] != '\0')
        strcat(path, "\\");
    strcat(path, pszRelPath);

    pszFile = path + strlen(path);
    if (fTruncateFileName) {
        while (pszFile > path) {
            pszFile--;
            if (*pszFile == '\\' || *pszFile == '/') {
                *pszFile = '\0';
                break;
            }
        }
    }
    if (!CanonicalizePathName(path, CANONICALIZE_ONLY, path)) {
        return(NULL);
    }
    if (DEBUG_4) {
        BuildMsgRaw(
            "FindSourceDirDB(%s, %s, %u)\n",
            path,
            pszFile,
            fTruncateFileName);
    }
    AssertPathString(path);
    return(LoadDirDB(path));
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceFileDB
//
//  Synopsis:   Returns a FILEREC with information about the given file.
//
//  Arguments:  [pdr]        -- DIRREC giving directory from which to start
//                                looking for [pszRelPath]
//              [pszRelPath] -- Relative path from [pdr] of the file
//              [ppdr]       -- [out] DIRREC of directory actually containing
//                                the file.  Can be NULL.
//
//  Returns:    FILEREC for file of interest.
//
//  Notes:      If the directory containing the file has not yet been scanned,
//              then it will be scanned using ScanDirectory().
//
//----------------------------------------------------------------------------

FILEREC *
FindSourceFileDB(
    DIRREC *pdr,
    LPSTR pszRelPath,
    DIRREC **ppdr)
{
    LPSTR p, pszFile;

    AssertPathString(pszRelPath);

    if (strchr(pszRelPath, '\\') != NULL) {
        // There's a path component in this filename.  Let's see where it points to.
        if ( (pszRelPath[0] == '\\') ||   /* Absolute from root or UNC Path */
             (pszRelPath[1] == ':' ))     /* drive : path  */
        {
            pdr = FindSourceDirDB("", pszRelPath, TRUE);
        } else {
            pdr = FindSourceDirDB(pdr->Name, pszRelPath, TRUE);
        }
    }
    if (ppdr != NULL) {
        *ppdr = pdr;
    }
    if (pdr == NULL ) {
        return(NULL);
    }
    pszFile = pszRelPath;
    for (p = pszFile; *p != '\0'; p++) {
        if (*p == '\\') {
            pszFile = p + 1;
        }
    }
    if (DEBUG_4) {
        BuildMsgRaw("FindSourceFileDB(%s, %s)\n", pdr->Name, pszFile);
    }

    //
    // Scan the directory containing the file if we haven't already.
    //
    if ((pdr->DirFlags & DIRDB_SCANNED) == 0) {
        if (DEBUG_1) {
            BuildMsgRaw(
                "FindSourceFileDB(%s, %s) Delayed scan\n",
                pdr->Name,
                pszFile);
        }
        pdr = ScanDirectory(pdr->Name);
        if (pdr == NULL) {
            return(NULL);
        }
    }

    return(LookupFileDB(pdr, pszFile));
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertSourceDB
//
//  Synopsis:   Insert a file listed in SOURCES= into a list of SOURCEREC
//              structures.
//
//  Arguments:  [ppsrNext]   -- Head of list of sources files to add to.
//              [pfr]        -- File to be inserted.
//              [SubDirMask] -- Indicates what directory the file is in.
//                                 (Current, Parent, or a machine-specific dir)
//              [SrcFlags]   -- SOURCEDB flags appropriate to this file.
//
//  Returns:    SOURCEREC that was inserted. May be ignored.
//
//  Notes:      InsertSourceDB maintains a sort order for PickFirst() based
//              first on the filename extension, then on the subdirectory
//              mask.
//
//              Two exceptions to the alphabetic sort are:
//                   - No extension sorts last.
//                   - .rc extension sorts first.
//
//              If the file is already in the list of sources then this
//              function just updates the flags and returns.
//
//----------------------------------------------------------------------------

SOURCEREC *
InsertSourceDB(
    SOURCEREC **ppsrNext,
    FILEREC *pfr,
    UCHAR SubDirMask,
    UCHAR SrcFlags)
{
    SOURCEREC *psr;
    SOURCEREC **ppsrInsert;
    LPSTR pszext;
    BOOL fRC;

    AssertFile(pfr);

    ppsrInsert = NULL;
    pszext = strrchr(pfr->Name, '.');
    fRC = FALSE;
    if (pszext != NULL && _stricmp(pszext, ".rc") == 0) {
        fRC = TRUE;
    }
    for ( ; (psr = *ppsrNext) != NULL; ppsrNext = &psr->psrNext) {
        LPSTR p;
        int r;

        AssertSource(psr);
        if (psr->pfrSource == pfr) {
            assert(psr->SourceSubDirMask == SubDirMask);
            psr->SrcFlags = SrcFlags;
            return(psr);
        }
        if (ppsrInsert == NULL && pszext != NULL) {
            if ((p = strrchr(psr->pfrSource->Name, '.')) == NULL) {
                r = -1;                 // insert new file here
            }
            else {
                r = strcmp(pszext, p);
                if (r != 0) {
                    if (fRC) {
                        r = -1;         // insert new RC file here
                    }
                    else if (strcmp(p, ".rc") == 0) {
                        r = 1;          // old RC file comes first
                    }
                }
            }
            if (r < 0 || SubDirMask > psr->SourceSubDirMask) {
                ppsrInsert = ppsrNext;
            }
        }
    }
    AllocMem(sizeof(SOURCEREC), &psr, MT_SOURCEDB);
    memset(psr, 0, sizeof(*psr));
    SigCheck(psr->Sig = SIG_SOURCEREC);

    if (ppsrInsert != NULL) {
        ppsrNext = ppsrInsert;
    }
    psr->psrNext = *ppsrNext;
    *ppsrNext = psr;

    psr->pfrSource = pfr;
    pfr->FileFlags |= FILEDB_SOURCEREC_EXISTS;
    psr->SourceSubDirMask = SubDirMask;
    psr->SrcFlags = SrcFlags;
    return(psr);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindSourceDB
//
//  Synopsis:   Finds the SOURCEREC in a list which corresponds to the given
//              FILEREC.
//
//----------------------------------------------------------------------------

SOURCEREC *
FindSourceDB(
    SOURCEREC *psr,
    FILEREC *pfr)
{

    while (psr != NULL) {
        AssertSource(psr);
        if (psr->pfrSource == pfr) {
            return(psr);
        }
        psr = psr->psrNext;
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeSourceDB
//
//  Synopsis:   Frees a list of SOURCERECs
//
//  Arguments:  [ppsr] -- List to free
//
//----------------------------------------------------------------------------

VOID
FreeSourceDB(SOURCEREC **ppsr)
{
    if (*ppsr != NULL) {
        SOURCEREC *psr;
        SOURCEREC *psrNext;

        psr = *ppsr;
        AssertSource(psr);
        psrNext = psr->psrNext;
        SigCheck(psr->Sig = 0);
        FreeMem(ppsr, MT_SOURCEDB);
        *ppsr = psrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeIncludeDB
//
//----------------------------------------------------------------------------

VOID
FreeIncludeDB(INCLUDEREC **ppir)
{
    if (*ppir != NULL) {
        INCLUDEREC *pir;
        INCLUDEREC *pirNext;

        pir = *ppir;
        AssertInclude(pir);
        AssertCleanTree(pir, NULL);      // Tree must be clean
        pirNext = pir->Next;
        SigCheck(pir->Sig = 0);
        FreeMem(ppir, MT_INCLUDEDB);
        *ppir = pirNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeFileDB
//
//----------------------------------------------------------------------------

VOID
FreeFileDB(FILEREC **ppfr)
{
    if (*ppfr != NULL) {
        FILEREC *pfr;
        FILEREC *pfrNext;

        pfr = *ppfr;
        AssertFile(pfr);
        UnsnapIncludeFiles(pfr, TRUE);
        while (pfr->IncludeFiles) {
            FreeIncludeDB(&pfr->IncludeFiles);
        }
        pfrNext = pfr->Next;
        SigCheck(pfr->Sig = 0);
        FreeMem(ppfr, MT_FILEDB);
        *ppfr = pfrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeDirDB
//
//----------------------------------------------------------------------------

VOID
FreeDirDB(DIRREC **ppdr)
{
    if (*ppdr != NULL) {
        DIRREC *pdr;
        DIRREC *pdrNext;

        pdr = *ppdr;
        AssertDir(pdr);
        FreeDirData(pdr);
        while (pdr->Files) {
            FreeFileDB(&pdr->Files);
        }
        pdrNext = pdr->Next;
        SigCheck(pdr->Sig = 0);
        FreeMem(ppdr, MT_DIRDB);
        *ppdr = pdrNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeAllDirs
//
//----------------------------------------------------------------------------

VOID
FreeAllDirs(VOID)
{
    while (AllDirs != NULL) {
        FreeDirDB(&AllDirs);
#if DBG
        if (fDebug & 8) {
            BuildMsgRaw("Freed one directory\n");
            PrintAllDirs();
        }
#endif
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupDirDB
//
//  Synopsis:   Searches the database for a given directory.
//
//  Arguments:  [DirName] -- Directory to search for.
//
//  Returns:    DIRREC of the given directory.  NULL if not found.
//
//  Notes:      If the directory is not in the database it will not be added.
//              Use LoadDirDB in this case.
//
//----------------------------------------------------------------------------

PDIRREC
LookupDirDB(
    LPSTR DirName
    )
{
    PDIRREC *DirDBNext = &AllDirs;
    PDIRREC DirDB;
    USHORT sum;

    AssertPathString(DirName);
    sum = CheckSum(DirName);
    while (DirDB = *DirDBNext) {
        if (sum == DirDB->CheckSum && strcmp(DirName, DirDB->Name) == 0) {

            if (DirDB->FindCount == 0 && fForce) {
                FreeDirDB(DirDBNext);
                return(NULL);
            }
            DirDB->FindCount++;

            // Move to head of list to make next lookup faster

            // *DirDBNext = DirDB->Next;
            // DirDB->Next = AllDirs;
            // AllDirs = DirDB;

            return(DirDB);
        }
        DirDBNext = &DirDB->Next;
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadDirDB
//
//  Synopsis:   Searches the database for a directory name, and if not found
//              creates a new DIRREC entry in the database.
//
//  Arguments:  [DirName] -- Directory to search for.
//
//  Returns:    Filled in DIRREC structure for the given directory.
//
//  Notes:      The directory will not be scanned if it wasn't in the
//              database.  Use ScanDirectory to scan the directory,
//              however, note that InsertSourceDB will automatically scan
//              the directory only when necessary.
//
//----------------------------------------------------------------------------

PDIRREC
LoadDirDB(
    LPSTR DirName
    )
{
    UINT i;
    PDIRREC DirDB, *DirDBNext;
    LPSTR s;

    AssertPathString(DirName);
    if (DirDB = LookupDirDB(DirName)) {
        return(DirDB);
    }

    if (ProbeFile(NULL, DirName) == -1) {
        return( NULL );
    }

    DirDBNext = &AllDirs;
    while (DirDB = *DirDBNext) {
        DirDBNext = &DirDB->Next;
    }

    AllDirsModified = TRUE;

    AllocMem(sizeof(DIRREC) + strlen(DirName), &DirDB, MT_DIRDB);
    memset(DirDB, 0, sizeof(*DirDB));
    SigCheck(DirDB->Sig = SIG_DIRREC);

    DirDB->DirFlags = DIRDB_NEW;
    DirDB->FindCount = 1;
    CopyString(DirDB->Name, DirName, TRUE);
    DirDB->CheckSum = CheckSum(DirDB->Name);

    if (DEBUG_1) {
        BuildMsgRaw("LoadDirDB creating %s\n", DirDB->Name);
    }

    *DirDBNext = DirDB;
    return( DirDB );
}

//+---------------------------------------------------------------------------
//
//  Debug helper functions to print parts of the database.
//
//----------------------------------------------------------------------------

#if DBG
VOID
PrintAllDirs(VOID)
{
    DIRREC **ppdr, *pdr;

    for (ppdr = &AllDirs; (pdr = *ppdr) != NULL; ppdr = &pdr->Next) {
        PrintDirDB(pdr, 1|2|4);
    }
}
#endif


VOID
PrintFlags(FILE *pf, ULONG Flags, FLAGSTRINGS *pfs)
{
    LPSTR p = ",";

    while (pfs->pszName != NULL) {
        if (pfs->Mask & Flags) {
            fprintf(pf, "%s %s", p, pfs->pszName);
            p = "";
        }
        pfs++;
    }
    fprintf(pf, szNewLine);
}


BOOL
PrintIncludes(FILE *pf, FILEREC *pfr, BOOL fTree)
{
    INCLUDEREC *pir;
    BOOL fMatch = pfr->IncludeFilesTree == pfr->IncludeFiles;

    pir = fTree? pfr->IncludeFilesTree : pfr->IncludeFiles;
    while (pir != NULL) {
        LPSTR pszdir = "<No File Record>";
        char OpenQuote, CloseQuote;

        if (pir->IncFlags & INCLUDEDB_LOCAL) {
            OpenQuote = CloseQuote = '"';
        }
        else {
            OpenQuote = '<';
            CloseQuote = '>';
        }

        fprintf(
            pf,
            "   %c#include %c%s%c",
            fMatch? ' ' : fTree? '+' : '-',
            OpenQuote,
            pir->Name,
            CloseQuote);
        if (pir->Version != 0) {
            fprintf(pf, " (v%d)", pir->Version);
        }
        if (pir->pfrCycleRoot != NULL) {
            fprintf(
                pf,
                " (root=%s\\%s)",
                pir->pfrCycleRoot->Dir->Name,
                pir->pfrCycleRoot->Name);
        }
        if (pir->pfrInclude != NULL) {
            if (pir->pfrInclude->Dir == pfr->Dir) {
                pszdir = ".";
            }
            else {
                pszdir = pir->pfrInclude->Dir->Name;
            }
        }
        fprintf(pf, " %s", pszdir);
        PrintFlags(pf, pir->IncFlags, IncludeFlags);
        if (pir->NextTree != pir->Next) {
            fMatch = FALSE;
        }
        pir = fTree? pir->NextTree : pir->Next;
    }
    return(fMatch);
}


VOID
PrintSourceDBList(SOURCEREC *psr, int i)
{
    TARGET_MACHINE_INFO *pMachine;

    pMachine = i < 0 ? TargetMachines[0] : PossibleTargetMachines[i];

    for ( ; psr != NULL; psr = psr->psrNext) {
        assert(
            (psr->SourceSubDirMask & ~TMIDIR_PARENT) == 0 ||
            pMachine->SourceSubDirMask ==
                (psr->SourceSubDirMask & ~TMIDIR_PARENT));
        BuildMsgRaw(
            "    %s%s%s%s%s",
            (psr->SourceSubDirMask & TMIDIR_PARENT)? "..\\" : "",
            (psr->SourceSubDirMask & ~TMIDIR_PARENT)?
                pMachine->SourceDirectory : "",
            (psr->SourceSubDirMask & ~TMIDIR_PARENT)? "\\" : "",
            psr->pfrSource->Name,
            (psr->SrcFlags & SOURCEDB_PCH)?
                " (pch)" :
                (psr->SrcFlags & SOURCEDB_SOURCES_LIST) == 0?
                    " (From exe list)" : "");
        PrintFlags(stderr, psr->SrcFlags, SourceFlags);
    }
}


VOID
PrintFileDB(FILE *pf, FILEREC *pfr, int DetailLevel)
{
    fprintf(pf, "  File: %s", pfr->Name);
    if (pfr->FileFlags & FILEDB_DIR) {
        fprintf(pf, " (Sub-Directory)");
    }
    else
    if (pfr->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) {
        LPSTR pszType = (pfr->FileFlags & FILEDB_SOURCE)? "Source" : "Header";

        if (pfr->FileFlags & FILEDB_ASM) {
            fprintf(pf, " (Assembler (CPP) %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_MASM) {
            fprintf(pf, " (Assembler (MASM) %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_RC) {
            fprintf(pf, " (Resource Compiler (RC) %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_MIDL) {
            fprintf(pf, " (MIDL %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_ASN) {
            fprintf(pf, " (ASN %s File)", pszType);
        }
        else
        if (pfr->FileFlags & FILEDB_MKTYPLIB) {
            fprintf(pf, " (Type Library (MkTypLib) %s File)", pszType);
        }
        else {
            fprintf(pf, " (C %s File)", pszType);
        }
        if ((pfr->FileFlags & FILEDB_HEADER) && pfr->Version != 0) {
            fprintf(pf, " (v%d)", pfr->Version);
        }
        if (pfr->GlobalSequence != 0) {
            fprintf(pf, " (GlobalSeq=%d)", pfr->GlobalSequence);
        }
        if (pfr->LocalSequence != 0) {
            fprintf(pf, " (LocalSeq=%d)", pfr->LocalSequence);
        }
        fprintf(pf, " - %u lines", pfr->SourceLines);
    }
    PrintFlags(pf, pfr->FileFlags, FileFlags);

    if (pfr->IncludeFiles != NULL) {
        BOOL fMatch;

        fMatch = PrintIncludes(pf, pfr, FALSE);
        if (pfr->IncludeFilesTree != NULL) {
            fprintf(pf, "   IncludeTree %s\n", fMatch? "matches" : "differs:");
            if (!fMatch) {
                PrintIncludes(pf, pfr, TRUE);
            }
        }
    }
}


VOID
PrintDirDB(DIRREC *pdr, int DetailLevel)
{
    FILE *pf = stderr;
    FILEREC *pfr, **ppfr;

    if (DetailLevel & 1) {
        fprintf(pf, "Directory: %s", pdr->Name);
        if (pdr->DirFlags & DIRDB_DIRS) {
            fprintf(pf, " (Dirs Present)");
        }
        if (pdr->DirFlags & DIRDB_SOURCES) {
            fprintf(pf, " (Sources Present)");
        }
        if (pdr->DirFlags & DIRDB_MAKEFILE) {
            fprintf(pf, " (Makefile Present)");
        }
        PrintFlags(pf, pdr->DirFlags, DirFlags);
    }
    if (DetailLevel & 2) {
        if (pdr->TargetPath != NULL) {
            fprintf(pf, "  TargetPath: %s\n", pdr->TargetPath);
        }
        if (pdr->TargetName != NULL) {
            fprintf(pf, "  TargetName: %s\n", pdr->TargetName);
        }
        if (pdr->TargetExt != NULL) {
            fprintf(pf, "  TargetExt: %s\n", pdr->TargetExt);
        }
        if (pdr->KernelTest != NULL) {
            fprintf(pf, "  KernelTest: %s\n", pdr->KernelTest);
        }
        if (pdr->UserAppls != NULL) {
            fprintf(pf, "  UserAppls: %s\n", pdr->UserAppls);
        }
        if (pdr->UserTests != NULL) {
            fprintf(pf, "  UserTests: %s\n", pdr->UserTests);
        }
        if (pdr->PchObj != NULL) {
            fprintf(pf, "  PchObj: %s\n", pdr->PchObj);
        }
        if (pdr->Pch != NULL) {
            fprintf(pf, "  Pch: %s\n", pdr->Pch);
        }
    }
    if (DetailLevel & 4) {
        for (ppfr = &pdr->Files; (pfr = *ppfr) != NULL; ppfr = &pfr->Next) {
            PrintFileDB(pf, pfr, DetailLevel);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupFileDB
//
//  Synopsis:   Search the database for the given file.
//
//  Arguments:  [DirDB]    -- Directory containing the file
//              [FileName] -- File to look for
//
//  Returns:    FILEREC of file if found, NULL if not.
//
//  Notes:      The file will not be added to the database if not already
//              there.
//
//----------------------------------------------------------------------------

PFILEREC
LookupFileDB(
    PDIRREC DirDB,
    LPSTR FileName
    )
{
    PFILEREC FileDB, *FileDBNext;
    USHORT sum;

    AssertPathString(FileName);
    sum = CheckSum(FileName);
    if (DEBUG_4) {
        BuildMsgRaw("LookupFileDB(%s, %s) - ", DirDB->Name, FileName);
    }
    FileDBNext = &DirDB->Files;
    while (FileDB = *FileDBNext) {
        if (sum == FileDB->CheckSum && strcmp(FileName, FileDB->Name) == 0) {
            if (DEBUG_4) {
                BuildMsgRaw("success\n");
            }
            return(FileDB);
        }
        FileDBNext = &FileDB->Next;
    }

    if (DEBUG_4) {
        BuildMsgRaw("failure\n");
    }
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  FILEDESC
//
//  FileDesc is a table describing file names and patterns that we recognize
//  and handle specially.  WARNING:  This table is ordered so the patterns
//  at the front are necessarily more specific than those later on.
//
//----------------------------------------------------------------------------

char szMakefile[] = "#";
char szClang[]    = "//";
char szAsn[]      = "--";
char szMasm[]     = ";";

//
// N.B. The first entry in the file descriptor list is an entry that is
//      optionally filled with the name of the target dirs file for the
//      first build target.
//

FILEDESC FileDesc[] =
{   { "/0dirs",       szMakefile,  FALSE, 0,    DIRDB_DIRS },
    { "makefile",     szMakefile,  FALSE, 0,    DIRDB_MAKEFILE },
    { "makefil0",     szMakefile,  FALSE, 0,    DIRDB_MAKEFIL0 | DIRDB_PASS0 },
    { "makefil1",     szMakefile,  FALSE, 0,    DIRDB_MAKEFIL1 },
    { "sources",      szMakefile,  FALSE, 0,    DIRDB_SOURCES },
    { "dirs",         szMakefile,  FALSE, 0,    DIRDB_DIRS },
    { "mydirs",       szMakefile,  FALSE, 0,    DIRDB_DIRS },

    { "makefile.inc", szMakefile,  FALSE, 0,                            0 },
    { "common.ver",   szClang,     TRUE,  FILEDB_HEADER,                0 },

    { ".rc",          szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".rc2",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".rcs",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".rcv",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".ver",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_RC, DIRDB_RESOURCE },
    { ".c",           szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0 },
    { ".cxx",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0 },
    { ".cpp",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_C,     0 },
    { ".f",           szClang,     TRUE,  FILEDB_SOURCE,                0 },
    { ".p",           szClang,     TRUE,  FILEDB_SOURCE,                0 },
    { ".s",           szClang,     TRUE,  FILEDB_SOURCE | FILEDB_ASM,   0 },
    { ".asm",         szMasm,      TRUE,  FILEDB_SOURCE | FILEDB_MASM,  0 },
    { ".mc",          szMasm,      TRUE,  FILEDB_SOURCE | FILEDB_RC |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".idl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MIDL |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".asn",         szAsn,       TRUE,  FILEDB_SOURCE | FILEDB_ASN |
                                          FILEDB_MULTIPLEPASS | FILEDB_PASS0,
                                          DIRDB_PASS0 },
    { ".tdl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MKTYPLIB | FILEDB_PASS0, 0 },
    { ".odl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MKTYPLIB | FILEDB_PASS0, 0 },
    { ".pdl",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_PASS0, 0 },
    { ".h",           szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hxx",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hpp",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hmd",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".hdl",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".inl",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".rh",          szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".dlg",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_RC,    0 },
    { ".inc",         szMasm,      TRUE,  FILEDB_HEADER | FILEDB_MASM,  0 },
    { ".src",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },  // see mvdm\softpc.new\obj.vdm\imlibdep.c
    { ".def",         szClang,     TRUE,  FILEDB_HEADER | FILEDB_C,     0 },
    { ".thk",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MULTIPLEPASS |
                                          FILEDB_PASS0, DIRDB_PASS0 },
    { ".java",        szClang,     TRUE,  FILEDB_SOURCE | FILEDB_JAVA,  0 },
    { ".mof",         szClang,     TRUE,  FILEDB_SOURCE | FILEDB_MOF |
                                          FILEDB_PASS0, DIRDB_PASS0 },

    { ".cs",          szClang,     TRUE,  FILEDB_SOURCE | FILEDB_CSHARP, 0 },
// MUST BE LAST
    { NULL,           "",          FALSE, 0,                            0 }
};


//+---------------------------------------------------------------------------
//
//  Function:   MatchFileDesc
//
//  Synopsis:   Matches the given filename to an entry in FileDesc, if
//              possible.
//
//  Arguments:  [pszFile] -- File to match
//
//  Returns:    A FILEDESC structure.  If a match was not found the data
//              in the FILEDESC will be empty.
//
//----------------------------------------------------------------------------

FILEDESC *
MatchFileDesc(LPSTR pszFile)
{
    LPSTR pszExt = strrchr(pszFile, '.');
    FILEDESC *pfd;

    AssertPathString(pszFile);
    pfd = &FileDesc[0];

    while (pfd->pszPattern != NULL) {
        if (pfd->pszPattern[0] == '.') {
            if (pszExt != NULL && !strcmp(pszExt, pfd->pszPattern))
                break;
        }
        else
        if (!strcmp(pszFile, pfd->pszPattern))
            break;

        pfd++;
    }
    return pfd;
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertFileDB
//
//  Synopsis:   Adds a file to the database.
//
//  Arguments:  [DirDB]     -- Directory containing the file
//              [FileName]  -- File to add
//              [DateTime]  -- Timestamp of file
//              [Attr]      -- File attributes (directory or file)
//              [FileFlags] -- FILEDB flags
//
//  Returns:    New FILEREC of file
//
//----------------------------------------------------------------------------

PFILEREC
InsertFileDB(
    PDIRREC DirDB,
    LPSTR FileName,
    ULONG DateTime,
    USHORT Attr,
    ULONG  FileFlags)
{
    PFILEREC FileDB, *FileDBNext;
    LPSTR pszCommentToEOL = NULL;

    AssertPathString(FileName);
    if (Attr & FILE_ATTRIBUTE_DIRECTORY) {
        if (!strcmp(FileName, ".")) {
            return(NULL);
        }
        if (!strcmp(FileName, "..")) {
            return(NULL);
        }
        assert(FileFlags == 0);
        FileFlags = FILEDB_DIR;
    }
    else {
        FILEDESC *pfd = MatchFileDesc(FileName);

        DirDB->DirFlags |= pfd->DirFlags;
        FileFlags |= pfd->FileFlags;

        if (!pfd->fNeedFileRec) {
            return (NULL);
        }
        pszCommentToEOL = pfd->pszCommentToEOL;
    }

    FileDBNext = &DirDB->Files;

    while ((FileDB = *FileDBNext) != NULL) {
        FileDBNext = &(*FileDBNext)->Next;
        if (strcmp(FileName, FileDB->Name) == 0) {
            BuildError(
                "%s: ignoring second instance of %s\n",
                DirDB->Name,
                FileName);
            return(NULL);
        }
    }

    AllocMem(sizeof(FILEREC) + strlen(FileName), &FileDB, MT_FILEDB);
    memset(FileDB, 0, sizeof(*FileDB));
    SigCheck(FileDB->Sig = SIG_FILEREC);

    CopyString(FileDB->Name, FileName, TRUE);
    FileDB->CheckSum = CheckSum(FileDB->Name);

    FileDB->DateTime = DateTime;
    FileDB->Attr = Attr;
    FileDB->Dir = DirDB;
    FileDB->FileFlags = FileFlags;
    FileDB->NewestDependency = FileDB;
    FileDB->pszCommentToEOL = pszCommentToEOL;

    if ((FileFlags & FILEDB_FILE_MISSING) == 0) {
        AllDirsModified = TRUE;
    }
    *FileDBNext = FileDB;
    return(FileDB);
}



//+---------------------------------------------------------------------------
//
//  Function:   DeleteUnscannedFiles
//
//  Synopsis:   Removes unscanned files (leaving scanned files and directories)
//              from the Files list of the given directory
//
//  Arguments:  [DirDB] -- Directory to clean up
//
//----------------------------------------------------------------------------

VOID
DeleteUnscannedFiles(
    PDIRREC DirDB
    )
{
    PFILEREC FileDB, *FileDBNext;

    FileDBNext = &DirDB->Files;
    while (FileDB = *FileDBNext) {
        //
        // If a file has the missing flag set then it doesn't exist.  But for
        // it to be in the list of files it has to be listed in a SOURCES line
        // (or some equivalent).  This means there is a SOURCEREC somewhere
        // which is pointing to the FILEREC for that file, so we don't want to
        // free its memory.
        //
        if ( (FileDB->FileFlags & (FILEDB_SCANNED | FILEDB_FILE_MISSING | FILEDB_SOURCEREC_EXISTS)) ||
             (FileDB->Attr & FILE_ATTRIBUTE_DIRECTORY) ) {
            FileDBNext = &FileDB->Next;
            }
        else {
            FreeFileDB( FileDBNext );
            AllDirsModified = TRUE;
            }
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   InsertIncludeDB
//
//  Synopsis:   Inserts an include file into the database
//
//  Arguments:  [FileDB]          -- File which includes this file
//              [IncludeFileName] -- Name of include file
//              [IncFlags]        -- INCLUDEDB flags for this file
//
//  Returns:    INCLUDEREC of previously existing or new entry one.
//
//----------------------------------------------------------------------------

PINCLUDEREC
InsertIncludeDB(
    PFILEREC FileDB,
    LPSTR IncludeFileName,
    USHORT IncFlags
    )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    AssertPathString(IncludeFileName);

    IncludeDBNext = &FileDB->IncludeFiles;

    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        if (!strcmp(IncludeDB->Name, IncludeFileName)) {
            IncludeDB->IncFlags &= ~INCLUDEDB_GLOBAL;
            IncludeDB->pfrInclude = NULL;
            return(IncludeDB);
        }
        IncludeDBNext = &IncludeDB->Next;
    }

    AllocMem(
        sizeof(INCLUDEREC) + strlen(IncludeFileName),
        IncludeDBNext,
        MT_INCLUDEDB);

    IncludeDB = *IncludeDBNext;

    memset(IncludeDB, 0, sizeof(*IncludeDB));
    SigCheck(IncludeDB->Sig = SIG_INCLUDEREC);

    IncludeDB->IncFlags = IncFlags;
    CopyString(IncludeDB->Name, IncludeFileName, TRUE);

    AllDirsModified = TRUE;

    return(IncludeDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LinkToCycleRoot
//
//----------------------------------------------------------------------------

VOID
LinkToCycleRoot(INCLUDEREC *pirOrg, FILEREC *pfrCycleRoot)
{
    INCLUDEREC *pir;

    AllocMem(
        sizeof(INCLUDEREC) + strlen(pfrCycleRoot->Name),
        &pir,
        MT_INCLUDEDB);
    memset(pir, 0, sizeof(*pir));
    SigCheck(pir->Sig = SIG_INCLUDEREC);

    pir->IncFlags = INCLUDEDB_SNAPPED | INCLUDEDB_CYCLEALLOC;
    pir->pfrInclude = pfrCycleRoot;

    CopyString(pir->Name, pfrCycleRoot->Name, TRUE);
    if (DEBUG_1) {
        BuildMsgRaw(
            "%x CycleAlloc  %s\\%s <- %s\\%s\n",
            pir,
            pir->pfrInclude->Dir->Name,
            pir->pfrInclude->Name,
            pirOrg->pfrInclude->Dir->Name,
            pirOrg->pfrInclude->Name);
    }

    MergeIncludeFiles(pirOrg->pfrInclude, pir, NULL);

    assert((pir->IncFlags & INCLUDEDB_CYCLEORPHAN) == 0);
    assert(pir->IncFlags & INCLUDEDB_CYCLEROOT);
}


//+---------------------------------------------------------------------------
//
//  Function:   MergeIncludeFiles
//
//----------------------------------------------------------------------------

VOID
MergeIncludeFiles(FILEREC *pfr, INCLUDEREC *pirList, FILEREC *pfrRoot)
{
    INCLUDEREC *pirT;
    INCLUDEREC *pir, **ppir;

    while ((pirT = pirList) != NULL) {
        pirList = pirList->NextTree;
        pirT->NextTree = NULL;
        assert(pirT->pfrInclude != NULL);

        for (ppir = &pfr->IncludeFilesTree;
             (pir = *ppir) != NULL;
             ppir = &pir->NextTree) {

            if (pirT->pfrInclude == pir->pfrInclude) {
                if (pirT->IncFlags & INCLUDEDB_CYCLEROOT) {
                    RemoveFromCycleRoot(pirT, pfrRoot);
                }
                pirT->IncFlags |= INCLUDEDB_CYCLEORPHAN;
                if (DEBUG_1) {
                    BuildMsgRaw(
                        "%x CycleOrphan %s\\%s <- %s\\%s\n",
                        pirT,
                        pirT->pfrInclude->Dir->Name,
                        pirT->pfrInclude->Name,
                        pfr->Dir->Name,
                        pfr->Name);
                }
                break;
            }
        }
        if (*ppir == NULL) {
            *ppir = pirT;
            pirT->pfrCycleRoot = pfr;
            pirT->IncFlags |= INCLUDEDB_CYCLEROOT;
            if (DEBUG_1) {
                BuildMsgRaw(
                    "%x CycleRoot   %s\\%s <- %s\\%s\n",
                    pirT,
                    pirT->pfrInclude->Dir->Name,
                    pirT->pfrInclude->Name,
                    pirT->pfrCycleRoot->Dir->Name,
                    pirT->pfrCycleRoot->Name);
            }
        }
    }
    if (fDebug & 16) {
        PrintFileDB(stderr, pfr, 2);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoveFromCycleRoot
//
//----------------------------------------------------------------------------

VOID
RemoveFromCycleRoot(INCLUDEREC *pir, FILEREC *pfrRoot)
{
    INCLUDEREC **ppir;

    assert(pir->pfrCycleRoot != NULL);

    // if pfrRoot was passed in, the caller knows it's on pfrRoot's list,
    // and is already dealing with the linked list without our help.

    if (pfrRoot != NULL) {
        assert((pir->IncFlags & INCLUDEDB_CYCLEALLOC) == 0);
        assert(pir->pfrCycleRoot == pfrRoot);
        pir->pfrCycleRoot = NULL;
        pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
        if (DEBUG_1) {
            BuildMsgRaw(
                "%x CycleUnroot %s\\%s <- %s\\%s\n",
                pir,
                pir->pfrInclude->Dir->Name,
                pir->pfrInclude->Name,
                pfrRoot->Dir->Name,
                pfrRoot->Name);
        }
        return;
    }
    ppir = &pir->pfrCycleRoot->IncludeFilesTree;
    while (*ppir != NULL) {
        if (*ppir == pir) {
            *ppir = pir->NextTree;      // remove from tree list
            pir->NextTree = NULL;
            pir->pfrCycleRoot = NULL;
            pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
            return;
        }
        ppir = &(*ppir)->NextTree;
    }
    BuildError(
        "%s\\%s: %x %s: not on cycle root's list\n",
        pir->pfrCycleRoot->Dir->Name,
        pir->pfrCycleRoot->Name,
        pir,
        pir->Name);

    assert(pir->pfrCycleRoot == NULL);  // always asserts if loop exhausted
}


//+---------------------------------------------------------------------------
//
//  Function:   UnsnapIncludeFiles
//
//  Synopsis:   Removes pointers from INCLUDEREC to the actual FILEREC of
//              the include file so we can 'resnap' them.
//
//  Arguments:  [pfr]           -- FILEREC to unsnap
//              [fUnsnapGlobal] -- If TRUE, global and local includes are
//                                 unsnapped. Otherwise, just local ones are.
//
//----------------------------------------------------------------------------

VOID
UnsnapIncludeFiles(FILEREC *pfr, BOOL fUnsnapGlobal)
{
    INCLUDEREC **ppir;
    INCLUDEREC *pir;

    // Dynamic Tree List:
    //  - no cycle orphans
    //  - cycle roots must belong to current file record
    //  - cycle allocs must be freed

    AssertFile(pfr);
    while (pfr->IncludeFilesTree != NULL) {
        pir = pfr->IncludeFilesTree;            // pick up next entry
        AssertInclude(pir);
        pfr->IncludeFilesTree = pir->NextTree;  // remove from tree list

        assert((pir->IncFlags & INCLUDEDB_CYCLEORPHAN) == 0);

        if (pir->IncFlags & (INCLUDEDB_CYCLEROOT | INCLUDEDB_CYCLEALLOC)) {

            // unsnap the record

            pir->IncFlags &= ~(INCLUDEDB_SNAPPED | INCLUDEDB_GLOBAL);
            pir->pfrInclude = NULL;
            pir->NextTree = NULL;
        }

        if (pir->IncFlags & INCLUDEDB_CYCLEROOT) {
            assert(pir->pfrCycleRoot == pfr);
            pir->pfrCycleRoot = NULL;
            pir->IncFlags &= ~INCLUDEDB_CYCLEROOT;
        }
        assert(pir->pfrCycleRoot == NULL);

        if (pir->IncFlags & INCLUDEDB_CYCLEALLOC) {
            pir->IncFlags &= ~INCLUDEDB_CYCLEALLOC;
            assert(pir->Next == NULL);
            FreeIncludeDB(&pir);
        }
    }

    // Static List:
    //  - no cycle allocs
    //  - cycle roots must be removed from a different file's Dynamic list
    //  - cycle orphans are nops

    for (ppir = &pfr->IncludeFiles; (pir = *ppir) != NULL; ppir = &pir->Next) {
        assert((pir->IncFlags & INCLUDEDB_CYCLEALLOC) == 0);
        if (pir->IncFlags & INCLUDEDB_CYCLEROOT) {
            assert(pir->pfrCycleRoot != pfr);
            RemoveFromCycleRoot(pir, NULL);
        }
        pir->IncFlags &= ~INCLUDEDB_CYCLEORPHAN;

        if (pir->pfrInclude != NULL &&
            (fUnsnapGlobal ||
             (pir->pfrInclude->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES) == 0)) {

            // unsnap the record

            pir->IncFlags &= ~(INCLUDEDB_SNAPPED | INCLUDEDB_GLOBAL);
            pir->pfrInclude = NULL;
        }
        pir->NextTree = NULL;
    }
}

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   AssertCleanTree
//
//  Synopsis:   Enforce that no include files are snapped.
//
//  Arguments:  [pir] - include record to test
//              [pfr] - optional containing file record
//
//----------------------------------------------------------------------------

VOID
AssertCleanTree(INCLUDEREC *pir, OPTIONAL FILEREC *pfr)
{
    if (IsCleanTree(pir)) {
        return;
    }
    if (fAssertCleanTree) {
        BuildMsgRaw("\n*************************************\n");
        BuildMsgRaw("Persistent Cycle: pir=%x: %s\n", pir, pir->Name);
        if (pfr != NULL) {
            BuildMsgRaw("    pfr=%x: %s\n", pfr, pfr->Name);
            if (pfr->Dir != NULL) {
                BuildMsgRaw("    pdr=%x: %s\n", pfr->Dir, pfr->Dir->Name);
            }
        }
        if (pir->pfrInclude != NULL) {
            BuildMsgRaw("    pfrInclude=%x: %s\n", pir->pfrInclude, pir->pfrInclude->Name);
            if (pir->pfrInclude->Dir != NULL) {
                BuildMsgRaw("    pdrInclude=%x: %s\n", pir->pfrInclude->Dir, pir->pfrInclude->Dir->Name);
            }
        }
        BuildMsgRaw("\n*************************************\n");
        fflush(stdout);
        fflush(stderr);

        PrintAllDirs();
        BuildMsgRaw("\n*************************************\n");
        fflush(stdout);
        fflush(stderr);
    }
    assert(IsCleanTree(pir));
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   UnsnapAllDirectories
//
//  Synopsis:   Removes pointers from all INCLUDERECs to the actual FILERECs
//              of include files so we can 'resnap' them.
//
//  Arguments:  None
//----------------------------------------------------------------------------

VOID
UnsnapAllDirectories(VOID)
{
    DIRREC *pdr;
    UINT   i;

    GlobalSequence = LocalSequence = 0;

    for (pdr = AllDirs; pdr != NULL; pdr = pdr->Next) {
        FILEREC *pfr;

        AssertDir(pdr);

        // Clear unwanted flags on each directory

        pdr->DirFlags &= ~(DIRDB_SCANNED |
                           DIRDB_PASS0NEEDED |
                           DIRDB_COMPILENEEDED |
                           DIRDB_NEW);

        pdr->CountOfFilesToCompile = 0;
        pdr->SourceLinesToCompile  = 0;
        pdr->CountOfPassZeroFiles = 0;
        pdr->PassZeroLines = 0;

        // Free all source records that point to missing files, because the
        // file records may be freed when rescanning directories after pass 0.

        if (pdr->pds != NULL)
        {
            for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
                SOURCEREC **ppsr;
                SOURCEREC *psr;

                ppsr = &pdr->pds->psrSourcesList[i];
                while ((psr = *ppsr) != NULL)
                {
                    if (psr->SrcFlags & SOURCEDB_FILE_MISSING)
                    {
                        FreeSourceDB(ppsr);
                    }
                    else
                    {
                        ppsr = &psr->psrNext;
                    }
                }
            }
        }

        // Clear out all snapped include files and sequence numbers

        for (pfr = pdr->Files; pfr != NULL; pfr = pfr->Next) {

            AssertFile(pfr);
            UnsnapIncludeFiles(pfr, TRUE);
            pfr->GlobalSequence = pfr->LocalSequence = 0;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MarkIncludeFileRecords
//
//----------------------------------------------------------------------------

VOID
MarkIncludeFileRecords(
    PFILEREC FileDB
    )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    IncludeDBNext = &FileDB->IncludeFiles;
    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        IncludeDB->pfrInclude = (PFILEREC) -1;
        IncludeDBNext = &IncludeDB->Next;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteIncludeFileRecords
//
//----------------------------------------------------------------------------

VOID
DeleteIncludeFileRecords(
    PFILEREC FileDB
    )
{
    PINCLUDEREC IncludeDB, *IncludeDBNext;

    IncludeDBNext = &FileDB->IncludeFiles;
    while (IncludeDB = *IncludeDBNext) {
        AssertCleanTree(IncludeDB, FileDB);      // Tree must be clean
        if (IncludeDB->pfrInclude == (PFILEREC) -1) {
            FreeIncludeDB(IncludeDBNext);
        }
        else {
            IncludeDBNext = &IncludeDB->Next;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FindIncludeFileDB
//
//  Synopsis:   Find the FILEREC for an include file that our compiland
//              includes.
//
//  Arguments:  [pfrSource]          -- FILEREC of file which includes the one
//                                      we're looking for. Might be a header.
//              [pfrCompiland]       -- FILEREC of ultimate source file.
//              [pdrBuild]           -- DIRREC of directory being built
//              [pszSourceDirectory] -- Name of machine-specific dir
//              [IncludeDB]          -- INCLUDEDB of include file we're looking
//                                      for.
//
//  Returns:    FILEREC of include file, if found.
//
//----------------------------------------------------------------------------

PFILEREC
FindIncludeFileDB(
    FILEREC *pfrSource,
    FILEREC *pfrCompiland,
    DIRREC *pdrBuild,
    LPSTR pszSourceDirectory,
    INCLUDEREC *IncludeDB)
{
    DIRREC *pdr;
    DIRREC *pdrMachine;
    FILEREC *pfr;
    UINT n;

    AssertFile(pfrSource);
    AssertFile(pfrCompiland);
    AssertDir(pfrSource->Dir);
    AssertDir(pfrCompiland->Dir);
    AssertDir(pdrBuild);
    assert(pfrSource->Dir->FindCount >= 1);
    assert(pfrCompiland->Dir->FindCount >= 1);
    assert(pdrBuild->FindCount >= 1);
    AssertInclude(IncludeDB);

    // The rules for #include "foo.h" and #include <foo.h> are:
    //  - "foo.h" searches in the directory of the source file that has the
    //    #include statement first, then falls into the INCLUDES= directories
    //  - <foo.h> simply searches the INCLUDES= directories
    //
    //  - since makefile.def *always* passes -I. -ITargetMachines[i] first,
    //    that has to be handled here as well.
    //
    //  - deal with #include <sys\types> and #include "..\foo\bar.h" by
    //    scanning those directories, too.

    n = CountIncludeDirs;
    pdrMachine = FindSourceDirDB(pdrBuild->Name, pszSourceDirectory, FALSE);

    // If local ("foo.h"), search the current file's directory, too.
    // The compiler also will search the directory of each higher level
    // file in the include hierarchy, but we won't get quite so fancy here.
    // Just search the directory of the current file and of the compiland.
    //
    // Skip these directories if they match the current build directory or
    // the machine subdirectory, because that's handled below.

    if (IncludeDB->IncFlags & INCLUDEDB_LOCAL) {
        if (pfrCompiland->Dir != pdrBuild &&
            pfrCompiland->Dir != pdrMachine &&
            pfrCompiland->Dir != pfrSource->Dir) {
            AddIncludeDir(pfrCompiland->Dir, &n);
        }
        if (pfrSource->Dir != pdrBuild && pfrSource->Dir != pdrMachine) {
            AddIncludeDir(pfrSource->Dir, &n);
        }
    }

    // Search the current target machine subdirectory of the build directory
    // -- as per makefile.def

    if (pdrMachine != NULL) {
        AddIncludeDir(pdrMachine, &n);
    }

    // Search the current build directory -- as per makefile.def.

    AddIncludeDir(pdrBuild, &n);

    while (n--) {
        pdr = IncludeDirs[n];
        if (pdr == NULL) {
            continue;
        }
        AssertDir(pdr);
        assert(pdr->FindCount >= 1);
        pfr = FindSourceFileDB(pdr, IncludeDB->Name, NULL);
        if (pfr != NULL) {
            if (DEBUG_1) {
                BuildMsgRaw(
                    "Found include file %s\\%s\n",
                    pfr->Dir->Name,
                    pfr->Name);
            }
            return(pfr);
        }
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveMasterDB
//
//  Synopsis:   Save the database to disk in build.dat
//
//  Arguments:  (none)
//
//  Returns:    TRUE if successful
//
//----------------------------------------------------------------------------

BOOL
SaveMasterDB(VOID)
{
    PDIRREC DirDB, *DirDBNext;
    PFILEREC FileDB, *FileDBNext;
    PINCLUDEREC IncludeDB, *IncludeDBNext;
    FILE *fh;

    if (!AllDirsModified) {
        return(TRUE);
    }

    if (!(fh = fopen(DbMasterName, "wb"))) {
        return( FALSE );
    }

    setvbuf(fh, NULL, _IOFBF, 0x7000);
    BuildMsg("Saving %s...", DbMasterName);

    AllDirsModified = FALSE;
    DirDBNext = &AllDirs;
    fprintf(fh, "V %x\r\n", BUILD_VERSION);
    while (DirDB = *DirDBNext) {
        fprintf(fh, "D \"%s\" %x\r\n", DirDB->Name, DirDB->DirFlags);
        FileDBNext = &DirDB->Files;
        while (FileDB = *FileDBNext) {
            if ((FileDB->FileFlags & FILEDB_FILE_MISSING) == 0) {
                fprintf(
                    fh,
                    " F \"%s\" %x %x %lx %u %u\r\n",
                    FileDB->Name,
                    FileDB->FileFlags,
                    FileDB->Attr,
                    FileDB->DateTime,
                    FileDB->SourceLines,
                    FileDB->Version);
            }
            IncludeDBNext = &FileDB->IncludeFiles;
            while (IncludeDB = *IncludeDBNext) {
                fprintf(
                    fh,
                    "  I \"%s\" %x %u\r\n",
                    IncludeDB->Name,
                    IncludeDB->IncFlags,
                    IncludeDB->Version);

                IncludeDBNext= &IncludeDB->Next;
            }
            FileDBNext = &FileDB->Next;
        }
        fprintf(fh, "\r\n");
        DirDBNext = &DirDB->Next;
    }
    fclose(fh);
    BuildMsgRaw(szNewLine);
    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterDB
//
//  Synopsis:   Load the master database from build.dat
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

void
LoadMasterDB( void )
{
    PDIRREC DirDB, *DirDBNext;
    PFILEREC FileDB, *FileDBNext;
    PINCLUDEREC IncludeDB, *IncludeDBNext;
    FILE *fh;
    LPSTR s;
    char ch, ch2;
    BOOL fFirst = TRUE;
    UINT Version;
    LPSTR pszerr = NULL;

    AllDirs = NULL;
    AllDirsModified = FALSE;
    AllDirsInitialized = FALSE;

    if (!SetupReadFile("", DbMasterName, ";", &fh)) {
        return;
    }
    BuildMsg("Loading %s...", DbMasterName);

    DirDBNext = &AllDirs;
    FileDBNext = NULL;
    IncludeDBNext = NULL;

    while ((s = ReadLine(fh)) != NULL) {
        ch = *s++;
        if (ch == '\0') {
            continue;           // skip empty lines
        }
        ch2 = *s++;             // should be a blank
        if (ch2 == '\0') {
            pszerr = "missing field";
            break;              // fail on single character lines
        }
        if (fFirst) {
            if (ch != 'V' || ch2 != ' ' || !AToX(&s, &Version)) {
                pszerr = "bad version format";
                break;
            }
            if (Version != BUILD_VERSION) {
                break;
            }
            fFirst = FALSE;
            continue;
        }
        if (ch2 != ' ') {
            pszerr = "bad separator";
            break;
        }
        if (ch == 'D') {
            DirDB = LoadMasterDirDB(s);
            if (DirDB == NULL) {
                pszerr = "Directory error";
                break;
            }
            *DirDBNext = DirDB;
            DirDBNext = &DirDB->Next;
            FileDBNext = &DirDB->Files;
            IncludeDBNext = NULL;
        }
        else
        if (ch == 'F' && FileDBNext != NULL) {
            FileDB = LoadMasterFileDB(s);
            if (FileDB == NULL) {
                pszerr = "File error";
                break;
            }
            *FileDBNext = FileDB;
            FileDBNext = &FileDB->Next;
            FileDB->Dir = DirDB;
            IncludeDBNext = &FileDB->IncludeFiles;
        }
        else
        if (ch == 'I' && IncludeDBNext != NULL) {
            IncludeDB = LoadMasterIncludeDB(s);
            if (IncludeDB == NULL) {
                pszerr = "Include error";
                break;
            }
            *IncludeDBNext = IncludeDB;
            IncludeDBNext = &IncludeDB->Next;
        }
        else {
            pszerr = "bad entry type";
            break;
        }
    }

    if (s != NULL) {
        if (pszerr == NULL) {
            BuildMsgRaw(" - old version - recomputing.\n");
        } else {
            BuildMsgRaw(szNewLine);
            BuildError("corrupt database (%s)\n", pszerr);
        }
        FreeAllDirs();
    }
    else {
        BuildMsgRaw(szNewLine);
        AllDirsInitialized = TRUE;
    }
    CloseReadFile(NULL);
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterDirDB
//
//  Synopsis:   Load a directory entry from build.dat
//
//  Arguments:  [s] -- line containing text from file.
//
//  Returns:    DIRRECT
//
//----------------------------------------------------------------------------

PDIRREC
LoadMasterDirDB(
    LPSTR s
    )
{
    PDIRREC DirDB;
    LPSTR DirName;
    ULONG DirFlags;

    if (*s == '"') {
        s++;
        DirName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    }
    else
    {
        DirName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &DirFlags)) {
        return(NULL);
    }
    AllocMem(sizeof(DIRREC) + strlen(DirName), &DirDB, MT_DIRDB);
    memset(DirDB, 0, sizeof(*DirDB));
    SigCheck(DirDB->Sig = SIG_DIRREC);

    DirDB->DirFlags = DirFlags & DIRDB_DBPRESERVE;
    CopyString(DirDB->Name, DirName, TRUE);
    DirDB->CheckSum = CheckSum(DirDB->Name);
    return( DirDB );
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterFileDB
//
//  Synopsis:   Load a file entry from build.dat
//
//  Arguments:  [s] -- line containing text from file
//
//  Returns:    FILEREC
//
//----------------------------------------------------------------------------

PFILEREC
LoadMasterFileDB(
    LPSTR s
    )
{
    PFILEREC FileDB;
    LPSTR FileName;
    ULONG Version;
    ULONG FileFlags;
    ULONG Attr;
    ULONG SourceLines;
    ULONG DateTime;
    FILEDESC *pfd;

    if (*s == '"') {
        s++;
        FileName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    }
    else
    {
        FileName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &FileFlags) ||
        !AToX(&s, &Attr) ||
        !AToX(&s, &DateTime) ||
        !AToD(&s, &SourceLines) ||
        !AToD(&s, &Version) ||
        strchr(FileName, '/') != NULL ||
        strchr(FileName, '\\') != NULL) {
        return(NULL);
    }
    AllocMem(sizeof(FILEREC) + strlen(FileName), &FileDB, MT_FILEDB);
    memset(FileDB, 0, sizeof(*FileDB));
    SigCheck(FileDB->Sig = SIG_FILEREC);

    CopyString(FileDB->Name, FileName, TRUE);
    FileDB->CheckSum = CheckSum(FileDB->Name);

    FileDB->FileFlags = FileFlags & FILEDB_DBPRESERVE;
    FileDB->Attr = (USHORT) Attr;
    FileDB->DateTime = DateTime;
    FileDB->Version = (USHORT) Version;
    FileDB->SourceLines = SourceLines;
    FileDB->NewestDependency = FileDB;

    pfd = MatchFileDesc(FileDB->Name);
    FileDB->pszCommentToEOL = pfd->pszCommentToEOL;
    return(FileDB);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadMasterIncludeDB
//
//  Synopsis:   Loads an include file entry from build.dat
//
//  Arguments:  [s] -- line containing text from file.
//
//  Returns:    INCLUDEREC
//
//----------------------------------------------------------------------------

PINCLUDEREC
LoadMasterIncludeDB(
    LPSTR s
    )
{
    PINCLUDEREC IncludeDB;
    LPSTR FileName;
    ULONG Version;
    ULONG IncFlags;

    if (*s == '"') {
        s++;
        FileName = s;
        while (*s != '"') {
            s++;
        }
        *s++ = '\0';
    }
    else
    {
        FileName = s;
        while (*s > ' ') {
            s++;
        }
    }
    *s++ = '\0';

    if (!AToX(&s, &IncFlags) || !AToD(&s, &Version)) {
        return(NULL);
    }
    AllocMem(
        sizeof(INCLUDEREC) + strlen(FileName),
        &IncludeDB,
        MT_INCLUDEDB);
    memset(IncludeDB, 0, sizeof(*IncludeDB));
    SigCheck(IncludeDB->Sig = SIG_INCLUDEREC);

    IncludeDB->IncFlags = (USHORT) (IncFlags & INCLUDEDB_DBPRESERVE);
    IncludeDB->Version = (USHORT) Version;
    CopyString(IncludeDB->Name, FileName, TRUE);
    return(IncludeDB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildinc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       buildinc.c
//
//  Contents:   This is the checking include module for the NT Build Tool (BUILD.EXE)
//
//              Used for detecting the includes that do not satisfy the acceptable
//              patterns.
//
//  History:    see SLM
//----------------------------------------------------------------------------

#include "build.h"

//+---------------------------------------------------------------------------
//
//  Function:   FoundCountedSequenceInString
//
//  Synopsis:   Roughly equivalent to "strstr" except that the substring doesn't
//              have to be NULL-terminated.
//
//  Arguments:  [String]   -- null-terminated string to search
//              [Sequence] -- string to search for
//              [Length]   -- the length of the sequence
//----------------------------------------------------------------------------

LPCTSTR
FindCountedSequenceInString(
    IN LPCTSTR String,
    IN LPCTSTR Sequence,
    IN DWORD   Length
    )
    {

    assert( Sequence );
    assert( String );

    if ( Length > 0 ) {

        while ( *String ) {

            while (( *String ) && ( *String != *Sequence )) {
                String++;
                }

            if ( *String ) {

                LPCTSTR SubString   = String   + 1;
                LPCTSTR SubSequence = Sequence + 1;
                DWORD   Remaining   = Length   - 1;

                while (( Remaining ) && ( *SubString++ == *SubSequence++ )) {
                    Remaining--;
                    }

                if ( Remaining == 0 ) {
                    return String;
                    }

                String++;
                }
            }

        return NULL;
        }

    return String;
    }


//+---------------------------------------------------------------------------
//
//  Function:   DoesInstanceMatchPattern
//
//  Synopsis:   Returns TRUE if pattern matches instance.
//              Wildcards:
//              * matches any text
//              ? matches any and exactly one character
//              # matches any text up to backslash character or end of string
//
//  Arguments:  [Instance] -- the string to be matched
//              [Pattern]  -- the pattern
//----------------------------------------------------------------------------

BOOL
DoesInstanceMatchPattern(
    IN LPCTSTR Instance,
    IN LPCTSTR Pattern
    )
    {

    assert( Instance );
    assert( Pattern );

    while ( *Pattern ) {

        if ( *Pattern == TEXT('*')) {

            Pattern++;

            while ( *Pattern == TEXT('*')) {    // skip multiple '*' characters
                Pattern++;
                }

            if ( *Pattern == 0 ) {      // '*' at end of pattern matches rest
                return TRUE;
                }

            if ( *Pattern == '?' ) {    // '?' following '*'

                //
                //  Expensive because we have to restart match for every
                //  character position remaining since '?' can match anything.
                //

                while ( *Instance ) {

                    if ( DoesInstanceMatchPattern( Instance, Pattern )) {
                        return TRUE;
                        }

                    Instance++;
                    }

                return FALSE;
                }

            else {

                //
                //  Now we know that next character in pattern is a regular
                //  character to be matched.  Find out the length of that
                //  string to the next wildcard or end of string.
                //

                LPCTSTR NextWildCard = Pattern + 1;
                DWORD   MatchLength;

                while (( *NextWildCard ) && ( *NextWildCard != TEXT('*')) && ( *NextWildCard != TEXT('?')) && ( *NextWildCard != TEXT('#'))) {
                    NextWildCard++;
                    }

                MatchLength = (DWORD)(NextWildCard - Pattern);   // always non-zero

                //
                //  Now try to match with any instance of substring in pattern
                //  found in the instance.
                //

                Instance = FindCountedSequenceInString( Instance, Pattern, MatchLength );

                while ( Instance ) {

                    if ( DoesInstanceMatchPattern( Instance + MatchLength, NextWildCard )) {
                        return TRUE;
                        }

                    Instance = FindCountedSequenceInString( Instance + 1, Pattern, MatchLength );
                    }

                return FALSE;
                }
            }

        else if ( *Pattern == TEXT('#')) {

            //
            //  Match text up to backslash character or end of string
            //

            Pattern++;

            while (( *Instance != 0 ) && ( *Instance != '\\' )) {
                Instance++;
                }

            continue;
            }

        else if ( *Pattern == TEXT('?')) {

            if ( *Instance == 0 ) {
                return FALSE;
                }
            }

        else if ( *Pattern != *Instance ) {

            return FALSE;
            }

        Pattern++;
        Instance++;
        }

    return ( *Instance == 0 );
    }


//+---------------------------------------------------------------------------
//
//  Function:   CombinePaths
//
//  Synopsis:   Combine two strings to get a full path.
//
//  Arguments:  [ParentPath] -- head path
//              [ChildPath]  -- path to be added
//              [TargetPath] -- full path
//----------------------------------------------------------------------------

LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath   // can be same as ParentPath if want to append
    )
    {

    ULONG ParentLength = strlen( ParentPath );
    LPSTR p;

    assert( ParentPath );
    assert( ChildPath );

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    strcpy( p, ChildPath );

    return TargetPath;
    }


//+---------------------------------------------------------------------------
//
//  Function:   CreateRelativePath
//
//  Synopsis:   Determine the "canonical" path of one file relative to
//              another file
//
//  Arguments:  [SourceAbsName] -- absolute path of the source file
//              [TargetAbsName] -- absolute path of the target file
//              [RelativePath]  -- resulted relative path
//----------------------------------------------------------------------------

VOID
CreateRelativePath(
    IN  LPCSTR SourceAbsName,    // must be lowercase
    IN  LPCSTR TargetAbsName,    // must be lowercase
    OUT LPSTR  RelativePath      // must be large enough
    )
    {

    //
    //  First, walk through path components that match in Source and Target.
    //  For example:
    //
    //      d:\nt\private\ntos\dd\efs.h
    //      d:\nt\private\windows\base\ntcrypto\des.h
    //                    ^
    //                    This is where the relative path stops going up (..)
    //                    and starts going back down.
    //
    //  So, the "cannonical" relative path generated should look like:
    //
    //      ..\..\..\windows\base\ntcrypto\des.h
    //
    //  For relative includes that are "below" the includer in the path should
    //  look like this:
    //
    //      .\foo\bar\foobar.h
    //

    LPCSTR Source = SourceAbsName;
    LPCSTR Target = TargetAbsName;
    LPSTR Output = RelativePath;
    ULONG PathSeparatorIndex;
    BOOL  AnyParent;
    ULONG i;

    assert( SourceAbsName );
    assert( TargetAbsName );

    PathSeparatorIndex = 0;

    i = 0;

    //
    //  Scan forward to first non-matching character, and keep track of
    //  most recent path separator character.
    //

    while (( Source[ i ] == Target[ i ] ) && ( Source[ i ] != 0 )) {

        if ( Source[ i ] == '\\' ) {
            PathSeparatorIndex = i;
            }

        ++i;
        }

    //
    //  Coming out of this loop, there are 2 possibilities:
    //
    //       1) Found common ancestor path ( *PathSeparatorIndex == '\\' )
    //       2) Don't have common ancestor ( *PathSeparatorIndex != '\\' )
    //

    if ( Source[ PathSeparatorIndex ] != '\\' ) {
        strcpy( RelativePath, TargetAbsName );
        return;
        }

    i = PathSeparatorIndex + 1;

    //
    //  Now continue to walk down source path and insert a "..\" in the result
    //  for each path separator encountered.
    //

    AnyParent = FALSE;

    while ( Source[ i ] != 0 ) {

        if ( Source[ i ] == '\\' ) {

            AnyParent = TRUE;
            *Output++ = '.';
            *Output++ = '.';
            *Output++ = '\\';
            }

        ++i;
        }

    if ( ! AnyParent ) {

        //
        //  Relative path is below current directory.
        //

        *Output++ = '.';
        *Output++ = '\\';
        }


    //
    //  Now we simply append what's remaining of the Target path from the
    //  ancestor match point.
    //

    strcpy( Output, Target + PathSeparatorIndex + 1 );
    }


//+---------------------------------------------------------------------------
//
//  Function:   ShouldWarnInclude
//
//  Synopsis:   Returns true if the name of the included file matches a
//              BUILD_UNACCEPTABLE_INCLUDES pattern or it does not match
//              any of the patterns specified in BUILD_ACCEPTABLE_INCLUDES.
//
//  Arguments:  [CompilandFullName] -- name of the including file
//              [IncludeeFullName]  -- name of the included file
//----------------------------------------------------------------------------

BOOL
ShouldWarnInclude(
    IN LPCSTR CompilandFullName,
    IN LPCSTR IncludeeFullName
    )
    {
    UINT i;
    CHAR IncludeeRelativeName[ MAX_PATH ];


    assert( CompilandFullName );
    assert( IncludeeFullName );

    CreateRelativePath( CompilandFullName, IncludeeFullName, IncludeeRelativeName );

    //
    //  First we check for a match against any unacceptable include path
    //  because we always want to warn about these.
    //

    for ( i = 0; UnacceptableIncludePatternList[ i ] != NULL; i++ ) {

        if ( DoesInstanceMatchPattern( IncludeeFullName, UnacceptableIncludePatternList[ i ] )) {
            return TRUE;
            }

        if ( DoesInstanceMatchPattern( IncludeeRelativeName, UnacceptableIncludePatternList[ i ] )) {
            return TRUE;
            }
        }

    //
    //  If we get to here, the include path was not explicitly unacceptable, so
    //  we now want to see if it matches any acceptable paths.  But, if no
    //  acceptable paths are specified, we don't want to warn.
    //

    if ( AcceptableIncludePatternList[ 0 ] == NULL ) {
        return FALSE;
        }

    for ( i = 0; AcceptableIncludePatternList[ i ] != NULL; i++ ) {

        if ( DoesInstanceMatchPattern( IncludeeFullName, AcceptableIncludePatternList[ i ] )) {
            return FALSE;
            }

        if ( DoesInstanceMatchPattern( IncludeeRelativeName, AcceptableIncludePatternList[ i ] )) {
            return FALSE;
            }
        }

    return TRUE;
    }


//+---------------------------------------------------------------------------
//
//  Function:   CheckIncludeForWarning
//
//  Synopsis:   Warnings if the dependency does not respect the
//              BUILD_UNACCEPTABLE_INCLUDES or BUILD_ACCEPTABLE_INCLUDES
//              restristions. Works with build -#.
//
//  Arguments:  [CompilandDir]
//              [CompilandName]
//              [IncluderDir]
//              [IncluderName]
//              [IncludeeDir]
//              [IncludeeName]
//----------------------------------------------------------------------------

VOID
CheckIncludeForWarning(
    IN LPCSTR CompilandDir,
    IN LPCSTR CompilandName,
    IN LPCSTR IncluderDir,
    IN LPCSTR IncluderName,
    IN LPCSTR IncludeeDir,
    IN LPCSTR IncludeeName
    )
    {

    CHAR CompilandFullName[ MAX_PATH ];
    CHAR IncluderFullName[ MAX_PATH ];
    CHAR IncludeeFullName[ MAX_PATH ];

    assert( CompilandDir );
    assert( CompilandName );
    assert( IncluderDir );
    assert( IncluderName );
    assert( IncludeeDir );
    assert( IncludeeName );

    CombinePaths( CompilandDir, CompilandName, CompilandFullName );
    CombinePaths( IncluderDir,  IncluderName,  IncluderFullName  );
    CombinePaths( IncludeeDir,  IncludeeName,  IncludeeFullName  );

    _strlwr( CompilandFullName );
    _strlwr( IncluderFullName );
    _strlwr( IncludeeFullName );

    if ( IncFile ) {
        fprintf(
             IncFile,
             "%s includes %s\r\n",
             IncluderFullName,
             IncludeeFullName
             );
        }

    if ( ShouldWarnInclude( CompilandFullName, IncludeeFullName )) {

        if ( strcmp( IncluderFullName, CompilandFullName ) == 0 ) {

            if ( WrnFile ) {

                fprintf(
                     WrnFile,
                     "WARNING: %s includes %s\n",
                     CompilandFullName,
                     IncludeeFullName
                     );
                }

            if ( fShowWarningsOnScreen ) {

                BuildMsgRaw(
                    "WARNING: %s includes %s\n",
                    CompilandFullName,
                    IncludeeFullName
                    );
                }
            }

        else {

            if ( WrnFile ) {

                fprintf(
                     WrnFile,
                     "WARNING: %s includes %s through %s\n",
                     CompilandFullName,
                     IncludeeFullName,
                     IncluderFullName
                     );
                }

            if ( fShowWarningsOnScreen ) {

                BuildMsgRaw(
                    "WARNING: %s includes %s through %s\n",
                    CompilandFullName,
                    IncludeeFullName,
                    IncluderFullName
                    );
                }
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildscr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       buildscr.h
//
//  Contents:   Header file defining the objects needed to interface with
//              the MTScript engine.
//
//----------------------------------------------------------------------------

class CProcessSink : public IScriptedProcessSink
{
public:
    CProcessSink();
   ~CProcessSink() {}

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IScriptedProcessSink methods

    STDMETHOD(RequestExit)();
    STDMETHOD(ReceiveData)(wchar_t *pszType,
                           wchar_t *pszData,
                           long *plReturn);

private:
    ULONG _ulRefs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildscn.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       buildscn.c
//
//  Contents:   Directory and File scanning functions for Build.exe
//
//
//  History:    16-May-89     SteveWo  Created
//                  ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddShowDir
//
//  Synopsis:   Add a directory to the ShowDir array
//
//----------------------------------------------------------------------------

VOID
AddShowDir(DIRREC *pdr)
{
    AssertDir(pdr);
    if (CountShowDirs >= MAX_BUILD_DIRECTORIES) {
        static BOOL fError = FALSE;

        if (!fError) {
            BuildError(
                "Show Directory table overflow, using first %u entries\n",
                MAX_BUILD_DIRECTORIES);
                fError = TRUE;
        }
    }
    else {
        ShowDirs[CountShowDirs++] = pdr;
    }
    pdr->DirFlags |= DIRDB_SHOWN;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddIncludeDir
//
//  Synopsis:   Add a directory to the IncludeDirs array
//
//----------------------------------------------------------------------------

VOID
AddIncludeDir(DIRREC *pdr, UINT *pui)
{
    AssertDir(pdr);
    assert(pdr->FindCount >= 1);
    assert(*pui <= MAX_INCLUDE_DIRECTORIES);
    if (*pui >= MAX_INCLUDE_DIRECTORIES) {
        BuildError(
            "Include Directory table overflow, %u entries allowed\n",
            MAX_INCLUDE_DIRECTORIES);
        exit(16);
    }
    IncludeDirs[(*pui)++] = pdr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanGlobalIncludeDirectory
//
//  Synopsis:   Scans a global include directory and adds it to the
//              IncludeDir array.
//
//----------------------------------------------------------------------------

VOID
ScanGlobalIncludeDirectory(LPSTR path)
{
    DIRREC *pdr;

    if ((pdr = ScanDirectory(path)) != NULL) {
        AddIncludeDir(pdr, &CountIncludeDirs);
        pdr->DirFlags |= DIRDB_GLOBAL_INCLUDES;
        if (fShowTreeIncludes && !(pdr->DirFlags & DIRDB_SHOWN)) {
            AddShowDir(pdr);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanIncludeEnv
//
//  Synopsis:   Scans all include directories specified in the INCLUDE
//              environment variable.
//
//  Arguments:  [IncludeEnv] -- value of the INCLUDE environment variable.
//
//  Notes:      The INCLUDE variable is a string with a list of directories
//              separated by semicolons (;).
//
//----------------------------------------------------------------------------

VOID
ScanIncludeEnv(
    LPSTR IncludeEnv
    )
{
    char path[DB_MAX_PATH_LENGTH] = {0};
    LPSTR IncDir, IncDirEnd;
    UINT cb;

    if (!IncludeEnv) {
        return;
        }

    if (DEBUG_1) {
        BuildMsgRaw("ScanIncludeEnv(%s)\n", IncludeEnv);
    }

    IncDir = IncludeEnv;
    while (*IncDir) {
        IncDir++;
    }

    while (IncDir > IncludeEnv) {
        IncDirEnd = IncDir;
        while (IncDir > IncludeEnv) {
            if (*--IncDir == ';') {
                break;
            }
        }

        if (*IncDir == ';') {
            if (cb = (UINT)(IncDirEnd-IncDir-1)) {
                strncpy( path, IncDir+1, cb );
            }
        } else {
            if (cb = (UINT)(IncDirEnd-IncDir)) {
                strncpy( path, IncDir, cb );
            }
        }
        if (cb) {
            path[ cb ] = '\0';
            while (path[ 0 ] == ' ') {
                strcpy( path, &path[ 1 ] );
                cb--;
            }

            while (cb && path[--cb] == ' ') {
                path[ cb ] = '\0';
            }
            if (path[0]) {
                ScanGlobalIncludeDirectory(path);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanSubDir
//
//  Synopsis:   Scans all the files in the given directory, sets the
//              directory flags appropriately (e.g.  DIRDB_SOURCES, etc),
//              and adds a list of interesting files to the Files list in
//              the DirDB structure for the directory.
//
//  Arguments:  [pszDir] -- Name of directory to scan
//              [pdr]    -- [out] Filled in DIRREC on return
//
//  Notes:      An 'interesting' file is one which has a recognized
//              extension.  See the InsertFileDB and MatchFileDesc
//              functions for more info.
//
//----------------------------------------------------------------------------

VOID
ScanSubDir(LPSTR pszDir, DIRREC *pdr)
{
    char FileName[DB_MAX_PATH_LENGTH];
    FILEREC *FileDB, **FileDBNext;
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;
    ULONG DateTime;
    USHORT Attr;

    strcat(pszDir, "\\");
    strcat(pszDir, "*.*");

    pdr->DirFlags |= DIRDB_SCANNED;
    FindHandle = FindFirstFile(pszDir, &FindFileData);
    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        if (DEBUG_1) {
            BuildMsg("FindFirstFile(%s) failed.\n", pszDir);
        }
        return;
    }
    do {
        Attr = (USHORT)(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        if ((Attr & FILE_ATTRIBUTE_DIRECTORY) &&
            (!strcmp(FindFileData.cFileName, ".") ||
             !strcmp(FindFileData.cFileName, ".."))) {
            continue;
        }

        CopyString(FileName, FindFileData.cFileName, TRUE);

        FileTimeToDosDateTime(&FindFileData.ftLastWriteTime,
                              ((LPWORD) &DateTime) + 1,
                              (LPWORD) &DateTime);

        if ((pdr->DirFlags & DIRDB_NEW) == 0 &&
            (FileDB = LookupFileDB(pdr, FileName)) != NULL) {

            if (FileDB->FileFlags & FILEDB_PASS0)
                pdr->DirFlags |= DIRDB_PASS0;

            //
            // Clear the file missing flag, since we know the file exists now.
            // This flag may be set if the file was generated during pass zero.
            //
            if (FileDB->FileFlags & FILEDB_FILE_MISSING)
                FileDB->FileFlags &= ~FILEDB_FILE_MISSING;

            //
            // The time we last stored for this file is different than the
            // actual time on the file, so force it to be rescanned.
            //
            if (FileDB->DateTime != DateTime) {
                if (FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) {
                    FileDB->FileFlags &= ~FILEDB_SCANNED;
                }
                else {
                    FileDB->FileFlags |= FILEDB_SCANNED;
                }

                if (DEBUG_1) {
                    BuildMsg(
                        "%s  -  DateTime (%lx != %lx)\n",
                        FileDB->Name,
                        FileDB->DateTime,
                        DateTime);
                }

                FileDB->DateTime = DateTime;
                FileDB->Attr = Attr;
            }
            else {
                FileDB->FileFlags |= FILEDB_SCANNED;
            }
        }
        else {
            FileDB = InsertFileDB(pdr, FileName, DateTime, Attr, 0);
        }
    } while (FindNextFile(FindHandle, &FindFileData));

    FindClose(FindHandle);

    if ((pdr->DirFlags & DIRDB_DIRS) && (pdr->DirFlags & DIRDB_SOURCES))
    {
        BuildError("%s\\sources. unexpected in directory with DIRS file\n",
                   pdr->Name);
        BuildError("Ignoring %s\\sources.\n", pdr->Name);

        pdr->DirFlags &= ~DIRDB_SOURCES;
    }
    //
    // Scan each file in this directory unless using QuickZero
    //
    if (fQuickZero && fFirstScan)
    {
       return;
    }
    FileDBNext = &pdr->Files;
    while (FileDB = *FileDBNext) {
        if (!(FileDB->FileFlags & (FILEDB_DIR | FILEDB_SCANNED))) {
            if (ScanFile(FileDB)) {
                AllDirsModified = TRUE;
            }
        }
        FileDBNext = &FileDB->Next;
    }
    DeleteUnscannedFiles(pdr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanDirectory
//
//  Synopsis:   Tries to find the given directory in the database, and if
//              not found calls ScanSubDir.
//
//  Arguments:  [pszDir] -- Directory to scan
//
//  Returns:    Filled in DIRREC structure for the directory.
//
//  Notes:      If fQuicky (-z or -Z options) are set, then instead of calling
//              ScanSubDir, which is long, it just checks for known files, like
//              'sources' for 'makefile' to determine whether or not the
//              directory should be compiled.
//
//----------------------------------------------------------------------------

PDIRREC
ScanDirectory(LPSTR pszDir)
{
    DIRREC *pdr;
    char FullPath[DB_MAX_PATH_LENGTH];

    if (DEBUG_1) {
        BuildMsgRaw("ScanDirectory(%s)\n", pszDir);
    }

    if (!CanonicalizePathName(pszDir, CANONICALIZE_DIR, FullPath)) {
        if (DEBUG_1) {
            BuildMsgRaw("CanonicalizePathName failed\n");
        }
        return(NULL);
    }
    pszDir = FullPath;

    if ((pdr = LoadDirDB(pszDir)) == NULL) {
        return(NULL);
    }

    if (fQuicky && (!fQuickZero)) {

        if (!(pdr->DirFlags & DIRDB_SCANNED)) {
            pdr->DirFlags |= DIRDB_SCANNED;
            if (ProbeFile(pdr->Name, "sources") != -1) {
                pdr->DirFlags |= DIRDB_SOURCES | DIRDB_MAKEFILE;
            }
            else
            if (ProbeFile(pdr->Name, "mydirs") != -1 ||
                ProbeFile(pdr->Name, "dirs") != -1 ||
                ProbeFile(pdr->Name, pszTargetDirs) != -1) {

                pdr->DirFlags |= DIRDB_DIRS;
                if (ProbeFile(pdr->Name, "makefil0") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFIL0;
                }
                if (ProbeFile(pdr->Name, "makefil1") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFIL1;
                }
                if (ProbeFile(pdr->Name, "makefile") != -1) {
                    pdr->DirFlags |= DIRDB_MAKEFILE;
                }
            }
        }
        return(pdr);
    }

    if (pdr->DirFlags & DIRDB_SCANNED) {
        return(pdr);
    }

    if (!RecurseLevel && fNoisyScan) {
        ClearLine();
        BuildMsgRaw("    Scanning %s ", pszDir);
        if (fDebug || !(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
        }
    }

    ScanSubDir(pszDir, pdr);

    if (!RecurseLevel) {
        ClearLine();
    }
    return(pdr);
}


#define BUILD_TLIB_INCLUDE_STMT "importlib"
#define BUILD_TLIB_INCLUDE_STMT_LENGTH (sizeof( BUILD_TLIB_INCLUDE_STMT )-1)

#define BUILD_MIDL_INCLUDE_STMT "import"
#define BUILD_MIDL_INCLUDE_STMT_LENGTH (sizeof( BUILD_MIDL_INCLUDE_STMT )-1)

#define BUILD_RC_INCLUDE_STMT "rcinclude"
#define BUILD_RC_INCLUDE_STMT_LENGTH (sizeof( BUILD_RC_INCLUDE_STMT )-1)

#define BUILD_ASN_INCLUDE_STMT "--<"
#define BUILD_ASN_INCLUDE_STMT_LENGTH (sizeof( BUILD_ASN_INCLUDE_STMT )-1)

#define BUILD_INCLUDE_STMT "include"
#define BUILD_INCLUDE_STMT_LENGTH (sizeof( BUILD_INCLUDE_STMT )-1)

#define BUILD_VER_COMMENT "/*++ BUILD Version: "
#define BUILD_VER_COMMENT_LENGTH (sizeof( BUILD_VER_COMMENT )-1)

#define BUILD_MASM_VER_COMMENT ";;;; BUILD Version: "
#define BUILD_MASM_VER_COMMENT_LENGTH (sizeof( BUILD_MASM_VER_COMMENT )-1)


//+---------------------------------------------------------------------------
//
//  Function:   IsIncludeStatement
//
//  Synopsis:   Tries to determine whether or not a given line contains an
//              include statement (e.g. #include <foobar.h> ).
//
//  Arguments:  [pfr] -- FILEREC of file being scanned
//              [p]   -- Current line of file
//
//  Returns:    NULL if line is not an include statment.  Returns pointer to
//              beginning of filename if it is (e.g. <foobar.h> ).
//
//  Notes:      The returned filename includes the surrounding quotes or
//              brackets, if any.  Also, the pointer is just a pointer into
//              the given string, not a separate copy.
//
//              Supported statements are:
//              All file types: #include <filename> and #include "filename"
//              MIDL files:     import "filename"
//              RC files:       rcinclude filename
//              MKTYPLIB files: importlib("filename")
//
//----------------------------------------------------------------------------

#define IsTokenPrefix0(psz, szToken, cchToken)               \
            (strncmp((psz), (szToken), (cchToken)) == 0)

#define IsTokenPrefix(psz, szToken, cchToken)               \
            (IsTokenPrefix0((psz), (szToken), (cchToken)) && \
             (psz)[cchToken] != '\0')

#define IsTokenMatch(psz, szToken, cchToken) \
            (IsTokenPrefix((psz), (szToken), (cchToken)) && \
             !iscsym((psz)[cchToken]))

#define IsCiTokenPrefix0(psz, szToken, cchToken)             \
            (_strnicmp((psz), (szToken), (cchToken)) == 0)

#define IsCiTokenPrefix(psz, szToken, cchToken)             \
            (IsCiTokenPrefix0((psz), (szToken), (cchToken)) && \
             (psz)[cchToken] != '\0')

#define IsCiTokenMatch(psz, szToken, cchToken) \
            (IsCiTokenPrefix((psz), (szToken), (cchToken)) && \
             !iscsym((psz)[cchToken]))

LPSTR
IsIncludeStatement(FILEREC *pfr, LPSTR p)
{
    if (!p || *p == '\0')
        return NULL;

    if (!(pfr->FileFlags & (FILEDB_MASM | FILEDB_MIDL | FILEDB_MKTYPLIB | FILEDB_RC | FILEDB_ASN))) {
        if (*p != '#') {
            return(NULL);
        }
    }

    if (*p == '#')
        p++;

    while (isspace(*p)) {
        p++;
    }

    if (IsTokenMatch(p, BUILD_INCLUDE_STMT, BUILD_INCLUDE_STMT_LENGTH)) {
        p += BUILD_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_MASM) &&
        IsCiTokenMatch(p, BUILD_INCLUDE_STMT, BUILD_INCLUDE_STMT_LENGTH)) {
        p += BUILD_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_MIDL) &&
        IsTokenMatch(p, BUILD_MIDL_INCLUDE_STMT, BUILD_MIDL_INCLUDE_STMT_LENGTH)) {
        p += BUILD_MIDL_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_RC) &&
        IsTokenMatch(p, BUILD_RC_INCLUDE_STMT, BUILD_RC_INCLUDE_STMT_LENGTH)) {

        p += BUILD_RC_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_ASN) &&
        IsTokenPrefix0(p, BUILD_ASN_INCLUDE_STMT, BUILD_ASN_INCLUDE_STMT_LENGTH)) {

        p += BUILD_ASN_INCLUDE_STMT_LENGTH;
    }
    else
    if ((pfr->FileFlags & FILEDB_MKTYPLIB) &&
        IsTokenMatch(p, BUILD_TLIB_INCLUDE_STMT, BUILD_TLIB_INCLUDE_STMT_LENGTH)) {
        p += BUILD_TLIB_INCLUDE_STMT_LENGTH;
        while (isspace(*p)) {
            p++;
        }

        if (*p == '(')   // Skip the open paren and get to the quote.
            p++;
    }
    else {
        return(NULL);
    }

    while (isspace(*p)) {
        p++;
    }
    return(p);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsPragmaHdrStop
//
//  Synopsis:   Determines if the given line is a #pragma hdrstop line
//
//  Arguments:  [p] -- String to analyze
//
//  Returns:    TRUE if the line is a pragma hdrstop
//
//----------------------------------------------------------------------------

BOOL
IsPragmaHdrStop(LPSTR p)
{
    static char szPragma[] = "pragma";
    static char szHdrStop[] = "hdrstop";

    if (*p == '#') {
        while (*++p == ' ') {
            ;
        }
        if (strncmp(p, szPragma, sizeof(szPragma) - 1) == 0 &&
            *(p += sizeof(szPragma) - 1) == ' ') {

            while (*p == ' ') {
                p++;
            }
            if (strncmp(p, szHdrStop, sizeof(szHdrStop) - 1) == 0 &&
                !iscsym(p[sizeof(szHdrStop) - 1])) {

                return(TRUE);
            }
        }
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanFile
//
//  Synopsis:   Scans the given file to determine files which it includes.
//
//  Arguments:  [FileDB] -- File to scan.
//
//  Returns:    TRUE if successful
//
//  Notes:      This function is a nop if the given file does not have either
//              the FILEDB_SOURCE or FILEDB_HEADER flag set.
//              (see InsertSourceDB)
//
//              Note that the performance of this function is critical since
//              it is called for every file in each directory.
//
//----------------------------------------------------------------------------

#define ASN_NONE          0  // not in Asn INCLUDES statement
#define ASN_START         1  // expectimg "INCLUDES" token
#define ASN_FILENAME      2  // expecting a quoted "filename"
#define ASN_COMMA         3  // expecting end token (">--") or comma

#define ASN_CONTINUATION  8  // expecting comment token first

char *
AsnStateToString(UINT AsnState)
{
    static char buf[100];
    char *psz;

    switch (AsnState & ~ASN_CONTINUATION) {
        case ASN_NONE:      psz = "None"; break;
        case ASN_START:     psz = "Start"; break;
        case ASN_FILENAME:  psz = "Filename"; break;
        case ASN_COMMA:     psz = "Comma"; break;
        default:            psz = "???"; break;
    }
    sprintf(buf, "%s%s", psz, (AsnState & ASN_CONTINUATION)? "+Cont" : "");
    return(buf);
}


BOOL
ScanFile(
    PFILEREC FileDB
    )
{
    FILE *FileHandle;
    char CloseQuote;
    LPSTR p;
    LPSTR IncludeFileName, TextLine;
    BOOL fFirst = TRUE;
    USHORT IncFlags = 0;
    UINT i, cline;
    UINT AsnState = ASN_NONE;

    if ((FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_HEADER)) == 0) {
        FileDB->FileFlags |= FILEDB_SCANNED;
        return(TRUE);
    }

    //
    // Don't scan non-pass-zero files if we're doing pass zero.
    //
    if (fPassZero && (FileDB->FileFlags & FILEDB_PASS0) == 0)
        return TRUE;

    if (!SetupReadFile(
            FileDB->Dir->Name,
            FileDB->Name,
            FileDB->pszCommentToEOL,
            &FileHandle)) {
        return(FALSE);
    }

    if (!RecurseLevel && fNoisyScan) {
        ClearLine();
        BuildMsgRaw(
            "    Scanning %s ",
            FormatPathName(FileDB->Dir->Name, FileDB->Name));
        if (!(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
        }
    }

    FileDB->SourceLines = 0;
    FileDB->Version = 0;

    MarkIncludeFileRecords( FileDB );
    FileDB->FileFlags |= FILEDB_SCANNED;

    AllDirsModified = TRUE;

    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        if (fFirst) {
            fFirst = FALSE;
            if (FileDB->FileFlags & FILEDB_HEADER) {
                if (FileDB->FileFlags & FILEDB_MASM) {
                    if (!strncmp( TextLine,
                                  BUILD_MASM_VER_COMMENT,
                                  BUILD_MASM_VER_COMMENT_LENGTH)) {
                        FileDB->Version = (USHORT)
                            atoi( TextLine + BUILD_MASM_VER_COMMENT_LENGTH);
                    }
                }
                else
                if (!strncmp( TextLine,
                              BUILD_VER_COMMENT,
                              BUILD_VER_COMMENT_LENGTH)) {
                    FileDB->Version = (USHORT)
                        atoi( TextLine + BUILD_VER_COMMENT_LENGTH);
                }
            }
        }

        if (AsnState != ASN_NONE) {
            p = TextLine;
        }
        else {
            p = IsIncludeStatement(FileDB, TextLine);
        }

        if (p != NULL) {
            USHORT IncFlagsNew = IncFlags;

            if (FileDB->FileFlags & FILEDB_ASN) {
                if (AsnState & ASN_CONTINUATION) {
                    if (p[0] != '-' || p[1] != '-') {
                        AsnState = ASN_NONE;    // ignore includes and ...
                        p = NULL;
                        break;                  // get next line
                    }
                    p += 2;
                    AsnState &= ~ASN_CONTINUATION;
                }
moreasn:
                while (p != NULL) {
                    while (isspace(*p)) {
                        p++;
                    }
                    if (*p == '\0') {
                        AsnState |= ASN_CONTINUATION;
                        goto nextline;          // get next line
                    }
                    switch (AsnState) {
                        case ASN_NONE:
                            AsnState = ASN_START;
                            continue;                // re-enter state machine

                        case ASN_START:
                            if (!IsTokenPrefix0(
                                        p,
                                        "INCLUDES",
                                        sizeof("INCLUDES") - 1)) {
                                goto terminate;
                            }
                            AsnState = ASN_FILENAME;
                            p += sizeof("INCLUDES") - 1;
                            continue;                // re-enter state machine

                        case ASN_FILENAME:
                            if (*p != '"') {
                                goto terminate;
                            }
                            AsnState = ASN_COMMA;
                            goto parsefilename;

                        case ASN_COMMA:
                            if (*p == '>' && p[1] == '-' && p[2] == '-') {
                                goto terminate;
                            }
                            if (*p != ',') {
                                goto terminate;
                            }
                            p++;
                            AsnState = ASN_FILENAME;
                            continue;                // re-enter state machine
                    }
                    assert(FALSE);            // Bad AsnState
terminate:
                    AsnState = ASN_NONE;    // ignore includes statement, & ...
nextline:
                    p = NULL;               // get next line
                    break;
                }
            }

parsefilename:
            if (p != NULL) {
                CloseQuote = (UCHAR) 0xff;
                if (*p == '<') {
                    p++;
                    CloseQuote = '>';
                }
                else
                if (*p == '"') {
                    p++;
                    IncFlagsNew |= INCLUDEDB_LOCAL;
                    CloseQuote = '"';
                }
                else
                if (FileDB->FileFlags & FILEDB_MASM) {
                    IncFlagsNew |= INCLUDEDB_LOCAL;
                    CloseQuote = ';';
                }

                IncludeFileName = p;
                while (*p != '\0' && *p != CloseQuote && *p != ' ') {
                    p++;
                }
                if (CloseQuote == ';' && (*p == ' ' || *p == '\0')) {
                    CloseQuote = *p;
                }

                if (*p != CloseQuote || CloseQuote == (UCHAR) 0xff) {
                    BuildError(
                        "%s - invalid include statement: %s\n",
                        FormatPathName(FileDB->Dir->Name, FileDB->Name),
                        TextLine);
                    break;
                }

                *p = '\0';
                CopyString(IncludeFileName, IncludeFileName, TRUE);
                for (i = 0; i < CountExcludeIncs; i++) {
                    if (!strcmp(IncludeFileName, ExcludeIncs[i])) {
                        IncludeFileName = NULL;
                        break;
                    }
                }

                if (IncludeFileName != NULL) {
                    InsertIncludeDB(FileDB, IncludeFileName, IncFlagsNew);
                }
                if (FileDB->FileFlags & FILEDB_ASN) {
                    p++;
                    goto moreasn;
                }
            }
        }
        else
        if (IncFlags == 0 &&
            (FileDB->FileFlags & (FILEDB_ASM | FILEDB_MASM | FILEDB_MIDL | FILEDB_ASN | FILEDB_RC | FILEDB_HEADER)) == 0 &&
            IsPragmaHdrStop(TextLine)) {

            IncFlags = INCLUDEDB_POST_HDRSTOP;
        }
    }
    CloseReadFile(&cline);
    FileDB->SourceLines = cline;

    DeleteIncludeFileRecords( FileDB );

    if (!RecurseLevel) {
        ClearLine();
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildexe.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       buildexe.c
//
//  Contents:   Functions related to spawning processes and processing
//              their output, using pipes and multiple threads.
//
//  History:    22-May-89     SteveWo  Created
//                 ... see SLM logs
//              26-Jul-94     LyleC    Cleanup/Add Pass0 Support
//
//----------------------------------------------------------------------------

#include "build.h"

#include <fcntl.h>

//+---------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

#define DEFAULT_LPS     (fStatusTree? 5000 : 50)

#define LastRow(pts)    ((USHORT) ((pts)->cRowTotal - 1))
#define LastCol(pts)    ((USHORT) ((pts)->cColTotal - 1))

typedef struct _PARALLEL_CHILD {
    PTHREADSTATE ThreadState;
    HANDLE       Event;
    CHAR         ExecuteProgramCmdLine[1024];
} PARALLEL_CHILD, *PPARALLEL_CHILD;

ULONG_PTR StartCompileTime;

DWORD OldConsoleMode;
DWORD NewConsoleMode;

HANDLE *WorkerThreads;
HANDLE *WorkerEvents;
ULONG NumberProcesses;
ULONG ThreadsStarted;

BOOLEAN fConsoleInitialized = FALSE;
BYTE ScreenCell[2];
BYTE StatusCell[2];

#define STATE_UNKNOWN       0
#define STATE_COMPILING     1
#define STATE_ASSEMBLING    2
#define STATE_LIBING        3
#define STATE_LINKING       4
#define STATE_C_PREPROC     5
#define STATE_S_PREPROC     6
#define STATE_PRECOMP       7
#define STATE_MKTYPLIB      8
#define STATE_MIDL          9
#define STATE_MC            10
#define STATE_STATUS        11
#define STATE_BINPLACE      12
#define STATE_VCTOOL        13
#define STATE_ASN           14
#define STATE_PACKING       15

#define FLAGS_CXX_FILE              0x0001
#define FLAGS_WARNINGS_ARE_ERRORS   0x0002

LPSTR States[] = {
    "Unknown",                      // 0
    "Compiling",                    // 1
    "Assembling",                   // 2
    "Building Library",             // 3
    "Linking Executable",           // 4
    "Preprocessing",                // 5
    "Assembling",                   // 6
    "Compiling Precompiled Header", // 7
    "Building Type Library",        // 8
    "Running MIDL on",              // 9
    "Compiling message file",       // 10
    "Build Status Line",            // 11
    "Binplacing",                   // 12
    "Processing",                   // 13
    "Running ASN Compiler on",      // 14
    "Packing Theme",                // 15
};

//----------------------------------------------------------------------------
//
// Function prototypes
//
//----------------------------------------------------------------------------

VOID
GetScreenSize(THREADSTATE *ThreadState);

VOID
GetCursorPosition(USHORT *pRow, USHORT *pCol, USHORT *pRowTop);

VOID
SetCursorPosition(USHORT Row, USHORT Col);

VOID
WriteConsoleCells(
    LPSTR String,
    USHORT StringLength,
    USHORT Row,
    USHORT Col,
    BYTE *Attribute);

VOID
MoveRectangleUp (
    USHORT Top,
    USHORT Left,
    USHORT Bottom,
    USHORT Right,
    USHORT NumRow,
    BYTE  *FillCell);

VOID
ReadConsoleCells(
    BYTE *pScreenCell,
    USHORT cb,
    USHORT Row,
    USHORT Column);

VOID
ClearRows(
    PTHREADSTATE ThreadState,
    USHORT Top,
    USHORT NumRows,
    PBYTE  Cell
    );

LPSTR
IsolateFirstToken(
    LPSTR *pp,
    CHAR delim
    );

LPSTR
IsolateLastToken(
    LPSTR p,
    CHAR delim
    );

DWORD
ParallelChildStart(
    PPARALLEL_CHILD Data
    );

DWORD
PipeSpawnClose (
    FILE *pstream
    );

FILE *
PipeSpawn (
    const CHAR *cmdstring
    );

BOOL
DetermineChildState(
    PTHREADSTATE ThreadState,
    LPSTR p
    );

void
PrintChildState(
    PTHREADSTATE ThreadState,
    LPSTR p,
    PFILEREC FileDB
    );


//+---------------------------------------------------------------------------
//
//  Function:   RestoreConsoleMode
//
//----------------------------------------------------------------------------

VOID
RestoreConsoleMode(VOID)
{
    SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), OldConsoleMode);
    NewConsoleMode = OldConsoleMode;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsolateFirstToken
//
//  Synopsis:   Returns the first token in a string.
//
//  Arguments:  [pp]    -- String to parse
//              [delim] -- Token delimiter
//
//  Returns:    Pointer to first token
//
//  Notes:      Leading spaces are ignored.
//
//----------------------------------------------------------------------------

LPSTR
IsolateFirstToken(
    LPSTR *pp,
    CHAR delim
    )
{
    LPSTR p, Result;

    p = *pp;
    while (*p <= ' ') {
        if (!*p) {
            *pp = p;
            return( "" );
            }
        else
            p++;
        }

    Result = p;
    while (*p) {
        if (*p == delim) {
            *p++ = '\0';
            break;
            }
        else {
            p++;
            }
        }
    *pp = p;
    if (*Result == '.' && Result[1] == '\\') {
        return( Result+2 );
        }
    else {
        return( Result );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsolateLastToken
//
//  Synopsis:   Return the last token in a string.
//
//  Arguments:  [p]     -- String to parse
//              [delim] -- Token delimiter
//
//  Returns:    Pointer to last token
//
//  Notes:      Trailing spaces are skipped.
//
//----------------------------------------------------------------------------

LPSTR
IsolateLastToken(
    LPSTR p,
    CHAR delim
    )
{
    LPSTR Start;

    Start = p;
    while (*p) {
        p++;
        }

    while (--p > Start) {
        if (*p <= ' ') {
            *p = '\0';
            }
        else
            break;
        }

    while (p > Start) {
        if (*--p == delim) {
            p++;
            break;
            }
        }

    if (*p == '.' && p[1] == '\\') {
        return( p+2 );
        }
    else {
        return( p );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   TestPrefix
//
//  Synopsis:   Returns TRUE if [Prefix] is the first part of [pp]
//
//----------------------------------------------------------------------------

BOOL
TestPrefix(
    LPSTR  *pp,
    LPSTR Prefix
    )
{
    LPSTR p = *pp;
    UINT cb;

    if (!_strnicmp( p, Prefix, cb = strlen( Prefix ) )) {
        *pp = p + cb;
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   TestPrefixPath
//
//  Synopsis:   Returns TRUE if [Prefix] is the first part of [pp]
//              If the firstpart of [pp] (excluding whitespace) contains
//              backslashes, then only the right-most component is used
//
//----------------------------------------------------------------------------

BOOL
TestPrefixPath(
    LPSTR  *pp,
    LPSTR Prefix
    )
{
    LPSTR p = *pp;
    UINT cb;
    LPSTR PathString;
    INT PathStringLength ;
    LPSTR LastComp ;

    cb = strlen( Prefix );

    if (_strnicmp( p, Prefix, cb ) == 0 ) {
        *pp = p + cb;
        return( TRUE );
        }
    else {
        PathString = strchr( p, ' ' );

        if ( PathString ) {
            PathStringLength = (INT) (PathString - p) ;

            *PathString = '\0';

            LastComp = strrchr( p, '\\' );

            *PathString = ' ';

            if ( LastComp ) {

                if ( _strnicmp( p, Prefix, cb ) == 0 ) {
                    *pp = p + cb ;
                    return( TRUE );
                    }
                }

            }

        return( FALSE );

        }
}


//+---------------------------------------------------------------------------
//
//  Function:   Substr
//
//----------------------------------------------------------------------------

BOOL
Substr(
    LPSTR s,
    LPSTR p
    )
{
    LPSTR x;

    while (*p) {
        x = s;
        while (*p++ == *x) {
            if (*x == '\0') {
                return( TRUE );
                }
            x++;
            }
        if (*x == '\0') {
            return( TRUE );
            }
        }
    return( FALSE );
}



//+---------------------------------------------------------------------------
//
//  Function:   WriteTTY
//
//  Synopsis:   Writes the given string to the output device.
//
//  Arguments:  [ThreadState]   -- Struct containing info about the output dev.
//              [p]             -- String to display
//              [fStatusOutput] -- If TRUE then put on the status line.
//
//----------------------------------------------------------------------------

VOID
WriteTTY (THREADSTATE *ThreadState, LPSTR p, BOOL fStatusOutput)
{
    USHORT SaveRow;
    USHORT SaveCol;
    USHORT SaveRowTop;
    USHORT cb, cbT;
    PBYTE Attribute;
    BOOL ForceNewline;

    //
    // If we're not writing to the screen then don't do anything fancy, just
    // output the string.
    //
    if (!fStatus || !ThreadState->IsStdErrTty) {
        while (TRUE) {
            int cch;

            cch = strcspn(p, "\r");
            if (cch != 0) {
                fwrite(p, 1, cch, stderr);
                p += cch;
            }
            if (*p == '\0') {
                break;
            }
            if (p[1] != '\n') {
                fwrite(p, 1, 1, stderr);
            }
            p++;
        }
        fflush(stderr);
        return;
    }
    assert(ThreadState->cColTotal != 0);
    assert(ThreadState->cRowTotal != 0);

    //
    // Scroll as necessary
    //
    GetCursorPosition(&SaveRow, &SaveCol, &SaveRowTop);

    //  During processing, there might be N threads that are displaying
    //  messages and a single thread displaying directory-level
    //  linking and building messages.  We need to make sure there's room for
    //  the single thread's message as well as ours.  Since that single
    //  thread displays one line at a time (including CRLF) we must make sure
    //  that his display (as well as ours) doesn't inadvertantly scroll
    //  the status line at the top.  We do this by guaranteeing that there is
    //  a blank line at the end.


    //  We are synchronized with the single top-level thread
    //  at a higher level than this routine via TTYCriticalSection.  We
    //  are, thus, assured that we control the cursor completely.


    //  Stay off the LastRow
    if (SaveRow == LastRow(ThreadState)) {
        USHORT RowTop = 2;

        if (fStatus) {
            RowTop += SaveRowTop + (USHORT) NumberProcesses + 1;
        }

        MoveRectangleUp (
            RowTop,                     // Top
            0,                          // Left
            LastRow(ThreadState),       // Bottom
            LastCol(ThreadState),       // Right
            2,                          // NumRow
            ScreenCell);                // FillCell

        SaveRow -= 2;
        SetCursorPosition(SaveRow, SaveCol);
    }

    //
    // Different color for the status line.
    //
    if (fStatusOutput) {
        Attribute = &StatusCell[1];
    }
    else {
        Attribute = &ScreenCell[1];
    }
    cb = (USHORT) strlen(p);

    //
    // Write out the string.
    //
    while (cb > 0) {
        ForceNewline = FALSE;

        if (cb > 1) {
            if (p[cb - 1] == '\n' && p[cb - 2] == '\r') {
                cb -= 2;
                ForceNewline = TRUE;
            }
        }

        if (cb >= ThreadState->cColTotal - SaveCol) {
            cbT = ThreadState->cColTotal - SaveCol;
            if (fFullErrors)
                ForceNewline = TRUE;
        }
        else {
            cbT = cb;
        }

        WriteConsoleCells(p, cbT, SaveRow, SaveCol, Attribute);
        SetCursorPosition(SaveRow, SaveCol);

        if (ForceNewline) {
            SaveCol = 0;
            SaveRow++;
        }
        else {
            SaveCol += cbT;
        }

        if (!fFullErrors) {
            break;
        }

        if (cb > cbT) {
            // we have more to go... do a newline

            //  If we're back at the beginning of the bottom line
            if (SaveRow == LastRow(ThreadState)) {
                USHORT RowTop = 1;

                if (fStatus) {
                    RowTop += SaveRowTop + (USHORT) NumberProcesses + 1;
                }

                // move window up one line (leaving two lines blank at bottom)
                MoveRectangleUp (
                    RowTop,                     // Top
                    0,                          // Left
                    LastRow(ThreadState),       // Bottom
                    LastCol(ThreadState),       // Right
                    1,                          // NumRow
                    ScreenCell);                // FillCell

                SaveRow--;
            }
            SetCursorPosition(SaveRow, SaveCol);
        }

        cb -= cbT;
        p += cbT;
    }

    SetCursorPosition(SaveRow, SaveCol);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteTTYLoggingErrors
//
//  Synopsis:   Writes a message to the appropriate log file and also the
//              screen if specified.
//
//  Arguments:  [Warning]     -- TRUE if the message is a warning
//              [ThreadState] -- Info about output device
//              [p]           -- String
//
//----------------------------------------------------------------------------

VOID
WriteTTYLoggingErrors(
    BOOL Warning,
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    UINT cb;

    if (fErrorLog) {
        cb = strlen( p );
        fwrite( p, 1, cb, Warning ? WrnFile : ErrFile );
    }
    if (fShowWarningsOnScreen && Warning)
    {
        WriteTTY(ThreadState, p, FALSE);
        return;
    }
    if (!fErrorLog || !Warning) {
        WriteTTY(ThreadState, p, FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MsCompilerFilter
//
//  Synopsis:   Filters output from the compiler so we know what's happening
//
//  Arguments:  [ThreadState] -- State of thread watching the compiler
//                               (compiling, linking, etc...)
//              [p]           -- Message we're trying to parse.
//              [FileName]    -- [out] Filename in message
//              [LineNumber]  -- [out] Line number in message
//              [Message]     -- [out] Message number (for post processing)
//              [Warning]     -- [out] TRUE if message is a warning.
//
//  Returns:    TRUE  - Message is an error or warning
//              FALSE - Message is not an error or a warning
//
//  History:    26-Jul-94     LyleC    Created
//
//  Notes:
//
//    This routine filters strings in the MS compiler format.  That is:
//
//       {toolname} : {number}: {text}
//
//    where:
//
//        toolname    If possible, the container and specific module that has
//                    the error.  For instance, the compiler uses
//                    filename(linenum), the linker uses library(objname), etc.
//                    If unable to provide a container, use the tool name.
//        number      A number, prefixed with some tool identifier (C for
//                    compiler, LNK for linker, LIB for librarian, N for nmake,
//                    etc).
//        test        The descriptive text of the message/error.
//
//        Accepted String formats are:
//
//        container(module): error/warning NUM ...
//        container(module) : error/warning NUM ...
//        container (module): error/warning NUM ...
//        container (module) : error/warning NUM ...
//
//----------------------------------------------------------------------------

BOOL
MsCompilerFilter(
    PTHREADSTATE ThreadState,
    LPSTR p,
    LPSTR *FileName,
    LPSTR *LineNumber,
    LPSTR *Message,
    BOOL *Warning
    )
{
    LPSTR p1;
    BOOL fCommandLineWarning;

    *Message = NULL;

    p1 = p;

    if (strstr(p, "Compiler error (")) {
        *Message = p;
        *Warning = FALSE;
        if ((p1 = strstr( p, "source=" )))
            *LineNumber = p1+7;
        else
            *LineNumber = "1";
        *FileName = ThreadState->ChildCurrentFile;
        return TRUE;
    }

    if (0 == strncmp(p, "fatal error ", strlen("fatal error "))) {
        *Message = p;
        *Warning = FALSE;
        *LineNumber = "1";
        *FileName = ThreadState->ChildCurrentFile;
        return TRUE;
    }

    // First look for the " : " or "): " sequence.

    while (*p1) {
        if ((p1[0] == ')') && (p1[1] == ' ')) p1++;

        if ((p1[0] == ' ') || (p1[0] == ')')) {
            if (p1[1] == ':') {
                if (p1[2] == ' ') {
                    *Message = p1 + 3;
                    *p1 = '\0';

                    break;
                }
                else
                    break;   // No sense going any further
            }
            else if ((p1[0] == ' ') && (p1[1] == '('))
                p1++;
            else
                break;   // No sense going any further
        }
        else
            p1++;
    }

    if (*Message != NULL) {
        // then figure out if this is an error or warning.

        *Warning = TRUE;        // Assume the best.
        fCommandLineWarning = FALSE;

        if (TestPrefix( Message, "error " ) ||
            TestPrefix( Message, "fatal error " ) ||
            TestPrefix( Message, "command line error " ) ||
            TestPrefix( Message, "Compiler error " )) {
            *Warning = FALSE;
        } else
        if (TestPrefix( Message, "warning " )) {
            *Warning = TRUE;
        } else
        if (TestPrefix( Message, "command line warning " )) {
            // Command-line warnings don't count when considering whether
            // warnings should be errors (under /WX).
            *Warning = TRUE;
            fCommandLineWarning = TRUE;
        }

        if (!fCommandLineWarning && (ThreadState->ChildFlags & FLAGS_WARNINGS_ARE_ERRORS) != 0) {
            if (Substr( "X0000", *Message )) {
                *Warning = TRUE;   // Special case this one. Never an error
            } else {
                *Warning = FALSE;  // Warnings treated as errors for this compile
            }
        }

        // Set the container name and look for the module paren's

        *FileName = p;
        *LineNumber = NULL;

        p1 = p;

        while (*p1) {
            if (*p1 == '(' && p1[1] != ')') {
                *p1 = '\0';
                p1++;
                *LineNumber = p1;
                while (*p1) {
                    if (*p1 == ')') {
                        *p1 = '\0';
                        break;
                    }
                    p1++;
                }

                break;
            }

            p1++;
        }

        return(TRUE);
    }

    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatMsErrorMessage
//
//  Synopsis:   Take the information obtained from MsCompilerFilter,
//              reconstruct the error message, and print it to the screen.
//
//----------------------------------------------------------------------------

VOID
FormatMsErrorMessage(
    PTHREADSTATE ThreadState,
    LPSTR FileName,
    LPSTR LineNumber,
    LPSTR Message,
    BOOL Warning
    )
{
    char *DirectoryToUse;

    if (ThreadState->ChildState == STATE_LIBING) {
        if (Warning) {
            NumberLibraryWarnings++;
            }
        else {
            NumberLibraryErrors++;
            }
        }
    else
    if (ThreadState->ChildState == STATE_LINKING) {
        if (Warning) {
            NumberLinkWarnings++;
            }
        else {
            NumberLinkErrors++;
            }
        }
    else if (ThreadState->ChildState == STATE_BINPLACE) {
        if (Warning) {
            NumberBinplaceWarnings++;
            }
        else {
            NumberBinplaceErrors++;
            }
    }
    else {
        if (Warning) {
            NumberCompileWarnings++;
            }
        else {
            NumberCompileErrors++;
            if (ThreadState->CompileDirDB) {
                ThreadState->CompileDirDB->DirFlags |= DIRDB_COMPILEERRORS;
                }
            }
        }

    if (fParallel && !fNoThreadIndex) {
        char buffer[50];
        sprintf(buffer, "%d>", ThreadState->ThreadIndex);
        WriteTTYLoggingErrors(Warning, ThreadState, buffer);
    }

    if (FileName) {
        DirectoryToUse = ThreadState->ChildCurrentDirectory;

        if (TestPrefix( &FileName, CurrentDirectory )) {
            DirectoryToUse = CurrentDirectory;
            if (*FileName == '\\') {
                FileName++;
                }
            }

        if (TestPrefix( &FileName, ThreadState->ChildCurrentDirectory )) {
            DirectoryToUse = ThreadState->ChildCurrentDirectory;
            if (*FileName == '\\') {
                FileName++;
                }
            }

        WriteTTYLoggingErrors( Warning,
                               ThreadState,
                               FormatPathName( DirectoryToUse,
                                               FileName
                                             )
                             );
        }

    WriteTTYLoggingErrors( Warning, ThreadState, "(" );
    if (LineNumber) {
        WriteTTYLoggingErrors( Warning, ThreadState, LineNumber );
        }
    WriteTTYLoggingErrors( Warning, ThreadState, ") : " );
    if (Warning) {
        WriteTTYLoggingErrors( Warning, ThreadState, "warning " );
        }
    else {
        WriteTTYLoggingErrors( Warning, ThreadState, "error " );
        }
    WriteTTYLoggingErrors( Warning, ThreadState, Message );
    WriteTTYLoggingErrors( Warning, ThreadState, "\r\n" );
}


//+---------------------------------------------------------------------------
//
//  Function:   PassThrough
//
//  Synopsis:   Keep track of and print the given message without any
//              filtering.
//
//  Arguments:  [ThreadState] --
//              [p]           -- Message
//              [Warning]     -- TRUE if warning
//
//  Returns:    FALSE
//
//----------------------------------------------------------------------------

BOOL
PassThrough(
    PTHREADSTATE ThreadState,
    LPSTR p,
    BOOL Warning
    )
{
    if (ThreadState->ChildState == STATE_LIBING) {
        if (Warning) {
            NumberLibraryWarnings++;
            }
        else {
            NumberLibraryErrors++;
            }
        }
    else
    if (ThreadState->ChildState == STATE_LINKING) {
        if (Warning) {
            NumberLinkWarnings++;
            }
        else {
            NumberLinkErrors++;
            }
        }
    else
    if (ThreadState->ChildState == STATE_BINPLACE) {
        if (Warning) {
            NumberBinplaceWarnings++;
            }
        else {
            NumberBinplaceErrors++;
            }
        }
    else {
        if (Warning) {
            NumberCompileWarnings++;
            }
        else {
            NumberCompileErrors++;
            if (ThreadState->CompileDirDB) {
                ThreadState->CompileDirDB->DirFlags |= DIRDB_COMPILEERRORS;
                }
            }
        }

    if (fParallel && !fNoThreadIndex) {
        char buffer[50];
        sprintf(buffer, "%d>", ThreadState->ThreadIndex);
        WriteTTYLoggingErrors(Warning, ThreadState, buffer);
    }

    WriteTTYLoggingErrors( Warning, ThreadState, p );
    WriteTTYLoggingErrors( Warning, ThreadState, "\r\n" );
    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   PassThroughFilter
//
//  Synopsis:   Straight pass-through filter for compiler messages
//
//----------------------------------------------------------------------------

BOOL
PassThroughFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    return PassThrough( ThreadState, p, FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   C510Filter
//
//  Synopsis:   Compiler filter which strips out unwanted warnings.
//
//  Arguments:  [ThreadState] --
//              [p]           --
//
//----------------------------------------------------------------------------

BOOL
C510Filter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR t;
    PFILEREC FileDB;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        if (fSilent && Warning) {
            if (Substr( "C4001", Message ) ||
                Substr( "C4010", Message ) ||
                Substr( "C4056", Message ) ||
                Substr( "C4061", Message ) ||
                Substr( "C4100", Message ) ||
                Substr( "C4101", Message ) ||
                Substr( "C4102", Message ) ||
                Substr( "C4127", Message ) ||
                Substr( "C4135", Message ) ||
                Substr( "C4201", Message ) ||
                Substr( "C4204", Message ) ||
                Substr( "C4208", Message ) ||
                Substr( "C4509", Message )
               ) {
                return( FALSE );
                }

            if (ThreadState->ChildFlags & FLAGS_CXX_FILE) {
                if (Substr( "C4047", Message ) ||
                    Substr( "C4022", Message ) ||
                    Substr( "C4053", Message )
                   ) {
                    return( FALSE );
                    }
                }
            }

        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
        }
    else {

        // If we're compiling, then the compiler spits out various bit of info,
        // namely:
        //      1. filename alone on a line (.c, .cpp, .cxx)
        //      2. "Generating Code..." when the back-end is invoked
        //      3. "Compiling..." when the front-end is invoked again

        if (ThreadState->ChildState == STATE_COMPILING) {

            if (0 == strcmp(p, "Generating Code...")) {

                strcpy( ThreadState->ChildCurrentFile, "Generating Code..." );
                PrintChildState(ThreadState, p, NULL);
                return FALSE;
            }

            t = strrchr(p, '.');
            if (t != NULL &&
                (0 == strcmp(t, ".cxx") ||
                 0 == strcmp(t, ".cpp") ||
                 0 == strcmp(t, ".c"))) {
 
                strcpy( ThreadState->ChildCurrentFile, IsolateLastToken(p, ' '));
//                strcpy(ThreadState->ChildCurrentFile, p);
                if (strstr(ThreadState->ChildCurrentFile, ".cxx") ||
                    strstr(ThreadState->ChildCurrentFile, ".cpp")) {
                    ThreadState->ChildFlags |= FLAGS_CXX_FILE;
                } else {
                    ThreadState->ChildFlags &= ~FLAGS_CXX_FILE;
                }

                FileDB = NULL;
                if (ThreadState->CompileDirDB) {
                    NumberCompiles++;
                    CopyString(                         // fixup path string
                        ThreadState->ChildCurrentFile,
                        ThreadState->ChildCurrentFile,
                        TRUE);

                    if (!fQuicky) {
                        FileDB = FindSourceFileDB(
                                    ThreadState->CompileDirDB,
                                    ThreadState->ChildCurrentFile,
                                    NULL);
                    }
                }

                PrintChildState(ThreadState, p, FileDB);
                return FALSE;
            }
        }

        return( FALSE );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   MSToolFilter
//
//----------------------------------------------------------------------------

BOOL
MSToolFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


BOOL
LinkFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    );

//+---------------------------------------------------------------------------
//
//  Function:   LinkFilter1
//
//----------------------------------------------------------------------------

BOOL
LinkFilter1(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR p1;
    char buffer[ 256 ];

    if (p[ strlen( p ) - 1 ] == ':') {
        return( LinkFilter( ThreadState, p ) );
        }

    p1 = p;
    while (*p1) {
        if (*p1 == '(') {
            *p1++ = 0;
            if (*p1 == '.' && p1[1] == '\\') {
                p1 += 2;
                }
            FileName = p1;
            while (*p1) {
                if (*p1 == ')') {
                    *p1++ = 0;
                    strcpy( buffer, "L2029: Unresolved external reference to " );
                    strcat( buffer, ThreadState->UndefinedId );
                    FormatMsErrorMessage( ThreadState, FileName, "1",
                                          buffer, FALSE
                                        );
                    return( TRUE );
                    }
                else {
                    p1++;
                    }
                }
            }
        else {
            p1++;
            }
        }

    return( FALSE  );
}


//+---------------------------------------------------------------------------
//
//  Function:   LinkFilter
//
//----------------------------------------------------------------------------

BOOL
LinkFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR p1;

    p1 = p;
    while (*p1) {
        if (*p1 == ':') {
            if (p1[-1] == ']') {
                return( FALSE );
                }

            if (p1[-1] == ' ' && p1[1] == ' ') {
                if (MsCompilerFilter( ThreadState, p,
                                      &FileName,
                                      &LineNumber,
                                      &Message,
                                      &Warning
                                    )
                   ) {

                    if (!Warning || !(_strnicmp(Message, "L4021", 5) ||
                          _strnicmp(Message, "L4038", 5) ||
                              _strnicmp(Message, "L4046", 5))) {
                        if (LineNumber)
                            FileName = LineNumber;
                        if (FileName[0] == '.' && FileName[1] == '\\') {
                            FileName += 2;
                            }
                        FormatMsErrorMessage( ThreadState, FileName, "1",
                                              Message, FALSE );
                        return( TRUE );
                        }
                    }

                   FormatMsErrorMessage( ThreadState, FileName, "1",
                                           Message, TRUE );


                return( TRUE );
                }

            if (p1[-1] == ')') {
                p1 -= 11;
                if (p1 > p && !strcmp( p1, " in file(s):" )) {
                    strcpy( ThreadState->UndefinedId,
                            IsolateFirstToken( &p, ' ' )
                          );
                    ThreadState->FilterProc = LinkFilter1;
                    return( TRUE );
                    }
                }

            return( FALSE );
            }
        else {
            p1++;
            }
        }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CoffFilter
//
//----------------------------------------------------------------------------

BOOL
CoffFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;

    if (MsCompilerFilter( ThreadState, p,
                          &FileName,
                          &LineNumber,
                          &Message,
                          &Warning
                        )
       ) {
        if (fSilent && Warning) {
            if (Substr( "LNK4016", Message )) {
                Warning = FALSE;        // undefined turns into an error
                                        // for builds
                }
            }

        FormatMsErrorMessage( ThreadState,
                              FileName, LineNumber, Message, Warning );
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   ClRiscFilter
//
//  Synopsis:   Risc compiler filter
//
//  Note:  It may be possible to remove this filter.
//
//----------------------------------------------------------------------------

BOOL
ClRiscFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR FileName;
    LPSTR LineNumber;
    LPSTR Message;
    BOOL Warning;
    LPSTR q;

    if (TestPrefix( &p, "cfe: " )) {
        if (strncmp(p, "Error: ", strlen("Error: ")) == 0) {
            p += strlen("Error: ");
            Warning = FALSE;

        } else if (strncmp(p, "Warning: ", strlen("Warning: ")) == 0) {
            p += strlen("Warning: ");
            Warning = TRUE;
        } else {
            return(FALSE);
        }

        q = p;
        if (p = strstr( p, ".\\\\" )) {
            p += 3;
        } else {
            p = q;
        }

        FileName = p;
        while (*p > ' ') {
            if (*p == ',' || (*p == ':' && *(p+1) == ' ')) {
                *p++ = '\0';
                break;
                }

            p++;
            }

        if (*p != ' ') {
            return( FALSE );
            }

        *p++ = '\0';

        if (strcmp(p, "line ") == 0) {
            p += strlen("line ");

        }

        LineNumber = p;
        while (*p != '\0' && *p != ':') {
            p++;
            }

        if (*p != ':') {
            return( FALSE );
            }

        *p++ = '\0';
        if (*p == ' ') {
            Message = p+1;
            ThreadState->LinesToIgnore = 2;

            if (fSilent && Warning) {
                if (!strcmp( Message, "Unknown Control Statement" )
                   ) {
                    return( FALSE );
                    }
                }

            FormatMsErrorMessage( ThreadState,
                                  FileName,
                                  LineNumber,
                                  Message,
                                  Warning
                                );
            return( TRUE );
            }
        }
    //
    // If we did not recognize the cfe compiler, pass it to the MS compiler
    // message filter
    //

    return( C510Filter( ThreadState, p ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   MgClientFilter
//
//----------------------------------------------------------------------------

BOOL
MgClientFilter(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    return( PassThrough( ThreadState, p, TRUE ) );
}

BOOL fAlreadyUnknown = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   DetermineChildState
//
//  Synopsis:   Parse the message given by the compiler (or whatever) and try
//              to figure out what it's doing.
//
//  Arguments:  [ThreadState] -- Current thread state
//              [p]           -- New message string
//
//  Returns:    TRUE if we figured it out, FALSE if we didn't recognize
//              anything.
//
//----------------------------------------------------------------------------

BOOL
DetermineChildState(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    PFILEREC FileDB;
    LPSTR FileName;
    BOOL fPrintChildState = TRUE;

    //
    // ************ Determine what state the child process is in.
    //               (Compiling, linking, running MIDL, etc.)
    //
    if ( TestPrefix( &p, "rc ") ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "rc16 ") ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if ( TestPrefix( &p, "cl " )  || TestPrefix( &p, "cl386 " ) ) {
        LPSTR pch;
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = C510Filter;
        ThreadState->ChildFlags = 0;
        if ( strstr( p, "/WX" ) != NULL || strstr( p, "-WX" ) != NULL) {
            ThreadState->ChildFlags |= FLAGS_WARNINGS_ARE_ERRORS;
        }
        if ((strstr( p, "/EP " ) != NULL) ||
            (strstr( p, "/E " ) != NULL) ||
            (strstr( p, "/P " ) != NULL) ||
            (strstr( p, "-EP " ) != NULL) ||
            (strstr( p, "-E " ) != NULL) ||
            (strstr( p, "-P " ) != NULL)
           ) {
            if (strstr( p, "amd64") || strstr( p, "AMD64")) {
                ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
            else if (strstr( p, "i386") || strstr( p, "I386")) {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }
            else if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
            else {
                ThreadState->ChildTarget = "unknown target";
            }

            strcpy( ThreadState->ChildCurrentFile,IsolateLastToken( p, ' ' ) );
            if ( strstr( p, ".s" ) != NULL )
                ThreadState->ChildState = STATE_S_PREPROC;
            else
                ThreadState->ChildState = STATE_C_PREPROC;
            }
        else
        if ( (pch = strstr( p, "/Yc" )) != NULL ) {
            size_t namelen = strcspn( pch+3, " \t" );
            if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            } else if (strstr( p, "amd64") || strstr( p, "AMD64")) {
                ThreadState->ChildTarget = Amd64TargetMachine.Description;
            } else {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }

            ThreadState->ChildState = STATE_PRECOMP;
            strncpy( ThreadState->ChildCurrentFile,
                     pch + 3, namelen
                  );
            ThreadState->ChildCurrentFile[namelen] = '\0';
            }
        else {
            if (strstr( p, "ia64") || strstr( p, "IA64")) {
                ThreadState->ChildTarget = ia64TargetMachine.Description;
            } else if (strstr( p, "amd64") || strstr( p, "AMD64")) {
                ThreadState->ChildTarget = Amd64TargetMachine.Description;
            } else {
                ThreadState->ChildTarget = i386TargetMachine.Description;
            }
            ThreadState->ChildState = STATE_COMPILING;
            strcpy( ThreadState->ChildCurrentFile, "" );
            fPrintChildState = FALSE;
            }
        }
    else
    if ( TestPrefixPath( &p, "csc " ) || TestPrefixPath( &p, "csc.exe " ) ) {
        
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
    }
    else

    if ( TestPrefix( &p, "cl16 " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = C510Filter;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        ThreadState->ChildState = STATE_COMPILING;
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' ));
        }
    else

    if ((TestPrefix( &p, "ml " )) ||
        (TestPrefix( &p, "ml64 " ))) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "masm386 ") || TestPrefix( &p, "masm ")) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildState = STATE_ASSEMBLING;
        ThreadState->ChildFlags = 0;
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        if (strstr(p, ",")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken(IsolateFirstToken(&p,','), ' '));
            }
        else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateLastToken(IsolateFirstToken(&p,';'), ' '));
            }

        }
    else

    if (TestPrefix( &p, "lib " ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        if (TestPrefix( &p, "-out:" )) {
            ThreadState->LinesToIgnore = 1;
            ThreadState->ChildState = STATE_LIBING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            }
        else
        if (TestPrefix( &p, "-def:" )) {
            ThreadState->LinesToIgnore = 1;
            ThreadState->ChildState = STATE_LIBING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            if (TestPrefix( &p, "-out:" )) {
                strcpy( ThreadState->ChildCurrentFile,
                        IsolateFirstToken( &p, ' ' )
                      );
                }
            }
        else {
            return FALSE;
            }
        }
    else

    if (TestPrefix( &p, "lib16 " ) || TestPrefix( &p, "implib " ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        ThreadState->FilterProc = MSToolFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_LIBING;
        if (strstr(p, ";")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ';' ));
            }
        else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' ));
            }
        }
    else

    if (TestPrefix( &p, "link " ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }
        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        if (TestPrefix( &p, "-out:" )) {
            ThreadState->LinesToIgnore = 2;
            ThreadState->ChildState = STATE_LINKING;
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ' ' )
                  );
            }
        }
    else

    if (TestPrefix( &p, "link16" ) ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }
        if (strstr( p, "amd64") || strstr( p, "AMD64")) {
            ThreadState->ChildTarget = Amd64TargetMachine.Description;
            }
        else if (strstr( p, "i386") || strstr( p, "I386")) {
            ThreadState->ChildTarget = i386TargetMachine.Description;
            }
        else if (strstr( p, "ia64") || strstr( p, "IA64")) {
            ThreadState->ChildTarget = ia64TargetMachine.Description;
            }
        else {
            ThreadState->ChildTarget = "unknown target";
            }

        ThreadState->FilterProc = LinkFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_LINKING;
        p = IsolateLastToken(p, ' ');
        if (strstr(p, ";")) {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ';' ));
            }
        else {
            strcpy( ThreadState->ChildCurrentFile,
                    IsolateFirstToken( &p, ',' ));
            }

        }
    else


    if (TestPrefix( &p, "icl ")) {
        while (*p == ' ') {
            p++;
            }
        ThreadState->ChildState = STATE_COMPILING;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = ia64TargetMachine.Description;
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "mktyplib " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_MKTYPLIB;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "MC: Compiling " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_MC;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "midl " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_MIDL;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile,
                IsolateLastToken( p, ' ' )
              );
        }
    else

    if (TestPrefix( &p, "asn1 " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_ASN;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "all platforms";
        ThreadState->FilterProc = C510Filter;

        strcpy(ThreadState->ChildCurrentFile, IsolateLastToken(p, ' '));
        }
    else

    if (TestPrefix( &p, "Build_Status " )) {
        while (*p == ' ') {
            p++;
            }

        ThreadState->ChildState = STATE_STATUS;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildTarget = "";
        ThreadState->FilterProc = C510Filter;

        strcpy( ThreadState->ChildCurrentFile, "" );
        }

    else
    if (TestPrefix( &p, "binplace " )) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string

        NumberBinplaces++;

        while (*p == ' ') {
            p++;
        }

        // If this is a standard link/binplace step, don't tell the
        // user what's going on, just pass any errors/warnings to
        // the output.  If this is a straight binplace, list the state.

        if (ThreadState->ChildState == STATE_LINKING) {
            ThreadState->ChildState = STATE_BINPLACE;
            ThreadState->ChildFlags = 0;
            ThreadState->FilterProc = MSToolFilter;
            return TRUE;
        } else {
            ThreadState->ChildState = STATE_BINPLACE;
            ThreadState->ChildFlags = 0;
            ThreadState->FilterProc = MSToolFilter;
            strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
        }
    }

    else
    if (TestPrefix( &p, "cmdcomp " ) ||
        TestPrefix( &p, "cmtempl " ) ||
        TestPrefix( &p, "maptweak ") ||
        TestPrefix( &p, "genord ") ||
        TestPrefix( &p, "makehm ")
        ) {
        if (*p == ':')
            return FALSE;       // This is a warning/error string
        while (*p == ' ') {
            p++;
        }

        ThreadState->ChildState = STATE_VCTOOL;
        ThreadState->ChildFlags = 0;
        ThreadState->FilterProc = MSToolFilter;
        strcpy( ThreadState->ChildCurrentFile, IsolateLastToken( p, ' ' ) );
    }

    else
    if ((TestPrefix( &p, "packthem " )) || (TestPrefix( &p, "..\\packthem " )))
    {
        if (*p == ':')
            return FALSE;       // This is a warning/error string

        while (*p == ' ')
            p++;

        ThreadState->ChildTarget = i386TargetMachine.Description;

        ThreadState->FilterProc = CoffFilter;
        ThreadState->ChildFlags = 0;
        ThreadState->ChildState = STATE_PACKING;

        if (TestPrefix( &p, "-o" )) 
        {
            strcpy( ThreadState->ChildCurrentFile, IsolateFirstToken( &p, ' ' ));
        }
    }

    else {

        return FALSE;
        }

    //
    // ***************** Set the Thread State according to what we determined.
    //
    FileName = ThreadState->ChildCurrentFile;

    if (TestPrefix( &FileName, CurrentDirectory )) {
        if (*FileName == '\\') {
            FileName++;
            }

        if (TestPrefix( &FileName, ThreadState->ChildCurrentDirectory )) {
            if (*FileName == '\\') {
                FileName++;
                }
            }

        strcpy( ThreadState->ChildCurrentFile, FileName );
        }

    FileDB = NULL;

    if (ThreadState->ChildState == STATE_LIBING) {
        NumberLibraries++;
        }
    else
    if (ThreadState->ChildState == STATE_LINKING) {
        NumberLinks++;
        }
    else
    if ((ThreadState->ChildState == STATE_STATUS) ||
        // Don't need to do anything here - binplace count already handled above
        (ThreadState->ChildState == STATE_BINPLACE) ||
        (ThreadState->ChildState == STATE_UNKNOWN)) {
        ;  // Do nothing.
        }
    else {
        if (ThreadState->CompileDirDB) {
            NumberCompiles++;
            CopyString(                         // fixup path string
                ThreadState->ChildCurrentFile,
                ThreadState->ChildCurrentFile,
                TRUE);

            if (!fQuicky) {
                FileDB = FindSourceFileDB(
                            ThreadState->CompileDirDB,
                            ThreadState->ChildCurrentFile,
                            NULL);
            }
        }
    }

    if (strstr(ThreadState->ChildCurrentFile, ".cxx") ||
        strstr(ThreadState->ChildCurrentFile, ".cpp")) {
        ThreadState->ChildFlags |= FLAGS_CXX_FILE;
    }

    if (fPrintChildState)
        PrintChildState(ThreadState, p, FileDB);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrintChildState
//
//  Synopsis:
//
//  Arguments:  [ThreadState] -- Current thread state
//
//  Returns:    TRUE if we figured it out, FALSE if we didn't recognize
//              anything.
//
//----------------------------------------------------------------------------

void
PrintChildState(
    PTHREADSTATE ThreadState,
    LPSTR p,
    PFILEREC FileDB
    )
{
    USHORT SaveCol;
    USHORT SaveRow;
    USHORT SaveRowTop;
    BOOL fStatusOutput = FALSE;
    char buffer[ DB_MAX_PATH_LENGTH ];
    LONG FilesLeft;
    LONG LinesLeft;
    ULONG LinesPerSecond;
    ULONG SecondsLeft;
    ULONG PercentDone;

    //
    // *********************** Print the thread state to the screen
    //
    if (ThreadState->IsStdErrTty) {
        GetScreenSize(ThreadState);
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        if (fStatus) {
            GetCursorPosition(&SaveRow, &SaveCol, &SaveRowTop);

            //  Clear row for process message
            ClearRows (ThreadState,
                       (USHORT) (SaveRowTop + ThreadState->ThreadIndex - 1),
                       1,
                       StatusCell);

            //  Clear row for status message
            ClearRows (ThreadState,
                       (USHORT) (SaveRowTop + NumberProcesses),
                       1,
                       StatusCell);

            //  Make sure there's still some room at the bottom
            if (SaveRow == LastRow(ThreadState)) {
                USHORT RowTop = 1 + SaveRowTop + (USHORT) NumberProcesses + 1;

                MoveRectangleUp (
                    RowTop,                     // Top
                    0,                          // Left
                    LastRow(ThreadState),       // Bottom
                    LastCol(ThreadState),       // Right
                    1,                          // NumRow
                    ScreenCell);                // FillCell

                SaveRow--;
            }

            SetCursorPosition(
                (USHORT) (SaveRowTop + ThreadState->ThreadIndex - 1),
                0);
            fStatusOutput = TRUE;
        }
    }

    if (szBuildTag) {
        sprintf(buffer, "%s: ", szBuildTag);
        WriteTTY(ThreadState, buffer, fStatusOutput);
    }

    if (fParallel && !fNoThreadIndex) {
        sprintf(buffer, "%d>", ThreadState->ThreadIndex);
        WriteTTY(ThreadState, buffer, fStatusOutput);
    }

    if (ThreadState->ChildState == STATE_UNKNOWN) {
        if (!fAlreadyUnknown) {
            WriteTTY(
                ThreadState,
                "Processing Unknown item(s)...\r\n",
                fStatusOutput);
            fAlreadyUnknown = TRUE;
        }
    }
    else
    if (ThreadState->ChildState == STATE_STATUS) {
        WriteTTY(ThreadState, p, fStatusOutput);
        WriteTTY(ThreadState, "\r\n", fStatusOutput);
    }
    else {
        fAlreadyUnknown = FALSE;
        WriteTTY(ThreadState, States[ThreadState->ChildState], fStatusOutput);
        WriteTTY(ThreadState, " - ", fStatusOutput);
        WriteTTY(
            ThreadState,
            FormatPathName(ThreadState->ChildCurrentDirectory,
                           ThreadState->ChildCurrentFile),
            fStatusOutput);

        WriteTTY(ThreadState, " for ", fStatusOutput);
        WriteTTY(ThreadState, ThreadState->ChildTarget, fStatusOutput);
        WriteTTY(ThreadState, "\r\n", fStatusOutput);
    }

    if (StartCompileTime) {
        ElapsedCompileTime += (ULONG)(time(NULL) - StartCompileTime);
    }

    if (FileDB != NULL) {
        StartCompileTime = time(NULL);
    }
    else {
        StartCompileTime = 0L;
    }

    //
    // ****************** Update the status line
    //
    if (fStatus) {
        if (FileDB != NULL) {
            FilesLeft = TotalFilesToCompile - TotalFilesCompiled;
            if (FilesLeft < 0) {
                FilesLeft = 0;
            }
            LinesLeft = TotalLinesToCompile - TotalLinesCompiled;
            if (LinesLeft < 0) {
                LinesLeft = 0;
                PercentDone = 99;
            }
            else if (TotalLinesToCompile != 0) {
                if (TotalLinesCompiled > 20000000L) {
                    int TLC = TotalLinesCompiled / 100;
                    int TLTC = TotalLinesToCompile / 100;

                    PercentDone = (TLC * 100L)/TLTC;
                }
                else
                    PercentDone = (TotalLinesCompiled * 100L)/TotalLinesToCompile;
            }
            else {
                PercentDone = 0;
            }

            if (ElapsedCompileTime != 0) {
                LinesPerSecond = TotalLinesCompiled / ElapsedCompileTime;
            }
            else {
                LinesPerSecond = 0;
            }

            if (LinesPerSecond != 0) {
                SecondsLeft = LinesLeft / LinesPerSecond;
            }
            else {
                SecondsLeft = LinesLeft / DEFAULT_LPS;
            }

            sprintf(
                buffer,
                "%2d%% done. %4ld %sLPS  Time Left:%s  Files: %d  %sLines: %s\r\n",
                PercentDone,
                LinesPerSecond,
                fStatusTree? "T" : "",
                FormatTime(SecondsLeft),
                FilesLeft,
                fStatusTree? "Total " : "",
                FormatNumber(LinesLeft));

            SetCursorPosition((USHORT) (SaveRowTop + NumberProcesses), 0);

            WriteTTY(ThreadState, buffer, fStatusOutput);
        }

        if (ThreadState->IsStdErrTty) {
            assert(ThreadState->cColTotal != 0);
            assert(ThreadState->cRowTotal != 0);
            SetCursorPosition(SaveRow, SaveCol);
        }
    }

    //
    // ***************** Keep track of how many files have been compiled.
    //
    if (ThreadState->ChildState == STATE_COMPILING  ||
        ThreadState->ChildState == STATE_ASSEMBLING ||
        ThreadState->ChildState == STATE_MKTYPLIB   ||
        ThreadState->ChildState == STATE_MIDL       ||
        ThreadState->ChildState == STATE_ASN        ||
        (FileDB != NULL && ThreadState->ChildState == STATE_PRECOMP)) {
        TotalFilesCompiled++;
    }
    if (FileDB != NULL) {
        TotalLinesCompiled += FileDB->TotalSourceLines;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessLine
//
//  Synopsis:   Watch the lines coming from the thread for special strings.
//
//----------------------------------------------------------------------------

BOOL
ProcessLine(
    PTHREADSTATE ThreadState,
    LPSTR p
    )
{
    LPSTR p1;

    while (*p <= ' ') {
        if (!*p) {
            return( FALSE );
            }
        else {
            p++;
            }
        }

    p1 = p;
    while (*p1) {
        if (*p1 == '\r')
            break;
        else
            p1++;
        }
    *p1 = '\0';

    p1 = p;
    if (TestPrefix( &p1, "Stop." )) {
        return( TRUE );
        }

    //  Stop multithread access to shared:
    //      database
    //      window
    //      compilation stats

    EnterCriticalSection(&TTYCriticalSection);

    if (TestPrefix( &p1, "nmake :" )) {
        PassThrough( ThreadState, p, FALSE );
    } else
    if (TestPrefix( &p1, "BUILDMSG: " )) {
        if (TestPrefix(&p1, "Warning")) {
            PassThrough(ThreadState, p, TRUE);
        } else {
            WriteTTY(ThreadState, p, TRUE);
            WriteTTY(ThreadState, "\r\n", TRUE);
        }
    } else
    if (ThreadState->LinesToIgnore) {
        ThreadState->LinesToIgnore--;
    }
    else {
        if ( !DetermineChildState( ThreadState, p ) ) {
            if (ThreadState->FilterProc != NULL) {
                (*ThreadState->FilterProc)( ThreadState, p );
                }
            }
        }

    LeaveCriticalSection(&TTYCriticalSection);

    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   FilterThread
//
//  Synopsis:   Capture the output of the thread and process it.
//
//----------------------------------------------------------------------------

VOID
FilterThread(
    PTHREADSTATE ThreadState
    )
{
    UINT CountBytesRead;
    LPSTR StartPointer = NULL;
    LPSTR EndPointer;
    LPSTR NewPointer;
    ULONG BufSize = 512;

    AllocMem(BufSize, &StartPointer, MT_THREADFILTER);
    while (TRUE) {
        EndPointer = StartPointer;
        do {
            if (BufSize - (EndPointer-StartPointer) < 512) {
                AllocMem(BufSize*2, &NewPointer, MT_THREADFILTER);
                RtlCopyMemory(
                    NewPointer,
                    StartPointer,
                    EndPointer - StartPointer + 1);     // copy null byte, too
                EndPointer += NewPointer - StartPointer;
                FreeMem(&StartPointer, MT_THREADFILTER);
                StartPointer = NewPointer;
                BufSize *= 2;
            }
            if (!fgets(EndPointer, 512, ThreadState->ChildOutput)) {
                if (errno != 0)
                    BuildError("Pipe read failed - errno = %d\n", errno);
                FreeMem(&StartPointer, MT_THREADFILTER);
                return;
            }
            CountBytesRead = strlen(EndPointer);
            EndPointer = EndPointer + CountBytesRead;
        } while (CountBytesRead == 511 && EndPointer[-1] != '\n');

        CountBytesRead = (UINT)(EndPointer - StartPointer);
        if (LogFile != NULL && CountBytesRead) {
            if (fParallel && !fNoThreadIndex) {
                char buffer[50];
                sprintf(buffer, "%d>", ThreadState->ThreadIndex);
                fwrite(buffer, 1, strlen(buffer), LogFile);
            }
            fwrite(StartPointer, 1, CountBytesRead, LogFile);
        }

        if (ProcessLine(ThreadState, StartPointer)) {
            FreeMem(&StartPointer, MT_THREADFILTER);
            return;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ExecuteProgram
//
//  Synopsis:   Spawn a new thread to execute the given program and filter
//              its output.
//
//  Arguments:  [ProgramName]       --
//              [CommandLine]       --
//              [MoreCommandLine]   --
//              [MustBeSynchronous] -- For synchronous operation on a
//                                      multi-processor machine.
//
//  Returns:    ERROR_SUCCESS, ERROR_NOTENOUGHMEMORY, or return code from
//              PipeSpawnClose.
//
//  Notes:      On a multiprocessor machine, this will spawn a new thread
//              and then return, letting the thread run asynchronously.  Use
//              WaitForParallelThreads() to ensure all threads are finished.
//              By default, this routine will spawn as many threads as the
//              machine has processors.  This can be overridden with the -M
//              option.
//
//----------------------------------------------------------------------------

char ExecuteProgramCmdLine[ 1024 ];

UINT
ExecuteProgram(
    LPSTR ProgramName,
    LPSTR CommandLine,
    LPSTR MoreCommandLine,
    BOOL MustBeSynchronous)
{
    LPSTR p;
    UINT rc;
    THREADSTATE *ThreadState;
    UINT OldErrorMode;

    AllocMem(sizeof(THREADSTATE), &ThreadState, MT_THREADSTATE);

    memset(ThreadState, 0, sizeof(*ThreadState));
    ThreadState->ChildState = STATE_UNKNOWN;
    ThreadState->ChildTarget = "Unknown Target";
    ThreadState->IsStdErrTty = (BOOL) _isatty(_fileno(stderr));
    ThreadState->CompileDirDB = CurrentCompileDirDB;

    if (ThreadState->IsStdErrTty) {
        GetScreenSize(ThreadState);
        assert(ThreadState->cColTotal != 0);
        assert(ThreadState->cRowTotal != 0);

        // We're displaying to the screen, so initialize the console.

        if (!fConsoleInitialized) {
            StatusCell[1] =
                        BACKGROUND_RED |
                        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN |
                        FOREGROUND_INTENSITY;

            ReadConsoleCells(ScreenCell, sizeof(ScreenCell), 2, 0);

            // If we stumbled upon an old Status line in row 2 of the window,
            // try the current row to avoid using the Status line background
            // colors for fill when scrolling.

            if (ScreenCell[1] == StatusCell[1]) {
                USHORT Row, Col;

                GetCursorPosition(&Row, &Col, NULL);
                ReadConsoleCells(ScreenCell, sizeof(ScreenCell), Row, 0);
            }
            ScreenCell[0] = StatusCell[0] = ' ';

            GetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), &OldConsoleMode);
            NewConsoleMode = OldConsoleMode;
            fConsoleInitialized = TRUE;
        }
        if (fStatus)
        {
            NewConsoleMode = OldConsoleMode & ~(ENABLE_WRAP_AT_EOL_OUTPUT);
        } else
        {
            NewConsoleMode = OldConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT;
        }
        SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), NewConsoleMode);
    }
    else {
        ThreadState->cRowTotal = 0;
        ThreadState->cColTotal = 0;
    }

    p = ThreadState->ChildCurrentDirectory;
    GetCurrentDirectory(sizeof(ThreadState->ChildCurrentDirectory), p);

    if (TestPrefix(&p, CurrentDirectory)) {
        if (*p == '\\') {
            p++;
        }
        strcpy(ThreadState->ChildCurrentDirectory, p);
    }

    if (ThreadState->ChildCurrentDirectory[0]) {
        strcat(ThreadState->ChildCurrentDirectory, "\\");
    }

    sprintf(
        ExecuteProgramCmdLine,
        "%s %s%s",
        ProgramName,
        CommandLine,
        MoreCommandLine);
    LogMsg("'%s %s%s'\n", ProgramName, CommandLine, MoreCommandLine);

    if (fParallel && !MustBeSynchronous) {
        PPARALLEL_CHILD ChildData;
        DWORD i;
        DWORD ThreadId;

        AllocMem(sizeof(PARALLEL_CHILD), &ChildData, MT_CHILDDATA);
        strcpy(ChildData->ExecuteProgramCmdLine,ExecuteProgramCmdLine);
        ChildData->ThreadState = ThreadState;

        if (ThreadsStarted < NumberProcesses) {
            if (ThreadsStarted == 0) {
                AllocMem(
                    sizeof(HANDLE) * NumberProcesses,
                    (VOID **) &WorkerThreads,
                    MT_THREADHANDLES);
                AllocMem(
                    sizeof(HANDLE) * NumberProcesses,
                    (VOID **) &WorkerEvents,
                    MT_EVENTHANDLES);
            }
            WorkerEvents[ThreadsStarted] = CreateEvent(NULL,
                                                       FALSE,
                                                       FALSE,
                                                       NULL);
            ChildData->Event = WorkerEvents[ThreadsStarted];

            ThreadState->ThreadIndex = ThreadsStarted+1;
            WorkerThreads[ThreadsStarted] = CreateThread(NULL,
                                                         0,
                                                         (LPTHREAD_START_ROUTINE)ParallelChildStart,
                                                         ChildData,
                                                         0,
                                                         &ThreadId);
            if ((WorkerThreads[ThreadsStarted] == NULL) ||
                (WorkerEvents[ThreadsStarted] == NULL)) {
                FreeMem(&ChildData, MT_CHILDDATA);
                FreeMem(&ThreadState, MT_THREADSTATE);
                return(ERROR_NOT_ENOUGH_MEMORY);
            } else {
                WaitForSingleObject(WorkerEvents[ThreadsStarted],INFINITE);
                ++ThreadsStarted;
            }
        } else {
            //
            // Wait for a thread to complete before starting
            // the next one.
            //
            i = WaitForMultipleObjects(NumberProcesses,
                                       WorkerThreads,
                                       FALSE,
                                       INFINITE);
            CloseHandle(WorkerThreads[i]);
            ChildData->Event = WorkerEvents[i];
            ThreadState->ThreadIndex = i+1;
            WorkerThreads[i] = CreateThread(NULL,
                                            0,
                                            (LPTHREAD_START_ROUTINE)ParallelChildStart,
                                            ChildData,
                                            0,
                                            &ThreadId);
            if (WorkerThreads[i] == NULL) {
                FreeMem(&ChildData, MT_CHILDDATA);
                FreeMem(&ThreadState, MT_THREADSTATE);
                return(ERROR_NOT_ENOUGH_MEMORY);
            } else {
                WaitForSingleObject(WorkerEvents[i],INFINITE);
            }
        }

        return(ERROR_SUCCESS);

    } else {

        //
        // Synchronous operation
        //
        StartCompileTime = 0L;
        ThreadState->ThreadIndex = 1;

        //
        // Disable child error popups in child processes.
        //

        if (fClean) {
            OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );
            }

        ThreadState->ChildOutput = PipeSpawn( ExecuteProgramCmdLine );
        if (fClean) {
            SetErrorMode( OldErrorMode );
            }

        rc = ERROR_SUCCESS;

        if (ThreadState->ChildOutput == NULL) {
            BuildError(
                "Exec of '%s' failed - errno = %d\n",
                ExecuteProgramCmdLine,
                errno);
            }
        else {
            FilterThread( ThreadState );

            if (StartCompileTime) {
                ElapsedCompileTime += (ULONG)(time(NULL) - StartCompileTime);
                }

            rc = PipeSpawnClose( ThreadState->ChildOutput );
            if (rc == -1) {
                BuildError("Child Terminate failed - errno = %d\n", errno);
            }
            else
            if (rc) {
                BuildError("%s failed - rc = %d\n", ProgramName, rc);
                }
            }

        if (ThreadState->IsStdErrTty) {
            RestoreConsoleMode();
        }

        FreeMem(&ThreadState, MT_THREADSTATE);
        return( rc );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   WaitForParallelThreads
//
//  Synopsis:   Wait for all threads to finish before returning.
//
//----------------------------------------------------------------------------

VOID
WaitForParallelThreads(
    VOID
    )
{
    if (fParallel) {
        WaitForMultipleObjects(ThreadsStarted,
                               WorkerThreads,
                               TRUE,
                               INFINITE);
        while (ThreadsStarted) {
            CloseHandle(WorkerThreads[--ThreadsStarted]);
            CloseHandle(WorkerEvents[ThreadsStarted]);
        }
        if (WorkerThreads != NULL) {
            FreeMem((VOID **) &WorkerThreads, MT_THREADHANDLES);
            FreeMem((VOID **) &WorkerEvents, MT_EVENTHANDLES);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ParallelChildStart
//
//  Synopsis:   Function that is run once for each thread.
//
//  Arguments:  [Data] -- Data given to CreateThread.
//
//----------------------------------------------------------------------------

DWORD
ParallelChildStart(
    PPARALLEL_CHILD Data
    )
{
    UINT OldErrorMode;
    UINT rc;

    //
    // Disable child error popups
    //
    if (fClean) {
        OldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );
    }
    Data->ThreadState->ChildOutput = PipeSpawn(Data->ExecuteProgramCmdLine);

    if (fClean) {
        SetErrorMode(OldErrorMode);
    }

    //
    // Poke the event to indicate that the child process has
    // started and it is ok for the main thread to change
    // the current directory.
    //
    SetEvent(Data->Event);

    if (Data->ThreadState->ChildOutput==NULL) {
        BuildError(
            "Exec of '%s' failed - errno = %d\n",
            ExecuteProgramCmdLine,
            errno);
    } else {
        FilterThread(Data->ThreadState);
        rc = PipeSpawnClose(Data->ThreadState->ChildOutput);
        if (rc == -1) {
            BuildError("Child terminate failed - errno = %d\n", errno);
        } else {
            if (rc) {
                BuildError("%s failed - rc = %d\n", Data->ExecuteProgramCmdLine, rc);
            }
        }
    }

    if (Data->ThreadState->IsStdErrTty) {
        RestoreConsoleMode();
    }
    FreeMem(&Data->ThreadState, MT_THREADSTATE);
    FreeMem(&Data, MT_CHILDDATA);
    return(rc);

}


//+---------------------------------------------------------------------------
//
//  Function:   ClearRows
//
//----------------------------------------------------------------------------

VOID
ClearRows(
    THREADSTATE *ThreadState,
    USHORT Top,
    USHORT NumRows,
    BYTE *Cell)
{
    COORD Coord;
    DWORD NumWritten;

    Coord.X = 0;
    Coord.Y = Top;

    FillConsoleOutputCharacter(
        GetStdHandle(STD_ERROR_HANDLE),
        Cell[0],
        ThreadState->cColTotal * NumRows,
        Coord,
        &NumWritten);
    FillConsoleOutputAttribute(
        GetStdHandle(STD_ERROR_HANDLE),
        (WORD) Cell[1],
        ThreadState->cColTotal * NumRows,
        Coord,
        &NumWritten);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetScreenSize
//
//----------------------------------------------------------------------------

VOID
GetScreenSize(THREADSTATE *ThreadState)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi)) {
        ThreadState->cRowTotal = 25;
        ThreadState->cColTotal = 80;
    }
    else {
        ThreadState->cRowTotal = csbi.srWindow.Bottom + 1;
        ThreadState->cColTotal = csbi.dwSize.X;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCursorPosition
//
//----------------------------------------------------------------------------

VOID
GetCursorPosition(
    USHORT *pRow,
    USHORT *pCol,
    USHORT *pRowTop)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);
    *pRow = csbi.dwCursorPosition.Y;
    *pCol = csbi.dwCursorPosition.X;
    if (pRowTop != NULL) {
        *pRowTop = csbi.srWindow.Top;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetCursorPosition
//
//----------------------------------------------------------------------------

VOID
SetCursorPosition(USHORT Row, USHORT Col)
{
    COORD Coord;

    Coord.X = Col;
    Coord.Y = Row;
    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), Coord);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteConsoleCells
//
//----------------------------------------------------------------------------

VOID
WriteConsoleCells(
    LPSTR String,
    USHORT StringLength,
    USHORT Row,
    USHORT Col,
    BYTE *Attribute)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD NumWritten;
    WORD OldAttribute;
    COORD StartCoord;

    //
    // Get current default attribute and save it.
    //

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    OldAttribute = csbi.wAttributes;

    //
    // Set the default attribute to the passed parameter, along with
    // the cursor position.
    //

    if ((BYTE) OldAttribute != *Attribute) {
        SetConsoleTextAttribute(
            GetStdHandle(STD_ERROR_HANDLE),
            (WORD) *Attribute);
    }

    StartCoord.X = Col;
    StartCoord.Y = Row;
    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), StartCoord);

    //
    // Write the passed string at the current cursor position, using the
    // new default attribute.
    //

    WriteFile(
        GetStdHandle(STD_ERROR_HANDLE),
        String,
        StringLength,
        &NumWritten,
        NULL);

    //
    // Restore previous default attribute.
    //

    if ((BYTE) OldAttribute != *Attribute) {
        SetConsoleTextAttribute(GetStdHandle(STD_ERROR_HANDLE), OldAttribute);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   MoveRectangleUp
//
//----------------------------------------------------------------------------

VOID
MoveRectangleUp (
    USHORT Top,
    USHORT Left,
    USHORT Bottom,
    USHORT Right,
    USHORT NumRow,
    BYTE  *FillCell)
{
    SMALL_RECT ScrollRectangle;
    COORD DestinationOrigin;
    CHAR_INFO Fill;

    ScrollRectangle.Left = Left;
    ScrollRectangle.Top = Top;
    ScrollRectangle.Right = Right;
    ScrollRectangle.Bottom = Bottom;
    DestinationOrigin.X = Left;
    DestinationOrigin.Y = Top - NumRow;
    Fill.Char.AsciiChar = FillCell[0];
    Fill.Attributes = (WORD) FillCell[1];

    ScrollConsoleScreenBuffer(
        GetStdHandle(STD_ERROR_HANDLE),
        &ScrollRectangle,
        NULL,
        DestinationOrigin,
        &Fill);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadConsoleCells
//
//----------------------------------------------------------------------------

VOID
ReadConsoleCells(
    BYTE *ScreenCell,
    USHORT cb,
    USHORT Row,
    USHORT Column)
{
    COORD BufferSize, BufferCoord;
    SMALL_RECT ReadRegion;
    CHAR_INFO CharInfo[1], *p;
    USHORT CountCells;

    CountCells = cb >> 1;
    assert(CountCells * sizeof(CHAR_INFO) <= sizeof(CharInfo));
    ReadRegion.Top = Row;
    ReadRegion.Left = Column;
    ReadRegion.Bottom = Row;
    ReadRegion.Right = Column + CountCells - 1;
    BufferSize.X = 1;
    BufferSize.Y = CountCells;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    ReadConsoleOutput(
        GetStdHandle(STD_ERROR_HANDLE),
        CharInfo,
        BufferSize,
        BufferCoord,
        &ReadRegion);

    p = CharInfo;
    while (CountCells--) {
        *ScreenCell++ = p->Char.AsciiChar;
        *ScreenCell++ = (BYTE) p->Attributes;
        p++;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ClearLine
//
//----------------------------------------------------------------------------

VOID
ClearLine(VOID)
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD Coord;
    DWORD   NumWritten;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_ERROR_HANDLE), &csbi);

    Coord.Y = csbi.dwCursorPosition.Y;
    Coord.X = csbi.dwCursorPosition.X = 0;
    FillConsoleOutputCharacter(
            GetStdHandle(STD_ERROR_HANDLE),
            ' ',
            csbi.dwSize.X,
            csbi.dwCursorPosition,
            &NumWritten);

    SetConsoleCursorPosition(GetStdHandle(STD_ERROR_HANDLE), Coord);
    fLineCleared = TRUE;
}


// PipeSpawn variables.  We can get away with one copy per thread.

__declspec(thread) HANDLE ProcHandle;
__declspec(thread) FILE *pstream;

//+---------------------------------------------------------------------------
//
//  Function:   PipeSpawn (similar to _popen)
//
//----------------------------------------------------------------------------

FILE *
PipeSpawn (
    const CHAR *cmdstring
    )
{
    int PipeHandle[2];
    HANDLE WriteHandle, ErrorHandle;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Status;
    char CmdLine[1024];

    if (cmdstring == NULL)
        return (NULL);

    // Open the pipe where we'll collect the output.

    _pipe(PipeHandle, 1024, _O_BINARY|_O_NOINHERIT);

    DuplicateHandle(GetCurrentProcess(),
                    (HANDLE)_get_osfhandle((LONG)PipeHandle[1]),
                    GetCurrentProcess(),
                    &WriteHandle,
                    0L,
                    TRUE,
                    DUPLICATE_SAME_ACCESS);

    DuplicateHandle(GetCurrentProcess(),
                    (HANDLE)_get_osfhandle((LONG)PipeHandle[1]),
                    GetCurrentProcess(),
                    &ErrorHandle,
                    0L,
                    TRUE,
                    DUPLICATE_SAME_ACCESS);

    _close(PipeHandle[1]);

    pstream = _fdopen(PipeHandle[0], "rb" );
    if (!pstream) {
        CloseHandle(WriteHandle);
        CloseHandle(ErrorHandle);
        _close(PipeHandle[0]);
        return(NULL);
    }

    strcpy(CmdLine, cmdexe);
    strcat(CmdLine, " /c ");
    strcat(CmdLine, cmdstring);

    memset(&StartupInfo, 0, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    StartupInfo.hStdOutput = WriteHandle;
    StartupInfo.hStdError = ErrorHandle;
    StartupInfo.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    StartupInfo.dwFlags = STARTF_USESTDHANDLES;

    memset(&ProcessInformation, 0, sizeof(PROCESS_INFORMATION));

    // And start the process.

    Status = CreateProcess(cmdexe, CmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &StartupInfo, &ProcessInformation);

    CloseHandle(WriteHandle);
    CloseHandle(ErrorHandle);
    CloseHandle(ProcessInformation.hThread);

    if (!Status) {
        fclose(pstream);        // This will close the read handle
        pstream = NULL;
        ProcHandle = NULL;
    } else {
        ProcHandle = ProcessInformation.hProcess;
    }

    return(pstream);
}


//+---------------------------------------------------------------------------
//
//  Function:   PipeSpawnClose (similar to _pclose)
//
//----------------------------------------------------------------------------

DWORD
PipeSpawnClose (
    FILE *pstream
    )
{
    DWORD retval = 0;   /* return value (to caller) */

    if ( pstream == NULL) {
        return retval;
    }

    (void)fclose(pstream);

    if ( WaitForSingleObject(ProcHandle, (DWORD) -1L) == 0) {
        GetExitCodeProcess(ProcHandle, &retval);
    }
    CloseHandle(ProcHandle);

    return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildmak.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994.
//
//  File:       buildmak.c
//
//  Contents:   This is the Make module for the NT Build Tool (BUILD.EXE)
//
//              The Make module scans directories for file names and edits the
//              data base appropriately.
//
//  Functions:
//
//  History:    16-May-89     SteveWo      Created
//                  ... See SLM log
//              26-Jul-94     LyleC        Cleanup/Add Pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"


#define SCANFLAGS_CHICAGO       0x00000002
#define SCANFLAGS_OS2           0x00000004
#define SCANFLAGS_POSIX         0x00000008
#define SCANFLAGS_CRT           0x00000010

ULONG ScanFlagsLast;
ULONG ScanFlagsCurrent;

USHORT GlobalSequence;
USHORT LocalSequence;
ULONG idFileToCompile = 1;
BOOL fLineCleared = TRUE;

char szRecurse[] = " . . . . . . . . .";
char szAsterisks[] = " ********************";

char *pszSdkLibDest;
char *pszDdkLibDest;
char *pszIncOak;
char *pszIncDdk;
char *pszIncWdm;
char *pszIncSdk;
char *pszIncCrt;
char *pszIncMfc;
char *pszIncOs2;
char *pszIncPosix;
char *pszIncChicago;

char szCheckedAltDir[] = " CHECKED_ALT_DIR=1";


#ifndef ARRAY_SIZE
#define ARRAY_SIZE(array, type) (sizeof(array)/sizeof(type))
#endif

//
// The following definitions are for the ObjectDirFlag entry in the TARGETDATA
// struct.
//

//
// TD_OBJECTDIR   maps to ObjectDirectory[iObjectDir]\foobar.tar
// TD_PASS0HDRDIR maps to $(PASS0_HEADERDIR)\foobar.tar
// TD_PASS0DIR1   maps to $(PASS0_SOURCEDIR)\foobar.tar or $(PASS0_CLIENTDIR)\foobar.tar
// TD_PASS0DIR2   maps to $(MIDL_UUIDDIR)\foobar.tar or $(PASS0_SERVERDIR)\foobar.tar
//
// where .tar is the given target extension, ObjectDirectory[iObjectDir] is the
// appropriate object directory for that platform, and the macros are expanded
// to the values given in the sources file.
//
#define TD_OBJECTDIR           1
#define TD_PASS0HDRDIR         2
#define TD_PASS0DIR1           3
#define TD_PASS0DIR2           4
#define TD_MCSOURCEDIR         5

typedef struct _tagTARGETDATA
{
    UCHAR ObjectDirFlag;    // Indicates what object dir should be used.
    LPSTR pszTargetExt;     // Extension of target. (Including '.')
} TARGETDATA, *LPTARGETDATA;

typedef struct _tagOBJECTTARGETINFO
{
    LPSTR        pszSourceExt;  // Extension of source file (including '.').
    UCHAR        NumData;       // Number of entries in [Data].
    LPTARGETDATA Data;          // Pointer to array of TARGETDATAs.
} OBJECTTARGETINFO, *LPOBJECTTARGETINFO;

typedef struct _tagOBJECTTARGETARRAY
{
    int                cTargetInfo;
    OBJECTTARGETINFO **aTargetInfo;
} OBJECTTARGETARRAY;


//
// TARGETDATA information is used by both BuildCompileTarget() and
// WriteObjectsDefinition() via the GetTargetData() function.  Do not put
// extensions in this table whose TARGETDATA consists entirely of
// { TD_OBJECTDIR, ".obj" } because that is the default.  Instead you must
// modify the switch statement in WriteObjectsDefinition.
//
// The first target in each TARGETDATA array is considered the 'rule target'
// because that is the target for which the inference rule in makefile.def is
// written.  The 'rule target' will always be deleted in addition to the
// out-of-date target if *any* of the targets are out of date.
//


//
// The following data defines the *PASS0* mappings of source extensions
// to target files:
//
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_SOURCEDIR)\_p.c,
//                      $(MIDL_UUIDDIR)\_i.c
//              .asn -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_HEADERDIR)\.c
//              .mc  -> $(PASS0_HEADERDIR)\.h, $(PASS0_SOURCEDIR)\.rc
//              .odl -> obj\*\.tlb
//              .tdl -> obj\*\.tlb
//

//              .mc  -> $(PASS0_HEADERDIR)\.h, $(PASS0_HEADERDIR)\.rc
TARGETDATA MCData0[] = {
                        { TD_PASS0HDRDIR, ".h" },
                        { TD_MCSOURCEDIR, ".rc" }
                      };
OBJECTTARGETINFO MCInfo0 = { ".mc", ARRAY_SIZE(MCData0, TARGETDATA), MCData0 };

//              .asn  -> $(PASS0_HEADERDIR)\.h, $(PASS0_SOURCEDIR)\.c
TARGETDATA AsnData0[] = {
                        { TD_PASS0HDRDIR, ".h" },
                        { TD_PASS0DIR1, ".c" },
                      };
OBJECTTARGETINFO AsnInfo0 =
    { ".asn", ARRAY_SIZE(AsnData0, TARGETDATA), AsnData0 };


//         .odl/.tdl -> obj\*\.tlb
TARGETDATA TLBData0 = { TD_OBJECTDIR, ".tlb" };

OBJECTTARGETINFO TLBInfo0 =
    { ".tdl", ARRAY_SIZE(TLBData0, TARGETDATA), &TLBData0 };

OBJECTTARGETINFO TLB2Info0 =
    { ".odl", ARRAY_SIZE(TLBData0, TARGETDATA), &TLBData0 };

//         .thk -> obj\*\.asm
TARGETDATA THKData0 = { TD_OBJECTDIR, ".asm" };

OBJECTTARGETINFO THKInfo0 =
    { ".thk", ARRAY_SIZE(THKData0, TARGETDATA), &THKData0 };


//              .mof -> obj\*\.mof, obj\*\.bmf
TARGETDATA MOFData0[] = {
	                     {TD_OBJECTDIR, ".mof" },
	                     {TD_OBJECTDIR, ".bmf" }
                      };
OBJECTTARGETINFO MOFInfo0 = { ".mof", ARRAY_SIZE(MOFData0, TARGETDATA),
   MOFData0 };

//          ------
LPOBJECTTARGETINFO aTargetInfo0[] = {
                                   &MCInfo0,
                                   &AsnInfo0,
                                   &TLBInfo0,
                                   &TLB2Info0,
                                   &THKInfo0,
                                   &MOFInfo0,
                                   };
#define CTARGETINFO0    ARRAY_SIZE(aTargetInfo0, LPOBJECTTARGETINFO)


//
// The following data defines the *PASS1* mappings of source extensions
// to target files:
//
//              .rc  -> obj\*\.res
//              .asn -> obj\*\.obj
//              .thk -> obj\*\.asm,
//              .java -> obj\*\.class,
//                      obj\*\.obj,
//

//              .rc  -> obj\*\.res
TARGETDATA RCData1 = { TD_OBJECTDIR, ".res" };
OBJECTTARGETINFO RCInfo1 = { ".rc", ARRAY_SIZE(RCData1, TARGETDATA), &RCData1 };

//              .thk -> .asm -> .obj
TARGETDATA THKData1[] = {
                        {TD_OBJECTDIR, ".obj" }
                       };
OBJECTTARGETINFO THKInfo1 =
    { ".thk", ARRAY_SIZE(THKData1, TARGETDATA), THKData1 };

//              .java -> .class
TARGETDATA JAVAData1[] = {
                        {TD_OBJECTDIR, ".class" }
                       };
OBJECTTARGETINFO JAVAInfo1 =
    { ".java", ARRAY_SIZE(JAVAData1, TARGETDATA), JAVAData1 };




//          ------
LPOBJECTTARGETINFO aTargetInfo1[] = {
                                   &RCInfo1,
                                   &THKInfo1,
                                   &JAVAInfo1,
                                   };
#define CTARGETINFO1    ARRAY_SIZE(aTargetInfo1, LPOBJECTTARGETINFO)


OBJECTTARGETARRAY aTargetArray[] = {
    { CTARGETINFO0, aTargetInfo0 },
    { CTARGETINFO1, aTargetInfo1 },
};


//          ------
//   MIDL stuff -- IDL files have two potential sets of targets, depending
//   on if the IDL_TYPE flag was set to 'ole' in the sources file or not.
//
//         IDL_TYPE = ole
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_SOURCEDIR)\_p.c,
//                      $(MIDL_UUIDDIR)\_i.c
TARGETDATA IDLDataOle0[] = {
                         { TD_PASS0HDRDIR, ".h" },   // Header File
//                         { TD_PASS0DIR1,   "_p.c" }, // Proxy Stub File
//                         { TD_PASS0DIR2,   "_i.c" }, // UUID file
                       };
OBJECTTARGETINFO IDLInfoOle0 =
    { ".idl", ARRAY_SIZE(IDLDataOle0, TARGETDATA), IDLDataOle0 };

//         IDL_TYPE = rpc
//              .idl -> $(PASS0_HEADERDIR)\.h,
//                      $(PASS0_CLIENTDIR)\_c.c,
//                      $(PASS0_SERVERDIR)\_s.c,
TARGETDATA IDLDataRpc0[] = {
                         { TD_PASS0HDRDIR, ".h" },   // Header File
//                         { TD_PASS0DIR1,   "_c.c" }, // Client Stub File
//                         { TD_PASS0DIR2,   "_s.c" }, // Server Stub File
                       };
OBJECTTARGETINFO IDLInfoRpc0 =
    { ".idl", ARRAY_SIZE(IDLDataRpc0, TARGETDATA), IDLDataRpc0 };

//          ------
LPOBJECTTARGETINFO aMidlTargetInfo0[] = {
                                        &IDLInfoOle0,
                                        &IDLInfoRpc0,
                                       };
UCHAR cMidlTargetInfo0 = ARRAY_SIZE(aMidlTargetInfo0, LPOBJECTTARGETINFO);

//          ------
//
// Any extension not given in the above table is assumed to have a target in
// the ObjectDirectory[iObjectDir] (obj\*) & have a target extension of .obj.
//

TARGETDATA DefaultData = { TD_OBJECTDIR, ".obj" };


//*******

TARGET *
BuildCompileTarget(
    FILEREC *pfr,
    LPSTR    pszfile,
    USHORT   TargetIndex,
    LPSTR    pszConditionalIncludes,
    DIRREC  *pdrBuild,
    DIRSUP  *pdsBuild,
    LONG     iPass,
    LPSTR    *ppszObjectDir,
    LPSTR    pszSourceDir);


//+---------------------------------------------------------------------------
//
//  Function:   ExpandObjAsterisk
//
//  Synopsis:   Expand an asterisk in a filename to a platform name
//
//  Arguments:  [pbuf]               -- Output buffer for new filename
//              [pszpath]            -- Input filename w/ asterisk
//              [ppszObjectDirectory] -- String[2] to replace asterisk with
//
//----------------------------------------------------------------------------

VOID
ExpandObjAsterisk(
    LPSTR pbuf,
    LPSTR pszpath,
    LPSTR *ppszObjectDirectory)
{
    SplitToken(pbuf, '*', &pszpath);
    if (*pszpath == '*') {
        assert(strncmp(
                    pszObjDirSlash,
                    ppszObjectDirectory[iObjectDir],
                    strlen(pszObjDirSlash)) == 0);
        strcat(pbuf, ppszObjectDirectory[iObjectDir] + strlen(pszObjDirSlash));
        strcat(pbuf, pszpath + 1);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CountSourceLines
//
//  Synopsis:   Counts the source lines in a given file, including headers if
//              the '-S' option was given.
//
//  Arguments:  [idScan] -- Used to catch multiple inclusions
//              [pfr]    -- File to scan
//
//  Returns:    Number of lines
//
//----------------------------------------------------------------------------

LONG
CountSourceLines(USHORT idScan, FILEREC *pfr)
{
    INCLUDEREC *pir;

    AssertFile(pfr);

    // if we have already seen this file before, then assume
    // that #if guards prevent it's inclusion

    if (pfr->idScan == idScan) {
        return(0L);
    }

    pfr->idScan = idScan;

    //  Start off with the file itself
    pfr->TotalSourceLines = pfr->SourceLines;

    if (fStatusTree) {

        //
        // If the user asked for include file line counts, then walk include
        // tree, accruing nested include file line counts .
        //

        for (pir = pfr->IncludeFilesTree; pir != NULL; pir = pir->NextTree) {
            AssertInclude(pir);
            if (pir->pfrInclude != NULL) {
                AssertFile(pir->pfrInclude);
                pfr->TotalSourceLines +=
                        CountSourceLines(idScan, pir->pfrInclude);
            }
        }
    }
    return(pfr->TotalSourceLines);
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanNTTargetFile0
//
//  Synopsis:   Parses pzFiles and deletes all files listed.
//               pzFile must have been allocated by MakeMacroString.
//               No asterisk expansion performed.
//
//              This is used when fClean is TRUE and SOURCES_OPTIONS
//               includes -c0. See ReadSourcesFile. Note that
//               SOURCES_OPTIONS must be defined before NTTARGETFILE0.
//              This is a mechanism to delete target files not
//               included in _objects.mac.
//
//  Arguments:  [pzFiles] -- List of files
//
//----------------------------------------------------------------------------
VOID
CleanNTTargetFile0 (char * pzFiles)
{
    BOOL fRestoreSep;
    char * pzDelete;

    while (*pzFiles != '\0') {
        pzDelete = pzFiles;

        // Find end of the next file name and NULL terminate it (if needed)
        fRestoreSep = FALSE;
        while (*pzFiles != '\0') {
            if (*pzFiles == ' ') {
                fRestoreSep = TRUE;
                *pzFiles = '\0';
                break;
            } else {
                pzFiles++;
            }
        }

        DeleteSingleFile (NULL, pzDelete, FALSE);

        if (fRestoreSep) {
            *pzFiles++ = ' ';
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessSourceDependencies
//
//  Synopsis:   Scan all source files in a given directory tree to determine
//              which files are out of date and need to be compiled and/or
//              linked.
//
//  Arguments:  [DirDB]           -- Directory to process
//              [pds]             -- Supplementary directory information
//              [DateTimeSources] -- Timestamp of 'sources' file
//
//----------------------------------------------------------------------------

VOID
ProcessSourceDependencies(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources)
{
    TARGET *Target;
    ULONG DateTimePch = 0;    // Actual timestamp of pch preserved here.
    UINT i;
    SOURCEREC *apsr[3];
    SOURCEREC **ppsr;
    char path[DB_MAX_PATH_LENGTH];
    static USHORT idScan = 0;

    AssertDir(DirDB);

    apsr[0] = pds->psrSourcesList[0];
    apsr[2] = NULL;

    //
    // For a clean build, just delete all targets
    //
    if (fFirstScan && fClean && !fKeep) {
        DeleteMultipleFiles("obj", "*.*");    // _objects.mac
        for (i = 0; i < CountTargetMachines; i++) {
            assert(strncmp(
                        pszObjDirSlash,
                        TargetMachines[i]->ObjectDirectory[iObjectDir],
                        strlen(pszObjDirSlash)) == 0);
            DeleteMultipleFiles(TargetMachines[i]->ObjectDirectory[iObjectDir], "*.*");

            apsr[1] = pds->psrSourcesList[TargetToPossibleTarget[i] + 1];

            //
            // Delete the pch file if we have one.
            //
            if (pds->PchTarget != NULL)
            {
                char TargetDir[DB_MAX_PATH_LENGTH];
                ExpandObjAsterisk(TargetDir,
                                  pds->PchTargetDir,
                                  TargetMachines[i]->ObjectDirectory);

                //
                // Kind of a cludgy way to do this, but we must ensure that
                // we don't delete a pch file that was built earlier on during
                // this same build.  We do this by comparing the timestamp of
                // the pch file against the time we started the build.
                //
                if ((*pDateTimeFile)(TargetDir, pds->PchTarget) <= BuildStartTime)
                {
                    DeleteSingleFile(TargetDir, pds->PchTarget, FALSE);
                    if (DirDB->PchObj != NULL) {
                        ExpandObjAsterisk(path,
                                          DirDB->PchObj,
                                          TargetMachines[i]->ObjectDirectory);
                        DeleteSingleFile(NULL, path, FALSE);
                    } else {
                        char *p;
                        strcpy(path, pds->PchTarget);
                        p = strrchr(path, '.');
                        if (p != NULL && strcmp(p, ".pch") == 0) {
                            strcpy(p, ".obj");
                            DeleteSingleFile(TargetDir, path, FALSE);
                        }
                    }
                }
            }

            if (DirDB->DirFlags & DIRDB_PASS0) {
                for (ppsr = apsr; *ppsr != NULL; ppsr++) {
                    SOURCEREC *psr;

                    for (psr = *ppsr; psr != NULL; psr = psr->psrNext) {
                        FILEREC *pfr;

                        AssertSource(psr);

                        pfr = psr->pfrSource;

                        //
                        // Pass Zero files have different target directories.
                        //
                        if (pfr->FileFlags & FILEDB_PASS0)
                        {
                            USHORT j;
                            //
                            // If the file has multiple targets, (e.g. .mc,
                            // .idl or .asn), then loop through all targets.
                            //
                            j = 0;
                            while (Target = BuildCompileTarget(
                                                pfr,
                                                pfr->Name,
                                                j,
                                                pds->ConditionalIncludes,
                                                DirDB,
                                                pds,
                                                0,        // pass 0
                                                TargetMachines[i]->ObjectDirectory,
                                                TargetMachines[i]->SourceDirectory)) {

                                DeleteSingleFile(NULL, Target->Name, FALSE);

                                FreeMem(&Target, MT_TARGET);

                                j++;
                            }
                        }
                    }
                }
            }

            if ((DirDB->DirFlags & DIRDB_TARGETFILE0) && (DirDB->NTTargetFile0 != NULL)) {
                CleanNTTargetFile0 (DirDB->NTTargetFile0);
            }
        }
    }

    if (fFirstScan && (DirDB->DirFlags & DIRDB_TARGETFILE0)) {
        DirDB->DirFlags |= DIRDB_PASS0NEEDED;
    }

    if (!fQuickZero || !fFirstScan || !RecurseLevel)
    {
        GenerateObjectsDotMac(DirDB, pds, DateTimeSources);
    }
    else if (fFirstScan)
    {
        SOURCEREC *psr;
        USHORT i;
        USHORT j;
        BOOL fNeedCompile = FALSE;

        if ( !(DirDB->DirFlags & DIRDB_PASS0NEEDED)) {

            for (i = 0; i < CountTargetMachines; i++) {

                for (psr = pds->psrSourcesList[0]; psr != NULL; psr = psr->psrNext) {
                    FILEREC *pfr;

                    AssertSource(psr);

                    pfr = psr->pfrSource;

                    AssertFile(pfr);

                    if (pfr->FileFlags & FILEDB_PASS0)
                    {

                        for (j = 0;
                            Target = BuildCompileTarget(
                                            pfr,
                                            pfr->Name,
                                            j,
                                            pds->ConditionalIncludes,
                                            DirDB,
                                            pds,
                                            0,
                                            TargetMachines[i]->ObjectDirectory,
                                            TargetMachines[i]->SourceDirectory);
                            j++) {

                            if ((psr->SrcFlags & SOURCEDB_FILE_MISSING) ||
                                (Target->DateTime == 0) ||
                                ((pfr->FileFlags & FILEDB_C) && Target->DateTime < DateTimePch))
                            {
                                fNeedCompile = TRUE;
                            }

                            FreeMem(&Target, MT_TARGET);
                        }

                        if (fNeedCompile)
                        {
                            DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                        }
                    }
                }
            }
        }

        if (DirDB->DirFlags & DIRDB_PASS0NEEDED)
        {
            GenerateObjectsDotMac(DirDB, pds, DateTimeSources);
        }
    }

    if ((DirDB->TargetExt != NULL) &&
        (DirDB->TargetName != NULL) &&
        (DirDB->TargetPath != NULL) &&
        (fClean && !fKeep))
    {
        // If we haven't already deleted the final target, do so now.
        if (_memicmp(DirDB->TargetPath, pszObjDirSlash, strlen(pszObjDirSlash) -1)) {
            for (i = 0; i < CountTargetMachines; i++) {
                FormatLinkTarget(
                    path,
                    TargetMachines[i]->ObjectDirectory,
                    DirDB->TargetPath,
                    DirDB->TargetName,
                    DirDB->TargetExt);
                DeleteSingleFile(NULL, path, FALSE);
                FormatLinkTarget(
                    path,
                    TargetMachines[i]->ObjectDirectory,
                    DirDB->TargetPath,
                    DirDB->TargetName,
                    ".pdb");
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
    }

    if (pds->fNoTarget) {
        if (apsr[0] || !(DirDB->DirFlags & DIRDB_PASS0NEEDED) || fSemiQuicky) {
            // If there's sources to compile, mark as such then get out.
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        }
        return;
    }

    if (fQuicky) {
        if (fSemiQuicky)
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        else
            DirDB->DirFlags |= DIRDB_PASS0NEEDED;
        return;
    }

    //
    // For a DLL or LIB target, ensure that it will be rebuilt
    //
    if (DirDB->TargetPath != NULL &&
        DirDB->TargetName != NULL &&
        ((DirDB->DirFlags & DIRDB_DLLTARGET) ||
         (DirDB->TargetExt != NULL && strcmp(DirDB->TargetExt, ".lib") == 0))) {

        for (i = 0; i < CountTargetMachines; i++) {
            FormatLinkTarget(
                path,
                TargetMachines[i]->ObjectDirectory,
                DirDB->TargetPath,
                DirDB->TargetName,
                ".lib");

            if (ProbeFile(NULL, path) == -1) {
                DirDB->DirFlags |= DIRDB_COMPILENEEDED;
            }
            else
            if (fFirstScan && (fCleanLibs || (fClean && !fKeep))) {
                DeleteSingleFile(NULL, path, FALSE);
                DirDB->DirFlags |= DIRDB_COMPILENEEDED;
            }
        }
    }

    //
    // If the scan flags have changed (or haven't been set), then indicate
    // that we should look for the actual location of global included files
    // instead of assuming it's in the same location as we last knew.  This is
    // because different directories my include the same file from different
    // places.
    //
    if (GlobalSequence == 0 ||
        ScanFlagsLast == 0 ||
        ScanFlagsLast != ScanFlagsCurrent) {

        GlobalSequence++;               // don't reuse snapped global includes
        if (GlobalSequence == 0) {
            GlobalSequence++;
        }
        ScanFlagsLast = ScanFlagsCurrent;
    }

    //
    // Do the same as above for locally included files.
    //
    LocalSequence++;                    // don't reuse snapped local includes
    if (LocalSequence == 0) {
        LocalSequence++;
    }

    for (i = 0; i < CountTargetMachines; i++) {

        //
        // Ensure that precompiled headers are rebuilt as necessary.
        //

        if (!fPassZero && (pds->PchInclude != NULL || pds->PchTarget != NULL)) {
            LPSTR p;

            ExpandObjAsterisk(
                        path,
                        pds->PchTargetDir != NULL?
                            pds->PchTargetDir : pszObjDirSlashStar,
                        TargetMachines[i]->ObjectDirectory);

            if (!CanonicalizePathName(path, CANONICALIZE_DIR, path)) {
                DateTimePch = ULONG_MAX;        // always out of date
                goto ProcessSourceList;
            }
            strcat(path, "\\");

            //
            // If they gave a target directory for the pch file, then use it,
            // otherwise assume it's in the same directory as the .h file.
            //
            if (pds->PchTarget != NULL) {
                strcat(path, pds->PchTarget);
            }
            else {
                assert(pds->PchInclude != NULL);
                p = path + strlen(path);
                if ( DirDB->Pch ) {
                    strcpy(p, DirDB->Pch);
                } else {
                    strcpy(p, pds->PchInclude);
                    if ((p = strrchr(p, '.')) != NULL) {
                        *p = '\0';
                    }
                    strcat(path, ".pch");
                }
            }

            //
            // 'path' now contains the (possibly relative) path name of
            // the PCH target: "..\path\foobar.pch"
            //
            Target = BuildCompileTarget(
                        NULL,
                        path,
                        0,
                        pds->ConditionalIncludes,
                        DirDB,
                        NULL,
                        1,        // pass 1
                        TargetMachines[i]->ObjectDirectory,
                        TargetMachines[i]->SourceDirectory);

            DateTimePch = Target->DateTime;

            if (DateTimePch == 0) {             // Target doesn't exist
                DateTimePch = ULONG_MAX;        // Always out of date
            }

            if (fClean && !fKeep && fFirstScan) {
                // Target will be deleted later if it exists.
            }
            else if (pds->PchInclude == NULL) {

                //
                // The SOURCES file didn't indicate where the source file
                // for the .pch is, so assume the .pch binary is up to date
                // with respect to the source includes and with respect to
                // the pch source file itself.
                //
                // char szFullPath[DB_MAX_PATH_LENGTH];

                // CanonicalizePathName(DirDB->Name, CANONICALIZE_DIR, szFullPath);

                //BuildMsg("SOURCES file in %s gives PRECOMPILED_TARGET but not "
                //         "PRECOMPILED_INCLUDE.\n", szFullPath);
                Target->DateTime = 0;           // Don't delete pch target
            }
            else {
                FILEREC *pfrPch = NULL;

                path[0] = '\0';

                if (pds->PchIncludeDir != NULL) {
                    strcpy(path, pds->PchIncludeDir);
                    strcat(path, "\\");
                }
                strcat(path, pds->PchInclude);

                if ((pds->PchIncludeDir != NULL) &&
                    (IsFullPath(pds->PchIncludeDir))) {
                    DIRREC *DirDBPch;

                    DirDBPch = FindSourceDirDB(pds->PchIncludeDir,
                                               pds->PchInclude, TRUE);

                    if (DirDBPch) {
                        pfrPch = FindSourceFileDB(DirDBPch,
                                                  pds->PchInclude,
                                                  NULL);
                    }
                }
                else {
                    pfrPch = FindSourceFileDB(DirDB, path, NULL);
                }


                if (pfrPch != NULL) {
                    FILEREC *pfrRoot;
                    SOURCEREC *psr = NULL;

                    BOOL fCase1;
                    BOOL fCase2;
                    BOOL fCase3;
                    BOOL fNeedCompile;
                    BOOL fCheckDepends;

                    // Remote directory PCH files can't be found here

                    if (pfrPch->Dir == DirDB) {
                        psr = FindSourceDB(pds->psrSourcesList[0], pfrPch);
                        assert(psr != NULL);
                        psr->SrcFlags |= SOURCEDB_PCH;
                    }

                    Target->pfrCompiland = pfrPch;
                    assert((pfrRoot = NULL) == NULL);   // assign NULL

                    fNeedCompile = FALSE;
                    fCheckDepends = FALSE;

                    switch(0) {
                      default:
                        fCase1 = (fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfrPch, TRUE, &pfrRoot));
                        if ( fCase1 ) {
                            fNeedCompile = TRUE;
                            break;
                        }
                        fCase2 = (Target->DateTime == 0);
                        if ( fCase2 ) {
                            fNeedCompile = TRUE;
                            break;
                        }
                        fCase3 = (!fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfrPch, TRUE, &pfrRoot));
                        if ( fCase3 ) {
                            fNeedCompile = TRUE;
                            break;
                        }
                        break;
                    }

                    if (( fCheckIncludePaths ) && ( ! fCheckDepends )) {
                        CheckDependencies(Target, pfrPch, TRUE, &pfrRoot);
                    }

                    if (fNeedCompile) {

                        if (psr != NULL) {
                            if (fWhyBuild) {
                                BuildMsgRaw("\n");
                                if (fCase1) {
                                    BuildMsgRaw("Compiling %s because (Case 1) *1\n", psr->pfrSource->Name);
                                } else
                                if (fCase2) {
                                    BuildMsgRaw("Compiling %s because Target date == 0 (Target->Compiland=%s) *1\n", psr->pfrSource->Name, Target->pfrCompiland->Name);
                                } else
                                if (fCase3) {
                                    BuildMsgRaw("Compiling %s because (Case 3) *1\n", psr->pfrSource->Name);
                                }
                            }

                            psr->SrcFlags |= SOURCEDB_COMPILE_NEEDED;
                        } else {
                            if (fWhyBuild) {
                                BuildMsgRaw("\n");
                                BuildMsgRaw("Compiling %s because Target date == 0 (Target->Compiland=%s) *1\n", Target->Name, Target->pfrCompiland->Name);
                            }
                        }

                        pfrPch->Dir->DirFlags |= DIRDB_COMPILENEEDED;
                        DateTimePch = ULONG_MAX; // always out of date
                        if (fKeep) {
                            Target->DateTime = 0;  // don't delete pch target
                        }
                    }
                    else {      // else it exists and is up to date...
                        Target->DateTime = 0;   // don't delete pch target
                    }

                    // No cycle possible at the root of the tree.
                    assert(pfrRoot == NULL);
                }
                else if (DEBUG_1) {
                    BuildError("Cannot locate precompiled header file: %s.\n",
                                path);
                }
            }

            //
            // Target->DateTime will be zero if the file is up to date (or we
            // don't want to delete it).  If Target->DateTime is non-zero,
            // delete the .pch and corresponding .obj file so they will be
            // rebuilt.
            //
            if (Target->DateTime != 0) {
                DeleteSingleFile(NULL, Target->Name, FALSE);
                if (DirDB->PchObj != NULL) {
                    ExpandObjAsterisk(
                                path,
                                DirDB->PchObj,
                                TargetMachines[i]->ObjectDirectory);
                    DeleteSingleFile(NULL, path, FALSE);
                } else {
                    p = strrchr(Target->Name, '.');
                    if (p != NULL && strcmp(p, ".pch") == 0) {
                        strcpy(p, ".obj");
                        DeleteSingleFile(NULL, Target->Name, FALSE);
                    }
                }
            }
            FreeMem(&Target, MT_TARGET);
        }

        //
        // Check to see which files given in the SOURCES macro need to be
        // rebuilt, and delete their targets (.obj) if they're out of date.
        //

ProcessSourceList:

        apsr[1] = pds->psrSourcesList[TargetToPossibleTarget[i] + 1];

        for (ppsr = apsr; ppsr < apsr + (sizeof(apsr)/sizeof(*apsr)); ppsr++) {
            SOURCEREC *psr;

            if (*ppsr == NULL) {
                continue;
            }


            for (psr = *ppsr; psr != NULL; psr = psr->psrNext) {
                FILEREC *pfr, *pfrRoot;

                AssertSource(psr);

                pfr = psr->pfrSource;

                AssertFile(pfr);

                if ((psr->SrcFlags & SOURCEDB_PCH) == 0) {

                    USHORT j;
                    LONG iPass, iPassEnd;

                    iPass = 1;
                    iPassEnd = 0;

                    if (pfr->FileFlags & FILEDB_PASS0)
                        iPass = 0;

                    if ((pfr->FileFlags & FILEDB_MULTIPLEPASS) ||
                        !(pfr->FileFlags & FILEDB_PASS0))
                        iPassEnd = 1;

                    assert(iPass <= iPassEnd);

                    //
                    // If we're doing a pass zero scan and the file is
                    // not a pass zero file, then continue because we
                    // don't care about it right now.
                    //
                    if (fFirstScan && fPassZero && iPass == 1) {
                        continue;
                    }

                    //
                    // Don't check dependencies of pass zero files on the
                    // second scan, because they're all supposed to be built
                    // by now.
                    //
                    if (!fFirstScan && iPassEnd == 0) {
                        continue;
                    }

                    //
                    // If the file was created during pass zero, then make sure
                    // we don't think it's still missing.
                    //
                    if (!fFirstScan &&
                        (psr->SrcFlags & SOURCEDB_FILE_MISSING) &&
                        !(pfr->FileFlags & FILEDB_FILE_MISSING))
                    {
                        psr->SrcFlags &= ~SOURCEDB_FILE_MISSING;
                    }

                    // If the file is a multiple pass file (e.g. .asn), loop
                    // through both passes.

                    for ( ; iPass <= iPassEnd; iPass++) {

                        //
                        // If the file has multiple targets (e.g. .mc, .idl or
                        // .asn), then loop through all the targets.
                        //
                        for (j = 0;
                            Target = BuildCompileTarget(
                                            pfr,
                                            pfr->Name,
                                            j,
                                            pds->ConditionalIncludes,
                                            DirDB,
                                            pds,
                                            iPass,
                                            TargetMachines[i]->ObjectDirectory,
                                            TargetMachines[i]->SourceDirectory);
                            j++)
                        {

                            BOOL fCase1;
                            BOOL fCase2;
                            BOOL fCase3;
                            BOOL fCase4;
                            BOOL fCase5;
                            BOOL fNeedCompile;
                            BOOL fCheckDepends;

                            if (DEBUG_4) {
                                BuildMsgRaw(szNewLine);
                            }
                            assert((pfrRoot = NULL) == NULL);   // assign NULL

                            //  Decide whether the target needs to be compiled.
                            //  Forcibly examine dependencies to get line count.

                            fNeedCompile = FALSE;
                            fCheckDepends = FALSE;

                            switch(0) {
                              default:
                                fCase1 = (psr->SrcFlags & SOURCEDB_FILE_MISSING);
                                if ( fCase1 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase2 = (fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfr, TRUE, &pfrRoot));
                                if ( fCase2 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase3 = (Target->DateTime == 0);
                                if ( fCase3 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase4 = ((pfr->FileFlags & FILEDB_C) && Target->DateTime < DateTimePch);
                                if ( fCase4 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                fCase5 = (!fStatusTree && (fCheckDepends=TRUE) && CheckDependencies(Target, pfr, TRUE, &pfrRoot));
                                if ( fCase5 ) {
                                    fNeedCompile = TRUE;
                                    break;
                                }
                                break;
                            }

                            if (( fCheckIncludePaths ) && ( ! fCheckDepends )) {
                                CheckDependencies(Target, pfr, TRUE, &pfrRoot);
                            }

                            if ( fNeedCompile )
                            {
                                if (fWhyBuild) {
                                    BuildMsgRaw("\n");
                                    if (fCase1) {
                                        BuildMsgRaw("Compiling %s because filename is missing from build database *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase2) {
                                        BuildMsgRaw("Compiling %s because (Case 2) *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase3) {
                                        BuildMsgRaw("Compiling %s because Target date == 0 *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase4) {
                                        BuildMsgRaw("Compiling %s because C file is later earlier than pch *2\n", psr->pfrSource->Name);
                                    } else
                                    if (fCase5) {
                                        BuildMsgRaw("Compiling %s because (Case 5) *2\n", psr->pfrSource->Name);
                                    }
                                }

                                psr->SrcFlags |= SOURCEDB_COMPILE_NEEDED;

                                if (pfr->FileFlags & FILEDB_PASS0) {
                                    DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                                }
                                else
                                    DirDB->DirFlags |= DIRDB_COMPILENEEDED;

                                if (Target->DateTime != 0 && !fKeep)
                                {
                                    DeleteSingleFile(NULL, Target->Name, FALSE);
                                }

                                FreeMem(&Target, MT_TARGET);

                                if (j != 0) {
                                    //
                                    // Delete the 'rule target' so nmake
                                    // doesn't complain about "don't know how
                                    // to make ..."
                                    //
                                    Target = BuildCompileTarget(
                                                 pfr,
                                                 pfr->Name,
                                                 0,
                                                 pds->ConditionalIncludes,
                                                 DirDB,
                                                 pds,
                                                 iPass,
                                                 TargetMachines[i]->ObjectDirectory,
                                                 TargetMachines[i]->SourceDirectory);
                                    if (Target) {
                                        DeleteSingleFile(
                                                NULL,
                                                Target->Name,
                                                FALSE);

                                        FreeMem(&Target, MT_TARGET);
                                    }
                                }

                                // No need to check other targets,
                                // we know they all will be rebuilt.
                                break;
                            }

                            // No cycle possible at the root of the tree.

                            assert(pfrRoot == NULL);
                            FreeMem(&Target, MT_TARGET);
                        }
                    }
                }
                if (fClean || (psr->SrcFlags & SOURCEDB_COMPILE_NEEDED)) {
                    ULONG cline;

                    if (++idScan == 0) {
                        ++idScan;               // skip zero
                    }

                    if (fFirstScan && (pfr->FileFlags & FILEDB_PASS0))
                    {
                        cline = CountSourceLines(idScan, pfr);
                        DirDB->PassZeroLines += cline;
                        DirDB->CountOfPassZeroFiles++;
                    }

                    // For a multiple pass file, we really need to count the
                    // lines in the file compiled duing pass1 (and generated
                    // during pass 0).  Instead, we just count the pass 0
                    // source file all over again.  It's cheap, but the line
                    // count is inaccurate.

                    if (!fPassZero &&
                        ((pfr->FileFlags & FILEDB_MULTIPLEPASS) ||
                         !(pfr->FileFlags & FILEDB_PASS0)))
                    {
                        cline = CountSourceLines(idScan, pfr);
                        DirDB->SourceLinesToCompile += cline;
                        DirDB->CountOfFilesToCompile++;
                    }
                }
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ScanSourceDirectories
//
//  Synopsis:   Scan a source directory to determine what files it
//              contains, whether it should be compiled or linked, and
//              whether it has subdirectories that we should process.
//
//  Arguments:  [DirName] -- Directory to scan
//
//----------------------------------------------------------------------------

VOID
ScanSourceDirectories(LPSTR DirName)
{
    char path[DB_MAX_PATH_LENGTH];
    PDIRREC DirDB;
    DIRSUP *pds = NULL;
    LPSTR SavedCurrentDirectory;
    BOOL DirsPresent;
    ULONG DateTimeSources = 0;
    UINT i;

    if (DEBUG_4) {
        BuildMsgRaw(
            "ScanSourceDirectories(%s) level = %d\n",
            DirName,
            RecurseLevel);
    }

    // Change to the given directory
    SavedCurrentDirectory = PushCurrentDirectory(DirName);

    // Process all the files in this directory
    DirDB = ScanDirectory(DirName);

    AssertOptionalDir(DirDB);
    if (fCleanRestart && DirDB != NULL && !strcmp(DirDB->Name, RestartDir)) {
        fCleanRestart = FALSE;
        fClean = fRestartClean;
        fCleanLibs = fRestartCleanLibs;
    }

    if (!DirDB || !(DirDB->DirFlags & (DIRDB_DIRS | DIRDB_SOURCES))) {
        PopCurrentDirectory(SavedCurrentDirectory);
        return;
    }

    if (fShowTree && !(DirDB->DirFlags & DIRDB_SHOWN)) {
        AddShowDir(DirDB);
    }

    if (DirDB->DirFlags & DIRDB_SOURCES) {
        BOOL fSourcesRead = TRUE;

        SetObjDir((DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) != 0);

        //
        // This directory contains a SOURCES file
        //

        if (fFirstScan)
        {
            AllocMem(sizeof(DIRSUP), &pds, MT_DIRSUP);
            memset(pds, 0, sizeof(*pds));
            fSourcesRead = ReadSourcesFile(DirDB, pds, &DateTimeSources);

            DirDB->pds = pds;
        }
        else
        {
            pds = DirDB->pds;

            assert(pds);

            DateTimeSources = pds->DateTimeSources;

            //
            // We need to rebuild the sources list because
            // the previous scan was probably not complete.
            //
            if (pds)
                PostProcessSources(DirDB, pds);

        }

        assert(pds);

        if (DEBUG_4) {
            BuildMsgRaw("ScanSourceDirectories(%s) SOURCES\n", DirName);
        }

        ScanFlagsCurrent = 0;
        CountIncludeDirs = CountSystemIncludeDirs;

        //  Scan the include environments in the order that MAKEFILE.DEF
        //  processes them.  This order is:
        //
        //  1) Sources variable INCLUDE
        //  2) Cairo/Chicago directories
        //  3) System includes
        //  4) UMTYPE-derived includes
        //
        //  The subtlety is that we must do this in the reverse order
        //  since each of the processing routines pushes search directories
        //  onto the HEAD of the include search list.
        //
        //  Note: we come in here with the system includes already set.
        //  There's no way to stick the UMTYPE-derived ones ahead of the
        //  system includes

        //  4) UMTYPE-derived includes
        if (pds->TestType != NULL && !strcmp(pds->TestType, "os2")) {
            ScanGlobalIncludeDirectory(pszIncCrt);
            ScanGlobalIncludeDirectory(pszIncOs2);
            ScanFlagsCurrent |= SCANFLAGS_OS2;
        }
        else
        if (pds->TestType != NULL && !strcmp(pds->TestType, "posix")) {
            ScanGlobalIncludeDirectory(pszIncPosix);
            ScanFlagsCurrent |= SCANFLAGS_POSIX;
        }
        else {
            ScanGlobalIncludeDirectory(pszIncCrt);
            ScanFlagsCurrent |= SCANFLAGS_CRT;
        }

        if (DirDB->DirFlags & DIRDB_CHICAGO_INCLUDES) {
            ScanGlobalIncludeDirectory(pszIncChicago);
            ScanFlagsCurrent |= SCANFLAGS_CHICAGO;
        }

        //  1) Sources variable INCLUDE
        if (pds->LocalIncludePath) {

            ScanIncludeEnv(pds->LocalIncludePath);
        }

        DirsPresent = FALSE;

    }
    else
    if (DirDB->DirFlags & DIRDB_DIRS) {
        //
        // This directory contains a DIRS or MYDIRS file
        //
        DirsPresent = ReadDirsFile(DirDB);

        if (DEBUG_4) {
            BuildMsgRaw("ScanSourceDirectories(%s) DIRS\n", DirName);
        }
    }

    if (!fQuicky || (fQuickZero && fFirstScan)) {
        if (!RecurseLevel) {
            BuildError(
                "Examining %s directory%s for %s.%s\n",
                DirDB->Name,
                DirsPresent? " tree" : "",
                fLinkOnly? "targets to link" : "files to compile",
                fFirstScan ? "" : " (2nd Pass)"
                );
        }
        ClearLine();
        BuildMsgRaw("    %s ", DirDB->Name);
        fLineCleared = FALSE;
        if (fDebug || !(BOOL) _isatty(_fileno(stderr))) {
            BuildMsgRaw(szNewLine);
            fLineCleared = TRUE;
        }
    }

    if (!fLinkOnly) {

        if (DirDB->DirFlags & DIRDB_SOURCESREAD) {
            //
            // Determine what files need to be compiled
            //
            ProcessSourceDependencies(DirDB, pds, DateTimeSources);
        }
        else
        if (fFirstScan && DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFIL0)) {
            DirDB->DirFlags |= ((fSemiQuicky && (!fQuickZero || !fFirstScan)) ? DIRDB_COMPILENEEDED :
                                                                                DIRDB_PASS0NEEDED);
        }
        else
        if (DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFIL1)) {
            DirDB->DirFlags |= DIRDB_COMPILENEEDED;
        }

        if (fFirstScan && (DirDB->DirFlags & DIRDB_PASS0NEEDED))
        {
            if (CountPassZeroDirs >= MAX_BUILD_DIRECTORIES) {
                BuildError(
                    "%s: Ignoring PassZero Directory table overflow, %u "
                    "entries allowed\n",
                    DirDB->Name,
                    MAX_BUILD_DIRECTORIES);
            }
            else {
                //
                // This directory needs to be compiled in pass zero.  Add it
                // to the list.
                //
                PassZeroDirs[CountPassZeroDirs++] = DirDB;
            }

            if (fQuicky && !fQuickZero) {
                if (!(fSemiQuicky && (DirDB->DirFlags & DIRDB_COMPILENEEDED))) {
                    // For -Z with compile needed anyway, CompileSourceDirectories do it.
                    CompilePassZeroDirectories();
                }
                CountPassZeroDirs = 0;
            }
            else {
                if (fFirstScan) {
                    fPassZero = TRUE;     // Limits scanning during pass zero.
                }

                if (DirDB->CountOfPassZeroFiles) {
                    if (fLineCleared) {
                        BuildMsgRaw("    %s ", DirDB->Name);
                    }
                    BuildMsgRaw(
                        "- %d Pass Zero files (%s lines)\n",
                        DirDB->CountOfPassZeroFiles,
                        FormatNumber(DirDB->PassZeroLines));
                }
            }
        }

        if ((DirDB->DirFlags & DIRDB_COMPILENEEDED) &&
            (!fFirstScan || !fPassZero)) {

            if (CountCompileDirs >= MAX_BUILD_DIRECTORIES) {
                BuildError(
                    "%s: Ignoring Compile Directory table overflow, %u "
                    "entries allowed\n",
                    DirDB->Name,
                    MAX_BUILD_DIRECTORIES);
            }
            else {
                //
                // This directory needs to be compiled.  Add it to the list.
                //
                CompileDirs[CountCompileDirs++] = DirDB;
            }

            if (fQuicky && (!fQuickZero || !fFirstScan)) {
                CompileSourceDirectories();
                CountCompileDirs = 0;
            }
            else
            if (DirDB->CountOfFilesToCompile) {
                if (fLineCleared) {
                    BuildMsgRaw("    %s ", DirDB->Name);
                }
                BuildMsgRaw(
                    "- %d source files (%s lines)\n",
                    DirDB->CountOfFilesToCompile,
                    FormatNumber(DirDB->SourceLinesToCompile));
            }
        }
    }

    if (DirsPresent && (DirDB->DirFlags & DIRDB_MAKEFILE)) {
        DirDB->DirFlags |= DIRDB_LINKNEEDED | DIRDB_FORCELINK;
    }
    else
    if (DirDB->DirFlags & DIRDB_TARGETFILES) {
        DirDB->DirFlags |= DIRDB_LINKNEEDED | DIRDB_FORCELINK;
    }

    if ((DirDB->DirFlags & DIRDB_LINKNEEDED) && (!fQuicky || fSemiQuicky)) {
        if (CountLinkDirs >= MAX_BUILD_DIRECTORIES) {
            BuildError(
                "%s: Ignoring Link Directory table overflow, %u entries allowed\n",
                DirDB->Name,
                MAX_BUILD_DIRECTORIES);
        }
        else {
            LinkDirs[CountLinkDirs++] = DirDB;
        }
    }
    if ((DirDB->DirFlags & DIRDB_SOURCESREAD) && !fFirstScan) {
        FreeDirSupData(pds);        // free data that are no longer needed
        FreeMem(&pds, MT_DIRSUP);
        DirDB->pds = NULL;
    }

    //
    // Recurse into subdirectories
    //
    if (DirsPresent) {
        for (i = 1; i <= DirDB->CountSubDirs; i++) {
            FILEREC *FileDB, **FileDBNext;

            FileDBNext = &DirDB->Files;
            while (FileDB = *FileDBNext) {
                if (FileDB->SubDirIndex == (USHORT) i) {
                    GetCurrentDirectory(DB_MAX_PATH_LENGTH, path);
                    strcat(path, "\\");
                    strcat(path, FileDB->Name);
                    DirDB->RecurseLevel = (USHORT) ++RecurseLevel;
                    ScanSourceDirectories(path);
                    RecurseLevel--;
                    break;
                }
                FileDBNext = &FileDB->Next;
            }
        }
    }

    if (((fQuickZero && fFirstScan) || (!fQuicky)) && !RecurseLevel) {
        ClearLine();
    }

    PopCurrentDirectory(SavedCurrentDirectory);
}


//+---------------------------------------------------------------------------
//
//  Function:   CompilePassZeroDirectories
//
//  Synopsis:   Spawns the compiler on the directories in the PassZeroDirs
//              array.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
CompilePassZeroDirectories(
    VOID
    )
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i;
    PCHAR s;

    StartElapsedTime();
    for (i = 0; i < CountPassZeroDirs; i++) {

        DirDB = PassZeroDirs[ i ];
        AssertDir(DirDB);

        if (fQuicky && !fSemiQuicky)
            s = "Compiling and linking";
        else
            s = "Building generated files in";

        BuildMsg("%s %s\n", s, DirDB->Name);
        LogMsg("%s %s%s\n", s, DirDB->Name, szAsterisks);

        if ((fQuickZero && fFirstScan) || !fQuicky) {
            SavedCurrentDirectory = PushCurrentDirectory( DirDB->Name );
        }

        if (DirDB->DirFlags & DIRDB_DIRS) {
            if (DirDB->DirFlags & DIRDB_MAKEFIL0) {
                strcpy( MakeParametersTail, " -f makefil0." );
                strcat( MakeParametersTail, " NOLINK=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\n", MakeProgram, MakeParameters);
                }
                else {
                    if (DEBUG_1) {
                        BuildMsg(
                            "Executing: %s %s\n",
                            MakeProgram,
                            MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE);
                }
            }
        }
        else {
            strcpy(MakeParametersTail, " NTTEST=");
            if (DirDB->KernelTest) {
                strcat(MakeParametersTail, DirDB->KernelTest);
            }

            strcat(MakeParametersTail, " UMTEST=");
            if (DirDB->UserTests) {
                strcat(MakeParametersTail, DirDB->UserTests);
            }

            if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
                strcat(MakeParametersTail, szCheckedAltDir);
            }
            if (fQuicky && !fSemiQuicky) {
                if (DirDB->DirFlags & DIRDB_DLLTARGET) {
                    strcat(MakeParametersTail, " MAKEDLL=1");
                }
                ProcessLinkTargets(DirDB, NULL);
            }
            else {
                strcat( MakeParametersTail, " NOLINK=1 PASS0ONLY=1");
            }

            if (fQuery) {
                BuildErrorRaw(
                         "'%s %s%s'\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }
            else {
                if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                    (fParallel)) {
                    //
                    // Wait for all threads to complete before
                    // trying to compile this directory.
                    //
                    WaitForParallelThreads();
                }
                if (DEBUG_1) {
                    BuildMsg("Executing: %s %s%s\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
                }
                CurrentCompileDirDB = DirDB;
                RecurseLevel = DirDB->RecurseLevel;
                ExecuteProgram(
                            MakeProgram,
                            MakeParameters,
                            MakeTargets,
                            (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0);
            }
        }
        PrintElapsedTime();
        if ((fQuickZero && fFirstScan) || !fQuicky) {
            PopCurrentDirectory(SavedCurrentDirectory);
        }

        DirDB->DirFlags &= ~DIRDB_PASS0NEEDED;
        DirDB->CountOfPassZeroFiles = 0;
        DirDB->PassZeroLines = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CompileSourceDirectories
//
//  Synopsis:   Spawns the compiler on the directories in the CompileDirs
//              array.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
CompileSourceDirectories(
    VOID
    )
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i,j;
    PCHAR s;
    char path[DB_MAX_PATH_LENGTH];

    StartElapsedTime();
    for (i = 0; i < CountCompileDirs; i++) {

        DirDB = CompileDirs[ i ];

        AssertDir(DirDB);

        if (fQuicky && !fSemiQuicky) {
            s = "Compiling and linking";
        }
        else {
            s = "Compiling";
        }
        BuildMsg("%s %s directory\n", s, DirDB->Name);
        LogMsg("%s %s directory%s\n", s, DirDB->Name, szAsterisks);

        if (!fQuicky || (fQuickZero && (!fFirstScan || !RecurseLevel))) {
            SavedCurrentDirectory = PushCurrentDirectory( DirDB->Name );
            if (fQuickZero && !RecurseLevel && fFirstScan)
            {
                GenerateObjectsDotMac(DirDB, DirDB->pds, DirDB->pds->DateTimeSources);
            }
        }

        if (DirDB->DirFlags & DIRDB_DIRS) {
            if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                (fParallel)) {
                //
                // Wait for all threads to complete before
                // trying to compile this directory.
                //
                WaitForParallelThreads();
            }
            if (fSemiQuicky && (DirDB->DirFlags & DIRDB_MAKEFIL0)) {
                strcpy( MakeParametersTail, " -f makefil0." );
                strcat( MakeParametersTail, " NOLINK=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\n", MakeProgram, MakeParameters);
                }
                else {
                    if (DEBUG_1) {
                        BuildMsg(
                            "Executing: %s %s\n",
                            MakeProgram,
                            MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE);
                }
            }

            if (DirDB->DirFlags & DIRDB_MAKEFIL1) {
                strcpy( MakeParametersTail, " -f makefil1." );
                strcat( MakeParametersTail, " NOLINK=1 NOPASS0=1" );
                if (fClean) {
                    strcat( MakeParametersTail, " clean" );
                }

                if (fQuery) {
                    BuildErrorRaw("'%s %s'\n", MakeProgram, MakeParameters);
                }
                else {
                    if (DEBUG_1) {
                        BuildMsg(
                            "Executing: %s %s\n",
                            MakeProgram,
                            MakeParameters);
                    }

                    CurrentCompileDirDB = NULL;
                    RecurseLevel = DirDB->RecurseLevel;
                    ExecuteProgram(MakeProgram, MakeParameters, MakeTargets, TRUE);
                }
            }
        }
        else {
            strcpy(MakeParametersTail, " NTTEST=");
            if (DirDB->KernelTest) {
                strcat(MakeParametersTail, DirDB->KernelTest);
            }

            strcat(MakeParametersTail, " UMTEST=");
            if (DirDB->UserTests) {
                strcat(MakeParametersTail, DirDB->UserTests);
            }

            if (fQuicky && DirDB->PchObj) {
                for (j = 0; j < CountTargetMachines; j++) {
                    FormatLinkTarget(
                        path,
                        TargetMachines[j]->ObjectDirectory,
                        DirDB->TargetPath,
                        DirDB->PchObj,
                        "");

                    if (ProbeFile( NULL, path ) != -1) {
                        //
                        // the pch.obj file is present so we therefore
                        // must do this incremental build without pch
                        //
                        strcat( MakeParametersTail, " NTNOPCH=yes" );
                        break;
                    }
                }
            }

            if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
                strcat(MakeParametersTail, szCheckedAltDir);
            }
            if (fQuicky && !fSemiQuicky) {
                if (DirDB->DirFlags & DIRDB_DLLTARGET) {
                    strcat(MakeParametersTail, " MAKEDLL=1");
                }
                ProcessLinkTargets(DirDB, NULL);
            }
            else
            if (fQuicky && fSemiQuicky) {
                strcat(MakeParametersTail, " NOLINK=1");
            }
            else {
                strcat(MakeParametersTail, " NOLINK=1 NOPASS0=1");
            }

            if (fQuery) {
                BuildErrorRaw(
                         "'%s %s%s'\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }
            else {
                if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                    (fParallel)) {
                    //
                    // Wait for all threads to complete before
                    // trying to compile this directory.
                    //
                    WaitForParallelThreads();
                }
                if (DEBUG_1) {
                    BuildMsg("Executing: %s %s%s\n",
                             MakeProgram,
                             MakeParameters,
                             MakeTargets);
                }
                CurrentCompileDirDB = DirDB;
                RecurseLevel = DirDB->RecurseLevel;
                ExecuteProgram(
                            MakeProgram,
                            MakeParameters,
                            MakeTargets,
                            (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0);
            }
        }
        PrintElapsedTime();
        if (!fQuicky || (fQuickZero && (!fFirstScan || !RecurseLevel))) {
            PopCurrentDirectory(SavedCurrentDirectory);
        }
    }
}

static CountLinkTargets;

//+---------------------------------------------------------------------------
//
//  Function:   LinkSourceDirectories
//
//  Synopsis:   Link the directories given in the LinkDirs array.  This is
//              done by passing LINKONLY=1 to nmake.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
LinkSourceDirectories(VOID)
{
    PDIRREC DirDB;
    LPSTR SavedCurrentDirectory;
    UINT i;

    CountLinkTargets = 0;
    StartElapsedTime();
    for (i = 0; i < CountLinkDirs; i++) {
        DirDB = LinkDirs[ i ];
        AssertDir(DirDB);
        SavedCurrentDirectory = PushCurrentDirectory(DirDB->Name);

        //
        // Deletes link targets as necessary
        //
        ProcessLinkTargets(DirDB, SavedCurrentDirectory);

        PopCurrentDirectory(SavedCurrentDirectory);
    }

    if (fPause && !fMTScriptSync) {
        BuildMsg("Press enter to continue with linking (or 'q' to quit)...");
        if (getchar() == 'q') {
            return;
        }
    }

    for (i = 0; i < CountLinkDirs; i++) {
        DirDB = LinkDirs[i];

        if (!fMTScriptSync &&
            (DirDB->DirFlags & DIRDB_COMPILEERRORS) &&
            (DirDB->DirFlags & DIRDB_FORCELINK) == 0) {

            BuildMsg("Compile errors: not linking %s directory\n", DirDB->Name);
            LogMsg(
                "Compile errors: not linking %s directory%s\n",
                DirDB->Name,
                szAsterisks);
            continue;
        }

        SavedCurrentDirectory = PushCurrentDirectory(DirDB->Name);

        BuildMsg("Linking %s directory\n", DirDB->Name);
        LogMsg  ("Linking %s directory%s\n", DirDB->Name, szAsterisks);

        strcpy(MakeParametersTail, " LINKONLY=1 NOPASS0=1");
        strcat(MakeParametersTail, " NTTEST=");
        if (DirDB->KernelTest) {
            strcat(MakeParametersTail, DirDB->KernelTest);
        }

        strcat(MakeParametersTail, " UMTEST=");
        if (DirDB->UserTests) {
            strcat(MakeParametersTail, DirDB->UserTests);
        }

        if (DirDB->DirFlags & DIRDB_CHECKED_ALT_DIR) {
            strcat(MakeParametersTail, szCheckedAltDir);
        }

        if (DirDB->DirFlags & DIRDB_DLLTARGET) {
            strcat(MakeParametersTail, " MAKEDLL=1");
        }

        if ((DirDB->DirFlags & DIRDB_DIRS) &&
            (DirDB->DirFlags & DIRDB_MAKEFILE) &&
            fClean) {
            strcat(MakeParametersTail, " clean");
        }

        if (fQuery) {
            BuildErrorRaw(
                "'%s %s%s'\n",
                MakeProgram,
                MakeParameters,
                MakeTargets);
        }
        else {
            if ((DirDB->DirFlags & DIRDB_SYNCHRONIZE_DRAIN) &&
                (fParallel) && (fSyncLink)) {
                //
                // Wait for all threads to complete before
                // trying to compile this directory.
                //
                WaitForParallelThreads();
            }
            if (DEBUG_1) {
                BuildMsg("Executing: %s %s%s\n",
                         MakeProgram,
                         MakeParameters,
                         MakeTargets);
            }

            CurrentCompileDirDB = NULL;
            RecurseLevel = DirDB->RecurseLevel;
            ExecuteProgram(MakeProgram,
                           MakeParameters,
                           MakeTargets,
                           (fSyncLink) && (DirDB->DirFlags & DIRDB_SYNCHRONIZE_BLOCK) != 0);
        }
        PopCurrentDirectory(SavedCurrentDirectory);
        PrintElapsedTime();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTargetData
//
//  Synopsis:   Searches aTargetInfo for an entry corresponding to the given
//              extension.
//
//  Arguments:  [ext]        -- Extension to look up (including '.').
//              [iPass]      -- 0 for pass zero; 1 for pass 1
//              [index]      -- Index used to differentiate multiple targets
//              [usMidlFlag] -- Indicates which set of MIDL targets should
//                              be used for MIDL source files.
//
//  Returns:    A TARGETDATA for the given extension and index. NULL if
//              Index is invalid.
//
//  History:    29-Jul-94     LyleC    Created
//
//  Notes:      If ext is not found in the aTargetInfo array, then a default
//              TARGETINFO is used which maps the extension to obj\*\.obj.
//
//----------------------------------------------------------------------------

LPTARGETDATA
GetTargetData(LPSTR ext, LONG iPass, USHORT index, ULONG usMidlIndex)
{
    int i;
    OBJECTTARGETINFO **aTargetInfo;
    int cTargetInfo;

    if (!ext || (ext[0] == '\0') || (ext[1] == '\0'))
        return &DefaultData;

    if ((ext[1] == aMidlTargetInfo0[usMidlIndex]->pszSourceExt[1]) &&
        (strcmp(ext, aMidlTargetInfo0[usMidlIndex]->pszSourceExt) == 0))
    {
        if (index >= aMidlTargetInfo0[usMidlIndex]->NumData)
            return NULL;

        return &(aMidlTargetInfo0[usMidlIndex]->Data[index]);
    }

    assert(iPass == 0 || iPass == 1);
    cTargetInfo = aTargetArray[iPass].cTargetInfo;
    aTargetInfo = aTargetArray[iPass].aTargetInfo;

    for (i = 0; i < cTargetInfo; i++)
    {
        if ((ext[1] == aTargetInfo[i]->pszSourceExt[1]) &&
            (strcmp(ext, aTargetInfo[i]->pszSourceExt) == 0))
        {
            if (index >= aTargetInfo[i]->NumData)
                return NULL;

            return(&aTargetInfo[i]->Data[index]);
        }
    }

    if (index)
        return NULL;

    return &DefaultData;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildCompileTarget
//
//  Synopsis:   Fills a TARGET struct with data about the target of a given
//              source file.
//
//  Arguments:  [pfr]                    -- FileRec of source file
//              [pszfile]                -- Path of source file (compiland)
//              [TargetIndex]            -- Which target for a source file
//                                          with multiple targets.
//              [pszConditionalIncludes] -- List of conditional includes
//              [pdrBuild]               -- Build directory (with source file)
//              [iPass]                  -- 0 for pass zero; 1 for pass 1
//              [ppszObjectDir]          -- Names of target object directories
//              [pszSourceDir]           -- Name of machine specific source dir
//
//  Returns:    A filled TARGET struct.  NULL if TargetIndex is an invalid
//              value for the given file type.
//
//  Notes:      If [pfr] is NULL, then [pszfile] is not modified and is
//              used as the full pathname of the target file.
//              [pszObjectDir] is ignored in this case.  if [pfr] is not
//              NULL, the filename component of [pszfile] is taken, its
//              extension is modified, and it is appended to [pszObjectDir]
//              to obtain the pathname of the target.  The other data is
//              used to fill in the rest of the TARGET struct in all cases.
//
//              For source files with multiple targets, use the TargetIndex
//              parameter to indicate which target you want the path of.  For
//              instance, .idl files have two targets, so a TargetIndex of 0
//              will return the .h target and TargetIndex=1 will return the
//              .c target.  A TargetIndex of 2 or above in this case will
//              return NULL. TargetIndex is ignored if [pfr] is NULL.
//
//----------------------------------------------------------------------------

TARGET *
BuildCompileTarget(
    FILEREC *pfr,
    LPSTR    pszfile,
    USHORT   TargetIndex,
    LPSTR    pszConditionalIncludes,
    DIRREC  *pdrBuild,
    DIRSUP  *pdsBuild,
    LONG     iPass,
    LPSTR   *ppszObjectDir,
    LPSTR    pszSourceDir)
{
    LPSTR p, p1;
    PTARGET Target;
    char path[DB_MAX_PATH_LENGTH];
    LPTARGETDATA pData;

    p = pszfile;
    if (pfr != NULL) {
        p1 = p;
        while (*p) {
            if (*p++ == '\\') {
                p1 = p;         // point to last component of pathname
            }
        }

        sprintf(path, "%s", p1);

        p = strrchr(path, '.');

        pData = GetTargetData(p, iPass, TargetIndex, pdsBuild->IdlType);

        if (!pData) {
            if (DEBUG_1) {
                BuildMsg(
                    "BuildCompileTarget(\"%s\"[%u][%u], \"%s\") -> NULL\n",
                    pszfile,
                    iPass,
                    TargetIndex,
                    ppszObjectDir[iObjectDir]);
            }
            return NULL;
        }

        assert(pdsBuild);

        switch (pData->ObjectDirFlag)
        {
        case TD_OBJECTDIR:
            p = ppszObjectDir[iObjectDir];
            break;

        case TD_PASS0HDRDIR:
            p = pdsBuild->PassZeroHdrDir;
            break;

            p = pdsBuild->PassZeroSrcDir1;
            break;

        case TD_MCSOURCEDIR:
        case TD_PASS0DIR1:
            p = pdsBuild->PassZeroSrcDir1;
            break;

        case TD_PASS0DIR2:
            p = pdsBuild->PassZeroSrcDir2;
            break;

        default:
            assert(0 && "Invalid ObjectDirFlag");
            break;
        }

        if (!p) {
            // Make sure path ends in a period
            sprintf(path, "%s.", p1);
        } else
        if (p[0] == '.' && p[1] == '\0') {
            strcpy(path, p1);
        }
        else {
            sprintf(path, "%s\\%s", p, p1);
        }

        p = strrchr(path, '.');

        if (p) {
            strcpy(p, pData->pszTargetExt);
        }

        p = path;
    }

    AllocMem(sizeof(TARGET) + strlen(p), &Target, MT_TARGET);
    strcpy(Target->Name, p);
    Target->pdrBuild = pdrBuild;
    Target->DateTime = (*pDateTimeFile)(NULL, p);
    Target->pfrCompiland = pfr;
    Target->pszSourceDirectory = pszSourceDir;
    Target->ConditionalIncludes = pszConditionalIncludes;
    Target->DirFlags = pdrBuild->DirFlags;
    if (DEBUG_1) {
        BuildMsg(
            "BuildCompileTarget(\"%s\"[%u][%u], \"%s\") -> \"%s\"\n",
            pszfile,
            iPass,
            TargetIndex,
            ppszObjectDir[iObjectDir],
            Target->Name);
    }
    if (Target->DateTime == 0) {
        if (fShowOutOfDateFiles) {
            BuildError("%s target is missing.\n", Target->Name);
        }
    }
    return(Target);
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatLinkTarget
//
//  Synopsis:   Builds a link target path name.
//
//  Arguments:  [path]            -- Place to put constructed name
//              [ObjectDirectory] -- e.g. "obj\i386"
//              [TargetPath]      -- Path (w/o platfrom spec. name) for target
//              [TargetName]      -- Base name of target
//              [TargetExt]       -- Extension of target
//
//  Notes:      Sample input: (path, "obj\i386", "..\obj", "foobar", ".dll")
//
//                    output: path = "..\obj\i386\foobar.dll"
//
//----------------------------------------------------------------------------

VOID
FormatLinkTarget(
    LPSTR path,
    LPSTR *ObjectDirectory,
    LPSTR TargetPath,
    LPSTR TargetName,
    LPSTR TargetExt)
{
    LPSTR p, p1;

    p = ObjectDirectory[iObjectDir];
    assert(strncmp(pszObjDirSlash, p, strlen(pszObjDirSlash)) == 0);
    p1 = p + strlen(p);
    while (p1 > p) {
        if (*--p1 == '\\') {
            p1++;
            break;
        }
    }
    sprintf(path, "%s\\%s\\%s%s", TargetPath, p1, TargetName, TargetExt);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProcessLinkTargets
//
//  Synopsis:   Deletes link targets for the given directory (.lib & .dll)
//
//  Arguments:  [DirDB]            -- Directory to process
//              [CurrentDirectory] -- Current directory
//
//----------------------------------------------------------------------------

VOID
ProcessLinkTargets(PDIRREC DirDB, LPSTR CurrentDirectory)
{
    UINT i;
    char path[DB_MAX_PATH_LENGTH];

    AssertDir(DirDB);
    for (i = 0; i < CountTargetMachines; i++) {
        //
        // Delete 'special' link targets
        //
        if (DirDB->KernelTest) {
            FormatLinkTarget(
                path,
                TargetMachines[i]->ObjectDirectory,
                pszObjDir,
                DirDB->KernelTest,
                ".exe");
            if (fClean && !fKeep && fFirstScan) {
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
        else {
            UINT j;

            for (j = 0; j < 2; j++) {
                LPSTR pNextName;

                pNextName = j == 0? DirDB->UserAppls : DirDB->UserTests;
                if (pNextName != NULL) {
                    char name[256];

                    while (SplitToken(name, '*', &pNextName)) {
                        FormatLinkTarget(
                            path,
                            TargetMachines[i]->ObjectDirectory,
                            pszObjDir,
                            name,
                            ".exe");

                        if (fClean && !fKeep && fFirstScan) {
                            DeleteSingleFile(NULL, path, FALSE);
                        }
                    }
                }
            }
        }

        if (DirDB->TargetPath != NULL &&
            DirDB->TargetName != NULL &&
            DirDB->TargetExt != NULL &&
            strcmp(DirDB->TargetExt, ".lib")) {

            FormatLinkTarget(
                path,
                TargetMachines[i]->ObjectDirectory,
                DirDB->TargetPath,
                DirDB->TargetName,
                DirDB->TargetExt);

            if (fClean && !fKeep && fFirstScan) {
                DeleteSingleFile(NULL, path, FALSE);
            }
        }
        if (DirDB->DirFlags & DIRDB_DIRS) {
            if (fDebug && (DirDB->DirFlags & DIRDB_MAKEFILE)) {
                BuildError(
                    "%s\\makefile. unexpected in directory with DIRS file\n",
                    DirDB->Name);
            }
            if ((DirDB->DirFlags & DIRDB_SOURCES)) {
                BuildError(
                    "%s\\sources. unexpected in directory with DIRS file\n",
                    DirDB->Name);
                BuildError("Ignoring %s\\sources.\n", DirDB->Name);
                DirDB->DirFlags &= ~DIRDB_SOURCES;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IncludeError
//
//  Synopsis:   Print out the name of an include file and an error message
//              to the screen.
//
//  Arguments:  [pt]       -- Target of the file which includes the include
//                             file or [pfr].
//              [pfr]      -- File which includes the include file
//              [pir]      -- Include file at issue
//              [pszError] -- Error string
//
//  Notes:      If [pt]->pfrCompiland and [pfr] are different, then the names
//              of both are printed.
//
//----------------------------------------------------------------------------

VOID
IncludeError(TARGET *pt, FILEREC *pfr, INCLUDEREC *pir, LPSTR pszError)
{
    char c1, c2;

    AssertFile(pfr);
    AssertInclude(pir);
    if (pir->IncFlags & INCLUDEDB_LOCAL) {
        c1 = c2 = '"';
    }
    else {
        c1 = '<';
        c2 = '>';
    }
    BuildError("%s\\%s: ", pt->pfrCompiland->Dir->Name, pt->pfrCompiland->Name);
    if (pt->pfrCompiland != pfr) {
        if (pt->pfrCompiland->Dir != pfr->Dir) {
            BuildErrorRaw("%s\\", pfr->Dir->Name);
        }
        BuildErrorRaw("%s: ", pfr->Name);
    }
    BuildErrorRaw("%s %c%s%c\n", pszError, c1, pir->Name, c2);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsConditionalInc
//
//  Synopsis:   Returns TRUE if the given filename is a conditional include
//              for this directory.  (As given by the CONDITIONAL_INCLUDES
//              macro).
//
//  Arguments:  [pszFile] -- Name of file to check
//              [pt]      -- Target struct giving list of conditional includes
//
//  Returns:    TRUE if it's a conditional include
//
//----------------------------------------------------------------------------

BOOL
IsConditionalInc(LPSTR pszFile, TARGET *pt)
{
    AssertPathString(pszFile);

    if (pt->ConditionalIncludes != NULL) {
        LPSTR p;
        char name[DB_MAX_PATH_LENGTH];

        p = pt->ConditionalIncludes;
        while (SplitToken(name, ' ', &p)) {
            if (strcmp(name, pszFile) == 0) {
                return(TRUE);
            }
        }
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsExcludedInc
//
//  Synopsis:   Returns TRUE if the given file is listed in the ExcludeIncs
//              array.
//
//  Arguments:  [pszFile] -- File to check
//
//----------------------------------------------------------------------------

BOOL
IsExcludedInc(LPSTR pszFile)
{
    ULONG i;

    AssertPathString(pszFile);
    for (i = 0; i < CountExcludeIncs; i++) {
        if (!strcmp(pszFile, ExcludeIncs[i])) {
            return(TRUE);
        }
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckDependencies
//
//  Synopsis:   Process dependencies to see if a target is out of date
//
//  Arguments:  [Target]    -- Target to check date on
//              [FileDB]    -- File which makes [Target]
//              [CheckDate] -- If FALSE, then the date check is bypassed.
//              [ppfrRoot]  -- Returns a cycle root if a cycle is encountered.
//                               Used only during recursion.
//
//  Returns:    TRUE if [Target] is out of date w/r/t [FileDB]
//
//----------------------------------------------------------------------------

BOOL
CheckDependencies(
    PTARGET Target,
    FILEREC *FileDB,
    BOOL CheckDate,
    FILEREC **ppfrRoot)
{
    BOOL fOutOfDate;
    BOOL CheckVersion;
    static ULONG ChkRecursLevel = 0;

    *ppfrRoot = NULL;
    ChkRecursLevel++;

    assert(FileDB != NULL);     // NULL FileDB should never happen.
    AssertFile(FileDB);

    if (FileDB->fDependActive) {

        // We have detected a loop in the graph of include files.
        // Just return, to terminate the recursion.

        if (DEBUG_1) {
            BuildMsgRaw(
                "ChkDepend(%s, %s, %u) %s\n",
                Target->Name,
                FileDB->Name,
                CheckDate,
                "Target Match, *** ASSUME UP TO DATE ***");
        }
        if (DEBUG_4) {
            BuildMsgRaw(
                "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x %s\n",
                ChkRecursLevel,
                LocalSequence,
                GlobalSequence,
                Target->Name,
                Target->DateTime,
                "",
                ChkRecursLevel,
                szRecurse,
                FileDB->Name,
                CheckDate,
                FileDB->DateTime,
                "Target Match");
        }
        *ppfrRoot = FileDB;
        ChkRecursLevel--;
        return(FALSE);
    }
    if (DEBUG_4) {
        BuildMsgRaw(
            "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x\n",
            ChkRecursLevel,
            LocalSequence,
            GlobalSequence,
            Target->Name,
            Target->DateTime,
            "++",
            ChkRecursLevel,
            szRecurse,
            FileDB->Name,
            CheckDate,
            FileDB->DateTime);
    }

    // We've decided to process this file:

    FileDB->fDependActive = TRUE;
    CheckVersion = fEnableVersionCheck;
    fOutOfDate = FALSE;

    if (FileDB->GlobalSequence != GlobalSequence ||
        FileDB->LocalSequence != LocalSequence) {
        if (FileDB->GlobalSequence != 0 || FileDB->LocalSequence != 0) {
            if (DEBUG_1) {
                BuildError(
                    "Include Sequence %hu/%hu -> %hu/%hu\n",
                    FileDB->LocalSequence,
                    FileDB->GlobalSequence,
                    LocalSequence,
                    GlobalSequence);
            }
            if (fDebug & 16) {
                PrintFileDB(stderr, FileDB, 0);
            }
            UnsnapIncludeFiles(
                FileDB,
                (FileDB->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES) == 0 ||
                    FileDB->GlobalSequence != GlobalSequence);
        }
        FileDB->GlobalSequence = GlobalSequence;
        FileDB->LocalSequence = LocalSequence;
        FileDB->DateTimeTree = 0;
    }

    if (DEBUG_1) {
        BuildMsgRaw(
            "ChkDepend(%s, %s, %u)\n",
            Target->Name,
            FileDB->Name,
            CheckDate);
    }

    if (CheckDate &&
        (FileDB->FileFlags & FILEDB_HEADER) &&
        FileDB->DateTimeTree == 0 &&
        IsExcludedInc(FileDB->Name)) {

        if (DEBUG_1) {
            BuildMsg("Skipping date check for %s\n", FileDB->Name);
        }
        CheckVersion = FALSE;
        FileDB->DateTimeTree = 1;       // never out of date
    }

    if (FileDB->IncludeFiles == NULL && FileDB->DateTimeTree == 0) {
        FileDB->DateTimeTree = FileDB->DateTime;
        if (DEBUG_4) {
            BuildMsgRaw(
                "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x\n",
                ChkRecursLevel,
                LocalSequence,
                GlobalSequence,
                Target->Name,
                Target->DateTime,
                "t<-f",
                ChkRecursLevel,
                szRecurse,
                FileDB->Name,
                CheckDate,
                FileDB->DateTime);
        }
    }
    if (CheckDate &&
        (Target->DateTime < FileDB->DateTime ||
         Target->DateTime < FileDB->DateTimeTree)) {
        if (Target->DateTime != 0) {
            if (DEBUG_1 || fShowOutOfDateFiles) {
                BuildMsg("%s is out of date with respect to %s\\%s.\n",
                         Target->Name,
                         FileDB->NewestDependency->Dir->Name,
                         FileDB->NewestDependency->Name);
            }
        }
        fOutOfDate = TRUE;
    }

    //
    // If FileDB->DateTimeTree is non-zero, then the field is equal to the
    // newest DateTime of this file or any of its dependants, so we don't
    // need to go through the dependency tree again.
    //

    if (FileDB->DateTimeTree == 0) {
        INCLUDEREC *IncludeDB, **IncludeDBNext, **ppirTree;

        //
        // Find the file records for all include files so that after cycles are
        // collapsed, we won't attempt to lookup an include file relative to
        // the wrong directory.
        //

        ppirTree = &FileDB->IncludeFilesTree;
        for (IncludeDBNext = &FileDB->IncludeFiles;
            (IncludeDB = *IncludeDBNext) != NULL;
            IncludeDBNext = &IncludeDB->Next) {

            AssertInclude(IncludeDB);
            AssertCleanTree(IncludeDB, FileDB);
            IncludeDB->IncFlags |= INCLUDEDB_SNAPPED;
            if (IncludeDB->pfrInclude == NULL) {
                IncludeDB->pfrInclude =
                    FindIncludeFileDB(
                        FileDB,
                        Target->pfrCompiland,
                        Target->pdrBuild,
                        Target->pszSourceDirectory,
                        IncludeDB);
                AssertOptionalFile(IncludeDB->pfrInclude);
                if (IncludeDB->pfrInclude != NULL &&
                    (IncludeDB->pfrInclude->Dir->DirFlags & DIRDB_GLOBAL_INCLUDES))
                {
                    IncludeDB->IncFlags |= INCLUDEDB_GLOBAL;
                }

            }
            if (IncludeDB->pfrInclude == NULL) {
                if (!IsConditionalInc(IncludeDB->Name, Target)) {
                    if (DEBUG_1 || !(IncludeDB->IncFlags & INCLUDEDB_MISSING)) {
                        IncludeError(
                            Target,
                            FileDB,
                            IncludeDB,
                            "cannot find include file");
                        IncludeDB->IncFlags |= INCLUDEDB_MISSING;
                    }
                } else
                if (DEBUG_1) {
                    IncludeError(
                        Target,
                        FileDB,
                        IncludeDB,
                        "Skipping missing conditional include file");
                }
                continue;
            }
            *ppirTree = IncludeDB;
            ppirTree = &IncludeDB->NextTree;
        }
        *ppirTree = NULL;       // truncate any links from previous sequence
        FileDB->DateTimeTree = FileDB->DateTime;

        //
        // Walk through the dynamic list.
        //
rescan:
        for (IncludeDBNext = &FileDB->IncludeFilesTree;
            (IncludeDB = *IncludeDBNext) != NULL;
            IncludeDBNext = &IncludeDB->NextTree) {

            AssertInclude(IncludeDB);
            if (DEBUG_2) {
                BuildMsgRaw(
                    "%lu-%hu/%hu %s  %*s%-10s %*s%s\n",
                    ChkRecursLevel,
                    LocalSequence,
                    GlobalSequence,
                    Target->pfrCompiland->Name,
                    (ChkRecursLevel - 1) * 2,
                    "",
                    IncludeDB->Name,
                    max(0, 12 - ((int)ChkRecursLevel - 1) * 2),
                    "",
                    IncludeDB->pfrInclude != NULL?
                        IncludeDB->pfrInclude->Dir->Name : "not found");
            }

            //
            //  tommcg 5/21/98
            //
            //  If included file is not in "sanctioned" path, warn about it.
            //  Sanctioned paths are set in an environment variable named
            //  BUILD_ACCEPTABLE_INCLUDES which can contain wildcards and look
            //  something like this:
            //
            //  *\nt\public\*;*\nt\private\inc\*;*\..\inc\*;*\..\include\*
            //

            if (( fCheckIncludePaths ) && ( IncludeDB->pfrInclude != NULL )) {

                CheckIncludeForWarning(
                    Target->pfrCompiland->Dir->Name,
                    Target->pfrCompiland->Name,
                    FileDB->Dir->Name,
                    FileDB->Name,
                    IncludeDB->pfrInclude->Dir->Name,
                    IncludeDB->pfrInclude->Name
                    );
                }

            assert(IncludeDB->IncFlags & INCLUDEDB_SNAPPED);
            if (IncludeDB->pfrInclude != NULL) {
                if (fEnableVersionCheck) {
                    CheckDate = (IncludeDB->pfrInclude->Version == 0);
                }

                if (IncludeDB->Version != IncludeDB->pfrInclude->Version) {
                    if (CheckVersion) {
                        if (DEBUG_1 || fShowOutOfDateFiles) {
                            BuildError(
                                 "%s (v%d) is out of date with "
                                         "respect to %s\\%s (v%d).\n",
                                 FileDB->Name,
                                 IncludeDB->Version,
                                 IncludeDB->pfrInclude->Dir->Name,
                                 IncludeDB->pfrInclude->Name,
                                 IncludeDB->pfrInclude->Version);
                         }
                        FileDB->DateTimeTree = ULONG_MAX; // always out of date
                        fOutOfDate = TRUE;
                    }
                    else
                    if (!fClean && fEnableVersionCheck && !fSilent) {
                        BuildError(
                            "%s - #include %s (v%d updated to v%d)\n",
                            FileDB->Name,
                            IncludeDB->pfrInclude->Name,
                            IncludeDB->Version,
                            IncludeDB->pfrInclude->Version);
                    }
                    IncludeDB->Version = IncludeDB->pfrInclude->Version;
                    AllDirsModified = TRUE;
                }
                if (CheckDependencies(Target,
                                      IncludeDB->pfrInclude,
                                      CheckDate,
                                      ppfrRoot)) {
                    fOutOfDate = TRUE;

                    // No cycle possible if recursive call returned TRUE.

                    assert(*ppfrRoot == NULL);
                }

                // if the include file is involved in a cycle, unwind the
                // recursion up to the root of the cycle while collpasing
                // the cycle, then process the tree again from cycle root.

                else if (*ppfrRoot != NULL) {

                    AssertFile(*ppfrRoot);

                    // Don't say the file is out of date, yet.

                    fOutOfDate = FALSE;

                    // Remove the current include file record from the list,
                    // because it participates in the cycle.

                    *IncludeDBNext = IncludeDB->NextTree;
                    if (IncludeDB->IncFlags & INCLUDEDB_CYCLEROOT) {
                        RemoveFromCycleRoot(IncludeDB, FileDB);
                    }
                    IncludeDB->NextTree = NULL;
                    IncludeDB->IncFlags |= INCLUDEDB_CYCLEORPHAN;

                    // If the included file is not the cycle root, add the
                    // cycle root to the included file's include file list.

                    if (*ppfrRoot != IncludeDB->pfrInclude) {
                        LinkToCycleRoot(IncludeDB, *ppfrRoot);
                    }

                    if (*ppfrRoot == FileDB) {

                        // We're at the cycle root; clear the root pointer.
                        // Then go rescan the list.

                        *ppfrRoot = NULL;
                        if (DEBUG_4) {
                            BuildMsgRaw(
                                "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x %s\n",
                                ChkRecursLevel,
                                LocalSequence,
                                GlobalSequence,
                                Target->Name,
                                Target->DateTime,
                                "^^",
                                ChkRecursLevel,
                                szRecurse,
                                FileDB->Name,
                                CheckDate,
                                FileDB->DateTime,
                                "ReScan");
                            BuildMsgRaw("^^\n");
                        }
                        goto rescan;
                    }

                    // Merge the list for the file involved in the
                    // cycle into the root file's include list.

                    MergeIncludeFiles(
                        *ppfrRoot,
                        FileDB->IncludeFilesTree,
                        FileDB);
                    FileDB->IncludeFilesTree = NULL;

                    // Return immediately and reprocess the flattened
                    // tree, which now excludes the include files
                    // directly involved in the cycle.  First, make
                    // sure the files removed from the cycle have their file
                    // (not tree) time stamps reflected in the cycle root.

                    if ((*ppfrRoot)->DateTimeTree < FileDB->DateTime) {
                        (*ppfrRoot)->DateTimeTree = FileDB->DateTime;
                        (*ppfrRoot)->NewestDependency = FileDB;

                        if (DEBUG_4) {
                            BuildMsgRaw(
                                "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x\n",
                                ChkRecursLevel,
                                LocalSequence,
                                GlobalSequence,
                                Target->Name,
                                Target->DateTime,
                                "t<-c",
                                ChkRecursLevel,
                                szRecurse,
                                (*ppfrRoot)->Name,
                                CheckDate,
                                (*ppfrRoot)->DateTimeTree);
                        }
                    }
                    break;
                }

                //
                // Propagate newest time up through the dependency tree.
                // This way, each parent will have the date of its newest
                // dependent, so we don't have to check through the whole
                // dependency tree for each file more than once.
                //
                // Note that similar behavior has not been enabled for
                // version checking.
                //

                if (FileDB->DateTimeTree < IncludeDB->pfrInclude->DateTimeTree)
                {
                    FileDB->DateTimeTree = IncludeDB->pfrInclude->DateTimeTree;
                    FileDB->NewestDependency =
                        IncludeDB->pfrInclude->NewestDependency;

                    if (DEBUG_4) {
                        BuildMsgRaw(
                            "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x\n",
                            ChkRecursLevel,
                            LocalSequence,
                            GlobalSequence,
                            Target->Name,
                            Target->DateTime,
                            "t<-s",
                            ChkRecursLevel,
                            szRecurse,
                            FileDB->Name,
                            CheckDate,
                            FileDB->DateTimeTree);
                    }
                }
            }
            else
            {
                //
                // Couldn't find the FILEDB for the include file, but this
                // could be because the file is 'rcinclude'd, or 'importlib'd
                // and isn't considered a source file.  In this case, just get
                // the timestamp on the file if possible.
                //
                // Time will be zero if the file is not found.
                //
                ULONG Time = (*pDateTimeFile)(NULL, IncludeDB->Name);
                if (FileDB->DateTimeTree < Time)
                {
                    FileDB->DateTimeTree = Time;
                    //
                    // Since we don't have a FILEDB for this dependency, just
                    // set the pointer to itself and print a message.
                    //
                    FileDB->NewestDependency = FileDB;

                    if (DEBUG_1 || fShowOutOfDateFiles) {
                        BuildError(
                             "%s (v%d) is out of date with respect to %s.\n",
                             FileDB->Name,
                             IncludeDB->Version,
                             IncludeDB->Name);
                    }

                    if (DEBUG_4) {
                        BuildMsgRaw(
                            "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x\n",
                            ChkRecursLevel,
                            LocalSequence,
                            GlobalSequence,
                            Target->Name,
                            Target->DateTime,
                            "t<-s",
                            ChkRecursLevel,
                            szRecurse,
                            FileDB->Name,
                            CheckDate,
                            FileDB->DateTimeTree);
                    }

                }
            }
        }
    }
    if (DEBUG_4) {
        BuildMsgRaw(
            "%lu-%hu/%hu: ChkDepend(%s %x, %4s%.*s%s, %u) %x %s\n",
            ChkRecursLevel,
            LocalSequence,
            GlobalSequence,
            Target->Name,
            Target->DateTime,
            "--",
            ChkRecursLevel,
            szRecurse,
            FileDB->Name,
            CheckDate,
            FileDB->DateTimeTree,
            *ppfrRoot != NULL? "Collapse Cycle" :
                fOutOfDate? "OUT OF DATE" : "up-to-date");
    }
    assert(FileDB->fDependActive);
    FileDB->fDependActive = FALSE;
    ChkRecursLevel--;
    return(fOutOfDate);
}



//+---------------------------------------------------------------------------
//
//  Function:   PickFirst
//
//  Synopsis:   When called iteratively, the set of returned values is
//              effectively a merge sort of the two source lists.
//
//  Effects:    The pointers given in [ppsr1] and [ppsr2] are modified to point
//              to the next appropriate item in the list.
//
//  Arguments:  [ppsr1] -- First SOURCEREC list
//              [ppsr2] -- Second SOURCEREC list
//
//  Returns:    The appropriate next item from either [ppsr1] or [ppsr2]
//
//  Notes:      [ppsr1] and [ppsr2] should each be appropriately sorted.
//
// InsertSourceDB maintains a sort order for PickFirst() based first on the
// filename extension, then on the subdirectory mask.  Two exceptions to the
// alphabetic sort are:
//             - No extension sorts last.
//             - .rc extension sorts first.
//
//----------------------------------------------------------------------------

#define PF_FIRST        -1
#define PF_SECOND       1

SOURCEREC *
PickFirst(SOURCEREC **ppsr1, SOURCEREC **ppsr2)
{
    SOURCEREC **ppsr;
    SOURCEREC *psr;
    int r = 0;

    AssertOptionalSource(*ppsr1);
    AssertOptionalSource(*ppsr2);
    if (*ppsr1 == NULL) {
        if (*ppsr2 == NULL) {
            return(NULL);               // both lists NULL -- no more
        }
        r = PF_SECOND;                  // 1st is NULL -- return 2nd
    }
    else if (*ppsr2 == NULL) {
        r = PF_FIRST;                   // 2nd is NULL -- return 1st
    }
    else {
        LPSTR pszext1, pszext2;

        pszext1 = strrchr((*ppsr1)->pfrSource->Name, '.');
        pszext2 = strrchr((*ppsr2)->pfrSource->Name, '.');
        if (pszext1 == NULL) {
            r = PF_SECOND;              // 1st has no extension -- return 2nd
        }
        else if (pszext2 == NULL) {
            r = PF_FIRST;               // 2nd has no extension -- return 1st
        }
        else if (strcmp(pszext1, ".rc") == 0) {
            r = PF_FIRST;               // 1st is .rc -- return 1st
        }
        else if (strcmp(pszext2, ".rc") == 0) {
            r = PF_SECOND;              // 2nd is .rc -- return 2nd
        }
        else {
            r = strcmp(pszext1, pszext2);
            if (r == 0 &&
                (*ppsr1)->SourceSubDirMask != (*ppsr2)->SourceSubDirMask) {
                if ((*ppsr1)->SourceSubDirMask > (*ppsr2)->SourceSubDirMask) {
                    r = PF_FIRST;       // 2nd subdir after 1st -- return 1st
                } else {
                    r = PF_SECOND;      // 1st subdir after 2nd -- return 2nd
                }
            }
        }
    }
    if (r <= 0) {
        ppsr = ppsr1;
    } else {
        ppsr = ppsr2;
    }
    psr = *ppsr;
    *ppsr = psr->psrNext;
    return(psr);
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteObjectsDefinition
//
//  Synopsis:   Writes out a single platform-specific section of the
//              _objects.mac file.
//
//  Arguments:  [OutFileHandle]   -- File handle to write to
//              [psrCommon]       -- List of common source files
//              [psrMachine]      -- List of machine-specific source files
//              [DirDB]           -- directory record
//              [ObjectVariable]  -- e.g.  386_SOURCES
//              [ObjectDirectory] -- name of machine obj dir (e.g. obj\i386)
//
//  Returns:
//
//  History:    26-Jul-94     LyleC    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
WriteObjectsDefinition(
    FILE *OutFileHandle,
    SOURCEREC *psrMachine,
    DIRSUP *pds,
    LPSTR ObjectVariable,
    LPSTR ObjectDirectory,
    LPSTR DirName
    )
{
    LPSTR        pbuf;
    LPSTR        pszextsrc;
    LPSTR        pszextdir;
    LPTARGETDATA pData;
    SOURCEREC   *psrComCopy;
    SOURCEREC   *psrMachCopy;
    SOURCEREC *psrCommon = pds->psrSourcesList[0];

    SOURCEREC *psr;
    USHORT  i;
    LONG iPass;

    //
    // We loop twice - the first time writing out the non-pass-zero files
    // to the ObjectVariable, the second time writing out pass zero
    // files to the PASS0_ObjectVariable.
    //
    for (iPass = 1; iPass >= 0; iPass--)
    {
        pbuf = BigBuf;

        pbuf[0] = '\0';
        if (iPass == 0) {
            strcpy(pbuf, "PASS0_");
        }
        strcat(pbuf, ObjectVariable);
        strcat(pbuf, "=");
        pbuf += strlen(pbuf);

        psrComCopy = psrCommon;
        psrMachCopy = psrMachine;

        while ((psr = PickFirst(&psrComCopy, &psrMachCopy)) != NULL) {

            AssertSource(psr);
            if ((psr->SrcFlags & SOURCEDB_SOURCES_LIST) == 0) {
                continue;
            }

            // if pass 0 macro and not a pass 0 file, skip it.

            if (iPass == 0 && !(psr->pfrSource->FileFlags & FILEDB_PASS0))
                continue;

            // if pass 1 macro and not a pass 1 file, skip it.

            if (iPass == 1 &&
                (psr->pfrSource->FileFlags & FILEDB_PASS0) &&
                !(psr->pfrSource->FileFlags & FILEDB_MULTIPLEPASS))
                continue;

            pszextsrc = strrchr(psr->pfrSource->Name, '.');

            if (!pszextsrc) {
                BuildError("Bad sources extension: %s\n", psr->pfrSource->Name);
                continue;
            }

            i = 0;
            while (pData = GetTargetData(pszextsrc, iPass, i, pds->IdlType))
            {
                if (pData == &DefaultData)
                {
                    //
                    // Check for implicitly 'known' extensions...
                    //
                    switch (pszextsrc[1]) {
                    case 'f':      // Fortran
                    case 'h':      // Header file ?
                    case 'p':      // Pascal
                        BuildError(
                            "%s: Interesting sources extension: %s\n",
                            DirName,
                            psr->pfrSource->Name);
                        // FALL THROUGH

                    case 'a':    // Assembly file (.asm)
                    case 'c':    // C file (.c or .cxx)
                    case 's':    // Assembly file (.s)
                        break;

                    default:
                        BuildError("Bad sources extension: %s\n",
                                   psr->pfrSource->Name);
                    }
                }

                switch (pData->ObjectDirFlag)
                {
                case TD_OBJECTDIR:
                    pszextdir = ObjectDirectory;
                    break;

                case TD_PASS0HDRDIR:
                    pszextdir = "$(PASS0_HEADERDIR)";
                    break;

                case TD_MCSOURCEDIR:
                    pszextdir = "$(MC_SOURCEDIR)";
                    break;

                case TD_PASS0DIR1:
                    pszextdir = pds->PassZeroSrcDir1;
                    break;

                case TD_PASS0DIR2:
                    pszextdir = pds->PassZeroSrcDir2;
                    break;

                default:
                    assert(0 && "Invalid ObjectDirFlag");
                    break;
                }
                assert(pszextdir);
                assert(pData->pszTargetExt);

                sprintf(
                    pbuf,
                    " \\\r\n    %s\\%.*s%s",
                    pszextdir,
                    pszextsrc - psr->pfrSource->Name,
                    psr->pfrSource->Name,
                    pData->pszTargetExt);
                pbuf += strlen(pbuf);

                i++;
            }
        }
        strcpy(pbuf, "\r\n\r\n");
        pbuf += 4;

        fwrite(BigBuf, 1, (UINT) (pbuf - BigBuf), OutFileHandle);
    }
}


DWORD
CreateDirectoriesOnPath(
    LPTSTR                  pszPath,
    LPSECURITY_ATTRIBUTES   psa)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pszPath && *pszPath)
    {
        LPTSTR pch = pszPath;

        // If the path is a UNC path, we need to skip the \\server\share
        // portion.
        //
        if ((TEXT('\\') == *pch) && (TEXT('\\') == *(pch+1)))
        {
            // pch now pointing at the server name.  Skip to the backslash
            // before the share name.
            //
            pch += 2;
            while (*pch && (TEXT('\\') != *pch))
            {
                pch++;
            }

            if (!*pch)
            {
                // Just the \\server was specified.  This is bogus.
                //
                return ERROR_INVALID_PARAMETER;
            }

            // pch now pointing at the backslash before the share name.
            // Skip to the backslash that should come after the share name.
            //
            pch++;
            while (*pch && (TEXT('\\') != *pch))
            {
                pch++;
            }

            if (!*pch)
            {
                // Just the \\server\share was specified.  No subdirectories
                // to create.
                //
                return ERROR_SUCCESS;
            }
        }

        // Loop through the path.
        //
        for (; *pch; pch++)
        {
            // Stop at each backslash and make sure the path
            // is created to that point.  Do this by changing the
            // backslash to a null-terminator, calling CreateDirecotry,
            // and changing it back.
            //
            if (TEXT('\\') == *pch)
            {
                BOOL fOk;

                *pch = 0;
                fOk = CreateDirectory (pszPath, psa);
                *pch = TEXT('\\');

                // Any errors other than path alredy exists and we should
                // bail out.  We also get access denied when trying to
                // create a root drive (i.e. c:) so check for this too.
                //
                if (!fOk)
                {
                    dwErr = GetLastError ();
                    if (ERROR_ALREADY_EXISTS == dwErr)
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else if ((ERROR_ACCESS_DENIED == dwErr) &&
                             (pch - 1 > pszPath) && (TEXT(':') == *(pch - 1)))
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }

        if (ERROR_SUCCESS == dwErr)
        {
            // All dirs up to the last are created.  Make the last one also.
            if (CreateDirectory(pszPath, psa))
            {
                dwErr = GetLastError ();
                if (ERROR_ALREADY_EXISTS == dwErr)
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateBuildDirectory
//
//  Synopsis:   Creates a directory to hold generate object files.  SET the
//              FILE_ATTRIBUTE_ARCHIVE bit for the directory, since there is nothing
//              to backup.  We use SET since the default setting for a new directory
//              is clear.  Go figure.  DOS was such a well planned product.
//
//  Arguments:  [Name]            -- Directory to create
//
//  Returns:    TRUE if directory already exists or was created successfully.
//              FALSE otherwise.
//----------------------------------------------------------------------------

BOOL
CreateBuildDirectory(LPSTR Name)
{
    DWORD Attributes;

    Attributes = GetFileAttributes(Name);
    if (Attributes == -1) {
        CreateDirectoriesOnPath(Name, NULL);
        Attributes = GetFileAttributes(Name);
    }

    if (Attributes != -1 && ((Attributes & FILE_ATTRIBUTE_ARCHIVE) == 0)) {
        SetFileAttributes(Name, Attributes | FILE_ATTRIBUTE_ARCHIVE);
    }

    return((BOOL)(Attributes != -1));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreatedBuildFile
//
//  Synopsis:   Called whenever BUILD creates a file.  Clears the FILE_ATTRIBUTE_ARCHIVE
//              bit for the file, since there is nothing to backup with a generated file.
//
//  Arguments:  [DirName]         -- DIRDB for directory
//              [FileName]        -- file name path relative to DirName
//
//----------------------------------------------------------------------------

VOID
CreatedBuildFile(LPSTR DirName, LPSTR FileName)
{
    char Name[ DB_MAX_PATH_LENGTH * 2 + 1]; // ensure we have enough space for "DirName" + "\\" + "FileName"
    DWORD Attributes;

    strcpy(Name, DirName);
    if (Name[0] != '\0') {
        strcat(Name, "\\");
    }
    strcat(Name, FileName);

    Attributes = GetFileAttributes(Name);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(Name, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GenerateObjectsDotMac
//
//  Synopsis:   Creates the _objects.mac file containing info for all platforms
//
//  Arguments:  [DirDB]           -- Directory to create file for
//              [pds]             -- Supplementary information on [DirDB]
//              [DateTimeSources] -- Timestamp of the SOURCES file
//
//----------------------------------------------------------------------------

VOID
GenerateObjectsDotMac(DIRREC *DirDB, DIRSUP *pds, ULONG DateTimeSources)
{
    FILE *OutFileHandle;
    UINT i;
    ULONG ObjectsDateTime;

    CreateBuildDirectory("obj");
    if (strcmp(pszObjDir, "obj") != 0) {
        if (ProbeFile(".", pszObjDir) == -1) {
            CreateDirectory(pszObjDir, NULL);
        }
    }
    for (i = 0; i < CountTargetMachines; i++) {
        assert(strncmp(
                    pszObjDirSlash,
                    TargetMachines[i]->ObjectDirectory[iObjectDir],
                    strlen(pszObjDirSlash)) == 0);
        CreateBuildDirectory(TargetMachines[i]->ObjectDirectory[iObjectDir]);
    }

    if (ObjectsDateTime = (*pDateTimeFile)(DirDB->Name, "obj\\_objects.mac")) {

        if (DateTimeSources == 0) {
            BuildError("%s: no sources timestamp\n", DirDB->Name);
        }

        if (ObjectsDateTime >= DateTimeSources) {
            if (!fForce) {
                return;
            }
        }
    }
    if (!MyOpenFile(DirDB->Name, "obj\\_objects.mac", "wb", &OutFileHandle, TRUE)) {
        return;
    }

    if ((DirDB->DirFlags & DIRDB_SOURCES_SET) == 0) {
        BuildError("Missing SOURCES= definition in %s\n", DirDB->Name);
    } else {
        for (i = 0; i < MAX_TARGET_MACHINES; i++) {
            WriteObjectsDefinition(
                OutFileHandle,
                pds->psrSourcesList[i + 1],
                pds,
                PossibleTargetMachines[i]->ObjectVariable,
                PossibleTargetMachines[i]->ObjectMacro,
                DirDB->Name);
        }
    }
    fclose(OutFileHandle);
    CreatedBuildFile(DirDB->Name, "obj\\_objects.mac");

    //
    // If the _objects.mac file was generated during the first pass, then we
    // want to regenerate it during the second scan because the first scan
    // wasn't complete and _objects.mac may not be correct for non-pass-zero
    // files.  We do this by setting the timestamp back to the old time.
    //
    if (fFirstScan && fPassZero)
    {
        HANDLE hf;
        FILETIME ft;

        hf = CreateFile("obj\\_objects.mac", GENERIC_WRITE, 0,
                (LPSECURITY_ATTRIBUTES)NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                (HANDLE)NULL);

        if (hf != INVALID_HANDLE_VALUE) {
            ULONG time;

            if (ObjectsDateTime) {
                time = ObjectsDateTime;
            }
            else if (DateTimeSources) {
                //
                // All we care about is that time time stamp on _objects.mac
                // is less than that of the sources file so it will get
                // regenerated during the second scan.
                //
                time = DateTimeSources;
                if (LOWORD(time) != 0)
                    time &= 0xFFFF0000;  // 00:00:00 on the same date
                else
                    time = 0x1421A000;       // 12:00:00 1/1/1990
            }
            else {
                time = 0x1421A000;       // 12:00:00 1/1/1990
            }

            DosDateTimeToFileTime(HIWORD(time), LOWORD(time), &ft);

            SetFileTime(hf, (LPFILETIME)NULL, (LPFILETIME)NULL, &ft);

            CloseHandle(hf);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildsrc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       buildsrc.c
//
//  Contents:   Functions used to process SOURCES and DIRS files
//
//  History:    16-May-89     SteveWo    Created
//              26-Jul-94     LyleC      Split out from buildmak.c
//
//----------------------------------------------------------------------------

#include "build.h"

//
// Definitions used by the macro functions
//

#define LPAREN  '('
#define RPAREN  ')'

// Legal character for a macro name.
#define MACRO_CHAR(ch) iscsym(ch)

#define CMACROMAX       1000     // maximum unique macros per sources/dirs file

typedef struct _MACRO {
    LPSTR  pszValue;
    UCHAR  szName[1];
} MACRO;


MACRO *apMacro[CMACROMAX];
UINT cMacro = 0;

LPSTR *ppCurrentDirsFileName;
DWORD StartTime;

#define SOURCES_TARGETNAME              0
#define SOURCES_TARGETPATH              1
#define SOURCES_TARGETPATHLIB           2
#define SOURCES_TARGETTYPE              3
#define SOURCES_TARGETEXT               4
#define SOURCES_INCLUDES                5
#define SOURCES_NTTEST                  6
#define SOURCES_UMTYPE                  7
#define SOURCES_UMTEST                  8
#define SOURCES_OPTIONAL_UMTEST         9
#define SOURCES_UMAPPL                  10
#define SOURCES_UMAPPLEXT               11
#define SOURCES_NTTARGETFILE0           12
#define SOURCES_NTTARGETFILES           13
#define SOURCES_PRECOMPILED_INCLUDE     14
#define SOURCES_PRECOMPILED_PCH         15
#define SOURCES_PRECOMPILED_OBJ         16
#define SOURCES_PRECOMPILED_TARGET      17
#define SOURCES_CHICAGO_PRODUCT         18
#define SOURCES_CONDITIONAL_INCLUDES    19
#define SOURCES_SYNCHRONIZE_BLOCK       20
#define SOURCES_SYNCHRONIZE_DRAIN       21
#define SOURCES_PASS0_SOURCEDIR         22
#define SOURCES_PASS0_HEADERDIR         23
#define SOURCES_MIDL_UUIDDIR            24
#define SOURCES_PASS0_CLIENTDIR         25
#define SOURCES_PASS0_SERVERDIR         26
#define SOURCES_IDLTYPE                 27
#define SOURCES_SOURCES_OPTIONS         28
#define SOURCES_MFC_INCLUDES            29
#define SOURCES_SDK_LIB_DEST            30
#define SOURCES_DDK_LIB_DEST            31
#define SOURCES_SDK_INC_PATH            32
#define SOURCES_CRT_INC_PATH            33
#define SOURCES_OAK_INC_PATH            34
#define SOURCES_DDK_INC_PATH            35
#define SOURCES_WDM_INC_PATH            36
#define SOURCES_PRIVATE_INC_PATH        37
#define SOURCES_CHECKED_ALT_DIR         38
#define SOURCES_PROJECT_NAME            39
#define SOURCES_PASS0_PUBLISH           40

LPSTR RelevantSourcesMacros[] = {
    "TARGETNAME",
    "TARGETPATH",
    "TARGETPATHLIB",
    "TARGETTYPE",
    "TARGETEXT",
    "INCLUDES",
    "NTTEST",
    "UMTYPE",
    "UMTEST",
    "OPTIONAL_UMTEST",
    "UMAPPL",
    "UMAPPLEXT",
    "NTTARGETFILE0",
    "NTTARGETFILES",
    "PRECOMPILED_INCLUDE",
    "PRECOMPILED_PCH",
    "PRECOMPILED_OBJ",
    "PRECOMPILED_TARGET",
    "CHICAGO_PRODUCT",
    "CONDITIONAL_INCLUDES",
    "SYNCHRONIZE_BLOCK",
    "SYNCHRONIZE_DRAIN",
    "PASS0_SOURCEDIR",
    "PASS0_HEADERDIR",
    "MIDL_UUIDDIR",
    "PASS0_CLIENTDIR",
    "PASS0_SERVERDIR",
    "IDL_TYPE",
    "SOURCES_OPTIONS",
    "MFC_INCLUDES",
    "SDK_LIB_DEST",
    "DDK_LIB_DEST",
    "SDK_INC_PATH",
    "CRT_INC_PATH",
    "OAK_INC_PATH",
    "DDK_INC_PATH",
    "WDM_INC_PATH",
    "PRIVATE_INC_PATH",
    "CHECKED_ALT_DIR",
    "_PROJECT_",
    "PASS0_PUBLISH",
    NULL
};

#define SOURCES_MAX     \
        (sizeof(RelevantSourcesMacros)/sizeof(RelevantSourcesMacros[0]) - 1)

VOID
MarkDirNames(PDIRREC DirDB, LPSTR TextLine, BOOL Required);

//+---------------------------------------------------------------------------
//
//  Function:   CompressBlanks
//
//  Synopsis:   Compress multiple blank characters out of macro value, in
//              place.
//
//  Arguments:  [psrc] -- String to compress
//
//  Notes:      Note that tabs, CRs, continuation lines (and their line
//              breaks) have already been replaced with blanks.
//
//----------------------------------------------------------------------------

VOID
CompressBlanks(LPSTR psrc)
{
    LPSTR pdst = psrc;

    while (*psrc == ' ') {
        psrc++;                 // skip leading macro value blanks
    }
    while (*psrc != '\0') {
        if (*psrc == '#') {             // stop at comment
            break;
        }
        if ((*pdst++ = *psrc++) == ' ') {
            while (*psrc == ' ') {
                psrc++;         // skip multiple blanks
            }
        }
    }
    *pdst = '\0';                       // terminate the compressed copy
    if (*--pdst == ' ') {
        *pdst = '\0';           // trim trailing macro value blanks
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetBaseDir
//
//  Synopsis:   Return the value of BASEDIR, the base NT directory, if
//              appropriate.
//
//  Arguments:  [pname] -- path to split
//
//----------------------------------------------------------------------------

LPSTR
GetBaseDir(LPSTR pname)
{
    if (_stricmp("BASEDIR", pname) == 0) {
        return(NtRoot);
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindMacro
//
//  Synopsis:   Returns the value of a given macro by name.
//
//  Arguments:  [pszName] -- Name of macro who's value is desired.
//
//  Returns:    String containing the value of the macro
//
//----------------------------------------------------------------------------

LPSTR
FindMacro(LPSTR pszName)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        if (_stricmp(pszName, (*ppm)->szName) == 0) {
            return((*ppm)->pszValue);
        }
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveMacro
//
//  Synopsis:   Save the value of a macro
//
//  Arguments:  [pszName]  -- Name of macro to save
//              [pszValue] -- Value of macro
//
//  Notes:      A new string must be allocated and initialized prior to
//              freeing the old string when updating a macro value.
//
//----------------------------------------------------------------------------

VOID
SaveMacro(LPSTR pszName, LPSTR pszValue)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        if (_stricmp(pszName, (*ppm)->szName) == 0) {
            break;
        }
    }
    if (ppm == &apMacro[CMACROMAX]) {
        BuildError("Macro table full, ignoring: %s = %s\n", pszName, pszValue);
        return;
    }
    if (ppm == &apMacro[cMacro]) {
        cMacro++;
        AllocMem(sizeof(MACRO) + strlen(pszName), ppm, MT_MACRO);
        strcpy((*ppm)->szName, pszName);
        (*ppm)->pszValue = NULL;
    }
    MakeMacroString(&(*ppm)->pszValue, pszValue);
    if (DEBUG_1) {
        BuildMsg(
            "SaveMacro(%s = %s)\n",
            (*ppm)->szName,
            (*ppm)->pszValue == NULL? "NULL" : (*ppm)->pszValue);
    }
    if ((*ppm)->pszValue == NULL) {
        FreeMem(ppm, MT_MACRO);
        *ppm = apMacro[--cMacro];
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeMacros
//
//  Synopsis:   Free all macros
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
FreeMacros(VOID)
{
    MACRO **ppm;

    for (ppm = apMacro; ppm < &apMacro[cMacro]; ppm++) {
        FreeString(&(*ppm)->pszValue, MT_DIRSTRING);
        FreeMem(ppm, MT_MACRO);
        assert(*ppm == NULL);
    }
    cMacro = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   SplitMacro
//
//  Synopsis:   Take a string containing "MACRONAME = VALUE" and return
//              the target and value.
//
//  Arguments:  [pline] -- String to split and target return.
//
//  Returns:    Value of macro.
//
//----------------------------------------------------------------------------

LPSTR
SplitMacro(LPSTR *pszTarget)
{
    LPSTR pvalue, p, pline;

    pvalue = NULL;
    pline = *pszTarget;

    // Quickly reject comments and ! directives.
    if (*pline == '#' || *pline == '!') {
        return NULL;
    }

    if ((p = strchr(pline, '=')) != NULL) {
        pvalue = p + 1;                 // point past old '='
        while (p > pline && p[-1] == ' ') {
            p--;                        // point to start of trailing blanks
        }

        // Check for missing target.
        if (p == pline) {
            return NULL;
        }

        *p = '\0';                      // trim trailing blanks & '='

        // Perform macro substitution on target.
        *pszTarget = NULL;
        if (!MakeMacroString(pszTarget, pline)) {
            return NULL;
        }

        // Validate target name.  If must be a non-empty string of
        // valid macro name characters.
        if (**pszTarget == 0) {
            FreeString(pszTarget, MT_DIRSTRING);
            return NULL;
        }
        for (p = *pszTarget; *p != 0; p++) {
            if (!MACRO_CHAR(*p)) {
                FreeString(pszTarget, MT_DIRSTRING);
                return NULL;
            }
        }

        CompressBlanks(pvalue);
    }
    return(pvalue);
}


//+---------------------------------------------------------------------------
//
//  Function:   SubstituteString
//
//  Synopsis:   Perform any macro substitution.  This code was copied from the
//              nmake source.
//
//  Arguments:
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

void
SubstituteString(
    char **result,
    char **name,
    char **dest,
    char **end,
    char *source,
    unsigned *length
    )
{

#define ESCH  '^'

    char *oldString, *newString;
    char *pEq, *pPar, *t;
    char *s;
    unsigned i;

    ++*name;
    for (pEq = *name; *pEq && *pEq != '='; pEq++)
        if (*pEq == ESCH)
            pEq++;

    // Did we find the '=' sign?
    if (*pEq != '=')
        printf("Error1\n");

    // Did the user forget the initial string?
    if (pEq == *name)
        printf("Error2\n");

    for (pPar = pEq; *pPar && *pPar != ')'; pPar++)
        if (*pPar == ESCH)
            pPar++;

    if (*pPar != ')')
        printf("Error3\n");

    oldString = (char *)malloc((UINT)((pEq - *name) + 1));
    if (!oldString) {
        BuildError("(Fatal Error) Out Of Memory: SubstituteString()\n");
        exit(16);
    }
    for (s = oldString, t = *name; *t != '='; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    i = strlen(oldString);
    newString = (char *)malloc((UINT)(pPar - pEq));
    if (!newString) {
        BuildError("(Fatal Error) Out Of Memory: SubstituteString()\n");
        exit(16);
    }
    for (s = newString, t++; *t != ')'; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    *name = pPar + 1;
    while (*source) {
        if ((*source == *oldString)                     // check for match
            && !strncmp(source, oldString, i)) {       // copy new in for
            for (s = newString; *s; *(*dest)++ = *s++)  //  old string
                if (*dest == *end) {
                    *result = realloc(*result, *length + 100);
                    if (!*result) {
                        BuildError("(Fatal Error) Out Of Memory: SubstituteString()\n");
                        exit(16);
                    }
                    *dest = *result + *length;
                    *length += 100;
                    *end = *result + *length;
                }
            source += i;
            continue;
        }
        if (*dest == *end) {
            *result = realloc(*result, *length + 100);
            if (!*result) {
                BuildError("(Fatal Error) Out Of Memory: SubstituteString()\n");
                exit(16);
            }
            *dest = *result + *length;
            *length += 100;
            *end = *result + *length;
        }
        *(*dest)++ = *source++;         // else copy 1 char
    }
    free(oldString);
    free(newString);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeMacroString
//
//  Synopsis:   Take a string, and expand any macros in it.  (e.g.
//              "$(BASEDIR)\foobar\myfile.lib" is expanded to
//              "f:\nt\private\foobar\myfile.lib" if $(BASEDIR) has a value of
//              "f:\nt\private".
//
//  Arguments:  [pp]   -- Output string
//              [psrc] -- Input string
//
//  Returns:
//
//  Notes:      Any previous string value in [pp] is freed before updating it.
//
//----------------------------------------------------------------------------

char MMSBuffer[64*1024];
BOOL
MakeMacroString(LPSTR *pp, LPSTR psrc)
{
    LPSTR pname, p2, pdst, p3;
    int cb;
    char chTerminator;
    int cNameChars;
    int cChars;

    pdst = MMSBuffer;
    cb = strlen(psrc);
    if (cb > sizeof(MMSBuffer) - 1) {
        BuildError(
            "(Fatal Error) Buffer overflow: MakeMacroString(%s)\n",
            psrc);
        exit(16);
    }
    while ((pname = strchr(psrc, '$')) != NULL &&
           ((pname[1] == LPAREN &&
             (p2 = strchr(pname, RPAREN)) != NULL) ||
            (MACRO_CHAR(pname[1]) &&
             !MACRO_CHAR(pname[2])))) {

        LPSTR pszvalue;

        // Handle one-character non-paren macro usage.
        if (pname[1] == LPAREN) {
            // Initialize cNameChars with the number of chars to
            // skip to get to the first name character.
            cNameChars = 2;
        } else {
            p2 = pname + 2;
            cNameChars = 1;
        }

        chTerminator = *p2;
        *pname = *p2 = '\0';

        // copy up to macro name
        cChars = strlen(psrc);
        memcpy(pdst, psrc, cChars + 1);
        psrc += cChars;
        pdst += cChars;

        *pname = '$';
        pname += cNameChars;
        cNameChars += strlen(pname) + (chTerminator == RPAREN ? 1 : 0);

        p3 = NULL;
        if (chTerminator == RPAREN &&
            (p3 = strchr(pname, ':')) != NULL) {
            // macro substitution exists.  ie: $(foo:old=new)
            *p3 = '\0';
        }

        if ((pszvalue = FindMacro(pname)) == NULL &&
            (pszvalue = getenv(pname)) == NULL &&
            (pszvalue = GetBaseDir(pname)) == NULL) {

            pszvalue = "";              // can't find macro name -- ignore it
        }

        if (p3) {
            char *pNew = malloc(10);
            char *pResult = pNew;
            char *pEnd = pNew+10;
            unsigned Len = 10;

            if (!pNew) {
                BuildError("(Fatal Error) Internal buffer overflow: MakeMacroString(%s[%s = %s]%s)\n",
                           MMSBuffer,
                           pname,
                           pszvalue,
                           p2 + 1);
                exit(16);
            }

            *p3 = ':';
            *p2=RPAREN;
            SubstituteString(&pResult, &p3, &pNew, &pEnd, pszvalue, &Len);
            *pNew = '\0';
            *p2='\0';
            pszvalue = pResult;
        }

        cb += strlen(pszvalue) - cNameChars;
        assert(cb >= 0);
        if (cb > sizeof(MMSBuffer) - 1) {
            BuildError(
                "(Fatal Error) Internal buffer overflow: MakeMacroString(%s[%s = %s]%s)\n",
                MMSBuffer,
                pname,
                pszvalue,
                p2 + 1);
            exit(16);
        }
        strcpy(pdst, pszvalue);         // copy expanded value

        if (p3) {
            free(pszvalue);
        }

        pdst += strlen(pdst);
        *p2 = chTerminator;
        psrc += cNameChars;
    }
    strcpy(pdst, psrc);                 // copy rest of string
    if (pdst != MMSBuffer) {
        CompressBlanks(MMSBuffer);
    }
    p2 = *pp;
    *pp = NULL;
    if (MMSBuffer[0] != '\0') {
        MakeString(pp, MMSBuffer, TRUE, MT_DIRSTRING);
    }
    if (p2 != NULL) {
        FreeMem(&p2, MT_DIRSTRING);
    }

    return(MMSBuffer[0] != '\0');
}


//+---------------------------------------------------------------------------
//
//  Function:   SetMacroString
//
//  Synopsis:   If the two macro names are the same, store the value in that
//              macro
//
//  Arguments:  [pMacro1] -- Name of first macro
//              [pMacro2] -- Name of second macro
//              [pValue]  -- Unexpanded value to store.
//              [ppValue] -- Expanded value of macro.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
SetMacroString(LPSTR pMacro1, LPSTR pMacro2, LPSTR pValue, LPSTR *ppValue)
{
    if (_stricmp(pMacro1, pMacro2) == 0) {
        MakeMacroString(ppValue, pValue);
        return(TRUE);   // return TRUE even if MakeMacroString stored a NULL
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SplitToken
//
//  Synopsis:   Split the string at the given separator character or space.
//
//  Arguments:  [pbuf]  -- First part of split string returned here.
//              [chsep] -- Separator character.
//              [ppstr] -- Source string to split.  Becomes the second half.
//
//  Returns:    TRUE if the split was successful.  FALSE if it wasn't split.
//
//  Notes:      If *ppstr = "path\filename" and chsep = '\' on input, then
//              pbuf = "path" and *ppstr = "\filename" on output.
//
//----------------------------------------------------------------------------

BOOL
SplitToken(LPSTR pbuf, char chsep, LPSTR *ppstr)
{
    LPSTR psrc, pdst;

    psrc = *ppstr;
    pdst = pbuf;
    //BuildError("SplitToken('%c', '%s') ==> ", chsep, psrc);
    while (*psrc == chsep || *psrc == ' ') {
        psrc++;
    }
    while (*psrc != '\0' && *psrc != chsep && *psrc != ' ') {
        *pdst = *psrc++;
        if (*pdst == '/') {
            *pdst = '\\';
        }
        pdst++;
    }
    *pdst = '\0';
    *ppstr = psrc;
    //BuildErrorRaw("('%s', '%s')\n", psrc, pbuf);
    return(pdst != pbuf);
}


//+---------------------------------------------------------------------------
//
//  Function:   CrackSources
//
//  Synopsis:   Parse the SOURCES= line in a sources file and adds those source
//              files to the list of sources in the DIRREC struct.
//
//  Arguments:  [pdr] -- Directory record
//              [pds] -- Supplemental directory information
//              [i]   -- Which platform we're parsing
//
//----------------------------------------------------------------------------

VOID
CrackSources(
    DIRREC *pdr,
    DIRSUP *pds,
    int i)

{

    LPSTR pszsubdir, plist;
    LPSTR pszfile, pszpath;
    FILEREC *pfr;
    DIRREC *pdrAssociate;
    DIRREC *pdrParent;
    DIRREC *pdrMachine;
    DIRREC *pdrParentMachine;
    DIRREC *pdrTarget;
    DIRREC **ppdr;
    LPSTR pszSources;
    char path[DB_MAX_PATH_LENGTH];
    TARGET_MACHINE_INFO *pMachine;

    if (i == 0) {
        pMachine = TargetMachines[0];
        pszSources = "SOURCES";

    } else {
        pMachine = PossibleTargetMachines[i - 1];
        pszSources = pMachine->SourceVariable;
    }

    pdrAssociate = pdrParent = pdrMachine = pdrParentMachine = pdrTarget = NULL;
    plist = pds->SourcesVariables[i];
    while (SplitToken(path, ' ', &plist)) {
        UCHAR SubDirMask, SrcFlags;

        SubDirMask = 0;
        ppdr = &pdr;                    // assume current directory
        pszsubdir = path;
        if (pszsubdir[0] == '.' && pszsubdir[1] == '\\') {
            BuildError(
                "%s: Ignoring current directory prefix in %s= entry: %s\n",
                pdr->Name,
                pszSources,
                path);
            pszsubdir += 2;
        }

        if (pszsubdir[0] == '.' &&
            pszsubdir[1] == '.' &&
            pszsubdir[2] == '\\') {

            SubDirMask = TMIDIR_PARENT;
            ppdr = &pdrParent;          // assume parent directory
            pszsubdir += 3;
        }

        pszpath = path;
        pszfile = strchr(pszsubdir, '\\');
        if (pszfile == NULL) {
            pszfile = pszsubdir;

        } else {
            LPSTR pszSecondSlash;
            LPSTR pszAssociateDir;
            LPSTR pszMachineDir;

            // Check for second slash and handle $O\.  If there is
            // no second slash, check for a machine specific directory name.
            // Second slashes are not legal if there's already been
            // a '..'.

            if ((SubDirMask & TMIDIR_PARENT) == 0) {
                pszSecondSlash = strchr(pszfile + 1, '\\');
                if (pszSecondSlash != NULL) {
                    pszfile = pszSecondSlash;
                }

            } else {
                pszSecondSlash = NULL;
            }


            *pszfile = '\0';
            if (pszSecondSlash != NULL) {
                pszMachineDir = pMachine->ObjectDirectory[iObjectDir];
                pszAssociateDir = pszMachineDir;

            } else {
                pszMachineDir = pMachine->SourceDirectory;
                pszAssociateDir = pMachine->AssociateDirectory;
            }

            if (((_stricmp(pszsubdir, pszAssociateDir) != 0) &&
                (_stricmp(pszsubdir, pszMachineDir) != 0)) ||
                strchr(pszfile + 1, '\\') != NULL) {

                *pszfile = '\\';
                BuildError(
                    "%s: Ignoring invalid directory prefix in %s= entry: %s\n",
                    pdr->Name,
                    pszSources,
                    path);

                //

                pszpath = strrchr(path, '\\');
                assert(pszpath != NULL);
                pszpath++;
                SubDirMask = 0;
                ppdr = &pdr;            // default to current direcory

            } else {
                SubDirMask |= pMachine->SourceSubDirMask;
                *pszfile++ = '\\';
                if (SubDirMask & TMIDIR_PARENT) {
                    ppdr = &pdrParentMachine;

                } else if (pszSecondSlash != NULL) {
                    // Must have matched $O.
                    ppdr = &pdrTarget;

                } else {
                    if (_stricmp(pszsubdir, pszMachineDir) != 0) {
                        ppdr = &pdrMachine;

                    } else {
                        ppdr = &pdrAssociate;
                    }
                }
            }
        }

NewDirectory:
        if (*ppdr == NULL) {
            pfr = FindSourceFileDB(pdr, pszpath, ppdr);

        } else {
            pfr = LookupFileDB(*ppdr, pszfile);
        }

        SrcFlags = SOURCEDB_SOURCES_LIST;
        if ((pfr == NULL) && !fPassZero) {
            if (fDebug) {
                BuildError("%s: Missing source file: %s\n", pdr->Name, path);
            }
            if (*ppdr == NULL) {
                if (fDebug || pszpath == path) {
                    BuildError(
                        "%s: Directory does not exist: %s\n",
                        pdr->Name,
                        path);
                }

                // Probably an error in the subordinate sources file.
                // since old versions of build managed to get these entries
                // into the objects lists, we have to do the same...
                //
                // If ..\ prefix exists, strip it off and try again.
                // Else try again with the current directory.

                if (SubDirMask & TMIDIR_PARENT) {
                    SubDirMask &= ~TMIDIR_PARENT;       // strip off "..\\"
                }
                else {
                    SubDirMask = 0;             // use current direcory
                }
                if (SubDirMask == 0) {
                    ppdr = &pdr;                // current direcory
                    pszpath = pszfile;
                }
                else {
                    ppdr = &pdrMachine;         // machine sub dir
                    pszpath = pszsubdir;
                }
                goto NewDirectory;
            }
            pfr = InsertFileDB(*ppdr, pszfile, 0, 0, FILEDB_FILE_MISSING);
            if (pfr == NULL) {
                BuildError(
                    "%s: Ignoring invalid %s= entry: %s\n",
                    pdr->Name,
                    pszSources,
                    path);
            }
        }
        if (pfr != NULL) {
            AssertFile(pfr);
            if (SubDirMask == 0) {
                pfr->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            if (pfr->FileFlags & FILEDB_FILE_MISSING) {
                SrcFlags |= SOURCEDB_FILE_MISSING;
            }
            InsertSourceDB(&pds->psrSourcesList[i], pfr, SubDirMask, SrcFlags);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveUserTests
//
//  Synopsis:   Save the value of the UMTEST macro into the DIRREC struct.
//
//  Arguments:  [DirDB]    -- Dir struct to save into
//              [TextLine] -- String from UMTEST= line in sources file
//
//----------------------------------------------------------------------------

VOID
SaveUserTests(
    PDIRREC DirDB,
    LPSTR TextLine)
{
    UINT i;
    BOOL fSave = FALSE;
    char name[DB_MAX_PATH_LENGTH];
    char buf[512];

    buf[0] = '\0';
    if (DirDB->UserTests != NULL) {
        strcpy(buf, DirDB->UserTests);
    }
    CopyString(TextLine, TextLine, TRUE);
    while (SplitToken(name, '*', &TextLine)) {
        for (i = 0; i < CountOptionalDirs; i++) {
            if (!strcmp(name, OptionalDirs[i])) {
                if (buf[0] != '\0') {
                    strcat(buf, "*");
                    DirDB->DirFlags |= DIRDB_FORCELINK; // multiple targets
                }
                strcat(buf, name);
                fSave = TRUE;
                break;
            }
        }
    }
    if (fSave) {
        MakeMacroString(&DirDB->UserTests, buf);
        DirDB->DirFlags |= DIRDB_LINKNEEDED;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessSourcesFileLine
//
//  Synopsis:   Given a line from a sources file, do the right thing.
//
//  Arguments:  [DirDB]    -- Directory containing sources file
//              [pds]      -- Supplementary info on directory
//              [TextLine] -- Line to process
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void
ProcessSourcesFileLine(
    DIRREC *DirDB,          // Current Directory record
    DIRSUP *pds,            // Supplemental Directory record
    LPSTR TextLine,         // Line to process
    int iTarget             // Index into target machine array.
    )
{
    LPSTR MacroName, p1;
    UINT i, iMacro;
    char path[DB_MAX_PATH_LENGTH];
    BOOL fCleanNTTargetFile0 = FALSE;
    LPSTR pValue;           // right side of equal sign

    pValue = SplitMacro(&TextLine);
    if (pValue == NULL) {
        return;
    }

    // Note: TextLine is now the left side of the equal sign.  See if it's interesting.

    //
    // This sets pds->SourcesVariables[0] to the value of SOURCES= if
    // the current line is SOURCES=...
    //
    if (SetMacroString(
            "SOURCES",
            TextLine,
            pValue,
            &pds->SourcesVariables[0])) {

        DirDB->DirFlags |= DIRDB_SOURCES_SET;
        goto SaveAndFreeMacro;
    }
    else {
        for (i = 0; i < MAX_TARGET_MACHINES; i++) {
            //
            // This sets pds->SourcesVariables[0] to the value of
            // PLAT_SOURCES= if the current line is PLAT_SOURCES=...
            //
            if (SetMacroString(
                    PossibleTargetMachines[i]->SourceVariable,
                    TextLine,
                    pValue,
                    &pds->SourcesVariables[i + 1])) {

                DirDB->DirFlags |= DIRDB_SOURCES_SET;
                goto SaveAndFreeMacro;
            }
        }
    }

    // Not a SOURCES or xxx_SOURCES macro, check against all the other interesting
    // macro names.

    iMacro = 0;

    while ((MacroName = RelevantSourcesMacros[iMacro]) != NULL) {
        if (_stricmp(TextLine, MacroName) == 0) {
            break;
        }
        iMacro++;
    }
    if (MacroName != NULL) {    // if macro name found in list
        switch (iMacro) {
            case SOURCES_TARGETNAME:
                MakeMacroString(&DirDB->TargetName, pValue);
                break;

            case SOURCES_TARGETPATH:
                if (strcmp(pValue, "obj") == 0) {
                    pValue = pszObjDir;
                }
                MakeMacroString(&DirDB->TargetPath, pValue);
                if (DirDB->TargetPath != NULL) {
                    CreateBuildDirectory(DirDB->TargetPath);
                    for (i = 0; i < CountTargetMachines; i++) {
                        p1 = TargetMachines[i]->ObjectDirectory[iObjectDir];
                        assert(strncmp(pszObjDirSlash, p1, strlen(pszObjDirSlash)) == 0);
                        p1 += strlen(pszObjDirSlash);
                        sprintf(path, "%s\\%s", DirDB->TargetPath, p1);
                        CreateBuildDirectory(path);
                    }
                }
                break;

            case SOURCES_TARGETPATHLIB:
                if (strcmp(pValue, "obj") == 0) {
                    pValue = pszObjDir;
                }
                MakeMacroString(&DirDB->TargetPathLib, pValue);
                if (DirDB->TargetPathLib != NULL) {
                    CreateBuildDirectory(DirDB->TargetPathLib);
                    for (i = 0; i < CountTargetMachines; i++) {
                        p1 = TargetMachines[i]->ObjectDirectory[iObjectDir];
                        assert(strncmp(pszObjDirSlash, p1, strlen(pszObjDirSlash)) == 0);
                        p1 += strlen(pszObjDirSlash);
                        sprintf(path, "%s\\%s", DirDB->TargetPathLib, p1);
                        CreateBuildDirectory(path);
                    }
                }
                break;

            case SOURCES_TARGETTYPE:
                if (!_stricmp(pValue, "PROGRAM") || !_stricmp(pValue, "PROGLIB")) {
                    MakeMacroString(&DirDB->TargetExt, ".exe");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "OBJLIB")) {
                    MakeMacroString(&DirDB->TargetExt, ".olb");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "DRIVER") || !_stricmp(pValue, "MINIPORT")) {
                    MakeMacroString(&DirDB->TargetExt, ".sys");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "GDI_DRIVER")) {
                    MakeMacroString(&DirDB->TargetExt, ".dll");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "EXPORT_DRIVER")) {
                    MakeMacroString(&DirDB->TargetExt, ".sys");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                    DirDB->DirFlags |= DIRDB_DLLTARGET;
                } else if (!_stricmp(pValue, "DYNLINK") || !_stricmp(pValue, "HAL")) {
                    MakeMacroString(&DirDB->TargetExt, ".dll");
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                    DirDB->DirFlags |= DIRDB_DLLTARGET;
                } else if ((!_stricmp(pValue, "LIBRARY")) || (!_stricmp(pValue, "DRIVER_LIBRARY"))) {
                    MakeMacroString(&DirDB->TargetExt, ".lib");
                    DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "UMAPPL_NOLIB")) {
                    DirDB->DirFlags &= ~DIRDB_LINKNEEDED;
                } else if (!_stricmp(pValue, "NOTARGET")) {
                    //
                    // Used to indicate no target for a directory,
                    // e.g. if only pass0 files are generated
                    pds->fNoTarget = TRUE;
                    if (!fQuicky || (fQuickZero && fFirstScan)) {
                        DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                    }
                } else {
                    BuildError( "Unsupported TARGETTYPE value - %s\n", pValue);
                }
                break;

            case SOURCES_TARGETEXT:
                {
                    char TargetExt[_MAX_EXT] = ".";
                    strcat(TargetExt, pValue);
                    MakeMacroString(&DirDB->TargetExt, TargetExt);
                }
                break;

            case SOURCES_INCLUDES:
                MakeMacroString(&pds->LocalIncludePath, pValue);
                if (DEBUG_1) {
                    BuildMsg(
                        "        Found local INCLUDES=%s\n",
                        pds->LocalIncludePath);
                }
                break;

            case SOURCES_MFC_INCLUDES:
                // MFC_INCLUDES/SDK_INC/CRT_INC/OAK_INC really can't be changed
                // in the sources file (yet) since we've already processed the
                // system includes.  Lay the groundwork for now.
                MakeMacroString((char **)&pszIncMfc, pValue);
                break;

            case SOURCES_SDK_LIB_DEST:
                MakeMacroString((char **)&pszSdkLibDest, pValue);
                break;

            case SOURCES_DDK_LIB_DEST:
                MakeMacroString((char **)&pszDdkLibDest, pValue);
                break;

            case SOURCES_SDK_INC_PATH:
                MakeMacroString((char **)&pszIncSdk, pValue);
                break;

            case SOURCES_CRT_INC_PATH:
                MakeMacroString((char **)&pszIncCrt, pValue);
                break;

            case SOURCES_OAK_INC_PATH:
                MakeMacroString((char **)&pszIncOak, pValue);
                break;

            case SOURCES_DDK_INC_PATH:
                MakeMacroString((char **)&pszIncDdk, pValue);
                break;

            case SOURCES_WDM_INC_PATH:
                MakeMacroString((char **)&pszIncWdm, pValue);
                break;

            case SOURCES_PRIVATE_INC_PATH:
                MakeMacroString((char **)&pszIncPri, pValue);
                break;

            case SOURCES_PRECOMPILED_PCH:
                MakeMacroString(&DirDB->Pch, pValue);
                break;

            case SOURCES_PRECOMPILED_OBJ:
                MakeMacroString(&DirDB->PchObj, pValue);
                break;

            case SOURCES_PRECOMPILED_INCLUDE:
            case SOURCES_PRECOMPILED_TARGET:
                {
                    LPSTR *ppszPath, *ppszFile, p;
                    if (iMacro == SOURCES_PRECOMPILED_INCLUDE) {
                        ppszPath = &pds->PchIncludeDir;
                        ppszFile = &pds->PchInclude;
                    } else {
                        ppszPath = &pds->PchTargetDir;
                        ppszFile = &pds->PchTarget;
                    }

                    MakeMacroString(ppszPath, "");  // free old string
                    if (!MakeMacroString(ppszFile, pValue)) {
                        break;
                    }
                    p = *ppszFile + strlen(*ppszFile);
                    while (p > *ppszFile && *--p != '\\')
                        ;

                    if (p > *ppszFile) {
                        *p = '\0';
                        MakeMacroString(ppszPath, *ppszFile);
                        MakeMacroString(ppszFile, p + 1);
                    }

                    if (DEBUG_1) {
                        BuildMsg(
                            "Precompiled header%s is %s in directory %s\n",
                            iMacro == SOURCES_PRECOMPILED_INCLUDE?
                                "" : " target",
                            *ppszFile,
                            *ppszPath != NULL?
                                *ppszPath : "'.'");
                    }
                }

                if (iMacro == SOURCES_PRECOMPILED_INCLUDE ||
                    pds->PchTargetDir == NULL) {

                    break;
                }

                EnsureDirectoriesExist(pds->PchTargetDir);
                break;

            case SOURCES_PASS0_HEADERDIR:
                MakeMacroString(&pds->PassZeroHdrDir, pValue);
                EnsureDirectoriesExist(pds->PassZeroHdrDir);
                if (DEBUG_1)
                {
                    BuildMsg("Pass Zero Header Directory is '%s'\n",
                             pds->PassZeroHdrDir);
                }
                break;

            case SOURCES_PASS0_SOURCEDIR:
            case SOURCES_PASS0_CLIENTDIR:
                // SOURCES_PASS0_SOURCEDIR and SOURCES_PASS0_CLIENTDIR
                // are mutually exclusive - enforced by makefile.def
                MakeMacroString(&pds->PassZeroSrcDir1, pValue);
                EnsureDirectoriesExist(pds->PassZeroSrcDir1);
                if (DEBUG_1)
                {
                    BuildMsg("Pass Zero Source/Client Directory is '%s'\n",
                             pds->PassZeroSrcDir1);
                }
                break;

            case SOURCES_MIDL_UUIDDIR:
            case SOURCES_PASS0_SERVERDIR:
                // SOURCES_MIDL_UUIDDIR and SOURCES_PASS0_SERVERDIR
                // are mutually exclusive - enforced by makefile.def
                MakeMacroString(&pds->PassZeroSrcDir2, pValue);
                EnsureDirectoriesExist(pds->PassZeroSrcDir2);
                if (DEBUG_1)
                {
                    BuildMsg("Midl UUID/Server Source Directory is '%s'\n",
                             pds->PassZeroSrcDir2);
                }
                break;

            case SOURCES_NTTEST:
                if (MakeMacroString(&DirDB->KernelTest, pValue)) {
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                }
                break;

            case SOURCES_UMTYPE:
                MakeMacroString(&pds->TestType, pValue);
                if (DEBUG_1) {
                    BuildMsg(
                        "        Found UMTYPE=%s\n",
                        pds->TestType);
                    }
                break;

            case SOURCES_UMTEST:
            case SOURCES_OPTIONAL_UMTEST:
                SaveUserTests(DirDB, pValue);
                break;

            case SOURCES_UMAPPL:
                if (MakeMacroString(&DirDB->UserAppls, pValue)) {
                    DirDB->DirFlags |= DIRDB_LINKNEEDED;
                }
                break;

            case SOURCES_UMAPPLEXT:
                if (!_stricmp(pValue, ".exe")) {
                    MakeMacroString(&DirDB->TargetExt, ".exe");
                    }
                else
                if (!_stricmp(pValue, ".com")) {
                    MakeMacroString(&DirDB->TargetExt, ".com");
                    }
                else
                if (!_stricmp(pValue, ".scr")) {
                    MakeMacroString(&DirDB->TargetExt, ".scr");
                    }
                else {
                    BuildError(
                        "Unsupported UMAPPLEXT value - %s\n",
                        pValue);
                }
                break;

            case SOURCES_IDLTYPE:
                if (!_stricmp(pValue, "ole")) {
                    pds->IdlType = 0;
                    }
                else
                if (!_stricmp(pValue, "rpc")) {
                    pds->IdlType = 1;
                    }
                else {
                    BuildError(
                        "Unsupported IDL_TYPE value - %s\n",
                        pValue);
                }
                break;

            case SOURCES_SOURCES_OPTIONS:
                fCleanNTTargetFile0 = fClean && strstr(pValue, "-c0");
                break;

            case SOURCES_NTTARGETFILE0:
                DirDB->DirFlags |= DIRDB_TARGETFILE0;
                if (fCleanNTTargetFile0) {
                    MakeMacroString(&DirDB->NTTargetFile0, pValue);
                }
                break;

            case SOURCES_NTTARGETFILES:
                DirDB->DirFlags |= DIRDB_TARGETFILES;
                break;

            case SOURCES_CHICAGO_PRODUCT:
                DirDB->DirFlags |= DIRDB_CHICAGO_INCLUDES;
                break;

            case SOURCES_CONDITIONAL_INCLUDES:
                MakeMacroString(&pds->ConditionalIncludes, pValue);
                break;

            case SOURCES_SYNCHRONIZE_BLOCK:
                DirDB->DirFlags |= DIRDB_SYNCHRONIZE_BLOCK;
                break;

            case SOURCES_SYNCHRONIZE_DRAIN:
                DirDB->DirFlags |= DIRDB_SYNCHRONIZE_DRAIN;
                break;

            case SOURCES_CHECKED_ALT_DIR:
                DirDB->DirFlags |= DIRDB_CHECKED_ALT_DIR;
                if (DEBUG_1) {
                    BuildMsg("Found CHECKED_ALT_DIR\n");
                }
                SetObjDir(TRUE);
                if (fCheckedBuild) {
                    SaveMacro("_OBJ_DIR", pszObjDir);
                    if (iTarget < 0) {
                        SaveMacro("O", TargetMachines[0]->
                                  ObjectDirectory[iObjectDir]);
                    } else {
                        SaveMacro("O",
                                  PossibleTargetMachines[iTarget/2]->
                                  ObjectDirectory[iObjectDir]);
                    }
                }
                break;

            case SOURCES_PROJECT_NAME:
                sprintf(path, "%s\\%s", NtRoot, pValue);
                SaveMacro("PROJECT_ROOT", path);
                break;

            case SOURCES_PASS0_PUBLISH:
                DirDB->DirFlags |= DIRDB_PASS0NEEDED;
                break;
        }
    }

SaveAndFreeMacro:
    SaveMacro(TextLine, pValue);

    // Make sure we cleanup from the SplitMacro call at the top.
    FreeString(&TextLine, MT_DIRSTRING);
}

void
ReadProjectsInfo(
    DIRREC *DirDB,
    DIRSUP *pds
    )
{
    FILE *FileHandle;
    LPSTR TextLine, pBackSlash, pszProject;
    BOOL Found;

    char pszProjectMkPath[DB_MAX_PATH_LENGTH];
    char path[DB_MAX_PATH_LENGTH];

    // First load project.mk for this project.

    strcpy(pszProjectMkPath, DirDB->Name);
    strcpy(path, pszProjectMkPath);
    strcat(path, "\\project.mk");
    Found = !_access(path, 0);
    while (!Found && strlen(pszProjectMkPath))
    {
        pBackSlash=strrchr(pszProjectMkPath, '\\');
        if (pBackSlash) {
            *pBackSlash = '\0';
        } else {
            return;
        }
        strcpy(path, pszProjectMkPath);
        strcat(path, "\\project.mk");
        Found = !_access(path, 0);
    }

    if (!Found) {
        return;
    }

    if (!OpenFilePush(pszProjectMkPath, "project.mk", "#", &FileHandle)) {
        return;
    }

    SaveMacro("_PROJECT_MK_PATH", pszProjectMkPath);
    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        ProcessSourcesFileLine(DirDB, pds, TextLine, -1);
    }
    CloseReadFile(NULL);

    // Load the optional myproject.mk

    if (OpenFilePush(pszProjectMkPath, "myproject.mk", "#", &FileHandle)) {

        while ((TextLine = ReadLine(FileHandle)) != NULL) {
            ProcessSourcesFileLine(DirDB, pds, TextLine, -1);
        }
        CloseReadFile(NULL);
    }

    // Then load ntmakeenv\projects.inc to get the other magic macro names.

    if (!OpenFilePush(getenv("NTMAKEENV"), "projects.inc", "#", &FileHandle)) {
        return;
    }

    while ((TextLine = ReadLine(FileHandle)) != NULL) {
        ProcessSourcesFileLine(DirDB, pds, TextLine, -1);
    }
    CloseReadFile(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadSourcesFile
//
//  Synopsis:   Parses the sources files (common and platform specific)
//
//  Arguments:  [DirDB]            -- Directory containing sources file
//              [pds]              -- Supplementary info on directory
//              [pDateTimeSources] -- Timestamp of Sources file
//
//  Returns:    TRUE if read successfully
//
//----------------------------------------------------------------------------

BOOL
ReadSourcesFile(DIRREC *DirDB, DIRSUP *pds, ULONG *pDateTimeSources)
{
    FILE *InFileHandle;
    LPSTR p, TextLine;
    UINT i;
    int iTarget;
    ULONG DateTime;
    char path[DB_MAX_PATH_LENGTH];

    memset(pds, 0, sizeof(*pds));
    pds->fNoTarget=FALSE;
    assert(DirDB->TargetPath == NULL);
    assert(DirDB->TargetPathLib == NULL);
    assert(DirDB->TargetName == NULL);
    assert(DirDB->TargetExt == NULL);
    assert(DirDB->KernelTest == NULL);
    assert(DirDB->UserAppls == NULL);
    assert(DirDB->UserTests == NULL);
    assert(DirDB->NTTargetFile0 == NULL);
    assert(DirDB->Pch == NULL);
    assert(DirDB->PchObj == NULL);
    assert(cMacro == 0);
    *pDateTimeSources = 0;

    //
    // Read the information in each of the target specific directories
    // and simulate concatenation of all of the sources files.
    //
    // Possible sources files are read from DirDB->Name | target-source
    // and DirDb->Name | ..\target-source.
    //
    // iTarget values, and the corresponding files processed are:
    //  -1      sources.
    //   0      PossibleTargetMachines[0]\sources.
    //   1      ..\PossibleTargetMachines[0]\sources.
    //   2      PossibleTargetMachines[1]\sources.
    //   3      ..\PossibleTargetMachines[1]\sources.
    //   4      PossibleTargetMachines[2]\sources.
    //   5      ..\PossibleTargetMachines[2]\sources.

    SaveMacro("MAKEDIR", DirDB->Name);
    SaveMacro("SDK_LIB_DEST", pszSdkLibDest);
    SaveMacro("DDK_LIB_DEST", pszDdkLibDest);
    SaveMacro("PUBLIC_INTERNAL_PATH", pszPublicInternalPath);
    // Use the default architecture for now
    SaveMacro("TARGET_DIRECTORY", TargetMachines[0]->SourceDirectory);

    SetObjDir(FALSE);
    SaveMacro("_OBJ_DIR", pszObjDir);
    // Define a default CONDITIONAL_INCLUDES line to deal with the mac hdrs in windows/rpc/ole32.h.
    MakeMacroString(&pds->ConditionalIncludes, "winwlm.h rpcmac.h rpcerr.h macpub.h macapi.h macname1.h macname2.h");

    // Before processing the sources file, see if there's a projects.mk in the tree.
    ReadProjectsInfo(DirDB, pds);

    for (iTarget = -1; iTarget < 2*MAX_TARGET_MACHINES; iTarget++) {
        path[0] = '\0';
        if (iTarget >= 0) {
            if (iTarget & 1) {
                strcat(path, "..\\");
            }
            strcat(path, PossibleTargetMachines[iTarget/2]->SourceDirectory);
            strcat(path, "\\");
        }
        strcat(path, "sources.");
        if (!OpenFilePush(DirDB->Name, path, "#", &InFileHandle)) {
            if (iTarget == -1) {
                FreeMacros();
                return(FALSE);
            }
            continue;           // skip non-existent subordinate sources files
        }
        if (DEBUG_1) {
            BuildMsg(
                "    Scanning%s file %s\n",
                iTarget >= 0 ? " subordinate" : "",
                FormatPathName(DirDB->Name, path));
        }

        // Update per-target macros.
        if (iTarget < 0) {
            SaveMacro("TARGET_DIRECTORY",
                      TargetMachines[0]->SourceDirectory);
            SaveMacro("O", TargetMachines[0]->
                      ObjectDirectory[iObjectDir]);
        } else {
            SaveMacro("TARGET_DIRECTORY",
                      PossibleTargetMachines[iTarget/2]->SourceDirectory);
            SaveMacro("O", PossibleTargetMachines[iTarget/2]->
                      ObjectDirectory[iObjectDir]);
        }

        DirDB->DirFlags |= DIRDB_SOURCESREAD;

        while ((TextLine = ReadLine(InFileHandle)) != NULL) {
            ProcessSourcesFileLine(DirDB, pds, TextLine, iTarget);
        }

        // Subordinate files close themselves at EOF.  Timestamps
        // are propagated in CloseReadFile so the primary
        // file's timestamp is automatically updated.
    }

    // Close the primary file.
    DateTime = CloseReadFile(NULL);
    if (*pDateTimeSources < DateTime) {
        *pDateTimeSources = DateTime;       // keep newest timestamp
    }

    if (!pds->fNoTarget && (DirDB->TargetPath == NULL)) {
        strcpy(path, "sources.");
        SetupReadFile(DirDB->Name, path, "#", &InFileHandle);
        BuildError(
            "Unknown TARGETPATH value\n",
            NULL);
        CloseReadFile(NULL);
    }

    FreeMacros();

    if (fChicagoProduct) {
        DirDB->DirFlags |= DIRDB_CHICAGO_INCLUDES;
    }

    //
    // Directory has pass0 files in it (.idl, .mc, .asn, etc), check to make
    // sure they specified where the generated files should go.  Default to the
    // obj subdirectories if they didn't.  These always need to be non-null.
    //
    if (!pds->PassZeroHdrDir) {
        MakeString(&pds->PassZeroHdrDir, ".", TRUE, MT_DIRSTRING);
    }

    if (!pds->PassZeroSrcDir1) {
        MakeString(&pds->PassZeroSrcDir1, ".", TRUE, MT_DIRSTRING);
    }

    if (!pds->PassZeroSrcDir2)
        MakeString(&pds->PassZeroSrcDir2, pds->PassZeroSrcDir1, TRUE, MT_DIRSTRING);

    if (DirDB->UserTests != NULL) {
        _strlwr(DirDB->UserTests);
    }
    if (DirDB->UserAppls != NULL) {
        if (DirDB->UserTests != NULL || strchr(DirDB->UserAppls, '*') != NULL) {
            DirDB->DirFlags |= DIRDB_FORCELINK; // multiple targets
        }
    }

    PostProcessSources(DirDB, pds);

    if (DEBUG_1) {
        PrintDirDB(DirDB, 1|2);
        PrintDirSupData(pds);
        PrintDirDB(DirDB, 4);
    }

    pds->DateTimeSources = *pDateTimeSources;

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   PostProcessSources
//
//  Synopsis:   Scan the files in the given directory and add files to the
//              directory's list of source files (SOURCEREC), including PCH
//              files, UMTEST files, etc.
//
//  Arguments:  [pdr] -- Directory to process
//              [pds] -- Directory supplemental information
//
//----------------------------------------------------------------------------

void
PostProcessSources(DIRREC *pdr, DIRSUP *pds)
{
    PFILEREC FileDB, *FileDBNext;
    char path[DB_MAX_PATH_LENGTH];
    LPSTR p, p1;
    UINT i;

    for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            CrackSources(pdr, pds, i);
        }
    }

    FileDBNext = &pdr->Files;
    while (FileDB = *FileDBNext) {

        if (pds->PchInclude && strcmp(FileDB->Name, pds->PchInclude) == 0) {
            InsertSourceDB(&pds->psrSourcesList[0], FileDB, 0, SOURCEDB_PCH);
            if (DEBUG_1) {
                BuildMsg("Adding PCH file to Sources List: %s.\n", FileDB->Name);
            }
        }

        if ((FileDB->FileFlags & (FILEDB_SOURCE | FILEDB_OBJECTS_LIST)) ==
            FILEDB_SOURCE) {

            p = FileDB->Name;
            p1 = path;
            while (*p != '\0' && *p != '.') {
                *p1++ = *p++;
            }
            *p1 = '\0';
            _strlwr(path);
            if (pdr->KernelTest != NULL &&
                !strcmp(path, pdr->KernelTest)) {

                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            else
            if (pdr->UserAppls != NULL &&
                (p = strstr(pdr->UserAppls, path)) &&
                (p == pdr->UserAppls || p[-1] == '*' || p[-1] == ' ')) {
                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            else
            if (pdr->UserTests != NULL &&
                (p = strstr(pdr->UserTests, path)) &&
                (p == pdr->UserTests || p[-1] == '*' || p[-1] == ' ')) {

                FileDB->FileFlags |= FILEDB_OBJECTS_LIST;
            }
            if (FileDB->FileFlags & FILEDB_OBJECTS_LIST) {
                InsertSourceDB(&pds->psrSourcesList[0], FileDB, 0, 0);
            }
        }
        FileDBNext = &FileDB->Next;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadDirsFile
//
//  Synopsis:   Parse the DIRS file
//
//  Arguments:  [DirDB] -- Directory to look in
//
//  Returns:    TRUE if parsed
//
//  Notes:      The existence of a file named 'mydirs' or the name of the
//              target specific dirs will override the normal 'dirs' file.
//
//----------------------------------------------------------------------------

BOOL
ReadDirsFile(
    PDIRREC DirDB
    )

{
    FILE *InFileHandle;
    LPSTR TextLine, pValue;
    LPSTR apszDirs[] = { "mydirs.", NULL, "dirs.", NULL };
    CHAR TargetName[16];

    strcpy(&TargetName[0], pszTargetDirs);
    strcat(&TargetName[0], ".");
    apszDirs[1] = &TargetName[0];

    for (ppCurrentDirsFileName = apszDirs;
         *ppCurrentDirsFileName != NULL;
         ppCurrentDirsFileName++) {
        if (SetupReadFile(DirDB->Name, *ppCurrentDirsFileName, "#", &InFileHandle)) {
            break;
        }
    }

    if (*ppCurrentDirsFileName == NULL) {
        FreeMacros();
        return(FALSE);
    }

    if (fFirstScan && (ppCurrentDirsFileName <= &apszDirs[1])) {
        BuildMsg("Using .\\%s instead of DIRS...\n",
                 FormatPathName(DirDB->Name, *ppCurrentDirsFileName));
    }

    if (DEBUG_1) {
        BuildMsg(
            "    Scanning file %s\n",
            FormatPathName(DirDB->Name, *ppCurrentDirsFileName));
    }

    assert(cMacro == 0);
    while ((TextLine = ReadLine(InFileHandle)) != NULL) {
        if ((pValue = SplitMacro(&TextLine)) != NULL) {
            SaveMacro(TextLine, pValue);
            FreeString(&TextLine, MT_DIRSTRING);
        }
    }
    CloseReadFile(NULL);
    if ((pValue = FindMacro("DIRS")) != NULL) {
        MarkDirNames(DirDB, pValue, TRUE);
    }
    if ((pValue = FindMacro("OPTIONAL_DIRS")) != NULL) {
        MarkDirNames(DirDB, pValue, BuildAllOptionalDirs);
    }
    if ((FindMacro("SYNCHRONIZE_DRAIN")) != NULL) {
        DirDB->DirFlags |= DIRDB_SYNCHRONIZE_DRAIN;
    }
    FreeMacros();
    return( TRUE );
}


//
// Debugging and Utility Functions
//

VOID
PrintDirSupData(DIRSUP *pds)
{
    int i;

    if (pds->LocalIncludePath != NULL) {
        BuildMsgRaw("  LocalIncludePath: %s\n", pds->LocalIncludePath);
    }
    if (pds->TestType != NULL) {
        BuildMsgRaw("  TestType: %s\n", pds->TestType);
    }
    if (pds->PchIncludeDir != NULL) {
        BuildMsgRaw("  PchIncludeDir: %s\n", pds->PchIncludeDir);
    }
    if (pds->PchInclude != NULL) {
        BuildMsgRaw("  PchInclude: %s\n", pds->PchInclude);
    }
    if (pds->PchTargetDir != NULL) {
        BuildMsgRaw("  PchTargetDir: %s\n", pds->PchTargetDir);
    }
    if (pds->PchTarget != NULL) {
        BuildMsgRaw("  PchTarget: %s\n", pds->PchTarget);
    }
    if (pds->ConditionalIncludes != NULL) {
        BuildMsgRaw("  ConditionalIncludes: %s\n", pds->ConditionalIncludes);
    }
    for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            BuildMsgRaw(
                "  SourcesVariables[%d]: %s\n",
                i,
                pds->SourcesVariables[i]);
        }
        if (pds->psrSourcesList[i] != NULL) {
            BuildMsgRaw("  SourcesList[%d]:\n", i);
            PrintSourceDBList(pds->psrSourcesList[i], i - 1);
        }
    }
}


VOID
FreeDirSupData(DIRSUP *pds)
{
    int i;

    if (pds->LocalIncludePath != NULL) {
        FreeMem(&pds->LocalIncludePath, MT_DIRSTRING);
    }
    if (pds->TestType != NULL) {
        FreeMem(&pds->TestType, MT_DIRSTRING);
    }
    if (pds->PchInclude != NULL) {
        FreeMem(&pds->PchInclude, MT_DIRSTRING);
    }
    if (pds->PchIncludeDir != NULL) {
        FreeMem(&pds->PchIncludeDir, MT_DIRSTRING);
    }
    if (pds->PchTargetDir != NULL) {
        FreeMem(&pds->PchTargetDir, MT_DIRSTRING);
    }
    if (pds->PchTarget != NULL) {
        FreeMem(&pds->PchTarget, MT_DIRSTRING);
    }
    if (pds->ConditionalIncludes != NULL) {
        FreeMem(&pds->ConditionalIncludes, MT_DIRSTRING);
    }
    if (pds->PassZeroHdrDir != NULL) {
        FreeMem(&pds->PassZeroHdrDir, MT_DIRSTRING);
    }
    if (pds->PassZeroSrcDir1 != NULL) {
        FreeMem(&pds->PassZeroSrcDir1, MT_DIRSTRING);
    }
    if (pds->PassZeroSrcDir2 != NULL) {
        FreeMem(&pds->PassZeroSrcDir2, MT_DIRSTRING);
    }
    for (i = 0; i < MAX_TARGET_MACHINES + 1; i++) {
        if (pds->SourcesVariables[i] != NULL) {
            FreeMem(&pds->SourcesVariables[i], MT_DIRSTRING);
        }
        while (pds->psrSourcesList[i] != NULL) {
            FreeSourceDB(&pds->psrSourcesList[i]);
        }
    }
}


VOID
FreeDirData(DIRREC *pdr)
{
    if (pdr->TargetPath != NULL) {
        FreeMem(&pdr->TargetPath, MT_DIRSTRING);
    }
    if (pdr->TargetPathLib != NULL) {
        FreeMem(&pdr->TargetPathLib, MT_DIRSTRING);
    }
    if (pdr->TargetName != NULL) {
        FreeMem(&pdr->TargetName, MT_DIRSTRING);
    }
    if (pdr->TargetExt != NULL) {
        FreeMem(&pdr->TargetExt, MT_DIRSTRING);
    }
    if (pdr->KernelTest != NULL) {
        FreeMem(&pdr->KernelTest, MT_DIRSTRING);
    }
    if (pdr->UserAppls != NULL) {
        FreeMem(&pdr->UserAppls, MT_DIRSTRING);
    }
    if (pdr->UserTests != NULL) {
        FreeMem(&pdr->UserTests, MT_DIRSTRING);
    }
    if (pdr->NTTargetFile0 != NULL) {
        FreeMem(&pdr->NTTargetFile0, MT_DIRSTRING);
    }
    if (pdr->Pch != NULL) {
        FreeMem(&pdr->Pch, MT_DIRSTRING);
    }
    if (pdr->PchObj != NULL) {
        FreeMem(&pdr->PchObj, MT_DIRSTRING);
    }
    if (pdr->pds != NULL) {
        FreeDirSupData(pdr->pds);
        FreeMem(&pdr->pds, MT_DIRSUP);
        pdr->pds = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MarkDirNames
//
//  Synopsis:   Parses a DIRS= or OPTIONAL_DIRS line and marks the directories
//              appropriately.
//
//  Arguments:  [DirDB]    -- Directory containing DIRS file
//              [TextLine] -- DIRS= or OPTIONAL_DIRS= line
//              [Required] -- Indicates if directories are optional or not.
//
//----------------------------------------------------------------------------

VOID
MarkDirNames(PDIRREC DirDB, LPSTR TextLine, BOOL Required)
{
    UINT i;
    LPSTR p, token;
    PFILEREC FileDB, *FileDBNext;
    char dirbuf[DB_MAX_PATH_LENGTH];
    ULONG DirInclude;

    AssertPathString(TextLine);
    while (SplitToken(dirbuf, '*', &TextLine)) {
        // Assume all platforms are included for this dir.
        DirInclude = DIR_INCLUDE_ALL;
        for (p = dirbuf; *p != '\0'; p++) {
            if ( dirbuf != p && *p == '{' ) {
                // An explicit include path was listed.
                DirInclude = DIR_INCLUDE_NONE;
                *p = '\0';
                token = strtok(p+1, ",}");
                while (token) {
                    if (!_stricmp(token, "X86") ||
                        !_stricmp(token, "I386") ||
                        !_stricmp(token, "386"))
                    {
                        DirInclude |= DIR_INCLUDE_X86;
                    } else if (!_stricmp(token, "32") ||
                               !_stricmp(token, "Win32"))
                    {
                        DirInclude |= DIR_INCLUDE_WIN32;
                    } else if (!_stricmp(token, "64") ||
                               !_stricmp(token, "Win64"))
                    {
                        DirInclude |= DIR_INCLUDE_WIN64;
                    } else if (!_stricmp(token, "IA64")) {
                        DirInclude |= DIR_INCLUDE_IA64;
                    } else if (!_stricmp(token, "AMD64")) {
                        DirInclude |= DIR_INCLUDE_AMD64;
                    } else if (!_stricmp(token, "RISC")) {
                        DirInclude |= DIR_INCLUDE_RISC;
                    }
                    token = strtok(NULL, ",}");
                }
                break;
            } else {
                if (!iscsym(*p) && *p != '.' && *p != '-' ) {
                    BuildError(
                        "%s: ignoring bad subdirectory: %s\n",
                        DirDB->Name,
                        dirbuf);
                    p = NULL;
                    break;
                }
            }
        }

        if (!(DirInclude & TargetMachines[0]->DirIncludeMask)) {
            continue;
        }

        if (p != NULL) {
            if (!Required) {
                for (i = 0; i < CountOptionalDirs; i++) {
                    if (!strcmp(dirbuf, OptionalDirs[i])) {
                        OptionalDirsUsed[i] = TRUE;
                        break;
                    }
                }
                if (i >= CountOptionalDirs) {
                    p = NULL;
                }
            }
            else {
                for (i = 0; i < CountExcludeDirs; i++) {
                    if (!strcmp(dirbuf, ExcludeDirs[i])) {
                        ExcludeDirsUsed[i] = TRUE;
                        p = NULL;
                        break;
                    }
                }
            }
        }
        if (p != NULL) {
            if ((fQuicky || fSemiQuicky) && (!fQuickZero)) {
                FileDB = InsertFileDB(
                            DirDB,
                            dirbuf,
                            0,
                            FILE_ATTRIBUTE_DIRECTORY,
                            0);
                if (FileDB != NULL) {
                    FileDB->SubDirIndex = ++DirDB->CountSubDirs;
                }
            }
            else {
                FileDBNext = &DirDB->Files;
                while (FileDB = *FileDBNext) {
                    if (FileDB->FileFlags & FILEDB_DIR) {
                        if (!strcmp(dirbuf, FileDB->Name)) {
                            FileDB->SubDirIndex = ++DirDB->CountSubDirs;
                            break;
                        }
                    }
                    FileDBNext = &FileDB->Next;
                }
                if (FileDB == NULL) {
                    BuildError(
                        "%s found in %s, is not a subdirectory of %s\n",
                        dirbuf,
                        FormatPathName(DirDB->Name, *ppCurrentDirsFileName),
                        DirDB->Name);
                }
            }

        }
    }
}


VOID
StartElapsedTime(VOID)
{
    if (fPrintElapsed && StartTime == 0) {
        StartTime = GetTickCount();
    }
}


VOID
PrintElapsedTime(VOID)
{
    DWORD ElapsedTime;
    DWORD ElapsedHours;
    DWORD ElapsedMinutes;
    DWORD ElapsedSeconds;
    DWORD ElapsedMilliseconds;

    if (fPrintElapsed) {
        ElapsedTime = GetTickCount() - StartTime;
        ElapsedHours = ElapsedTime/(1000 * 60 * 60);
        ElapsedTime = ElapsedTime % (1000 * 60 * 60);
        ElapsedMinutes = ElapsedTime/(1000 * 60);
        ElapsedTime = ElapsedTime % (1000 * 60);
        ElapsedSeconds = ElapsedTime/1000;
        ElapsedMilliseconds = ElapsedTime % 1000;
        BuildMsg(
            "Elapsed time [%d:%02d:%02d.%03d]\n",
            ElapsedHours,
            ElapsedMinutes,
            ElapsedSeconds,
            ElapsedMilliseconds);
        LogMsg(
            "Elapsed time [%d:%02d:%02d.%03d]%s\n",
            ElapsedHours,
            ElapsedMinutes,
            ElapsedSeconds,
            ElapsedMilliseconds,
            szAsterisks);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\makefile.inc ===
build.c : $(SDK_INC_PATH)\ntverp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildscr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       buildscr.cpp
//
//  Contents:   Implementation of the code which talks to the MTScript engine
//              when doing a distributed build using the build console.
//
//----------------------------------------------------------------------------

#include "scrproc.h"

#include "build.h"
#include "buildscr.h"

#define INITGUID
#include <guiddef.h>

DEFINE_GUID(CLSID_LocalScriptedProcess, 0x854c316f,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);
DEFINE_GUID(IID_IScriptedProcess, 0x854c3171,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);
DEFINE_GUID(IID_IScriptedProcessSink, 0x854c3172,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);

DEFINE_GUID(CLSID_ObjectDaemon,0x854c3184,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xE4,0x39,0x1b);
DEFINE_GUID(IID_IConnectedMachine,0x854c316c,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xe4,0x39,0x1b);
DEFINE_GUID(IID_IObjectDaemon,0x854c3183,0xc854,0x4a77,0xb1,0x89,0x60,0x68,0x59,0xE4,0x39,0x1b);

#define MAX_RETRIES 2

HANDLE g_hMTEvent  = NULL;
HANDLE g_hMTThread = NULL;
DWORD  g_dwMTThreadId = 0;

//+---------------------------------------------------------------------------
//
//  Function:   WaitForResume
//
//  Synopsis:   Sends a "phase complete" message to the script engine and then
//              waits for it to tell us to resume (if specified).
//
//  Arguments:  [fPause] -- If TRUE, we wait for a resume command
//              [pe]     -- Message to send to the script engine
//
//----------------------------------------------------------------------------

void
WaitForResume(BOOL fPause, PROC_EVENTS pe)
{
    if (g_hMTEvent)
    {
        HANDLE aHandles[2] = { g_hMTEvent, g_hMTThread };

        ResetEvent(g_hMTEvent);

        PostThreadMessage(g_dwMTThreadId, pe, 0, 0);

        if (fPause)
        {
            // Wait until either the event object is signaled or the thread dies
            WaitForMultipleObjects(2, aHandles, FALSE, INFINITE);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ExitMTScriptThread
//
//  Synopsis:   Tells the thread talking to the MTScript engine to exit.
//
//----------------------------------------------------------------------------

void
ExitMTScriptThread()
{
    if (g_hMTEvent)
    {
        PostThreadMessage(g_dwMTThreadId, PE_EXIT, 0, 0);

        WaitForSingleObject(g_hMTThread, INFINITE);

        CloseHandle(g_hMTThread);
        CloseHandle(g_hMTEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SendStatus
//
//  Synopsis:   Sends a status message to the MTScript engine with the
//              current number of errors, warnings, and completed files.
//
//  Arguments:  [pSP] -- Pointer to MTScript engine interface
//
//----------------------------------------------------------------------------

void
SendStatus(IScriptedProcess *pSP)
{
    wchar_t achBuf[300];
    long    lRet;

    static ULONG cErrorsPrev = MAXDWORD;
    static ULONG cWarnPrev   = MAXDWORD;
    static ULONG cFilesPrev  = MAXDWORD;

    ULONG cErrors = NumberCompileErrors + NumberLibraryErrors + NumberLinkErrors + NumberBinplaceErrors;
    ULONG cWarn = NumberCompileWarnings + NumberLibraryWarnings + NumberLinkWarnings + NumberBinplaceWarnings;
    ULONG cFiles = NumberCompiles + NumberLibraries + NumberLinks /* + NumberBinplaces */;

    // Only send status if it's changed since last time we did it.
    if (   cErrors != cErrorsPrev
        || cWarn   != cWarnPrev
        || cFiles  != cFilesPrev)
    {
        cErrorsPrev = cErrors;
        cWarnPrev   = cWarn;
        cFilesPrev  = cFiles;

        wsprintfW(achBuf, L"errors=%d,warnings=%d,files=%d", cErrors, cWarn, cFiles);

        pSP->SendData(L"status", achBuf, &lRet);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HandleMessage
//
//  Synopsis:   Handles a message that has come across our message queue.
//
//  Arguments:  [pmsg] -- Message
//              [pSP]  -- Pointer to MTScript engine interface
//
//----------------------------------------------------------------------------

BOOL
HandleMessage(MSG *pmsg, IScriptedProcess *pSP)
{
    long    lRet;
    HRESULT hr = S_OK;

    switch (pmsg->message)
    {
    case PE_PASS0_COMPLETE:
        SendStatus(pSP);

        hr = pSP->SendData(L"pass 0 complete", L"", &lRet);

        break;

    case PE_PASS1_COMPLETE:
        SendStatus(pSP);

        hr = pSP->SendData(L"pass 1 complete", L"", &lRet);

        break;

    case PE_PASS2_COMPLETE:
        SendStatus(pSP);

        hr = pSP->SendData(L"pass 2 complete", L"", &lRet);

        break;

    case PE_EXIT:
        SendStatus(pSP);

        hr = pSP->SendData(L"build complete", L"", &lRet);

        return TRUE;
        break;
    }

    if (hr)
    {
        BuildErrorRaw("\nBUILD: Communication with script engine failed: %x", hr);
    }

    return (hr) ? TRUE : FALSE;
}

const DWORD UPDATE_INTERVAL = 2 * 1000;  // Update every 2 seconds

//+---------------------------------------------------------------------------
//
//  Function:   MTScriptThread
//
//  Synopsis:   Thread entrypoint.  Initializes and then sits around
//              handling various events.
//
//  Arguments:  [pv] -- Not used.
//
//----------------------------------------------------------------------------

DWORD WINAPI
MTScriptThread(LPVOID pv)
{
    HRESULT            hr;
    IScriptedProcess * pSP = NULL;
    wchar_t            achBuf[100];
    MSG                msg;
    DWORD              dwRet;
    CProcessSink       cps;
    BOOL               fExit = FALSE;
    int                cRetries = 0;

    BuildMsg("Establishing connection with Script engine...\n");
    LogMsg("Establishing connection with Script engine...\n");

    // Force Windows to create a message queue for this thread, since we will
    // be communicated to via PostThreadMessage.

    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // If anything fails we just quit this thread and communication with
    // the MTScript engine won't happen.

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (hr)
    {
        BuildErrorRaw("BUILD: CoInitializeEx failed with %x\n", hr);
        goto Cleanup;
    }

    hr = S_FALSE;

    while (hr)
    {
        pSP = NULL;
        IObjectDaemon *pIObjectDaemon;
        hr = CoCreateInstance(CLSID_ObjectDaemon, NULL, CLSCTX_SERVER, 
                             IID_IObjectDaemon, (LPVOID*)&pIObjectDaemon);    

        if (!hr)
        {
            IDispatch *pIDispatch;
            BSTR bstrProgID = SysAllocString(L"MTScript.Remote");
            BSTR bstrIdentity = SysAllocString(_wgetenv(L"__MTSCRIPT_ENV_IDENTITY"));
            hr = pIObjectDaemon->OpenInterface(bstrIdentity, bstrProgID, (BOOL)FALSE, (IDispatch**)&pIDispatch);
            if (!hr)
            {
                IConnectedMachine *pIConnectedMachine;
                hr = pIDispatch->QueryInterface(IID_IConnectedMachine, (LPVOID*)&pIConnectedMachine);
                if (!hr)
                {
                    hr = pIConnectedMachine->CreateIScriptedProcess(GetCurrentProcessId(), (wchar_t *)_wgetenv(L"__MTSCRIPT_ENV_ID"), (IScriptedProcess **)&pSP);
                    pIConnectedMachine->Release();
                }
                else
                {
                    BuildMsg("CreateIScriptedProcess failed with %x.\n", hr);
                    LogMsg("CreateIScriptedProcess failed with %x.\n", hr);
                }
                pIDispatch->Release();
            }
            else
            {
                BuildMsg("OpenInterface failed with %x.\n", hr);
                LogMsg("OpenInterface failed with %x.\n", hr);
            }
            SysFreeString(bstrProgID);
            SysFreeString(bstrIdentity);
            pIObjectDaemon->Release();
        }
        else
        {
            BuildMsg("CoCreateInstance failed with %x.\n", hr);
            LogMsg("CoCreateInstance failed with %x.\n", hr);
        }

        
        if (!hr)
        {
            hr = pSP->SetProcessSink(&cps);
            if (hr)
            {
                BuildMsg("SetProcessSink failed with %x.\n", hr);
                LogMsg("SetProcessSink failed with %x.\n", hr);
            }
        }

        if (hr)
        {
            if (cRetries >= MAX_RETRIES)
            {
                BuildErrorRaw("BUILD: FATAL: Connection to script engine could not be established. (%x)\n", hr);

                goto Cleanup;
            }

            if (pSP)
            {
                pSP->Release();
                pSP = NULL;
            }

            BuildMsg("Connection to script engine failed with %x, retries=%d...\n", hr, cRetries);
            LogMsg("Connection to script engine failed with %x, retries=%d...\n", hr, cRetries);

            Sleep(500);

            cRetries++;
        }
    }

    BuildMsg("Connection to script engine established...\n");
    LogMsg("Connection to script engine established...\r\n");

    // Tell build.c that it can continue
    SetEvent(g_hMTEvent);

    while (TRUE)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (HandleMessage(&msg, pSP))
            {
                fExit = TRUE;
            }
        }

        if (fExit)
        {
            break;
        }

        dwRet = MsgWaitForMultipleObjects(0,
                                          NULL,
                                          FALSE,
                                          UPDATE_INTERVAL,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
        {
            // A message is coming through on our message queue. Just loop
            // around.
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            SendStatus(pSP);
        }
        else
        {
            // MWFMO failed. Just bail out.
            break;
        }
    }

Cleanup:
    if (pSP)
    {
        pSP->SetProcessSink(NULL);
        pSP->Release();
    }

    CoUninitialize();

    if (hr)
    {
        g_hMTThread = NULL;
    }

    SetEvent(g_hMTEvent);

    return 0;
}

// ***********************************************************************
//
// CProcessSink implementation
//
// We hand this class to the MTScript engine so it can communicate back
// to us.
//
// ***********************************************************************

CProcessSink::CProcessSink()
{
    _ulRefs = 1;
}

HRESULT
CProcessSink::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == IID_IUnknown || riid == IID_IScriptedProcessSink)
    {
        *ppv = (IScriptedProcessSink*)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

ULONG
CProcessSink::AddRef()
{
    return InterlockedIncrement((long*)&_ulRefs);
}

ULONG
CProcessSink::Release()
{
    if (InterlockedDecrement((long*)&_ulRefs) == 0)
    {
        _ulRefs = 0xFF;
        delete this;
        return 0;
    }

    return _ulRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessSink::RequestExit, public
//
//  Synopsis:   Called when the MTScript engine wants us to quit. If we don't,
//              it will terminate us.
//
//----------------------------------------------------------------------------

HRESULT
CProcessSink::RequestExit()
{
    // There is no easy way to tell build.exe to abort. We'll just let
    // MTScript terminate us.

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessSink::ReceiveData, public
//
//  Synopsis:   Called when the MTScript engine wants to send us a message.
//
//  Arguments:  [pszType]  -- String giving the message
//              [pszData]  -- String giving data associated with the message.
//              [plReturn] -- A place we can return a value back.
//
//----------------------------------------------------------------------------

HRESULT
CProcessSink::ReceiveData(wchar_t *pszType, wchar_t *pszData, long *plReturn)
{
    *plReturn = 0;

    if (wcscmp(pszType, L"resume") == 0)
    {
        SetEvent(g_hMTEvent);
    }
    else
    {
        *plReturn = -1;   // Signals an error
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\buildutl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1989 - 1994
//
//  File:       buildutl.c
//
//  Contents:   Utility functions for Build.exe
//
//  History:    16-May-89     SteveWo  Created
//                 ... See SLM log
//              26-Jul-94     LyleC    Cleanup/Add pass0 support
//
//----------------------------------------------------------------------------

#include "build.h"


#if DBG
//+---------------------------------------------------------------------------
//
//  Memory Allocation/Deallocation functions
//
//  These functions provide leak tracking on a debug build.
//
//----------------------------------------------------------------------------

typedef struct _MEMHEADER {
    MemType mt;
    ULONG cbRequest;
    struct _MEMHEADER *pmhPrev;
    struct _MEMHEADER *pmhNext;
} MEMHEADER;

#define CBHEADER        sizeof(MEMHEADER)
#define CBTAIL          sizeof(ULONG)

char patternFree[CBTAIL] = { 'M', 'E', 'M', 'D' };
char patternBusy[CBTAIL] = { 'm', 'e', 'm', 'd' };

__inline MEMHEADER *
GetHeader(VOID *pvblock)
{
    return((MEMHEADER *) (pvblock) - 1);
}

__inline VOID *
GetBlock(MEMHEADER *pmh)
{
    return((VOID *) (pmh + 1));
}

__inline VOID
FillTailBusy(LPSTR p)
{
    memcpy(p, patternBusy, sizeof(patternBusy));
}

__inline VOID
FillTailFree(LPSTR p)
{
    memcpy(p, patternFree, sizeof(patternFree));
}

__inline BOOL
CheckTail(LPSTR p)
{
    return(memcmp(p, patternBusy, sizeof(patternBusy)) == 0);
}


typedef struct _MEMTAB {
    LPSTR pszType;
    ULONG cbAlloc;
    ULONG cAlloc;
    ULONG cbAllocTotal;
    ULONG cAllocTotal;
    MEMHEADER mh;
} MEMTAB;

ULONG cbAllocMax;
ULONG cAllocMax;

MEMTAB MemTab[] = {
    { "Totals", },              // MT_TOTALS
    { "Unknown", },             // MT_UNKNOWN

    { "ChildData", },           // MT_CHILDDATA
    { "CmdString", },           // MT_CMDSTRING
    { "DirDB", },               // MT_DIRDB
    { "DirSup", },              // MT_DIRSUP
    { "DirPath", },             // MT_DIRPATH
    { "DirString", },           // MT_DIRSTRING
    { "EventHandles", },        // MT_EVENTHANDLES
    { "FileDB", },              // MT_FILEDB
    { "FileReadBuf", },         // MT_FILEREADBUF
    { "FrbString", },           // MT_FRBSTRING
    { "IncludeDB", },           // MT_INCLUDEDB
    { "IoBuffer", },            // MT_IOBUFFER
    { "Macro", },               // MT_MACRO
    { "SourceDB", },            // MT_SOURCEDB
    { "Target", },              // MT_TARGET
    { "ThreadFilter", },        // MT_THREADFILTER
    { "ThreadHandles", },       // MT_THREADHANDLES
    { "ThreadState", },         // MT_THREADSTATE
};
#define MT_MAX  (sizeof(MemTab)/sizeof(MemTab[0]))


VOID
InitMem(VOID)
{
    MEMTAB *pmt;
    for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
        assert(pmt->cAllocTotal == 0);
        pmt->mh.mt = MT_INVALID;
        pmt->mh.pmhNext = &pmt->mh;
        pmt->mh.pmhPrev = &pmt->mh;
    }
}


#else

#define CBHEADER        0
#define CBTAIL          0

#endif


//+---------------------------------------------------------------------------
//
//  Function:   AllocMem
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb]  -- Requested Size
//              [ppv] -- [out] allocated memory
//              [mt]  -- Type of memory being allocated (MT_XXX)
//
//----------------------------------------------------------------------------

VOID
AllocMem(UINT cb, VOID **ppv, MemType mt)
{
    *ppv = malloc(cb + CBHEADER + CBTAIL);
    if (*ppv == NULL) {
        BuildError("(Fatal Error) malloc(%u) failed\n", cb);
        exit(16);
    }
#if DBG
    {
        MEMTAB *pmt;
        MEMHEADER *pmh;

        pmh = *ppv;
        *ppv = GetBlock(pmh);

        if (mt >= MT_MAX) {
            mt = MT_UNKNOWN;
        }
        pmt = &MemTab[MT_TOTALS];
        if (pmt->cAllocTotal == 0) {
            InitMem();
        }
        pmt->cAlloc++;
        pmt->cAllocTotal++;
        pmt->cbAlloc += cb;
        pmt->cbAllocTotal += cb;
        if (cbAllocMax < pmt->cbAlloc) {
            cbAllocMax = pmt->cbAlloc;
        }
        if (cAllocMax < pmt->cAlloc) {
            cAllocMax = pmt->cAlloc;
        }

        pmt = &MemTab[mt];
        pmt->cAlloc++;
        pmt->cAllocTotal++;
        pmt->cbAlloc += cb;
        pmt->cbAllocTotal += cb;

        pmh->mt = mt;
        pmh->cbRequest = cb;

        pmh->pmhNext = pmt->mh.pmhNext;
        pmt->mh.pmhNext = pmh;
        pmh->pmhPrev = pmh->pmhNext->pmhPrev;
        pmh->pmhNext->pmhPrev = pmh;

        FillTailBusy((char *) *ppv + cb);

        if (DEBUG_4 && DEBUG_1) {
            BuildError("AllocMem(%d, mt=%s) -> %lx\n", cb, pmt->pszType, *ppv);
        }
    }
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   FreeMem
//
//  Synopsis:   Free memory allocated by AllocMem
//
//  Arguments:  [ppv] -- Memory pointer
//              [mt]  -- Type of memory (MT_XXX)
//
//  Notes:      Sets the memory pointer to null after freeing it.
//
//----------------------------------------------------------------------------

VOID
FreeMem(VOID **ppv, MemType mt)
{
    assert(*ppv != NULL);
#if DBG
    {
        MEMTAB *pmt;
        MEMHEADER *pmh;

        pmh = GetHeader(*ppv);
        if (mt == MT_DIRDB ||
            mt == MT_FILEDB ||
            mt == MT_INCLUDEDB ||
            mt == MT_SOURCEDB) {

            SigCheck(assert(((DIRREC *) (*ppv))->Sig == 0));
        }
        if (mt >= MT_MAX) {
            mt = MT_UNKNOWN;
        }
        pmt = &MemTab[MT_TOTALS];
        pmt->cAlloc--;
        pmt->cbAlloc -= pmh->cbRequest;
        pmt = &MemTab[mt];
        pmt->cAlloc--;
        pmt->cbAlloc -= pmh->cbRequest;

        if (DEBUG_4 && DEBUG_1) {
            BuildError(
                "FreeMem(%d, mt=%s) <- %lx\n",
                pmh->cbRequest,
                pmt->pszType,
                *ppv);
        }
        assert(CheckTail((char *) *ppv + pmh->cbRequest));
        FillTailFree((char *) *ppv + pmh->cbRequest);
        assert(mt == pmh->mt);

        pmh->pmhNext->pmhPrev = pmh->pmhPrev;
        pmh->pmhPrev->pmhNext = pmh->pmhNext;
        pmh->pmhNext = pmh->pmhPrev = NULL;

        pmh->mt = MT_INVALID;
        *ppv = pmh;
    }
#endif
    free(*ppv);
    *ppv = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportMemoryUsage
//
//  Synopsis:   Report current memory usage (if any) on a debug build.  If
//              called just before termination, memory leaks will be
//              displayed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

VOID
ReportMemoryUsage(VOID)
{
#if DBG
    MEMTAB *pmt;
    UINT i;

    if (DEBUG_1) {
        BuildErrorRaw(
            "Maximum memory usage: %5lx bytes in %4lx blocks\n",
            cbAllocMax,
            cAllocMax);
        for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
            BuildErrorRaw(
            "%5lx bytes in %4lx blocks, %5lx bytes in %4lx blocks Total (%s)\n",
                pmt->cbAlloc,
                pmt->cAlloc,
                pmt->cbAllocTotal,
                pmt->cAllocTotal,
                pmt->pszType);
        }
    }
    FreeMem(&BigBuf, MT_IOBUFFER);
    if (fDebug & 8) {
        PrintAllDirs();
    }
    FreeAllDirs();
    if (DEBUG_1 || MemTab[MT_TOTALS].cbAlloc != 0) {
        BuildErrorRaw(szNewLine);
        if (MemTab[MT_TOTALS].cbAlloc != 0) {
            BuildError("Internal memory leaks detected:\n");
        }
        for (pmt = MemTab; pmt < &MemTab[MT_MAX]; pmt++) {
            BuildErrorRaw(
            "%5lx bytes in %4lx blocks, %5lx bytes in %4lx blocks Total (%s)\n",
                pmt->cbAlloc,
                pmt->cAlloc,
                pmt->cbAllocTotal,
                pmt->cAllocTotal,
                pmt->pszType);
        }
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   MyOpenFile
//
//  Synopsis:   Open a file
//
//----------------------------------------------------------------------------

BOOL
MyOpenFile(
    LPSTR DirName,
    LPSTR FileName,
    LPSTR Access,
    FILE **ppf,
    BOOL BufferedIO)
{
    char path[ DB_MAX_PATH_LENGTH * 2 + 1]; // ensure we have enough space for "DirName" + "\\" + "FileName"

    strcpy(path, DirName);
    if (path[0] != '\0') {
        strcat(path, "\\");
    }
    strcat(path, FileName);
    *ppf = fopen( path, Access );
    if (*ppf == NULL) {
        if (*Access == 'w') {
            BuildError("%s: create file failed\n", path);
        }
        return(FALSE);
    }
    if (!BufferedIO) {
        setvbuf(*ppf, NULL, _IONBF, 0);      // Clear buffering on the stream.
    }
    return(TRUE);
}


typedef struct _FILEREADBUF {
    struct _FILEREADBUF *pfrbNext;
    LPSTR pszFile;
    LPSTR pbBuffer;
    LPSTR pbNext;
    UINT cbBuf;
    UINT cbBuffer;
    UINT cbTotal;
    UINT cbFile;
    USHORT cLine;
    USHORT cNull;
    ULONG DateTime;
    FILE *pf;
    LPSTR pszCommentToEOL;
    size_t cbCommentToEOL;
    BOOLEAN fEof;
    BOOLEAN fOpen;
    BOOLEAN fMakefile;
} FILEREADBUF;

static FILEREADBUF Frb;
char achzeros[16];


//+---------------------------------------------------------------------------
//
//  Function:   OpenFilePush
//
//----------------------------------------------------------------------------

BOOL
OpenFilePush(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    )
{
    FILEREADBUF *pfrb;

    if (Frb.fOpen) {
        AllocMem(sizeof(*pfrb), &pfrb, MT_FILEREADBUF);
        memcpy(pfrb, &Frb, sizeof(*pfrb));
        memset(&Frb, 0, sizeof(Frb));
        Frb.pfrbNext = pfrb;
    } else {
        pfrb = NULL;
    }

    if (!SetupReadFile(
            pszdir,
            pszfile,
            pszCommentToEOL,
            ppf)) {

        if (pfrb != NULL) {
            memcpy(&Frb, pfrb, sizeof(*pfrb));
            FreeMem(&pfrb, MT_FILEREADBUF);
        }

        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePush
//
//----------------------------------------------------------------------------

LPSTR
ReadFilePush(LPSTR pszfile)
{
    FILE *pf;

    assert(Frb.fOpen);
    OpenFilePush(IsFullPath(pszfile) ? "" : Frb.pszFile, pszfile,
                 Frb.pszCommentToEOL, &pf);
    return(ReadLine(Frb.pf));
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePop
//
//----------------------------------------------------------------------------

LPSTR
ReadFilePop(VOID)
{
    if (Frb.pfrbNext == NULL) {
        return(NULL);
    }
    CloseReadFile(NULL);
    return(ReadLine(Frb.pf));
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadBuf
//
//----------------------------------------------------------------------------

BOOL
ReadBuf(FILE *pf)
{
    LPSTR p, p2;

    assert(pf == Frb.pf);
    assert(!Frb.fEof);
    Frb.pbNext = Frb.pbBuffer;
    Frb.cbBuf = fread(Frb.pbBuffer, 1, Frb.cbBuffer - 1, Frb.pf);
    if (Frb.cbBuf == 0) {
        Frb.fEof = TRUE;        // no more to read
        return(FALSE);
    }
    if (Frb.cbTotal == 0 &&
        Frb.cbBuf > sizeof(achzeros) &&
        memcmp(Frb.pbBuffer, achzeros, sizeof(achzeros)) == 0) {

        BuildError("ignoring binary file\n");
        Frb.fEof = TRUE;
        return(FALSE);
    }
    p = &Frb.pbBuffer[Frb.cbBuf - 1];
    if (Frb.cbTotal + Frb.cbBuf < Frb.cbFile) {
        do {
            while (p > Frb.pbBuffer && *p != '\n') {
                p--;
            }
            p2 = p;             // save end of last complete line
            if (p > Frb.pbBuffer && *p == '\n') {
                p--;
                if (p > Frb.pbBuffer && *p == '\r') {
                    p--;
                }
                while (p > Frb.pbBuffer && (*p == '\t' || *p == ' ')) {
                    p--;
                }
            }
        } while (*p == '\\');
        if (p == Frb.pbBuffer) {
            BuildError("(Fatal Error) too many continuation lines\n");
            exit(8);
        }
        p = p2;                 // restore end of last complete line
        Frb.cbBuf = (UINT)(p - Frb.pbBuffer + 1);
    } else {
        Frb.fEof = TRUE;        // no more to read
    }
    p[1] = '\0';
    Frb.cbTotal += Frb.cbBuf;

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsNmakeInclude
//
//----------------------------------------------------------------------------

LPSTR
IsNmakeInclude(LPSTR pinc)
{
    static char szInclude[] = "include";
    LPSTR pnew, p;

    while (*pinc == ' ') {
        pinc++;
    }
    if (_strnicmp(pinc, szInclude, sizeof(szInclude) - 1) == 0 &&
        pinc[sizeof(szInclude) - 1] == ' ') {

        pnew = NULL;
        pinc += sizeof(szInclude);
        while (*pinc == ' ') {
            pinc++;
        }

        if (MakeMacroString(&pnew, pinc)) {
            p = strchr(pnew, ' ');
            if (p != NULL) {
                *p = '\0';
            }
            return(pnew);
        }
    }
    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadLine
//
//  Synopsis:   Read a line from the input file.
//
//  Arguments:  [pf] -- File to read from
//
//  Returns:    Line read from file
//
//  Notes:      ReadLine returns a canonical line from the input file.
//              This involves:
//
//              1)  Converting tab to spaces.  Various editors/users change
//                      tabbing.
//              2)  Uniformly terminate lines.  Some editors drop CR in
//                      CRLF or add extras.
//              3)  Handle file-type-specific continuations.
//
//----------------------------------------------------------------------------

LPSTR
ReadLine(FILE *pf)
{
    LPSTR p, pend, pline;
    LPSTR pcont;
    UCHAR chComment0 = Frb.pszCommentToEOL[0];
    BOOL fInComment, fWhiteSpace;

    assert(pf == Frb.pf || (pf != NULL && Frb.pfrbNext != NULL));
    if (Frb.cbBuf == 0) {
        if (Frb.fEof) {
            return(ReadFilePop());
        }
        if (fseek(Frb.pf, Frb.cbTotal, SEEK_SET) == -1) {
            return(ReadFilePop());
        }
        if (!ReadBuf(Frb.pf)) {
            return(ReadFilePop());
        }
    }
    pline = p = Frb.pbNext;
    pend = &p[Frb.cbBuf];
    pcont = NULL;

    //  scan through line forward

    fInComment = FALSE;
    while (p < pend) {
        switch (*p) {
        case '\n':                      //  Are we at an end of line?
            if (*p == '\n') {
                Frb.cLine++;
            }
            // FALL THROUGH

        case '\0':
            if (pcont == NULL) {
                goto eol;               // bail out if single line
            }                           // else combine multiple lines...

            *pcont = ' ';               // remove continuation char
            pcont = NULL;               // eat only one line per continuation

            // We've seen a continuation char with whitespace following.
            // If we're in a comment then we complain and break anyway.

            if (fInComment) {
                if (DEBUG_1) {
                    BuildError ("continued line is commented out\n");
                }
                goto eol;               // bail out - ignore continuation
            }
            *p = ' ';                   // join the lines with blanks
            break;

        case '\\':
            pcont = p;          // remember continuation character
            break;

        case ' ':
            break;

        case '\t':
        case '\r':
            *p = ' ';
            break;

        default:

            //  See if the character we're examining begins the
            //  comment-to-EOL string.

            if (*p == chComment0 &&
                !strncmp(p, Frb.pszCommentToEOL, Frb.cbCommentToEOL)) {
                fInComment = TRUE;
            }
            pcont = NULL;               // not a continuation character
            break;
        }
        p++;
    }
eol:
    assert(Frb.cbBuf >= (UINT) (p - Frb.pbNext));
    Frb.cbBuf -= (UINT)(p - Frb.pbNext);
    Frb.pbNext = p;

    if (pcont != NULL) {
        *pcont = ' ';                   // file ended with backslash...
    }
    assert(*p == '\0' || *p == '\n');
    if (p < pend) {
        if (*p == '\0') {
            if (Frb.cNull++ == 0) {
                BuildError("null byte at offset %lx\n",
                    Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
            }
        }
        *p = '\0';                      // terminate line
        assert(Frb.cbBuf >= 1);
        Frb.cbBuf--;                    // account for newline (or null)
        Frb.pbNext++;
    } else {
        assert(p == pend && *p == '\0');
        if (*pline == 'Z' - 64 && p == &pline[1] && Frb.cbBuf == 0) {
            pline = NULL;                       // found CTL-Z at end of file
        } else {
//            BuildError( "last line incomplete\n");
        }
    }
    fWhiteSpace = FALSE;
    if (pline != NULL) {
        while (*pline == ' ') {
            pline++;                    // skip leading whitespace
            fWhiteSpace = TRUE;
        }
        if (*p != '\0') {
            BuildError( "\"*p != '\\0'\" at offset %lx\n",
                Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
            BuildError(
                "pline=%x(%s) p=%x(%s)\n",
                pline,
                pline,
                p,
                p,
                Frb.cbTotal - Frb.cbBuf + p - Frb.pbNext);
        }
        assert(*p == '\0');
        while (p > pline && *--p == ' ') {
            *p = '\0';                  // truncate trailing whitespace
        }
    }
    if (pline == NULL) {
        return(ReadFilePop());
    }
    if (Frb.fMakefile && !fWhiteSpace && *pline == '!') {
        p = IsNmakeInclude(pline + 1);
        if (p != NULL) {
            if (Frb.fMakefile && DEBUG_4) {
                BuildError("!include(%s)\n", p);
            }
            pline = ReadFilePush(p);
            FreeMem(&p, MT_DIRSTRING);
        }
    }
    return(pline);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetupReadFile
//
//  Synopsis:   Open a file and prepare to read from it.
//
//  Arguments:  [pszdir]          -- Directory name
//              [pszfile]         -- Filename
//              [pszCommentToEOL] -- Comment to EOL string
//              [ppf]             -- [out] Open file handle
//
//  Returns:    TRUE if opened successfully
//
//  Notes:      This function, in order to minimize disk hits, reads the
//              entire file into a buffer, which is then used by the ReadLine
//              function.
//
//----------------------------------------------------------------------------

BOOL
SetupReadFile(
    LPSTR pszdir,
    LPSTR pszfile,
    LPSTR pszCommentToEOL,
    FILE **ppf
    )
{
    char path[DB_MAX_PATH_LENGTH];

    assert(!Frb.fOpen);
    assert(Frb.pf == NULL);
    assert(Frb.pszFile == NULL);
    Frb.fMakefile = strcmp(pszCommentToEOL, "#") == 0;
    Frb.DateTime = 0;

    strcpy(path, pszdir);
    if (Frb.pfrbNext != NULL) {         // if a nested open
        LPSTR p;

        if (Frb.fMakefile && !IsFullPath(pszfile)) {

            // nmake handles relative includes in makefiles by
            // attempting to locate the file relative to each makefile
            // in the complete include chain.

            FILEREADBUF *pfrb;

            for (pfrb = Frb.pfrbNext; pfrb != NULL; pfrb = pfrb->pfrbNext) {
                assert(pfrb->pszFile != NULL);

                strcpy(path, pfrb->pszFile);
                p = strrchr(path, '\\');
                if (p != NULL) {
                    *p = '\0';
                }

                if (ProbeFile(path, pszfile) != -1) {
                    break;
                }
            }

            if (pfrb == NULL) {
                // Unable to find file anywhere along path.
                return FALSE;
            }
        } else {
            p = strrchr(path, '\\');
            if (p != NULL) {
                *p = '\0';
            }
        }
    }

    if (!MyOpenFile(path, pszfile, "rb", ppf, TRUE)) {
        *ppf = NULL;
        return(FALSE);
    }
    if (Frb.fMakefile) {
        Frb.DateTime = (*pDateTimeFile)(path, pszfile);
    }
    Frb.cLine = 0;
    Frb.cNull = 0;
    Frb.cbTotal = 0;
    Frb.pf = *ppf;
    Frb.fEof = FALSE;
    Frb.pszCommentToEOL = pszCommentToEOL;
    Frb.cbCommentToEOL = strlen(pszCommentToEOL);

    if (fseek(Frb.pf, 0L, SEEK_END) != -1) {
        Frb.cbFile = ftell(Frb.pf);
        if (fseek(Frb.pf, 0L, SEEK_SET) == -1) {
            Frb.cbFile = 0;
        }
    } else {
        Frb.cbFile = 0;
    }

    Frb.cbBuffer = BigBufSize;
    if (Frb.pfrbNext != NULL) {
        if (Frb.cbBuffer > Frb.cbFile + 1) {
            Frb.cbBuffer = Frb.cbFile + 1;
        }
        AllocMem(Frb.cbBuffer, &Frb.pbBuffer, MT_IOBUFFER);
    } else {
        Frb.pbBuffer = BigBuf;
    }
    if (!ReadBuf(Frb.pf)) {
        fclose(Frb.pf);
        Frb.pf = *ppf = NULL;
        if (Frb.pfrbNext != NULL) {
            FreeMem(&Frb.pbBuffer, MT_IOBUFFER);
        }
        return(FALSE);          // zero byte file
    }
    if (path[0] != '\0') {
        strcat(path, "\\");
    }
    strcat(path, pszfile);
    MakeString(&Frb.pszFile, path, TRUE, MT_FRBSTRING);
    Frb.fOpen = TRUE;
    if (Frb.fMakefile && DEBUG_4) {
        BuildError(
            "Opening file: cbFile=%lu cbBuf=%lu\n",
            Frb.cbTotal,
            Frb.cbBuffer);
    }
    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseReadFile
//
//  Synopsis:   Close the open file buffer.
//
//  Arguments:  [pcline] -- [out] Count of lines in file.
//
//  Returns:    Timestamp of file
//
//----------------------------------------------------------------------------

ULONG
CloseReadFile(
    UINT *pcline
    )
{
    assert(Frb.fOpen);
    assert(Frb.pf != NULL);
    assert(Frb.pszFile != NULL);

    if (Frb.fMakefile && DEBUG_4) {
        BuildError("Closing file\n");
    }
    if (Frb.cNull > 1) {
        BuildError("%hu null bytes in file\n", Frb.cNull);
    }
    fclose(Frb.pf);
    Frb.fOpen = FALSE;
    Frb.pf = NULL;
    FreeString(&Frb.pszFile, MT_FRBSTRING);
    if (Frb.pfrbNext != NULL) {
        FILEREADBUF *pfrb;

        FreeMem(&Frb.pbBuffer, MT_IOBUFFER);
        pfrb = Frb.pfrbNext;
        if (pfrb->DateTime < Frb.DateTime) {
            pfrb->DateTime = Frb.DateTime;  // propagate subordinate timestamp
        }
        memcpy(&Frb, pfrb, sizeof(*pfrb));
        FreeMem(&pfrb, MT_FILEREADBUF);
    }
    if (pcline != NULL) {
        *pcline = Frb.cLine;
    }
    return(Frb.DateTime);
}


//+---------------------------------------------------------------------------
//
//  Function:   ProbeFile
//
//  Synopsis:   Determine if a file exists
//
//----------------------------------------------------------------------------

UINT
ProbeFile(
    LPSTR DirName,
    LPSTR FileName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];

    if (DirName != NULL) {
        sprintf(path, "%s\\%s", DirName, FileName);
        FileName = path;
    }
    return(GetFileAttributes(FileName));
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureDirectoriesExist
//
//  Synopsis:   Ensures the given directory exists. If the path contains
//              an asterisk, it will be expanded into all current machine
//              target names.
//
//  Arguments:  [DirName] -- Name of directory to create if necessary
//
//  Returns:    FALSE if the directory could not be created, TRUE if it
//              already exists or it could be created.
//
//----------------------------------------------------------------------------

BOOL
EnsureDirectoriesExist(
    LPSTR DirName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    char *p;
    UINT i;

    if (!DirName || DirName[0] == '\0')
        return FALSE;

    for (i = 0; i < CountTargetMachines; i++) {

        // Replace '*' with appropriate name

        ExpandObjAsterisk(
            path,
            DirName,
            TargetMachines[i]->ObjectDirectory);

        if (ProbeFile(NULL, path) != -1) {
            continue;
        }
        p = path;
        while (TRUE) {
            p = strchr(p, '\\');
            if (p != NULL) {
                *p = '\0';
            }
            if (!CreateBuildDirectory(path)) {
                    return FALSE;
            }
            if (p == NULL) {
                break;
            }
            *p++ = '\\';
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DateTimeFile
//
//  Synopsis:   Get the timestamp on a file
//
//----------------------------------------------------------------------------

ULONG
DateTimeFile(
    LPSTR DirName,
    LPSTR FileName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;
    ULONG FileDateTime;

    if (DirName == NULL || DirName[0] == '\0') {
        FindHandle = FindFirstFile( FileName, &FindFileData );
    } else {
        sprintf( path, "%s\\%s", DirName, FileName );
        FindHandle = FindFirstFile( path, &FindFileData );
    }

    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        return( 0L );
    } else {
        FindClose( FindHandle );
        FileDateTime = 0L;
        FileTimeToDosDateTime( &FindFileData.ftLastWriteTime,
                               ((LPWORD)&FileDateTime)+1,
                               (LPWORD)&FileDateTime
                             );

        return( FileDateTime );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DateTimeFile2
//
//  Synopsis:   Get the timestamp on a file using the new GetFileAttributesExA
//
//----------------------------------------------------------------------------

ULONG
DateTimeFile2(
    LPSTR DirName,
    LPSTR FileName
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FILE_ATTRIBUTE_DATA FileData;
    ULONG FileDateTime;
    BOOL rc;

    if (DirName == NULL || DirName[0] == '\0') {
        strcpy( path, FileName );
    } else {
        sprintf( path, "%s\\%s", DirName, FileName );
    }

    rc = (*pGetFileAttributesExA) (path, GetFileExInfoStandard, (LPVOID)&FileData);

    if (!rc) {
        return( 0L );
    } else {
        FILETIME ftSystemTime;
        SYSTEMTIME stSystemTime;
        unsigned __int64 ui64Local, ui64File;
        GetSystemTime(&stSystemTime);
        SystemTimeToFileTime(&stSystemTime, &ftSystemTime);

        ui64Local = (((unsigned __int64) ftSystemTime.dwHighDateTime) << 32) +
                      (unsigned __int64) ftSystemTime.dwLowDateTime;

        ui64File = (((unsigned __int64) FileData.ftLastWriteTime.dwHighDateTime) << 32) +
                     (unsigned __int64) FileData.ftLastWriteTime.dwLowDateTime;

        // Take into account that file times may have two second intervals (0x989680 = 1 second)
        // for FAT drives.
        if (ui64File > (ui64Local + (0x989680*2))) {
            BuildError("ERROR - \"%s\" file time is in the future.\n", path);
        }

        FileDateTime = 0L;
        FileTimeToDosDateTime( &FileData.ftLastWriteTime,
                               ((LPWORD)&FileDateTime)+1,
                               (LPWORD)&FileDateTime
                             );
        return( FileDateTime );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSingleFile
//
//  Synopsis:   Delete the given file
//
//----------------------------------------------------------------------------

BOOL
DeleteSingleFile(
    LPSTR DirName,
    LPSTR FileName,
    BOOL QuietFlag
    )
{
    char path[ DB_MAX_PATH_LENGTH * 2 + 1]; // ensure we have enough space for "DirName" + "\\" + "FileName"

    if (DirName) {
        sprintf( path, "%s\\%s", DirName, FileName );
        }
    else {
        strcpy( path, FileName );
        }
    if (!QuietFlag && fQuery) {
        BuildMsgRaw("'erase %s'\n", path);
        return( TRUE );
        }

    return( DeleteFile( path ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteMultipleFiles
//
//  Synopsis:   Delete one or more files matching a pattern.
//
//----------------------------------------------------------------------------

BOOL
DeleteMultipleFiles(
    LPSTR DirName,
    LPSTR FilePattern
    )
{
    char path[ DB_MAX_PATH_LENGTH ];
    WIN32_FIND_DATA FindFileData;
    HDIR FindHandle;

    sprintf( path, "%s\\%s", DirName, FilePattern );

    if (fQuery) {
        BuildMsgRaw("'erase %s'\n", path);
        return( TRUE );
        }

    FindHandle = FindFirstFile( path, &FindFileData );
    if (FindHandle == (HDIR)INVALID_HANDLE_VALUE) {
        return( FALSE );
        }

    do {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            DeleteSingleFile( DirName, FindFileData.cFileName, TRUE );
            }
        }
    while (FindNextFile( FindHandle, &FindFileData ));

    FindClose( FindHandle );
    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseOrDeleteFile
//
//----------------------------------------------------------------------------

BOOL
CloseOrDeleteFile(
    FILE **ppf,
    LPSTR DirName,
    LPSTR FileName,
    ULONG SizeThreshold
    )
{
    ULONG Temp;

    if (*ppf == NULL) {
        return TRUE;
    }

    Temp = ftell( *ppf );
    fclose( *ppf );
    *ppf = NULL;
    if (Temp <= SizeThreshold) {
        return( DeleteSingleFile( DirName, FileName, TRUE ) );
        }
    else {
        CreatedBuildFile(DirName, FileName);
        return( TRUE );
        }
}


//+---------------------------------------------------------------------------
//
//  Function:   PushCurrentDirectory
//
//----------------------------------------------------------------------------

LPSTR
PushCurrentDirectory(
    LPSTR NewCurrentDirectory
    )
{
    LPSTR OldCurrentDirectory;
    char path[DB_MAX_PATH_LENGTH];

    GetCurrentDirectory(sizeof(path), path);
    AllocMem(strlen(path) + 1, &OldCurrentDirectory, MT_DIRPATH);
    strcpy(OldCurrentDirectory, path);
    SetCurrentDirectory(NewCurrentDirectory);
    return(OldCurrentDirectory);
}


//+---------------------------------------------------------------------------
//
//  Function:   PopCurrentDirectory
//
//----------------------------------------------------------------------------

VOID
PopCurrentDirectory(
    LPSTR OldCurrentDirectory
    )
{
    if (OldCurrentDirectory) {
        SetCurrentDirectory(OldCurrentDirectory);
        FreeMem(&OldCurrentDirectory, MT_DIRPATH);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CanonicalizePathName
//
//  Synopsis:   Take the given relative pathname and the current directory
//              and obtain the full absolute path of the file.
//
//  Arguments:  [SourcePath] -- Relative path
//              [Action]     -- Canonicalizing flags
//              [FullPath]   -- [out] Full path of file or directory
//
//  Returns:    TRUE if canonicalization succeeded.
//
//  Notes:      [Action] indicates whether the function will fail if the
//              resulting path is not of the correct type.  CANONICALIZE_ONLY
//              never fails, and CANON..._FILE or CANON..._DIR will fail if
//              the resulting path is not of the specified type.
//
//----------------------------------------------------------------------------

BOOL
CanonicalizePathName(
    LPSTR SourcePath,
    UINT Action,
    LPSTR FullPath
    )
{
    char   PathBuffer[DB_MAX_PATH_LENGTH] = {0},
          *FilePart;
    char *psz;
    DWORD  attr;

    if (!GetFullPathName(
            SourcePath,
            sizeof(PathBuffer),
            PathBuffer,
            &FilePart)) {
        BuildError(
            "CanonicalizePathName: GetFullPathName(%s) failed - rc = %d.\n",
             SourcePath,
             GetLastError());
        return( FALSE );
    }
    CopyString(FullPath, PathBuffer, TRUE);

    if (Action == CANONICALIZE_ONLY) {
        return( TRUE );
    }

    if ((attr = GetFileAttributes( PathBuffer )) == -1) {
        UINT rc = GetLastError();

        if (DEBUG_1 ||
            (rc != ERROR_FILE_NOT_FOUND && rc != ERROR_PATH_NOT_FOUND)) {
            BuildError(
                "CanonicalizePathName: GetFileAttributes(%s --> %s) failed - rc = %d.\n",
                 SourcePath,
                 PathBuffer,
                 rc);
        }
        return( FALSE );
    }

    if (Action == CANONICALIZE_DIR) {
        if ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0) {
            return(TRUE);
        }
        psz = "directory";
    }
    else {
        if ((attr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            return(TRUE);
        }
        psz = "file";
    }
    BuildError(
        "CanonicalizePathName: %s --> %s is not a %s\n",
        SourcePath,
        PathBuffer,
        psz);
    return(FALSE);
}

static char FormatPathBuffer[ DB_MAX_PATH_LENGTH ];

//+---------------------------------------------------------------------------
//
//  Function:   FormatPathName
//
//  Synopsis:   Take a directory name and relative pathname and merges the
//              two into a correctly formatted path.  If the resulting path
//              has the current directory as a component, the current
//              directory part is removed.
//
//  Arguments:  [DirName]  -- Directory
//              [FileName] -- Pathname relative to [DirName]
//
//  Returns:    Resulting string (should not be freed).
//
//  Notes:      Example: DirName="f:\nt\private\foo\subdir1\subdir2"
//                       FileName="..\..\bar.c"
//                       CurrentDirectory="f:\nt\private"
//                       Result="foo\bar.c"
//
//----------------------------------------------------------------------------

LPSTR
FormatPathName(
    LPSTR DirName,
    LPSTR FileName
    )
{
    UINT cb;
    LPSTR p;

    CopyString(FormatPathBuffer, CurrentDirectory, TRUE);
    if (DirName && *DirName) {
        if (DirName[1] == ':') {
            p = FormatPathBuffer;
        }
        else
        if (DirName[0] == '\\') {
            p = FormatPathBuffer + 2;
        }
        else {
            p = FormatPathBuffer + strlen(FormatPathBuffer);
            *p++ = '\\';
        }
        CopyString(p, DirName, TRUE);
    }
    p = FormatPathBuffer + strlen(FormatPathBuffer);
    if (p[-1] != '\\') {
        *p++ = '\\';
        *p = '\0';
    }

    if (FileName[1] == ':') {
        p = FormatPathBuffer;
    }
    else
    if (FileName[0] == '\\') {
        p = FormatPathBuffer + 2;
    }
    else
    if (!strncmp(FileName, ".\\", 2)) {
        FileName += 2;
    }
    else
    if (!strncmp(FileName, "..\\", 3)) {
        do
        {
            p--;
            while (*--p != '\\') {
                if (p <= FormatPathBuffer) {
                    p = FormatPathBuffer;
                    break;
                }
            }
            p++;
            FileName += 3;

        }
        while (!strncmp(FileName, "..\\", 3) && (p != FormatPathBuffer));
    }
    CopyString(p, FileName, TRUE);

    cb = strlen(CurrentDirectory);
    p = FormatPathBuffer + cb;
    if (!fAlwaysPrintFullPath) {
        if (!_strnicmp(CurrentDirectory, FormatPathBuffer, cb) && *p == '\\') {
            return(p + 1);
        }
    }
    return(FormatPathBuffer);
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendString
//
//----------------------------------------------------------------------------

LPSTR
AppendString(
    LPSTR Destination,
    LPSTR Source,
    BOOL PrefixWithSpace
    )
{
    if (Source != NULL) {
        while (*Destination) {
            Destination++;
        }
        if (PrefixWithSpace) {
            *Destination++ = ' ';
        }
        while (*Destination = *Source++) {
            Destination++;
        }
    }
    return(Destination);
}


#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   AssertPathString
//
//----------------------------------------------------------------------------

VOID
AssertPathString(LPSTR pszPath)
{
    LPSTR p = pszPath;

    while (*p != '\0') {
        if ((*p >= 'A' && *p <= 'Z') || *p == '/') {
            BuildError("Bad Path string: '%s'\n", pszPath);
            assert(FALSE);
        }
        p++;
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   CopyString
//
//----------------------------------------------------------------------------

LPSTR
CopyString(
    LPSTR Destination,
    LPSTR Source,
    BOOL fPath)
{
    UCHAR ch;
    LPSTR Result;

    Result = Destination;
    while ((ch = *Source++) != '\0') {
        if (fPath) {
            if (ch >= 'A' && ch <= 'Z') {
                ch -= (UCHAR) ('A' - 'a');
            } else if (ch == '/') {
                ch = '\\';
            }
        }
        *Destination++ = ch;
    }
    *Destination = ch;
    return(Result);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeString
//
//----------------------------------------------------------------------------

VOID
MakeString(
    LPSTR *Destination,
    LPSTR Source,
    BOOL fPath,
    MemType mt
    )
{
    if (Source == NULL) {
        Source = "";
    }
    AllocMem(strlen(Source) + 1, Destination, mt);
    *Destination = CopyString(*Destination, Source, fPath);
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeExpandedString
//
//----------------------------------------------------------------------------

VOID
MakeExpandedString(
    LPSTR *Destination,
    LPSTR Source
    )
{
    AllocMem(strlen(Source) + strlen(NtRoot) + 1, Destination, MT_DIRSTRING);
    sprintf(*Destination, "%s%s", NtRoot, Source);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeString
//
//----------------------------------------------------------------------------

VOID
FreeString(LPSTR *ppsz, MemType mt)
{
    if (*ppsz != NULL) {
        FreeMem(ppsz, mt);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatNumber
//
//----------------------------------------------------------------------------

LPSTR
FormatNumber(
    ULONG Number
    )
{
    USHORT i;
    LPSTR p;
    static char FormatNumberBuffer[16];

    p = FormatNumberBuffer + sizeof( FormatNumberBuffer ) - 1;
    *p = '\0';
    i = 0;
    do {
        if (i != 0 && (i % 3) == 0) {
            *--p = ',';
        }
        i++;
        *--p = (UCHAR) ((Number % 10) + '0');
        Number /= 10;
    } while (Number != 0);
    return( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatTime
//
//----------------------------------------------------------------------------

LPSTR
FormatTime(
    ULONG Seconds
    )
{
    ULONG Hours, Minutes;
    static char FormatTimeBuffer[16];

    Hours = Seconds / 3600;
    Seconds = Seconds % 3600;
    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    sprintf( FormatTimeBuffer,
             "%2ld:%02ld:%02ld",
             Hours,
             Minutes,
             Seconds
           );

    return( FormatTimeBuffer );
}


//+---------------------------------------------------------------------------
//
//  Function:   AToX
//
//  Synopsis:   Hex atoi with pointer bumping and success flag
//
//  Arguments:  [pp]  -- String to convert
//              [pul] -- [out] Result
//
//  Returns:    TRUE if success
//
//----------------------------------------------------------------------------

BOOL
AToX(LPSTR *pp, ULONG *pul)
{
    LPSTR p = *pp;
    int digit;
    ULONG r;
    BOOL fRet = FALSE;

    while (*p == ' ') {
        p++;
    }
    for (r = 0; isxdigit(digit = *p); p++) {
        fRet = TRUE;
        if (isdigit(digit)) {
            digit -= '0';
        } else if (isupper(digit)) {
            digit -= 'A' - 10;
        } else {
            digit -= 'a' - 10;
        }
        r = (r << 4) + digit;
    }
    *pp = p;
    *pul = r;
    return(fRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   AToD
//
//  Synopsis:   Decimal atoi with pointer bumping and success flag
//
//  Arguments:  [pp]  -- String to convert
//              [pul] -- [out] Result
//
//  Returns:    TRUE if success
//
//----------------------------------------------------------------------------

BOOL
AToD(LPSTR *pp, ULONG *pul)
{
    LPSTR p = *pp;
    int digit;
    ULONG r;
    BOOL fRet = FALSE;

    while (*p == ' ') {
        p++;
    }
    for (r = 0; isdigit(digit = *p); p++) {
        fRet = TRUE;
        r = (r * 10) + digit - '0';
    }
    *pp = p;
    *pul = r;
    return(fRet);
}

//+---------------------------------------------------------------------------
//
//  Logging and Display Functions
//
//----------------------------------------------------------------------------

VOID
__cdecl
LogMsg(const char *pszfmt, ...)
{
    va_list va;

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
    }
}


VOID
EnterMessageMode(VOID)
{
    EnterCriticalSection(&TTYCriticalSection);
    if (fConsoleInitialized &&
        (NewConsoleMode & ENABLE_WRAP_AT_EOL_OUTPUT) == 0) {

        SetConsoleMode(
            GetStdHandle(STD_ERROR_HANDLE),
            NewConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT);
    }
}


VOID
LeaveMessageMode(VOID)
{
    if (fConsoleInitialized &&
        (NewConsoleMode & ENABLE_WRAP_AT_EOL_OUTPUT) == 0) {

        SetConsoleMode(GetStdHandle(STD_ERROR_HANDLE), NewConsoleMode);
    }
    LeaveCriticalSection(&TTYCriticalSection);
}


VOID
__cdecl
BuildMsg(const char *pszfmt, ...)
{
    va_list va;

    EnterMessageMode();

    ClearLine();
    va_start(va, pszfmt);
    fprintf(stderr, "BUILD: ");
    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();
}


VOID
__cdecl
BuildMsgRaw(const char *pszfmt, ...)
{
    va_list va;

    EnterMessageMode();

    va_start(va, pszfmt);
    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();
}


VOID
__cdecl
BuildError(const char *pszfmt, ...)
{
    va_list va;

    EnterMessageMode();

    ClearLine();
    va_start(va, pszfmt);
    fprintf(stderr, "BUILD: ");

    if (Frb.fOpen) {
        fprintf (stderr, "%s(%hu): ", Frb.pszFile, Frb.cLine);
    }

    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        fprintf(LogFile, "BUILD: ");

        if (Frb.fOpen) {
            fprintf (LogFile, "%s(%hu): ", Frb.pszFile, Frb.cLine);
        }

        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}


VOID
__cdecl
BuildErrorRaw(const char *pszfmt, ...)
{
    va_list va;

    EnterMessageMode();

    va_start(va, pszfmt);
    vfprintf(stderr, pszfmt, va);
    va_end(va);
    fflush(stderr);

    LeaveMessageMode();

    if (LogFile != NULL) {
        va_start(va, pszfmt);
        vfprintf(LogFile, pszfmt, va);
        va_end(va);
        fflush(LogFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buildnum\buildnum.c ===
#define UNICODE 1
#include <windows.h>
#include <lm.h>
#include <stdio.h>
#include <string.h>

#define BUILD_NUMBER_KEY L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION"
#define BUILD_NUMBER_BUFFER_LENGTH 80
#define BUILD_LAB_BUFFER_LENGTH 80

DWORD GetBuildNumber(LPWSTR Server, LPWSTR BuildNumber, LPWSTR BuildLab);

int __cdecl
main(
    int argc,
    char ** argv
    )
{
    DWORD error;
    DWORD cb;
    WCHAR server[MAX_COMPUTERNAME_LENGTH + 3];
    WCHAR buildNumber[BUILD_NUMBER_BUFFER_LENGTH];
    WCHAR buildLab[BUILD_LAB_BUFFER_LENGTH];
    BOOLEAN bBrief = FALSE;

    //
    // All server names start with \\.
    //

    server[0] = L'\\';
    server[1] = L'\\';

    //
    // Get the build number for each server requested.
    //

    argc--;
    argv++;

    if (argc > 0) {
        if ( (*argv[0]=='-' || *argv[0]=='/') &&  (argv[0][1]=='b' || argv[0][1]=='B') ) {
            bBrief=TRUE;
            argc--;
            argv++;
        }
    }

    //
    // Get the build number of the local machine
    //

    if (argc == 0 ) {
        cb = MAX_COMPUTERNAME_LENGTH + 1;
        if ( !GetComputerName( &server[2], &cb ) ) {
            wcscpy( &server[2], L"Local Machine" );
        }

        error = GetBuildNumber( NULL, buildNumber, buildLab );
        if ( error != ERROR_SUCCESS ) {

            printf( "Error %d querying build number for %ws\n", error, server);

        } else if (bBrief) {
            printf( "%ws", buildNumber );
        } else {
            if (buildLab[0])
                printf( "%ws is running build %ws (%ws)\n", server, buildNumber, buildLab );
            else 
                printf( "%ws is running build %ws\n", server, buildNumber );
        }

    } else {

    while ( argc ) {
        CHAR *p = *argv;

        if ( !_stricmp( p, "/?" ) || !_stricmp( p, "-?" ) ) {
            puts( "Usage: BUILDNUM [-b] [ServerName [servername]...]\n"
                  "   If no servername, then local machine is assumed.\n"
                  "   -b prints only the build number digits (must be 1st arg if used).\n" );
            return 0;
        }

        if ( !strncmp( "\\\\", p, 2 ) ) {
            p += 2;
        }

        if ( strlen( p ) > MAX_COMPUTERNAME_LENGTH ) {

            printf( "Computer name \\\\%s is too long\n", *argv );

        } else {

            WCHAR *q = &server[2];

            while ( *p ) {
                *q++ = *p++;
            }
            *q = 0;

            error = GetBuildNumber( server, buildNumber, buildLab );
            if ( error != ERROR_SUCCESS ) {

                printf( "Error %d querying build number for %ws\n", error, server );

            } else if (bBrief) {
                printf( "%ws", buildNumber );
            } else {
                if (buildLab[0])
                    printf( "%ws is running build %ws (%ws)\n", server, buildNumber, buildLab );
                else 
                    printf( "%ws is running build %ws\n", server, buildNumber );
            }
        }

        argc--;
        argv++;

    }
    }
    return 0;

} // main

DWORD
GetBuildNumber(
    LPWSTR Server,
    LPWSTR BuildNumber,
    LPWSTR BuildLab
    )
{
    DWORD error;
    HKEY key;
    HKEY keyBuildNumber;
    DWORD buildNumberLength;
    DWORD keyType;

    if ( Server == NULL ) {
        key = HKEY_LOCAL_MACHINE;
    }

    error = RegConnectRegistry( Server, HKEY_LOCAL_MACHINE, &key );
    if ( error != ERROR_SUCCESS ) {
        return error;
    }

    error = RegOpenKeyEx( key, BUILD_NUMBER_KEY, 0, KEY_READ, &keyBuildNumber );
    if ( error != ERROR_SUCCESS) {
        return error;
    }

    buildNumberLength = BUILD_NUMBER_BUFFER_LENGTH * sizeof(WCHAR);
    error = RegQueryValueEx(
                keyBuildNumber,
                L"CurrentBuildNumber",
                NULL,
                &keyType,
                (LPBYTE)BuildNumber,
                &buildNumberLength
                );
    if ( error != ERROR_SUCCESS ) {
        error = RegQueryValueEx(
                    keyBuildNumber,
                    L"CurrentBuild",
                    NULL,
                    &keyType,
                    (LPBYTE)BuildNumber,
                    &buildNumberLength
                    );
    }

    buildNumberLength = BUILD_LAB_BUFFER_LENGTH * sizeof(WCHAR);
    if (RegQueryValueEx(
                keyBuildNumber,
                L"BuildLab",
                NULL,
                &keyType,
                (LPBYTE)BuildLab,
                &buildNumberLength
                ) != ERROR_SUCCESS )
    {
        *BuildLab = 0;
    }

    RegCloseKey( keyBuildNumber );
    RegCloseKey( key );

    return error;

} // GetBuildNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\advanced.c ===
//
// Advanced.C
//
#include "sigverif.h"

//
//  Initialization of search dialog.
//
BOOL Search_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    TCHAR szBuffer[MAX_PATH];

    g_App.hSearch = hwnd;

    // Since the "check system files" option is faster, check that option by default
    if (!g_App.bUserScan)
        CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_SCAN);
    else CheckRadioButton(hwnd, IDC_SCAN, IDC_NOTMS, IDC_NOTMS);

    // Pre-load the user's search path with the Windows directory
    if (!*g_App.szScanPath)
    {
        MyGetWindowsDirectory(g_App.szScanPath, MAX_PATH);
    }

    // Display the current search folder
    SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);

    // Pre-load the user's search pattern with "*.*"
    if (!*g_App.szScanPattern)
    {
        MyLoadString(g_App.szScanPattern, IDS_ALL);
    }

    // Display the current search pattern.
    SetDlgItemText(hwnd, IDC_TYPE, szBuffer);

    // Now disable all the dialog items associated with IDS_NOTMS
    if (!g_App.bUserScan)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
        EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
    }

    // If we are searching subdirectories, check the SubFolders checkbox
    if (g_App.bSubFolders)
        CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_CHECKED);
    else CheckDlgButton(hwnd, IDC_SUBFOLDERS, BST_UNCHECKED);

    // Set the combobox value to g_App.szScanPattern
    SetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern);

    // Initialize the combobox with several pre-defined extension types
    MyLoadString(szBuffer, IDS_EXE);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_DLL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_SYS);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_DRV);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_OCX);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);
    MyLoadString(szBuffer, IDS_ALL);
    SendMessage(GetDlgItem(hwnd, IDC_TYPE), CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer);

    return TRUE;
}

//
//  Handle any WM_COMMAND messages sent to the search dialog
//
void Search_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id) 
    {
        //  The user clicked the ID_BROWSE button, so call BrowseForFolder and update IDC_FOLDER
        case ID_BROWSE:
            if (BrowseForFolder(hwnd, g_App.szScanPath))
            {
                SetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath);
            }
            break;

        //  The user clicked IDC_SCAN, so disable all the IDC_NOTMS controls
        case IDC_SCAN:
            if (!g_App.bScanning)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_TYPE), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
                EnableWindow(GetDlgItem(hwnd, ID_BROWSE), FALSE);
            }
            break;

        //  The user clicked IDC_NOTMS, so make sure all the controls are enabled
        case IDC_NOTMS:
            if (!g_App.bScanning)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_SUBFOLDERS), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_TYPE), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), TRUE);
                EnableWindow(GetDlgItem(hwnd, ID_BROWSE), TRUE);
            }
            break;
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT Search_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr = (NMHDR *) lParam;

    switch(lpnmhdr->code)
    {
        case PSN_APPLY:         g_App.bUserScan = (IsDlgButtonChecked(hwnd, IDC_NOTMS) == BST_CHECKED);
                                if (g_App.bUserScan)
                                {
                                    // Get the search pattern from the combobox and update g_App.szScanPattern
                                    GetDlgItemText(hwnd, IDC_TYPE, g_App.szScanPattern, MAX_PATH);
                                    // Get the path from the edit control and update g_App.szScanPath
                                    GetDlgItemText(hwnd, IDC_FOLDER, g_App.szScanPath, MAX_PATH);
                                    // Get the checked/unchecked state of the "SubFolders" checkbox
                                    g_App.bSubFolders = (IsDlgButtonChecked(hwnd, IDC_SUBFOLDERS) == BST_CHECKED);
                                }
        case PSN_KILLACTIVE:    return FALSE;
    }

    return 0;
}


//
//  The search dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK Search_DlgProc(HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) 
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Search_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Search_OnCommand);

        case WM_NOTIFY:
            return Search_NotifyHandler(hwnd, uMsg, wParam, lParam);

        case WM_HELP:
            SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
            break;

        case WM_CONTEXTMENU:
            SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
            break;

        default: fProcessed = FALSE;
    }

    return fProcessed;
}

void AdvancedPropertySheet(HWND hwnd)
{
    PROPSHEETPAGE   psp[NUM_PAGES];
    PROPSHEETHEADER psh;
    TCHAR           szCaption[MAX_PATH];
    TCHAR           szPage1[MAX_PATH];
    TCHAR           szPage2[MAX_PATH];
    
    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[0].hInstance = g_App.hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SEARCH);
    psp[0].hIcon = g_App.hIcon;
    psp[0].pfnDlgProc = Search_DlgProc;
    MyLoadString(szPage1, IDS_SEARCHTAB);
    psp[0].pszTitle = szPage1;
    psp[0].lParam = 0;
    psp[0].pfnCallback = NULL;

    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[1].hInstance = g_App.hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_SETTINGS);
    psp[1].hIcon = g_App.hIcon;
    psp[1].pfnDlgProc = LogFile_DlgProc;
    MyLoadString(szPage2, IDS_LOGGINGTAB);
    psp[1].pszTitle = szPage2;
    psp[1].lParam = 0;
    psp[1].pfnCallback = NULL;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwnd;
    psh.hInstance = g_App.hInstance;
    psh.hIcon = g_App.hIcon;
    MyLoadString(szCaption, IDS_ADVANCED_SETTINGS);
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\devnode.c ===
//
//  DEVNODE.C
//
#include "sigverif.h"

//
// Given the full path to a driver, add it to the file list.
//
void AddDriverFileToList(LPTSTR lpDirName, LPTSTR lpFullPathName)
{
    LPFILENODE                  lpFileNode = NULL;
    TCHAR                       szFullPath[MAX_PATH];
    TCHAR                       szDirName[MAX_PATH];
    TCHAR                       szFileName[MAX_PATH];
    LPTSTR                      lpFilePart;
    BOOL                        bRet;

    *szFullPath = 0;
    *szDirName  = 0;
    *szFileName = 0;

    // If no directory is passed in, try to get the full path
    if (!lpDirName || !*lpDirName) {
        bRet = GetFullPathName(lpFullPathName, MAX_PATH, szDirName, &lpFilePart);
        if (bRet) {
            lstrcpy(szFullPath, szDirName);

            if (lpFilePart && *lpFilePart) {
                lstrcpy(szFileName, lpFilePart);
                *lpFilePart = 0;
                if (lstrlen(szDirName) > 3)
                    *(lpFilePart - 1) = 0;
            }
        }
    } else { // Use the directory and filename that was passed in to us
        // Expand out lpDirName in case there are any ".." entries
        if (!GetFullPathName(lpDirName, MAX_PATH, szDirName, NULL))
            lstrcpy(szDirName, lpDirName);
        lstrcpy(szFileName, lpFullPathName);
    }

    if (*szDirName && *szFileName && !IsFileAlreadyInList(szDirName, szFileName)) {
        // Create a filenode, based on the directory and filename
        lpFileNode = CreateFileNode(szDirName, szFileName);

        if (lpFileNode) {
            InsertFileNodeIntoList(lpFileNode);

            // Increment the total number of files we've found that meet the search criteria.
            g_App.dwFiles++;
        }
    }
}

//
//  Some Services have "\\SystemRoot" in their ImagePath entry, so I have to
//  handle that as if it were the MyGetWindowsDirectory string instead.
//
BOOL CheckPathForSystemRoot(LPTSTR lpPathName)
{
    TCHAR szSystemRoot[MAX_PATH];
    TCHAR szTempBuffer[MAX_PATH];

    //
    //  Check for "\\SystemRoot" and convert to MyGetWindowsDirectory path
    //
    szSystemRoot[0] = 0;
    MyLoadString(szSystemRoot, IDS_SYSTEMROOT);
    if (!_tcsnicmp(lpPathName, szSystemRoot, lstrlen(szSystemRoot))) {
        MyGetWindowsDirectory(szTempBuffer, MAX_PATH);
        lstrcat(szTempBuffer, lpPathName + lstrlen(szSystemRoot));
        lstrcpy(lpPathName, szTempBuffer);

        return TRUE;
    }

    return FALSE;
}

void GetFilesFromInfSection(HINF hInf, LPTSTR lpFileName, LPTSTR lpSectionName)
{
    TCHAR       szTarget[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpBuffer;
    LPTSTR      lpString, lpSeparator;
    BOOL        bRet;
    DWORD       dwRequiredSize;
    INFCONTEXT  iContext;

    ZeroMemory(szTarget, sizeof(szTarget));
    SetupGetTargetPath(hInf, NULL, lpSectionName, szTarget, sizeof(szTarget), NULL);

    // HYDRA HACK!!!
    //
    // Check to see if the target is %WINDIR% and if %WINDIR% has been redirected, change it back!!
    // We have the real %WINDIR% stored in g_App.szWinDir, so we can stuff that into szTarget.
    // We just have to remember to put back whatever was at the end of szTarget.
    //
    GetWindowsDirectory(szBuffer, MAX_PATH);
    if (!_tcsnicmp(szBuffer, szTarget, lstrlen(szBuffer)) && _tcsicmp(g_App.szWinDir, szBuffer)) {
        lstrcpy(szBuffer, szTarget + lstrlen(szBuffer));
        lstrcpy(szTarget, g_App.szWinDir);
        lstrcat(szTarget, szBuffer);
    }

    ZeroMemory(&iContext, sizeof(INFCONTEXT));
    bRet = SetupFindFirstLine(hInf, lpSectionName, NULL, &iContext);

    while (bRet && !g_App.bStopScan) {
        dwRequiredSize = 0;
        bRet = SetupGetLineText(&iContext, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize) {
            
            lpBuffer = MALLOC((dwRequiredSize + 1) * sizeof(TCHAR));
            
            if (lpBuffer) {
            
                bRet = SetupGetLineText(&iContext, NULL, NULL, NULL, lpBuffer, dwRequiredSize, NULL);
                
                if (bRet) {
                    lpString = lpBuffer;
    
                    if (lpString && *lpString) {
                        // If there's a comma, then terminate the string at the comma
                        lpSeparator = _tcschr(lpString, TEXT(','));
                        if (lpSeparator) {
                            // Null terminate at the comma, so the first entry is a null-terminated string
                            *lpSeparator = 0;
                        }
    
                        // Make sure we didn't just terminate ourselves.
                        if (*lpString) {
                            AddDriverFileToList(szTarget, lpString);
                        }
                    }
                }
            
                FREE(lpBuffer);
            }
        }

        bRet = SetupFindNextLine(&iContext, &iContext);
    }
}

void GetStuffFromInfSection(LPTSTR lpFileName, LPTSTR lpSectionName)
{
    TCHAR   szFullPath[MAX_PATH];
    TCHAR   szTarget[MAX_PATH];
    TCHAR   szKeyName[MAX_PATH];
    LPTSTR  lpString    = NULL;
    LPTSTR  lpSeparator = NULL;
    LPTSTR  lpBuffer    = NULL;
    DWORD   dwRequiredSize;
    HINF    hInf;
    BOOL    bRet;
    UINT    uError;

    szFullPath[0] = 0;
    GetFullPathName(lpFileName, MAX_PATH, szFullPath, NULL);

    //
    // Try opening the INF in the usual INF directory
    //
    hInf = SetupOpenInfFile(szFullPath, NULL, INF_STYLE_WIN4, &uError);
    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // We didn't find it in the INF directory, so try the INF\OTHER directory.
        //
        MyLoadString(szKeyName, IDS_OTHER);
        lstrcat(szKeyName, lpFileName);
        GetFullPathName(szKeyName, MAX_PATH, szFullPath, NULL);

        hInf = SetupOpenInfFile(szFullPath, NULL, INF_STYLE_WIN4, &uError);
        if (hInf == INVALID_HANDLE_VALUE) {
            // Add the INF to the file list so it shows up as unscanned.
            AddDriverFileToList(NULL, lpFileName);
            return;
        }
        // The INF must exist, so add it to the file list for verification!
        AddDriverFileToList(NULL, szFullPath);
    } else {
        // The INF must exist, so add it to the file list for verification!
        AddDriverFileToList(NULL, szFullPath);
    }

    MyLoadString(szKeyName, IDS_COPYFILES);
    dwRequiredSize = 0;
    bRet = SetupGetLineText(NULL, hInf, lpSectionName, szKeyName, NULL, 0, &dwRequiredSize);
    if (dwRequiredSize) {
        
        lpBuffer = MALLOC((dwRequiredSize + 1) * sizeof(TCHAR));
        
        if (lpBuffer) {
        
            bRet = SetupGetLineText(NULL, hInf, lpSectionName, szKeyName, lpBuffer, dwRequiredSize, NULL);
            if (!bRet) {
                //MyMessageBox(TEXT("SetupGetLineText Failed!"));
                FREE(lpBuffer);
                return;
            }
        }

        lpString = lpBuffer;
    }

    ZeroMemory(szTarget, sizeof(szTarget));
    SetupGetTargetPath(hInf, NULL, lpSectionName, szTarget, sizeof(szTarget), NULL);

    while (lpString && *lpString && !g_App.bStopScan) {
        // If there's a comma, then bump lpSeparator to after the comma
        lpSeparator = _tcschr(lpString, TEXT(','));
        if (lpSeparator) {
            // Null terminate at the comma, so the first entry is a null-terminated string
            *lpSeparator = 0;
            lpSeparator++;
        }

        //
        // If the section has an '@' symbol, then it is directly referencing a filename
        // Otherwise, it's a section and we need to process that via GetFilesFromInfSection()
        //
        if (*lpString == TEXT('@')) {
            lpString++;
            if (*lpString) {
                AddDriverFileToList(szTarget, lpString);
            }
        } else GetFilesFromInfSection(hInf, lpFileName, lpString);

        lpString = lpSeparator;
    }

    if (lpBuffer) {
    
        FREE(lpBuffer);
    }

    SetupCloseInfFile(hInf);
}

void FillDeviceStatus(PDEVICETREE DeviceTree, PDEVTREENODE DeviceTreeNode)
{
    DEVINST DeviceInstance = DeviceTreeNode->DevInst;
    TCHAR   LineBuffer[MAX_PATH*2];
    TCHAR   szBuffer[MAX_PATH];
    TCHAR   szBuffer2[MAX_PATH];
    TCHAR   szRegBuffer[MAX_PATH];
    HKEY    hServiceKey;
    DWORD   dwType, dwSize;
    LONG    lRet;
    CONFIGRET ConfigRet;

    ZeroMemory(szBuffer, sizeof(szBuffer));
    dwSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                    CM_DRP_CLASS,
                                                    NULL,
                                                    (PVOID)szBuffer,
                                                    &dwSize,
                                                    0,
                                                    NULL);
    //
    // We don't want to pick up PNP printers, since we get their drivers from
    // EnumPrinterDrivers (and NTPRINT.INF has a DestinationID of 66000)
    //
    if (!lstrcmp(szBuffer, TEXT("Printer")))
        return;

    ZeroMemory(szBuffer, sizeof(szBuffer));
    dwSize = sizeof(DeviceTreeNode->Driver);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                    CM_DRP_DRIVER,
                                                    NULL,
                                                    (PVOID)DeviceTreeNode->Driver,
                                                    &dwSize,
                                                    0,
                                                    NULL);
    if (ConfigRet != CR_SUCCESS) {
        MyLoadString(szBuffer, IDS_QUESTIONMARK);
    }

    //wsprintf(LineBuffer, TEXT("Driver: %s"), DeviceTreeNode->Driver);
    //MyMessageBox(LineBuffer);

    if (DeviceTreeNode->Driver && *DeviceTreeNode->Driver) {
        MyLoadString(szRegBuffer, IDS_REG_CLASS);
        lstrcat(szRegBuffer, DeviceTreeNode->Driver);
        lRet = RegOpenKey(HKEY_LOCAL_MACHINE, szRegBuffer, &hServiceKey);
        if (lRet != ERROR_SUCCESS) {
            // If the NT5 registry path doesn't work, try the Win9x path.
            MyLoadString(szRegBuffer, IDS_REG_CLASS2);
            lstrcat(szRegBuffer, DeviceTreeNode->Driver);
            lRet = RegOpenKey(HKEY_LOCAL_MACHINE, szRegBuffer, &hServiceKey);
        }
        if (lRet == ERROR_SUCCESS) {
            //
            // Get the INF file and section to determine what files get copied for this driver
            //
            dwSize = sizeof(szBuffer);
            MyLoadString(szRegBuffer, IDS_REG_INFPATH);
            lRet = RegQueryValueEx(hServiceKey, szRegBuffer, NULL, &dwType, (PVOID)szBuffer, &dwSize);
            if (lRet == ERROR_SUCCESS) {
                lstrcpy(LineBuffer, szBuffer);
                dwSize = sizeof(szBuffer);
                MyLoadString(szRegBuffer, IDS_REG_INFSECTION);
                lRet = RegQueryValueEx(hServiceKey, szRegBuffer, NULL, &dwType, (PVOID)szBuffer, &dwSize);
                if (lRet == ERROR_SUCCESS) {
                    // 
                    // Now look for an "InfSectionExt" value, which we need to stick on the end of InfSection.
                    //
                    dwSize = sizeof(szBuffer2);
                    MyLoadString(szRegBuffer, IDS_REG_INFSECTIONEXT);
                    lRet = RegQueryValueEx(hServiceKey, szRegBuffer, NULL, &dwType, (PVOID)szBuffer2, &dwSize);
                    if (lRet == ERROR_SUCCESS) {
                        lstrcat(szBuffer, szBuffer2);
                    }
                    GetStuffFromInfSection(LineBuffer, szBuffer);
                }
            }

            // Make sure the reg key gets closed!!
            RegCloseKey(hServiceKey);
        }
    }

    dwSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                    CM_DRP_SERVICE,
                                                    NULL,
                                                    (PVOID)szBuffer,
                                                    &dwSize,
                                                    0,
                                                    NULL);
    if (ConfigRet != CR_SUCCESS) {
        MyLoadString(szBuffer, IDS_QUESTIONMARK);
    }

    //wsprintf(LineBuffer, TEXT("Service:\t\t%s"), szBuffer);
    //MyMessageBox(LineBuffer);

    if (*szBuffer) {
        MyLoadString(szRegBuffer, IDS_REG_SERVICES);
        lstrcat(szRegBuffer, szBuffer);
        lRet = RegOpenKey(HKEY_LOCAL_MACHINE, szRegBuffer, &hServiceKey);
        if (lRet == ERROR_SUCCESS) {
            dwSize = sizeof(szBuffer);
            MyLoadString(szRegBuffer, IDS_REG_IMAGEPATH);
            lRet = RegQueryValueEx(hServiceKey, szRegBuffer, NULL, &dwType, (PVOID)szBuffer, &dwSize);
            if (lRet == ERROR_SUCCESS) {
                if (!CheckPathForSystemRoot(szBuffer)) {
                    MyGetWindowsDirectory(LineBuffer, MAX_PATH);
                    if (*szBuffer != TEXT('\\'))
                        lstrcat(LineBuffer, TEXT("\\"));
                    lstrcat(LineBuffer, szBuffer);
                } else lstrcpy(LineBuffer, szBuffer);

                // Add this file to the master lpFileList!!
                AddDriverFileToList(NULL, LineBuffer);
            }

            // Make sure the reg key is closed!!
            RegCloseKey(hServiceKey);
        }
    }
}

BOOL AddChildDevices(PDEVICETREE DeviceTree, PDEVTREENODE ParentNode)
{
    CONFIGRET       ConfigRet;
    DEVINST         DeviceInstance;
    PDEVTREENODE    pDeviceTreeNode;
    DEVTREENODE     DeviceTreeNode;
    DWORD           dwSize;
    TCHAR           szBuffer[MAX_PATH];


    ConfigRet = CM_Get_Child_Ex(&DeviceInstance,
                                ParentNode->DevInst,
                                0,
                                NULL
                               );

    while (ConfigRet == CR_SUCCESS) {
        pDeviceTreeNode = NULL;
        ZeroMemory(&DeviceTreeNode, sizeof(DEVTREENODE));
        DeviceTreeNode.DevInst = DeviceInstance;

        //
        // Fetch the class, if it doesn't exist, skip it.
        //

        dwSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_CLASSGUID,
                                                        NULL,
                                                        &szBuffer,
                                                        &dwSize,
                                                        0,
                                                        NULL);

        pDeviceTreeNode = MALLOC(sizeof(DEVTREENODE));

        if (pDeviceTreeNode) {

            *pDeviceTreeNode = DeviceTreeNode;

            pDeviceTreeNode->Sibling = ParentNode->Child;
            ParentNode->Child = pDeviceTreeNode;

            dwSize = sizeof(szBuffer);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_DEVICEDESC,
                                                            NULL,
                                                            (PVOID)szBuffer,
                                                            &dwSize,
                                                            0,
                                                            NULL);
            if (ConfigRet != CR_SUCCESS) {
                MyLoadString(szBuffer, IDS_UNKNOWN);
            }

        }

        //
        // Do Child DevNodes
        //
        if (pDeviceTreeNode) {
            FillDeviceStatus(DeviceTree, pDeviceTreeNode);
            AddChildDevices(DeviceTree, pDeviceTreeNode);
        }


        //
        // We're done this branch, now get the next sibling ...
        //
        ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                      DeviceInstance,
                                      0,
                                      NULL);
    }

    return TRUE;
}

void DestroyDeviceTree(PDEVTREENODE pDevTreeNode, PDEVTREENODE pRootNode)
{
    PDEVTREENODE pTreeNode;

    while (pDevTreeNode) {
        if (pDevTreeNode->Child)
            DestroyDeviceTree(pDevTreeNode->Child, pRootNode);

        pTreeNode = pDevTreeNode->Sibling;

        if (pDevTreeNode != pRootNode)
            FREE(pDevTreeNode);

        pDevTreeNode = pTreeNode;
    }
}

void BuildDriverFileList(void)
{
    CONFIGRET   ConfigRet;
    DEVICETREE  DeviceTree;
    TCHAR       szBuffer[MAX_PATH];

    //
    // Get the root devnode.
    //
    ZeroMemory(&DeviceTree, sizeof(DEVICETREE));

    ConfigRet = CM_Locate_DevNode_Ex(&DeviceTree.RootNode.DevInst,
                                     NULL,
                                     CM_LOCATE_DEVNODE_NORMAL,
                                     NULL
                                    );

    if (ConfigRet != CR_SUCCESS) {
        //MyErrorBoxId(IDS_ROOTDEVNODE);
        return;
    }

    //
    // Make sure we are in the %WINDIR%\INF directory so the driver INFs get populated properly
    // First we switch into the %WINDIR% directory
    //
    if (MyGetWindowsDirectory(szBuffer, MAX_PATH)) {
        if (SetCurrentDirectory(szBuffer)) {
            // Now go into the INF directory
            MyLoadString(szBuffer, IDS_INFPATH);
            SetCurrentDirectory(szBuffer);
        }
    }

    AddChildDevices(&DeviceTree, &DeviceTree.RootNode);

    DestroyDeviceTree(&DeviceTree.RootNode, &DeviceTree.RootNode);
}

void BuildPrinterFileList(void)
{
    BOOL            bRet;
    DWORD           dwBytesNeeded = 0;
    DWORD           dwDrivers = 0;
    LPBYTE          lpBuffer = NULL, lpTemp = NULL;
    LPTSTR          lpFileName;
    DRIVER_INFO_3   DriverInfo;
    PDRIVER_INFO_3  lpDriverInfo;
    TCHAR           szBuffer[MAX_PATH];

    ZeroMemory(&DriverInfo, sizeof(DRIVER_INFO_3));
    bRet = EnumPrinterDrivers(  NULL,
                                SIGVERIF_PRINTER_ENV,
                                3,
                                (LPBYTE) &DriverInfo,
                                sizeof(DRIVER_INFO_3),
                                &dwBytesNeeded,
                                &dwDrivers);

    if (!bRet && dwBytesNeeded > 0) {
        
        lpBuffer = MALLOC(dwBytesNeeded);

        //
        // If we can't get any memory then just bail out of this function
        //
        if (!lpBuffer) {

            return;
        }
        
        bRet = EnumPrinterDrivers(  NULL,
                                    SIGVERIF_PRINTER_ENV,
                                    3,
                                    (LPBYTE) lpBuffer,
                                    dwBytesNeeded,
                                    &dwBytesNeeded,
                                    &dwDrivers);
    }

    //wsprintf(szBuffer, TEXT("dwBytesNeeded: %d, dwDrivers: %d"), dwBytesNeeded, dwDrivers);
    //MyMessageBox(szBuffer);

    if (dwDrivers > 0) {
        // By default, go into the System directory, since Win9x doesn't give full paths to drivers.
        GetSystemDirectory(szBuffer, MAX_PATH);
        SetCurrentDirectory(szBuffer);

        for (lpTemp = lpBuffer; dwDrivers > 0; dwDrivers--) {
            lpDriverInfo = (PDRIVER_INFO_3) lpTemp;
            if (lpDriverInfo->pName) {
                if (lpDriverInfo->pDriverPath && *lpDriverInfo->pDriverPath) {
                    AddDriverFileToList(NULL, lpDriverInfo->pDriverPath);
                }
                if (lpDriverInfo->pDataFile && *lpDriverInfo->pDataFile) {
                    AddDriverFileToList(NULL, lpDriverInfo->pDataFile);
                }
                if (lpDriverInfo->pConfigFile && *lpDriverInfo->pConfigFile) {
                    AddDriverFileToList(NULL, lpDriverInfo->pConfigFile);
                }
                if (lpDriverInfo->pHelpFile && *lpDriverInfo->pHelpFile) {
                    AddDriverFileToList(NULL, lpDriverInfo->pHelpFile);
                }

                //MyMessageBox(lpDriverInfo->pName);
                lpFileName = lpDriverInfo->pDependentFiles;
                while (lpFileName && *lpFileName) {
                    AddDriverFileToList(NULL, lpFileName);
                    for (;*lpFileName;lpFileName++);
                    lpFileName++;
                }
            }
            
            lpTemp += sizeof(DRIVER_INFO_3);
        }
    }

    if (lpBuffer) {
    
        FREE(lpBuffer);
    }
}

BOOL GetBVTFileList(LPTSTR lpDirName, LPTSTR lpFileName)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpString, lpFilePart;

    //
    // If the user specified the "/BVT:" switch, we want to grab the string after it 
    //
    MyLoadString(szBuffer, IDS_BVT);
    lpString = MyStrStr(GetCommandLine(), szBuffer);
    if (lpString && *lpString) {
        // Switch back into the original startup directory
        SetCurrentDirectory(g_App.szAppDir);

        lpString += lstrlen(szBuffer);
        if (!EXIST(lpString)) {
            //MyMessageBox(lpString);
            return FALSE;
        }
        GetFullPathName(lpString, MAX_PATH, lpDirName, &lpFilePart);
        lstrcpy(lpFileName, lpDirName);
        *lpFilePart = 0;
        SetCurrentDirectory(lpDirName);
        return TRUE;
    }

    return FALSE;
}

BOOL IsNTServer(void)
{
    BOOL    bRet = FALSE;
    HKEY    hKey;
    LONG    lRet;
    DWORD   dwSize, dwType;
    TCHAR   szBuffer[MAX_PATH];
    TCHAR   szRegBuffer[MAX_PATH];

    // Open HKLM\System\CurrentControlSet\Control\ProductOptions
    MyLoadString(szRegBuffer, IDS_REG_PRODUCTOPTIONS);
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE, szRegBuffer, &hKey);
    if (lRet == ERROR_SUCCESS) {
        // Now we need to query the ProductType value
        ZeroMemory(szBuffer, sizeof(szBuffer));
        dwSize = sizeof(szBuffer);
        MyLoadString(szRegBuffer, IDS_REG_PRODUCTTYPE);
        lRet = RegQueryValueEx(hKey, szRegBuffer, NULL, &dwType, (PVOID)szBuffer, &dwSize);
        if (lRet == ERROR_SUCCESS) {
            // Check to see if ProductType contained "ServerNT"
            MyLoadString(szRegBuffer, IDS_PRODUCT_SERVER);
            if (!_tcsnicmp(szRegBuffer, szBuffer, lstrlen(szRegBuffer))) {
                // If so, then we want to return TRUE!
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }

    return bRet;
}

BOOL IsProcessorAlpha(void)
{
    OSVERSIONINFO   osinfo;
    SYSTEM_INFO     sysinfo;

    ZeroMemory(&osinfo, sizeof(OSVERSIONINFO));
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);

    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ZeroMemory(&sysinfo, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sysinfo);
        if (sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) {
            return TRUE;
        }
    }

    return FALSE;
}

void BuildCoreFileList(void)
{
    LPFILENODE  lpFileNode;
    TCHAR       szInfName[MAX_PATH];
    TCHAR       szSectionName[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH];
    BOOL        bRet = TRUE;

    // Check to see if the "/BVT:" switch was specified for a custom file list
    // If so, then don't verify that the file is digitally signed.
    if (GetBVTFileList(szBuffer, szInfName)) {
        GetCurrentDirectory(MAX_PATH, szBuffer);

        MyLoadString(szSectionName, IDS_MASTERFILELIST);
        GetStuffFromInfSection(szInfName, szSectionName);

        if (IsNTServer()) {
            SetCurrentDirectory(szBuffer);  
            MyLoadString(szSectionName, IDS_SERVERFILELIST);
            GetStuffFromInfSection(szInfName, szSectionName);
        }

        if (!IsProcessorAlpha()) {
            SetCurrentDirectory(szBuffer);  
            MyLoadString(szSectionName, IDS_X86FILELIST);
            GetStuffFromInfSection(szInfName, szSectionName);
        }
    } else {
        // The user didn't use "/BVT:", so grab the corelist filename from our resources
        // Make sure we are in the %WINDIR%\INF directory so lpFileNode gets created properly

        // First switch into the %WINDIR% directory
        bRet = MyGetWindowsDirectory(szBuffer, MAX_PATH);
        if (bRet) {
            bRet = SetCurrentDirectory(szBuffer);
            if (bRet) {
                // Now go into the %WINDIR%\INF directory.
                MyLoadString(szBuffer, IDS_INFPATH);
                bRet = SetCurrentDirectory(szBuffer);
            }
        }

        // If we actually get into %WINDIR%\INF, then we verify the core list and party on it!
        if (bRet) {
            // Get the name of the INF containing the core file list
            MyLoadString(szInfName, IDS_COREFILELIST);

            //
            // Verify that the core file list is digitally signed before using it.
            //
            lpFileNode = CreateFileNode(NULL, szInfName);
            if (lpFileNode) {

                // If we don't already have an g_App.hCatAdmin handle, acquire one.
                if (g_App.hCatAdmin || CryptCATAdminAcquireContext(&g_App.hCatAdmin, NULL, 0)) {
                    
                    bRet = VerifyFileNode(lpFileNode);
                    
                    if (bRet) {
                        GetCurrentDirectory(MAX_PATH, szBuffer);

                        MyLoadString(szSectionName, IDS_MASTERFILELIST);
                        GetStuffFromInfSection(szInfName, szSectionName);

                        if (IsNTServer()) {
                            SetCurrentDirectory(szBuffer);  
                            MyLoadString(szSectionName, IDS_SERVERFILELIST);
                            GetStuffFromInfSection(szInfName, szSectionName);
                        }

                        if (!IsProcessorAlpha()) {
                            SetCurrentDirectory(szBuffer);  
                            MyLoadString(szSectionName, IDS_X86FILELIST);
                            GetStuffFromInfSection(szInfName, szSectionName);
                        }
                    }

                    // If we had an g_App.hCatAdmin, free it and set it to zero so we can acquire a new one in the future.
                    if (g_App.hCatAdmin) {
                        
                        CryptCATAdminReleaseContext(g_App.hCatAdmin,0);
                        g_App.hCatAdmin = (HCATADMIN) NULL;
                    }

                } else bRet = FALSE;
                
                // Free the memory for this file node
                DestroyFileNode(lpFileNode);
            
            } else {
                
                bRet = FALSE;
            }
        }
    }

    if (!bRet) {

        MyErrorBoxId(IDS_COREFILELIST_NOTSIGNED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\browse.c ===
//
// Browse.C
//
#include "sigverif.h"

// Global browse buffer that is used until user click OK or Cancel
TCHAR g_szBrowsePath[MAX_PATH];

//
// This callback function handles the initialization of the browse dialog and when
// the user changes the selection in the tree-view.  We want to keep updating the 
// g_szBrowsePath buffer with selection changes until the user clicks OK.
//
int CALLBACK BrowseCallbackProc( HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
    int iRet = 0;
    TCHAR PathName[MAX_PATH];
    LPTSTR lpPathName = PathName;
    LPITEMIDLIST lpid;

    switch(uMsg)
    {
        case BFFM_INITIALIZED:  // Initialize the dialog with the OK button and g_szBrowsePath
                                SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);
                                SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) g_szBrowsePath);

                                break;

        case BFFM_SELCHANGED:   lpid = (LPITEMIDLIST) lParam;
                                if (SHGetPathFromIDList(lpid, lpPathName))
                                {               
                                    // If the path is good, then update g_szBrowsePath
                                    lstrcpy(g_szBrowsePath, lpPathName);
                                }
                                SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) 1);

                                break;
    }

    return iRet;
}  

//
// This uses SHBrowseForFolder to get the directory the user wants to search.
// We specify a callback function that updates g_szBrowsePath until the user clicks OK or Cancel.
// If they clicked OK, then we update the string passed in to us as lpszBuf.
// 
//
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf) {

    BROWSEINFO          bi;
    TCHAR               szBuffer[MAX_PATH],
                        szMessage[256];
    LPITEMIDLIST        lpid;

    // Check if the lpszBuf path is valid, if so use that as the browse dialog's initial directory.
    // If it isn't valid, initialize g_szBrowsePath with the Windows directory.
    if (!SetCurrentDirectory(lpszBuf))
    {
        MyGetWindowsDirectory(g_szBrowsePath, MAX_PATH);
    } else lstrcpy(g_szBrowsePath, lpszBuf);

    // Start the root of the browse dialog in the CSIDL_DRIVES namespace
    if ( !SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_DRIVES, &lpid)) )
        return FALSE;

    // This loads in the "Please select a directory" text into the dialog.
    MyLoadString(szMessage, IDS_SELECTDIR);

    //
    // Setup the BrowseInfo struct.
    //
    bi.hwndOwner        = hwnd;
    bi.pidlRoot         = lpid;
    bi.pszDisplayName   = szBuffer;
    bi.lpszTitle        = szMessage;
    bi.ulFlags          = BIF_RETURNONLYFSDIRS;
    bi.lpfn             = (BFFCALLBACK) BrowseCallbackProc;
    bi.lParam           = 0x123;

    if (SHBrowseForFolder(&bi) == NULL)
        return FALSE;

    // The user must have clicked OK, so we can update lpszBuf with g_szBrowsePath!
    lstrcpy(lpszBuf, g_szBrowsePath);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\filelist.c ===
//
//  FILELIST.C
//
#include "sigverif.h"

LPTSTR MyStrStr(LPTSTR lpString, LPTSTR lpSubString)
{
    if (!lpString || !lpSubString) {
    
        return NULL;
    }

    //return (_tcsstr(lpString, lpSubString));
    return (StrStrI(lpString, lpSubString));
}

void InsertFileNodeIntoList(LPFILENODE lpFileNode)
{
    LPFILENODE  lpTempNode = g_App.lpFileList;
    LPFILENODE  lpPrevNode = NULL;
    INT         iRet;

    if (!lpFileNode)
        return;

    if (!g_App.lpFileList)
    {
        //
        // Initialize the global file lists
        //
        g_App.lpFileList = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    }
    else
    {
        for(lpTempNode=g_App.lpFileList;lpTempNode;lpTempNode=lpTempNode->next)
        {
            //
            // Insert items sorted by directory and then filename
            //
            iRet = lstrcmp(lpTempNode->lpDirName, lpFileNode->lpDirName);
            if (iRet == 0)
            {
                //
                // If the directory names match, key off the filename
                //
                iRet = lstrcmp(lpTempNode->lpFileName, lpFileNode->lpFileName);
            }

            if (iRet >= 0)
            {
                if (!lpPrevNode)
                {
                    //
                    // Insert at the head of the list
                    //
                    lpFileNode->next = lpTempNode;
                    g_App.lpFileList = lpFileNode;
                    return;
                }
                else
                {
                    //
                    // Inserting between lpPrevNode and lpTempNode
                    //
                    lpFileNode->next = lpTempNode;
                    lpPrevNode->next = lpFileNode;
                    return;
                }
            }

            lpPrevNode = lpTempNode;
        }

        //
        // There were no matches, so insert this item at the end of the list
        //
        g_App.lpFileLast->next = lpFileNode;
        g_App.lpFileLast = lpFileNode;
    }
}

BOOL IsFileAlreadyInList(LPTSTR lpDirName, LPTSTR lpFileName)
{
    LPFILENODE lpFileNode;

    CharLowerBuff(lpDirName, lstrlen(lpDirName));
    CharLowerBuff(lpFileName, lstrlen(lpFileName));

    for(lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next)
    {
        if (!lstrcmp(lpFileNode->lpFileName, lpFileName) && !lstrcmp(lpFileNode->lpDirName, lpDirName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

// Free all the memory allocated in a single File Node.
void DestroyFileNode(LPFILENODE lpFileNode)
{
    if (!lpFileNode) {
        return;
    }

    if (lpFileNode->lpFileName) {
        FREE(lpFileNode->lpFileName);
    }

    if (lpFileNode->lpDirName) {
        FREE(lpFileNode->lpDirName);
    }

    if (lpFileNode->lpVersion) {
        FREE(lpFileNode->lpVersion);
    }

    if (lpFileNode->lpCatalog) {
        FREE(lpFileNode->lpCatalog);
    }

    if (lpFileNode->lpSignedBy) {
        FREE(lpFileNode->lpSignedBy);
    }

    if (lpFileNode->lpTypeName) {
        FREE(lpFileNode->lpTypeName);
    }

    if (lpFileNode) {
        FREE(lpFileNode);
        lpFileNode = NULL;
    }
}

// Free all the memory allocated in the g_App.lpFileList.
void DestroyFileList(void)
{
    LPFILENODE lpFileNode;

    while(g_App.lpFileList)
    {
        lpFileNode = g_App.lpFileList->next;
        DestroyFileNode(g_App.lpFileList);
        g_App.lpFileList = lpFileNode;
    }

    g_App.lpFileLast = NULL;
    g_App.dwFiles    = 0;
    g_App.dwSigned   = 0;
    g_App.dwUnsigned = 0;
}

LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName)
{
    LPFILENODE                  lpFileNode;
    TCHAR                       szDirName[MAX_PATH];
    FILETIME                    ftLocalTime;
    WIN32_FILE_ATTRIBUTE_DATA   faData;
    BOOL                        bRet;
    
    GetCurrentDirectory(MAX_PATH, szDirName);
    CharLowerBuff(szDirName, lstrlen(szDirName));

    lpFileNode = (LPFILENODE) MALLOC(sizeof(FILENODE));

    if (lpFileNode) 
    {
        lpFileNode->lpFileName = (LPTSTR) MALLOC((lstrlen(lpFileName) + 1) * sizeof(TCHAR));

        if (!lpFileNode->lpFileName) 
        {
            goto clean0;
        }
        
        lstrcpy(lpFileNode->lpFileName, lpFileName);
        CharLowerBuff(lpFileNode->lpFileName, lstrlen(lpFileNode->lpFileName));
    
        if (lpDirectory)
        {
            lpFileNode->lpDirName = (LPTSTR) MALLOC((lstrlen(lpDirectory) + 1) * sizeof(TCHAR));
            
            if (!lpFileNode->lpDirName) 
            {
                goto clean0;
            }
                
            lstrcpy(lpFileNode->lpDirName, lpDirectory);
            CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
        }
        else
        {
            lpFileNode->lpDirName = (LPTSTR) MALLOC((lstrlen(szDirName) + 1) * sizeof(TCHAR));

            if (!lpFileNode->lpDirName) 
            {
                goto clean0;
            }
            
            lstrcpy(lpFileNode->lpDirName, szDirName);
            CharLowerBuff(lpFileNode->lpDirName, lstrlen(lpFileNode->lpDirName));
        }
    
        if (lpDirectory)
            SetCurrentDirectory(lpDirectory);
    
        ZeroMemory(&faData, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        bRet = GetFileAttributesEx(lpFileName, GetFileExInfoStandard, &faData);
        if (bRet) 
        {
            // Store away the last access time for logging purposes.
            FileTimeToLocalFileTime(&faData.ftLastWriteTime, &ftLocalTime);
            FileTimeToSystemTime(&ftLocalTime, &lpFileNode->LastModified);
        }
    }
    
    if (lpDirectory)
        SetCurrentDirectory(szDirName);

    return lpFileNode;

clean0:

    //
    // If we get here then we weren't able to allocate all of the memory needed
    // for this structure, so free up any memory we were able to allocate and
    // reutnr NULL.
    //
    if (lpFileNode) 
    {
        if (lpFileNode->lpFileName) 
        {
            FREE(lpFileNode->lpFileName);
        }

        if (lpFileNode->lpDirName) 
        {
            FREE(lpFileNode->lpDirName);
        }

        FREE(lpFileNode);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\build\scrproc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for scrproc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __scrproc_h__
#define __scrproc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IScriptedProcess_FWD_DEFINED__
#define __IScriptedProcess_FWD_DEFINED__
typedef interface IScriptedProcess IScriptedProcess;
#endif 	/* __IScriptedProcess_FWD_DEFINED__ */


#ifndef __IScriptedProcessSink_FWD_DEFINED__
#define __IScriptedProcessSink_FWD_DEFINED__
typedef interface IScriptedProcessSink IScriptedProcessSink;
#endif 	/* __IScriptedProcessSink_FWD_DEFINED__ */


#ifndef __LocalScriptedProcess_FWD_DEFINED__
#define __LocalScriptedProcess_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalScriptedProcess LocalScriptedProcess;
#else
typedef struct LocalScriptedProcess LocalScriptedProcess;
#endif /* __cplusplus */

#endif 	/* __LocalScriptedProcess_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_scrproc_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_scrproc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_scrproc_0000_v0_0_s_ifspec;

#ifndef __IScriptedProcess_INTERFACE_DEFINED__
#define __IScriptedProcess_INTERFACE_DEFINED__

/* interface IScriptedProcess */
/* [uuid][object] */ 


EXTERN_C const IID IID_IScriptedProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3171-c854-4a77-b189-606859e4391b")
    IScriptedProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProcessID( 
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendData( 
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExitCode( 
            /* [in] */ long lExitCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProcessSink( 
            /* [in] */ IScriptedProcessSink *pSPS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptedProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScriptedProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScriptedProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScriptedProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcessID )( 
            IScriptedProcess * This,
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID);
        
        HRESULT ( STDMETHODCALLTYPE *SendData )( 
            IScriptedProcess * This,
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn);
        
        HRESULT ( STDMETHODCALLTYPE *SetExitCode )( 
            IScriptedProcess * This,
            /* [in] */ long lExitCode);
        
        HRESULT ( STDMETHODCALLTYPE *SetProcessSink )( 
            IScriptedProcess * This,
            /* [in] */ IScriptedProcessSink *pSPS);
        
        END_INTERFACE
    } IScriptedProcessVtbl;

    interface IScriptedProcess
    {
        CONST_VTBL struct IScriptedProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptedProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptedProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptedProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptedProcess_SetProcessID(This,lProcessID,pszEnvID)	\
    (This)->lpVtbl -> SetProcessID(This,lProcessID,pszEnvID)

#define IScriptedProcess_SendData(This,pszType,pszData,plReturn)	\
    (This)->lpVtbl -> SendData(This,pszType,pszData,plReturn)

#define IScriptedProcess_SetExitCode(This,lExitCode)	\
    (This)->lpVtbl -> SetExitCode(This,lExitCode)

#define IScriptedProcess_SetProcessSink(This,pSPS)	\
    (This)->lpVtbl -> SetProcessSink(This,pSPS)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScriptedProcess_SetProcessID_Proxy( 
    IScriptedProcess * This,
    /* [in] */ long lProcessID,
    /* [string][in] */ wchar_t *pszEnvID);


void __RPC_STUB IScriptedProcess_SetProcessID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcess_SendData_Proxy( 
    IScriptedProcess * This,
    /* [string][in] */ wchar_t *pszType,
    /* [string][in] */ wchar_t *pszData,
    /* [out] */ long *plReturn);


void __RPC_STUB IScriptedProcess_SendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcess_SetExitCode_Proxy( 
    IScriptedProcess * This,
    /* [in] */ long lExitCode);


void __RPC_STUB IScriptedProcess_SetExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcess_SetProcessSink_Proxy( 
    IScriptedProcess * This,
    /* [in] */ IScriptedProcessSink *pSPS);


void __RPC_STUB IScriptedProcess_SetProcessSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptedProcess_INTERFACE_DEFINED__ */


#ifndef __IScriptedProcessSink_INTERFACE_DEFINED__
#define __IScriptedProcessSink_INTERFACE_DEFINED__

/* interface IScriptedProcessSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IScriptedProcessSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3172-c854-4a77-b189-606859e4391b")
    IScriptedProcessSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestExit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReceiveData( 
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptedProcessSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScriptedProcessSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScriptedProcessSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScriptedProcessSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestExit )( 
            IScriptedProcessSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReceiveData )( 
            IScriptedProcessSink * This,
            /* [string][in] */ wchar_t *pszType,
            /* [string][in] */ wchar_t *pszData,
            /* [out] */ long *plReturn);
        
        END_INTERFACE
    } IScriptedProcessSinkVtbl;

    interface IScriptedProcessSink
    {
        CONST_VTBL struct IScriptedProcessSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptedProcessSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptedProcessSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptedProcessSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptedProcessSink_RequestExit(This)	\
    (This)->lpVtbl -> RequestExit(This)

#define IScriptedProcessSink_ReceiveData(This,pszType,pszData,plReturn)	\
    (This)->lpVtbl -> ReceiveData(This,pszType,pszData,plReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScriptedProcessSink_RequestExit_Proxy( 
    IScriptedProcessSink * This);


void __RPC_STUB IScriptedProcessSink_RequestExit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptedProcessSink_ReceiveData_Proxy( 
    IScriptedProcessSink * This,
    /* [string][in] */ wchar_t *pszType,
    /* [string][in] */ wchar_t *pszData,
    /* [out] */ long *plReturn);


void __RPC_STUB IScriptedProcessSink_ReceiveData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptedProcessSink_INTERFACE_DEFINED__ */



#ifndef __MTScriptedProcessLib_LIBRARY_DEFINED__
#define __MTScriptedProcessLib_LIBRARY_DEFINED__

/* library MTScriptedProcessLib */
/* [uuid] */ 


EXTERN_C const IID LIBID_MTScriptedProcessLib;

EXTERN_C const CLSID CLSID_LocalScriptedProcess;

#ifdef __cplusplus

class DECLSPEC_UUID("854c316f-c854-4a77-b189-606859e4391b")
LocalScriptedProcess;
#endif
#endif /* __MTScriptedProcessLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for od.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __od_h__
#define __od_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IObjectDaemon_FWD_DEFINED__
#define __IObjectDaemon_FWD_DEFINED__
typedef interface IObjectDaemon IObjectDaemon;
#endif 	/* __IObjectDaemon_FWD_DEFINED__ */


#ifndef __ObjectDaemon_FWD_DEFINED__
#define __ObjectDaemon_FWD_DEFINED__

#ifdef __cplusplus
typedef class ObjectDaemon ObjectDaemon;
#else
typedef struct ObjectDaemon ObjectDaemon;
#endif /* __cplusplus */

#endif 	/* __ObjectDaemon_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IObjectDaemon_INTERFACE_DEFINED__
#define __IObjectDaemon_INTERFACE_DEFINED__

/* interface IObjectDaemon */
/* [object][dual][uuid] */ 


EXTERN_C const IID IID_IObjectDaemon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3183-c854-4a77-b189-606859e4391b")
    IObjectDaemon : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMaximumIndex( 
            /* [retval][out] */ DWORD *dwMaxIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentity( 
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrIdentity) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProgID( 
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrProgId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenInterface( 
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId,
            /* [in] */ BOOL fCreate,
            /* [retval][out] */ IDispatch **ppDisp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveInterface( 
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IdentifyInterface( 
            /* [in] */ IDispatch *pDisp,
            /* [out] */ BSTR *pbstrIdentity,
            /* [retval][out] */ BSTR *pbstrProgId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IdentifyInterfaceIndex( 
            /* [in] */ IDispatch *pDisp,
            /* [retval][out] */ DWORD *pdwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectDaemonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectDaemon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectDaemon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectDaemon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IObjectDaemon * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IObjectDaemon * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IObjectDaemon * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IObjectDaemon * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMaximumIndex )( 
            IObjectDaemon * This,
            /* [retval][out] */ DWORD *dwMaxIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentity )( 
            IObjectDaemon * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrIdentity);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProgID )( 
            IObjectDaemon * This,
            /* [in] */ DWORD dwIndex,
            /* [retval][out] */ BSTR *pbstrProgId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OpenInterface )( 
            IObjectDaemon * This,
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId,
            /* [in] */ BOOL fCreate,
            /* [retval][out] */ IDispatch **ppDisp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveInterface )( 
            IObjectDaemon * This,
            /* [in] */ BSTR bstrIdentity,
            /* [in] */ BSTR bstrProgId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IdentifyInterface )( 
            IObjectDaemon * This,
            /* [in] */ IDispatch *pDisp,
            /* [out] */ BSTR *pbstrIdentity,
            /* [retval][out] */ BSTR *pbstrProgId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IdentifyInterfaceIndex )( 
            IObjectDaemon * This,
            /* [in] */ IDispatch *pDisp,
            /* [retval][out] */ DWORD *pdwIndex);
        
        END_INTERFACE
    } IObjectDaemonVtbl;

    interface IObjectDaemon
    {
        CONST_VTBL struct IObjectDaemonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectDaemon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectDaemon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectDaemon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectDaemon_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IObjectDaemon_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IObjectDaemon_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IObjectDaemon_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IObjectDaemon_GetMaximumIndex(This,dwMaxIndex)	\
    (This)->lpVtbl -> GetMaximumIndex(This,dwMaxIndex)

#define IObjectDaemon_GetIdentity(This,dwIndex,pbstrIdentity)	\
    (This)->lpVtbl -> GetIdentity(This,dwIndex,pbstrIdentity)

#define IObjectDaemon_GetProgID(This,dwIndex,pbstrProgId)	\
    (This)->lpVtbl -> GetProgID(This,dwIndex,pbstrProgId)

#define IObjectDaemon_OpenInterface(This,bstrIdentity,bstrProgId,fCreate,ppDisp)	\
    (This)->lpVtbl -> OpenInterface(This,bstrIdentity,bstrProgId,fCreate,ppDisp)

#define IObjectDaemon_RemoveInterface(This,bstrIdentity,bstrProgId)	\
    (This)->lpVtbl -> RemoveInterface(This,bstrIdentity,bstrProgId)

#define IObjectDaemon_IdentifyInterface(This,pDisp,pbstrIdentity,pbstrProgId)	\
    (This)->lpVtbl -> IdentifyInterface(This,pDisp,pbstrIdentity,pbstrProgId)

#define IObjectDaemon_IdentifyInterfaceIndex(This,pDisp,pdwIndex)	\
    (This)->lpVtbl -> IdentifyInterfaceIndex(This,pDisp,pdwIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_GetMaximumIndex_Proxy( 
    IObjectDaemon * This,
    /* [retval][out] */ DWORD *dwMaxIndex);


void __RPC_STUB IObjectDaemon_GetMaximumIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_GetIdentity_Proxy( 
    IObjectDaemon * This,
    /* [in] */ DWORD dwIndex,
    /* [retval][out] */ BSTR *pbstrIdentity);


void __RPC_STUB IObjectDaemon_GetIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_GetProgID_Proxy( 
    IObjectDaemon * This,
    /* [in] */ DWORD dwIndex,
    /* [retval][out] */ BSTR *pbstrProgId);


void __RPC_STUB IObjectDaemon_GetProgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_OpenInterface_Proxy( 
    IObjectDaemon * This,
    /* [in] */ BSTR bstrIdentity,
    /* [in] */ BSTR bstrProgId,
    /* [in] */ BOOL fCreate,
    /* [retval][out] */ IDispatch **ppDisp);


void __RPC_STUB IObjectDaemon_OpenInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_RemoveInterface_Proxy( 
    IObjectDaemon * This,
    /* [in] */ BSTR bstrIdentity,
    /* [in] */ BSTR bstrProgId);


void __RPC_STUB IObjectDaemon_RemoveInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_IdentifyInterface_Proxy( 
    IObjectDaemon * This,
    /* [in] */ IDispatch *pDisp,
    /* [out] */ BSTR *pbstrIdentity,
    /* [retval][out] */ BSTR *pbstrProgId);


void __RPC_STUB IObjectDaemon_IdentifyInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjectDaemon_IdentifyInterfaceIndex_Proxy( 
    IObjectDaemon * This,
    /* [in] */ IDispatch *pDisp,
    /* [retval][out] */ DWORD *pdwIndex);


void __RPC_STUB IObjectDaemon_IdentifyInterfaceIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectDaemon_INTERFACE_DEFINED__ */



#ifndef __ObjectDaemonLib_LIBRARY_DEFINED__
#define __ObjectDaemonLib_LIBRARY_DEFINED__

/* library ObjectDaemonLib */
/* [uuid] */ 


EXTERN_C const IID LIBID_ObjectDaemonLib;

EXTERN_C const CLSID CLSID_ObjectDaemon;

#ifdef __cplusplus

class DECLSPEC_UUID("854c3184-c854-4a77-b189-606859e4391b")
ObjectDaemon;
#endif
#endif /* __ObjectDaemonLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for mtscript.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __mtscript_h__
#define __mtscript_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRemoteMTScriptProxy_FWD_DEFINED__
#define __IRemoteMTScriptProxy_FWD_DEFINED__
typedef interface IRemoteMTScriptProxy IRemoteMTScriptProxy;
#endif 	/* __IRemoteMTScriptProxy_FWD_DEFINED__ */


#ifndef __IConnectedMachine_FWD_DEFINED__
#define __IConnectedMachine_FWD_DEFINED__
typedef interface IConnectedMachine IConnectedMachine;
#endif 	/* __IConnectedMachine_FWD_DEFINED__ */


#ifndef __IGlobalMTScript_FWD_DEFINED__
#define __IGlobalMTScript_FWD_DEFINED__
typedef interface IGlobalMTScript IGlobalMTScript;
#endif 	/* __IGlobalMTScript_FWD_DEFINED__ */


#ifndef __DLocalMTScriptEvents_FWD_DEFINED__
#define __DLocalMTScriptEvents_FWD_DEFINED__
typedef interface DLocalMTScriptEvents DLocalMTScriptEvents;
#endif 	/* __DLocalMTScriptEvents_FWD_DEFINED__ */


#ifndef __DRemoteMTScriptEvents_FWD_DEFINED__
#define __DRemoteMTScriptEvents_FWD_DEFINED__
typedef interface DRemoteMTScriptEvents DRemoteMTScriptEvents;
#endif 	/* __DRemoteMTScriptEvents_FWD_DEFINED__ */


#ifndef __LocalMTScript_FWD_DEFINED__
#define __LocalMTScript_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalMTScript LocalMTScript;
#else
typedef struct LocalMTScript LocalMTScript;
#endif /* __cplusplus */

#endif 	/* __LocalMTScript_FWD_DEFINED__ */


#ifndef __RemoteMTScript_FWD_DEFINED__
#define __RemoteMTScript_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteMTScript RemoteMTScript;
#else
typedef struct RemoteMTScript RemoteMTScript;
#endif /* __cplusplus */

#endif 	/* __RemoteMTScript_FWD_DEFINED__ */


#ifndef __RemoteMTScriptProxy_FWD_DEFINED__
#define __RemoteMTScriptProxy_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteMTScriptProxy RemoteMTScriptProxy;
#else
typedef struct RemoteMTScriptProxy RemoteMTScriptProxy;
#endif /* __cplusplus */

#endif 	/* __RemoteMTScriptProxy_FWD_DEFINED__ */


/* header files for imported files */

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __MTScriptEngine_LIBRARY_DEFINED__
#define __MTScriptEngine_LIBRARY_DEFINED__

/* library MTScriptEngine */
/* [version][uuid] */ 

#define	IConnectedMachine_lVersionMajor	( 0 )

#define	IConnectedMachine_lVersionMinor	( 0 )


EXTERN_C const IID LIBID_MTScriptEngine;

#ifndef __IRemoteMTScriptProxy_INTERFACE_DEFINED__
#define __IRemoteMTScriptProxy_INTERFACE_DEFINED__

/* interface IRemoteMTScriptProxy */
/* [object][dual][uuid] */ 


EXTERN_C const IID IID_IRemoteMTScriptProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c3181-c854-4a77-b189-606859e4391b")
    IRemoteMTScriptProxy : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [defaultvalue][in] */ BSTR bstrMachine = L"") = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConnectToMTScript( 
            /* [defaultvalue][in] */ BSTR bstrMachine = L"",
            /* [defaultvalue][in] */ BSTR bstrIdentity = L"Build",
            /* [defaultvalue][in] */ BOOL fCreate = FALSE) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConnectToObjectDaemon( 
            /* [defaultvalue][in] */ BSTR bstrMachine,
            /* [retval][out] */ IObjectDaemon **ppIOD) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DownloadFile( 
            /* [in] */ BSTR bstrUrl,
            /* [retval][out] */ BSTR *bstrFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteMTScriptProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteMTScriptProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteMTScriptProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRemoteMTScriptProxy * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IRemoteMTScriptProxy * This,
            /* [defaultvalue][in] */ BSTR bstrMachine);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConnectToMTScript )( 
            IRemoteMTScriptProxy * This,
            /* [defaultvalue][in] */ BSTR bstrMachine,
            /* [defaultvalue][in] */ BSTR bstrIdentity,
            /* [defaultvalue][in] */ BOOL fCreate);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConnectToObjectDaemon )( 
            IRemoteMTScriptProxy * This,
            /* [defaultvalue][in] */ BSTR bstrMachine,
            /* [retval][out] */ IObjectDaemon **ppIOD);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IRemoteMTScriptProxy * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DownloadFile )( 
            IRemoteMTScriptProxy * This,
            /* [in] */ BSTR bstrUrl,
            /* [retval][out] */ BSTR *bstrFile);
        
        END_INTERFACE
    } IRemoteMTScriptProxyVtbl;

    interface IRemoteMTScriptProxy
    {
        CONST_VTBL struct IRemoteMTScriptProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteMTScriptProxy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteMTScriptProxy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteMTScriptProxy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteMTScriptProxy_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteMTScriptProxy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteMTScriptProxy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteMTScriptProxy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteMTScriptProxy_Connect(This,bstrMachine)	\
    (This)->lpVtbl -> Connect(This,bstrMachine)

#define IRemoteMTScriptProxy_ConnectToMTScript(This,bstrMachine,bstrIdentity,fCreate)	\
    (This)->lpVtbl -> ConnectToMTScript(This,bstrMachine,bstrIdentity,fCreate)

#define IRemoteMTScriptProxy_ConnectToObjectDaemon(This,bstrMachine,ppIOD)	\
    (This)->lpVtbl -> ConnectToObjectDaemon(This,bstrMachine,ppIOD)

#define IRemoteMTScriptProxy_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRemoteMTScriptProxy_DownloadFile(This,bstrUrl,bstrFile)	\
    (This)->lpVtbl -> DownloadFile(This,bstrUrl,bstrFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_Connect_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [defaultvalue][in] */ BSTR bstrMachine);


void __RPC_STUB IRemoteMTScriptProxy_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_ConnectToMTScript_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [defaultvalue][in] */ BSTR bstrMachine,
    /* [defaultvalue][in] */ BSTR bstrIdentity,
    /* [defaultvalue][in] */ BOOL fCreate);


void __RPC_STUB IRemoteMTScriptProxy_ConnectToMTScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_ConnectToObjectDaemon_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [defaultvalue][in] */ BSTR bstrMachine,
    /* [retval][out] */ IObjectDaemon **ppIOD);


void __RPC_STUB IRemoteMTScriptProxy_ConnectToObjectDaemon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_Disconnect_Proxy( 
    IRemoteMTScriptProxy * This);


void __RPC_STUB IRemoteMTScriptProxy_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRemoteMTScriptProxy_DownloadFile_Proxy( 
    IRemoteMTScriptProxy * This,
    /* [in] */ BSTR bstrUrl,
    /* [retval][out] */ BSTR *bstrFile);


void __RPC_STUB IRemoteMTScriptProxy_DownloadFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteMTScriptProxy_INTERFACE_DEFINED__ */


#ifndef __IConnectedMachine_INTERFACE_DEFINED__
#define __IConnectedMachine_INTERFACE_DEFINED__

/* interface IConnectedMachine */
/* [object][version][dual][uuid] */ 


EXTERN_C const IID IID_IConnectedMachine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c316c-c854-4a77-b189-606859e4391b")
    IConnectedMachine : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Exec( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ BSTR bstrParams,
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PublicData( 
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Platform( 
            /* [retval][out] */ BSTR *platform) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OS( 
            /* [retval][out] */ BSTR *os) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVer( 
            /* [retval][out] */ long *majorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVer( 
            /* [retval][out] */ long *minorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BuildNum( 
            /* [retval][out] */ long *buildnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PlatformIsNT( 
            /* [retval][out] */ VARIANT_BOOL *pfIsNT) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServicePack( 
            /* [retval][out] */ BSTR *servicepack) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMajorVer( 
            /* [retval][out] */ long *majorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMinorVer( 
            /* [retval][out] */ long *minorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusValue( 
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateIScriptedProcess( 
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID,
            /* [retval][out] */ IScriptedProcess **pISP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConnectedMachineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConnectedMachine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConnectedMachine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConnectedMachine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IConnectedMachine * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IConnectedMachine * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IConnectedMachine * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IConnectedMachine * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IConnectedMachine * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ BSTR bstrParams,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicData )( 
            IConnectedMachine * This,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Platform )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *platform);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OS )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *os);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *majorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *minorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BuildNum )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *buildnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlatformIsNT )( 
            IConnectedMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsNT);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServicePack )( 
            IConnectedMachine * This,
            /* [retval][out] */ BSTR *servicepack);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMajorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *majorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMinorVer )( 
            IConnectedMachine * This,
            /* [retval][out] */ long *minorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusValue )( 
            IConnectedMachine * This,
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateIScriptedProcess )( 
            IConnectedMachine * This,
            /* [in] */ long lProcessID,
            /* [string][in] */ wchar_t *pszEnvID,
            /* [retval][out] */ IScriptedProcess **pISP);
        
        END_INTERFACE
    } IConnectedMachineVtbl;

    interface IConnectedMachine
    {
        CONST_VTBL struct IConnectedMachineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConnectedMachine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConnectedMachine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConnectedMachine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConnectedMachine_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IConnectedMachine_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IConnectedMachine_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IConnectedMachine_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IConnectedMachine_Exec(This,bstrCmd,bstrParams,pvData)	\
    (This)->lpVtbl -> Exec(This,bstrCmd,bstrParams,pvData)

#define IConnectedMachine_get_PublicData(This,pvData)	\
    (This)->lpVtbl -> get_PublicData(This,pvData)

#define IConnectedMachine_get_Name(This,name)	\
    (This)->lpVtbl -> get_Name(This,name)

#define IConnectedMachine_get_Platform(This,platform)	\
    (This)->lpVtbl -> get_Platform(This,platform)

#define IConnectedMachine_get_OS(This,os)	\
    (This)->lpVtbl -> get_OS(This,os)

#define IConnectedMachine_get_MajorVer(This,majorver)	\
    (This)->lpVtbl -> get_MajorVer(This,majorver)

#define IConnectedMachine_get_MinorVer(This,minorver)	\
    (This)->lpVtbl -> get_MinorVer(This,minorver)

#define IConnectedMachine_get_BuildNum(This,buildnum)	\
    (This)->lpVtbl -> get_BuildNum(This,buildnum)

#define IConnectedMachine_get_PlatformIsNT(This,pfIsNT)	\
    (This)->lpVtbl -> get_PlatformIsNT(This,pfIsNT)

#define IConnectedMachine_get_ServicePack(This,servicepack)	\
    (This)->lpVtbl -> get_ServicePack(This,servicepack)

#define IConnectedMachine_get_HostMajorVer(This,majorver)	\
    (This)->lpVtbl -> get_HostMajorVer(This,majorver)

#define IConnectedMachine_get_HostMinorVer(This,minorver)	\
    (This)->lpVtbl -> get_HostMinorVer(This,minorver)

#define IConnectedMachine_get_StatusValue(This,nIndex,pnStatus)	\
    (This)->lpVtbl -> get_StatusValue(This,nIndex,pnStatus)

#define IConnectedMachine_CreateIScriptedProcess(This,lProcessID,pszEnvID,pISP)	\
    (This)->lpVtbl -> CreateIScriptedProcess(This,lProcessID,pszEnvID,pISP)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_Exec_Proxy( 
    IConnectedMachine * This,
    /* [in] */ BSTR bstrCmd,
    /* [in] */ BSTR bstrParams,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IConnectedMachine_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_PublicData_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IConnectedMachine_get_PublicData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_Name_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IConnectedMachine_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_Platform_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *platform);


void __RPC_STUB IConnectedMachine_get_Platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_OS_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *os);


void __RPC_STUB IConnectedMachine_get_OS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_MajorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *majorver);


void __RPC_STUB IConnectedMachine_get_MajorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_MinorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *minorver);


void __RPC_STUB IConnectedMachine_get_MinorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_BuildNum_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *buildnum);


void __RPC_STUB IConnectedMachine_get_BuildNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_PlatformIsNT_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pfIsNT);


void __RPC_STUB IConnectedMachine_get_PlatformIsNT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_ServicePack_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ BSTR *servicepack);


void __RPC_STUB IConnectedMachine_get_ServicePack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_HostMajorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *majorver);


void __RPC_STUB IConnectedMachine_get_HostMajorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_HostMinorVer_Proxy( 
    IConnectedMachine * This,
    /* [retval][out] */ long *minorver);


void __RPC_STUB IConnectedMachine_get_HostMinorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_get_StatusValue_Proxy( 
    IConnectedMachine * This,
    /* [in] */ long nIndex,
    /* [retval][out] */ long *pnStatus);


void __RPC_STUB IConnectedMachine_get_StatusValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConnectedMachine_CreateIScriptedProcess_Proxy( 
    IConnectedMachine * This,
    /* [in] */ long lProcessID,
    /* [string][in] */ wchar_t *pszEnvID,
    /* [retval][out] */ IScriptedProcess **pISP);


void __RPC_STUB IConnectedMachine_CreateIScriptedProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConnectedMachine_INTERFACE_DEFINED__ */


#ifndef __IGlobalMTScript_INTERFACE_DEFINED__
#define __IGlobalMTScript_INTERFACE_DEFINED__

/* interface IGlobalMTScript */
/* [object][local][dual][uuid] */ 


EXTERN_C const IID IID_IGlobalMTScript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854c316b-c854-4a77-b189-606859e4391b")
    IGlobalMTScript : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMajorVer( 
            /* [retval][out] */ long *majorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HostMinorVer( 
            /* [retval][out] */ long *minorver) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PublicData( 
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PublicData( 
            /* [in] */ VARIANT vData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PrivateData( 
            /* [retval][out] */ VARIANT *pvData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrivateData( 
            /* [in] */ VARIANT vData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExitProcess( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Restart( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalMachine( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Identity( 
            /* [retval][out] */ BSTR *pbstrIdentity) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Include( 
            BSTR bstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CallScript( 
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SpawnScript( 
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptParam( 
            /* [retval][out] */ VARIANT *Param) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptPath( 
            /* [retval][out] */ BSTR *pbstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CallExternal( 
            /* [in] */ BSTR bstrDLLName,
            /* [in] */ BSTR bstrFunctionName,
            /* [optional][in] */ VARIANT *pParam,
            /* [retval][out] */ long *pdwRetVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetSync( 
            /* [in] */ const BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForSync( 
            /* [in] */ BSTR bstrName,
            /* [in] */ long nTimeout,
            /* [retval][out] */ VARIANT_BOOL *pfSignaled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForMultipleSyncs( 
            /* [in] */ const BSTR bstrNameList,
            /* [in] */ VARIANT_BOOL fWaitForAll,
            /* [in] */ long nTimeout,
            /* [retval][out] */ long *plSignal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SignalThreadSync( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TakeThreadLock( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseThreadLock( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoEvents( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MessageBoxTimeout( 
            /* [in] */ BSTR bstrMessage,
            /* [in] */ long cButtons,
            /* [in] */ BSTR bstrButtonText,
            /* [in] */ long lTimeout,
            /* [in] */ long lEventInterval,
            /* [in] */ VARIANT_BOOL fCanCancel,
            /* [in] */ VARIANT_BOOL fConfirm,
            /* [retval][out] */ long *plSelected) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RunLocalCommand( 
            /* [in] */ BSTR bstrCommand,
            /* [in] */ BSTR bstrDir,
            /* [defaultvalue][in] */ BSTR bstrTitle,
            /* [defaultvalue][in] */ VARIANT_BOOL fMinimize,
            /* [defaultvalue][in] */ VARIANT_BOOL fGetOutput,
            /* [defaultvalue][in] */ VARIANT_BOOL fWait,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoCrashPopup,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoEnviron,
            /* [retval][out] */ long *plProcessID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLastRunLocalError( 
            /* [retval][out] */ long *plErrorCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProcessOutput( 
            /* [in] */ long lProcessID,
            /* [retval][out] */ BSTR *pbstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProcessExitCode( 
            /* [in] */ long lProcessID,
            /* [retval][out] */ long *plExitCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TerminateProcess( 
            /* [in] */ long lProcessID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendToProcess( 
            /* [in] */ long lProcessID,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrData,
            /* [retval][out] */ long *plReturn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMail( 
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrBCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [defaultvalue][in] */ BSTR bstrAttachmentPath,
            /* [defaultvalue][in] */ BSTR bstrUsername,
            /* [defaultvalue][in] */ BSTR bstrPassword,
            /* [retval][out] */ long *plErrorCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendSMTPMail( 
            /* [in] */ BSTR bstrFrom,
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ BSTR bstrSMTPHost,
            /* [retval][out] */ long *plErrorCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ASSERT( 
            /* [in] */ VARIANT_BOOL Assertion,
            /* [in] */ BSTR Message) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OUTPUTDEBUGSTRING( 
            /* [in] */ BSTR Message) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnevalString( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *bstrOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyOrAppendFile( 
            /* [in] */ BSTR bstrSrc,
            /* [in] */ BSTR bstrDst,
            /* [in] */ long nSrcOffset,
            /* [in] */ long nSrcLength,
            /* [in] */ VARIANT_BOOL fAppend,
            /* [retval][out] */ long *nSrcFilePosition) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sleep( 
            /* [in] */ int nTimeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyScript( 
            BSTR bstrEvent,
            VARIANT vData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterEventSource( 
            /* [in] */ IDispatch *pDisp,
            /* [defaultvalue][in] */ BSTR bstrProgID = L"") = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterEventSource( 
            /* [in] */ IDispatch *pDisp) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StatusValue( 
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_StatusValue( 
            /* [in] */ long nIndex,
            /* [in] */ long nStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGlobalMTScriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGlobalMTScript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGlobalMTScript * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGlobalMTScript * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGlobalMTScript * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGlobalMTScript * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGlobalMTScript * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGlobalMTScript * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMajorVer )( 
            IGlobalMTScript * This,
            /* [retval][out] */ long *majorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostMinorVer )( 
            IGlobalMTScript * This,
            /* [retval][out] */ long *minorver);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PublicData )( 
            IGlobalMTScript * This,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PublicData )( 
            IGlobalMTScript * This,
            /* [in] */ VARIANT vData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateData )( 
            IGlobalMTScript * This,
            /* [retval][out] */ VARIANT *pvData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivateData )( 
            IGlobalMTScript * This,
            /* [in] */ VARIANT vData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExitProcess )( 
            IGlobalMTScript * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Restart )( 
            IGlobalMTScript * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalMachine )( 
            IGlobalMTScript * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Identity )( 
            IGlobalMTScript * This,
            /* [retval][out] */ BSTR *pbstrIdentity);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Include )( 
            IGlobalMTScript * This,
            BSTR bstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CallScript )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SpawnScript )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR Path,
            /* [in][optional] */ VARIANT *Param);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScriptParam )( 
            IGlobalMTScript * This,
            /* [retval][out] */ VARIANT *Param);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScriptPath )( 
            IGlobalMTScript * This,
            /* [retval][out] */ BSTR *pbstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CallExternal )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrDLLName,
            /* [in] */ BSTR bstrFunctionName,
            /* [optional][in] */ VARIANT *pParam,
            /* [retval][out] */ long *pdwRetVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ResetSync )( 
            IGlobalMTScript * This,
            /* [in] */ const BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForSync )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ long nTimeout,
            /* [retval][out] */ VARIANT_BOOL *pfSignaled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForMultipleSyncs )( 
            IGlobalMTScript * This,
            /* [in] */ const BSTR bstrNameList,
            /* [in] */ VARIANT_BOOL fWaitForAll,
            /* [in] */ long nTimeout,
            /* [retval][out] */ long *plSignal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SignalThreadSync )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TakeThreadLock )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReleaseThreadLock )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DoEvents )( 
            IGlobalMTScript * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MessageBoxTimeout )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ long cButtons,
            /* [in] */ BSTR bstrButtonText,
            /* [in] */ long lTimeout,
            /* [in] */ long lEventInterval,
            /* [in] */ VARIANT_BOOL fCanCancel,
            /* [in] */ VARIANT_BOOL fConfirm,
            /* [retval][out] */ long *plSelected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RunLocalCommand )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrCommand,
            /* [in] */ BSTR bstrDir,
            /* [defaultvalue][in] */ BSTR bstrTitle,
            /* [defaultvalue][in] */ VARIANT_BOOL fMinimize,
            /* [defaultvalue][in] */ VARIANT_BOOL fGetOutput,
            /* [defaultvalue][in] */ VARIANT_BOOL fWait,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoCrashPopup,
            /* [defaultvalue][in] */ VARIANT_BOOL fNoEnviron,
            /* [retval][out] */ long *plProcessID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLastRunLocalError )( 
            IGlobalMTScript * This,
            /* [retval][out] */ long *plErrorCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProcessOutput )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID,
            /* [retval][out] */ BSTR *pbstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProcessExitCode )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID,
            /* [retval][out] */ long *plExitCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TerminateProcess )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendToProcess )( 
            IGlobalMTScript * This,
            /* [in] */ long lProcessID,
            /* [in] */ BSTR bstrType,
            /* [in] */ BSTR bstrData,
            /* [retval][out] */ long *plReturn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMail )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrBCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [defaultvalue][in] */ BSTR bstrAttachmentPath,
            /* [defaultvalue][in] */ BSTR bstrUsername,
            /* [defaultvalue][in] */ BSTR bstrPassword,
            /* [retval][out] */ long *plErrorCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendSMTPMail )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrFrom,
            /* [in] */ BSTR bstrTo,
            /* [in] */ BSTR bstrCC,
            /* [in] */ BSTR bstrSubject,
            /* [in] */ BSTR bstrMessage,
            /* [in] */ BSTR bstrSMTPHost,
            /* [retval][out] */ long *plErrorCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ASSERT )( 
            IGlobalMTScript * This,
            /* [in] */ VARIANT_BOOL Assertion,
            /* [in] */ BSTR Message);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OUTPUTDEBUGSTRING )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR Message);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnevalString )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *bstrOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CopyOrAppendFile )( 
            IGlobalMTScript * This,
            /* [in] */ BSTR bstrSrc,
            /* [in] */ BSTR bstrDst,
            /* [in] */ long nSrcOffset,
            /* [in] */ long nSrcLength,
            /* [in] */ VARIANT_BOOL fAppend,
            /* [retval][out] */ long *nSrcFilePosition);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IGlobalMTScript * This,
            /* [in] */ int nTimeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reboot )( 
            IGlobalMTScript * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyScript )( 
            IGlobalMTScript * This,
            BSTR bstrEvent,
            VARIANT vData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventSource )( 
            IGlobalMTScript * This,
            /* [in] */ IDispatch *pDisp,
            /* [defaultvalue][in] */ BSTR bstrProgID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterEventSource )( 
            IGlobalMTScript * This,
            /* [in] */ IDispatch *pDisp);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusValue )( 
            IGlobalMTScript * This,
            /* [in] */ long nIndex,
            /* [retval][out] */ long *pnStatus);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StatusValue )( 
            IGlobalMTScript * This,
            /* [in] */ long nIndex,
            /* [in] */ long nStatus);
        
        END_INTERFACE
    } IGlobalMTScriptVtbl;

    interface IGlobalMTScript
    {
        CONST_VTBL struct IGlobalMTScriptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGlobalMTScript_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGlobalMTScript_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGlobalMTScript_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGlobalMTScript_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGlobalMTScript_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGlobalMTScript_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGlobalMTScript_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGlobalMTScript_get_HostMajorVer(This,majorver)	\
    (This)->lpVtbl -> get_HostMajorVer(This,majorver)

#define IGlobalMTScript_get_HostMinorVer(This,minorver)	\
    (This)->lpVtbl -> get_HostMinorVer(This,minorver)

#define IGlobalMTScript_get_PublicData(This,pvData)	\
    (This)->lpVtbl -> get_PublicData(This,pvData)

#define IGlobalMTScript_put_PublicData(This,vData)	\
    (This)->lpVtbl -> put_PublicData(This,vData)

#define IGlobalMTScript_get_PrivateData(This,pvData)	\
    (This)->lpVtbl -> get_PrivateData(This,pvData)

#define IGlobalMTScript_put_PrivateData(This,vData)	\
    (This)->lpVtbl -> put_PrivateData(This,vData)

#define IGlobalMTScript_ExitProcess(This)	\
    (This)->lpVtbl -> ExitProcess(This)

#define IGlobalMTScript_Restart(This)	\
    (This)->lpVtbl -> Restart(This)

#define IGlobalMTScript_get_LocalMachine(This,pbstrName)	\
    (This)->lpVtbl -> get_LocalMachine(This,pbstrName)

#define IGlobalMTScript_get_Identity(This,pbstrIdentity)	\
    (This)->lpVtbl -> get_Identity(This,pbstrIdentity)

#define IGlobalMTScript_Include(This,bstrPath)	\
    (This)->lpVtbl -> Include(This,bstrPath)

#define IGlobalMTScript_CallScript(This,Path,Param)	\
    (This)->lpVtbl -> CallScript(This,Path,Param)

#define IGlobalMTScript_SpawnScript(This,Path,Param)	\
    (This)->lpVtbl -> SpawnScript(This,Path,Param)

#define IGlobalMTScript_get_ScriptParam(This,Param)	\
    (This)->lpVtbl -> get_ScriptParam(This,Param)

#define IGlobalMTScript_get_ScriptPath(This,pbstrPath)	\
    (This)->lpVtbl -> get_ScriptPath(This,pbstrPath)

#define IGlobalMTScript_CallExternal(This,bstrDLLName,bstrFunctionName,pParam,pdwRetVal)	\
    (This)->lpVtbl -> CallExternal(This,bstrDLLName,bstrFunctionName,pParam,pdwRetVal)

#define IGlobalMTScript_ResetSync(This,bstrName)	\
    (This)->lpVtbl -> ResetSync(This,bstrName)

#define IGlobalMTScript_WaitForSync(This,bstrName,nTimeout,pfSignaled)	\
    (This)->lpVtbl -> WaitForSync(This,bstrName,nTimeout,pfSignaled)

#define IGlobalMTScript_WaitForMultipleSyncs(This,bstrNameList,fWaitForAll,nTimeout,plSignal)	\
    (This)->lpVtbl -> WaitForMultipleSyncs(This,bstrNameList,fWaitForAll,nTimeout,plSignal)

#define IGlobalMTScript_SignalThreadSync(This,bstrName)	\
    (This)->lpVtbl -> SignalThreadSync(This,bstrName)

#define IGlobalMTScript_TakeThreadLock(This,bstrName)	\
    (This)->lpVtbl -> TakeThreadLock(This,bstrName)

#define IGlobalMTScript_ReleaseThreadLock(This,bstrName)	\
    (This)->lpVtbl -> ReleaseThreadLock(This,bstrName)

#define IGlobalMTScript_DoEvents(This)	\
    (This)->lpVtbl -> DoEvents(This)

#define IGlobalMTScript_MessageBoxTimeout(This,bstrMessage,cButtons,bstrButtonText,lTimeout,lEventInterval,fCanCancel,fConfirm,plSelected)	\
    (This)->lpVtbl -> MessageBoxTimeout(This,bstrMessage,cButtons,bstrButtonText,lTimeout,lEventInterval,fCanCancel,fConfirm,plSelected)

#define IGlobalMTScript_RunLocalCommand(This,bstrCommand,bstrDir,bstrTitle,fMinimize,fGetOutput,fWait,fNoCrashPopup,fNoEnviron,plProcessID)	\
    (This)->lpVtbl -> RunLocalCommand(This,bstrCommand,bstrDir,bstrTitle,fMinimize,fGetOutput,fWait,fNoCrashPopup,fNoEnviron,plProcessID)

#define IGlobalMTScript_GetLastRunLocalError(This,plErrorCode)	\
    (This)->lpVtbl -> GetLastRunLocalError(This,plErrorCode)

#define IGlobalMTScript_GetProcessOutput(This,lProcessID,pbstrData)	\
    (This)->lpVtbl -> GetProcessOutput(This,lProcessID,pbstrData)

#define IGlobalMTScript_GetProcessExitCode(This,lProcessID,plExitCode)	\
    (This)->lpVtbl -> GetProcessExitCode(This,lProcessID,plExitCode)

#define IGlobalMTScript_TerminateProcess(This,lProcessID)	\
    (This)->lpVtbl -> TerminateProcess(This,lProcessID)

#define IGlobalMTScript_SendToProcess(This,lProcessID,bstrType,bstrData,plReturn)	\
    (This)->lpVtbl -> SendToProcess(This,lProcessID,bstrType,bstrData,plReturn)

#define IGlobalMTScript_SendMail(This,bstrTo,bstrCC,bstrBCC,bstrSubject,bstrMessage,bstrAttachmentPath,bstrUsername,bstrPassword,plErrorCode)	\
    (This)->lpVtbl -> SendMail(This,bstrTo,bstrCC,bstrBCC,bstrSubject,bstrMessage,bstrAttachmentPath,bstrUsername,bstrPassword,plErrorCode)

#define IGlobalMTScript_SendSMTPMail(This,bstrFrom,bstrTo,bstrCC,bstrSubject,bstrMessage,bstrSMTPHost,plErrorCode)	\
    (This)->lpVtbl -> SendSMTPMail(This,bstrFrom,bstrTo,bstrCC,bstrSubject,bstrMessage,bstrSMTPHost,plErrorCode)

#define IGlobalMTScript_ASSERT(This,Assertion,Message)	\
    (This)->lpVtbl -> ASSERT(This,Assertion,Message)

#define IGlobalMTScript_OUTPUTDEBUGSTRING(This,Message)	\
    (This)->lpVtbl -> OUTPUTDEBUGSTRING(This,Message)

#define IGlobalMTScript_UnevalString(This,bstrIn,bstrOut)	\
    (This)->lpVtbl -> UnevalString(This,bstrIn,bstrOut)

#define IGlobalMTScript_CopyOrAppendFile(This,bstrSrc,bstrDst,nSrcOffset,nSrcLength,fAppend,nSrcFilePosition)	\
    (This)->lpVtbl -> CopyOrAppendFile(This,bstrSrc,bstrDst,nSrcOffset,nSrcLength,fAppend,nSrcFilePosition)

#define IGlobalMTScript_Sleep(This,nTimeout)	\
    (This)->lpVtbl -> Sleep(This,nTimeout)

#define IGlobalMTScript_Reboot(This)	\
    (This)->lpVtbl -> Reboot(This)

#define IGlobalMTScript_NotifyScript(This,bstrEvent,vData)	\
    (This)->lpVtbl -> NotifyScript(This,bstrEvent,vData)

#define IGlobalMTScript_RegisterEventSource(This,pDisp,bstrProgID)	\
    (This)->lpVtbl -> RegisterEventSource(This,pDisp,bstrProgID)

#define IGlobalMTScript_UnregisterEventSource(This,pDisp)	\
    (This)->lpVtbl -> UnregisterEventSource(This,pDisp)

#define IGlobalMTScript_get_StatusValue(This,nIndex,pnStatus)	\
    (This)->lpVtbl -> get_StatusValue(This,nIndex,pnStatus)

#define IGlobalMTScript_put_StatusValue(This,nIndex,nStatus)	\
    (This)->lpVtbl -> put_StatusValue(This,nIndex,nStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_HostMajorVer_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ long *majorver);


void __RPC_STUB IGlobalMTScript_get_HostMajorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_HostMinorVer_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ long *minorver);


void __RPC_STUB IGlobalMTScript_get_HostMinorVer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_PublicData_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IGlobalMTScript_get_PublicData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_put_PublicData_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ VARIANT vData);


void __RPC_STUB IGlobalMTScript_put_PublicData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_PrivateData_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ VARIANT *pvData);


void __RPC_STUB IGlobalMTScript_get_PrivateData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_put_PrivateData_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ VARIANT vData);


void __RPC_STUB IGlobalMTScript_put_PrivateData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ExitProcess_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_ExitProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Restart_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_Restart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_LocalMachine_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ BSTR *pbstrName);


void __RPC_STUB IGlobalMTScript_get_LocalMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_Identity_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ BSTR *pbstrIdentity);


void __RPC_STUB IGlobalMTScript_get_Identity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Include_Proxy( 
    IGlobalMTScript * This,
    BSTR bstrPath);


void __RPC_STUB IGlobalMTScript_Include_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_CallScript_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR Path,
    /* [in][optional] */ VARIANT *Param);


void __RPC_STUB IGlobalMTScript_CallScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SpawnScript_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR Path,
    /* [in][optional] */ VARIANT *Param);


void __RPC_STUB IGlobalMTScript_SpawnScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_ScriptParam_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ VARIANT *Param);


void __RPC_STUB IGlobalMTScript_get_ScriptParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_ScriptPath_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ BSTR *pbstrPath);


void __RPC_STUB IGlobalMTScript_get_ScriptPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_CallExternal_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrDLLName,
    /* [in] */ BSTR bstrFunctionName,
    /* [optional][in] */ VARIANT *pParam,
    /* [retval][out] */ long *pdwRetVal);


void __RPC_STUB IGlobalMTScript_CallExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ResetSync_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ const BSTR bstrName);


void __RPC_STUB IGlobalMTScript_ResetSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_WaitForSync_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ long nTimeout,
    /* [retval][out] */ VARIANT_BOOL *pfSignaled);


void __RPC_STUB IGlobalMTScript_WaitForSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_WaitForMultipleSyncs_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ const BSTR bstrNameList,
    /* [in] */ VARIANT_BOOL fWaitForAll,
    /* [in] */ long nTimeout,
    /* [retval][out] */ long *plSignal);


void __RPC_STUB IGlobalMTScript_WaitForMultipleSyncs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SignalThreadSync_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IGlobalMTScript_SignalThreadSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_TakeThreadLock_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IGlobalMTScript_TakeThreadLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ReleaseThreadLock_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IGlobalMTScript_ReleaseThreadLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_DoEvents_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_DoEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_MessageBoxTimeout_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrMessage,
    /* [in] */ long cButtons,
    /* [in] */ BSTR bstrButtonText,
    /* [in] */ long lTimeout,
    /* [in] */ long lEventInterval,
    /* [in] */ VARIANT_BOOL fCanCancel,
    /* [in] */ VARIANT_BOOL fConfirm,
    /* [retval][out] */ long *plSelected);


void __RPC_STUB IGlobalMTScript_MessageBoxTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_RunLocalCommand_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrCommand,
    /* [in] */ BSTR bstrDir,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ VARIANT_BOOL fMinimize,
    /* [defaultvalue][in] */ VARIANT_BOOL fGetOutput,
    /* [defaultvalue][in] */ VARIANT_BOOL fWait,
    /* [defaultvalue][in] */ VARIANT_BOOL fNoCrashPopup,
    /* [defaultvalue][in] */ VARIANT_BOOL fNoEnviron,
    /* [retval][out] */ long *plProcessID);


void __RPC_STUB IGlobalMTScript_RunLocalCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_GetLastRunLocalError_Proxy( 
    IGlobalMTScript * This,
    /* [retval][out] */ long *plErrorCode);


void __RPC_STUB IGlobalMTScript_GetLastRunLocalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_GetProcessOutput_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID,
    /* [retval][out] */ BSTR *pbstrData);


void __RPC_STUB IGlobalMTScript_GetProcessOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_GetProcessExitCode_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID,
    /* [retval][out] */ long *plExitCode);


void __RPC_STUB IGlobalMTScript_GetProcessExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_TerminateProcess_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID);


void __RPC_STUB IGlobalMTScript_TerminateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SendToProcess_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long lProcessID,
    /* [in] */ BSTR bstrType,
    /* [in] */ BSTR bstrData,
    /* [retval][out] */ long *plReturn);


void __RPC_STUB IGlobalMTScript_SendToProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SendMail_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrTo,
    /* [in] */ BSTR bstrCC,
    /* [in] */ BSTR bstrBCC,
    /* [in] */ BSTR bstrSubject,
    /* [in] */ BSTR bstrMessage,
    /* [defaultvalue][in] */ BSTR bstrAttachmentPath,
    /* [defaultvalue][in] */ BSTR bstrUsername,
    /* [defaultvalue][in] */ BSTR bstrPassword,
    /* [retval][out] */ long *plErrorCode);


void __RPC_STUB IGlobalMTScript_SendMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_SendSMTPMail_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrFrom,
    /* [in] */ BSTR bstrTo,
    /* [in] */ BSTR bstrCC,
    /* [in] */ BSTR bstrSubject,
    /* [in] */ BSTR bstrMessage,
    /* [in] */ BSTR bstrSMTPHost,
    /* [retval][out] */ long *plErrorCode);


void __RPC_STUB IGlobalMTScript_SendSMTPMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_ASSERT_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ VARIANT_BOOL Assertion,
    /* [in] */ BSTR Message);


void __RPC_STUB IGlobalMTScript_ASSERT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_OUTPUTDEBUGSTRING_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR Message);


void __RPC_STUB IGlobalMTScript_OUTPUTDEBUGSTRING_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_UnevalString_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR *bstrOut);


void __RPC_STUB IGlobalMTScript_UnevalString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_CopyOrAppendFile_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ BSTR bstrSrc,
    /* [in] */ BSTR bstrDst,
    /* [in] */ long nSrcOffset,
    /* [in] */ long nSrcLength,
    /* [in] */ VARIANT_BOOL fAppend,
    /* [retval][out] */ long *nSrcFilePosition);


void __RPC_STUB IGlobalMTScript_CopyOrAppendFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Sleep_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ int nTimeout);


void __RPC_STUB IGlobalMTScript_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_Reboot_Proxy( 
    IGlobalMTScript * This);


void __RPC_STUB IGlobalMTScript_Reboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_NotifyScript_Proxy( 
    IGlobalMTScript * This,
    BSTR bstrEvent,
    VARIANT vData);


void __RPC_STUB IGlobalMTScript_NotifyScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_RegisterEventSource_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ IDispatch *pDisp,
    /* [defaultvalue][in] */ BSTR bstrProgID);


void __RPC_STUB IGlobalMTScript_RegisterEventSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_UnregisterEventSource_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ IDispatch *pDisp);


void __RPC_STUB IGlobalMTScript_UnregisterEventSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_get_StatusValue_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long nIndex,
    /* [retval][out] */ long *pnStatus);


void __RPC_STUB IGlobalMTScript_get_StatusValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IGlobalMTScript_put_StatusValue_Proxy( 
    IGlobalMTScript * This,
    /* [in] */ long nIndex,
    /* [in] */ long nStatus);


void __RPC_STUB IGlobalMTScript_put_StatusValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGlobalMTScript_INTERFACE_DEFINED__ */


#ifndef __DLocalMTScriptEvents_DISPINTERFACE_DEFINED__
#define __DLocalMTScriptEvents_DISPINTERFACE_DEFINED__

/* dispinterface DLocalMTScriptEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DLocalMTScriptEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("854c316a-c854-4a77-b189-606859e4391b")
    DLocalMTScriptEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DLocalMTScriptEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DLocalMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DLocalMTScriptEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DLocalMTScriptEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DLocalMTScriptEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DLocalMTScriptEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DLocalMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DLocalMTScriptEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DLocalMTScriptEventsVtbl;

    interface DLocalMTScriptEvents
    {
        CONST_VTBL struct DLocalMTScriptEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DLocalMTScriptEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DLocalMTScriptEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DLocalMTScriptEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DLocalMTScriptEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DLocalMTScriptEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DLocalMTScriptEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DLocalMTScriptEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DLocalMTScriptEvents_DISPINTERFACE_DEFINED__ */


#ifndef __DRemoteMTScriptEvents_DISPINTERFACE_DEFINED__
#define __DRemoteMTScriptEvents_DISPINTERFACE_DEFINED__

/* dispinterface DRemoteMTScriptEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DRemoteMTScriptEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("854c3170-c854-4a77-b189-606859e4391b")
    DRemoteMTScriptEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DRemoteMTScriptEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            DRemoteMTScriptEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            DRemoteMTScriptEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            DRemoteMTScriptEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DRemoteMTScriptEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DRemoteMTScriptEventsVtbl;

    interface DRemoteMTScriptEvents
    {
        CONST_VTBL struct DRemoteMTScriptEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DRemoteMTScriptEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DRemoteMTScriptEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DRemoteMTScriptEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DRemoteMTScriptEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DRemoteMTScriptEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DRemoteMTScriptEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DRemoteMTScriptEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DRemoteMTScriptEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_LocalMTScript;

#ifdef __cplusplus

class DECLSPEC_UUID("854c316e-c854-4a77-b189-606859e4391b")
LocalMTScript;
#endif

EXTERN_C const CLSID CLSID_RemoteMTScript;

#ifdef __cplusplus

class DECLSPEC_UUID("854c316d-c854-4a77-b189-606859e4391b")
RemoteMTScript;
#endif

EXTERN_C const CLSID CLSID_RemoteMTScriptProxy;

#ifdef __cplusplus

class DECLSPEC_UUID("854c3182-c854-4a77-b189-606859e4391b")
RemoteMTScriptProxy;
#endif
#endif /* __MTScriptEngine_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\listview.c ===
//
// LISTVIEW.C
//
#include "sigverif.h"

HWND    g_hListView         = NULL;
HWND    g_hStatus           = NULL;
BOOL    g_bSortOrder[]      = { FALSE, FALSE, FALSE, FALSE, FALSE};
RECT    g_Rect;

// Initialize the image lists for the icons in the listview control.
BOOL WINAPI ListView_SetImageLists(HWND hwndList)
{
    SHFILEINFO      sfi;
    HIMAGELIST      himlSmall;
    HIMAGELIST      himlLarge;
    BOOL            bSuccess = TRUE;
    TCHAR           szDriveRoot[MAX_PATH];

    MyGetWindowsDirectory(szDriveRoot, cA(szDriveRoot));
    szDriveRoot[3] = 0;
    himlSmall = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_SMALLICON);

    himlLarge = (HIMAGELIST)SHGetFileInfo((LPCTSTR)szDriveRoot, 
                                          0,
                                          &sfi, 
                                          sizeof(SHFILEINFO), 
                                          SHGFI_SYSICONINDEX | SHGFI_LARGEICON);

    if (himlSmall && himlLarge) {
        ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);
        ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
    } else bSuccess = FALSE;

    return bSuccess;
}

//
// Insert everything from the g_App.lpFileList into the listview control.
//
void ListView_InsertItems(void)
{
    LPFILENODE  lpFileNode;
    LV_ITEM     lvi;
    TCHAR       szBuffer[MAX_PATH];
    LPTSTR      lpString;
    int         iRet;

    for (lpFileNode=g_App.lpFileList;lpFileNode;lpFileNode=lpFileNode->next) {
        if (lpFileNode->bScanned &&
            !lpFileNode->bSigned &&
            SetCurrentDirectory(lpFileNode->lpDirName)) {
            // Initialize lvi and insert the filename and icon into the first column.
            ZeroMemory(&lvi, sizeof(LV_ITEM));
            lvi.mask = LVIF_TEXT;
            lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iImage = lpFileNode->iIcon;
            lvi.lParam = (LPARAM) lpFileNode;
            lvi.iSubItem = 0;
            lvi.pszText = lpFileNode->lpFileName;
            lvi.iItem = MAX_INT;
            lvi.iItem = ListView_InsertItem(g_hListView, &lvi);

            // Insert the directory name into the second column.
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 1;
            lvi.pszText = lpFileNode->lpDirName;
            ListView_SetItem(g_hListView, &lvi);

            // Get the date format, so we are localizable...
            MyLoadString(szBuffer, IDS_UNKNOWN);
            iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT, 
                                    DATE_SHORTDATE,
                                    &lpFileNode->LastModified,
                                    NULL,
                                    NULL,
                                    0);
            if (iRet) {
                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

                if (lpString) {
                
                    iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT,
                                            DATE_SHORTDATE,
                                            &lpFileNode->LastModified,
                                            NULL,
                                            lpString,
                                            iRet);
                    
                    if (iRet) {
                        lstrcpy(szBuffer, lpString);
                    }
                    
                    FREE(lpString);
                }
            }
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 2;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            // Insert the filetype string into the fourth column.
            if (lpFileNode->lpTypeName) {
                lstrcpy(szBuffer, lpFileNode->lpTypeName);
            } else MyLoadString(szBuffer, IDS_UNKNOWN);
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 3;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);

            // Insert the version string into the fifth column.
            if (lpFileNode->lpVersion) {
                lstrcpy(szBuffer, lpFileNode->lpVersion);
            } else MyLoadString(szBuffer, IDS_NOVERSION);
            lvi.mask = LVIF_TEXT;
            lvi.iSubItem = 4;
            lvi.pszText = szBuffer;
            ListView_SetItem(g_hListView, &lvi);
        }
    }
}

//
// Initialize the listview dialog.  First, we are going to load the global icon resource.
// Then we are going to create a status window and the actual listview control.
// Then we need to add the four columns and work out their default widths.
//
BOOL ListView_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    LV_COLUMN   lvc;
    RECT        rect, rect2, rect3, rect4, rect5;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuffer2[MAX_PATH];
    INT         iCol = 0, iWidth = 0;

    // Load the global icon resource
    if (g_App.hIcon) {
        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    // Create the status window at the bottom of the dialog
    g_hStatus = CreateStatusWindow( WS_CHILD | WS_VISIBLE,
                                    NULL,
                                    hwnd,
                                    (UINT) IDC_STATUSWINDOW);

    // Load the status string and fill it in with the correct values.
    MyLoadString(szBuffer, IDS_NUMFILES);
    wsprintf(szBuffer2, szBuffer,   g_App.dwFiles, g_App.dwSigned, g_App.dwUnsigned, 
             g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    SendMessage(g_hStatus, WM_SETTEXT, (WPARAM) 0, (LPARAM) szBuffer2);

    GetWindowRect(hwnd, &g_Rect);

    // Get the windows RECT values for the dialog, the static text, and the status window.
    // We will use these values to figure out where to put the listview and the columns.
    GetWindowRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rect2);
    GetWindowRect(g_hStatus, &rect3);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rect4);

    MoveWindow( GetDlgItem(hwnd, IDCANCEL), 
                rect.right - rect2.left - (rect4.right - rect4.left) - (( 2 * (rect2.left - rect.left)) / 3),
                rect.bottom - rect.top - (( 7 * (rect4.bottom - rect4.top)) / 2),
                rect4.right - rect4.left,
                rect4.bottom - rect4.top,
                TRUE);

    //
    // Create the listview window!  I am using some really screwey logic to figure out how
    // big to make the listview and where to put it, but it seems to work.
    //
    g_hListView = CreateWindowEx(   WS_EX_CLIENTEDGE, 
                                    WC_LISTVIEW, TEXT(""), 
                                    WS_TABSTOP | WS_VSCROLL | WS_VISIBLE | WS_CHILD | WS_BORDER | 
                                    LVS_SINGLESEL | LVS_REPORT | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS,
                                    ((rect2.left - rect.left) * 2) / 3,
                                    (rect2.bottom - rect2.top) * 2,
                                    (rect.right - rect.left) - 2 * (rect2.left - rect.left),
                                    (rect.bottom - rect2.bottom) - (rect4 .bottom - rect4.top) - 3 * (rect3.bottom - rect3.top),
                                    hwnd, 
                                    (HMENU) IDC_LISTVIEW, 
                                    g_App.hInstance, 
                                    NULL);

    // If the CreateWindowEx failed, then bail.
    if (!g_hListView)
        return FALSE;

    GetWindowRect(g_hListView, &rect5);

    // Initialize the icon lists
    ListView_SetImageLists(g_hListView);

    // Create the first listview column for the icon and the file name.
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = (rect2.right - rect2.left) / 5;
    lvc.pszText = szBuffer;
    MyLoadString(szBuffer, IDS_COL_NAME);
    lvc.cchTextMax = MAX_PATH;
    ListView_InsertColumn(g_hListView, iCol++, &lvc);   

    // Create the second listview column for the directory name.
    iWidth += lvc.cx;
    lvc.cx = (rect2.right - rect2.left) / 4;
    MyLoadString(szBuffer, IDS_COL_FOLDER);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    // Create the third listview column for the date name.
    iWidth += lvc.cx;
    lvc.cx = (rect2.right - rect2.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, IDS_COL_DATE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    // Create the fourth listview column for the filetype string.
    iWidth += lvc.cx;
    lvc.cx = (rect2.right - rect2.left) / 6;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, IDS_COL_TYPE);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    // Create the fifth listview column for the version string.
    iWidth += lvc.cx;
    lvc.cx = (rect2.right - rect2.left) - iWidth - 5;
    lvc.fmt = LVCFMT_CENTER;
    MyLoadString(szBuffer, IDS_COL_VERSION);
    ListView_InsertColumn(g_hListView, iCol++, &lvc);

    // Now that the columns are set up, insert all the files in g_App.lpFileList!
    ListView_InsertItems();

    // Initialize the sorting order array to all FALSE.
    g_bSortOrder[0] = FALSE;
    g_bSortOrder[1] = FALSE;
    g_bSortOrder[2] = FALSE;
    g_bSortOrder[3] = FALSE;

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);
    SetFocus(GetDlgItem(hwnd, IDCANCEL));

    return TRUE;
}

//
// This function checks to see how big the sizing rectangle will be.  If the user is trying
// to size the dialog to less than the values in g_Rect, then we will fix the rectangle values
//
BOOL ListView_OnSizing(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    RECT    rect;
    LPRECT  lpRect = (LPRECT) lParam;
    BOOL    bRet = FALSE;

    GetWindowRect(hwnd, &rect);

    if ((lpRect->right - lpRect->left) < (g_Rect.right - g_Rect.left)) {
        lpRect->left = rect.left;
        lpRect->right = lpRect->left + (g_Rect.right - g_Rect.left);
        bRet = TRUE;
    }

    if ((lpRect->bottom - lpRect->top) < (g_Rect.bottom - g_Rect.top)) {
        lpRect->top = rect.top;
        lpRect->bottom = lpRect->top + (g_Rect.bottom - g_Rect.top);
        bRet = TRUE;
    }

    return bRet;
}

//
// This function allows us to resize the listview control and status windows when the
// user resizes the results dialog.  Thankfully, we can make everything relative using
// the RECT values for the main dialog, the static text, and the status window.
//
void ListView_ResizeWindow(HWND hwnd)
{
    RECT    rect, rect2, rect3, rect4;

    GetWindowRect(hwnd, &rect);

    if ((rect.right - rect.left) < (g_Rect.right - g_Rect.left)) {
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   g_Rect.right - g_Rect.left,
                   rect.bottom - rect.top,
                   TRUE);
    }

    if ((rect.bottom - rect.top) < (g_Rect.bottom - g_Rect.top)) {
        MoveWindow(hwnd,
                   rect.left,
                   rect.top,
                   rect.right - rect.left,
                   g_Rect.bottom - g_Rect.top,
                   TRUE);
    }

    GetWindowRect(GetDlgItem(hwnd, IDC_RESULTSTEXT), &rect2);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rect4);
    GetWindowRect(g_hStatus, &rect3);


    MoveWindow(g_hListView,
               ((rect2.left - rect.left) * 2) / 3,
               (rect2.bottom - rect2.top) * 2,
               (rect.right - rect.left) - 2 * (rect2.left - rect.left),
               (rect.bottom - rect2.bottom) - (rect4 .bottom - rect4.top) - 3 * (rect3.bottom - rect3.top),
               TRUE);

    MoveWindow(g_hStatus,
               0,
               (rect.bottom - rect.top) - (rect3.bottom - rect3.top),
               rect.right - rect.left,
               rect3.bottom - rect3.top,
               TRUE);

    MoveWindow(GetDlgItem(hwnd, IDCANCEL),
               rect.right - rect2.left - (rect4.right - rect4.left) - (( 2 * (rect2.left - rect.left)) / 3),
               rect.bottom - rect.top - ((7 * (rect4.bottom - rect4.top)) / 2),
               rect4.right - rect4.left,
               rect4.bottom - rect4.top,
               TRUE);
}

//
// This function is a callback that returns a value for ListView_SortItems.
// ListView_SortItems wants a negative, zero, or positive number.
// Since CompareString returns 1,2,3 we just subtract 2 from the return value.
//
// We use the g_bSortOrder array to figure out which way we have sorted in the past.
//
// Warning: we don't check for error values from CompareString
//
int CALLBACK ListView_CompareNames(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPFILENODE  lpFileNode1;
    LPFILENODE  lpFileNode2;
    FILETIME    FileTime1, FileTime2;
    int         iResult = 2;

    //
    // Depending on the sort order, we swap the order of comparison
    //
    if (g_bSortOrder[lParamSort]) {
        lpFileNode2 = (LPFILENODE) lParam1;
        lpFileNode1 = (LPFILENODE) lParam2;
    } else {
        lpFileNode1 = (LPFILENODE) lParam1;
        lpFileNode2 = (LPFILENODE) lParam2;
    }

    switch (lParamSort) {
    // We are comparing the file names
    case 0: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpFileName, 
                                    -1, 
                                    lpFileNode2->lpFileName,
                                    -1);
        break;

        // We are comparing the directory names
    case 1: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpDirName, 
                                    -1, 
                                    lpFileNode2->lpDirName,
                                    -1);
        break;

        // We are comparing the LastWriteTime's between the two files.
    case 2: SystemTimeToFileTime(&lpFileNode1->LastModified, &FileTime1);
        SystemTimeToFileTime(&lpFileNode2->LastModified, &FileTime2);
        iResult = CompareFileTime(&FileTime1, &FileTime2);
        return iResult;

        break;

        // We are comparing the filetype strings
    case 3: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpTypeName, 
                                    -1, 
                                    lpFileNode2->lpTypeName,
                                    -1);
        break;

        // We are comparing the version strings
    case 4: iResult = CompareString(LOCALE_SYSTEM_DEFAULT, 
                                    NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                    lpFileNode1->lpVersion, 
                                    -1, 
                                    lpFileNode2->lpVersion,
                                    -1);
        break;
    }

    return(iResult - 2);
}

//
// This function handles the clicks on the column headers and calls ListView_SortItems with the
// ListView_CompareNames callback previously defined.  It then toggles the sortorder for that column.
//
LRESULT ListView_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR       *lpnmhdr = (NMHDR *) lParam;
    NM_LISTVIEW *lpnmlv = (NM_LISTVIEW *) lParam;

    switch (lpnmhdr->code) {
    case LVN_COLUMNCLICK:
        switch (lpnmlv->iSubItem) {
        case 0: 
        case 1:
        case 2: 
        case 3: 
        case 4: ListView_SortItems(lpnmlv->hdr.hwndFrom, ListView_CompareNames, (LPARAM) lpnmlv->iSubItem);
            g_bSortOrder[lpnmlv->iSubItem] = !(g_bSortOrder[lpnmlv->iSubItem]);
            break;
        }
        break;
    }

    return 0;
}

//
// The only thing we look for here is the IDCANCEL if the user hit ESCAPE
//
void ListView_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {
    case IDCANCEL:
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        break;
    }
}

INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, ListView_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, ListView_OnCommand);

    case WM_NOTIFY:
        return ListView_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_CLOSE:
        if (g_hStatus) {
            DestroyWindow(g_hStatus);
            g_hStatus = NULL;
        }

        if (g_hListView) {
            DestroyWindow(g_hListView);
            g_hListView = NULL;
        }

        EndDialog(hwnd, ID_CLOSE);
        break;

    case WM_SIZING:
        fProcessed = ListView_OnSizing(hwnd, wParam, lParam);
        break;

    case WM_SIZE:
        ListView_ResizeWindow(hwnd);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\progress.c ===
/*****************************************************************************
 *
 *  Progress.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Our private progress control (because commctrl might be damanged)
 *
 *  Contents:
 *
 *      Progress_Init
 *
 *****************************************************************************/
#include "sigverif.h"

/***************************************************************************
 *
 *  GWL_* for Progress goo.
 *
 ***************************************************************************/

#define GWL_CUR             GWLP_USERDATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | Progress_GetRectPos |
 *
 *          Compute the position within the drawing rectangle that
 *          corresponds to the current position.
 *
 *          This is basically a MulDiv, except that we don't let the
 *          bar get all the way to 100% unless it really means it.
 *
 *
 ***************************************************************************/

int Progress_GetRectPos(int cx, int iCur, int iMax)
{
    int iRc;

    if (iCur != iMax) {
        iRc = MulDiv(cx, iCur, iMax);
    } else {
        iRc = cx;
    }

    return iRc;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnPaint |
 *
 *          Draw the first part in the highlight colors.
 *
 *          Draw the second part in the 3dface colors.
 *
 ***************************************************************************/

void Progress_OnPaint(HWND hwnd)
{
    HDC hdc;
    PAINTSTRUCT ps;

    hdc = BeginPaint(hwnd, &ps);
    if (hdc) {
        UINT taPrev;
        RECT rc;
        int cx;
        COLORREF clrTextPrev, clrBackPrev;
        int iCur, iMax, iPct;
        int ctch;
        HFONT hfPrev;
        TCHAR tsz[256];
        SIZE size;

        /*
         *  Set up the DC generically.
         */
        taPrev = SetTextAlign(hdc, TA_CENTER | TA_TOP);
        hfPrev = SelectFont(hdc, GetWindowFont(GetParent(hwnd)));

        /*
         *  Set up the colors for the left-hand side.
         */
        clrTextPrev = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrBackPrev = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));

        /*
         *  Now do some math.
         */
        GetClientRect(hwnd, &rc);

        cx = rc.right;

        iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

        if (iMax == 0) 
        {
            iMax = 1;           /* Avoid divide by zero */
        }

        if (iCur > 0) 
        {
            iPct = (iCur * 100) / iMax;
            if (iPct < 1)
                iPct = 1;
        } else iPct = 0;

        rc.right = Progress_GetRectPos(cx, iCur, iMax);

        // Update the percentage text in the progress bar.
        wsprintf(tsz, TEXT("%d%%"), iPct);
        for(ctch=0;tsz[ctch];ctch++);

        /*
         *  Draw the left-hand side.
         */
        //ctch = GetWindowText(hwnd, tsz, cA(tsz));
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size))
        {
            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        } else {
            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        /*
         *  Now set up for the right-hand side.
         */
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

        rc.left = rc.right;
        rc.right = cx;

        /*
         *  Draw the right-hand side.
         */
        if (!GetTextExtentPoint32(hdc, tsz, ctch, &size))
        {
            ExtTextOut( hdc, cx/2, 1, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        } else {
            ExtTextOut( hdc, cx/2, (rc.bottom - rc.top - size.cy + 1) / 2, 
                        ETO_CLIPPED | ETO_OPAQUE,
                        &rc, tsz, ctch, 0);
        }

        SetBkColor(hdc, clrBackPrev);
        SetTextColor(hdc, clrTextPrev);
        SelectFont(hdc, hfPrev);
        SetTextAlign(hdc, taPrev);

        EndPaint(hwnd, &ps);
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_OnSetPos |
 *
 *          Update the state and invalidate the section that is affected.
 *
 ***************************************************************************/

void Progress_OnSetPos(HWND hwnd, WPARAM wp)
{
    int iCur, iMax;
    RECT rc;
    LONG lState = GetWindowLong(hwnd, GWL_CUR);


    GetClientRect(hwnd, &rc);

    iCur = LOWORD(GetWindowLong(hwnd, GWL_CUR));
    iMax = HIWORD(GetWindowLong(hwnd, GWL_CUR));

    if (iMax == 0) {
        iMax = 1;           /* Avoid divide by zero */
    }

    rc.left = Progress_GetRectPos(rc.right, iCur, iMax);
    rc.right = Progress_GetRectPos(rc.right, (int)wp, iMax);

    InvalidateRect(hwnd, 0, 0);

    SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp,HIWORD(lState)));
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | Progress_WndProc |
 *
 *          There really isn't much to do.
 *
 *          The string is our window text (which Windows manages for us).
 *
 *          The progress bar itself is kept in the high/low words of
 *          our GWL_USERDATA.
 *
 *          HIWORD(GetWindowLong(GWL_USERDATA)) = maximum
 *          LOWORD(GetWindowLong(GWL_USERDATA)) = current value
 *
 ***************************************************************************/

LRESULT CALLBACK
Progress_WndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {

    case WM_PAINT:
        Progress_OnPaint(hwnd);
        return 0;

    /*
     *  When the range resets, invalidate so we repaint.
     *
     *  wp = new current pos
     *  lp = new range
     */
    case PBM_SETRANGE:
        lp = HIWORD(lp);
        SetWindowLong(hwnd, GWL_CUR, MAKELONG(wp, lp));
        /* FALLTHROUGH */

    /*
     *  When our text changes, invalidate so we repaint.
     */
    //case WM_SETTEXT:
        //InvalidateRect(hwnd, 0, 0);
        //break;

    case PBM_SETPOS:
        Progress_OnSetPos(hwnd, wp);
        break;

    case PBM_DELTAPOS:
        lp = LOWORD(GetWindowLong(hwnd, GWL_CUR));
        Progress_OnSetPos(hwnd, wp + lp);
        break;

    case WM_ERASEBKGND:
        return 0;
    }

    return DefWindowProc(hwnd, wm, wp, lp);
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Progress_InitRegisterClass |
 *
 *          Register our window classes.
 *
 ***************************************************************************/

void Progress_InitRegisterClass(void)
{
    WNDCLASS wc;

    /*
     *  Progress control.
     */
    wc.style = 0;
    wc.lpfnWndProc = Progress_WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = cbX(DWORD);
    wc.hInstance = g_App.hInstance;
    wc.hIcon = 0;
    wc.hCursor = LoadCursor(0, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND);
    wc.lpszMenuName = 0;
    wc.lpszClassName = TEXT("progress");

    RegisterClass(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\sigverif.h ===
//
//  SIGVERIF.H
//
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <tchar.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <winspool.h>
#include <imagehlp.h>
#ifdef UNICODE
//
// On NT, we can just include CAPI.H
//
#include <capi.h>
#else
//
// For Win9x we need to do the following hacks before including the NT headers
//
#define SetClassLongPtr SetClassLong
#define DWLP_MSGRESULT  DWL_MSGRESULT
#define GCLP_HICON      GCL_HICON
#define LONG_PTR        LONG
#define ULONG_PTR       ULONG
#define INT_PTR         INT
#include <wincrypt.h>
#include <sipbase.h>
#include <mscat.h>
#include <mssip.h>
#include <wintrust.h>
#endif
#include <softpub.h>
#include "resource.h"

// Macros and pre-defined values
#define     cbX(X)      sizeof(X)
#define     cA(a)       (cbX(a)/cbX(a[0]))
#define     MALLOC(x)   HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (x))
#define     FREE(x)     if (x) { HeapFree(GetProcessHeap(), 0, (x)); x = NULL; }
#define     EXIST(x)    (GetFileAttributes(x) != 0xFFFFFFFF)
#define     MAX_INT     0x7FFFFFFF
#define     HASH_SIZE   100
#define     NUM_PAGES   2

#define SIZECHARS(x) (sizeof((x))/sizeof(TCHAR))

// Registry key/value names for storing previous settings
#define     SIGVERIF_HKEY       HKEY_CURRENT_USER
#define     SIGVERIF_KEY        TEXT("Software\\Microsoft\\Sigverif")
#define     SIGVERIF_FLAGS      TEXT("Flags")
#define     SIGVERIF_LOGNAME    TEXT("Logname")

//
// NT5 allows EnumPrinterDrivers to pass in "All" to get every installed driver.
// Win98 doesn't support this, so assume NT is always Unicode and Win98 is ANSI.
//
#ifdef UNICODE
#define SIGVERIF_PRINTER_ENV	TEXT("All")
#else
#define SIGVERIF_PRINTER_ENV	NULL
#endif

// This structure holds all the information for a specific file.
typedef struct tagFileNode
{
    LPTSTR          lpFileName;
    LPTSTR          lpDirName;
    LPTSTR          lpVersion;
    LPTSTR          lpCatalog;
    LPTSTR          lpSignedBy;
    LPTSTR          lpTypeName;
    INT             iIcon;
    BOOL            bSigned;
    BOOL            bScanned;
    SYSTEMTIME      LastModified;
    struct  tagFileNode *next;
} FILENODE, *LPFILENODE;

// This structure is used by walkpath to keep track of subdirectories
typedef struct tagDirNode {
    TCHAR   DirName[MAX_PATH];
    struct  tagDirNode *next;
} DIRNODE, *LPDIRNODE;

// This structure is used when we walk the devicemanager list.
typedef struct _DeviceTreeNode 
{
    struct _DeviceTreeNode *Child;
    struct _DeviceTreeNode *Sibling;
    DEVINST    DevInst;
    TCHAR      Driver[MAX_PATH];
} DEVTREENODE, *PDEVTREENODE;

typedef struct _DeviceTreeData 
{
    HDEVINFO hDeviceInfo;
    DEVTREENODE RootNode;
} DEVICETREE, *PDEVICETREE;

// This is our global data structure that hold our global variables.
typedef struct tagAppData
{
    HWND        hDlg;
    HWND        hLogging;
    HWND        hSearch;
    HICON       hIcon;
    HINSTANCE   hInstance;
    TCHAR       szScanPath[MAX_PATH];
    TCHAR       szScanPattern[MAX_PATH];
    TCHAR       szAppDir[MAX_PATH];
    TCHAR       szLogFile[MAX_PATH];
    TCHAR       szLogDir[MAX_PATH];
    TCHAR       szWinDir[MAX_PATH];
    LPFILENODE  lpFileList;
    LPFILENODE  lpFileLast;
    HCATADMIN   hCatAdmin;
    DWORD       dwFiles;
    DWORD       dwSigned;
    DWORD       dwUnsigned;
    BOOL        bNoBVT;
    BOOL        bNoDev;
    BOOL        bNoPRN;
    BOOL        bOverwrite;
    BOOL        bLoggingEnabled;
    BOOL        bLogToRoot;
    BOOL        bFullSystemScan;
    BOOL        bScanning;
    BOOL        bStopScan;
    BOOL        bUserScan;
    BOOL        bSubFolders;
} GAPPDATA, *LPGAPPDATA;

// Global function prototypes
BOOL BrowseForFolder(HWND hwnd, LPTSTR lpszBuf);
void BuildFileList(LPTSTR lpPathName);
BOOL VerifyFileList(void);
BOOL VerifyFileNode(LPFILENODE lpFileNode);
void MyLoadString(LPTSTR lpString, UINT uId);
void MyMessageBox(LPTSTR lpString);
void MyErrorBox(LPTSTR lpString);
void MyErrorBoxId(UINT uId);
void MyMessageBoxId(UINT uId);
UINT MyGetWindowsDirectory(LPTSTR lpDirName, UINT uSize);
LPTSTR MyStrStr(LPTSTR lpString, LPTSTR lpSubString);
INT_PTR CALLBACK Details_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ListView_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LogFile_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LPFILENODE CreateFileNode(LPTSTR lpDirectory, LPTSTR lpFileName);
BOOL IsFileAlreadyInList(LPTSTR lpDirName, LPTSTR lpFileName);
void SigVerif_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext);
void AdvancedPropertySheet(HWND hwnd);
void InsertFileNodeIntoList(LPFILENODE lpFileNode);
void DestroyFileList(void);
void DestroyFileNode(LPFILENODE lpFileNode);
void PrintFileList(void);
void Progress_InitRegisterClass(void);
void BuildDriverFileList(void);
void BuildPrinterFileList(void);
void BuildCoreFileList(void);

//
// Context-Sensitive Help/Identifiers specific to SigVerif
//
#define SIGVERIF_HELPFILE                       TEXT("SIGVERIF.HLP")
#define WINDOWS_HELPFILE                        TEXT("WINDOWS.HLP")
#define IDH_SIGVERIF_SEARCH_CHECK_SYSTEM        1000
#define IDH_SIGVERIF_SEARCH_LOOK_FOR            1010
#define IDH_SIGVERIF_SEARCH_SCAN_FILES          1020
#define IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER      1030
#define IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS  1040
#define IDH_SIGVERIF_LOGGING_ENABLE_LOGGING     1050
#define IDH_SIGVERIF_LOGGING_APPEND             1060
#define IDH_SIGVERIF_LOGGING_OVERWRITE          1070
#define IDH_SIGVERIF_LOGGING_FILENAME           1080
#define IDH_SIGVERIF_LOGGING_VIEW_LOG           1090

//
// Context-Sensitive Help Identifiers for Browse button
//
#define IDH_BROWSE  28496

//
// g_App is allocated in SIGVERIF.C, so everywhere else we want to make it extern
//
#ifndef SIGVERIF_DOT_C
extern GAPPDATA g_App;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\sigverif.c ===
//
//  SIGVERIF.C
//
#define SIGVERIF_DOT_C
#include "sigverif.h"

// Allocate our global data structure
GAPPDATA    g_App;

//
//  Load a resource string into a buffer that is assumed to be MAX_PATH bytes.
//
void MyLoadString(LPTSTR lpString, UINT uId)
{
    LoadString(g_App.hInstance, uId, lpString, MAX_PATH);
}

//
//  Pop an OK messagebox with a specific string
//
void MyMessageBox(LPTSTR lpString)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, IDS_MSGBOX);
    MessageBox(g_App.hDlg, lpString, lpBuffer, MB_OK);
}

//
//  Pop an OK messagebox with a resource string ID
//
void MyMessageBoxId(UINT uId)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, uId);
    MyMessageBox(lpBuffer);
}

//
//  Pop an error messagebox with a specific string
//
void MyErrorBox(LPTSTR lpString)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, IDS_ERRORBOX);
    MessageBox(g_App.hDlg, lpString, lpBuffer, MB_OK);
}

//
//  Pop an error messagebox with a resource string ID
//
void MyErrorBoxId(UINT uId)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpBuffer = szBuffer;

    MyLoadString(lpBuffer, uId);
    MyErrorBox(lpBuffer);
}

//
// Since Multi-User Windows will give me back a Profile directory, I need to get the real Windows directory
// Dlg_OnInitDialog initializes g_App.szWinDir with the real Windows directory, so I just use that.
//
UINT MyGetWindowsDirectory(LPTSTR lpDirName, UINT uSize)
{
    UINT  uRet = 0;

    if (lpDirName)
    {
        lstrcpy(lpDirName, g_App.szWinDir);
        uRet = lstrlen(lpDirName);
    }

    return uRet;
}

//
//  Initialization of main dialog.
//
BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwDisp, dwType, dwFlags, cbData;
    TCHAR   szBuffer[MAX_PATH];

    // Initialize global hDlg to current hwnd.
    g_App.hDlg = hwnd;

    // Set the window class to have the icon in the resource file
    if (g_App.hIcon)
    {
        SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    // Make sure the IDC_STATUS control is hidden until something happens.
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    // Set the range for the custom progress bar to 0-100.
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETRANGE, (WPARAM) 0, (LPARAM) MAKELPARAM(0, 100));

    // Set the global lpLogName to the one that's given in the resource file
    MyLoadString(g_App.szLogFile, IDS_LOGNAME);

    //
    // Figure out what the real Windows directory is and store it in g_App.szWinDir
    // This is required because Hydra makes GetWindowsDirectory return a PROFILE directory
    //
    // We store the original CurrentDirectory in szBuffer so we can restore it after this hack.
    // Next we switch into the SYSTEM/SYSTEM32 directory and then into its parent directory.
    // This is what we want to store in g_App.szWinDir.
    //
    GetCurrentDirectory(MAX_PATH, szBuffer);
    GetSystemDirectory(g_App.szWinDir, MAX_PATH);
    SetCurrentDirectory(g_App.szWinDir);
    SetCurrentDirectory(TEXT(".."));
    GetCurrentDirectory(MAX_PATH, g_App.szWinDir);
    SetCurrentDirectory(szBuffer);

    // Set the global search folder to %WinDir%
    MyGetWindowsDirectory(g_App.szScanPath, MAX_PATH);

    // Set the global search pattern to "*.*"
    MyLoadString(g_App.szScanPattern, IDS_ALL);

    // Reset the progress bar back to zero percent
    SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);

    // By default, we want to turn logging and set the logging mode to OVERWRITE
    g_App.bLoggingEnabled   = TRUE;
    g_App.bOverwrite        = TRUE;

    //
    // Look in the registry for any settings from the last SigVerif session
    //
    lRes = RegCreateKeyEx(  SIGVERIF_HKEY,
                            SIGVERIF_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisp);

    if (lRes == ERROR_SUCCESS)
    {
        // If all we did was create a new key, then there must not be any data.  Just close the key.
        if (dwDisp == REG_CREATED_NEW_KEY)
        {
            RegCloseKey(hKey);
        }
        else // Otherwise, query the values and set any values that we found.
        {
            cbData = sizeof(DWORD);
            lRes = RegQueryValueEx( hKey,
                                    SIGVERIF_FLAGS,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) &dwFlags,
                                    &cbData);
            if (lRes == ERROR_SUCCESS)
            {
                g_App.bLoggingEnabled   = (dwFlags & 0x1);
                g_App.bOverwrite        = (dwFlags & 0x2);
            }

            cbData = MAX_PATH;
            lRes = RegQueryValueEx( hKey,
                                    SIGVERIF_LOGNAME,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) szBuffer,
                                    &cbData);
            if (lRes == ERROR_SUCCESS && dwType == REG_SZ)
            {
                lstrcpy(g_App.szLogFile, szBuffer);
            }

            RegCloseKey(hKey);
        }
    }

    // Get the startup directory of SigVerif
    GetCurrentDirectory(MAX_PATH, g_App.szAppDir);

    //
    // Check if the user specified /NOBVT, /NODEV, or /NOPRN
    //
    MyLoadString(szBuffer, IDS_NOBVT);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bNoBVT = TRUE;

    MyLoadString(szBuffer, IDS_NODEV);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bNoDev = TRUE;

    MyLoadString(szBuffer, IDS_NOPRN);
    if (MyStrStr(GetCommandLine(), szBuffer))
        g_App.bNoPRN = TRUE;

    //
    // If the user specified the "LogDir" flag, we want to log the signed and unsigned filenames to the root.
    //
    MyLoadString(szBuffer, IDS_LOGDIR);
    lstrcat(szBuffer, TEXT(":"));

    if (MyStrStr(GetCommandLine(), szBuffer))
    {
        LPTSTR lpString;

        lpString = MyStrStr(GetCommandLine(), szBuffer);
        
        if (lpString) {
        
            lpString += lstrlen(szBuffer);
        }

        if (lpString && *lpString) {

            lstrcpy(g_App.szLogDir, lpString);
            lpString = MyStrStr(g_App.szLogDir, TEXT(" "));
            
            if (lpString) {

                *lpString = TEXT('\0');
            }
        }

        g_App.bLogToRoot = TRUE;
    
    } else {

        MyLoadString(szBuffer, IDS_LOGDIR);
        
        if (MyStrStr(GetCommandLine(), szBuffer)) {
        
            g_App.bLogToRoot = TRUE;
        }
    }

    //
    // If the user specified the FullSystemScan flag, we want to scan the entire system drive and log the results.
    //
    MyLoadString(szBuffer, IDS_FULLSCAN);
    lstrcat(szBuffer, TEXT(":"));
    if (MyStrStr(GetCommandLine(), szBuffer))
    {
        g_App.bFullSystemScan     = TRUE;
        g_App.bLoggingEnabled     = TRUE;
        g_App.bLogToRoot          = TRUE;
        g_App.bUserScan           = TRUE;
        g_App.bSubFolders         = TRUE;
        lstrcpy(g_App.szScanPath, MyStrStr(GetCommandLine(), szBuffer) + lstrlen(szBuffer));

        // Now that everything is set up, simulate a click to the START button...
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
    }
    else
    {
        //
        // If the user specified the FullSystemScan flag, we want to scan the entire system drive and log the results.
        //
        MyLoadString(szBuffer, IDS_FULLSCAN);
        if (MyStrStr(GetCommandLine(), szBuffer))
        {
            g_App.bFullSystemScan     = TRUE;
            g_App.bLoggingEnabled     = TRUE;
            g_App.bLogToRoot          = TRUE;
            g_App.bUserScan           = TRUE;
            g_App.bSubFolders         = TRUE;
            *(g_App.szScanPath + 3)   = 0;

            // Now that everything is set up, simulate a click to the START button...
            PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
        }
    }

    //
    // If the user specified the DefaultSystemScan flag, we want to scan the entire system drive and log the results.
    //
    MyLoadString(szBuffer, IDS_DEFSCAN);
    if (MyStrStr(GetCommandLine(), szBuffer))
    {
        g_App.bFullSystemScan     = TRUE;       
        g_App.bLoggingEnabled     = TRUE;
        g_App.bLogToRoot          = TRUE;

        // Now that everything is set up, simulate a click to the START button...
        PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(ID_START, 0), (LPARAM) 0);
    }

    return TRUE;
}

//
//  Build file list according to dialog settings, then verify the files in the list
//
void WINAPI ProcessFileList(void)
{
    DWORD dwCount = 0;
    TCHAR szBuffer[MAX_PATH];

    // Set the scanning flag to TRUE, so we don't double-scan
    g_App.bScanning = TRUE;

    // Change the "Start" to "Stop"
    MyLoadString(szBuffer, IDS_STOP);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), FALSE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), FALSE);

    // Display the text that says "Building file list..."
    MyLoadString(szBuffer, IDS_STATUS_BUILD);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    // Hide the IDC_INFOTEXT text item so it doesn't cover IDC_STATUS
    //ShowWindow(GetDlgItem(g_App.hDlg, IDC_INFOTEXT), SW_HIDE);

    // Make sure the IDC_STATUS text item visible
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_SHOW);

    // Free any memory that we may have allocated for the g_App.lpFileList
    DestroyFileList();

    // Now actually build the g_App.lpFileList list given the dialog settings
    if (g_App.bUserScan)
    {
        BuildFileList(g_App.szScanPath);
    }
    else
    {
        if (!g_App.bNoBVT && !g_App.bStopScan)
            BuildCoreFileList();
        if (!g_App.bNoDev && !g_App.bStopScan)
            BuildDriverFileList();
        if (!g_App.bNoPRN && !g_App.bStopScan)
            BuildPrinterFileList();
    }

    // Hide the text that said "Building file list..."
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_BUILDLIST), SW_HIDE);

    // Check if there is even a file list to verify.
    if (g_App.lpFileList)
    {
        if (!g_App.bStopScan)
        {
            // Display the "Scanning File List..." text
            MyLoadString(szBuffer, IDS_STATUS_SCAN);
            SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

            // Reset the progress bar back to zero percent while it's invisible.
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);

            //
            // WooHoo! Let's display the progress bar and start cranking on the file list!
            //
            ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_SHOW);
            VerifyFileList();
            ShowWindow(GetDlgItem(g_App.hDlg, IDC_PROGRESS), SW_HIDE);
        }
    }
    else 
    {
        //
        // The IDC_NOTMS code displays it's own error message, so only display 
        // an error dialog if we are doing a System Integrity Scan
        //
        if (!g_App.bStopScan && !g_App.bUserScan)
        {
            MyMessageBoxId(IDS_NOSYSTEMFILES);
        }
    }

    // Disable the start button while we clean up the g_App.lpFileList
    EnableWindow(GetDlgItem(g_App.hDlg, ID_START), FALSE);

    if (!g_App.bStopScan)
    {
        // Display the text that says "Writing Log File..."
        MyLoadString(szBuffer, IDS_STATUS_LOG);
        SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

        // Write the results to the log file
        PrintFileList();
    } 
    else 
    {
        // If the user clicked STOP, let them know about it.
        MyMessageBoxId(IDS_SCANSTOPPED);
    }

    // Display the text that says "Freeing File List..."
    MyLoadString(szBuffer, IDS_STATUS_FREE);
    SetDlgItemText(g_App.hDlg, IDC_STATUS, szBuffer);

    // Free all the memory that we allocated for the g_App.lpFileList
    DestroyFileList();

    // Hide the IDC_STATUS text item so it doesn't cover IDC_STATUS
    ShowWindow(GetDlgItem(g_App.hDlg, IDC_STATUS), SW_HIDE);

    // Change the "Stop" button back to "Start"
    MyLoadString(szBuffer, IDS_START);
    SetDlgItemText(g_App.hDlg, ID_START, szBuffer);

    EnableWindow(GetDlgItem(g_App.hDlg, ID_START), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, ID_ADVANCED), TRUE);
    EnableWindow(GetDlgItem(g_App.hDlg, IDCANCEL), TRUE);

    // Clear the scanning flag
    g_App.bScanning = FALSE;
    g_App.bStopScan = FALSE;

    //
    // If the user started SigVerif with the FullSystemScan flag, then we exit.
    //
    if (g_App.bFullSystemScan)
    {
        PostMessage(g_App.hDlg, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
    }
}

//  Spawns a thread to do the scan so the GUI remains responsive.
void Dlg_OnPushStartButton(HWND hwnd)
{
    HANDLE hThread;
    DWORD dwThreadId;

    // Check if we are already scanning... if so, bail.
    if (g_App.bScanning)
        return;

    // Create a thread where Search_ProcessFileList can go without tying up the GUI thread.
    hThread = CreateThread(NULL, 
                           0, 
                           (LPTHREAD_START_ROUTINE) ProcessFileList, 
                           0, 
                           0, 
                           &dwThreadId);
}

//  Handle any WM_COMMAND messages sent to the search dialog
void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id) 
    {
        //
        //  The user clicked ID_START, so if we aren't scanning start scanning.
        //  If we are scanning, then stop the tests because the button actually says "Stop"
        //
        case ID_START:
            if (!g_App.bScanning)
            {
                Dlg_OnPushStartButton(hwnd);
            } else if (!g_App.bStopScan)
                        g_App.bStopScan = TRUE;
            break;

        //
        //  The user clicked IDCANCEL, so if the tests are running try to stop them before exiting.
        //
        case IDCANCEL:  
            if (g_App.bScanning)
            {
                g_App.bStopScan = TRUE;
            } else SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;
        
        //  Pop up the IDD_SETTINGS dialog so the user can change their log settings.
        case ID_ADVANCED:
            if (!g_App.bScanning)
            {
                AdvancedPropertySheet(hwnd);
            }
            break;
    }
}

void SigVerif_Help(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL bContext)
{
    static DWORD SigVerif_HelpIDs[] = 
    { 
        IDC_SCAN,           IDH_SIGVERIF_SEARCH_CHECK_SYSTEM, 
        IDC_NOTMS,          IDH_SIGVERIF_SEARCH_LOOK_FOR,
        IDC_TYPE,           IDH_SIGVERIF_SEARCH_SCAN_FILES,
        IDC_FOLDER,         IDH_SIGVERIF_SEARCH_LOOK_IN_FOLDER,
        IDC_SUBFOLDERS,     IDH_SIGVERIF_SEARCH_INCLUDE_SUBFOLDERS,
        IDC_ENABLELOG,      IDH_SIGVERIF_LOGGING_ENABLE_LOGGING, 
        IDC_APPEND,         IDH_SIGVERIF_LOGGING_APPEND,
        IDC_OVERWRITE,      IDH_SIGVERIF_LOGGING_OVERWRITE,
        IDC_LOGNAME,        IDH_SIGVERIF_LOGGING_FILENAME,
        IDC_VIEWLOG,        IDH_SIGVERIF_LOGGING_VIEW_LOG,
        0,0 
    };

    static DWORD Windows_HelpIDs[] = 
    { 
        ID_BROWSE,      IDH_BROWSE,
        0,0 
    };

    HWND hItem = NULL;
    LPHELPINFO lphi = NULL;
    POINT point;

    switch (uMsg)
    {
        case WM_HELP:
            lphi = (LPHELPINFO) lParam;
            if (lphi && (lphi->iContextType == HELPINFO_WINDOW))   // must be for a control
                hItem = (HWND) lphi->hItemHandle;
            break;
        
        case WM_CONTEXTMENU:
            hItem = (HWND) wParam;
            point.x = GET_X_LPARAM(lParam);
            point.y = GET_Y_LPARAM(lParam);
            if (ScreenToClient(hwnd, &point))
            {
                hItem = ChildWindowFromPoint(hwnd, point);
            }
            break;
    }

    if (hItem)
    {
        if (GetWindowLong(hItem, GWL_ID) == ID_BROWSE)
        {
            WinHelp(hItem,
                    (LPCTSTR) WINDOWS_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) Windows_HelpIDs);
        }
        else
        {
            WinHelp(hItem,
                    (LPCTSTR) SIGVERIF_HELPFILE,
                    (bContext ? HELP_CONTEXTMENU : HELP_WM_HELP),
                    (ULONG_PTR) SigVerif_HelpIDs);
        }
    }
}

//
//  The main dialog procedure.  Needs to handle WM_INITDIALOG, WM_COMMAND, and WM_CLOSE/WM_DESTROY.
//
INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg,
                         WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) 
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Dlg_OnCommand);

        case WM_CLOSE:  
            if (g_App.bScanning)
                g_App.bStopScan = TRUE;
            else 
                EndDialog(hwnd, IDCANCEL);
            break;  

        default: fProcessed = FALSE;
    }

    return fProcessed;
}

//
//  Program entry point.  Set up for creation of IDD_DIALOG.
//
WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                LPSTR lpszCmdParam, int nCmdShow)
{
    HWND hwnd;
    TCHAR szAppName[MAX_PATH];

    // Zero-Initialize our global data structure
    ZeroMemory(&g_App, sizeof(GAPPDATA));

    // Initialize global hInstance variable
    g_App.hInstance = hInstance;

    // Look for any existing instances of SigVerif...
    MyLoadString(szAppName, IDS_SIGVERIF);
    hwnd = FindWindow(NULL, szAppName);
    if (!hwnd)
    {
        // We definitely need this for the progress bar, and maybe other stuff too.
        InitCommonControls();

        // Register the custom control we use for the progress bar
        Progress_InitRegisterClass();

        // Load the icon from the resource file that we will use everywhere
        g_App.hIcon = LoadIcon(g_App.hInstance, MAKEINTRESOURCE(IDI_ICON1));

        // Create the IDD_DIALOG and use DlgProc as the main procedure
        DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG), NULL, DlgProc);

        // Free the icon
        if (g_App.hIcon) {
            DestroyIcon(g_App.hIcon);
        }
    } 
    else 
    {
        // If there is already an instance of SigVerif running, make that one foreground and we exit.
        SetForegroundWindow(hwnd);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sigverif.rc
//
#define IDS_COL_NAME                    1
#define IDS_COL_FOLDER                  2
#define IDS_COL_SIZE                    3
#define IDS_COL_TYPE                    4
#define IDS_COL_VERSION                 5
#define IDS_COL_SIGNEDBY                6
#define IDS_COL_DATE                    7
#define IDS_KB                          8
#define IDS_NOPROBLEMS                  9
#define IDS_ALLSIGNED                   10
#define IDS_MSGBOX                      11
#define IDS_ERRORBOX                    12
#define IDS_NUMFILES                    13
#define IDS_SIGNED                      14
#define IDS_NOTSIGNED                   15
#define IDS_NOFILES                     16
#define IDS_STOP                        17
#define IDS_START                       18
#define IDS_ALL                         19
#define IDS_EXE                         20
#define IDS_SYS                         21
#define IDS_OCX                         22
#define IDS_DLL                         23
#define IDS_DRV                         24
#define IDS_BADDIR                      25
#define IDS_SELECTDIR                   29
#define IDS_SCANSTOPPED                 30
#define IDS_NOVERSION                   31
#define IDS_LOGNAME                     32
#define IDS_BADLOGNAME                  33
#define IDS_CANTOPENLOGFILE             34
#define IDS_LOGHEADER1                  35
#define IDS_LOGHEADER2                  36
#define IDS_LOGHEADER3                  37
#define IDS_LOGHEADER4                  38
#define IDS_LOGHEADER5                  39
#define IDS_LOGHEADER6                  40
#define IDS_LOGHEADER7                  41
#define IDS_DIR                         42
#define IDS_VERSION                     43
#define IDS_STRING                      44
#define IDS_OSPLATFORM                  45
#define IDS_OSVERSION                   46
#define IDS_WINNT                       47
#define IDS_WIN9X                       48
#define IDS_WIN3X                       49
#define IDS_UNKNOWN                     50
#define IDS_NA                          51
#define IDS_LINEFEED                    52
#define IDS_SPACES                      53
#define IDS_FILETYPE                    54
#define IDS_FILE                        55
#define IDS_QUESTIONMARK                56
#define IDS_SYSTEMROOT                  57
#define IDS_LOGDIR                      58
#define IDS_NOSYSTEMFILES               59
#define IDS_REG_SERVICES                60
#define IDS_REG_IMAGEPATH               61
#define IDS_REG_CLASS                   62
#define IDS_REG_INFSECTION              63
#define IDS_REG_INFPATH                 64
#define IDS_COPYFILES                   65
#define IDS_COREFILELIST                66
#define IDS_COREFILELIST_NOTSIGNED      67
#define IDS_MASTERFILELIST              68
#define IDS_LOGHEADER8                  69
#define IDS_STRING_LINEFEED             70
#define IDS_INFPATH                     71
#define IDS_REG_INFSECTIONEXT           72
#define IDS_TOTALS                      73
#define IDS_BVT                         74
#define IDS_ROOTDEVNODE                 75
#define IDS_SIGVERIF                    76
#define IDS_NODEV                       77
#define IDS_NOPRN                       78
#define IDS_NOBVT                       79
#define IDS_STRING2                     80
#define IDS_REG_CLASS2                  81
#define IDS_OTHER                       82
#define IDS_STATUS_BUILD                83
#define IDS_STATUS_FREE                 84
#define IDS_STATUS_LOG                  85
#define IDS_STATUS_SCAN                 86
#define IDS_ADVANCED_SETTINGS           87
#define IDS_SEARCHTAB                   88
#define IDS_LOGGINGTAB                  89
#define IDS_X86                         90
#define IDS_MIPS                        91
#define IDS_ALPHA                       92
#define IDS_PPC                         93
#define IDS_REG_PRODUCTOPTIONS          94
#define IDS_REG_PRODUCTTYPE             95
#define IDS_PRODUCT_SERVER              96
#define IDS_SERVERFILELIST              97
#define IDS_FULLSCAN                    98
#define IDS_DEFSCAN                     99
#define IDS_X86FILELIST                 100
#define IDD_DIALOG                      101
#define IDI_ICON1                       102
#define IDB_BITMAP1                     102
#define IDD_DETAILS                     103
#define IDD_RESULTS                     104
#define IDD_SETTINGS                    105
#define IDD_ADVANCED                    106
#define IDD_SEARCH                      107
#define ID_VIEWLOG                      1000
#define IDC_BITMAP                      1000
#define IDC_FOLDER                      1001
#define IDC_TEXT                        1001
#define IDC_SCAN                        1002
#define IDC_NOTMS                       1003
#define IDC_SUBFOLDERS                  1004
#define ID_CLOSE                        1005
#define ID_START                        1006
#define ID_BROWSE                       1007
#define IDC_PROGRESS                    1008
#define IDC_LISTVIEW                    1009
#define IDC_STATUSWINDOW                1010
#define ID_SETTINGS                     1011
#define ID_ADVANCED                     1011
#define IDC_BUILDLIST                   1012
#define IDC_TYPE                        1013
#define IDC_FREELIST                    1014
#define ID_DETAILS_OK                   1015
#define ID_DETAILS                      1016
#define IDC_RESULTSTEXT                 1017
#define IDC_LOGNAME                     1018
#define IDC_OVERWRITE                   1019
#define IDC_APPEND                      1020
#define IDC_ENABLELOG                   1021
#define IDC_VIEWLOG                     1022
#define IDC_TAB1                        1023
#define IDC_STATUS                      1024
#define IDC_INFOTEXT                    1025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

//
// Version Information
//
#include <winver.h>
#include <ntverp.h>
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "File Signature Verification"
#define VER_INTERNALNAME_STR            "sigverif.exe"
#define VER_ORIGINALFILENAME_STR        "sigverif.exe"
#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\walkpath.c ===
//
// WALKPATH.C
//
#include "sigverif.h"

LPDIRNODE   g_lpDirList = NULL;
LPDIRNODE   g_lpDirEnd  = NULL;
BOOL        g_bRecurse  = TRUE;

//
// This function takes a directory name and a search pattern and looks for all files mathching the pattern.
// If bRecurse is set, then it will add subdirectories to the end of the g_lpDirList for subsequent traversal.
// 
// In this routine we allocate and fill in some of the lpFileNode values that we know about.
//
void FindFile(DIRNODE *lpDir, TCHAR *lpDirName, TCHAR *lpFileName)
{
    DWORD           dwRet;
    BOOL            bOk = TRUE;
    HANDLE          hFind;
    LPFILENODE      lpFileNode;
    LPDIRNODE       lpDirNode;
    WIN32_FIND_DATA FindFileData;

    // If the user clicked STOP, then bail immediately!
    // If the directory is bogus, then skip to the next one.
    if (!g_App.bStopScan && SetCurrentDirectory(lpDirName)) {
        // If the user wants to look in subdirectories, then we need to find everything in the current directory
        // and if it's a directory we want to add it to the end of the g_lpDirList.
        if (g_bRecurse) {
            hFind = FindFirstFile(TEXT("*.*"), &FindFileData);
            if (hFind != INVALID_HANDLE_VALUE) {
                bOk = TRUE;
                while (bOk && !g_App.bStopScan) {
                    if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                        lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                        (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        
                        lpDirNode = (LPDIRNODE) MALLOC(sizeof(DIRNODE));

                        if (lpDirNode) {
                        
                            dwRet = GetFullPathName(FindFileData.cFileName, MAX_PATH, lpDirNode->DirName, 0);
                            
                            if (!dwRet || dwRet >= MAX_PATH) {
                                GetShortPathName(lpDirName, lpDirNode->DirName, MAX_PATH);
                                GetFullPathName(FindFileData.cFileName, MAX_PATH, lpDirNode->DirName, 0);
                                SetCurrentDirectory(lpDirName);
                            }
                        }

                        g_lpDirEnd->next  = lpDirNode;
                        g_lpDirEnd        = lpDirNode;
                    }

                    bOk = FindNextFile(hFind, &FindFileData);
                }
                FindClose(hFind);
            }
        }

        // We have added any subdirectories to the dir list, so now we can actually look for
        // the lpFileName search pattern and start adding to the g_App.lpFileList.
        hFind = FindFirstFile(lpFileName, &FindFileData);
        if (hFind != INVALID_HANDLE_VALUE) {
            bOk = TRUE;

            // While there are more files to be found, keep looking in the directory...
            while (bOk && !g_App.bStopScan) {
                if (lstrcmp(FindFileData.cFileName, TEXT(".")) &&
                    lstrcmp(FindFileData.cFileName, TEXT("..")) &&
                    !(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    //
                    // Allocate an lpFileNode, fill it in, and add it to the end of g_App.lpFileList
                    //
                    // We need to call CharLowerBuff on the file and dir names because
                    // the catalog files all contain lower-case names for the files.
                    //
                    lpFileNode = CreateFileNode(lpDirName, FindFileData.cFileName);

                    if (lpFileNode) {
    
                        if (!g_App.lpFileList)
                            g_App.lpFileList = lpFileNode;
                        else g_App.lpFileLast->next = lpFileNode;
                        g_App.lpFileLast = lpFileNode;
    
                        // Increment the total number of files we've found that meet the search criteria.
                        g_App.dwFiles++;
                    }
                }

                // Get the next file meeting the search pattern.
                bOk = FindNextFile(hFind, &FindFileData);
            }
            FindClose(hFind);
        }
    }

    // Free the memory allocated in the directory node.
    lpDir       = g_lpDirList;
    g_lpDirList = g_lpDirList->next;
    FREE(lpDir);
}

//
// Build an g_App.lpFileList given the user settings in the main dialog.
//
void BuildFileList(LPTSTR lpPathName)
{
    TCHAR       FileName[MAX_PATH];
    TCHAR       Extension[MAX_PATH];
    LPTSTR      lpFileName = FileName;
    LPTSTR      lpExtension = Extension;
    LPDIRNODE   lpDirNode;

    // Check if this is a valid starting directory.
    // If not, then pop up an error message.
    if (!SetCurrentDirectory(lpPathName)) {
        MyErrorBoxId(IDS_BADDIR);
        return;
    }

    // If the "Include Subdirectories" is checked, then bRecurse is TRUE.
    if (g_App.bSubFolders)
        g_bRecurse = TRUE;
    else g_bRecurse = FALSE;

    // Get the search pattern from the resource or the user-specified string
    if (g_App.bUserScan)
        lstrcpy(lpFileName, g_App.szScanPattern);
    else MyLoadString(lpFileName, IDS_ALL);

    // Allocate the first entry in the g_lpDirList and set it to the
    // current directory.
    lpDirNode       = (LPDIRNODE) MALLOC(sizeof(DIRNODE));

    if (lpDirNode) {
    
        lstrcpy(lpDirNode->DirName, lpPathName);
        lpDirNode->next = NULL;
    }

    g_lpDirList     = lpDirNode;
    g_lpDirEnd      = lpDirNode;

    // Process the g_lpDirList as long as the user doesn't click STOP!
    while (g_lpDirList && !g_App.bStopScan)
        FindFile(g_lpDirList, g_lpDirList->DirName, lpFileName);

    // Make sure all the memory allocated to the g_lpDirList is freed.
    while (g_lpDirList) {
        lpDirNode = g_lpDirList->next;  
        FREE(g_lpDirList);
        g_lpDirList = lpDirNode;
    }

    // If there weren't any files found, then let the user know about it.
    if (!g_App.lpFileList)
        MyMessageBoxId(IDS_NOFILES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\verify.c ===
//
// VERIFY.C
//
#include "sigverif.h"

//
// Find the file extension and place it in the lpFileNode->lpTypeName field
//
void MyGetFileTypeName(LPFILENODE lpFileInfo)
{
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    LPTSTR lpExtension;

    // Initialize szBuffer to be an empty string.
    szBuffer[0] = 0;

    // Walk to the end of lpFileName
    for(lpExtension = lpFileInfo->lpFileName; *lpExtension; lpExtension++);

    // Walk backwards until we hit a '.' and we'll use that as our extension
    for(lpExtension--; *lpExtension && lpExtension >= lpFileInfo->lpFileName; lpExtension--)
    {
        if (lpExtension[0] == TEXT('.'))
        {
            lstrcpy(szExt, lpExtension + 1);
            CharUpperBuff(szExt, lstrlen(szExt));
            MyLoadString(szBuffer2, IDS_FILETYPE);
            wsprintf(szBuffer, szBuffer2, szExt);
        }
    }

    // If there's no extension, then just call this a "File".
    if (szBuffer[0] == 0)
    {
        MyLoadString(szBuffer, IDS_FILE);
    }

    lpFileInfo->lpTypeName = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

    if (lpFileInfo->lpTypeName)
    {
        lstrcpy(lpFileInfo->lpTypeName, szBuffer);
    }
}

//
// Use SHGetFileInfo to get the icon index for the specified file.
//
void MyGetFileInfo(LPFILENODE lpFileInfo)
{
    SHFILEINFO  sfi;

    ZeroMemory(&sfi, sizeof(SHFILEINFO));
    SHGetFileInfo(  lpFileInfo->lpFileName,
                    0,
                    &sfi,
                    sizeof(SHFILEINFO),
                    SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_TYPENAME);
    
    lpFileInfo->iIcon = sfi.iIcon;
    
    if (*sfi.szTypeName)
    {
        lpFileInfo->lpTypeName = MALLOC((lstrlen(sfi.szTypeName) + 1) * sizeof(TCHAR));

        if (lpFileInfo->lpTypeName) 
        {
            lstrcpy(lpFileInfo->lpTypeName, sfi.szTypeName);
        }

    } else {
        
        MyGetFileTypeName(lpFileInfo);
    }
}

void GetFileVersion(LPFILENODE lpFileInfo)
{
    DWORD               dwHandle, dwRet, dwLength;
    BOOL                bRet;
    LPVOID              lpData = NULL;
    LPVOID              lpBuffer;
    VS_FIXEDFILEINFO    *lpInfo;
    TCHAR               szBuffer[MAX_PATH];
    TCHAR               szBuffer2[MAX_PATH];

    dwRet = GetFileVersionInfoSize(lpFileInfo->lpFileName, &dwHandle);
    if (dwRet)
    {
        lpData = MALLOC(dwRet + 1);
        if (lpData)
        {
            bRet = GetFileVersionInfo(lpFileInfo->lpFileName, dwHandle, dwRet, lpData);
            if (bRet)
            {
                lpBuffer = NULL;
                dwLength = 0;
                bRet = VerQueryValue(lpData, TEXT("\\"), &lpBuffer, &dwLength);
                if (bRet)
                {
                    lpInfo = (VS_FIXEDFILEINFO *) lpBuffer;

                    MyLoadString(szBuffer2, IDS_VERSION);
                    wsprintf(szBuffer, szBuffer2,   HIWORD(lpInfo->dwFileVersionMS), LOWORD(lpInfo->dwFileVersionMS),
                                                    HIWORD(lpInfo->dwFileVersionLS), LOWORD(lpInfo->dwFileVersionLS));
                    
                    lpFileInfo->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

                    if (lpFileInfo->lpVersion) 
                    {
                        lstrcpy(lpFileInfo->lpVersion, szBuffer);
                    }
                }
            }

            FREE(lpData);
        }
    }

    if (!lpFileInfo->lpVersion)
    {
        MyLoadString(szBuffer, IDS_NOVERSION);
        
        lpFileInfo->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileInfo->lpVersion) 
        {
            lstrcpy(lpFileInfo->lpVersion, szBuffer);
        }
    }
}

/*************************************************************************
*   Function : VerifyIsFileSigned
*   Purpose : Calls WinVerifyTrust with Policy Provider GUID to
*   verify if an individual file is signed.
**************************************************************************/
BOOL VerifyIsFileSigned(LPTSTR pcszMatchFile, PDRIVER_VER_INFO lpVerInfo)
{
    INT                 iRet;
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
#ifndef UNICODE
    WCHAR               wszFileName[MAX_PATH];
#endif

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;
    
    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifndef UNICODE
    iRet = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, (LPWSTR)&wszFileName, cA(wszFileName));
    WinTrustFile.pcwszFilePath = wszFileName;
#else
    WinTrustFile.pcwszFilePath = pcszMatchFile;
#endif

    hRes = WinVerifyTrust(g_App.hDlg, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS)
        hRes = WinVerifyTrust(g_App.hDlg, &gPublishedSoftware, &WinTrustData);

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //
    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return (hRes == ERROR_SUCCESS);
}

//
// Given a specific LPFILENODE, verify that the file is signed or unsigned.
// Fill in all the necessary structures so the listview control can display properly.
//
BOOL VerifyFileNode(LPFILENODE lpFileNode)
{
    HANDLE                  hFile;
    BOOL                    bRet;
    HCATINFO                hCatInfo = NULL;
    HCATINFO                PrevCat;
    WINTRUST_DATA           WinTrustData;
    WINTRUST_CATALOG_INFO   WinTrustCatalogInfo;
    DRIVER_VER_INFO         VerInfo;
    GUID                    gSubSystemDriver = DRIVER_ACTION_VERIFY;
    HRESULT                 hRes;
    DWORD                   cbHash = HASH_SIZE;
    BYTE                    szHash[HASH_SIZE];
    LPBYTE                  lpHash = szHash;
    CATALOG_INFO            CatInfo;
    LPTSTR                  lpFilePart;
    TCHAR                   szBuffer[MAX_PATH];
    static TCHAR            szCurrentDirectory[MAX_PATH];
#ifndef UNICODE
    WCHAR UnicodeKey[MAX_PATH];
#endif
    
    // If this is the first item we are verifying, then initialize the static buffer.
    if (lpFileNode == g_App.lpFileList)
    {
        ZeroMemory(szCurrentDirectory, sizeof(szCurrentDirectory));
    }
    
    //
    // Check the current directory against the one in the lpFileNode.
    // We only want to call SetCurrentDirectory if the path is different.
    //
    if (lstrcmp(szCurrentDirectory, lpFileNode->lpDirName))
    {
        if (!SetCurrentDirectory(lpFileNode->lpDirName))
            return FALSE;
        
        lstrcpy(szCurrentDirectory, lpFileNode->lpDirName);
    }

    //
    // Get the handle to the file, so we can call CryptCATAdminCalcHashFromFileHandle
    //
    hFile = CreateFile( lpFileNode->lpFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // Initialize the hash buffer
    ZeroMemory(lpHash, HASH_SIZE);

    // Generate the hash from the file handle and store it in lpHash
    if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, lpHash, 0))
    {
        //
        // If we couldn't generate a hash, it might be an individually signed catalog.
        // If it's a catalog, zero out lpHash and cbHash so we know there's no hash to check.
        //
        if (IsCatalogFile(hFile, NULL))
        {
            lpHash = NULL;
            cbHash = 0;
        } 
        else  // If it wasn't a catalog, we'll bail and this file will show up as unscanned.
        {
            CloseHandle(hFile);
            return FALSE;
        }
    }

    // Close the file handle
    CloseHandle(hFile);

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;
    
    ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
    VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);
    
    WinTrustData.pCatalog = &WinTrustCatalogInfo;
            
    ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WinTrustCatalogInfo.pbCalculatedFileHash = lpHash;
    WinTrustCatalogInfo.cbCalculatedFileHash = cbHash;
#ifdef UNICODE
    WinTrustCatalogInfo.pcwszMemberTag = lpFileNode->lpFileName;
#else
    MultiByteToWideChar(CP_ACP, 0, lpFileNode->lpFileName, -1, UnicodeKey, cA(UnicodeKey));
    WinTrustCatalogInfo.pcwszMemberTag = UnicodeKey;
#endif

    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //
    PrevCat = NULL;
    hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);

    //
    // We want to cycle through the matching catalogs until we find one that matches both hash and member tag
    //
    bRet = FALSE;
    while(hCatInfo && !bRet)
    {
        ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        if(CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) 
        {
            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;
        
            // Now verify that the file is an actual member of the catalog.
            hRes = WinVerifyTrust(g_App.hDlg, &gSubSystemDriver, &WinTrustData);
            if (hRes == ERROR_SUCCESS)
            {
#ifdef UNICODE
                GetFullPathName(CatInfo.wszCatalogFile, MAX_PATH, szBuffer, &lpFilePart);
#else
                WideCharToMultiByte(CP_ACP, 0, CatInfo.wszCatalogFile, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                GetFullPathName(szBuffer, MAX_PATH, szBuffer, &lpFilePart);
#endif
                lpFileNode->lpCatalog = MALLOC((lstrlen(lpFilePart) + 1) * sizeof(TCHAR));

                if (lpFileNode->lpCatalog) {
                
                    lstrcpy(lpFileNode->lpCatalog, lpFilePart);
                }

                bRet = TRUE;
            }

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //
            if (VerInfo.pcSignerCertContext != NULL) {

                CertFreeCertificateContext(VerInfo.pcSignerCertContext);
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if (!bRet)
        {
            // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
            PrevCat = hCatInfo;
            hCatInfo = CryptCATAdminEnumCatalogFromHash(g_App.hCatAdmin, lpHash, cbHash, 0, &PrevCat);
        }
    }

    // Mark this file as having been scanned.
    lpFileNode->bScanned = TRUE;

    if (!hCatInfo)
    {
        //
        // If it wasn't found in the catalogs, check if the file is individually signed.
        //
        bRet = VerifyIsFileSigned(lpFileNode->lpFileName, (PDRIVER_VER_INFO) &VerInfo);
        if (bRet)
        {
            // If so, mark the file as being signed.
            lpFileNode->bSigned = TRUE;
        }
    } 
    else 
    {
        // The file was verified in the catalogs, so mark it as signed and free the catalog context.
        lpFileNode->bSigned = TRUE;
        CryptCATAdminReleaseCatalogContext(g_App.hCatAdmin, hCatInfo, 0);
    }

    if (lpFileNode->bSigned)
    {
#ifdef UNICODE
        lpFileNode->lpVersion = MALLOC((lstrlen(VerInfo.wszVersion) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpVersion) 
        {
            lstrcpy(lpFileNode->lpVersion, VerInfo.wszVersion);
        }

        lpFileNode->lpSignedBy = MALLOC((lstrlen(VerInfo.wszSignedBy) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpSignedBy) 
        {
            lstrcpy(lpFileNode->lpSignedBy, VerInfo.wszSignedBy);
        }
#else
        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszVersion, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpVersion = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpVersion) 
        {
            lstrcpy(lpFileNode->lpVersion, szBuffer);
        }

        WideCharToMultiByte(CP_ACP, 0, VerInfo.wszSignedBy, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        lpFileNode->lpSignedBy = MALLOC((lstrlen(szBuffer) + 1) * sizeof(TCHAR));

        if (lpFileNode->lpSignedBy) 
        {
            lstrcpy(lpFileNode->lpSignedBy, szBuffer);
        }
#endif
    }
    else
    {
        // 
        // Get the icon (if the file isn't signed) so we can display it in the listview faster.
        //
        MyGetFileInfo(lpFileNode);
    }

    return lpFileNode->bSigned;
}

//
// This function loops through g_App.lpFileList to verify each file.  We want to make this loop as tight
// as possible and keep the progress bar updating as we go.  When we are done, we want to pop up a
// dialog that allows the user to choose "Details" which will give them the listview control.
//
BOOL VerifyFileList(void)
{
    LPFILENODE lpFileNode;
    DWORD       dwCount = 0;
    DWORD       dwPercent = 0;
    DWORD       dwCurrent = 0;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuffer2[MAX_PATH];
    LPTSTR      lpString;
    DWORD       dwBytesWritten;
    HANDLE      hSigverif = INVALID_HANDLE_VALUE;
    HANDLE      hTotals = INVALID_HANDLE_VALUE;
    HANDLE      hFileSigned = INVALID_HANDLE_VALUE;
    HANDLE      hFileUnsigned = INVALID_HANDLE_VALUE;
    HANDLE      hFileUnscanned = INVALID_HANDLE_VALUE;
    INT         iRet;

    // Initialize the signed and unsigned counts
    g_App.dwSigned    = 0;
    g_App.dwUnsigned  = 0;

    // If we don't already have an g_App.hCatAdmin handle, acquire one.
    if (!g_App.hCatAdmin)
    {
        CryptCATAdminAcquireContext(&g_App.hCatAdmin, NULL, 0);
    }
    
    //
    //  If the user specified test switches, then we want to open log files to record
    //  the scanning results as they happen.  SIGVERIF.TXT has every file before it is
    //  scanned (in case of a fault), SIGNED.TXT gets signed files, UNSIGNED.TXT gets
    //  unsigned files, UNSCANNED.TXT gets everything else.  TOTALS.TXT was added last
    //  and gets the text from the status window on the results dialog.
    //
    if (g_App.bLogToRoot)
    {
        if (*g_App.szLogDir)
        {
            lstrcpy(szBuffer, g_App.szLogDir);
            lstrcat(szBuffer, TEXT("\\"));
        }
        else
        {
            MyGetWindowsDirectory(szBuffer, MAX_PATH);
            szBuffer[3] = 0;    
        }
        lstrcat(szBuffer, TEXT("SIGVERIF.CSV"));
        hSigverif = CreateFile( szBuffer, 
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        SetFilePointer(hSigverif, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hSigverif);

        if (*g_App.szLogDir)
        {
            lstrcpy(szBuffer, g_App.szLogDir);
            lstrcat(szBuffer, TEXT("\\"));
        }
        else
        {
            MyGetWindowsDirectory(szBuffer, MAX_PATH);
            szBuffer[3] = 0;    
        }
        lstrcat(szBuffer, TEXT("TOTALS.TXT"));

        hTotals = CreateFile(   szBuffer, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        SetFilePointer(hTotals, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hTotals);

        if (*g_App.szLogDir)
        {
            lstrcpy(szBuffer, g_App.szLogDir);
            lstrcat(szBuffer, TEXT("\\"));
        }
        else
        {
            MyGetWindowsDirectory(szBuffer, MAX_PATH);
            szBuffer[3] = 0;    
        }
        lstrcat(szBuffer, TEXT("SIGNED.CSV"));

        hFileSigned = CreateFile(   szBuffer, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        SetFilePointer(hFileSigned, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFileSigned);

        if (*g_App.szLogDir)
        {
            lstrcpy(szBuffer, g_App.szLogDir);
            lstrcat(szBuffer, TEXT("\\"));
        }
        else
        {
            MyGetWindowsDirectory(szBuffer, MAX_PATH);
            szBuffer[3] = 0;    
        }
        lstrcat(szBuffer, TEXT("UNSIGNED.CSV"));

        hFileUnsigned = CreateFile( szBuffer, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        SetFilePointer(hFileUnsigned, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFileUnsigned);

        if (*g_App.szLogDir)
        {
            lstrcpy(szBuffer, g_App.szLogDir);
            lstrcat(szBuffer, TEXT("\\"));
        }
        else
        {
            MyGetWindowsDirectory(szBuffer, MAX_PATH);
            szBuffer[3] = 0;    
        }
        lstrcat(szBuffer, TEXT("UNSCANNED.CSV"));

        hFileUnscanned = CreateFile( szBuffer, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        SetFilePointer(hFileUnscanned, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFileUnscanned);
    
#ifdef UNICODE
        // If we are using UNICODE, then write the 0xFF and 0xFE bytes at the beginning of the file.
        ZeroMemory(szBuffer, sizeof(szBuffer));
        szBuffer[0] = 0xFEFF;
        WriteFile(hSigverif, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        WriteFile(hTotals, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        WriteFile(hFileSigned, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        WriteFile(hFileUnsigned, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
        WriteFile(hFileUnscanned, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
#endif
    }

    //
    // Start looping through each file and update the progress bar if we cross a percentage boundary.
    //
    for(lpFileNode=g_App.lpFileList;lpFileNode && !g_App.bStopScan;lpFileNode=lpFileNode->next,dwCount++)
    {
        // Figure out the current percentage and update if it has increased.
        dwPercent = (dwCount * 100) / g_App.dwFiles;
        if (dwPercent > dwCurrent)
        {
            dwCurrent = dwPercent;
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) dwCurrent, (LPARAM) 0);
        }

        // Here's the call to VerifyFileNode!
        VerifyFileNode(lpFileNode);

        // In case something went wrong, make sure the version information gets filled in.
        if (!lpFileNode->lpVersion)
        {
            GetFileVersion(lpFileNode);
        }

        // Log the current file to hSigverif, in case something bad happens.
        if (g_App.bLogToRoot && hSigverif != INVALID_HANDLE_VALUE)
        {
            *szBuffer = '\0';
            wsprintf(szBuffer, lpFileNode->lpFileName);
            lstrcat(szBuffer, TEXT(","));
            WriteFile(hSigverif, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            *szBuffer = '\0';
            GetFullPathName(lpFileNode->lpFileName, SIZECHARS(szBuffer), szBuffer, NULL);
            lstrcat(szBuffer, TEXT(","));
            WriteFile(hSigverif, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            *szBuffer = '\0';
            // Get the date format, so we are localizable...
            iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT, 
                                    DATE_SHORTDATE,
                                    &lpFileNode->LastModified,
                                    NULL,
                                    NULL,
                                    0);
            if (iRet)
            {
                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));
                iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT,
                                        DATE_SHORTDATE,
                                        &lpFileNode->LastModified,
                                        NULL,
                                        lpString,
                                        iRet);
                if (iRet)
                {
                    lstrcpy(szBuffer, lpString);
                }
                FREE(lpString);
            }
            lstrcat(szBuffer, TEXT(","));
            WriteFile(hSigverif, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);


            *szBuffer = '\0';
            lstrcpy(szBuffer, lpFileNode->lpVersion);
            WriteFile(hSigverif, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer, IDS_LINEFEED);
            WriteFile(hSigverif, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            FlushFileBuffers(hSigverif);
        }

        if (lpFileNode->bScanned)
        {
            // If the file was signed, increment the g_App.dwSigned or g_App.dwUnsigned counter.
            if (lpFileNode->bSigned)
            {
                g_App.dwSigned++;
                if (g_App.bLogToRoot && hFileSigned != INVALID_HANDLE_VALUE)
                {
                    *szBuffer = '\0';
                    wsprintf(szBuffer, lpFileNode->lpFileName);
                    lstrcat(szBuffer, TEXT(","));
                    WriteFile(hFileSigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    *szBuffer = '\0';
                    GetFullPathName(lpFileNode->lpFileName, SIZECHARS(szBuffer), szBuffer, NULL);
                    lstrcat(szBuffer, TEXT(","));
                    WriteFile(hFileSigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    *szBuffer = '\0';
                    // Get the date format, so we are localizable...
                    iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT, 
                                            DATE_SHORTDATE,
                                            &lpFileNode->LastModified,
                                            NULL,
                                            NULL,
                                            0);
                    if (iRet)
                    {
                        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));
                        iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT,
                                                DATE_SHORTDATE,
                                                &lpFileNode->LastModified,
                                                NULL,
                                                lpString,
                                                iRet);
                        if (iRet)
                        {
                            lstrcpy(szBuffer, lpString);
                        }
                        FREE(lpString);
                    }
                    lstrcat(szBuffer, TEXT(","));
                    WriteFile(hFileSigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    *szBuffer = '\0';
                    lstrcpy(szBuffer, lpFileNode->lpVersion);
                    WriteFile(hFileSigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    MyLoadString(szBuffer, IDS_LINEFEED);
                    WriteFile(hFileSigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    FlushFileBuffers(hFileSigned);
                }
            }
            else
            {
                g_App.dwUnsigned++;
                if (g_App.bLogToRoot && hFileUnsigned != INVALID_HANDLE_VALUE)
                {
                    *szBuffer = '\0';
                    wsprintf(szBuffer, lpFileNode->lpFileName);
                    lstrcat(szBuffer, TEXT(","));
                    WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    *szBuffer = '\0';
                    GetFullPathName(lpFileNode->lpFileName, SIZECHARS(szBuffer), szBuffer, NULL);
                    lstrcat(szBuffer, TEXT(","));
                    WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    *szBuffer = '\0';
                    // Get the date format, so we are localizable...
                    iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT, 
                                            DATE_SHORTDATE,
                                            &lpFileNode->LastModified,
                                            NULL,
                                            NULL,
                                            0);
                    if (iRet)
                    {
                        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));
                        iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT,
                                                DATE_SHORTDATE,
                                                &lpFileNode->LastModified,
                                                NULL,
                                                lpString,
                                                iRet);
                        if (iRet)
                        {
                            lstrcpy(szBuffer, lpString);
                        }
                        FREE(lpString);
                    }
                    lstrcat(szBuffer, TEXT(","));
                    WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);


                    *szBuffer = '\0';
                    lstrcpy(szBuffer, lpFileNode->lpVersion);
                    WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    MyLoadString(szBuffer, IDS_LINEFEED);
                    WriteFile(hFileUnsigned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                    FlushFileBuffers(hFileUnsigned);
                }
            }
        } 
        else 
        {
            if (g_App.bLogToRoot && hFileUnscanned != INVALID_HANDLE_VALUE)
            {
                *szBuffer = '\0';
                wsprintf(szBuffer, lpFileNode->lpFileName);
                lstrcat(szBuffer, TEXT(","));
                WriteFile(hFileUnscanned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                *szBuffer = '\0';
                GetFullPathName(lpFileNode->lpFileName, SIZECHARS(szBuffer), szBuffer, NULL);
                lstrcat(szBuffer, TEXT(","));
                WriteFile(hFileUnscanned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                *szBuffer = '\0';
                // Get the date format, so we are localizable...
                iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT, 
                                        DATE_SHORTDATE,
                                        &lpFileNode->LastModified,
                                        NULL,
                                        NULL,
                                        0);
                if (iRet)
                {
                    lpString = MALLOC((iRet + 1) * sizeof(TCHAR));
                    iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT,
                                            DATE_SHORTDATE,
                                            &lpFileNode->LastModified,
                                            NULL,
                                            lpString,
                                            iRet);
                    if (iRet)
                    {
                        lstrcpy(szBuffer, lpString);
                    }
                    FREE(lpString);
                }
                lstrcat(szBuffer, TEXT(","));
                WriteFile(hFileUnscanned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                *szBuffer = '\0';
                lstrcpy(szBuffer, lpFileNode->lpVersion);
                WriteFile(hFileUnscanned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                MyLoadString(szBuffer, IDS_LINEFEED);
                WriteFile(hFileUnscanned, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

                FlushFileBuffers(hFileUnscanned);
            }
        }
    }

    if (g_App.bLogToRoot)
    {
        // Load the status string and fill it in with the correct values.
        MyLoadString(szBuffer, IDS_NUMFILES);
        wsprintf(szBuffer2, szBuffer,   g_App.dwFiles, g_App.dwSigned, g_App.dwUnsigned, 
                                        g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
        WriteFile(hTotals, szBuffer2, lstrlen(szBuffer2) * sizeof(TCHAR), &dwBytesWritten, NULL);
        if (hTotals != INVALID_HANDLE_VALUE)
            CloseHandle(hTotals);
        
        if (hSigverif != INVALID_HANDLE_VALUE)
            CloseHandle(hSigverif);
        if (hFileSigned != INVALID_HANDLE_VALUE)
            CloseHandle(hFileSigned);
        if (hFileUnsigned != INVALID_HANDLE_VALUE)
            CloseHandle(hFileUnsigned);
        if (hFileUnsigned != INVALID_HANDLE_VALUE)
            CloseHandle(hFileUnscanned);
    }
    
    // If we had an g_App.hCatAdmin, free it and set it to zero so we can acquire a new one in the future.
    if (g_App.hCatAdmin)
    {
        CryptCATAdminReleaseContext(g_App.hCatAdmin,0);
        g_App.hCatAdmin = NULL;
    }

    if (!g_App.bStopScan && !g_App.bFullSystemScan)
    {
        // If the user never clicked STOP, then make sure the progress bar hits 100%
        if (!g_App.bStopScan)
            SendMessage(GetDlgItem(g_App.hDlg, IDC_PROGRESS), PBM_SETPOS, (WPARAM) 100, (LPARAM) 0);

        if (!g_App.dwUnsigned)
        {
            // If there weren't any unsigned files, then we want to tell the user that everything is dandy!
            if (g_App.dwSigned)
                MyMessageBoxId(IDS_ALLSIGNED);
            else MyMessageBoxId(IDS_NOPROBLEMS);
        }
        else
        {
            // Show the user the results by going directly to IDD_RESULTS
            DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_RESULTS), g_App.hDlg, ListView_DlgProc);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bvtsigvf\logfile.c ===
//
// LOGFILE.C
//
#include "sigverif.h"

// We need to remember the previous logging state when we do toggling.
BOOL    g_bPrevLoggingEnabled = FALSE;

BOOL LogFile_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{   
    TCHAR   szBuffer[MAX_PATH];

    if (g_App.hIcon) {
        SetWindowLongPtr(hwnd, GCLP_HICON, (LONG_PTR) g_App.hIcon); 
    }

    g_App.hLogging = hwnd;

    g_bPrevLoggingEnabled = g_App.bLoggingEnabled;

    if (*g_App.szLogDir) {
        SetCurrentDirectory(g_App.szLogDir);
    } else {
        GetWindowsDirectory(szBuffer, MAX_PATH);
        SetCurrentDirectory(szBuffer);
    }
    SetDlgItemText(hwnd, IDC_LOGNAME, g_App.szLogFile);

    CheckDlgButton(hwnd, IDC_ENABLELOG, g_App.bLoggingEnabled ? BST_CHECKED : BST_UNCHECKED);

    EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(g_App.szLogFile));

    CheckRadioButton(hwnd, IDC_OVERWRITE, IDC_APPEND, g_App.bOverwrite ? IDC_OVERWRITE : IDC_APPEND);
    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);

    SetForegroundWindow(g_App.hDlg);
    SetForegroundWindow(hwnd);

    return TRUE;
}

void LogFile_UpdateDialog(HWND hwnd)
{
    TCHAR szBuffer[MAX_PATH];

    if (GetDlgItemText(hwnd, IDC_LOGNAME, szBuffer, MAX_PATH)) {
        EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), g_App.bLoggingEnabled && EXIST(szBuffer));
    } else EnableWindow(GetDlgItem(hwnd, IDC_VIEWLOG), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_APPEND), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_OVERWRITE), g_App.bLoggingEnabled);
    EnableWindow(GetDlgItem(hwnd, IDC_LOGNAME), g_App.bLoggingEnabled);
}

void LogFile_OnViewLog(HWND hwnd)
{
    TCHAR szDirName[MAX_PATH];
    TCHAR szFileName[MAX_PATH];

    if (*g_App.szLogDir) {
        lstrcpy(szDirName, g_App.szLogDir);
    } else {
        GetWindowsDirectory(szDirName, MAX_PATH);
    }

    if (!GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, MAX_PATH)) {
        MyErrorBoxId(IDS_BADLOGNAME);
        return;
    }

    ShellExecute(hwnd, NULL, szFileName, NULL, szDirName, SW_SHOW);
}

BOOL LogFile_VerifyLogFile(HWND hwnd, LPTSTR lpFileName, BOOL bNoisy)
{
    TCHAR   szFileName[MAX_PATH];
    HANDLE  hFile;
    BOOL    bRet;
    HWND    hTemp;

    ZeroMemory(szFileName, sizeof(szFileName));

    bRet = GetDlgItemText(hwnd, IDC_LOGNAME, szFileName, MAX_PATH);
    if (bRet) {
        hFile = CreateFile( szFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL, 
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
        } else {
            hFile = CreateFile( szFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL, 
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
                DeleteFile(szFileName);
            } else {
                //
                // If we couldn't open an existing file and we couldn't create a new one, then we fail.
                //
                bRet = FALSE;
            }
        }
    }

    if (!bRet && bNoisy) {
        //
        // Since we don't want to lose focus, we are going to temporarily change g_App.hDlg.  JasKey, I apologize.
        //
        hTemp = g_App.hDlg;
        g_App.hDlg = hwnd;
        MyErrorBoxId(IDS_BADLOGNAME);
        g_App.hDlg = hTemp;
    }

    //
    // If everything worked and the user wants the file name, copy it into lpFileName
    //
    if (bRet && lpFileName && *szFileName) {
        lstrcpy(lpFileName, szFileName);
    }

    return bRet;
}

BOOL LogFile_OnOK(HWND hwnd)
{
    HKEY    hKey;
    LONG    lRes;
    DWORD   dwDisp, dwType, dwFlags, cbData;
    TCHAR   szFileName[MAX_PATH];

    ZeroMemory(szFileName, sizeof(szFileName));

    if (LogFile_VerifyLogFile(hwnd, szFileName, FALSE)) {
        // The file is OK to append or overwrite.
        lstrcpy(g_App.szLogFile, szFileName);
    } else return FALSE;

    g_App.bOverwrite = IsDlgButtonChecked(hwnd, IDC_OVERWRITE);

    // Look in the registry for any settings from the last SigVerif session
    lRes = RegCreateKeyEx(  SIGVERIF_HKEY,
                            SIGVERIF_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisp);

    if (lRes == ERROR_SUCCESS) {
        cbData = sizeof(DWORD);
        dwFlags = 0;
        if (g_App.bLoggingEnabled)
            dwFlags = 0x1;
        if (g_App.bOverwrite)
            dwFlags |= 0x2;
        dwType = REG_DWORD;
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_FLAGS,
                                0,
                                dwType,
                                (LPBYTE) &dwFlags,
                                cbData);

        dwType = REG_SZ;
        cbData = MAX_PATH;
        lRes = RegSetValueEx(   hKey,
                                SIGVERIF_LOGNAME,
                                0,
                                dwType,
                                (LPBYTE) g_App.szLogFile,
                                cbData);

        RegCloseKey(hKey);
    }

    return TRUE;
}

void LogFile_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {
    case IDC_VIEWLOG:
        LogFile_OnViewLog(hwnd);
        break;

    case IDC_ENABLELOG:
        g_App.bLoggingEnabled = !g_App.bLoggingEnabled;
        // Fall through to update...

    default: LogFile_UpdateDialog(hwnd);
    }
}

//
// This function handles any notification messages for the Search page.
//
LRESULT LogFile_NotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR   *lpnmhdr = (NMHDR *) lParam;
    LRESULT lResult;
    BOOL    bRet;

    switch (lpnmhdr->code) {
    case PSN_APPLY:         if (LogFile_OnOK(hwnd))
            lResult = PSNRET_NOERROR;
        else lResult = PSNRET_INVALID_NOCHANGEPAGE;
        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) lResult);
        return lResult;

    case PSN_KILLACTIVE:    bRet = !LogFile_VerifyLogFile(hwnd, NULL, TRUE);
        if (bRet) {
            SetForegroundWindow(g_App.hLogging);
            SetFocus(GetDlgItem(g_App.hLogging, IDC_LOGNAME));
        }
        SetWindowLongPtr(hwnd,
                         DWLP_MSGRESULT,
                         (LONG_PTR) bRet);
        return bRet;
    }

    return 0;
}

INT_PTR CALLBACK LogFile_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fProcessed = TRUE;

    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_INITDIALOG, LogFile_OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, LogFile_OnCommand);

    case WM_NOTIFY:
        return LogFile_NotifyHandler(hwnd, uMsg, wParam, lParam);

    case WM_HELP:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, FALSE);
        break;

    case WM_CONTEXTMENU:
        SigVerif_Help(hwnd, uMsg, wParam, lParam, TRUE);
        break;

    default: fProcessed = FALSE;
    }

    return fProcessed;
}

void PrintUnscannedFileListItems(HANDLE hFile)
{
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    DWORD       dwBytesWritten;

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {
        // Make sure we only log files that have actually been scanned.
        if (!lpFileNode->bScanned) {
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {
                SetCurrentDirectory(lpFileNode->lpDirName);
                lstrcpy(szDirectory, lpFileNode->lpDirName);

                MyLoadString(szBuffer2, IDS_DIR);
                wsprintf(szBuffer, szBuffer2, szDirectory);
                WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            MyLoadString(szBuffer2, IDS_STRING_LINEFEED);
            wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        }
    }

    MyLoadString(szBuffer, IDS_LINEFEED);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
}

void PrintFileListItems(HANDLE hFile)
{
    LPFILENODE  lpFileNode;
    TCHAR       szDirectory[MAX_PATH];
    TCHAR       szBuffer[MAX_PATH * 2];
    TCHAR       szBuffer2[MAX_PATH];
    TCHAR       szBuffer3[MAX_PATH];
    DWORD       dwBytesWritten;
    LPTSTR      lpString;
    int         iRet;

    *szDirectory = 0;

    for (lpFileNode = g_App.lpFileList;lpFileNode;lpFileNode = lpFileNode->next) {
        // Make sure we only log files that have actually been scanned.
        if (lpFileNode->bScanned) {
            if (lstrcmp(szDirectory, lpFileNode->lpDirName)) {
                SetCurrentDirectory(lpFileNode->lpDirName);
                lstrcpy(szDirectory, lpFileNode->lpDirName);

                MyLoadString(szBuffer2, IDS_DIR);
                wsprintf(szBuffer, szBuffer2, szDirectory);
                WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, lpFileNode->lpFileName);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer, IDS_SPACES);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            // Get the date format, so we are localizable...
            MyLoadString(szBuffer2, IDS_UNKNOWN);
            iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT, 
                                    DATE_SHORTDATE,
                                    &lpFileNode->LastModified,
                                    NULL,
                                    NULL,
                                    0);
            if (iRet) {
                lpString = MALLOC((iRet + 1) * sizeof(TCHAR));
                
                if (lpString) {
                
                    iRet = GetDateFormat(   LOCALE_SYSTEM_DEFAULT,
                                            DATE_SHORTDATE,
                                            &lpFileNode->LastModified,
                                            NULL,
                                            lpString,
                                            iRet);
                    
                    if (iRet) {
                        lstrcpy(szBuffer2, lpString);
                    }
                    
                    FREE(lpString);
                }
            }
            MyLoadString(szBuffer3, IDS_STRING2);
            wsprintf(szBuffer, szBuffer3, szBuffer2);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer, IDS_SPACES);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            if (lpFileNode->lpVersion && *lpFileNode->lpVersion)
                lstrcpy(szBuffer3, lpFileNode->lpVersion);
            else MyLoadString(szBuffer3, IDS_NOVERSION);
            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, szBuffer3);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            MyLoadString(szBuffer2, IDS_STRING);
            MyLoadString(szBuffer3, lpFileNode->bSigned ? IDS_SIGNED : IDS_NOTSIGNED);
            wsprintf(szBuffer, szBuffer2, szBuffer3);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            if (lpFileNode->lpCatalog)
                lstrcpy(szBuffer3, lpFileNode->lpCatalog);
            else MyLoadString(szBuffer3, IDS_NA);
            MyLoadString(szBuffer2, IDS_STRING);
            wsprintf(szBuffer, szBuffer2, szBuffer3);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

            if (lpFileNode->lpSignedBy) {
            
                WriteFile(hFile, lpFileNode->lpSignedBy, lstrlen(lpFileNode->lpSignedBy) * sizeof(TCHAR), &dwBytesWritten, NULL);
            }

            MyLoadString(szBuffer, IDS_LINEFEED);
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        }
    }
}

void PrintFileList(void)
{
    HANDLE          hFile;
    DWORD           dwBytesWritten;
    TCHAR           szBuffer[MAX_PATH*2];
    TCHAR           szBuffer2[MAX_PATH];
    TCHAR           szBuffer3[MAX_PATH];
    LPTSTR          lpString = NULL;
    OSVERSIONINFO   osinfo;
    SYSTEM_INFO     sysinfo;
    int             iRet;

    // Bail if logging is disabled or there's no file list
    if (!g_App.bLoggingEnabled || !g_App.lpFileList)
        return;

    if (*g_App.szLogDir) {
        SetCurrentDirectory(g_App.szLogDir);
    } else {
        // Get the Windows directory and make it the current directory.
        GetWindowsDirectory(szBuffer, MAX_PATH);
        SetCurrentDirectory(szBuffer);
    }

    hFile = CreateFile( g_App.szLogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        MyErrorBoxId(IDS_CANTOPENLOGFILE);
        return;
    }

    // If the overwrite flag is set, truncate the file.
    if (g_App.bOverwrite) {
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        SetEndOfFile(hFile);
    } else SetFilePointer(hFile, 0, NULL, FILE_END);

#ifdef UNICODE
    // If we are using UNICODE, then write the 0xFF and 0xFE bytes at the beginning of the file.
    if (g_App.bOverwrite || (GetFileSize(hFile, NULL) == 0)) {
        szBuffer[0] = 0xFEFF;
        WriteFile(hFile, szBuffer, sizeof(TCHAR), &dwBytesWritten, NULL);
    }
#endif

    // Write the header to the logfile.
    MyLoadString(szBuffer, IDS_LOGHEADER1);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    // Get the date format, so we are localizable...
    MyLoadString(szBuffer2, IDS_UNKNOWN);
    iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,DATE_SHORTDATE,NULL,NULL,NULL,0);
    if (iRet) {
        
        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
        
            iRet = GetDateFormat(LOCALE_SYSTEM_DEFAULT,DATE_SHORTDATE,NULL,NULL,lpString,iRet);
            
            if (iRet) {
                lstrcpy(szBuffer2, lpString);
            }
            
            FREE(lpString);
        }
    }
    // Get the time format, so we are localizable...
    iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,NULL,0);
    if (iRet) {

        lpString = MALLOC((iRet + 1) * sizeof(TCHAR));

        if (lpString) {
        
            iRet = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,TIME_NOSECONDS,NULL,NULL,lpString,iRet);
        }
    }

    MyLoadString(szBuffer3, IDS_LOGHEADER2);
    
    if (lpString) {
    
        wsprintf(szBuffer, szBuffer3, szBuffer2, lpString);
        FREE(lpString);

    } else {
        
        wsprintf(szBuffer, szBuffer3, szBuffer2, szBuffer2);
    }

    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    // Get the OS Platform string for the log file.
    MyLoadString(szBuffer, IDS_OSPLATFORM);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    ZeroMemory(&osinfo, sizeof(OSVERSIONINFO));
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);
    switch (osinfo.dwPlatformId) {
    case VER_PLATFORM_WIN32_NT:         MyLoadString(szBuffer, IDS_WINNT); break;
    case VER_PLATFORM_WIN32_WINDOWS:    MyLoadString(szBuffer, IDS_WIN9X); break;
    case VER_PLATFORM_WIN32s:           MyLoadString(szBuffer, IDS_WIN3X); break;
    default:                            MyLoadString(szBuffer, IDS_UNKNOWN);
    }
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    // If this is NT, then get the processor architecture and log it
    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ZeroMemory(&sysinfo, sizeof(SYSTEM_INFO));
        GetSystemInfo(&sysinfo);
        // Initialize szBuffer to zeroes in case of an unknown architecture
        ZeroMemory(szBuffer, sizeof(szBuffer));
        switch (sysinfo.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_INTEL:  MyLoadString(szBuffer, IDS_X86); break;
        case PROCESSOR_ARCHITECTURE_MIPS:   MyLoadString(szBuffer, IDS_MIPS); break;
        case PROCESSOR_ARCHITECTURE_ALPHA:  MyLoadString(szBuffer, IDS_ALPHA); break;
        case PROCESSOR_ARCHITECTURE_PPC:    MyLoadString(szBuffer, IDS_PPC); break;
        }
        if (*szBuffer) {
            // Now write the processor type to the file
            WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        }
    }

    // Get the OS Version, Build, and CSD information and log it.
    MyLoadString(szBuffer2, IDS_OSVERSION);
    wsprintf(szBuffer, szBuffer2, osinfo.dwMajorVersion, osinfo.dwMinorVersion, (osinfo.dwBuildNumber & 0xFFFF), osinfo.szCSDVersion);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    // Print out the total/signed/unsigned results right before the file list
    MyLoadString(szBuffer2, IDS_TOTALS);
    wsprintf(szBuffer, szBuffer2,   g_App.dwFiles, g_App.dwSigned, g_App.dwUnsigned, 
             g_App.dwFiles - g_App.dwSigned - g_App.dwUnsigned);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

    // If we are doing a user-defined search, then log the parameters.
    if (g_App.bUserScan) {
        // Write the user-specified directory
        MyLoadString(szBuffer2, IDS_LOGHEADER3);
        wsprintf(szBuffer, szBuffer2, g_App.szScanPattern);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);

        // Write the user-specified search pattern
        MyLoadString(szBuffer2, IDS_LOGHEADER4);
        wsprintf(szBuffer, szBuffer2, g_App.szScanPath);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    }

    // Write the column headers to the log file
    MyLoadString(szBuffer, IDS_LOGHEADER5);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    MyLoadString(szBuffer, IDS_LOGHEADER6);
    WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
    PrintFileListItems(hFile);

    // Write the unscanned file headers to the log file
    if (g_App.dwFiles > (g_App.dwSigned + g_App.dwUnsigned)) {
        MyLoadString(szBuffer, IDS_LOGHEADER7);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        MyLoadString(szBuffer, IDS_LOGHEADER8);
        WriteFile(hFile, szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &dwBytesWritten, NULL);
        PrintUnscannedFileListItems(hFile);
    }

    CloseHandle(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cabs\symbolcd\place.inc ===
SYMBASEDIR=$(PROJECT_ROOT)\cabs\symbolcd

BINPLACE_PLACEFILE=$(SYMBASEDIR)\placefil.txt

ALT_PROJECT_TARGET=symbolcd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cabs\symbolcd\symsetup\resource.h ===
#define IDD_LICENSE         4000
#define IDC_EDIT_LICENSE    4002
#define IDC_UNUSED          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cabs\symbolcd\symsetup\runmyinf.h ===
// For Customer Support CD, the second inf is called symbols_sp.inf

TCHAR  szInfName2[_MAX_PATH*2] = _T("symbols_sp");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cabs\symbolcd\symsetup\commandline.c ===
#include "CommandLine.h"
#include <malloc.h>

BOOL WINAPI MakeSureDirectoryPathExistsW(LPCWSTR DirPath);

DWORD WINAPI CheckCommandLineOptions(INT ArgC, LPWSTR* ArgVW) {
    DWORD  dwReturnFlags = 0;
    INT    i;
    WCHAR* cp;
    WCHAR  wszInstallPath[MAX_PATH+1];

    for (i = 1; i < ArgC && wcschr(L"/-",ArgVW[i][0]) != NULL; ++i) {

        for (cp = &ArgVW[i][1]; *cp != L'\0'; ++cp) {
            switch (towupper(*cp)) {
                case L'U': {
                            HKEY  hKey;

                            LONG  lStatus          = 0;
                            LONG  lCreatedOrOpened = 0;
                            SET_FLAG(dwReturnFlags, FLAG_UNATTENDED_INSTALL);

                            // next param isn't a flag (or NULL), so it *must* be the path to install to
                            if ( (i+1 < ArgC) && wcschr(L"/-",ArgVW[i+1][0]) == NULL ) {
                                i++; // account for the parameter removed

                                SET_FLAG(dwReturnFlags, FLAG_UNATTENDED_PATH_PROVIDED);
                                StringCchCopyW(wszInstallPath, MAX_PATH+1, ArgVW[i]);

                                // make sure path ends in '\'
                                if (wszInstallPath[wcslen(wszInstallPath)]!=L'\\')
                                    StringCchCatW(wszInstallPath,MAX_PATH+1,L"\\");

                                // make sure the directory exists!
                                if (! MakeSureDirectoryPathExistsW(wszInstallPath) ) {
                                    SET_FLAG(dwReturnFlags, FLAG_FATAL_ERROR);
                                } else {
                                    // Either create the regkey (if it doesn't exist) or open it (if it
                                    // does exist). lCreatedOrOpened can be tested against
                                    // REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY to determine which
                                    // occurred.
                                    lStatus = RegCreateKeyExW(SYMBOLS_REGKEY_ROOT,
                                                              SYMBOLS_REGKEY_PATH,
                                                              0,
                                                              NULL,
                                                              REG_OPTION_NON_VOLATILE,
                                                              KEY_ALL_ACCESS,
                                                              NULL,
                                                              &hKey,
                                                              &lCreatedOrOpened);

                                    if (lStatus != ERROR_SUCCESS) {
                                        SET_FLAG(dwReturnFlags, FLAG_FATAL_ERROR);
                                    } else {
                                        // Write the value of the path to SYMBOLS_REGKEY
                                        lStatus = RegSetValueExW( hKey, SYMBOLS_REGKEY, 0, REG_SZ, (BYTE*)wszInstallPath, ((wcslen(wszInstallPath) + 1) * sizeof(WCHAR)));
                                        if (lStatus != ERROR_SUCCESS) {
                                            SET_FLAG(dwReturnFlags, FLAG_FATAL_ERROR);
                                        }
                                        // close the regkey
                                        lStatus = RegCloseKey( hKey );
                                        if (lStatus != ERROR_SUCCESS) {
                                            SET_FLAG(dwReturnFlags, FLAG_ERROR);
                                        }

                                    }
                                } // else ...
                                // couldn't set the path requests, so use what's
                                // already in the registry.

                            } // else ...
                            // no path provided, so don't set anything- setupapi will
                            // nicely use the existing key or default to the value
                            // specified in the INF
                            // StringCchCopyW(wszInstallPath, MAX_PATH+1, DEFAULT_INSTALL_PATH);
                        }
                        break;

                case L'Q': 
                        SET_FLAG(dwReturnFlags, FLAG_TOTALLY_QUIET);
                        break;

                case L'?': // explicit fall through
                case L'H': // explicit fall through
                default:
                        SET_FLAG(dwReturnFlags, FLAG_USAGE);
                        break;
            }
        }
    }

	if ( IS_FLAG_SET(dwReturnFlags, FLAG_USAGE) ) {
		WCHAR UsageBuffer[1024];

		StringCchPrintfW(UsageBuffer,
		                sizeof(UsageBuffer)/sizeof(WCHAR),
		                L"Usage: %s [ /u [<path>] [/q] ]\n\n"
						L"/u [<path>] \n"
						L"   Unattended install.  If <path> is specified install\n"
						L"   symbols to <path>. If no path is specified, symbols\n"
						L"   are installed to the default location.\n"
						L"   NOTE: USING UNATTENDED INSTALL MEANS YOU\n"
						L"   HAVE READ AND AGREED TO THE END USER LICENSE\n"
						L"   AGREEMENT FOR THIS PRODUCT.\n"
						L"/q\n"
						L"    Valid only when using unattended install. Prevents\n"
						L"    error messages from being display if unattended\n"
						L"    install fails.\n"
						L"/?\n"
						L"    Show this dialog box.\n\n"
						L"If no options are specified, the interactive installation\n"
						L" is started.",
						ArgVW[0]);


        MessageBoxW( NULL,
  					UsageBuffer,
                    L"Microsoft Windows Symbols",
                     0 );

	}

    return(dwReturnFlags);
}

// Modified from MakeSureDirectoryPathExists from dbghelp.h
// The same caveats apply. (see MSDN)
BOOL WINAPI MakeSureDirectoryPathExistsW(LPCWSTR DirPath) {
    LPWSTR p, DirCopy;
    DWORD  dw;

    // Make a copy of the string for editing.

    __try {
        DirCopy = (LPWSTR)malloc((wcslen(DirPath) + 1) * sizeof(WCHAR));

        if (!DirCopy) {
            return FALSE;
        }

        StringCchCopyW(DirCopy, wcslen(DirPath)+1, DirPath);

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == L'\\') && (*(p+1) == L'\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != L'\\') {
                p = CharNextW(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != L'\\') {
                p = CharNextW(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == L':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == L'\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = GetFileAttributesW(DirCopy);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectoryW(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            free(DirCopy);
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        free(DirCopy);
                        return FALSE;
                    }
                }

                *p = L'\\';
            }
            p = CharNextW(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
        free(DirCopy);
        return(FALSE);
    }

    free(DirCopy);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cabs\symbolcd\symsetup\runmyinf.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    runmyinf.c

Abstract:
    This windows app is the setup program for installing symbols off of
    the Customer Support Diagnostics CD.  It calls LaunchInfSection in
    advpack.dll to run "symbols.inf" that is sitting in the same directory.

    By default it launches DefaultInstall. 

    The setup is designed to be used with a chained install for the Customer
    Support CD for Service Packs.  If the Service Pack inf (symbols_sp.inf)
    is present in the same directory as symbols.inf, then the program launches
    DefaultInstall.Chained.1 in symbols.inf and DefaultInstall.Chained.2 
    in symbols_sp.inf.

Author:

    Barb Kess (barbkess) 19-July-1999

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "dbghelp.h"
#include "advpub.h"
#include "setupapi.h"
#include "spapip.h"
#include "winbase.h"
#include "tchar.h"
#include "resource.h"
#include "runmyinf.h"

#include "strsafe.h"

// header for CheckCommandLineOptions()
#include "CommandLine.h"

#define MAX_FILENAME        (300)

// Global variables
LPTSTR szEulaFile = _T("eula.txt");
TCHAR  szEulaFullPath[_MAX_PATH*2];
TCHAR  szInfName1[_MAX_PATH*2];
BOOL   ChainedInstall=FALSE;

// dwInstallOptions is global so all subs can test for FLAG_TOTALLY_QUIET and FLAG_UNATTENDED_INSTALL
DWORD  dwInstallOptions; 

//
// Call back procedure for displaying the license agreement
//

INT_PTR
CALLBACK
DlgProcDisplayLicense(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
);

BOOL
CopyFilesToTempDir(
    LPTSTR szSrcDir,
    LPTSTR szInfDir
);

BOOL
CopySomeFiles(
    LPTSTR szSrcDir,
    LPTSTR szDestDir,
    LPTSTR szFileName
);


BOOL
DeleteFilesAndTempDir(
    LPTSTR szTempDir
);

BOOL
GetTempDirName(
    LPTSTR szTempDir
);

BOOL
MyMakeSureDirectoryPathExists(
    LPCSTR DirPath
);

BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
);

BOOL
DeleteSymbolInstallKey(
);

BOOL
SymbolInstallKeyExists(
);

//
// Procedure taken from wextract.c code that centers the window
//

BOOL 
CenterWindow(
    HWND hwndChild,
    HWND hwndParent
);

//
// Procedure that reads the license agreement into a buffer
//

DWORD
GetMyBuffer(
    LPTSTR* pszBuf,
    LPTSTR  szFileName
);

//
// This setupapi function is only available on Windows 2000.
// Therefore it is getting loaded manually so NT4 installs won't
// throw up a pop-up saying it can't find this function
//

#define pSetupSetGlobalFlags ppSetupSetGlobalFlags
#define pSetupGetGlobalFlags ppSetupGetGlobalFlags

typedef VOID ( * PPSETUPSETGLOBALFLAGS )( DWORD );

typedef DWORD ( * PPSETUPGETGLOBALFLAGS )( VOID );

PPSETUPSETGLOBALFLAGS ppSetupSetGlobalFlags;
PPSETUPGETGLOBALFLAGS ppSetupGetGlobalFlags;

int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR lpszCmdLine,
        int nCmdShow
)
{
    HMODULE hdll = NULL;
    HRESULT hr = E_FAIL;

    TCHAR szCommand[_MAX_PATH*2]=_T("");      // Full path (including filename) of this exe
    int cchFileName;                          // Index into szCommand of the \ before the filename
    int cchNameOnly;                   
    TCHAR szInf2FullPath[_MAX_PATH*2]=_T(""); // Full path (including filename) of the 
                                              // international inf, if one exists
    TCHAR szSrcDir[_MAX_PATH*2]=_T("");       // Directory where symbols.exe was launched
    TCHAR szInfDir[_MAX_PATH*2]=_T("");       // Directory to Launch the Inf from
    TCHAR szInstallCommand1[_MAX_PATH * 2]=_T("");  // Command sent to LaunchINFSection.  If this
                                                    // is a chained install, this is the
                                                    // command sent to LaunchINFSection for the
                                                    // first part of the chained install. 
    TCHAR szInstallCommand2[_MAX_PATH * 2]=_T("");  // Command sent to LaunchINFSection for the
                                                    // second part of the chained install

    TCHAR  szDefaultInstall[_MAX_PATH*2] = _T("");
    TCHAR  szDefaultInstallChained1[_MAX_PATH*2] = _T("");
    TCHAR  szDefaultInstallChained2[_MAX_PATH*2] = _T("");

    DWORD rc;
    BOOL  ThisIsNT4=FALSE;             // Is this being installed on NT4?

    INT nAcceptLicense;
    WIN32_FIND_DATA FindFileData;

    OSVERSIONINFO VersionInfo;

    // Variables for handling command line flags
    //   Get lpszCmndLine as an array instead of as a flat string.  This means
    //   we don't have to roll our own logic for handling long and/or quoted file
    //   names- it gets done for us.
    //   No such API as CommandLineToArgvA, so this work is always done in Unicode.
    INT              iArgC;
    LPWSTR           cmdLine          = GetCommandLineW();
    LPWSTR *         lpArgVW          = CommandLineToArgvW(cmdLine, &iArgC);

    dwInstallOptions = CheckCommandLineOptions(iArgC, lpArgVW);
	if ( IS_FLAG_SET(dwInstallOptions, FLAG_USAGE) ) {
		// usage message is printed in CheckCommandLineOptions(), so just exit
		exit(0);
	}

    // don't allow FLAG_TOTALLY_QUIET unless doing an unattended install
    if ( IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL) ) {
            CLEAR_FLAG(dwInstallOptions, FLAG_TOTALLY_QUIET);
            MessageBox( NULL,
                        "It is not possible to do a quiet install without doing an unattended\ninstall. Defaulting to a normal install.",
                        "Microsoft Windows Symbols",
                        0 );

        }
	}

    // FLAG_FATAL_ERROR indicates that writing the registry key for FLAG_UNATTENDED_INSTALL failed
    if ( IS_FLAG_SET(dwInstallOptions,FLAG_UNATTENDED_INSTALL) && 
         IS_FLAG_SET(dwInstallOptions,FLAG_FATAL_ERROR)                 ) {

        // if FLAG_TOTALLY_QUIET, just exit
        if ( IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            exit(1);
        } else {
            // otherwise, default to an anttended install
            CLEAR_FLAG(dwInstallOptions, FLAG_UNATTENDED_INSTALL);
            CLEAR_FLAG(dwInstallOptions, FLAG_FATAL_ERROR);
            MessageBox( NULL,
                        "Microsoft Windows Symbols encountered an error doing the unattended\ninstall. Defaulting to a normal install.",
                        "Microsoft Windows Symbols",
                        0 );
        }
    }

    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VersionInfo );

    //
    // Give a friendly pop-up message if this is Win9x or NT 3.51
    //
    if ( (VersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ) ||
         (VersionInfo.dwMajorVersion < 4.0 ) )  {
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            MessageBox( NULL,
                        "Microsoft Windows Symbols does not install on this Operating System.",
                        "Microsoft Windows Symbols",
                        0 );
		}
        exit(0);
    }

    //
    // For NT 5 RC1 and greater, use pSetupSetGlobalFlags to keep old
    // symbol files from filling up people's hard drives with backed up symbols
    //
    // Not sure which build this was introduced in, but I know its broken if this
    // pSetupSetGlobalFlags procedure tries to load on NT4.
    //

    if (VersionInfo.dwBuildNumber >= 2072 ) {
        hdll = (HMODULE)LoadLibrary("setupapi.dll");
        if (hdll != NULL) {
            ppSetupSetGlobalFlags = ( PPSETUPSETGLOBALFLAGS )
                                GetProcAddress(
                                    hdll,
                                    "pSetupSetGlobalFlags"
                                );

            if (ppSetupSetGlobalFlags==NULL) {
                if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                    MessageBox( NULL,
                                "The install cannot finish because the function pSetupSetGlobalFlags is not in setupapi.dll",
                                "Microsoft Windows 2000 Symbols",
                                0 );
				}
                exit(0);
            }

            ppSetupGetGlobalFlags = ( PPSETUPGETGLOBALFLAGS )
                                GetProcAddress(
                                    hdll,
                                    "pSetupGetGlobalFlags"
                                );

            if (ppSetupGetGlobalFlags==NULL) {
                if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                    MessageBox( NULL,
                                "The install cannot finish because the function pSetupGetGlobalFlags is not in setupapi.dll",
                                "Microsoft Windows 2000 Symbols",
                                0 );
				}
                exit(0);
            }
        }

        //
        // Fix it so it doesn't try to keep old symbol files
        // and fill up people's hard drives with backed up symbols
        //

        pSetupSetGlobalFlags( pSetupGetGlobalFlags() | PSPGF_NO_BACKUP);
    }

    // Get this exe's full path name

    if (GetModuleFileName( NULL, szCommand, MAX_FILENAME ) == 0) {
        goto done;
    }

    // Get the index of the beginning of the filename by moving
    // backwards to the \ before the executable name.

    cchFileName = _tcslen( szCommand );
    while ( szCommand[cchFileName] != '\\'  && cchFileName >= 0 ) {
        cchFileName--;
    }
    if ( cchFileName < 0 ) exit(1);

    // Create a string for the InfName

    StringCbCopy ( szInfName1, _MAX_PATH*2*sizeof(TCHAR), szCommand+cchFileName+1 );

    cchNameOnly = _tcslen( szInfName1 );
    while ( szInfName1[cchNameOnly] != '.'  && cchNameOnly >= 0 ) {
        cchNameOnly--;
    }
    if ( cchNameOnly < 0 ) exit(1);
    szInfName1[cchNameOnly] = _T('\0');

    // Create a string containing the Default Install command
    StringCbCopy ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), _T(".inf, DefaultInstall") );

    if (IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        StringCbCat ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), _T(".Quiet") );
    }

    // Make this work for the way Windows 2000 SRP has the names
    // of the sections in their infs
    if ( (_tcscmp(szInfName1, _T("symbols_srp")) == 0) ||
         (_tcscmp(szInfName1, _T("symbols_sp")) == 0) ) {
        StringCbCat ( szDefaultInstall, _MAX_PATH*2*sizeof(TCHAR), _T(".x86") );
    }

    // Create a string for the DefaultInstall.Chained.1
    StringCbCopy ( szDefaultInstallChained1, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat ( szDefaultInstallChained1, _MAX_PATH*2*sizeof(TCHAR), _T(".inf, DefaultInstall.Chained.1") );

    if (IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        StringCbCat ( szDefaultInstallChained1, _MAX_PATH*2*sizeof(TCHAR), _T(".Quiet") );
    }

    // Create a string for the DefaultInstall.Chained.2
    StringCbCopy ( szDefaultInstallChained2, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
    StringCbCat ( szDefaultInstallChained2, _MAX_PATH*2*sizeof(TCHAR), _T(".inf, DefaultInstall.Chained.2") );

    if (IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        StringCbCat ( szDefaultInstallChained2, _MAX_PATH*2*sizeof(TCHAR), _T(".Quiet") );
    }

    // Create a string containing the directory where the inf is
    StringCbCopy( szInfDir, _MAX_PATH*2*sizeof(TCHAR), szCommand);
    szInfDir[cchFileName+1] = _T('\0');

    // Create a string containing this install directory
    StringCbCopy ( szSrcDir, _MAX_PATH*2*sizeof(TCHAR), szCommand);
    szSrcDir[cchFileName+1] = _T('\0');

    StringCbCopy ( szEulaFullPath, _MAX_PATH*2*sizeof(TCHAR), szCommand);
    StringCbCopy ( &szEulaFullPath[cchFileName+1], _MAX_PATH*2*sizeof(TCHAR), szEulaFile);


    // Unattended install implies the EULA has already been agreed to
    if (! IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
        DWORD  dwSize = 0;
        LPTSTR szBuf;
        
        //
        // Make sure the EULA exists
        //
        dwSize = GetMyBuffer(&szBuf, szEulaFullPath);
        if (dwSize == 0) {
            if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                MessageBox( NULL,
                            "The End User License Agreement could not be found.",
                            "Windows Symbols",
                            0 );
			}
            exit(1);
        }

        free(&szBuf);

        // Display license agreement
        nAcceptLicense = (INT) DialogBox( hInstance,
                                          MAKEINTRESOURCE(IDD_LICENSE),
                                          NULL,
                                          DlgProcDisplayLicense
                                        );

        if ( nAcceptLicense != IDYES ) {
            MessageBox( NULL,
                        "You need to accept the license agreement in order to install Windows Symbols.",
                        "Windows Symbols",
                        0 );
            exit(1);
        }
    }

    //
    // Decide if this is a chained install or not.
    //

    StringCbCopy ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szSrcDir);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szInfName2);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

    ChainedInstall=TRUE;

    if ( _tcscmp( szInfName1, szInfName2 ) == 0 ) {
        ChainedInstall=FALSE;

    } else if (FindFirstFile( szInf2FullPath, &FindFileData) == INVALID_HANDLE_VALUE) {
        ChainedInstall=FALSE;
    } 

    //
    // If this is NT4, do a work around for a bug in setupapi
    // Setupapi can't get the name of the cab correctly unless it is in
    // the root of the CD.
    // Workaround is to copy the files to a temp directory.
    // If this is NT4 and the setup isn't being run from a CD-ROM, we don't have to
    // copy the files to a temp directory.


    if ( (GetDriveType(NULL) == DRIVE_CDROM) &&
         (VersionInfo.dwMajorVersion < 5.0 ) ) {
        ThisIsNT4 = TRUE;

        if (! IS_FLAG_SET(dwInstallOptions, FLAG_UNATTENDED_INSTALL)) {
            MessageBox( NULL,
                        "The installer needs to copy some files to a temporary directory.  This may take several minutes.",
                        "Windows Symbols",
                        0 );
        }

        rc = CopyFilesToTempDir(szSrcDir,szInfDir);
        if (!rc) {
            if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                MessageBox( NULL,
                            "Setup failed to copy all the files to a temporary directory",
                            "Windows Symbols",
                            0 );
			}
            DeleteFilesAndTempDir(szInfDir);
            exit(1);
        }
    }

    //
    // See if the second inf exists in this directory.  If it does then
    // call the chained installs. Otherwise call the section that only 
    // installs the US file.
    //

    StringCbCopy ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szInfDir);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), szInfName2);
    StringCbCat ( szInf2FullPath, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

    if (FindFirstFile( szInf2FullPath, &FindFileData) == INVALID_HANDLE_VALUE) {

        StringCbCopy( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szInfDir );
        StringCbCat( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szDefaultInstall );

    } else {

        StringCbCopy( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szInfDir );
        StringCbCat( szInstallCommand1, _MAX_PATH*2*sizeof(TCHAR), szDefaultInstallChained1 );

        StringCbCopy( szInstallCommand2, _MAX_PATH*2*sizeof(TCHAR), szInfDir );
        StringCbCat( szInstallCommand2, _MAX_PATH*2*sizeof(TCHAR), szDefaultInstallChained2 );
    }

    /* tell AdvPack to process this INF */
    DeleteSymbolInstallKey();

    hr = LaunchINFSection( NULL, hInstance, szInstallCommand1, 0 );

    if ( ChainedInstall && SymbolInstallKeyExists() ) {
        hr = LaunchINFSection( NULL, hInstance, szInstallCommand2, 0 );
    }

    if ( ThisIsNT4) {
        DeleteFilesAndTempDir( szInfDir );
    } 

done:
    return( (int) hr );
}



INT_PTR
CALLBACK
DlgProcDisplayLicense(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{

    //
    // This is the callback procedure for displaying the
    // license agreement.
    //

    DWORD dwSize;
    LPTSTR szBuf;
    HWND hwndCtrl;

    // Get the license agreement text and store it in szBuf
    dwSize = GetMyBuffer(&szBuf, szEulaFullPath);
    if (dwSize == 0) {
        return FALSE;
    }

    switch (uMsg) {

        case WM_INITDIALOG:
            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetDlgItemText( hwndDlg, IDC_EDIT_LICENSE, szBuf );
            hwndCtrl = GetDlgItem(hwndDlg, IDC_EDIT_LICENSE);
            PostMessage(hwndCtrl, EM_SETSEL, -1, -1);
            return TRUE;

        case WM_CLOSE:
            EndDialog( hwndDlg, IDNO );
            return TRUE;

        case WM_COMMAND:
            switch ( LOWORD (wParam) )
            {
                case IDYES: EndDialog( hwndDlg, IDYES );
                            return (TRUE);

                case IDNO:  EndDialog( hwndDlg, IDNO );
                            return (TRUE);
            }
            break;
    }
    return FALSE;
}


BOOL CenterWindow( HWND hwndChild, HWND hwndParent )
{
    RECT rChild;
    RECT rParent;
    int  wChild;
    int  hChild;
    int  wParent;
    int  hParent;
    int  wScreen;
    int  hScreen;
    int  xNew;
    int  yNew;
    HDC  hdc;

    //
    // This is a procedure I got from the wextract.c code -- it centers the
    // window.
    //
    // Returns: BOOL
    //          True if successful,
    //          False otherwise
    //

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    if (hdc == NULL) {
        return FALSE;
    }
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return( SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER));
}



DWORD
GetMyBuffer(
    LPTSTR* pszBuf,
    LPTSTR  szFileName
)
{
    //
    // Reads contents of szFileName into a buffer.
    //
    // OUT pszBuf
    // IN  szFileName
    //
    // Return Value: size of the buffer
    //

    HANDLE hFile;
    DWORD dwSize;
    DWORD NumBytesRead;

    hFile = CreateFile( (LPCTSTR) szFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    // handle a missing EULA
    if (hFile == INVALID_HANDLE_VALUE ) {
        return(0);
    }

    dwSize = GetFileSize( hFile, NULL );

    *pszBuf = (LPTSTR)malloc( dwSize * sizeof(TCHAR) );

    if ( *pszBuf == NULL ) {
        return(0);
    }

    if (!ReadFile( hFile,
                   (LPVOID)*pszBuf,
                   dwSize,
                   &NumBytesRead,
                   NULL )
                   ) {
        free(*pszBuf);
        return(0);
    }

    return (dwSize);

}

BOOL
CopyFilesToTempDir(
    LPTSTR szSrcDir,
    LPTSTR szInfDir
)
{                  

    /* szSrcDir - IN - Directory that symbols.exe was launched from
       szInfDir - OUT - Directory that INF is copied to

       Purpose: Copy files to a temporary directory

     */

    BOOL rc;

    HINF hInf;
    PVOID Context;
    TCHAR szInfFile[_MAX_PATH * 2];
    TCHAR buf[_MAX_PATH * 2];
    

    GetTempDirName(szInfDir);    

    // Create the Temporary Install Directory
    rc = MyMakeSureDirectoryPathExists( szInfDir );
    if (!rc) {
        StringCbPrintf( buf, 
                       _MAX_PATH*2*sizeof(TCHAR),
                        "Installation failed because it can't create the temporary directory %s.", szInfDir );
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            MessageBox( NULL,
                        buf,
                        "Microsoft Windows 2000 Symbols",
                        0 );
		}
        return FALSE;
    }

    // Copy the 3 files associated with szInfName1

    StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cab") );
   
    rc = CopySomeFiles(szSrcDir, szInfDir, buf );
    if (!rc) return FALSE;

    StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cat") );

    rc = CopySomeFiles(szSrcDir, szInfDir, buf );
    if (!rc) return FALSE;

    StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName1 );
    StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

    rc = CopySomeFiles(szSrcDir, szInfDir, buf );
    if (!rc) return FALSE;

    // If this is a chained install, copy the 3 files associated
    // with szInfName2

    if (ChainedInstall) {

      StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
      StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cab") );
   
      rc = CopySomeFiles(szSrcDir, szInfDir, buf );
      if (!rc) return FALSE;

      StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
      StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".cat") );

      rc = CopySomeFiles(szSrcDir, szInfDir, buf );
      if (!rc) return FALSE;

      StringCbCopy(buf, _MAX_PATH*2*sizeof(TCHAR), szInfName2 );
      StringCbCat(buf, _MAX_PATH*2*sizeof(TCHAR), _T(".inf") );

      rc = CopySomeFiles(szSrcDir, szInfDir, buf );
      if (!rc) return FALSE;

    }

    // Copy the other two files that are needed for the install
    // onto NT4

    rc = CopySomeFiles(szSrcDir, szInfDir, _T("eula.txt") );
    if (!rc) return FALSE;

    rc = CopySomeFiles(szSrcDir, szInfDir, _T("advpack.dll") );
    if (!rc) return FALSE;

    return (TRUE);
}

BOOL
DeleteFilesAndTempDir(
    LPTSTR szTempDir
)
{

    /*
       szTempDir -IN - Directory to delete

       Purpose: Delete the files in the temporary directory.

    */
    BOOL rc;

    DeleteAllFilesInDirectory(szTempDir);
    rc = RemoveDirectory(szTempDir);
    RemoveDirectory(szTempDir);
    return (TRUE);
}



BOOL
GetTempDirName( 
    LPTSTR szTempDir
)
{

    DWORD dwPathLength;
    BOOL rc, Finished;
    UINT Num;
    TCHAR szNum[20];
    DWORD Length;

    HINF hInf;
    PVOID Context;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;
    TCHAR szInfDir[_MAX_PATH];
    TCHAR buf[_MAX_PATH * 2];
    HANDLE hFile;

    dwPathLength = GetTempPath( _MAX_PATH, szTempDir);

    if ( dwPathLength == 0 ) return FALSE;
    if ( dwPathLength > _MAX_PATH) return FALSE;

    // Append the symbol install temp dir
    StringCbCat(szTempDir, _MAX_PATH*2*sizeof(TCHAR), _T("sym") );

    Finished = FALSE;
    Length = _tcslen(szTempDir);
    Num = 0;
    while ( !Finished) {
        Num++;
        _itoa( Num, szNum, 10 );
       
        StringCbCopy( szTempDir+Length, (_MAX_PATH*2 - Length) * sizeof(TCHAR), szNum );
        StringCbCat( szTempDir, _MAX_PATH*2*sizeof(TCHAR), _T("\\") );

        hFile = CreateFile( szTempDir,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL, 
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     NULL );

        if ( hFile == INVALID_HANDLE_VALUE ) {
            Finished = TRUE;    
        }
    }

    // Create the Temporary Install Directory
    rc = MyMakeSureDirectoryPathExists( szTempDir );
    if (!rc) {
        StringCbPrintf( buf, 
                        _MAX_PATH*2*sizeof(TCHAR),
                        "Installation failed because it can't create the temporary directory %s.", szTempDir );
        if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
            MessageBox( NULL,
                        buf,
                        "Microsoft Windows 2000 Symbols",
                        0 );
		}
        return FALSE;
    }
    return TRUE;
}



BOOL
MyMakeSureDirectoryPathExists(
    LPCSTR DirPath
    )
{
    LPTSTR p, DirCopy;
    DWORD dw;

    // Make a copy of the string for editing.

    __try {
        DirCopy = (LPTSTR) malloc(_tcslen(DirPath) + 1);

        if (!DirCopy) {
            return FALSE;
        }

        StringCbCopy( DirCopy, 
                      (_tcslen(DirPath) + 1) * sizeof(TCHAR), 
                      DirPath );

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = GetFileAttributes(DirCopy);
                // Nothing exists with this name.  Try to make the directory name 
                // and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            free(DirCopy);
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, 
                        // but it's not a directory... Error
                        free(DirCopy);
                        return FALSE;
                    }
                }

                *p = '\\';
            }
            p = CharNext(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // ImagepSetLastErrorFromStatus( GetExceptionCode() );
        free(DirCopy);
        return(FALSE);
    }

    free(DirCopy);
    return TRUE;
}


BOOL
CopySomeFiles(
    LPTSTR szSrcDir,
    LPTSTR szDestDir,
    LPTSTR szFileName
)
{

TCHAR szSearchFileName[_MAX_PATH * 2];
TCHAR szDestFileName[_MAX_PATH * 2];
TCHAR szFoundFileName[_MAX_PATH * 2];
TCHAR szBuf[_MAX_PATH * 3];

WIN32_FIND_DATA Win32FindData;
HANDLE hFindFile;
BOOL Found;
BOOL rc;

    // Copy the catalog files
    StringCbCopy(szSearchFileName, _MAX_PATH*2*sizeof(TCHAR), szSrcDir);
    StringCbCat(szSearchFileName, _MAX_PATH*2*sizeof(TCHAR), szFileName );

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szSearchFileName, &Win32FindData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    while ( Found ) {
        StringCbCopy(szFoundFileName, _MAX_PATH*2*sizeof(TCHAR), szSrcDir);
        StringCbCat(szFoundFileName, _MAX_PATH*2*sizeof(TCHAR), Win32FindData.cFileName);

        StringCbCopy(szDestFileName, _MAX_PATH*2*sizeof(TCHAR), szDestDir);
        StringCbCat(szDestFileName, _MAX_PATH*2*sizeof(TCHAR), Win32FindData.cFileName);

        rc = CopyFile(szFoundFileName, szDestFileName, FALSE);
        if (!rc) {
            if ( GetLastError() == ERROR_HANDLE_DISK_FULL ) {
                StringCbPrintf( szBuf, 
                                _MAX_PATH*2*sizeof(TCHAR),
                                _T("There is not enough disk space in the temporary directory %s %s"),
                                szDestDir, 
                                _T("to complete the install.") );

                if (! IS_FLAG_SET(dwInstallOptions, FLAG_TOTALLY_QUIET) ) {
                    MessageBox( NULL,
                                szBuf,
                                "Microsoft Windows 2000 Symbols",
                                0 );
				}

            }
            RemoveDirectory(szDestDir);
            return (FALSE);
        }

        Found = FindNextFile( hFindFile, &Win32FindData );

    }
    return (TRUE);
}


BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
)
{

    HANDLE hFindFile;
    BOOL Found = FALSE;
    BOOL rc = TRUE;
    LPTSTR szBuf;
    LPTSTR szDir2;
    LPWIN32_FIND_DATA lpFindFileData;

    szDir2 = (LPTSTR)malloc( (_tcslen(szDir) + 4) * sizeof(TCHAR) );
    if (szDir2 == NULL) return (FALSE);
    StringCbCopy( szDir2, (_tcslen(szDir) + 4) * sizeof(TCHAR), szDir);
    StringCbCat( szDir2, (_tcslen(szDir) + 4) * sizeof(TCHAR), _T("*.*") );

    szBuf = (LPTSTR)malloc( ( _tcslen(szDir) + _MAX_FNAME + _MAX_EXT + 2 )
                            * sizeof(TCHAR) );
    if (szBuf == NULL) return(FALSE);


    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) return(FALSE);

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szDir2, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    }

    while ( Found ) {

        if ( !(lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
            StringCbPrintf( szBuf, (_tcslen(szDir) + _MAX_FNAME + _MAX_EXT + 2) * sizeof(TCHAR), 
                            _T("%s%s"), 
                            szDir, 
                            lpFindFileData->cFileName);
            if (!DeleteFile(szBuf)) {
                rc = FALSE;
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);
    }
    free(lpFindFileData);
    FindClose(hFindFile);
    free(szDir2);
    free(szBuf);
    return(rc);
}



BOOL DeleteSymbolInstallKey()
{
    DWORD rc;
    LONG  rc2;
    HKEY  hKeySymbols;

    rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                       _T("software\\microsoft\\Symbols"),
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                       &hKeySymbols
                     );

    if (rc == ERROR_SUCCESS) {
        rc2 = RegDeleteKey( hKeySymbols,
                            _T("SymbolInstall")
                          );
    }

    if (rc) {
      RegCloseKey(hKeySymbols);
    }

    return (TRUE);

}

BOOL SymbolInstallKeyExists ()
{

    DWORD rc;
    LONG  rc2;
    HKEY  hKeySymbols;

    rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                       _T("software\\microsoft\\Symbols\\SymbolInstall"),
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                       &hKeySymbols
                     );

    if (rc == ERROR_SUCCESS) {
        RegCloseKey(hKeySymbols);
        return(TRUE);
    } else {
        return (FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cabs\symbolcd\symsetup\commandline.h ===
#include <windows.h>
#include <Shellapi.h>
#include <strsafe.h>

// flag values for CheckCommandLineOptions return value
#define FLAG_USAGE                      (0x0001)
#define FLAG_UNATTENDED_INSTALL         (0x0002)
#define FLAG_UNATTENDED_PATH_PROVIDED   (0x0004)
#define FLAG_TOTALLY_QUIET              (0x0008)
#define FLAG_ERROR                      (0x7000)
#define FLAG_FATAL_ERROR                (0x8000)

// macros to set/check/clear flag values
#define SET_FLAG(x,y)                   (x |= y)
#define CLEAR_FLAG(x,y)                 (x &= (~y))
#define IS_FLAG_SET(x,y)                (x & y)

// regkey and default value
#define SYMBOLS_REGKEY_ROOT             HKEY_CURRENT_USER
#define SYMBOLS_REGKEY_PATH             L"SOFTWARE\\Microsoft\\Symbols\\Directories"
#define SYMBOLS_REGKEY                  L"Symbol Dir"
#define DEFAULT_INSTALL_PATH            L"%WINDIR%\\symbols"

// function for parsing the command line parameters
DWORD WINAPI CheckCommandLineOptions(INT ArgC, LPWSTR* ArgVW);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\daclwrap.cxx ===
//+-------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
//  File:        daclwrap.cxx
//
//  Contents:    class encapsulating file security.
//
//  Classes:     CDaclWrap
//
//  History:     Nov-93        Created         DaveMont
//
//--------------------------------------------------------------------
#include <t2.hxx>
#include <daclwrap.hxx>

#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap::CDaclWrap, public
//
//  Synopsis:   initialize data members, constructor will not throw
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDaclWrap::CDaclWrap()
      : _ccaa(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   cleanup allocated data
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDaclWrap::~CDaclWrap()
{
    for (ULONG j = 0; j < _ccaa; j++)
        delete _aaa[j].pcaa;
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap::SetAccess, public
//
//  Synopsis:   caches data for a new ACE
//
//  Arguments:  IN [option] - rePlace, Revoke, Grant, Deny
//              IN [Name] - principal (username)
//              IN [System] - server/machine where Name is defined
//              IN [access] - access mode (Read Change None All)
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::SetAccess(ULONG option, WCHAR *Name, WCHAR *System, ULONG access)
{
    ULONG ret;

    // sorry, static number of ACCESSes can be set at one time

    if (_ccaa >= CMAXACES)
        return(ERROR_BUFFER_OVERFLOW);

    // allocate a new account access class

    if (NULL == (_aaa[_ccaa].pcaa = new CAccountAccess(Name, System)))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // to fix the bug where someone asks to both grant and deny under
    // the /p option (the deny is thru access = N)

    if ((GENERIC_NONE == access) && (OPTION_REPLACE == option))
    {
        _aaa[_ccaa].option = OPTION_DENY;
    } else
    {
        _aaa[_ccaa].option = option;
    }

    SID *psid;

    if (ERROR_SUCCESS == ( ret = _aaa[_ccaa].pcaa->Init(access)))
    {
        // get the sid to make sure the username is valid

        if (ERROR_SUCCESS == ( ret =_aaa[_ccaa].pcaa->Sid(&psid)))
        {
            // loop thru the existing sids, making sure the new one is not a duplicate

            SID *poldsid;
            for (ULONG check = 0;check < _ccaa ; check++)
            {
                if (ERROR_SUCCESS == ( ret =_aaa[check].pcaa->Sid(&poldsid)))
                {
                    if (EqualSid(psid,poldsid))
                    {
                        VERBOSE((stderr, "SetAccess found matching new sids\n"))
                        return(ERROR_BAD_ARGUMENTS);
                    }
                }
            }
            _ccaa++;
        }
    }
    return(ret);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:BuildAcl, public
//
//  Synopsis:   merges cached new aces with the input ACL
//
//  Arguments:  OUT [pnewdacl] - Address of new ACL to build
//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN  [revision] - ACL revision
//              IN  [fdir]     - True = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::BuildAcl(ACL **pnewdacl, ACL *poldacl, UCHAR revision, BOOL fdir)
{
    ULONG ret, caclsize;

    // get the size of the new ACL we are going to create

    if (ERROR_SUCCESS == (ret =  _GetNewAclSize(&caclsize, poldacl, fdir)))
    {
        // allocate the new ACL

        if (ERROR_SUCCESS == (ret =  _AllocateNewAcl(pnewdacl, caclsize, revision)))
        {
            // and fill it up

            if (ERROR_SUCCESS != (ret =  _FillNewAcl(*pnewdacl, poldacl, fdir)))
            {
                // free the buffer if we failed

                LocalFree(*pnewdacl);
            }

        }
    }
    return(ret);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_GetNewAclSize, private
//
//  Synopsis:   returns the size need to merge the new ACEs with the old ACL,
//              this is an ugly algorithm:
//
//if (old aces exist)
//   for (new aces)
//      if (new ace option == GRANT)
//         for (old aces)
//            if (new ace SID == old ace SID)
//               do inheritance check
//               found = true
//               if (old ace type == ALLOWED)
//                  old ace mask |= new ace mask
//               else
//                  old ace mask &= ~new ace mask
//         if (!found)
//            add size of new ace
//         else
//            new ace mask = 0
//      else
//         add size of new ace
//
//   for (old aces)
//      for (new aces)
//         if (new ace option == DENY, REPLACE, REVOKE)
//            if (new ace SID == old ace SID)
//               found = true
//               break
//      if (!found)
//         add size of old ace
//      else
//         old ace mask = 0
//else
//   for (new aces)
//      add size of new ace
//
//
//  Arguments:  OUT [caclsize] - returns size
//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN  [fdir]     - True = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_GetNewAclSize(ULONG *caclsize, ACL *poldacl, BOOL fdir)
{
    ULONG ret;

    // the size for the ACL header

    *caclsize = sizeof(ACL);

    // initialize the access requests
    for (ULONG j = 0; j < _ccaa; j++)
       _aaa[j].pcaa->ReInit();

    // if we are merging, calculate the merge size

    if (poldacl && (poldacl->AceCount != 0))
    {
        // first the grant options

        for (j = 0; j < _ccaa; j++)
        {
            SID *psid;
            if (OPTION_GRANT == _aaa[j].option)
            {
                BOOL ffound = FALSE;
                ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

                for (ULONG cace = 0; cace < poldacl->AceCount;
                     cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
                {
                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                    {
                        if (EqualSid(psid,
                                     (SID *)&((ACCESS_ALLOWED_ACE *)
                                     pah)->SidStart) )
                        {
                            // if old and new types are the same, just and with the old

                            if (fdir && (pah->AceType == _aaa[j].pcaa->AceType()))
                            {
                                // make sure that we can handle the inheritance
                                _aaa[j].pcaa->AddInheritance(pah->AceFlags);

                                ffound = TRUE;
                            } else if (pah->AceType == _aaa[j].pcaa->AceType())
                            {
                                ffound = TRUE;
                            }

                            if (ACCESS_ALLOWED_ACE_TYPE == pah->AceType)
                            {
                                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)
                                pah)->Mask |= _aaa[j].pcaa->AccessMask();
                            } else if (ACCESS_DENIED_ACE_TYPE == pah->AceType)
                            {
                                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)
                                pah)->Mask &= ~_aaa[j].pcaa->AccessMask();
                            } else
                            {
                                VERBOSE((stderr, "_GetNewAclSize found an ace that was not allowed or denied\n"))
                                return(ERROR_INVALID_DATA);
                            }
                        }
                    } else
                    {
                        return(ret);
                    }
                }
                if (!ffound)
                {
                    // bugbug allowed/denied sizes currently the same

                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                                 sizeof(DWORD) +
                                 GetLengthSid(psid);

                    SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
                } else
                {
                    if (fdir && (ERROR_SUCCESS != (ret = _aaa[j].pcaa->TestInheritance())))
                        return(ret);
                    _aaa[j].pcaa->ClearAccessMask();
                }
            } else if ( (OPTION_REPLACE == _aaa[j].option) ||
                        (OPTION_DENY == _aaa[j].option) )
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    // bugbug allowed/denied sizes currently the same

                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                                 sizeof(DWORD) +
                                 GetLengthSid(psid);

                    SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
                } else
                    return(ret);
            }
        }
        // now for the deny, replace & revoke options

        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));
        SID *psid;

        // loop thru the old ACL

        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
            BOOL ffound = FALSE;

            // and thru the new ACEs looking for matching SIDs

            for (ULONG j = 0; j < _ccaa; j++)
            {
                if ( (_aaa[j].option & OPTION_DENY ) ||
                     (_aaa[j].option & OPTION_REPLACE ) ||
                     (_aaa[j].option & OPTION_REVOKE ) )
                {
                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                    {
                        if (EqualSid(psid,
                                     (SID *)&((ACCESS_ALLOWED_ACE *)
                                     pah)->SidStart) )
                        {
                            ffound = TRUE;
                        }
                    } else
                        return(ret);
                }
            }
            if (!ffound)
            {
                // if we did not find a match, add the size of the old ACE

                *caclsize += ((ACE_HEADER *)pah)->AceSize;

                SIZE((stderr, "adding on size of an old ACE (to the new ACL) = %d\n",*caclsize))
            } else
            {
                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)->Mask = 0;
            }
        }
        SIZE((stderr, "final size for new ACL = %d\n",*caclsize))
    } else
    {
        // no old ACL, just add up the sizes of the new aces

        for (j = 0; j < _ccaa; j++)
        {
            // need to know the size of the sid

            SID *psid;
            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
            {
                // bugbug allowed/denied sizes currently the same

                *caclsize += sizeof(ACCESS_ALLOWED_ACE) -
                             sizeof(DWORD) +
                             GetLengthSid(psid);

                SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize))
            } else
            {
                return(ret);
            }
        }
        SIZE((stderr, "final size for new ACL = %d\n",*caclsize))
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_AllocateNewAcl, private
//
//  Synopsis:   allocates and initializes the new ACL
//
//  Arguments:  OUT [pnewdacl] - address of new ACL to allocate
//              IN  [caclsize] - size to allocate for the new ACL
//              IN  [revision] - revision of the new ACL
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_AllocateNewAcl(ACL **pnewdacl, ULONG caclsize, ULONG revision)
{
    if (NULL == (*pnewdacl = (ACL *) LocalAlloc(LMEM_FIXED, caclsize)))
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!InitializeAcl(*pnewdacl,caclsize, revision))
    {
        ULONG ret = GetLastError();
        LocalFree(*pnewdacl);
        return(ret);

    }

    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_SetAllowedAce, private
//
//  Synopsis:   appends an allowed ACE to the input ACL
//
//  Arguments:  IN [dacl] - ACL to add the ACE to
//              IN [mask] - access mask to add
//              IN [psid] - SID to add
//              IN [fdir] - if a Dir add inherit ACE as well
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_SetAllowedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir)
{
    ULONG ret = ERROR_SUCCESS;

    // compute the size of the ACE we are making

    USHORT acesize = (USHORT)(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psid));

    SIZE((stderr, "adding allowed ace, size = %d\n",fdir ? acesize*2 : acesize))

    // static buffer in the hopes we won't have to allocate memory

    BYTE buf[1024];

    // allocator either uses buf or allocates a new buffer if size is not enough

    FastAllocator fa(buf, 1024);

    // get the buffer for the ACE

    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)fa.GetBuf(acesize);
    if (!paaa) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // fill in the ACE

    memcpy(&paaa->SidStart,psid,GetLengthSid(psid));
    paaa->Mask = mask;

    paaa->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    paaa->Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0;
    paaa->Header.AceSize = acesize;

    // put the ACE into the ACL

    if (!AddAce(dacl,
                dacl->AclRevision,
                0xffffffff,
                paaa,
                paaa->Header.AceSize))
        ret = GetLastError();
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_SetDeniedAce, private
//
//  Synopsis:   appends a denied ACE to the input ACL
//
//  Arguments:  IN [dacl] - ACL to add the ACE to
//              IN [mask] - access mask to add
//              IN [psid] - SID to add
//              IN [fdir] - if a Dir add inherit ACE as well
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_SetDeniedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir)
{
    ULONG ret = ERROR_SUCCESS;

    // compute the size of the ACE we are making

    USHORT acesize = (USHORT)(sizeof(ACCESS_DENIED_ACE) -
                              sizeof(DWORD) +
                              GetLengthSid(psid));

    SIZE((stderr, "adding denied ace, size = %d\n",acesize))

    // static buffer in the hopes we won't have to allocate memory

    BYTE buf[1024];

    // allocator either uses buf or allocates a new buffer if size is not enough

    FastAllocator fa(buf, 1024);

    // get the buffer for the ACE

    ACCESS_DENIED_ACE *paaa = (ACCESS_DENIED_ACE *)fa.GetBuf(acesize);
    if (!paaa)
        return (ERROR_NOT_ENOUGH_MEMORY);

    // fill in the ACE

    memcpy(&paaa->SidStart,psid,GetLengthSid(psid));
    paaa->Mask = mask;

    paaa->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    paaa->Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0;
    paaa->Header.AceSize = acesize;

    // put the ACE into the ACL

    if (!AddAce(dacl,
                dacl->AclRevision,
                0xffffffff,
                paaa,
                paaa->Header.AceSize))
        ret = GetLastError();
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDaclWrap:_FillNewAcl, private
//
//  Synopsis:   The worker routine that actually fills the ACL, it adds the
//              new denied ACEs, then if the new ACEs are being merged with
//              an existing ACL, the existing ACL's ACE's (that don't
//              conflict) are added, finally the new allowed ACEs are added.
//              another ugly algorithm:
//
//for (new aces)
//   if (new ace option == DENY)
//      add new ace
//
//if (old aces)
//   for (old aces)
//      if (old ace mask != 0)
//         add old ace
//
//   for (new aces)
//      if (new ace option != DENY)
//         if ( new ace option != REVOKE)
//            if (new ace mask != 0
//                add new ace
//
//else
//   for (new aces)
//      if (new ace option != DENY)
//         add new ace
//
//  Arguments:  IN [pnewdacl] - the new ACL to be filled
//              IN [poldacl]  - (OPTIONAL) old ACL that is to be merged
//              IN [fdir]     - TRUE = directory
//
//----------------------------------------------------------------------------
ULONG CDaclWrap::_FillNewAcl(ACL *pnewdacl, ACL *poldacl, BOOL fdir)
{
    SID *psid = NULL;
    ULONG ret;

    // set new denied aces

    VERBOSE((stderr, "start addr of new ACL %p\n",pnewdacl))

    for (ULONG j = 0; j < _ccaa; j++)
    {
        if (_aaa[j].option & OPTION_DENY)
        {
            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
            {
                if (!psid) {
                    return (ERROR_INVALID_DATA);
                }
                if (ERROR_SUCCESS != (ret = _SetDeniedAce(pnewdacl,
                                                           _aaa[j].pcaa->AccessMask(),
                                                           psid,
                                                           fdir )))
                    return(ret);
            } else
                return(ret);
        }
    }

    // check and see if the ACL from from the file is in correct format

    if (poldacl)
    {
        SIZE((stderr, "old ACL size = %d, acecount = %d\n",poldacl->AclSize,
              poldacl->AceCount))

        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

		//
        // loop thru the old ACL, and add all explicit aces
		//

        BOOL fallowedacefound = FALSE;
        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
            // error exit if the old ACL is incorrectly formated

			if(pah->AceFlags & INHERITED_ACE)
				continue;


            if (pah->AceType == ACCESS_DENIED_ACE_TYPE && fallowedacefound)
            {
                VERBOSE((stderr, "_FillNewAcl found an denied ACE after an allowed ACE\n"))
                return(ERROR_INVALID_DATA);
            }
            else if (pah->AceType == ACCESS_ALLOWED_ACE_TYPE)
                fallowedacefound = TRUE;

            // add the old ace to the new ACL if the old ace's mask is not zero

            if ( 0 != (ACCESS_MASK)((ACCESS_ALLOWED_ACE *)pah)->Mask)
            {
                // add the old ace
                if (!AddAce(pnewdacl,
                            pnewdacl->AclRevision,
                            0xffffffff,
                            pah,
                            pah->AceSize))
                    return(GetLastError());
            }
        }

        // now for the new aces

        for (ULONG j = 0; j < _ccaa; j++)
        {
            if ( (_aaa[j].option != OPTION_DENY) &&
                 (_aaa[j].option != OPTION_REVOKE) &&
                 (_aaa[j].pcaa->AccessMask() != 0) )
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    if (!psid) {
                        return (ERROR_INVALID_DATA);
                    }
                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl,
                                                               _aaa[j].pcaa->AccessMask(),
                                                               psid,
                                                               fdir )))
                        return(ret);
                } else
                    return(ret);
            }

        }

		//
        // loop thru the old ACL, and add all the inherited aces
		//
		pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL));

        for (ULONG cace = 0; cace < poldacl->AceCount;
            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah->AceSize))
        {
			if(pah->AceFlags & INHERITED_ACE)
			{
				// add the old ace to the new ACL if the old ace's mask is not zero

				if ( 0 != (ACCESS_MASK)((ACCESS_ALLOWED_ACE *)pah)->Mask)
				{
					// add the old ace
					if (!AddAce(pnewdacl,
								pnewdacl->AclRevision,
								0xffffffff,
								pah,
								pah->AceSize))
						return(GetLastError());
				}
			}
        }

    } else
    {
        // no old acl, just add the (rest) of the new aces
        for (ULONG j = 0; j < _ccaa; j++)
        {
            if (_aaa[j].option != OPTION_DENY)
            {
                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa->Sid(&psid)))
                {
                    if (!psid) {
                        return (ERROR_INVALID_DATA);
                    }
                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl,
                                                               _aaa[j].pcaa->AccessMask(),
                                                               psid,
                                                               fdir )))
                        return(ret);
                } else
                    return(ret);
            }
        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\dumpsec.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        DumpSec.cxx
//
// Contents:    class to dump file security ACL
//
// Classes:     CDumpSecurity
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <DumpSec.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::CDumpSecurity, public
//
//  Synopsis:   initialized data members, constructor will not throw
//
//  Arguments:  IN [pfilename] - name of file to dump security for
//
//----------------------------------------------------------------------------
CDumpSecurity::CDumpSecurity(WCHAR *pfilename)
    : _psd(NULL),
      _pwfilename(pfilename),
      _pdacl(NULL),
      _pah(NULL),
      _psid(NULL),
      _cacethissid(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced.  Init gets the security descriptor and
//              ACL for the file
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::Init()
{
    ULONG ret;
    ULONG cpsd;

    // get the size of the security buffer

    if (!GetFileSecurity(_pwfilename,
                         DACL_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &cpsd) )
    {
        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
        {
            if ( NULL == ( _psd = (BYTE *)LocalAlloc(LMEM_FIXED, cpsd)))
            {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            }

            // actually get the buffer this time

            if ( GetFileSecurity(_pwfilename,
                                 DACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION,
                                 _psd,
                                 cpsd,
                                 &cpsd) )
            {
                BOOL fdaclpresent;
                BOOL cod;

                // get the ACL

                if ( GetSecurityDescriptorDacl(_psd,
                                           &fdaclpresent,
                                           &_pdacl,
                                           &cod) )

                {
                    if (!fdaclpresent)
                    {
                        _pdacl = NULL;
                        return(ERROR_NO_SECURITY_ON_OBJECT);
                    }
                    // save the ACL location

                    _pah = (ACE_HEADER *)Add2Ptr(_pdacl, sizeof(ACL));
                    return(ERROR_SUCCESS);

                } else
                   return(GetLastError());
            } else
               return(GetLastError());
        }
    } else
        return(ERROR_NO_SECURITY_ON_OBJECT);

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees the security descriptor
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CDumpSecurity::~CDumpSecurity()
{
    if (_psd)
    {
        LocalFree(_psd);
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetSDOwner, public
//
//  Synopsis:   returns the owner of the file
//
//  Arguments:  OUT [psid] - address of the returned sid
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::GetSDOwner(SID **psid)
{
    BOOL cod;
    if ( GetSecurityDescriptorOwner(_psd, (void **)psid, &cod) )
        return(0);
    else
        return(GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetSDGroup, public
//
//  Synopsis:   returns the group from the file
//
//  Arguments:  OUT [pgsid] - address of the returned group sid
//
//----------------------------------------------------------------------------
ULONG CDumpSecurity::GetSDGroup(SID **pgsid)
{
    BOOL cod;
    if ( GetSecurityDescriptorGroup(_psd, (void **)pgsid, &cod) )
        return(0);
    else
        return(GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::ResetAce, public
//
//  Synopsis:   sets the 'ace' index to the start of the DACL
//
//  Arguments:  IN - [psid] - the SID to find aces for
//
//----------------------------------------------------------------------------
VOID CDumpSecurity::ResetAce(SID *psid)
{

    _psid = psid;
    _cacethissid = 0;
    if (_pdacl)
        _pah = (ACE_HEADER *)Add2Ptr(_pdacl, sizeof(ACL));
}
//+---------------------------------------------------------------------------
//
//  Member:     CDumpSecurity::GetNextAce, public
//
//  Synopsis:   gets the next ACE from the DACL for the specified SID
//
//  Arguments:  OUT  [pace] - pointer to the next ace for the SID passed
//                            in at the last reset.
//
//  Returns:    the number of the ACE
//
//----------------------------------------------------------------------------
LONG CDumpSecurity::GetNextAce(ACE_HEADER **paceh)
{
    LONG ret = -1;

    if (_pdacl)
    {
        for (;_cacethissid < _pdacl->AceCount;
            _cacethissid++, _pah = (ACE_HEADER *)Add2Ptr(_pah, _pah->AceSize))
        {
            if (!_psid || EqualSid(_psid,(SID *)&((ACCESS_ALLOWED_ACE *)_pah)->SidStart) )
            {
               *paceh = _pah;
                ret = _cacethissid++;
                _pah = (ACE_HEADER *)Add2Ptr(_pah, _pah->AceSize);
                break;
            }
        }
    }
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\account.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        account.cxx
//
// Contents:    Class wrapping account sid and name
//
// Classes:     CAccount
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <account.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::CAccount, public
//
//  Synopsis:   initializes data members
//
//  Arguments:  IN [Name]   - principal
//              IN [System] - server/domain
//
//----------------------------------------------------------------------------
CAccount::CAccount(WCHAR *Name, WCHAR *System)
    : _name(Name),
      _system(System),
      _domain(NULL),
      _psid(NULL),
      _fsid(TRUE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::CAccount, public
//
//  Synopsis:   Initializes data members
//
//  Arguments:  IN [pSid]   - SID of principal
//              IN [System] - server/domain
//
//----------------------------------------------------------------------------
CAccount::CAccount(SID *pSid, WCHAR *System)
    : _name(NULL),
      _system(System),
      _domain(NULL),
      _psid(pSid),
      _fsid(FALSE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees sid or name and domain
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccount::~CAccount()
{
    if (_fsid)
    {
        if (_psid)
        {
            LocalFree(_psid);
        }
    } else if (_name)
    {
        LocalFree(_name);
    }
    if (_domain)
        LocalFree(_domain);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountName, public
//
//  Synopsis:   returns the Name associated with the instance of the class
//
//  Arguments:  OUT [name] address of the principal name
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountName(WCHAR **name)
{

    ULONG ret = ERROR_SUCCESS;

    if (_name == NULL)
    {
        DWORD can = 0, crd = 0;
        SID_NAME_USE esnu;

        if (!LookupAccountSid( NULL,
                               _psid,
                               NULL,
                               &can,
                               NULL,
                               &crd,
                               &esnu))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
            {
                ret = ERROR_SUCCESS;
                if (NULL == (_name = (WCHAR *)LocalAlloc(LMEM_FIXED, can * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                if (NULL == (_domain = (WCHAR *)LocalAlloc(LMEM_FIXED, crd * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if ( !LookupAccountSid( NULL,
                                       _psid,
                                       _name,
                                       &can,
                                       _domain,
                                       &crd,
                                       &esnu) )
                {
                   ret = GetLastError();
                }
            }
        }
     }
     *name = _name;
     return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountSid, public
//
//  Synopsis:   returns the Sid
//
//  Arguments:  OUT [psid] - sid associated with instance of the class
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountSid(SID **psid)
{

    ULONG ret = ERROR_SUCCESS;

    if (_psid == NULL && _name != NULL)
    {
        DWORD cusid = 0, crd = 0;
        SID_NAME_USE esnu;

        if (!LookupAccountName( _system,
                                _name,
                               NULL,
                               &cusid,
                               NULL,
                               &crd,
                               &esnu))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
            {

                ret = ERROR_SUCCESS;
                if (NULL == (_psid = (SID *)LocalAlloc(LMEM_FIXED, cusid)))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                if (NULL == (_domain = (WCHAR *)LocalAlloc(LMEM_FIXED, crd * sizeof(WCHAR))))
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if ( !LookupAccountName( _system,
                                         _name,
                                         _psid,
                                         &cusid,
                                         _domain,
                                         &crd,
                                         &esnu) )

                {
                   ret = GetLastError();
                }
            }
        }
     }
     *psid = _psid;
     return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccount::GetAccountDomain, public
//
//  Synopsis:   returns the domain for the class
//
//  Arguments:  [domain] - returns the domain associated with the instance of
//                         the class
//
//----------------------------------------------------------------------------
ULONG CAccount::GetAccountDomain(WCHAR **domain)
{
    ULONG ret = ERROR_SUCCESS;

    if (_domain == NULL)
    {
        if (_fsid)
        {
            SID *psid;
            ret = GetAccountSid(&psid);
        } else
        {
            WCHAR *name;
            ret = GetAccountName(&name);
        }
    }
    *domain = _domain;
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\fileenum.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        FileEnum.cxx
//
// Contents:    class encapsulating file enumeration, including a deep option
//
// Classes:     CFileEnumeration
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <t2.hxx>
#include <FileEnum.hxx>
#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::CFileEnumerate, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  IN [fdeep] - TRUE = go into sub-directories
//
//----------------------------------------------------------------------------
CFileEnumerate::CFileEnumerate(BOOL fdeep)
    : _fdeep(fdeep),
      _findeep(FALSE),
      _froot(FALSE),
      _fcannotaccess(FALSE),
      _pcfe(NULL),
      _pwfileposition(NULL),
      _handle(INVALID_HANDLE_VALUE)
{
    ENUMERATE_RETURNS((stderr, "CFileEnumerate ctor\n"))
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   closes handles
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CFileEnumerate::~CFileEnumerate()
{
    if (_handle != INVALID_HANDLE_VALUE)
        FindClose(_handle);
    ENUMERATE_RETURNS((stderr, "CFileEnumerate dtor (%ws)\n", _wpath))
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced. converts a ASCII file/path to a UNICODE
//              file/path, and gets the first file in the enumeration
//
//  Arguments:  IN  [filename]  - the path/file to enumerate
//              OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Init(CHAR *filename, WCHAR **wfilename, BOOL *fdir)
{
    // Initialize the file name

    if (filename && (strlen(filename) < MAX_PATH))
    {
        // make it wchar
        WCHAR winfilename[MAX_PATH];

        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                filename, -1,
                                winfilename, sizeof(winfilename) / sizeof(winfilename[0])) == 0)
            return(ERROR_INVALID_NAME);

        // finish initialization

        return(_ialize(winfilename, wfilename, fdir));
    }
    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME))
    return(ERROR_INVALID_NAME);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Init, public
//
//  Synopsis:   Same as previous, except takes UNICODE file/path as input
//
//  Arguments:  IN  [filename]  - the path/file to enumerate
//              OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Init(WCHAR *filename, WCHAR **wfilename, BOOL *fdir)
{
    // Initialize the file name

    if (filename && (wcslen(filename) < MAX_PATH))
    {
        return(_ialize(filename, wfilename, fdir));
    }
    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME))
    return(ERROR_INVALID_NAME);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_ialize, private
//
//  Synopsis:   finishes initialization and starts search for first file in
//              the enumeration
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_ialize(WCHAR *winfilename, WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "Init start, path =  %ws\n", winfilename))
    ULONG ret = ERROR_SUCCESS;

    ENUMERATE_STAT((stderr, "start path = %ws\n",winfilename))

    // save the location of the filename or wildcards

    ULONG cwcharcount;

    if (!(cwcharcount = GetFullPathName(winfilename,
                                       MAX_PATH,
                                       _wpath,
                                       &_pwfileposition)))
    {
        return(ERROR_INVALID_NAME);
    }

    ENUMERATE_STAT((stderr, "got full path name = %ws, filename = (%ws), total chars = %d\n",_wpath, _pwfileposition, cwcharcount))

    // if the filepart (_pwfileposition) is NULL, then the name must end in a slash.
    // add a *

    if (NULL == _pwfileposition)
    {
       _pwfileposition = (WCHAR *)Add2Ptr(_wpath,wcslen(_wpath)*sizeof(WCHAR));
    }

    // save the filename/wildcards

    wcscpy(_wwildcards, _pwfileposition);

    ENUMERATE_EXTRA((stderr, "wild cards = %ws\n",_wwildcards))

    // if we are at a root (path ends in :\)

    if ( (_wpath[wcslen(_wpath) - 1] == L'\\') &&
         (wcslen(_wpath) > 1) &&
         (_wpath[wcslen(_wpath) - 2] == L':') )
    {
        _wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        _wfd.cFileName[0] = L'\0';
        *wfilename = _wpath;
        *fdir = TRUE;
        _froot = TRUE;
    } else
    {
    // check to see if we can iterate through files
        if ( (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile(_wpath, &_wfd) ) ) )
        {
            ret = GetLastError();
            _fcannotaccess = (ERROR_ACCESS_DENIED == ret);

            ENUMERATE_FAIL((stderr, "find first returned: %ld\n",ret))
        }
        if (ERROR_SUCCESS == ret)
        {
            // reject . & .. filenames (go on to next file )

            if ( (0 == wcscmp(_wfd.cFileName, L".")) ||
                 (0 == wcscmp(_wfd.cFileName, L"..")) )
            {
                ret = _NextLocal(wfilename,fdir);
            } else
            {
                // return the current directory

                if (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    *fdir = TRUE;
                else
                    *fdir = FALSE;

                // add the filename to the path so the whole thing is returned

                wcscpy(_pwfileposition, _wfd.cFileName);

                *wfilename = _wpath;
            }
        }

        ENUMERATE_STAT((stderr, "next filename = %ws\n", *wfilename))
    }

    // if we are going deep and we did not find a file yet:

    if ( _fdeep && ( ( ERROR_NO_MORE_FILES == ret ) ||
                     ( ERROR_FILE_NOT_FOUND == ret ) ) )
    {
        if (_handle != INVALID_HANDLE_VALUE)
        {
            FindClose(_handle);
            _handle = INVALID_HANDLE_VALUE;
        }
        ret = _InitDir(wfilename, fdir);
    }

    ENUMERATE_RETURNS((stderr, "Init returning  =  %ws(%ld)\n\n", *wfilename, ret))
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::Next, public
//
//  Synopsis:   finds the next file in the enumeration
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::Next(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "Next start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_NO_MORE_FILES;

    // if we failed to initialize with an ERROR_ACCESS_DENIED, then exit
    if (_fcannotaccess)
        return(ERROR_NO_MORE_FILES);

    // if we are not in deep

    if (!_findeep)
    {
        if (!_froot)
           ret = _NextLocal(wfilename, fdir);

        // if we ran out of files and we are going deep:

        if ( _fdeep &&
             ( ( ERROR_NO_MORE_FILES == ret ) ||
               ( ERROR_FILE_NOT_FOUND == ret ) || _froot ) )
        {
            if (_handle != INVALID_HANDLE_VALUE)
            {
                FindClose(_handle);
                _handle = INVALID_HANDLE_VALUE;
            }
            ret = _InitDir(wfilename, fdir);
            _froot = FALSE; // (we are past the root now)
        }

    } else
    {
        // if we are already down a directory (and in deep)

        if (_pcfe)
        {
            if (ERROR_SUCCESS != (ret = _pcfe->Next(wfilename, fdir)))
            {
                if (ERROR_ACCESS_DENIED != ret)
                {
                    delete _pcfe;
                    _pcfe = NULL;
                }
            }
        }

        // we need to go to the next directory in the current dir

        if (ERROR_NO_MORE_FILES == ret)
        {
            ret = _NextDir(wfilename, fdir);
        }
    }
    ENUMERATE_RETURNS((stderr, "Next returning  =  %ws(%ld)\n\n", *wfilename, ret))
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_NextLocal, private
//
//  Synopsis:   searchs for the next file in the current directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_NextLocal(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_NextLocal start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // ensure that we have a valid handle for a findnextfile

    if (INVALID_HANDLE_VALUE == _handle)
    {
        ret = ERROR_INVALID_HANDLE;
    } else
    {
        do
        {
            if (!FindNextFile(_handle, &_wfd))
            {
                ret = GetLastError();
                ENUMERATE_FAIL((stderr, "find next returned: %ld\n",ret))
            } else
                ret = ERROR_SUCCESS;
        }
        while ( (ERROR_SUCCESS == ret) &&
                ( (0 == wcscmp(_wfd.cFileName, L".")) ||
                  (0 == wcscmp(_wfd.cFileName, L"..")) ) );


        // if we found a file

        if (ERROR_SUCCESS == ret)
        {
            // return the directory attrib.

            if (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                *fdir = TRUE;
            else
                *fdir = FALSE;

            // add the filename to the path so the whole thing is returned

            wcscpy(_pwfileposition, _wfd.cFileName);

            *wfilename = _wpath;

            ENUMERATE_STAT((stderr, "next filename = %ws\n", *wfilename))
        }
    }
    ENUMERATE_RETURNS((stderr, "_NextLocal returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_InitDir, private
//
//  Synopsis:   (only called if going deep)
//              goes down a directory (and thus causing a new CFileEnumerator
//              to be created, or re-initializies
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_InitDir(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_InitDir start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // check and see if a directory was entered as the filename

    if ( (0 == _wcsicmp(_wwildcards, _wfd.cFileName)) &&
         (_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
    {
        ENUMERATE_EXTRA((stderr, "first file matched directory = %ws\n", _wpath))
        _pwfileposition += wcslen(_wfd.cFileName);
        wcscpy(_pwfileposition, L"\\*.*");
        _pwfileposition++;
        wcscpy(_wwildcards, L"*.*");
        ENUMERATE_EXTRA((stderr, "      path = %ws\n",_wpath))
        ENUMERATE_EXTRA((stderr, "wild cards = %ws\n",_wwildcards))

        WCHAR winfilename[MAX_PATH];
        wcscpy(winfilename, _wpath);

        ret = _ialize(winfilename, wfilename, fdir);
    } else
    {

        // we are in deep

        _findeep = TRUE;

        // search thru all directories

        wcscpy(_pwfileposition, L"*.*");

        if (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile(_wpath, &_wfd) ))
        {
            ret = GetLastError();
            ENUMERATE_FAIL((stderr, "find first (dir) returned: %ld\n",ret))
        } else
        {
            if ( !(_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                 (0 == wcscmp(_wfd.cFileName, L".")) ||
                 (0 == wcscmp(_wfd.cFileName, L"..")) )
            {
                ret = _NextDir(wfilename, fdir);
            } else
            {
                // if we have a sub directory, go down it

                ret = _DownDir(wfilename, fdir);

                // if we found nothing in that first sub directory, go the the next one

                if ( (ERROR_NO_MORE_FILES == ret ) ||
                     (ERROR_FILE_NOT_FOUND == ret ) )
                {
                    ret = _NextDir(wfilename, fdir);
                }
            }
        }
    }
    ENUMERATE_RETURNS((stderr, "_InitDir returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_NextDir, private
//
//  Synopsis:   (only called if going deep)
//              finds the next sub-directory from the current directory,
//              and then goes down into that directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_NextDir(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_NextDir start, path =  %ws\n", _wpath))
    ULONG ret = ERROR_SUCCESS;

    // skip the . & .. & files we cannot access

    if (INVALID_HANDLE_VALUE == _handle)
    {
        ret = ERROR_INVALID_HANDLE;
    } else
    {
        do
        {
            do
            {
                if (!FindNextFile(_handle, &_wfd))
                {
                    ret = GetLastError();
                    ENUMERATE_FAIL((stderr, "find next returned: %ld\n",ret))
                } else
                    ret = ERROR_SUCCESS;
            }
            while ( (ERROR_SUCCESS == ret) &&
                    ( !(_wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                      (0 == wcscmp(_wfd.cFileName, L".")) ||
                      (0 == wcscmp(_wfd.cFileName, L"..")) ) );

            // if we found a directory

            if (ERROR_SUCCESS == ret)
            {
                ret = _DownDir(wfilename, fdir);
            } else
            {
                // out of subdirectories to search, break out of the loop
                break;
            }
        }
        while (( ERROR_NO_MORE_FILES == ret) || (ERROR_FILE_NOT_FOUND == ret));
    }
    ENUMERATE_RETURNS((stderr, "_NextDir returning  =  %ws(%ld)\n", *wfilename, ret))

    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileEnumerate::_DownDir, private
//
//  Synopsis:   (only called if going deep)
//              creates a new CFileEnumerator for a sub-directory
//
//  Arguments:  OUT [wfilename] - first file in the enumeration
//              OUT [fdir]      - TRUE = returned file is a directory
//
//----------------------------------------------------------------------------
ULONG CFileEnumerate::_DownDir(WCHAR **wfilename, BOOL *fdir)
{
    ENUMERATE_RETURNS((stderr, "_DownDir start, path =  %ws\n", _wpath))
    ULONG ret;

    // make a new file enumerator class (this one) We should only go down
    // 8 directories at most.

    _pcfe = new CFileEnumerate(_fdeep);
    if (!_pcfe)
        return ERROR_NOT_ENOUGH_MEMORY;

    // add the wildcards to the end of the directory we are going down

    wcscpy(_pwfileposition, _wfd.cFileName);
    wcscat(_pwfileposition, L"\\");
    wcscat(_pwfileposition, _wwildcards);

    // start it up and see if we find a match

    if (ERROR_SUCCESS != (ret = _pcfe->Init(_wpath, wfilename, fdir)))
    {
        if (ERROR_ACCESS_DENIED != ret)
        {
            delete _pcfe;
            _pcfe = NULL;
        }
    }
    ENUMERATE_RETURNS((stderr, "_DownDir returning  =  %ws(%ld)\n", *wfilename, ret))
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\accacc.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        accacc.cxx
//
// Classes:     CAccountAccess
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <accacc.hxx>
#if DBG
extern ULONG Debug;
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::CAccountAccess, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  IN - [Name]   - principal
//              IN - [System] - server/domain
//
//----------------------------------------------------------------------------
CAccountAccess::CAccountAccess(WCHAR *Name, WCHAR *System)
    : _mask(0),
      _savemask(0),
      _foundinheritance(0),
      _acetype(0xff),
      CAccount(Name, System)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes access mask
//
//  Arguments:  IN [access] - access mask
//
//----------------------------------------------------------------------------
ULONG CAccountAccess::Init(ULONG access)
{
    if (access == 0)
    {
        _savemask = GENERIC_ALL;
        _mask = GENERIC_ALL;
        _acetype = ACCESS_DENIED_ACE_TYPE;
    } else
    {
        _acetype = ACCESS_ALLOWED_ACE_TYPE;
        _savemask = access;
        _mask = access;
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::AddInheritance, public
//
//  Synopsis:   accumulates inheritance of ACEs with matching SIDS
//
//  Arguments:  inheritance flags
//
//--------------------------------------------------------------------
void CAccountAccess::AddInheritance(BYTE Flags)
{
    if (!(Flags & NO_PROPAGATE_INHERIT_ACE))
    {
        if (Flags & INHERIT_ONLY_ACE)
        {
            if (Flags & CONTAINER_INHERIT_ACE)
                _foundinheritance |= CONTAINER_INHERIT_ACE;
            if (Flags & OBJECT_INHERIT_ACE)
                _foundinheritance |= OBJECT_INHERIT_ACE;
        } else
        {
           _foundinheritance |= APPLIES_TO_CONTAINER;
           if (Flags & CONTAINER_INHERIT_ACE)
              _foundinheritance |= CONTAINER_INHERIT_ACE;
           if (Flags & OBJECT_INHERIT_ACE)
              _foundinheritance |= OBJECT_INHERIT_ACE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\filesec.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        filesec.cxx
//
// Classes:     CFileSecurity class encapsulating SECURITY_DESCRIPTOR
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------

#include <filesec.hxx>
//+---------------------------------------------------------------------------
// Function:    Add2Ptr
//
// Synopsis:    Add an unscaled increment to a ptr regardless of type.
//
// Arguments:   [pv]    -- Initial ptr.
//              [cb]    -- Increment
//
// Returns:     Incremented ptr.
//
//----------------------------------------------------------------------------
VOID * Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::CFileSecurity, public
//
//  Synopsis:   initializes data members
//              constructor will not throw
//
//  Arguments:  [filename] - name of file to apply security descriptor to
//
//----------------------------------------------------------------------------
CFileSecurity::CFileSecurity(WCHAR *filename)
    : _psd(NULL),
      _pwfilename(filename)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::Init, public
//
//  Synopsis:   Init must be called before any other methods - this
//              is not enforced.  gets security descriptor from file
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
ULONG CFileSecurity::Init()
{
    ULONG ret;
    ULONG cpsd;

    // get the size of the security buffer

    if (!GetFileSecurity(_pwfilename,
                         DACL_SECURITY_INFORMATION |
                         GROUP_SECURITY_INFORMATION |
                         OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &cpsd) )
    {
        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError()))
        {
            if (NULL == (_psd = (BYTE *)LocalAlloc(LMEM_FIXED, cpsd)))
            {
                 return(ERROR_NOT_ENOUGH_MEMORY);
            }

            // actually get the buffer this time

            if ( GetFileSecurity(_pwfilename,
                                 DACL_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 OWNER_SECURITY_INFORMATION,
                                 _psd,
                                 cpsd,
                                 &cpsd) )
                ret = ERROR_SUCCESS;
            else
                ret = GetLastError();

        }
    } else
        return(ERROR_NO_SECURITY_ON_OBJECT);
    return(ret);
}
//+---------------------------------------------------------------------------
//
//  Member:     Dtor, public
//
//  Synopsis:   frees security descriptor if allocated
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CFileSecurity::~CFileSecurity()
{
    if (_psd)
    {
        LocalFree(_psd);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSecurity::SetFS, public
//
//  Synopsis:   sets or modifies the security descriptor DACL on the specified file
//
//  Arguments:  IN - [fmodify] - TRUE = modify ACL, FALSE = replace ACL
//              IN - [pcdw]    - wrapper around new ACEs
//              IN - [fdir]    - TRUE = directory
//
//  Returns:    status
//
//----------------------------------------------------------------------------
ULONG CFileSecurity::SetFS(BOOL fmodify, CDaclWrap *pcdw, BOOL fdir)
{
   BOOL fdaclpresent;
   BOOL cod;
   ACL *pdacl;
   ULONG ret;

   // get the ACL from the security descriptor

   if ( GetSecurityDescriptorDacl(_psd,
                                  &fdaclpresent,
                                  &pdacl,
                                  &cod) )

   {
       if (fdaclpresent)
       {
           // build the new ACL (from the new ACEs and the old ACL)

           PACL pnewdacl = NULL;

           if (ERROR_SUCCESS == (ret = pcdw->BuildAcl(&pnewdacl,
                                                      fmodify ? pdacl : NULL,
                                                      pdacl ? pdacl->AclRevision : ACL_REVISION,
                                                      fdir)
                                                      ))
           {
               // make a new security descriptor

               SECURITY_DESCRIPTOR newsd;

               InitializeSecurityDescriptor( &newsd, SECURITY_DESCRIPTOR_REVISION );

               SetSecurityDescriptorDacl( &newsd, TRUE, pnewdacl, FALSE );

               //
               // apply it to the file
               //

               if (!SetFileSecurity(_pwfilename,
                                    DACL_SECURITY_INFORMATION,
                                    &newsd))
               {
                   ret = GetLastError();
               }
               LocalFree(pnewdacl);
           }
       }
       else
           return(ERROR_NO_SECURITY_ON_OBJECT);
    } else
    {
        ret = GetLastError();
    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\makefile.inc ===
caclsmsg.rc: msg00001.bin

caclsmsg.h msg00001.bin: caclsmsg.mc
    mc -v -h .\ caclsmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\utest\main.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

//+----------------------------------------------------------------------------
ULONG GetAcl(WCHAR *filename, WCHAR *outfile);
//+----------------------------------------------------------------------------
#define RESULTS(a) if (fdebug & 1)  {printf a;}
#define VERBOSE(a) if (fdebug & 2)  {printf a;}

//+----------------------------------------------------------------------------
VOID Usage()
{
    printf("USAGE veracl <filename> [/d] [name permission[...]]\n");
}
//+----------------------------------------------------------------------------
ULONG fdebug;

VOID _cdecl main(INT argc, char *argv[])
{
    if ( (argc < 2) ||
         ( (argc > 2) && ( (argv[2][0] != '/') && ((argc % 2) != 0) ) ) )
    {
        Usage();
        exit(1);
    } else if ((argc > 2) && (argv[2][0] == '/') )
    {
        if (0 == _stricmp(&argv[2][1],"r") )
        {
            fdebug = 1;
        } else if (0 == _stricmp(&argv[2][1],"d") )
        {
            fdebug = 2;
        } else
        {
            Usage();
            exit(1);
        }
    } else
    {
        fdebug = 0;
    }

    ULONG ret;
    CHAR db[1024];
    FILE *pf;

    WCHAR wch[256];
    WCHAR *pwch;
    CHAR *pch;

    for ( pwch = wch, pch = argv[1]; *pwch = (WCHAR)(*pch);pwch++,pch++);

    if ( ERROR_SUCCESS == (ret = GetAcl(wch, L"DinkWink.cmp")))
    {
        if (NULL != (pf = fopen("DinkWink.cmp","r")))
        {
            CHAR *ptok = NULL;
            for (int k = fdebug ? 3 : 2; k < argc; k+=2)
            {
                if (NULL != fgets(db,1024, pf))
                {
                    VERBOSE(("GetAcl returned: %s[%d]\n",db,k))
                    
                    if (k <= 3)
                    {
                        if ( NULL == ( ptok = strtok(db, " ")))
                        {
                            VERBOSE(("no file name found\n"))
                            ret = ERROR_INVALID_DATA;
                            break;
                        }
                        VERBOSE(("ptok (1st) [%s]\n",ptok))
                    }
                    if (NULL != ( ptok = strtok(k <= 3 ? NULL : db, ":\n")))
                    {
                        // this ugly little mess should strip off the leading spaces
                        for (; *ptok == ' ';ptok++);
                        
                        VERBOSE(("ptok (2nd) [%s]\n",ptok))
                        if (0 == _stricmp(ptok, argv[k]))
                        {
                            if (NULL != (ptok = strtok(NULL, " ")))
                            {
                                VERBOSE(("ptok (3rd) [%s]\n",ptok))
                                if ((argc <= k) || (0 != _stricmp(ptok, argv[k+1])))
                                {
                                    VERBOSE(("mismatch type %s != %s\n",ptok))
                                    ret = ERROR_INVALID_DATA;
                                    break;
                                }
                            } else
                            {
                                VERBOSE(("access type not found in\n"))
                                ret = ERROR_INVALID_DATA;
                                break;
                            }
                        } else
                        {
                            VERBOSE(("mismatch %s != %s\n",ptok, argv[k]))
                            ret = ERROR_INVALID_DATA;
                            break;
                        }
                    } else
                    {
                        VERBOSE((": not found in CACLs output\n"))
                        ret = ERROR_INVALID_DATA;
                        break;
                    }
                } else
                {
                    VERBOSE(("End of CACLs output\n"))
                    ret = ERROR_INVALID_DATA;
                    break;
                }
            }
            if (k != argc)
            {
                VERBOSE(("not all name:permissions found on file\n"))
                for (int j = k; j < argc ;j+=2 )
                    VERBOSE(("    %s:%s\n",argv[j], argv[j+1]))
                ret = ERROR_INVALID_DATA;

            }
            fclose(pf);
        } else
        {
            ret = GetLastError();
            VERBOSE(("fopen failed, %ld\n", ret))
        }
        DeleteFile(L"DinkWink.cmp");
    } else
    {
        VERBOSE(("GetAcl failed, %ld\n", ret))
    }
    if (ret == ERROR_SUCCESS)
    {
        RESULTS(("PASSED\n"))
    }
    else
    {
        RESULTS(("FAILED\n"))
    }
    exit(ret);
}
//+----------------------------------------------------------------------------
ULONG GetAcl(WCHAR *filename, WCHAR *outfile)
{

    ULONG ret = ERROR_SUCCESS;
    WCHAR cmdline[1024];

    wsprintf(cmdline, L"cmd /c CACLS.EXE %ws > %ws",
             filename,
             outfile);

    VERBOSE(("CMD: %ws\n",cmdline))

    STARTUPINFO sui;
    memset(&sui,0,sizeof(STARTUPINFO));
    sui.cb = sizeof(STARTUPINFO);

    PROCESS_INFORMATION pi;

    if (CreateProcess(NULL,
                      cmdline,
                      NULL,
                      NULL,
                      TRUE,
                      NORMAL_PRIORITY_CLASS,
                      NULL,
                      NULL,
                      &sui,
                      &pi))
    {
        ULONG ec;
        CloseHandle(pi.hThread);
        DWORD dw = WaitForSingleObject(pi.hProcess, INFINITE);

        if (!GetExitCodeProcess(pi.hProcess, &ec))
            ret = GetLastError();

        CloseHandle(pi.hProcess);
        if (ret == ERROR_SUCCESS)
            ret = ec;
    } else
        ret = GetLastError();

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cat\cat.cpp ===
/* cat - conCATenate STDIN to STDOUT
 *
 * 24-Apr 1998 hiroyama
 *
 */

#include "precomp.h"
#pragma hdrstop

#include "fnreg.h"

#if !defined(UNICODE)
#error please compile me for UNICODE
#endif

#ifndef _T
#define _T      TEXT
#endif

#define LINENUMBER          0x0001
#define EOL_MARK            0x0002
#define TAB_SPECIAL         0x0004
#define CTRL_SPECIAL        0x0008
#define NO_BUFFERED_OUTPUT  0x0010
#define UNICODE_INPUT       0x0020
#define AUTO_UNICODE_DETECT 0x0040

struct InOutMode {
    BOOLEAN fUnicodeInput;
    BOOLEAN fMbcsOutput;
    BOOLEAN fNeedSwab;
    BOOLEAN fLineBuffer;
};

DWORD options = 0;

#define LARGE_BUFSIZE   (512)

void usage()
{
    static const char str[] =
        "cat [-aenotuvV] [filename ...]\n"
        "-a      same as -u if input begins with BOM\n"
        "-e      add '$' at the end of line\n"
        "-n      add line number\n"
        "-o      suppress buffering for output\n"
        "-t      show tab character as '^I'\n"
        "-u      unicode text processing\n"
        "-v      show control characters as '^' + alphabet, except tab and newline.\n"
        "-V      show version\n"
        "--      declare end of options\n";

    fputs(str, stderr);
    exit(EXIT_FAILURE);
}

template <class T>
inline void ntoa(T* p, int n, int width)
{
    p += width;
    *p-- = '\0';
    for (--width; width >= 0; --width) {
        *p-- = (n % 10) + '0';
        n /= 10;
    }
}

template <class T>
inline void swap(T& a, T& b)
{
    a ^= b ^= a ^= b;
}


/////////////////////////////////////////////////////////
// Complex cat UNICODE helpers
/////////////////////////////////////////////////////////

inline int getcaw(InOutMode mode, FILE* fp)
{
    if (mode.fUnicodeInput) {
        wchar_t c = fgetwc(fp);
        if (c == WEOF)
            return EOF;
        return c;
    }
    return fgetc(fp);
}

inline void ungetaw(InOutMode mode, int c, FILE* fp)
{
    if (mode.fUnicodeInput)
        ungetwc((wchar_t)c, fp);
    else
        ungetc(c, fp);
}

inline void putcharaw(InOutMode mode, int c)
{
    if (mode.fUnicodeInput) {
        // if output is dbcs (i.e. tty output), we need to
        // translate the unicode character
        if (mode.fMbcsOutput) {
            // prevent to print BOM
            if (c != 0xfeff) {
                // translate the output
                char buf[2];
                int n = wctomb(buf, (wchar_t)c);
                putchar(buf[0]);
                if (n == 2) {
                    putchar(buf[1]);
                }
            }
        }
        else {
            putwchar((wchar_t)c);
        }
    }
    else
        putchar(c);
}

inline void swab(int& c)
{
    c = ((c & 0xff00) >> 8) | ((unsigned char)c << 8);
}


/////////////////////////////////////////////////////////
// Complex cat
/////////////////////////////////////////////////////////

void complex_cat(const TCHAR* fname)
{
    FILE* fp;
    static char* large_buf;

    if (fname) {
        if ((fp = _tfopen(fname, _T("rb"))) == NULL) {
            _tperror(fname);
            exit(EXIT_FAILURE);
        }
        large_buf = (char*)alloca(LARGE_BUFSIZE);
        if (setvbuf(fp, large_buf, _IOFBF, LARGE_BUFSIZE))
            perror("setvbuf");
    }
    else {
        // if fname == NULL, take input from stdin.
        fp = stdin;
    }

    static bool tol = true;     // Top Of Line
    static long lineno = 0;
    int c, c2;

    // Initialize In/Out mode
    InOutMode inOutMode = {
        !!(options & UNICODE_INPUT),
        false,
        false,
        // if buffered mode and stdout is tty, flush buffer at each EOL
        !(options & NO_BUFFERED_OUTPUT) && _isatty(_fileno(stdout)),
    };

    // UNICODE initialization
    if (inOutMode.fUnicodeInput) {
        // sample the first word for BOM detection
        c = fgetwc(fp);
init_unicode:
        _setmode(_fileno(fp), _O_BINARY);
        if (_isatty(_fileno(stdout))) {
            // if the output is tty,
            // need to convert UNICODE to MBCS on output
            inOutMode.fMbcsOutput = true;
        }

        // try to process the BOM
        if (c == 0xfeff) {
            putcharaw(inOutMode, c);
        }
        else if (c == 0xfffe) {
            inOutMode.fNeedSwab = true;
            swab(c);
            putcharaw(inOutMode, c);
        }
        else {
            ungetwc((wchar_t)c, fp);
        }
    }
    else if (options & AUTO_UNICODE_DETECT) {
        // sample and examine the first word to see if it's UNICODE BOM
        c = fgetwc(fp);
        if (c == 0xfffe || c == 0xfeff) {
            inOutMode.fUnicodeInput = true;
            goto init_unicode;
        }
        ungetwc((wchar_t)c, fp);
    }

#ifdef MEASURE_PERF
    DWORD start = ::GetTickCount();
#endif

    while ((c = getcaw(inOutMode, fp)) != EOF) {
        if (tol) {
            // process line number
            tol = false;
            if (options & LINENUMBER) {
                if (inOutMode.fUnicodeInput && !inOutMode.fMbcsOutput) {
                    wchar_t buf[5];
                    ntoa(buf, ++lineno, 4);
                    fputws(buf, stdout);
                    fputws(L": ", stdout);
                }
                else {
                    char buf[5];
                    ntoa(buf, ++lineno, 4);
                    fputs(buf, stdout);
                    fputs(": ", stdout);
                }
            }
        }

        if (inOutMode.fNeedSwab)
            swab(c);

        switch (c) {
        case '\r':
            c2 = getcaw(inOutMode, fp);
            if (c2 != '\n') {
                ungetaw(inOutMode, c2, fp);
                goto normal_input;
            }
            // fall through
        case '\n':
            if (options & EOL_MARK) {
                putcharaw(inOutMode, '$');
            }
            if (c != '\n') {
                putcharaw(inOutMode, c);
                c = c2;
            }
            putcharaw(inOutMode, c);
            if (inOutMode.fLineBuffer) {
                // if line buffer mode, flush it
                fflush(stdout);
            }
            tol = true;
            break;

        case '\t':
            if (options & TAB_SPECIAL) {
                fputs("^I", stdout);
            }
            else {
                putcharaw(inOutMode, c);
            }
            break;

        default:
normal_input:
            if (c < 0x20 && (options & CTRL_SPECIAL)) {
                putcharaw(inOutMode, '^');
                c += '@';
            }
            putcharaw(inOutMode, c);
            break;
        }
    }

    if (fname) {
        fclose(fp);
    }

#ifdef MEASURE_PERF
    DWORD end = ::GetTickCount();
    fprintf(stderr, "delta=%u\n", end - start);
#endif
}

void cat(const TCHAR* fname = NULL)
{
    static bool is1st = true;
    if (is1st) {
        is1st = false;
        if (options & NO_BUFFERED_OUTPUT) {
            // non buffered mode
            if (setvbuf(stdout, NULL, _IONBF, 0))
                perror("setvbuf");
        }
        else {
            if (setvbuf(stdout, NULL, _IOFBF, LARGE_BUFSIZE))
                perror("setvbuf");
        }
    }

    complex_cat(fname);
}


void parse_option(const TCHAR* s, bool& eoo)    // eoo: end of options
{
    extern char version[];

    while (*++s) {
        switch (*s) {
        case _T('-'):
            eoo = true;
            return;
        case _T('a'):
            options |= AUTO_UNICODE_DETECT;
            break;
        case _T('e'):
            options |= EOL_MARK;
            break;
        case _T('n'):
            options |= LINENUMBER;
            break;
        case _T('v'):
            options |= CTRL_SPECIAL;
            break;
        case _T('t'):
            options |= TAB_SPECIAL;
            break;
        case _T('o'):
            options |= NO_BUFFERED_OUTPUT;
            break;
        case _T('u'):
            options |= UNICODE_INPUT;
            break;
        case _T('V'):
            fputs(version, stderr);
            exit(EXIT_SUCCESS);
        default:
            usage();    // never returns
        }
    }
}

#ifdef UNICODE
#define main    wmain
#endif

extern "C"
int __cdecl main(int argc, TCHAR** argv)
{
    int n = 0;
    bool eoo = false;

    fnexpand(&argc, &argv);

    setlocale(LC_ALL, "");

#if 1
    // set stdout binary mode
    _setmode(_fileno(stdout), _O_BINARY);

#else   // TEST
    for (int i = 0; i < argc; ++i) {
        _putts(argv[i]);
    }
    exit(0);
#endif

    while (--argc) {
        if (**++argv == _T('-') && !eoo) {
            parse_option(*argv, eoo);
        }
        else {
            ++n;
            eoo = true;
            cat(*argv);
        }
    }

    if (n == 0) {
        _setmode(_fileno(stdin), _O_BINARY);
        cat();
    }

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cacls\t2.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
// File:        t2.cxx
//
// Contents:
//
// Classes:
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <t2.hxx>
#include <filesec.hxx>
#include <fileenum.hxx>
#include <dumpsec.hxx>
#include "caclsmsg.h"
#include <locale.h>
#include <string.h>
#include <winnlsp.h>
#include <tchar.h>
#if DBG
ULONG Debug;
#endif
//+----------------------------------------------------------------------------
//
// local prototypes
//
//+----------------------------------------------------------------------------
BOOLEAN OpenToken(PHANDLE ph);
void printfsid(SID *psid, ULONG *outputoffset);
void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset);
void printfmask(ULONG mask, UCHAR acetype, BOOL fdir, ULONG outputoffset);
WCHAR *mbstowcs(char *aname );
BOOL GetUserAndAccess(TCHAR *arg, WCHAR **user, ULONG *access);
#if DBG
ULONG DebugEnumerate(TCHAR *filename, ULONG option);
#endif
ULONG DisplayAces(TCHAR *filename, ULONG option);
ULONG ModifyAces(TCHAR *filename,
                 MODE emode,
                 ULONG option,
                 TCHAR *argv[],
                 LONG astart[], LONG aend[] );

ULONG GetCmdLineArgs(INT argc, TCHAR *argv[],
                     ULONG *option,
                     LONG astart[], LONG aend[],
                     MODE *emode
#if DBG
                     ,ULONG *debug
#endif
                     );
ULONG
__cdecl
printmessage (FILE* fp, DWORD messageID, ...);



//+----------------------------------------------------------------------------
//
//  Function:   vfcprintf
//
//  Synopsis:   prints formatted text to [pOut].  This function will call the
//              defulat c printf functions if it can not call WriteConsole().
//              We are calling WriteConsole() because it will display extended
//              characters, were as fprintf, printf ..., functions do not display
//              multi linguel strings.
//
//  Arguments: [pOut]         - Must be stdout, stderr, otherwise the function will just
//                              call standard c functions.
//             [pszFormate]   - Format string
//             [argList]      - variable length argument list.
//
//----------------------------------------------------------------------------
void vfcprintf(FILE *pOut, LPCTSTR pszFormat, va_list argList)
{
   HANDLE handle;

   //
   // Get the standard handles for output.  This assumes that the callers is calling with
   // either stdout or stderr, if it's anything else then just use normal sprintf.
   //
   TCHAR szText[2048];
   if(pOut == stdout){
      handle = GetStdHandle(STD_OUTPUT_HANDLE);
   } else if(pOut == stderr ){
      handle = GetStdHandle(STD_ERROR_HANDLE);
   } else {
do_normal:
#if defined(_UNICODE) || defined(UNICODE)
      vswprintf( szText, pszFormat, argList );
      fwprintf(pOut, szText );
#else
      vsprintf( szText, pszFormat, argList );
      fprintf(pOut, szText );
#endif
      return;
   }

   //
   // If we can't get the output handle then just send it to standard fprintf functions
   //
   if(INVALID_HANDLE_VALUE == handle){
      goto do_normal;
   }

   //
   // Format the text using standard C functions.
   //
#if defined(_UNICODE) || defined(UNICODE)
   vswprintf( szText, pszFormat, argList );
#else
   vsprintf( szText, pszFormat, argList );
#endif

   DWORD cRead = 0;
   //
   // If we can't get the console mode from this handle, then it is being piped somewhere else
   // and we must use sprintf to write, because WriteConsole only works with a console
   // output handle.
   //
   if(!GetConsoleMode( handle, &cRead ))
   {
	    DWORD cchBuffer = lstrlen(szText);
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, (cchBuffer+1)*sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            szText,
                                            cchBuffer + 1,
                                            lpAnsiBuffer,
                                            (cchBuffer +1) * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                fprintf(pOut,"%s",lpAnsiBuffer);
            }

            LocalFree(lpAnsiBuffer);
		}

   } else {
      WriteConsole( handle, szText, lstrlen(szText), &cRead, NULL);
   }

}


//+----------------------------------------------------------------------------
//
//  Function:   fcprintf
//
//  synopsis:   Same as fprintf, except this will call vfcprintf, which
//              prints to the console use WriteConsole.
//
//  Arguments: [pOut]         - FILE stream to output to.
//             [pszFormate]   - Format string
//             [...]          - variable length argument list.
//
//----------------------------------------------------------------------------
void
__cdecl
fcprintf( FILE *pOut, LPCTSTR pszFormat, ...)
{
   va_list marker;
   va_start(marker, pszFormat);
   vfcprintf( pOut, pszFormat, marker);
   va_end(marker);
}


//+----------------------------------------------------------------------------
//
//  Function:   fcprintf
//
//  synopsis:   Same as printf, except this will call vfcprintf, which
//              prints to the console use WriteConsole.
//
//  Arguments: [pszFormate]   - Format string
//             [...]          - variable length argument list.
//
//----------------------------------------------------------------------------
void
__cdecl
cprintf( LPCTSTR pszFormat, ...)
{
   va_list marker;
   va_start(marker, pszFormat);
   vfcprintf( stdout, pszFormat, marker);
   va_end(marker);
}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints usage functionality
//
//  Arguments: none
//
//----------------------------------------------------------------------------
VOID usage()
{
    printmessage(stdout, MSG_CACLS_USAGE, NULL);

#if DBG
    if (Debug)
    {
        printf("\n   /B            deBug <[#]>\n");
        printf("                 default is display error returned\n");
        printf("                 in /B '#' is a mask: 1  display SIDS values\n");
        printf("                                      2  display access masks\n");
        printf("                                      4  display error returned\n");
        printf("                                      8  display error location\n");
        printf("                                   0x10  verbose\n");
        printf("                                   0x20  verboser\n");
        printf("                                   0x40  enumerate names\n");
        printf("                                   0x80  enumerate failures\n");
        printf("                                  0x100  enumerate starts and returns\n");
        printf("                                  0x200  enumerate extra data\n");
        printf("                                  0x400  size allocation data\n");
        printf("                                  0x800  display enumeration of files\n");
    }
#endif
}

BOOL
IsAclSupported(LPCWSTR lpszFileName)
{
	BOOL bReturn = TRUE;
	WCHAR szVolumePathName[MAX_PATH+1];
	if(GetVolumePathName(lpszFileName,
						 szVolumePathName,
						 MAX_PATH))
	{
		int nLen = wcslen(szVolumePathName);
		if((WCHAR)szVolumePathName[nLen -1] != L'\\')
		{
			szVolumePathName[nLen] = L'\\';
			szVolumePathName[nLen++] = L'\0';
		}
		DWORD dwFlags = 0;
		if(GetVolumeInformation(szVolumePathName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwFlags,
                                 NULL,
                                 0))
        {
			if(!(FS_PERSISTENT_ACLS & dwFlags))
			{
				printmessage(stdout,MSG_CACLS_NOT_NTFS);
				return FALSE;
			}
        }
		
	}		
	return bReturn;
}
//+----------------------------------------------------------------------------
//
//  Function:     Main, Public
//
//  Synopsis:     main!!
//
//  Arguments:    IN [argc] - cmdline arguement count
//                IN [argv] - input cmdline arguements
//
//----------------------------------------------------------------------------
#if defined( __cplusplus )
extern "C" {
#endif
VOID _cdecl wmain(int argc, wchar_t *argvw[])
{
    char lBuf[6];

    //
    // Set the local to system OEM code page.
    //
    setlocale(LC_ALL, ".OCP" );
	SetThreadUILanguage(0);
	
    //
    // Convert the wide character set to string array.
    //
    LONG astart[MAX_OPTIONS], aend[MAX_OPTIONS];
    MODE emode;

    LONG ret = 0;
    ULONG option;

    if (ERROR_SUCCESS != (ret = GetCmdLineArgs(argc, argvw,
                                               &option,
                                               astart, aend,
                                               &emode
#if DBG
                                               ,&Debug
#endif
                                               )))
    {
        usage();
        exit(ret);
    }

	if(!IsAclSupported(argvw[1]))
		exit(1);
    switch (emode)
    {
        case MODE_DISPLAY:
            ret = DisplayAces(argvw[1], option);
            break;
        case MODE_REPLACE:
        case MODE_MODIFY:
            ret = ModifyAces(argvw[1], emode, option, argvw, astart, aend );
            break;
#if DBG
        case MODE_DEBUG_ENUMERATE:
            ret = DebugEnumerate(argvw[1], option);
            break;
#endif
        default:
        {
            usage();
            exit(1);
        }
    }
    if (ERROR_SUCCESS != ret)
    {
        LAST_ERROR((stderr, "Cacls failed, %ld\n",ret))
        if( ret == ERROR_BAD_ARGUMENTS )
            ret = MSG_CACLS_INVALID_ARGUMENT;
        printmessage(stderr, ret, NULL);

        if( ret == MSG_CACLS_INVALID_ARGUMENT )
            usage();
 }
    exit(ret);
}
#if defined( __cplusplus )
}
#endif

//---------------------------------------------------------------------------
//
//  Function:     GetCmdLineArgs
//
//  Synopsis:     gets and parses command line arguments into commands
//                recognized by this program
//
//  Arguments:    IN  [argc]   - cmdline arguement count
//                IN  [argv]   - input cmdline arguements
//                OUT [option] - requested option
//                OUT [astart] - start of arguments for each option
//                OUT [aend]   - end of arguments for each option
//                OUT [emode]  - mode of operation
//                OUT [debug]  - debug mask
//
//
//----------------------------------------------------------------------------
ULONG GetCmdLineArgs(INT argc, TCHAR *argv[],
                     ULONG *option,
                     LONG astart[], LONG aend[],
                     MODE *emode
#if DBG
                     ,ULONG *debug
#endif
                     )
{
    ARG_MODE_INDEX am = ARG_MODE_INDEX_NEED_OPTION;

#if DBG
    *debug = 0;
#endif
    *emode = MODE_DISPLAY;
    *option = 0;

    for (LONG j=0; j < MAX_OPTIONS ;j++ )
    {
        astart[j] = 0;
        aend[j] = 0;
    }

    if ( (argc < 2) || (argv[1][0] == '/') )
    {
#if DBG
        // do this so debug args are printed out

        if (argc >= 2)
        {
            if ( (0 == lstrcmpi(&argv[1][1], TEXT("deBug"))) ||
                 (0 == lstrcmpi(&argv[1][1], TEXT("b")))  )
            {
                *debug = DEBUG_LAST_ERROR;
            }
        }
#endif
        return(ERROR_BAD_ARGUMENTS);
    }

    for (LONG k = 2; k < argc ; k++ )
    {
        if (argv[k][0] == '/')
        {
            switch (am)
            {
                case ARG_MODE_INDEX_NEED_OPTION:
#if DBG
                case ARG_MODE_INDEX_DEBUG:
#endif
                    break;

                case ARG_MODE_INDEX_DENY:
                case ARG_MODE_INDEX_REVOKE:
                case ARG_MODE_INDEX_GRANT:
                case ARG_MODE_INDEX_REPLACE:
                    if (astart[am] == k)
                        return(ERROR_BAD_ARGUMENTS);
                    break;

                default:
                    return(ERROR_BAD_ARGUMENTS);
            }

            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Tree"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("t"))) )
            {
                if (*option & OPTION_TREE)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_TREE;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Continue"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("c"))) )
            {
                if (*option & OPTION_CONTINUE_ON_ERROR)
                    return(ERROR_BAD_ARGUMENTS);
                *option |= OPTION_CONTINUE_ON_ERROR;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Edit"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("E"))) )
            {
                if (*emode != MODE_DISPLAY)
                    return(ERROR_BAD_ARGUMENTS);
                *emode = MODE_MODIFY;
                am = ARG_MODE_INDEX_NEED_OPTION;
                continue;
            }

#if DBG
            if ( (0 == lstrcmpi(&argv[k][1], TEXT("deBug"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("b")))  )
            {
                if (*debug)
                    return(ERROR_BAD_ARGUMENTS);
                am = ARG_MODE_INDEX_DEBUG;
                *debug = DEBUG_LAST_ERROR;
                continue;
            }
#endif
            if ( (0 == lstrcmpi(&argv[k][1], TEXT("Deny"))) ||
                 (0 == lstrcmpi(&argv[k][1], TEXT("D"))) )
            {
                am = ARG_MODE_INDEX_DENY;
                *option |= OPTION_DENY;
            } else if ( (0 == lstrcmpi(&argv[k][1], TEXT("Revoke"))) ||
                        (0 == lstrcmpi(&argv[k][1], TEXT("R"))) )
            {
                am = ARG_MODE_INDEX_REVOKE;
                *option |= OPTION_REVOKE;
            } else if ( (0 == lstrcmpi(&argv[k][1], TEXT("Grant"))) ||
                        (0 == lstrcmpi(&argv[k][1], TEXT("G"))) )
            {
                am = ARG_MODE_INDEX_GRANT;
                *option |= OPTION_GRANT;
            } else if ( (0 == lstrcmpi(&argv[k][1], TEXT("rePlace"))) ||
                        (0 == lstrcmpi(&argv[k][1], TEXT("P"))) )
            {
                *option |= OPTION_REPLACE;
                am = ARG_MODE_INDEX_REPLACE;
            } else
                return(ERROR_BAD_ARGUMENTS);

            if (astart[am] != 0)
                return(ERROR_BAD_ARGUMENTS);
            astart[am] = k+1;
        } else
        {
            switch (am)
            {
                case ARG_MODE_INDEX_NEED_OPTION:
                    return(ERROR_BAD_ARGUMENTS);

#if DBG
                case ARG_MODE_INDEX_DEBUG:
                    *debug = _wtol(argv[k]);
                    if (*debug & DEBUG_ENUMERATE)
                        if (*emode == MODE_DISPLAY)
                            *emode = MODE_DEBUG_ENUMERATE;
                        else
                            return(ERROR_BAD_ARGUMENTS);

                    am = ARG_MODE_INDEX_NEED_OPTION;
                    break;
#endif
                case ARG_MODE_INDEX_DENY:
                case ARG_MODE_INDEX_REVOKE:
                case ARG_MODE_INDEX_GRANT:
                case ARG_MODE_INDEX_REPLACE:
                    aend[am] = k+1;
                    break;

                default:
                    return(ERROR_BAD_ARGUMENTS);
            }
        }
    }

    if ( ( (*option & OPTION_DENY) && (aend[ARG_MODE_INDEX_DENY] == 0) ) ||
         ( (*option & OPTION_REVOKE) && (aend[ARG_MODE_INDEX_REVOKE] == 0) ) ||
         ( (*option & OPTION_GRANT) && (aend[ARG_MODE_INDEX_GRANT] == 0) ) ||
         ( (*option & OPTION_REPLACE) && (aend[ARG_MODE_INDEX_REPLACE] == 0) ) )
    {
        return(ERROR_BAD_ARGUMENTS);
    } else if ( (*option & OPTION_DENY) ||
                (*option & OPTION_REVOKE) ||
                (*option & OPTION_GRANT) ||
                (*option & OPTION_REPLACE) )
    {
        if (*emode == MODE_DISPLAY)
        {
            if (*option & OPTION_REVOKE)
            {
                return(ERROR_BAD_ARGUMENTS);
            }
            *emode = MODE_REPLACE;
        }
    }
    return(ERROR_SUCCESS);
}

//---------------------------------------------------------------------------
//
//  Function:     DisplayAces
//
//  Synopsis:     displays ACL from specified file
//
//  Arguments:    IN [filename] - file name
//                IN [option]   - display option
//
//----------------------------------------------------------------------------
ULONG DisplayAces(TCHAR *filename, ULONG option)
{
    CFileEnumerate cfe(option & OPTION_TREE);
    WCHAR *pwfilename;
    BOOL fdir;
    ULONG ret;

    if (NO_ERROR == (ret = cfe.Init(filename, &pwfilename, &fdir)))
    {
        while ( (NO_ERROR == ret) ||
                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&&
                  (option & OPTION_CONTINUE_ON_ERROR) ) )
        {
#if DBG
            if (fdir)
                DISPLAY((stderr, "processing file: "))
            else
                DISPLAY((stderr, "processing dir: "))
#endif
            cprintf( TEXT("%s"), pwfilename);
            if (ERROR_ACCESS_DENIED == ret)
            {
                printmessage(stdout,MSG_CACLS_ACCESS_DENIED, NULL);
            } else if (ERROR_SHARING_VIOLATION == ret)
            {
                printmessage(stdout,MSG_CACLS_SHARING_VIOLATION, NULL);
            } else
            {
                DISPLAY((stderr, "\n"))
                VERBOSE((stderr, "\n"))
                CDumpSecurity cds(pwfilename);

                if (NO_ERROR == (ret = cds.Init()))
                {
#if DBG
                    if (Debug & DEBUG_VERBOSE)
                    {
                        SID *psid;
                        ULONG oo;

                        if (NO_ERROR == (ret = cds.GetSDOwner(&psid)))
                        {
                            printf("  Owner = ");
                            printfsid(psid, &oo);
                            if (NO_ERROR == (ret = cds.GetSDGroup(&psid)))
                            {
                                printf("  Group = ");
                                printfsid(psid, &oo);
                            }
                            else
                                ERRORS((stderr, "GetSDGroup failed, %d\n",ret))
                        }
                        else
                            ERRORS((stderr, "GetSDOwner failed, %d\n",ret))
                    }
#endif
                    ACE_HEADER *paceh;

                    LONG retace;
                    if (NO_ERROR == ret)
                        for (retace = cds.GetNextAce(&paceh); retace >= 0; )
                        {
                            printface(paceh, fdir, wcslen(pwfilename));
                            retace = cds.GetNextAce(&paceh);
                            if (retace >= 0)
                                printf("%*s",
                                       WideCharToMultiByte(CP_ACP, 0,
                                               pwfilename, -1,
                                               NULL, 0,
                                               NULL, NULL)-1," ");
                        }
                }
#if DBG
                   else
                    ERRORS((stderr, "cds.init failed, %d\n",ret))
#endif
            }
            fprintf(stdout, "\n");

            if ( (NO_ERROR == ret) ||
                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&&
                   (option & OPTION_CONTINUE_ON_ERROR) ) )
                ret = cfe.Next(&pwfilename, &fdir);
        }

        switch (ret)
        {
            case ERROR_NO_MORE_FILES:
                ret = ERROR_SUCCESS;
                break;
            case ERROR_ACCESS_DENIED:
            case ERROR_SHARING_VIOLATION:
                break;
            case ERROR_SUCCESS:
                break;
            default:
                break;
        }

    } else
    {
        ERRORS((stderr, "cfe.init failed, %d\n",ret))
    }
    return(ret);
}
//---------------------------------------------------------------------------
//
//  Function:     ModifyAces
//
//  Synopsis:     modifies the aces for the specified file(s)
//
//  Arguments:    IN [filename] - name of file(s) to modify the aces on
//                IN [emode]  - mode of operation
//                IN [option] - requested option
//                IN [astart] - start of arguments for each option
//                IN [aend]   - end of arguments for each option
//
//----------------------------------------------------------------------------
ULONG ModifyAces(TCHAR *filename,
                 MODE emode,
                 ULONG option,
                 TCHAR *argv[],
                 LONG astart[], LONG aend[])
{
    CDaclWrap cdw;
    CFileEnumerate cfe(option & OPTION_TREE);
    WCHAR *user = NULL;
    ULONG access;
    ULONG ret = ERROR_SUCCESS;
    WCHAR *pwfilename;
    ULONG curoption;

    VERBOSERW((stderr, TEXT("user:permission pairs\n") ))

    // first proces the command line args to build up the new ace

    for (ULONG j = 0, k = 1;j < MAX_OPTIONS ; k <<= 1, j++ )
    {
        curoption = k;
        if (option & k)
        {
            for (LONG q = astart[j];
                      q < aend[j] ; q++ )
            {
                VERBOSERW((stderr, TEXT("      %s\n"),argv[q] ))

                if ((k & OPTION_GRANT) || (k & OPTION_REPLACE))
                {
                    if (!GetUserAndAccess(argv[q], &user, &access))
                    {
#if !defined(UNICODE) || !defined(_UNICODE)
                        if (user)
                            LocalFree(user);
#endif
                        return(ERROR_BAD_ARGUMENTS);
                    }
                    if (GENERIC_NONE == access)
                    {
                        if (!(k & OPTION_REPLACE))
                        {
#if !defined(UNICODE) || !defined(_UNICODE)
                            if (user)
                                LocalFree(user);
#endif
                            return(ERROR_BAD_ARGUMENTS);
                        }
                    }
                } else
                {
#if !defined(UNICODE) || !defined(_UNICODE)
                    user = mbstowcs(argv[q]);
#else
                    user = argv[q];
#endif
                    access = GENERIC_NONE;
                }

                VERBOSERW((stderr, TEXT("OPTION = %d, USER = %ws, ACCESS = %lx\n"),
                       option,
                       user,
                       access))


                if (ERROR_SUCCESS != (ret = cdw.SetAccess(curoption,
                                                     user,
                                                     NULL,
                                                     access)))
                {
                    ERRORS((stderr, "SetAccess for %ws:%lx failed, %d\n",
                           user,
                           access,
                           ret))
#if !defined(UNICODE) || !defined(_UNICODE)
                    LocalFree(user);
#endif
                    return(ret);
                }
#if !defined(UNICODE) || !defined(_UNICODE)
                LocalFree(user);
#endif
                user = NULL;
            }
        }
    }

    BOOL fdir;

    if (emode == MODE_REPLACE)
    {
        CHAR well[MAX_PATH];
        CHAR msgbuf[MAX_PATH];
        printmessage(stdout,MSG_CACLS_ARE_YOU_SURE, NULL);
        FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_Y, 0,
                      msgbuf, MAX_PATH, NULL);
        fgets(well,MAX_PATH,stdin);

        // remove the trailing return
        if ('\n' == well[strlen(well) - sizeof(CHAR)])
            well[strlen(well) - sizeof(CHAR)] = '\0';

        if (0 != _stricmp(well, msgbuf))
        {
            FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_YES, 0,
                          msgbuf, MAX_PATH, NULL);
            if (0 != _stricmp(well, msgbuf))
                return(ERROR_SUCCESS);
        }
    }

    if (NO_ERROR == (ret = cfe.Init(filename, &pwfilename, &fdir)))
    {
        while ( (NO_ERROR == ret) ||
                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&&
                  (option & OPTION_CONTINUE_ON_ERROR) ) )
        {
            CFileSecurity cfs(pwfilename);

            if (NO_ERROR == (ret = cfs.Init()))
            {
                if (NO_ERROR != (ret = cfs.SetFS(emode == MODE_REPLACE ? FALSE : TRUE, &cdw, fdir)))
                {
                    if (!(((ERROR_ACCESS_DENIED == ret) || (ERROR_SHARING_VIOLATION == ret)) &&
                          (option & OPTION_CONTINUE_ON_ERROR)))
                    {
                        ERRORS((stderr, "SetFS on %ws failed %ld\n",pwfilename, ret))
                        return(ret);
                    }
                }
            }
            else
            {
               //
               // If the error is access denied or sharing violation and we are to continue on error,
               // then keep going. Otherwise bail out here.
               //

               if (!(((ERROR_ACCESS_DENIED == ret) || (ERROR_SHARING_VIOLATION == ret)) &&
                   (option & OPTION_CONTINUE_ON_ERROR))) {

                  ERRORS((stderr, "init failed, %d\n",ret))
                  return(ret);
               }
            }

            if (NO_ERROR == ret)
            {

                if (fdir)
                {
                    printmessage(stdout, MSG_CACLS_PROCESSED_DIR, NULL);
                    cprintf(L"%s\n",  pwfilename);
                }
                else
                {
                    printmessage(stdout, MSG_CACLS_PROCESSED_FILE, NULL);
                    cprintf(L"%s\n",  pwfilename);
                }
            }
            else if (ERROR_ACCESS_DENIED == ret)
            {
                printmessage(stdout, MSG_CACLS_ACCESS_DENIED, NULL);
                cprintf(L"%s\n",  pwfilename);
            }
            else if (ret == ERROR_SHARING_VIOLATION)
            {
                printmessage(stdout, MSG_CACLS_SHARING_VIOLATION, NULL);
                cprintf(L"%s\n",  pwfilename);
            }

            if ( (NO_ERROR == ret) ||
                 ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) ) &&
                   (option & OPTION_CONTINUE_ON_ERROR) ) )
                ret = cfe.Next(&pwfilename, &fdir);
        }

        switch (ret)
        {
            case ERROR_NO_MORE_FILES:
                ret = ERROR_SUCCESS;
                break;
            case ERROR_ACCESS_DENIED:
            case ERROR_SHARING_VIOLATION:
                break;
            case ERROR_SUCCESS:
                break;
            default:
                DISPLAY((stderr, "%ws failed: %d\n", pwfilename, ret))
                break;
        }
    } else
        ERRORS((stderr, "file enumeration failed to initialize %ws, %ld\n",pwfilename, ret))

    if (ret == ERROR_NO_MORE_FILES)
    {
        ret = ERROR_SUCCESS;
    }

    if (ret != ERROR_SUCCESS)
    {
        ERRORS((stderr, "Enumeration failed, %d\n",ret))
    }

    return(ret);
}
#if DBG
//---------------------------------------------------------------------------
//
//  Function:     DebugEnumerate
//
//  Synopsis:     debug function
//
//  Arguments:    IN [filename] - file name
//                IN [option]   - option
//
//----------------------------------------------------------------------------
ULONG DebugEnumerate(TCHAR *filename, ULONG option)
{
    CFileEnumerate cfe(option & OPTION_TREE);
    WCHAR *pwfilename;
    BOOL fdir;
    ULONG ret;

    ret = cfe.Init(filename, &pwfilename, &fdir);
    while ( (ERROR_SUCCESS == ret) ||
            ( (ERROR_ACCESS_DENIED == ret ) &&
              (option & OPTION_CONTINUE_ON_ERROR) ) )
    {
        if (fdir)
            printf("dir  name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        else
            printf("file name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        ret = cfe.Next(&pwfilename, &fdir);
    }
    if (ret == ERROR_ACCESS_DENIED)
    {
        if (fdir)
            printf("dir  name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
        else
            printf("file name = %ws%ws\n",pwfilename,
                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L"");
    }
    if (ret != ERROR_NO_MORE_FILES)
        printf("Enumeration failed, %d\n",ret);

    return(ret);
}
#endif
//---------------------------------------------------------------------------
//
//  Function:     GetUserAccess
//
//  Synopsis:     parses an input string for user:access
//
//  Arguments:    IN  [arg]    - input string to parse
//                OUT [user]   - user if found
//                OUT [access] - access if found
//
//----------------------------------------------------------------------------
BOOL GetUserAndAccess(TCHAR *arg, WCHAR **user, ULONG *access)
{
    TCHAR *saccess = wcschr(arg,':');
    if (saccess)
    {
        *saccess = NULL;
        saccess++;

        if (wcschr(saccess,':'))
            return(FALSE);
#if defined(UNICODE) || defined(_UNICODE)
        *user = arg;
#else
        *user = mbstowcs(arg);
#endif

        if (0 == lstrcmpi(saccess, TEXT("F") ))
        {
            *access = ( STANDARD_RIGHTS_ALL |
                        FILE_READ_DATA |
                        FILE_WRITE_DATA |
                        FILE_APPEND_DATA |
                        FILE_READ_EA |
                        FILE_WRITE_EA |
                        FILE_EXECUTE |
                        FILE_DELETE_CHILD |
                        FILE_READ_ATTRIBUTES |
                        FILE_WRITE_ATTRIBUTES );
        }
        else if (0 == lstrcmpi(saccess,TEXT("R") ))
        {
            *access = FILE_GENERIC_READ | FILE_EXECUTE;
        }
        else if (0 == lstrcmpi(saccess, TEXT("C") ))
        {
            *access = FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE;
        }
        else if (0 == lstrcmpi(saccess, TEXT("N") ))
        {
            *access = GENERIC_NONE;
        }
        else if (0 == lstrcmpi(saccess, TEXT("W") ))
        {
            *access = FILE_GENERIC_WRITE | FILE_EXECUTE;
        }
        else
            return(FALSE);
        return(TRUE);
    }
    return(FALSE);
}
//---------------------------------------------------------------------------
//
//  Function:     mbstowcs
//
//  Synopsis:     converts char to wchar, allocates space for wchar
//
//  Arguments:    IN [aname] - char string
//
//----------------------------------------------------------------------------
WCHAR *mbstowcs(char *aname )
{
    if (aname)
    {
        WCHAR *pwname = NULL;
        pwname = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (strlen(aname)+1));
        if (NULL == pwname)
            return(NULL);
        WCHAR *prwname = pwname;
        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                aname, -1,
                                prwname, sizeof(WCHAR)*(strlen(aname)+1)) == 0)
            return(NULL);
        return(pwname);
    } else
        return(NULL);
}
//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//----------------------------------------------------------------------------
BOOLEAN OpenToken(PHANDLE ph)
{
    HANDLE hprocess;

    hprocess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    if (hprocess == NULL)
        return(FALSE);

    if (OpenProcessToken(hprocess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ph))
    {
        CloseHandle(hprocess);
        return(TRUE);
    }

    CloseHandle(hprocess);
    return(FALSE);
}
//----------------------------------------------------------------------------
//
//  Function:     printfsid
//
//  Synopsis:     prints a NT SID
//
//  Arguments:    IN [psid] - pointer to the sid to print
//
//----------------------------------------------------------------------------
void printfsid(SID *psid, ULONG *outputoffset)
{
#if DBG
    if ((Debug & DEBUG_VERBOSE) || (Debug & DEBUG_DISPLAY_SIDS))
    {
        printf("S-%lx",psid->Revision);

        if ( (psid->IdentifierAuthority.Value[0] != 0) ||
             (psid->IdentifierAuthority.Value[1] != 0) )
        {
            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                        (USHORT)psid->IdentifierAuthority.Value[0],
                        (USHORT)psid->IdentifierAuthority.Value[1],
                        (USHORT)psid->IdentifierAuthority.Value[2],
                        (USHORT)psid->IdentifierAuthority.Value[3],
                        (USHORT)psid->IdentifierAuthority.Value[4],
                        (USHORT)psid->IdentifierAuthority.Value[5] );
        } else
        {
            printf("-%lu",
                   (ULONG)psid->IdentifierAuthority.Value[5]          +
                   (ULONG)(psid->IdentifierAuthority.Value[4] <<  8)  +
                   (ULONG)(psid->IdentifierAuthority.Value[3] << 16)  +
                   (ULONG)(psid->IdentifierAuthority.Value[2] << 24) );
        }

        if ( 0 < psid->SubAuthorityCount )
        {
            for (int k = 0; k < psid->SubAuthorityCount; k++ )
            {
                printf("-%d",psid->SubAuthority[k]);
            }
        }
    }
#endif
    ULONG ret;

    CAccount ca(psid, NULL);

    WCHAR *domain = NULL;
    WCHAR *user;

    if (NO_ERROR == ( ret = ca.GetAccountDomain(&domain) ) )
    {
        if ( (NULL == domain) || (0 == wcslen(domain)) )
        {
            fprintf(stdout, " ");
            *outputoffset +=1;
        }
        else
        {
            fprintf(stdout, " ");
            wprintf(L"%s",  domain);
			fprintf(stdout, "\\");
            *outputoffset += 2 + wcslen( domain );;
        }

        if (NO_ERROR == ( ret = ca.GetAccountName(&user) ) )
        {
            wprintf(L"%s",  user);
			fprintf(stdout, ":");
            *outputoffset += 1 + wcslen(user);
        } else
        {
            *outputoffset += printmessage(stdout, MSG_CACLS_NAME_NOT_FOUND, NULL);

            ERRORS((stderr, "(%lx)",ret))
        }
    } else
    {
        *outputoffset+= printmessage(stdout, MSG_CACLS_DOMAIN_NOT_FOUND, NULL);
        ERRORS((stderr, "(%lx)",ret))
    }
    VERBOSE((stderr, "\n"))
}
//----------------------------------------------------------------------------
//
//  Function:     printface
//
//  Synopsis:     prints the specifed ace
//
//  Arguments:    IN [paceh] - input ace (header)
//                IN [fdir]  - TRUE = directory (different display options)
//
//----------------------------------------------------------------------------
void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset)
{
    VERBOSE((stderr, "  "))
    VERBOSER((stderr, "\npaceh->AceType  = %x\n",paceh->AceType  ))
    VERBOSER((stderr, "paceh->AceFlags = %x\n",paceh->AceFlags ))
    VERBOSER((stderr, "paceh->AceSize  = %x\n",paceh->AceSize  ))
    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)paceh;
    printfsid((SID *)&(paaa->SidStart),&outputoffset);
    if (paceh->AceFlags & OBJECT_INHERIT_ACE      )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_OBJECT_INHERIT, NULL);
    }
    if (paceh->AceFlags & CONTAINER_INHERIT_ACE   )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_CONTAINER_INHERIT, NULL);
    }
    if (paceh->AceFlags & NO_PROPAGATE_INHERIT_ACE)
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_NO_PROPAGATE_INHERIT, NULL);
    }
    if (paceh->AceFlags & INHERIT_ONLY_ACE        )
    {
        outputoffset+= printmessage(stdout, MSG_CACLS_INHERIT_ONLY, NULL);
    }

    if (paceh->AceType == ACCESS_DENIED_ACE_TYPE)
    {
            DISPLAY_MASK((stderr, "(DENIED)"))
            VERBOSE((stderr, "(DENIED)"))
    }

    printfmask(paaa->Mask, paceh->AceType, fdir, outputoffset);
    fprintf(stdout, "\n");
}
//----------------------------------------------------------------------------
//
//  Function:     printfmask
//
//  Synopsis:     prints the access mask
//
//  Arguments:    IN [mask]    - the access mask
//                IN [acetype] -  allowed/denied
//                IN [fdir]    - TRUE = directory
//
//----------------------------------------------------------------------------
CHAR  *aRightsStr[] = { "STANDARD_RIGHTS_ALL",
                        "DELETE",
                        "READ_CONTROL",
                        "WRITE_DAC",
                        "WRITE_OWNER",
                        "SYNCHRONIZE",
                        "STANDARD_RIGHTS_REQUIRED",
                        "SPECIFIC_RIGHTS_ALL",
                        "ACCESS_SYSTEM_SECURITY",
                        "MAXIMUM_ALLOWED",
                        "GENERIC_READ",
                        "GENERIC_WRITE",
                        "GENERIC_EXECUTE",
                        "GENERIC_ALL",
                        "FILE_GENERIC_READ",
                        "FILE_GENERIC_WRITE",
                        "FILE_GENERIC_EXECUTE",
                        "FILE_READ_DATA",
                        //FILE_LIST_DIRECTORY
                        "FILE_WRITE_DATA",
                        //FILE_ADD_FILE
                        "FILE_APPEND_DATA",
                        //FILE_ADD_SUBDIRECTORY
                        "FILE_READ_EA",
                        "FILE_WRITE_EA",
                        "FILE_EXECUTE",
                        //FILE_TRAVERSE
                        "FILE_DELETE_CHILD",
                        "FILE_READ_ATTRIBUTES",
                        "FILE_WRITE_ATTRIBUTES" };

#define NUMRIGHTS 26
ULONG aRights[NUMRIGHTS] = { STANDARD_RIGHTS_ALL  ,
                         DELETE                   ,
                         READ_CONTROL             ,
                         WRITE_DAC                ,
                         WRITE_OWNER              ,
                         SYNCHRONIZE              ,
                         STANDARD_RIGHTS_REQUIRED ,
                         SPECIFIC_RIGHTS_ALL      ,
                         ACCESS_SYSTEM_SECURITY   ,
                         MAXIMUM_ALLOWED          ,
                         GENERIC_READ             ,
                         GENERIC_WRITE            ,
                         GENERIC_EXECUTE          ,
                         GENERIC_ALL              ,
                         FILE_GENERIC_READ        ,
                         FILE_GENERIC_WRITE       ,
                         FILE_GENERIC_EXECUTE     ,
                         FILE_READ_DATA           ,
                         //FILE_LIST_DIRECTORY    ,
                         FILE_WRITE_DATA          ,
                         //FILE_ADD_FILE          ,
                         FILE_APPEND_DATA         ,
                         //FILE_ADD_SUBDIRECTORY  ,
                         FILE_READ_EA             ,
                         FILE_WRITE_EA            ,
                         FILE_EXECUTE             ,
                         //FILE_TRAVERSE          ,
                         FILE_DELETE_CHILD        ,
                         FILE_READ_ATTRIBUTES     ,
                         FILE_WRITE_ATTRIBUTES  };

void printfmask(ULONG mask, UCHAR acetype, BOOL fdir, ULONG outputoffset)
{
    ULONG savmask = mask;
    VERBOSER((stderr, "mask = %08lx ", mask))
    DISPLAY_MASK((stderr, "mask = %08lx\n", mask))

    VERBOSE((stderr, "    "))

#if DBG
    if (!(Debug & (DEBUG_VERBOSE | DEBUG_DISPLAY_MASK)))
    {
#endif
        if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (FILE_GENERIC_READ | FILE_EXECUTE)))
        {
            printmessage(stdout, MSG_CACLS_READ, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE)))
        {
            printmessage(stdout, MSG_CACLS_CHANGE, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask == (GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE | DELETE)))
        {
            printmessage(stdout, MSG_CACLS_CHANGE, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask ==  ( STANDARD_RIGHTS_ALL |
                             FILE_READ_DATA |
                             FILE_WRITE_DATA |
                             FILE_APPEND_DATA |
                             FILE_READ_EA |
                             FILE_WRITE_EA |
                             FILE_EXECUTE |
                             FILE_DELETE_CHILD |
                             FILE_READ_ATTRIBUTES |
                             FILE_WRITE_ATTRIBUTES )) )
        {
            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL);
        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &&
                   (mask ==  GENERIC_ALL))
        {
            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL);
        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &&
                   (mask == GENERIC_ALL))
        {
            printmessage(stdout, MSG_CACLS_NONE, NULL);
        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &&
                   (mask ==  ( STANDARD_RIGHTS_ALL |
                             FILE_READ_DATA |
                             FILE_WRITE_DATA |
                             FILE_APPEND_DATA |
                             FILE_READ_EA |
                             FILE_WRITE_EA |
                             FILE_EXECUTE |
                             FILE_DELETE_CHILD |
                             FILE_READ_ATTRIBUTES |
                             FILE_WRITE_ATTRIBUTES )) )
        {
            printmessage(stdout, MSG_CACLS_NONE, NULL);
        } else
        {
            if (acetype == ACCESS_DENIED_ACE_TYPE)
                printmessage(stdout, MSG_CACLS_DENY, NULL);

            printmessage(stdout, MSG_CACLS_SPECIAL_ACCESS, NULL);

            for (int k = 0; k<NUMRIGHTS ; k++ )
            {
                if ((mask & aRights[k]) == aRights[k])
                {
                    fprintf(stdout, "%*s%s\n",outputoffset, " ", aRightsStr[k]);
                }
                if (mask == 0)
                    break;
            }
        }
#if DBG
    } else
    {
        if (Debug & (DEBUG_DISPLAY_MASK | DEBUG_VERBOSE))
        {
            printf("\n");
            for (int k = 0; k<NUMRIGHTS ; k++ )
            {
                if ((mask & aRights[k]) == aRights[k])
                {
                    if (mask != savmask) printf(" |\n");
                    printf("    %s",aRightsStr[k]);
                    mask &= ~aRights[k];
                }
                if (mask == 0)
                break;
            }
        }
        VERBOSE((stderr, "=%x",mask))
        if (mask != 0)
            DISPLAY((stderr, "=%x/%x",mask,savmask))
    }
#endif
    fprintf(stdout, " ");
}
//----------------------------------------------------------------------------
//
//  Function:     printmessage
//
//  Synopsis:     prints a message, either from the local message file, or from the system
//
//  Arguments:    IN [fp]    - stderr, stdio, etc.
//                IN [messageID] - variable argument list
//
//  Returns:      length of the output buffer
//
//----------------------------------------------------------------------------
ULONG
__cdecl
printmessage (FILE* fp, DWORD messageID, ...)
{
    WCHAR  messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                      messagebuffer, 4095, &ap))
       FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, 0,
                        messagebuffer, 4095, &ap);

    CHAR achOem[2048];
    WideCharToMultiByte(CP_OEMCP,
                        0,
                        messagebuffer,
                        -1,
                        achOem,
                        sizeof(achOem),
                        NULL,
                        NULL);

    fprintf(fp,  achOem);
    va_end(ap);

    return(wcslen(messagebuffer));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cat\fnreg.h ===
// fnreg.h
//
// filename regular expression routine for WIN32
//
// Copyright (C) 1994-1998 by Hirofumi Yamamoto. All rights reserved.
//
// Redistribution and use in source and binary forms are permitted
// provided that
// the above copyright notice and this paragraph are duplicated in all such
// forms and that any documentation, advertising materials, and other
// materials related to such distribution and use acknowledge that the
// software was developed by Hirofumi Yamamoto may not be used to endorse or
// promote products derived from this software without specific prior written
// permission. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
// OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//


//////////////////////////////////////////////////////////////////////////
// BOOL fnexpand(int* argc, TCHAR*** argv);
//
// fnexpand takes &argc and &argv to expand wild cards in the arguments.
//
// Currently characters should be UNICODE. In other words,
// main routine should be wmain. See cat.cpp's main routine for the
// detail.
//////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
#endif
BOOL fnexpand(int* argc, TCHAR*** argv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cat\fnreg.cpp ===
// fnreg.cpp
//
// filename regular expression routine for WIN32
//
// Copyright (C) 1994-1998 by Hirofumi Yamamoto. All rights reserved.
//
// Redistribution and use in source and binary forms are permitted
// provided that
// the above copyright notice and this paragraph are duplicated in all such
// forms and that any documentation, advertising materials, and other
// materials related to such distribution and use acknowledge that the
// software was developed by Hirofumi Yamamoto may not be used to endorse or
// promote products derived from this software without specific prior written
// permission. THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
// OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
//

#include "precomp.h"
#pragma hdrstop

#include "fnreg.h"

// Hide everything in a name space
namespace fnreg_implement {

#ifdef UNICODE

#define MAX USHRT_MAX
typedef TCHAR uchar;
#define iskanji(x) false

#else   /* !UNICODE */

#define MAX UCHAR_MAX
typedef unsigned char uchar;
#define iskanji(x) isleadbyte(x)

#endif  /* !UNICODE */


#define PATHDLM _T("\\/")

#define ANY     _T('?')
#define CH      _T('.')
#define WILD    _T('*')
#define EOR     _T('\x01')

#define WILDCARD    _T("?*")

static TCHAR* fnrecompWorker(TCHAR* s, TCHAR* re, int& min, int& max)
{
    TCHAR* t;

    switch (*s) {
    case _T('\0'):
        *re = EOR;
        re[1] = _T('\0');
        return s;
    case ANY:
        *re++ = *s++;
        break;
    case WILD:
        *re++ = *s++;
        t = fnrecompWorker(s, re + 2, min, max);
        *re = min + 1;
        re[1] = max > MAX ? MAX : max + 1;
        max = MAX;
        return t;
    default:
        *re++ = CH;
#ifdef UNICODE
        *re++ = _totlower(*s);
        ++s;
#else
#error MBCS handling needed here.
#endif
    }
    t = fnrecompWorker(s, re, min, max);
    min++;
    max++;
    return t;
}


static BOOL fnrecomp(TCHAR* s, TCHAR* re)
{
    int a = 0, b = 0;
    return fnrecompWorker(s, re, a, b) != NULL;
}

static BOOL match(TCHAR* re, TCHAR* s)
{
    int min, max;
    int i;
    TCHAR* p;

    switch (*re) {
    case CH:
        return (re[1] == _totlower(*s)) && match(re + 2, s + 1);
    case ANY:
        return *s && match(re + 1, s + 1);
    case WILD:
        min = (uchar)re[1];
        max = (uchar)re[2];
        re += 3;
        i = 1;
#if !defined(UNICODE)
#error MBCS handling needed here.
#endif
        for (p = s + _tcslen(s); p >= s && i <= max; --p, ++i) {
            if (i >= min && match(re, p))
                return TRUE;
        }
        return FALSE;
    case EOR:
        if (re[1] == _T('\0'))
            return *s == _T('\0');
    }
    return FALSE;

}

///////////////////////////////////////////////////////////////////
// FileString class
///////////////////////////////////////////////////////////////////

class FileString {
public:
    FileString(const TCHAR* p);
    ~FileString();
    operator const TCHAR*() const { return m_string; }

    int operator==(FileString& s) const
    {
        return !_tcscmp(m_string, s.m_string);
    }
    int operator-(const FileString& f)
    {
        return _tcscmp(m_string, f);
    }
protected:
    TCHAR* m_string;
    void normalize();
};

void FileString::normalize()
{
    for (TCHAR* p = m_string; *p; ++p) {
        if (iskanji(*p))
            ++p;
        else if (*p == '\\')
            *p = '/';
    }
}

FileString::FileString(const TCHAR* p)
{
    m_string = new TCHAR[_tcslen(p) + 1];
    if (m_string == NULL) {
        fputs("FileString:: not enough mem\n", stderr);
        exit(1);
    }
    _tcscpy(m_string, p);
    normalize();
}

FileString::~FileString()
{
    delete[] m_string;
}

///////////////////////////////////////////////////////////////////
// PtrArray class
///////////////////////////////////////////////////////////////////

template <class T>
class PtrArray {
public:
    PtrArray(bool doDeleteContents = true, int defsize = DEFSIZE)
        : m_size(defsize), m_max(0), m_doDelete(doDeleteContents)
    {
        m_table = (T**)malloc(sizeof(T*) * m_size);
        if (m_table == NULL) {
            perror("PtrArray");
            exit(1);
        }
    }
    virtual ~PtrArray()
    {
        if (m_doDelete) {
            for (int i = 0; i < m_max; ++i) {
                delete m_table[i];
            }
        }
        if (m_table)
            free(m_table);
    }
    void add(T*);
    int howmany() { return m_max; }
    T* operator[](int n)
    {
        assert(n >= 0 && n < m_max);
        return m_table[n];
    }
    void sortIt();
protected:
    int m_size;
    int m_max;
    bool m_doDelete;    // whether to delete the contents
    T** m_table;
    enum { DEFSIZE = 128, INCR = 128 };
    static int __cdecl compare(const void*, const void*);
};

template <class T>
int __cdecl PtrArray<T>::compare(const void* a, const void* b)
{
    const T** ta = (const T**)a;
    const T** tb = (const T**)b;
    return int(**ta - **tb);
}

template <class T>
void PtrArray<T>::sortIt()
{
    qsort(m_table, m_max, sizeof(T*), compare);
}

template <class T>
void PtrArray<T>::add(T* t)
{
    if (m_max >= m_size) {
        m_table = (T**)realloc(m_table, (m_size += INCR) * sizeof(T*));
        if (m_table == NULL) {
            perror("PtrArray:add\n");
            exit(1);
        }
    }
    m_table[m_max++] = t;
}


///////////////////////////////////////////////////////////////////
// PtrArrayIterator class
///////////////////////////////////////////////////////////////////

#if 1
template <class T>
class PtrArrayIterator {
public:
    PtrArrayIterator(PtrArray<T>& s) : m_array(s), m_cur(0)
    {
    }

public:
    T* operator++(int);
    void restart() { m_cur = 0; }

protected:
    PtrArray<T>& m_array;
    int m_cur;
};

template <class T>
T* PtrArrayIterator<T>::operator++(int)
{
    T* t;
    if (m_cur < m_array.howmany()) {
        t = m_array[m_cur++];
    }
    else {
        t = NULL;
    }
    return t;
}

#else

template <class T>
class SimpleIterator {
public:
    SimpleIterator(T& s) : m_array(s), m_cur(0)
    {
    }

public:
    T* operator++(int);
    void restart() { m_cur = 0; }

protected:
    T& m_array;
    int m_cur;
};

template <class T>
T* PtrArrayIterator<T>::operator++(int)
{
    T* t;
    if (m_cur < m_array.howmany()) {
        t = m_array[m_cur];
        ++m_cur;
    }
    else {
        t = NULL;
    }
    return t;
}

#endif



///////////////////////////////////////////////////////////////////
// FilenameTable class
///////////////////////////////////////////////////////////////////

class FilenameTable {
public:
    FilenameTable(TCHAR* = NULL, int _searchDir = TRUE);
    ~FilenameTable();

public:
    void search(TCHAR* p, int level = 0);
    int howmany() { return m_names.howmany(); }
    PtrArray<FileString>& getTable() { return m_names; }

protected:
    int m_searchDir;
    PtrArray<FileString> m_names;
};

FilenameTable::FilenameTable(TCHAR* nm, int _searchDir /*=TRUE*/)
    : m_searchDir(_searchDir)
{
#if 0
    search(substHome(nm));
#else
    if (nm)
        search(nm);
#endif
}

FilenameTable::~FilenameTable()
{
}

inline bool chkCurrentOrParentDir(const TCHAR* s)
{
    return s[0] == _T('.') && (s[1] == _T('\0') || (s[1] == _T('.') && s[2] == _T('\0')));
}

void FilenameTable::search(TCHAR* p, int level)
{
    TCHAR* wild = _tcspbrk(p, WILDCARD);

    if (wild) {
        // has wildcards
        TCHAR* const morepath = _tcspbrk(wild, PATHDLM);      // more path ?
        TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], file[_MAX_FNAME], ext[_MAX_EXT];
        TCHAR re[(_MAX_FNAME + _MAX_EXT) * 2] = {0};

        // split the path
        {
            // *hack*
            // to avoid strcpy, we'll touch argument p directly
            TCHAR bc;
            if (morepath) {
                // truncate the path so that we will work with
                // the lookup directory which contains the wild cards
                bc = *morepath;
                *morepath = _T('\0');
            }
            _tsplitpath(p, drive, dir, file, ext);
            if (morepath) {
                *morepath = bc;
            }
        }
        // build file+ext which contains the wild cards
        TCHAR fnext[_MAX_FNAME + _MAX_EXT - 1];
        _tcscpy(fnext, file);
        _tcscat(fnext, ext);

        // compile the regular expression
        if (!fnrecomp(fnext, re)) {
            fputs("Illegal regular expression in ", stderr);
            _fputts(fnext, stderr);
            fputs("\n", stderr);
            exit(1);
        }

        // make search string
        TCHAR path[_MAX_PATH];
        _tmakepath(path, drive, dir, _T("*"), _T(".*"));

        // listup all the files and directories in the current lookup directory
        // and pickup matched ones
        _tfinddata_t findinfo;
        intptr_t hFind = _tfindfirst(path, &findinfo);
        if (hFind != -1) {
            do {
                if (!chkCurrentOrParentDir(findinfo.name)) {
                    if (match(re, findinfo.name)) {
                        // searched file or directory matches the pattern
                        _tmakepath(path, drive, dir, findinfo.name, _T(""));
                        if (morepath) {
                            // there's more sub directories to search.
                            if (findinfo.attrib & _A_SUBDIR) {
                                // if directory, do recursive calls
                                _tcscat(path, morepath);    // morepath begins with '/'
                                search(path, level + 1);
                            }
                        }
                        else {
                            // this directory is the last element
                            if (m_searchDir || !(findinfo.attrib & _A_SUBDIR)) {
                                FileString* name = new FileString(path);
                                if (name == NULL) {
                                    fputs("FilenameTable::search(): not enough mem\n", stderr);
                                    exit(1);
                                }
                                m_names.add(name);
                            }
                        }
                    }
                }
            } while (!_tfindnext(hFind, &findinfo));
            _findclose(hFind);
        }
    }

    if ((level == 0 && m_names.howmany() == 0) || (!wild && !_taccess(p, 0))) {
        FileString* name = new FileString(p);
        if (name == NULL) {
            fputs("FilenameTable::search() not enough mem\n", stderr);
            exit(1);
        }
        m_names.add(name);
    }

    if (level == 0 && m_names.howmany() > 0) {
        m_names.sortIt();
    }
}

};  // end of namespace


using namespace ::fnreg_implement;

///////////////////////////////////////////////////////////////////
// Global object of FilenameTable class
///////////////////////////////////////////////////////////////////

static PtrArray<FilenameTable> fnarray;


///////////////////////////////////////////////////////////////////
// Interface routine to the world
///////////////////////////////////////////////////////////////////

extern "C"
BOOL fnexpand(int* pargc, TCHAR*** pargv)
{
    assert(pargc != NULL);
    assert(pargv != NULL);

    for (int i = 1; i < *pargc; ++i) {
        FilenameTable* fn = new FilenameTable((*pargv)[i]);
        fnarray.add(fn);
    }

    int cnt = 0;

    PtrArrayIterator<FilenameTable> fnItor(fnarray);

    // first count up the argc
    for (FilenameTable* ft; ft = fnItor++; ) {
        cnt += ft->howmany();
    }
    fnItor.restart();

    // setup argc and argv
    *pargc = cnt + 1;
    TCHAR** nargv = new TCHAR*[*pargc];
    if (!nargv)
        return FALSE;
    nargv[0] = (*pargv)[0];

    // set all arguments
    for (cnt = 1, i = 0; ft = fnItor++; ++i) {
        PtrArrayIterator<FileString> itor(ft->getTable());
        FileString* fs;
        for (; fs = itor++; ++cnt) {
            const TCHAR* p = *fs;
            nargv[cnt] = (TCHAR*)p;
        }
    }
    assert(*pargc == cnt);

    *pargv = nargv;

    return TRUE;
}

#if defined(TEST) || defined(TEST0)
void print(TCHAR* p)
{
    for (; *p; ++p) {
        _puttchar(_T('['));
        if (*p >= 0x20 && *p < 0x7f) {
            _puttchar(*p);
        }
#if 1
        printf(":%d] ", *p);
#else
        _puttchar(_T(':'));
        TCHAR buf[34];
        _ltot(*p, buf, 10);
        _fputts(buf, stdout);
        _fputts(_T("] "), stdout);
#endif
    }
    _puttchar('\n');
}
#endif

#ifdef TEST

extern "C"
int wmain(int argc, TCHAR** argv)
{
    if (!fnexpand(argc, argv))
        return EXIT_FAILURE;

    while (--argc) {
        _putts(*++argv);
    }
    return EXIT_SUCCESS;
}

#endif

#ifdef TEST0

extern "C"
int wmain(int argc, TCHAR** argv)
{
    TCHAR re[256];
    if (!fnrecomp(argv[1], re)) {
        puts("error");
        return EXIT_FAILURE;
    }

    print(re);

    TCHAR buf[BUFSIZ];
    while (_getts(buf)) {
        if (match(re, buf))
            puts("match");
        else
            puts("does not match.");
    }
    return EXIT_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cat\precomp.h ===
// precomp.h

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <tchar.h>
#include <limits.h>
#include <io.h>
#include <fcntl.h>
#include <locale.h>
#include <assert.h>

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cat\version.cpp ===
//
// cat - conCATenate STDIN to STDOUT
//
// version file
//
//   27-May 1998 hiroyama
//
//

#include "precomp.h"
#pragma hdrstop

char version[] = "cat version 1.0 -- concatinate files or stdin\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\debug.c ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:

    debug.c

Abstract:

Author:

Environment:

Notes:

Revision History:

--*/

#include <stdio.h>     // vsprintf()
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#define DBGHDR    "[cddump] "
#define DBGHDRLEN (strlen( DBGHDR ))



#if DBG
//
// Debug level global variable
//
//  0  = Extreme errors only
//  1  = errors, major events
//  2  = Standard debug level
//  3  = Major code branches
//  4+ = Step through code

LONG DebugLevel         = 0;

VOID
__cdecl
CddumpDebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for RedBook driver

Arguments:

    Debug print level between 0 and x, with x being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    //
    // allow negative numbers
    //

    if ((DebugPrintLevel < 0) || (DebugPrintLevel <= DebugLevel)) {
        char buffer[200]; // Potential overflow

        //
        // single print so won't swap, obscuring message
        //

        va_start( ap, DebugMessage );
        RtlCopyMemory( buffer, DBGHDR, DBGHDRLEN );
        vsprintf(buffer+DBGHDRLEN, DebugMessage, ap);
        fprintf(stderr, buffer);
        va_end(ap);

    }
}


#else

// nothing

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\read.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    read.c

Abstract:

    dump cd tracks/sectors to wav files

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include "common.h"

#define LARGEST_SECTORS_PER_READ 27 // about 64k of data



ULONG32
CddumpDumpLba(
    HANDLE CdromHandle,
    HANDLE OutHandle,
    ULONG  StartAddress,
    ULONG  EndAddress
    )
{
    RAW_READ_INFO info;    // fill in for the read request
    PUCHAR sample;
    ULONG bytesReturned;
    ULONG currentLba;
    ULONG temp;
    ULONG sectorsPerRead;

    sample = NULL;
    currentLba = StartAddress;
    sectorsPerRead = LARGEST_SECTORS_PER_READ;

    TRY {

        sample = malloc(RAW_SECTOR_SIZE*LARGEST_SECTORS_PER_READ);
        if (sample == NULL) {
            printf("DumpLba => No memory for sample\n");
            LEAVE;
        }

        DebugPrint((3, "DumpLba => Largest Sectors Per Read: %d\n",
                    LARGEST_SECTORS_PER_READ));

        while (sectorsPerRead != 0) {

            while (currentLba + sectorsPerRead <= EndAddress) {

                //
                // do a read of sectorsPerRead sectors
                //

                info.DiskOffset.QuadPart = (ULONGLONG)(currentLba*(ULONGLONG)2048);
                info.SectorCount         = sectorsPerRead;
                info.TrackMode           = CDDA;

                DebugPrint((3, "DumpLba => (%d) read from %8d to %8d:",
                            sectorsPerRead, currentLba,
                            currentLba + sectorsPerRead - 1));

                if(!DeviceIoControl(CdromHandle,
                                    IOCTL_CDROM_RAW_READ,
                                    &info,                    // pointer to inputbuffer
                                    sizeof(RAW_READ_INFO),    // sizeof inputbuffer
                                    sample,                   // pointer to outputbuffer
                                    RAW_SECTOR_SIZE * sectorsPerRead, // sizeof outputbuffer
                                    &bytesReturned,           // pointer to number of bytes returned
                                    FALSE                     // ???
                                    )
                   ) {
                    DWORD error = GetLastError();

                    if (error == ERROR_INVALID_PARAMETER) {
                        printf("ERROR_INVALID_PARAMTER for read size %x, "
                               "trying smaller transfer\n", sectorsPerRead);
                        break; // out of inner while() loop
                    } else {
                        printf("Error %d sending IOCTL_CDROM_RAW_READ for sector %d\n",
                               GetLastError(), currentLba);
                        LEAVE;
                    }
                }

                if (bytesReturned != RAW_SECTOR_SIZE * sectorsPerRead) {

                    printf("Only returned %d of %d bytes for read %d\n",
                           bytesReturned,
                           RAW_SECTOR_SIZE * sectorsPerRead,
                           currentLba
                           );
                    LEAVE;
                }

                //
                // write that buffer out
                //
                DebugPrint((3, "DumpLba => (%d) write from %8d to %8d:",
                            sectorsPerRead, currentLba,
                            currentLba + sectorsPerRead - 1));

                if (!WriteFile(OutHandle,
                               sample,
                               RAW_SECTOR_SIZE * sectorsPerRead,
                               &temp,
                               NULL)) {

                    printf("Unable to write data for read %d\n", currentLba);
                    LEAVE;
                }

                //
                // increment currentLba
                //

                currentLba += sectorsPerRead;

            } // currentLba + sectorsPerRead <= EndAddress

            sectorsPerRead /= 2;

        } // sectorsPerRead != 0

    } FINALLY {

        if (sample) {
            free(sample);
        }

    }

    return 0;
}


PCDROM_TOC
CddumpGetToc(
    HANDLE device
    )
{
    PCDROM_TOC  toc;
    ULONG bytesReturned;
    ULONG errorValue;

    toc = (PCDROM_TOC)malloc( sizeof(CDROM_TOC) );
    if ( toc == NULL ) {
        printf( "Insufficient memory\n" );
        return NULL;
    }

    if( !DeviceIoControl( device,
                          IOCTL_CDROM_READ_TOC,
                          NULL,              // pointer to inputbuffer
                          0,                 // sizeof inputbuffer
                          toc,               // pointer to outputbuffer
                          sizeof(CDROM_TOC), // sizeof outputbuffer
                          &bytesReturned,    // pointer to number of bytes returned
                          FALSE              //
                          )
        ) {
        errorValue = GetLastError();
        printf( "Error %d sending IOCTL_CDROM_READ_TOC\n", errorValue );
        free( toc );
        return NULL;
    }
    return toc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\cddb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cddb.c

Abstract:

    cddb support

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include "common.h"

ULONG
CDDB_ID(
    PCDROM_TOC toc
    )

{
    ULONG i,n,j;
    ULONG cddbSum;
    ULONG totalLength;
    ULONG totalTracks;
    ULONG finalDiscId;

    i = 0;
    n = 0;
    totalTracks = toc->LastTrack - toc->FirstTrack;

    totalTracks++;  // MCI difference

    while (i < totalTracks) {

        // cddb_sum
        cddbSum = 0;
        j = (toc->TrackData[i].Address[1] * 60) +
            (toc->TrackData[i].Address[2]);
        while (j > 0) {
            cddbSum += j % 10;
            j /= 10;
        }

        n += cddbSum;
        i++;

    }

    // compute total cd length in seconds
    totalLength =
        ((toc->TrackData[totalTracks].Address[1] * 60) +
         (toc->TrackData[totalTracks].Address[2])
         ) -
        ((toc->TrackData[0].Address[1] * 60) +
         (toc->TrackData[0].Address[2])
         );

    finalDiscId = (((n % 0xff) << 24) |
                   (totalLength << 8) |
                   (totalTracks)
                   );

    return finalDiscId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\cddump.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cddump.c

Abstract:

    parses commands and acts

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include "common.h"

#define VERSION_MAJOR 1
#define VERSION_MINOR 0
#define VERSION_STRING "1.00"


ULONG32
TestCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
ListCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
DumpTrackCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
VerifyHeaderCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

ULONG32
ReadTOCCommand(
    HANDLE device,
    int argc,
    char *argv[]
    );

//
// Each structure instance can have a function pointer, name, and description
//

typedef struct {
    char *Name;
    char *Description;
    ULONG32 (*Function)(HANDLE device, int argc, char *argv[]);
} COMMAND;

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"test", NULL, TestCommand},
    {"help", "help for all commands", ListCommand},
    {"dump", "[track] dump an audio track", DumpTrackCommand},
    {"toc", "prints the table of contents", ReadTOCCommand},
    {"header", "[file] verifies the info in the wav header", VerifyHeaderCommand},
    {NULL, NULL, NULL}
};


int __cdecl main(int argc, char *argv[])
/*++

Routine Description:

    Parses input, showing help or calling function requested appropriately

Return Value:

     0 - success
    -1 - insufficient arguments
    -2 - error opening device (DNE?)

--*/
{
    int     i = 0;
    int     buflen;
    char   *buffer;
    HANDLE  h;

    if ( argc < 3 ) {
        ListCommand( NULL, argc, argv );
        return -1;
    }

    buflen = ( strlen(argv[1]) + 5 ) * sizeof(char);

    buffer = (char *)malloc( buflen );
    if (buffer == NULL) {
        fprintf(stderr, "Insufficient memory\n");
        return -1;
    }

    sprintf( buffer, "\\\\.\\%s", argv[1] );
    DebugPrint((2, "Main => Sending command %s to drive %s\n", argv[2], buffer));

    h = CreateFile( buffer,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if ( h == INVALID_HANDLE_VALUE ) {
        fprintf(stderr, "Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while ( CommandArray[i].Name != NULL ) {

        if(strcmp(argv[2], CommandArray[i].Name) == 0) {

            (CommandArray[i].Function)(h, (argc - 2), &(argv[2]));

            break;
        }

        i++;
    }

    if ( CommandArray[i].Name == NULL ) {
        fprintf(stderr, "Unknown command %s\n", argv[2]);
    }

    CloseHandle(h);

    return 0;
}

ULONG32
VerifyHeaderCommand(
    HANDLE device,
    int argc,
    char *argv[]
    )
/*++

Routine Description:

    opens the next argument and reads the wav header, printing to stdout

Arguments:

    device - unused
    argc - the number of additional arguments.
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    HANDLE wavHandle;

    if (argv[1] == NULL) {
        fprintf(stderr, "Need filename to attempt to parse\n");
        return -1;
    }

    TRY {

        DebugPrint((2, "VerifyHeader => Opening %s\n", argv[1]));

        wavHandle = CreateFile(argv[1],
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (wavHandle == INVALID_HANDLE_VALUE) {
            printf("Error openingfile %x\n", GetLastError());
            LEAVE;
        }

        ReadWavHeader(wavHandle);

    } FINALLY {

    }

    return 0;

}


ULONG32 TestCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:

    device - a file handle to send the ioctl to
    argc - the number of additional arguments.
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;
    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }



    return STATUS_SUCCESS;
}

ULONG32 ListCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:

    device - unused
    argc - unused
    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i;

    printf("\nCdDump Version " VERSION_STRING "\n");
    printf("\tUsage: cddump <drive> <command> [parameters]\n");
    printf("\tpossible commands: \n");
    for (i = 0; CommandArray[i].Name != NULL; i++) {

        if(CommandArray[i].Description != NULL) {
            printf( "\t\t%s - %s\n",
                    CommandArray[i].Name,
                    CommandArray[i].Description
                    );
        }

    }
    printf( "\n" );

    return STATUS_SUCCESS;
}

ULONG32 ReadTOCCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents

Arguments:

    device - a file handle to send the ioctl to
    argc - the number of additional arguments.  should be zero
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    PCDROM_TOC  toc;
    PTRACK_DATA track;
    ULONG       numberOfTracks;
    ULONG       i;

    DebugPrint((2, "ReadToc => Reading Table of Contents\n"));

    toc = CddumpGetToc( device );
    if (toc == NULL) {
        return -1;
    }

    printf("First Track Number: %d\n", toc->FirstTrack);
    printf("Last Track Number: %d\n", toc->LastTrack);
    printf("CDDB ID: %08x\n", CDDB_ID(toc));



    numberOfTracks = (toc->LastTrack - toc->FirstTrack) + 1;

    // parse and print the information

    track = (PTRACK_DATA) &(toc->TrackData[0]);

    printf("Number  ADR  Control    Start        End        Bytes\n");
    printf("------  ---  -------  ----------  ----------  ----------\n");

    for(i = 0; i < numberOfTracks; i++) {

        ULONG trackStart;
        ULONG trackEnd;
        ULONG trackBytes;

        trackStart = MSF_TO_LBA(track->Address[1],
                                track->Address[2],
                                track->Address[3]);
        trackEnd = MSF_TO_LBA((track+1)->Address[1],
                              (track+1)->Address[2],
                              (track+1)->Address[3]);
        trackEnd--;

        trackBytes = (trackEnd - trackStart) * RAW_SECTOR_SIZE;

        printf("  %2d    %2d     %2d     %10d  %10d  %8dk \n",
               track->TrackNumber,
               track->Adr,
               track->Control,
               trackStart,
               trackEnd,
               trackBytes / 1000
               );


        track++;
    }
    return STATUS_SUCCESS;
}



ULONG32 DumpTrackCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads a section of disc in raw read mode

Arguments:

    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[1] - the starting LBA.  Starts at zero if this is not here
    argv[2] - the ending LBA.  if not specified, equal to start

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    PCDROM_TOC toc;
    HANDLE  outputFile = (HANDLE)-1;
    ULONG   track;
    ULONG   endingSector;
    ULONG   numberOfSectors;     // actually useful data
    ULONG   numberOfReads;
    ULONG   status;

    ULONG   startingSector;
    LONG   i;

    ULONG   cddbId = 0;

    UCHAR   fileName[1024]; // randomly chosen size.

    PSAMPLE sample;

    toc = NULL;
    sample = NULL;

    TRY {
        track = atoi(argv[1]);
        if (track==0) {
            printf( "Cannot read track 0.\n" );
            status = -1;
            LEAVE;
        }

        toc = CddumpGetToc( device );
        if (toc==NULL) {
            status = -1;
            LEAVE;
        }

        cddbId = CDDB_ID(toc);
        sprintf(fileName, "%08x - Track %02d.wav", cddbId, track);

        DebugPrint((2, "DumpTrack => output filename: %s\n", fileName));

        //
        // account for zero-index
        //

        startingSector = MSF_TO_LBA(toc->TrackData[track-1].Address[1],
                                    toc->TrackData[track-1].Address[2],
                                    toc->TrackData[track-1].Address[3]
                                    );
        endingSector   = MSF_TO_LBA(toc->TrackData[track].Address[1],
                                    toc->TrackData[track].Address[2],
                                    toc->TrackData[track].Address[3]
                                    );
        endingSector--; // no overlap

        numberOfSectors = endingSector - startingSector;

        DebugPrint((3, "DumpTrack => old sectors: start %8d  end %8d  count %d\n",
                    startingSector, endingSector, numberOfSectors));


        sample = (PSAMPLE)malloc( RAW_SECTOR_SIZE );
        if ( sample == NULL ) {
            printf("Insufficient resources (sample)\n");
            status = -1;
            LEAVE;
        }

        //
        // first find a fully zero'd sample -- that will be
        // the _real_ start address of the track after adjusting
        // for redbook inaccuracies.
        //

        for (i=REDBOOK_INACCURACY; i > -(REDBOOK_INACCURACY); i--) {

            RAW_READ_INFO info;
            ULONG bytesReturned;
            ULONG j;
            BOOLEAN foundZeroSector = FALSE;

            if ((LONG)startingSector + i > 0 ) {  // only read positive

                info.DiskOffset.QuadPart = (ULONGLONG)((startingSector + i)*(ULONGLONG)2048);
                info.SectorCount         = 1;
                info.TrackMode           = CDDA;

                if(DeviceIoControl(device,
                                   IOCTL_CDROM_RAW_READ,
                                   &info,                 // pointer to inputbuffer
                                   sizeof(RAW_READ_INFO), // sizeof inputbuffer
                                   sample,                // pointer to outputbuffer
                                   RAW_SECTOR_SIZE,       // sizeof outputbuffer
                                   &bytesReturned,        // pointer to number of bytes returned
                                   FALSE)) {

                    //
                    // read succeeded, see if all zero'd
                    //

                    assert(bytesReturned == RAW_SECTOR_SIZE);

                    foundZeroSector = TRUE;
                    for (j=0;j<SAMPLES_PER_SECTOR;j++) {
                        if (sample[j].AsUlong32 != 0) foundZeroSector = FALSE;
                    }

                }

                if (foundZeroSector) {
                    DebugPrint((1, "DumpTrack => New starting sector is "
                                "offset by %d\n", i));
                    startingSector += i; // change to real starting sector
                    break;               // stop looping.
                }
            } // end of positive check
        } // end of loop

        //
        // then find a fully zero'd sample at the end -- that will
        // be the _real_ end address of the track after adjusting
        // for redbook inaccuracies.
        //

        for (i=-(REDBOOK_INACCURACY); i < REDBOOK_INACCURACY; i++) {

            RAW_READ_INFO info;
            ULONG bytesReturned;
            ULONG j;
            BOOLEAN foundZeroSector = FALSE;

            if ((LONG)endingSector + i > 0 ) {  // only read positive

                info.DiskOffset.QuadPart = (ULONGLONG)((endingSector + i)*(ULONGLONG)2048);
                info.SectorCount         = 1;
                info.TrackMode           = CDDA;

                if(DeviceIoControl(device,
                                   IOCTL_CDROM_RAW_READ,
                                   &info,                 // pointer to inputbuffer
                                   sizeof(RAW_READ_INFO), // sizeof inputbuffer
                                   sample,                // pointer to outputbuffer
                                   RAW_SECTOR_SIZE,       // sizeof outputbuffer
                                   &bytesReturned,        // pointer to number of bytes returned
                                   FALSE)) {

                    //
                    // read succeeded, see if all zero'd
                    //

                    assert(bytesReturned == RAW_SECTOR_SIZE);

                    foundZeroSector = TRUE;
                    for (j=0;j<SAMPLES_PER_SECTOR;j++) {
                        if (sample[j].AsUlong32 != 0) foundZeroSector = FALSE;
                    }

                }

                if (foundZeroSector) {
                    DebugPrint((2, "DumpTrack => New starting sector is "
                                "offset by %d\n", i));
                    endingSector += i; // change to real starting sector
                    break;               // stop looping.
                }
            } // end of positive check
        } // end of loop

        numberOfSectors = endingSector - startingSector;

        DebugPrint((2, "DumpTrack => new sectors: start %8d  end %8d  count %d\n",
                    startingSector, endingSector, numberOfSectors));

        //
        // a bit of debugging info...
        //

        DebugPrint((2, "DumpTrack => Reading %d sectors starting at sector %d\n",
                    numberOfSectors, startingSector));

        //
        // create the file
        //
        outputFile = CreateFile(fileName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                (HANDLE)NULL);

        if (outputFile == INVALID_HANDLE_VALUE) {
            printf( "Cannot open output file.\n" );
            status = -1;
            LEAVE;
        }

        //
        // dump the wav header info
        //
        DumpWavHeader(outputFile,
                      numberOfSectors * SAMPLES_PER_SECTOR,
                      44100,  // 44.1KHz sound
                      2,      // stereo sound
                      16      // 16-bit sound
                      );
        CddumpDumpLba(device,
                      outputFile,
                      startingSector,
                      endingSector
                      );

        DebugPrint((2, "DumpTrack => Done!\n"));


    } FINALLY {

        free(toc);
        free(sample);

    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\common.h ===
#ifndef __CDDUMP_COMMON_H__
#define __CDDUMP_COMMON_H__

//
// these headers are order-dependent
//

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <windows.h>
#include <devioctl.h>
#include <ntddcdrm.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define STATUS_SUCCESS     ( 0 )
#define RAW_SECTOR_SIZE    ( 2352 )
#define SAMPLES_PER_SECTOR ( RAW_SECTOR_SIZE / sizeof(SAMPLE) )
#define REDBOOK_INACCURACY ( 75 )
#define TRY
#define LEAVE              goto __label;
#define FINALLY            __label:

////////////////////////////////////////////////////////////////////////////////

#define LBA_TO_MSF(Lba,Minutes,Seconds,Frames)               \
{                                                            \
    (Minutes) = (UCHAR)(Lba  / (60 * 75));                   \
    (Seconds) = (UCHAR)((Lba % (60 * 75)) / 75);             \
    (Frames)  = (UCHAR)((Lba % (60 * 75)) % 75);             \
}

#define MSF_TO_LBA(Minutes,Seconds,Frames) \
    (ULONG)((60 * 75 * (Minutes) ) + (75 * (Seconds)) + ((Frames) - 150))

////////////////////////////////////////////////////////////////////////////////

typedef struct _SAMPLE {
    union {
        UCHAR  Data[4];
        struct {
            SHORT Left;
            SHORT Right;
        };
    };
    ULONG32 AsUlong32;
} SAMPLE, *PSAMPLE;



////////////////////////////////////////////////////////////////////////////////


PCDROM_TOC
CddumpGetToc(
    HANDLE device
    );

ULONG
CDDB_ID(
    PCDROM_TOC toc
    );

ULONG32
CddumpDumpLba(
    HANDLE CdromHandle,
    HANDLE OutHandle,
    ULONG  StartAddress,
    ULONG  EndAddress
    );

ULONG32
DumpWavHeader(
    HANDLE  OutFile,
    ULONG32 Samples,
    ULONG32 SamplesPerSecond,
    USHORT  Channels,
    USHORT  BitsPerSample
    );

VOID
ReadWavHeader(
    HANDLE InFile
    );


#if DBG
extern LONG DebugLevel;

#define DebugPrint(x) CddumpDebugPrint x

VOID
__cdecl
CddumpDebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );
#else
#define DebugPrint
#endif

////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __CDDUMP_COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\wav.h ===
#ifndef __WAV_H__
#define __WAV_H__

#ifdef __cplusplus
extern "C" {
#endif


#define ChunkIdRiff   'FFIR'
#define ChunkIdFormat ' tmf'
#define ChunkIdData   'atad'

#define RiffTypeWav   'EVAW'

#define FormatTagUncompressed 1

typedef struct _WAV_FORMAT_CHUNK {
    ULONG32   ChunkId;
    ULONG32   ChunkSize;
    SHORT     FormatTag;
    USHORT    Channels;
    ULONG32   SamplesPerSec;
    ULONG32   AvgBytesPerSec;
    USHORT    BlockAlign;
    USHORT    BitsPerSample;
} WAV_FORMAT_CHUNK, *PWAV_FORMAT_CHUNK;

typedef struct _WAV_DATA_CHUNK {
    ULONG32   ChunkId;
    ULONG32   ChunkSize;
    // data is appended
} WAV_DATA_CHUNK, *PWAV_DATA_CHUNK;

typedef struct _WAV_HEADER_CHUNK {
    ULONG32          ChunkId;
    ULONG32          ChunkSize;
    ULONG32          RiffType;
    WAV_FORMAT_CHUNK Format;
    WAV_DATA_CHUNK   Data;
} WAV_HEADER_CHUNK, *PWAV_HEADER_CHUNK;

#ifdef __cplusplus
}
#endif


#endif // __WAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cddump\wav.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cddump.c

Abstract:

    dump cd tracks to wav files

Environment:

    User mode only

Revision History:

    05-26-98 : Created

--*/

#include <windows.h>
#include <stdio.h>
#include "wav.h"

ULONG32
DumpWavHeader(
    HANDLE  OutFile,
    ULONG32 Samples,
    ULONG32 SamplesPerSecond,
    USHORT  Channels,
    USHORT  BitsPerSample
    )
{
    WAV_HEADER_CHUNK Header;
    ULONG32 temp;

    Header.ChunkId               = ChunkIdRiff;
    Header.RiffType              = RiffTypeWav;
    Header.Format.ChunkId        = ChunkIdFormat;
    Header.Format.ChunkSize      = sizeof(WAV_FORMAT_CHUNK) - (sizeof(ULONG)*2);
    Header.Format.FormatTag      = FormatTagUncompressed;

    Header.Format.BitsPerSample  = BitsPerSample;
    temp = (BitsPerSample+7)/8;  // temp = bytes per sample rounded up

    Header.Format.Channels       = Channels;

    temp *= Channels;            // temp = bytes for all channels

    if (temp > (USHORT)-1) {
        fprintf(stderr, "Bytes for all channels exceeds MAXUSHORT, not a valid "
                "option for WAV file\n");
        return -1;
    }

    Header.Format.BlockAlign     = (USHORT)temp;
    Header.Format.SamplesPerSec  = SamplesPerSecond;
    Header.Format.AvgBytesPerSec = temp * SamplesPerSecond;

    temp *= Samples;             // temp = number of total bytes
    temp *= 2;                   // unknown why this is needed.
    Header.Data.ChunkSize        = temp;
    Header.Data.ChunkId          = ChunkIdData;

    Header.ChunkSize = temp + sizeof(WAV_HEADER_CHUNK); // 54

    if (!WriteFile( OutFile, &Header, sizeof(Header), &temp, NULL ) ) {
        fprintf(stderr, "Unable to write header\n" );
        return -1;
    }
    return 0;

}

VOID
ReadWavHeader(
    HANDLE InFile
    )
{
    WAV_HEADER_CHUNK Header;
    ULONG temp;

    if (!ReadFile(InFile, &Header, sizeof(Header), &temp, NULL) ||
        temp != sizeof(Header)
        ) {

        fprintf(stderr, "Unable to read header %x\n", GetLastError());
        return;
    }

    if (Header.ChunkId != ChunkIdRiff) {
        printf("ChunkId is not RIFF (%x)\n", Header.ChunkId);
        return;
    }

    if (Header.RiffType != RiffTypeWav) {
        printf("RiffType is not RiffTypeWav (%x)\n", Header.RiffType);
        return;
    }

    if (Header.Format.ChunkId != ChunkIdFormat) {
        printf("Format.ChunkId is not ChunkIdFormat (%x)\n",
               Header.Format.ChunkId);
        return;
    }

    if (Header.Format.ChunkSize != sizeof(WAV_FORMAT_CHUNK) - (2*sizeof(ULONG))) {
        printf("Format.ChunkSize is not %x (%x)\n",
               sizeof(WAV_FORMAT_CHUNK) - (2*sizeof(ULONG)),
               Header.Format.ChunkSize);
        return;
    }

    if (Header.Format.FormatTag != FormatTagUncompressed) {
        printf("Format. is not Uncompressed (%x)\n", Header.Format.FormatTag);
        return;
    }


    if (Header.Data.ChunkId != ChunkIdData) {
        printf("Data.ChunkId is not ChunkIdData (%x)\n",
               Header.Data.ChunkId);
        return;
    }

    printf("Uncompressed RIFF/Wav File\n");
    printf("\t%2d bits per sample\n", Header.Format.BitsPerSample);
    printf("\t%2d channels\n", Header.Format.Channels);
    printf("\t%2d samples per second\n", Header.Format.SamplesPerSec);
    printf("\t%2d average bytes per second\n", Header.Format.AvgBytesPerSec);
    printf("Total data available to player: %d\n", Header.Data.ChunkSize);

    temp = Header.Data.ChunkSize / Header.Format.AvgBytesPerSec;

    printf("\t%d seconds of audio\n",
           temp
           );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checkrel\checkrel.c ===
#ifndef WIN32
#define RC_INVOKED
#endif

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <conio.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <imagehlp.h>

#define READ_BUFFER_SIZE (16 * 1024 * sizeof(DWORD)) // 64k blocks

#define CHECK_NAME "\\chkfile.chk"

LPSTR
atolx(
    LPSTR psz,
    LPDWORD pul);

DWORD
ParseCheckFile (
    VOID
    );

HANDLE
PortFindFirstFile(
    LPSTR FindPattern,
    BOOL fNormal,
    LPSTR FindName,
    LPDWORD FindSize);

BOOL
PortFindNextFile(
    HANDLE hFind,
    BOOL fNormal,
    LPSTR FindName,
    LPDWORD FindSize);

VOID
PortFindClose(
    HANDLE hFind
    );

UINT ProcessCheckFile(LPINT pcfiles);
VOID Usage(VOID);
VOID __cdecl crerror(LPSTR pszfmt, ...);
LPSTR *ProcessParameters(INT *pargc, LPSTR argv[]);
LPSTR ProcessArgBuf(LPSTR pszargs);
BOOL OpenCheckFile(VOID);
BOOL ProcessEntry(LPSTR pszFullPath, LPSTR pszRelPath);
BOOL FindEntry(LPSTR pszRelPath, PULONG pSum);
DWORD MissingEntries(VOID);
VOID ReadCheckHeader(FILE *pf);
VOID RecursiveCheckHeader(void);
VOID WriteCheckHeader(FILE *pf);
LPSTR iscomment(LPSTR psz);
LPSTR ismatch(LPSTR psz, LPSTR pszcompact);
LPSTR iscomment(LPSTR psz);
LPSTR AddDirectory(LPSTR psz);
BOOL AddEntry(LPSTR psz, BOOL frequired);
BOOL AddComponent(LPSTR pszdir, LPSTR pszpat, BOOL fdir, BOOL frequired);
LPSTR ReadDirectory(LPSTR pszdir);

#define CHECKSTRLEN(psz, cbmax)                                         \
        if (strlen(psz) > cbmax) {                                      \
            crerror("String overflow at line %u (%s)", __LINE__, psz);  \
            exit(4);                                                    \
        }

#define DEFAULTROOT "nt"

//
// Defined parsed check file entry structure and table storage.
//

typedef struct _CHECK_FILE_ENTRY {
    struct _CHECK_FILE_ENTRY *Next;
    DWORD Sum;
    WORD Length;
    CHAR *Name;
} CHECK_FILE_ENTRY, *PCHECK_FILE_ENTRY;

#define CHECK_ENTRY_TABLE_SIZE 4096

CHECK_FILE_ENTRY CheckEntryTable[CHECK_ENTRY_TABLE_SIZE];

//
// Define root of parsed check file list.
//

CHECK_FILE_ENTRY CheckEntryRoot;

struct component_s {
    struct component_s *pcmNext;        // next in linked list
    BOOL                fDir;           // TRUE if directory
    BOOL                fFound;         // TRUE if found
    BOOL                fRequired;      // TRUE if must exist
    CHAR                achPat[1];      // path component (subdir or pattern)
};

struct checkpath_s {
    struct checkpath_s *pcpNext;        // next in linked list
    struct component_s *pcmPat;         // subdirectories and file patterns
    CHAR                achDir[1];      // root relative directory path
};

struct checkpath_s *pcpPaths = NULL;


DWORD cbCheck;
LPSTR pszCheckFileName = NULL;  // input/output check file path
LPSTR pszLogFileName = NULL;    // error log file path
FILE *pfCheck = NULL;           // input/output check stdio file pointer
FILE *pfLog;                    // error log file pointer
LPSTR pszCheck = NULL;          // input check file contents
LPSTR RootOfTree = DEFAULTROOT;
BOOL fInProgress = FALSE;
UINT cbProgress = 0;

BOOL fAll = FALSE;
BOOL fCommand = FALSE;
BOOL fGenerateCheck = FALSE;
BOOL fNoArgs = FALSE;
BOOL fRecurse = FALSE;
BOOL fPrintMissing = TRUE;
BOOL fPrintExtra = TRUE;
DWORD fCdCheck;

CHAR OutputLine[512];
DWORD ReadBuffer[READ_BUFFER_SIZE / sizeof(DWORD) + 1];



//
// this table must be in alphabetical order !!!
//

LPSTR pszDefaultDir =
    "#directory start\n"
#if defined(i386)
    "*.\n"
    "*.com\n"
#endif
#if defined(MIPS) || defined(_ALPHA_)
    "*.dll\n"
    "*.exe\n"
#endif
#if defined(PPC)
    "*.exe\n"
#endif
    "?\\*.*\n"
    "?\\dump\\ optional\n"
    "?\\dump\\*.* optional\n"
    "?\\idw\\ optional\n"
    "?\\idw\\*.* optional\n"
    "?\\idw\\setup\\ optional\n"
    "?\\idw\\setup\\*.* optional\n"
    "?\\km\\ optional\n"
    "?\\km\\*.* optional\n"
    "?\\km\\symbols\\ optional\n"
    "?\\km\\symbols\\dll\\ optional\n"
    "?\\km\\symbols\\dll\\*.* optional\n"
    "?\\km\\symbols\\sys\\ optional\n"
    "?\\km\\symbols\\sys\\*.* optional\n"
    "?\\km\\system32\\ optional\n"
    "?\\km\\system32\\*.* optional\n"
    "?\\km\\system32\\drivers\\ optional\n"
    "?\\km\\system32\\drivers\\*.* optional\n"
    "?\\mstools\\ optional\n"
    "?\\mstools\\*.* optional\n"
    "?\\nws\\ optional\n"
    "?\\nws\\*.* optional\n"
    "?\\symbols\\*.* optional\n"
    "?\\symbols\\acm\\*.* optional\n"
    "?\\symbols\\com\\*.* optional\n"
    "?\\symbols\\cpl\\*.* optional\n"
    "?\\symbols\\dll\\*.* optional\n"
    "?\\symbols\\drv\\*.* optional\n"
    "?\\symbols\\exe\\*.* optional\n"
    "?\\symbols\\scr\\*.* optional\n"
    "?\\symbols\\sys\\*.* optional\n"
    "?\\system\\*.*\n"
    "?\\system32\\*.*\n"
    "?\\system32\\config\\*.*\n"
    "?\\system32\\dhcp\\*.* optional\n"
    "?\\system32\\drivers\\*.*\n"
    "?\\system32\\drivers\\etc\\*.*\n"
#ifdef i386
    "?\\system32\\os2\\ optional\n"
    "?\\system32\\os2\\dll\\ optional\n"
    "?\\system32\\os2\\dll\\*.* optional\n"
#endif
    "?\\system32\\ras\\*.* optional\n"
    "?\\system32\\spool\\ optional\n"
    "?\\system32\\spool\\drivers\\ optional\n"
    "?\\system32\\spool\\prtprocs\\ optional\n"
#ifdef MIPS
    "?\\system32\\spool\\prtprocs\\w32mips\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32mips\\*.dll optional\n"
#endif
#ifdef _ALPHA_
    "?\\system32\\spool\\prtprocs\\w32alpha\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32alpha\\*.dll optional\n"
#endif
#ifdef i386
    "?\\system32\\spool\\prtprocs\\w32x86\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32x86\\*.dll optional\n"
#endif
#ifdef PPC
    "?\\system32\\spool\\prtprocs\\w32ppc\\ optional\n"
    "?\\system32\\spool\\prtprocs\\w32ppc\\*.dll optional\n"
#endif
    "?\\system32\\wins\\*.* optional\n"
    "?\\ui\\ optional\n"
    "?\\ui\\*.* optional\n"
    "?\\ui\\dump\\ optional\n"
    "?\\ui\\dump\\*.* optional\n"
    "?\\ui\\symbols\\ optional\n"
    "?\\ui\\symbols\\cpl\\ optional\n"
    "?\\ui\\symbols\\cpl\\*.* optional\n"
    "?\\ui\\symbols\\dll\\ optional\n"
    "?\\ui\\symbols\\dll\\*.* optional\n"
    "?\\ui\\symbols\\exe\\ optional\n"
    "?\\ui\\symbols\\exe\\*.* optional\n"
    "?\\ui\\system32\\ optional\n"
    "?\\ui\\system32\\*.* optional\n"
#ifdef i386
    "?\\wdl\\ optional\n"
    "?\\wdl\\video\\ optional\n"
    "?\\wdl\\video\\avga\\ optional\n"
    "?\\wdl\\video\\avga\\*.* optional\n"
#endif
    "#directory end\n"
    "";

VOID
CdCheck()
{
#if 0

    LPSTR line=NULL;
    LPSTR psz;
    CHAR partialname[256];
    CHAR fullname[256];
    char flatname[256];
    DWORD ChkFileSum,ChkFileSize;
    LPSTR FilePart;
    DWORD ActualSize, ActualSum;
    FILE *pf = NULL;

    //
    // We are checking the CD. Read the entire checkfile
    // and cross check each entry against contents of the
    // CD
    //

    line = pszCheck;
    for ( line = pszCheck; line != NULL ; line = strchr(line, '\n')) {
        if (line >= pszCheck + cbCheck - 1) {
            line = pszCheck;
            }
        if (*line == '\n') {
            line++;
            }
        if (*line == '\0') {
            break;
            }
        if (*line == '\n') {
            continue;                   // skip used entries & empty lines
            }
        psz = line;
        while (*psz == ' ' || *psz == '\t') {
            psz++;                      // skip leading whitespace
            }
        if (*psz == '\n') {
            continue;                   // skip empty line
            }

        //
        // psz points to name sum size
        //

        sscanf(psz,"%s %x %x",partialname,&ChkFileSum,&ChkFileSize);
        GetFullPathName(partialname,sizeof(fullname),fullname,&FilePart);

        strcpy(flatname,RootOfTree);
        strcat(flatname,"\\");
        strcat(flatname,FilePart);

        pf = fopen(flatname, "rb");
        if (pf == NULL) {
            strcpy(flatname,RootOfTree);
            strcpy(flatname+2,"\\mstools\\bin");
            strcat(flatname,RootOfTree+2);
            strcat(flatname,"\\");
            strcat(flatname,FilePart);

            pf = fopen(flatname, "rb");
            if (pf == NULL) {
                if ( strstr(partialname,"idw\\") ) {
                    goto nextone;
                    }
                if ( strstr(partialname,"dump\\") ) {
                    goto nextone;
                    }
                crerror("Cannot open file(%d): %s", errno, FilePart);
                goto nextone;
                }
            }
        ActualSize = _filelength(_fileno(pf));
        if (ActualSize == 0xffffffff) {
            crerror("Cannot determine size of file: %s %d", FilePart, errno);
            fclose(pf);
            goto nextone;
            }
        if (ActualSize != ChkFileSize) {
            crerror("Size differs (actual %lx, expected %lx): %s",
                    ActualSize,
                    ChkFileSize,
                    FilePart);
            fclose(pf);
            goto nextone;
            }
//        ActualSum = CheckSumFile(pf, flatname, flatname, &ActualSize);

        if (ActualSum != ChkFileSum) {
            crerror("Sum differs (actual %lx, expected %lx): %s",
                    ActualSum,
                    ChkFileSum,
                    FilePart);
            }
nextone:;
        }
#endif /* 0 */
}

INT __cdecl
main(
    INT argc,
    LPSTR argv[]
    )

{

    UINT rc;

    pfLog = stderr;

    //
    // Initialize check file entry root list entry.
    //

    CheckEntryRoot.Next = NULL;
    argv = ProcessParameters(&argc, argv);
    if (fCommand) {
        pfCheck = stdout;
        rc = 0;
        while (argc > 1) {
            argc--;
            argv++;
            _strlwr(*argv);
            if (!ProcessEntry(*argv, *argv)) {
                rc++;
            }
        }

    } else {
        long l;
        time_t t = time(NULL);
        INT cfiles;

        // If we are generating a check file, then generate it.
        // Otherwise just check the release.

        rc = ProcessCheckFile(&cfiles);

        l = (long)(time(NULL) - t);
        printf("\n%3u files: %lu:%02lu\n", cfiles, l/60, l % 60);
    }

    exit(rc);
    return rc;
}


LPSTR pszUsage =
    "usage: checkrel [-?] display this message\n"
    "                [-a] process all files\n"
    "                [-c] command line contains file names to sum\n"
    "                [-f chkfile] input/output check file override\n"
    "                [-g] generate check file\n"
    "                [-l logfile] stderr log file\n"
    "                [-n] suppress check file arguments\n"
    "                [-r pathname] root path override\n"
    "                [-R] recursive file check\n"
    "                [-m] master cdrom check\n"
    "                [-i] don't warn about missing files\n"
    "                [-x] don't warn about extra files\n"
    "";

VOID
Usage(VOID)
{
    fprintf(stderr, pszUsage);
    exit(1);
}


VOID
__cdecl
crerror(
    LPSTR pszfmt,
    ...
    )

{

    va_list argptr;

    va_start(argptr, pszfmt);
    if (fInProgress && pfLog == stderr) {
        printf("\r%*s\r", cbProgress, "");              // clear line
        fflush(stdout);
        fInProgress = FALSE;
    }
    fprintf(pfLog, "CheckRel: ");
    vfprintf(pfLog, pszfmt, argptr);
    fprintf(pfLog, "\n");
}


LPSTR *
ProcessParameters(INT *pargc, LPSTR argv[])
{
    CHAR cswitch, c, *p;

    while (*pargc > 1) {
        --(*pargc);
        p = *++argv;
        if ((cswitch = *p) == '/' || cswitch == '-') {
            while (c = *++p) {
                switch (c) {
                case '?':
                    Usage();

                case 'm': fCdCheck++;            break;
                case 'a': fAll++;                break;
                case 'c': fCommand++;            break;
                case 'g': fGenerateCheck++;      break;
                case 'n': fNoArgs++;             break;
                case 'i': fPrintMissing = FALSE; break;
                case 'x': fPrintExtra   = FALSE; break;
                case 'R': fRecurse++;            break;

                case 'f':
                    if (p[1] == '\0' && --(*pargc)) {
                        ++argv;
                        if (pszCheckFileName == NULL) {
                            pszCheckFileName = *argv;
                            break;
                        }
                        crerror("Check file specified twice: -f %s -f %s",
                                pszCheckFileName,
                                *argv);
                        Usage();
                    }
                    Usage();

                case 'l':
                    if (p[1] == '\0' && --(*pargc)) {
                        ++argv;
                        if (pszLogFileName == NULL) {
                            pfLog = fopen(*argv, "wt");
                            if (pfLog == NULL) {
                                pfLog = stderr;
                                crerror("Cannot open %s (%d)", *argv, errno);
                                exit(2);
                            }
                            pszLogFileName = *argv;
                            break;
                        }
                        crerror("Log file specified twice: -l %s -l %s",
                                pszLogFileName,
                                *argv);
                        Usage();
                    }
                    Usage();

                case 'r':
                    if (p[1] == '\0' && --(*pargc)) {
                        ++argv;
                        RootOfTree = _strdup(*argv);
                        if (RootOfTree == NULL) {
                            crerror("Out of memory for tree root");
                            exit(2);
                        }
                        break;
                    }

                    Usage();

                default:
                    crerror("Invalid switch: -%c", c);
                    Usage();
                }
            }
        } else if (fCommand) {
            (*pargc)++;
            argv--;
            break;
        } else {
            crerror("Extra argument: %s", p);
            Usage();
        }
    }

    if (fCommand || fRecurse) {
        fGenerateCheck = TRUE;
        fAll = TRUE;
    }

    return(argv);
}


LPSTR
ProcessArgBuf(LPSTR pszargs)
{
    UINT i;
    INT argc;
    LPSTR pb;
    LPSTR psz;
    LPSTR *ppsz;
    LPSTR argv[20];
    CHAR achbuf[512];

    ppsz = argv;
    *ppsz++ = "Check File";
    psz = achbuf;
    if ((pb = strchr(pszargs, '\n')) != NULL) {
        pb++;
        while (*pszargs == ' ' || *pszargs == '\t') {
            pszargs++;                  // skip leading white space
        }
        if (*pszargs == '-') {
            for (;;) {
                i = strcspn(pszargs, " \t\n");
                *ppsz++ = psz;
                if (ppsz - argv + 1 >= sizeof(argv)/sizeof(argv[0])) {
                    crerror("Too many file args (%d)", ppsz - argv);
                    exit(2);
                }
                if (psz - achbuf + i + 2 >= sizeof(achbuf)) {
                    crerror("Too many file arg chars (%d)", sizeof(achbuf));
                    exit(2);
                }
                strncpy(psz, pszargs, i);
                psz += i;
                *psz++ = '\0';
                if (pszargs[i] == '\n') {
                    break;
                }
                pszargs += i + 1;
                while (*pszargs == ' ' || *pszargs == '\t') {
                    pszargs++;                  // skip leading white space
                }
            }
            *ppsz = NULL;
            argc = (INT)(ppsz - argv);
            if (!fNoArgs) {
                if (fGenerateCheck) {
                    printf("Check file arguments:");
                    for (ppsz = &argv[1]; *ppsz != NULL; ppsz++) {
                        printf(" %s", *ppsz);
                    }
                    printf("\n");
                }
                ProcessParameters(&argc, argv);
            }
        } else {
            pb = NULL;
        }
    }
    return(pb);
}


UINT
ProcessCheckFile(
    LPINT pcfiles
    )

{

    HANDLE hFind;
    DWORD FindSize;
    UINT cbFindPattern;
    LPSTR FindPattern;
    LPSTR pszRelPath;
    LPSTR pszFile;
    struct checkpath_s *pcp;
    struct component_s *pcm;
    CHAR FindName[MAX_PATH];
    INT i;

    *pcfiles = 0;
    if (!OpenCheckFile()) {
        return(1);
    }

    cbFindPattern = MAX_PATH + strlen(".") + 1;
    FindPattern = malloc(cbFindPattern + 1);
    if (FindPattern == NULL) {
        crerror("Process: memory allocation (%d bytes) failed",
                cbFindPattern + 1);
        return(1);
    }

    //
    // Set address of relative path.
    //

    pszRelPath = &FindPattern[strlen(".") + 1];
    i = 0;
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        i = (i & ~31) + 32;

        //
        // Build the initial find pattern.
        //

        sprintf(FindPattern,
                "%s\\%s%s",
                ".",
                pcp->achDir,
                *pcp->achDir ? "\\" : "");

        CHECKSTRLEN(FindPattern, cbFindPattern);

        //
        // Point past directory in find pattern.
        //

        pszFile = &FindPattern[strlen(FindPattern)];
        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            i++;
            if (pcm->fDir) {
                continue;                       // process only file patterns
            }

            if (!fAll && *pcm->achPat == '\0') {
                continue;               // skip entry if no search pattern
            }

            // Complete FindPattern: "c:\nt\system32\*.exe"

            if (fAll)
                strcpy(pszFile, "*.*");

            else if (pcm->achPat)
                strcpy(pszFile, pcm->achPat);

            else
                *pcm->achPat = '\0';

            CHECKSTRLEN(FindPattern, cbFindPattern);

            hFind = PortFindFirstFile(FindPattern, TRUE, FindName, &FindSize);

            if (hFind == INVALID_HANDLE_VALUE) {
                if (pcm->fRequired) {
                    crerror("Missing files: %s", pszRelPath);
                }

            } else {
                do {

                    // append file name to FindPattern: "c:\nt\driver\foo.sys"

                    _strlwr(FindName);
                    strcpy(pszFile, FindName);
                    CHECKSTRLEN(FindPattern, cbFindPattern);
                    if (fAll && strcmp(FindPattern, pszCheckFileName) == 0) {
                        continue;
                    }

                    *pcfiles += 1;
                    if (!ProcessEntry(FindPattern,
                                      pszRelPath)) {
                        crerror("ProcessEntry failed");
                        return(1);
                    }
                } while (PortFindNextFile(hFind, TRUE, FindName, &FindSize));
                PortFindClose(hFind);
            }

            // if ignoring the supplied extensions, skip redundant patterns

            if (fAll) {
                break;
            }
        }

        strcpy(pszFile, "*.*");         // search for all directories

        CHECKSTRLEN(FindPattern, cbFindPattern);

        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            if (pcm->fDir) {                    // process only directories
                pcm->fFound = FALSE;
            }
        }

        hFind = PortFindFirstFile(FindPattern, FALSE, FindName, &FindSize);
        *pszFile = '\0';

        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (strcmp(FindName, ".") == 0 ||
                    strcmp(FindName, "..") == 0) {
                    continue;
                }
                _strlwr(FindName);
                for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
                    if (pcm->fDir && strcmp(FindName, pcm->achPat) == 0) {
                        pcm->fFound = TRUE;
                        break;
                    }
                }

                if (pcm == NULL && fPrintExtra) {
                    crerror("Extra directory: %s%s", pszRelPath, FindName);
                }

            } while (PortFindNextFile(hFind, FALSE, FindName, &FindSize));
            PortFindClose(hFind);
        }

        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            if (pcm->fDir && !pcm->fFound && fPrintMissing) {
                crerror("Missing directory: %s%s", pszRelPath, pcm->achPat);
            }
        }
    }

    if (!fGenerateCheck && MissingEntries()) {
        return(1);
    }

    if (fInProgress) {
        printf("\n");
        fInProgress = FALSE;
    }

    return(0);
}


BOOL
OpenCheckFile(
    VOID
    )

{

    UINT cbCheckName;

    // If the check file name wasn't given, then construct it.

    if (pszCheckFileName == NULL) {
        cbCheckName = strlen(".") + 1 + strlen(CHECK_NAME);
        pszCheckFileName = malloc(cbCheckName + 1);
        if (pszCheckFileName == NULL) {
            crerror("Open: Out of memory (%d bytes)", cbCheckName + 1);
            exit(2);
        }
        sprintf(pszCheckFileName, "%s\\%s", ".", CHECK_NAME);
    }

    if (fRecurse) {
        RecursiveCheckHeader();

    } else if (fGenerateCheck) {
       ReadCheckHeader(NULL);
    }

    pfCheck = fopen(pszCheckFileName, fGenerateCheck||fRecurse? "wt" : "rt");

    if (pfCheck == NULL) {
        crerror("Cannot open %s (%d)", pszCheckFileName, errno);
        return(FALSE);
    }
    if (fGenerateCheck) {
        WriteCheckHeader(pfCheck);

    } else {
        ReadCheckHeader(pfCheck);
        if (fCdCheck) {
            CdCheck();
            return FALSE;
            }
    }

    return(TRUE);
}


VOID
ReadCheckHeader(
    FILE *pf
    )

{
    DWORD cb;
    UINT cbread, cbactual;
    LPSTR pb;

    if (pf == NULL) {
        cbCheck = strlen(pszDefaultDir) + 1;
        pszCheck = pszDefaultDir;

    } else {
        cbCheck = _filelength(_fileno(pfCheck)) + 1;
        if ((DWORD) (size_t) cbCheck != cbCheck) {
            crerror("Open: check file too large (%ld bytes)", cbCheck);
            exit(2);
        }

        pszCheck = malloc((size_t) cbCheck);
        if (pszCheck == NULL) {
            crerror("Open: memory allocation (%ld bytes) failed", cbCheck);
            exit(2);
        }

        pb = pszCheck;
        cb = cbCheck - 1;
        while (cb) {
            cbread = (cb >= READ_BUFFER_SIZE)? READ_BUFFER_SIZE : (UINT) cb;
            cbactual = fread(pb, 1, cbread, pfCheck);
            if (cbread > cbactual) {
                cb -= cbread - cbactual;
                cbCheck -= cbread - cbactual;
            }
            pb += cbactual;
            cb -= cbactual;
        }
        *pb = '\0';
    }

    while ((pb = iscomment(pszCheck)) != NULL ||
           (pb = ProcessArgBuf(pszCheck)) != NULL) {
        pszCheck = pb;                          // skip comment or parm line
    }

    if ((pb = ReadDirectory(pszCheck)) != NULL) {
        pszCheck = pb;                          // skip directory lines

    } else if (ReadDirectory(pszDefaultDir) == NULL) {
        crerror("Bad internal data structure directory format");
        exit(1);
    }

}


LPSTR
ReadDirectory(
    LPSTR pszdir
    )

{
    LPSTR pb;

    if ((pb = ismatch(pszdir, "#directorystart")) == NULL) {
        return(NULL);
    }

    pszdir = pb;                                // skip "start" line

    while ((pb = ismatch(pszdir, "#directoryend")) == NULL) {
        if ((pb = iscomment(pszdir)) == NULL &&
            (pb = AddDirectory(pszdir)) == NULL) {
            return(NULL);
        }

        pszdir = pb;
    }

    return(pb);
}


LPSTR
iscomment(
    LPSTR psz
    )

{

    while (*psz == ' ' || *psz == '\t') {
        psz++;
    }
    if (*psz == '\n' || *psz == '/' && psz[1] == '/') {
        psz += strcspn(psz, "\n");
        if (*psz == '\n') {
            psz++;
        }
        return(psz);                    // return start of next line
    }
    return(NULL);                       // not a comment
}


LPSTR
ismatch(
    LPSTR psz,
    LPSTR pszcompact
    )

{
    while (*psz) {
        if (*psz == ' ' || *psz == '\t') {
            psz++;
            continue;
        }
        if (*psz != *pszcompact) {
            break;
        }
        psz++;
        pszcompact++;
    }
    if (*psz != '\n' || *pszcompact != '\0') {
        return(NULL);
    }
    return(psz + 1);
}


LPSTR
AddDirectory(
    LPSTR psz
    )

{

    LPSTR pb;
    BOOL frequired;
    INT i, ch;

    if ((pb = strchr(psz, '\n')) == NULL) {
        crerror("Directory data error");
        return(NULL);
    }

    while (*psz == ' ' || *psz == '\t') {
        psz++;
    }

    frequired = TRUE;
    i = strcspn(psz, " \t\n");
    ch = psz[i];
    psz[i] = '\0';
    if (ch != '\n') {
        frequired = !ismatch(psz + i + 1, "optional");
    }

    if (!AddEntry(psz, frequired)) {
        psz[i] = (char)ch;
        return(NULL);
    }

    return(pb + 1);
}


BOOL
AddEntry(LPSTR psz,
         BOOL frequired
         )

{

    BOOL f, fdir, freq1;
    INT i;
    CHAR chsep;
    CHAR achdir[MAX_PATH];
    CHAR FullPath[MAX_PATH];

    //
    // If the leading character is ?, then prepend the name of the NT tree
    // to the directory name.
    //

    if (*psz == '?') {
        strcpy(&FullPath[0], RootOfTree);
        strcat(&FullPath[0], psz + 1);
        psz = &FullPath[0];
    }

    achdir[0] = '\0';
    do {
        i = strcspn(psz, "\\");
        chsep = psz[i];
        psz[i] = '\0';
        fdir = freq1 = TRUE;
        if (chsep == '\0' || psz[i + 1] == '\0') {
            if (chsep == '\0') {
                fdir = FALSE;                   // at end & no trailing pathsep
            }
            freq1 = frequired;                  // at end.
        }
        f = AddComponent(achdir, psz, fdir, freq1);
        if (achdir[0] != '\0') {
            strcat(achdir, "\\");
        }
        strcat(achdir, psz);
        psz[i] = chsep;
        if (!f) {
            return(FALSE);
        }
        psz += i + 1;
    } while(chsep != '\0' && *psz != '\0');
    return(TRUE);
}


//struct component_s {
//    struct component_s *pcmNext;      // next in linked list
//    BOOL              fDir;           // TRUE if directory
//    BOOL              fRequired;      // TRUE if must exist
//    CHAR              achPat[1];      // path component (subdir or pattern)
//};
//
//struct checkpath_s {
//    struct checkpath_s *pcpNext;      // next in linked list
//    struct component_s *pcmPat;       // subdirectories and file patterns
//    CHAR              achDir[1];      // root relative directory path
//};

BOOL
AddComponent(
    LPSTR pszdir,
    LPSTR pszpat,
    BOOL fdir,
    BOOL frequired
    )

{
    struct checkpath_s *pcp;
    struct checkpath_s *pcplast;
    struct component_s *pcm;
    struct component_s *pcmlast;
    INT r;
    INT t = 0;

    pcplast = NULL;
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        pcplast = pcp;
        if ((r = strcmp(pszdir, pcp->achDir)) <= 0) {
            break;
        }
    }
    if (pcp == NULL || r) {
        pcp = malloc(sizeof(*pcp) + strlen(pszdir));
        if (pcp == NULL) {
            crerror("AddComponent: out of memory");
            exit(2);
        }
        if (pcplast == NULL) {
            t |= 1;
            pcp->pcpNext = NULL;
            pcpPaths = pcp;
        } else {
            t |= 2;
            pcp->pcpNext = pcplast->pcpNext;
            pcplast->pcpNext = pcp;
        }
        pcp->pcmPat = NULL;
        strcpy(pcp->achDir, pszdir);
    }

    pcmlast = NULL;
    if (pszpat != NULL) {
        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            pcmlast = pcm;
            if ((r = strcmp(pszpat, pcm->achPat)) <= 0) {
                break;
            }
        }
    }

    if (pcm == NULL || r) {
        if (pszpat != NULL)
            pcm = malloc(sizeof(*pcm) + strlen(pszpat));
        else
            pcm = malloc(sizeof(*pcm));
        if (pcm == NULL) {
            crerror("AddComponent: out of memory");
            exit(2);
        }
        if (pcmlast == NULL) {
            t |= 4;
            pcm->pcmNext = NULL;
            pcp->pcmPat = pcm;
        } else {
            t |= 8;
            pcm->pcmNext = pcmlast->pcmNext;
            pcmlast->pcmNext = pcm;
        }
        pcm->fDir = fdir;
        pcm->fFound = FALSE;
        pcm->fRequired = frequired;
        if (pszpat == NULL)
            *pcm->achPat = '\000';
        else
            strcpy(pcm->achPat, pszpat);
    }
    if (!frequired) {
        pcm->fRequired = frequired;
    }
    return(TRUE);
}


VOID
WriteCheckHeader(FILE *pf)
{
    struct checkpath_s *pcp;
    struct component_s *pcm;
    INT ccol;
    CHAR achpath[MAX_PATH];
    CHAR *psz;
    CHAR SavedChar;

    if (fAll) {
        fprintf(pf,
                "-%s\n\n",
                fAll?    "a" : "");
    }
    fprintf(pf, "#directory start\n");
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
            sprintf(achpath,
                    "%s%s%s%s",
                    pcp->achDir,
                    *pcp->achDir? "\\" : "",
                    pcm->achPat,
                    pcm->fDir? "\\" : "");

            psz = strchr(achpath, '\\');
            if (psz == NULL) {
                fprintf(pf, achpath);

            } else {
                psz -= 1;
                SavedChar = *psz;
                *psz = '?';
                fprintf(pf, psz);
                *psz = SavedChar;
            }

            if (!pcm->fRequired) {
                ccol = strlen(achpath);
                fprintf(pf, " optional");
            }
            fprintf(pf, "\n");
        }
    }
    fprintf(pf, "#directory end\n\n");
}


BOOL
ProcessEntry(
    LPSTR pszFullPath,
    LPSTR pszRelPath
    )

{

    ULONG CheckSum;
    ULONG HeaderSum;
    ULONG FileSum;
    FILE *pf = NULL;
    UINT cbLine;
    CHAR *psz;
    ULONG Status;

    if (!fGenerateCheck) {
        if (!FindEntry(pszRelPath, &FileSum)) {
            if (fPrintExtra) {
                crerror("Extra file: %s", pszRelPath);
            }
            return TRUE;
        }
    }

    //
    // Compute checksum of file.
    //

    Status = MapFileAndCheckSum(pszFullPath, &HeaderSum, &CheckSum);
    if (Status != CHECKSUM_SUCCESS) {
        crerror("Cannot open or map file %s", pszFullPath);
        return TRUE;
    }

    if (fGenerateCheck) {
        cbLine = sprintf(OutputLine,
                         "%s %lx\n",
                         pszRelPath,
                         CheckSum);

        CHECKSTRLEN(OutputLine, sizeof(OutputLine));

        psz = strchr(OutputLine, '\\');
        if (fCommand || psz == NULL) {
            fwrite(OutputLine, 1, cbLine, pfCheck);

        } else {
            psz -= 1;
            *psz = '?';
            fwrite(psz, 1, (size_t)(cbLine - (psz - OutputLine)), pfCheck);
        }
    }

    if (!fGenerateCheck) {
        if (CheckSum != FileSum) {
            crerror("Sum differs (actual %lx, expected %lx): %s",
                    CheckSum,
                    FileSum,
                    pszRelPath);
        }
    }
    return TRUE;
}


BOOL
FindEntry(
    LPSTR pszRelPath,
    PULONG FileSum
    )

{

    PCHECK_FILE_ENTRY LastEntry;
    WORD Length;
    PCHECK_FILE_ENTRY NextEntry;

    //
    // If this is the first trip through this code, then reset to the
    // beginning of the check file.
    //

    if (CheckEntryRoot.Next == NULL) {
        if (ParseCheckFile() == 0) {
            return FALSE;
        }
    }

    //
    // Compute the length of the specified file name and loop through
    // check file list for a matching entry.
    //

    Length = (WORD)strlen(pszRelPath);
    LastEntry = &CheckEntryRoot;
    NextEntry = LastEntry->Next;
    do {

        //
        // If the length and the file name match, then remove the entry from
        // the list and return the file size and check sum value.
        //

        if (NextEntry->Length == Length) {
            if (strncmp(pszRelPath, NextEntry->Name, Length) == 0) {
                LastEntry->Next = NextEntry->Next;
                *FileSum = NextEntry->Sum;
                return TRUE;
            }
        }

        LastEntry = NextEntry;
        NextEntry = NextEntry->Next;
    } while (NextEntry != NULL);

    //
    // The specified file is not in the check file.
    //

    return FALSE;
}

DWORD
MissingEntries(
    VOID
    )

{

    DWORD Count = 0;
    PCHECK_FILE_ENTRY NextEntry;

    //
    // Scan through the check file list and display an error message for
    // each missing file.
    //

    if (fPrintMissing) {
        NextEntry = CheckEntryRoot.Next;
        while (NextEntry != NULL) {
            crerror("Missing file: %s", NextEntry->Name);
            Count += 1;
            NextEntry = NextEntry->Next;
        }
    }

    return Count;
}


DWORD
ParseCheckFile(
    VOID
    )

{

    DWORD Count = 0;
    LPSTR pszline;
    LPSTR psz;
    PCHECK_FILE_ENTRY LastEntry;
    WORD Length;
    PCHECK_FILE_ENTRY NextEntry;
    WORD SizeOfRoot;
    DWORD Sum;

    //
    // If the check file contains no entries, then return.
    //

    if (*pszCheck != '\n') {
        return Count;
    }

    //
    // Scan through the check file and parse each file name, checksum, and
    // size field.
    //

    SizeOfRoot = (WORD)strlen(RootOfTree);
    LastEntry = &CheckEntryRoot;
    for (pszline = pszCheck; pszline != NULL; pszline = strchr(pszline, '\n')) {

        //
        // Skip over the new line and search for the blank separator between
        // the file name and the checksum.
        //

        pszline += 1;
        psz = strchr(pszline, ' ');

        //
        // If there is no blank separator, then the end of the check file has
        // been reached.
        //

        if (psz == NULL) {
            return Count;
        }

        //
        // Compute the length and checksum of the file entry.
        //

        Length = (short)(psz - pszline);
        psz = atolx(psz + 1, &Sum);

        //
        // Allocate a check file entry for the specified file and insert it
        // at the end of the check file entry list.
        //

        Count += 1;
        if (Count > CHECK_ENTRY_TABLE_SIZE) {
           crerror("Checkrel: Check Entry Table Overflow");
           return 0;
        }

        NextEntry = &CheckEntryTable[Count - 1];
        NextEntry->Next = NULL;
        NextEntry->Sum = Sum;

        //
        // Form the file name from the NT root name and the specified path.
        //

        pszline[Length] = '\0';
        if (*pszline == '?') {
            pszline += 1;
            NextEntry->Name = (CHAR *)malloc(SizeOfRoot + Length);
            if (NextEntry->Name == NULL) {
                crerror("Checkrel: failure to allocate check file entry");
                return Count;
            }

            strcpy(NextEntry->Name, RootOfTree);
            strcat(NextEntry->Name, pszline);
            Length += SizeOfRoot - 1;

        } else {
            NextEntry->Name = pszline;
        }

        NextEntry->Length = Length;
        LastEntry->Next = NextEntry;
        LastEntry = NextEntry;
        pszline = psz;
    }

    return Count;
}

LPSTR
atolx(
    LPSTR psz,
    LPDWORD pul)

{

    DWORD ul;
    char ch;

    ul = 0;
    while (isxdigit(*psz)) {
        ch = *psz++;
        if (isdigit(ch)) {
            ch += 0 - '0';

        } else if (islower(ch)) {
            ch += 10 - 'a';

        } else {
            ch += 10 - 'A';
        }

        ul = (ul << 4) + ch;
    }

    *pul = ul;
    return(psz);
}


VOID
RecursiveCheckHeader()
{
    HANDLE hFind;
    DWORD FindSize;
    UINT cbFindPattern;
    LPSTR FindPattern;
    LPSTR pszRelPath;
    LPSTR pszFile;
    struct checkpath_s *pcp;
    struct component_s *pcm;
    CHAR FindName[MAX_PATH];
    INT i;

    cbFindPattern = strlen(".") + MAX_PATH;
    FindPattern = malloc(cbFindPattern + 1);
    if (FindPattern == NULL) {
        crerror("Process: memory allocation (%d bytes) failed",
                cbFindPattern + 1);
        return;
    }

    // Set relative path pointer into FindPattern: "driver\elnkii.sys"

    pszRelPath = &FindPattern[strlen(RootOfTree) + 1];
    AddComponent(".", NULL, TRUE, TRUE);

    i = 0;
    for (pcp = pcpPaths; pcp != NULL; pcp = pcp->pcpNext) {
        i = (i & ~31) + 32;

        // Build Initial FindPattern directory path: "c:\nt\"

        sprintf(FindPattern,
                "%s\\%s%s",
                ".",
                pcp->achDir,
                *pcp->achDir? "\\" : "");

        CHECKSTRLEN(FindPattern, cbFindPattern);

        // point past directory in FindPattern: "c:\nt\system32\"

        pszFile = &FindPattern[strlen(FindPattern)];

        strcpy(pszFile, "*.*");         // search for all directories
        CHECKSTRLEN(FindPattern, cbFindPattern);
        hFind = PortFindFirstFile(FindPattern, FALSE, FindName, &FindSize);
        *pszFile = '\0';

        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (strcmp(FindName, ".") == 0 ||
                    strcmp(FindName, "..") == 0) {
                    continue;
                }
                _strlwr(FindName);
                for (pcm = pcp->pcmPat; pcm != NULL; pcm = pcm->pcmNext) {
                    if (pcm->fDir && strcmp(FindName, pcm->achPat) == 0) {
                        pcm->fFound = TRUE;
                        break;
                    }
                }
                if (pcm == NULL) {
                    AddComponent(FindName, NULL, TRUE, TRUE);
                }
            } while (PortFindNextFile(hFind, FALSE, FindName, &FindSize));
            PortFindClose(hFind);
        }
    }
    if (fInProgress) {
        printf("\n");
        fInProgress = FALSE;
    }
    return;
}


#define ATTRMATCH(fnormal, attr) \
    (!fNormal ^ ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))

HANDLE
PortFindFirstFile(LPSTR FindPattern,
                  BOOL fNormal,
                  LPSTR FindName,
                  LPDWORD FindSize)
{
    HANDLE hFind;
    WIN32_FIND_DATA wfd;

    hFind = FindFirstFile(FindPattern, &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        if (!ATTRMATCH(fNormal, wfd.dwFileAttributes)) {
            if (!PortFindNextFile(hFind,
                                  fNormal,
                                  FindName,
                                  FindSize)) {
                FindClose(hFind);
                return(INVALID_HANDLE_VALUE);
            }
        } else {
            strcpy(FindName, wfd.cFileName);
            *FindSize = wfd.nFileSizeLow;
        }
    }
    return(hFind);
}


BOOL
PortFindNextFile(HANDLE hFind,
                 BOOL fNormal,
                 LPSTR FindName,
                 LPDWORD FindSize)
{
    BOOL b;
    WIN32_FIND_DATA wfd;

    do {
        b = FindNextFile(hFind, &wfd);
    } while (b && !ATTRMATCH(fNormal, wfd.dwFileAttributes));
    if (b) {
        strcpy(FindName, wfd.cFileName);
        *FindSize = wfd.nFileSizeLow;
    }
    return(b);
}


VOID
PortFindClose(HANDLE hFind)
{
    FindClose(hFind);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checkrel\newcheck.c ===
#ifndef COMPILED_FORDOS
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
#include <dos.h>
#include <stdio.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <malloc.h>
#include <errno.h>
#include <ctype.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <io.h>
#include <conio.h>
#include <sys\types.h>
#include <sys\stat.h>

#ifdef COMPILED_FORDOS
#define MAX_PATH 256
#endif

#define READ_BUFFER_SIZE (8192*sizeof(DWORD))
#define CHECK_NAME "\\chkfile.chk"
extern BOOL fUsage;
extern BOOL fGenerateCheck;
extern LPSTR RootOfTree;
char RootBuffer[MAX_PATH];
extern BOOL fVerbose;
LPSTR CheckFileName;
char OutputLine[512];
DWORD ReadBuffer[READ_BUFFER_SIZE/sizeof(DWORD)];

WORD
CheckSum(
    DWORD ParitialSum,
    LPWORD Source,
    DWORD Length
    );


typedef struct _FINDBUF {
    char reserved[21];
    char attrib;
    unsigned short wr_time;
    unsigned short wr_data;
    long size;
    char name[13];
} FINDBUF, *PFINDBUF;

DWORD
PortFindFirstFile(
    LPSTR FindPattern,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    );
BOOL
PortFindNextFile(
    DWORD FindHandle,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    );

VOID
PortFindClose(
    DWORD FindHandle
    );

VOID
GenerateCheckFile( VOID );

VOID
ValidateCheckFile( VOID );

BOOL
ProcessParameters(
    int argc,
    LPSTR argv[]
    );

FILE *GlobalCheckFile;

FILE *
OpenCheckFile( VOID );

BOOL
ComputeEntry(
    FILE *CheckFile,
    LPSTR FileName,
    DWORD FileLength
    );

DWORD
CheckSumFile(
    FILE *InputHandle,
    LPSTR PathName,
    DWORD FileLength,
    LPSTR FileName
    );

BOOL fGenerateCheck = FALSE;
LPSTR RootOfTree = "C:\\NT";
BOOL fVerbose = FALSE;
BOOL fUsage = FALSE;

#ifndef COMPILED_FORDOS
int ThreadCount;
HANDLE ThreadListMutex;
HANDLE ThreadListSemaphore;
LIST_ENTRY WorkList;

#define ITEM_TYPE_EXIT      1
#define ITEM_TYPE_VALIDATE  2
#define ITEM_TYPE_GENERATE  3

typedef struct _WORK_ITEM {
    LIST_ENTRY ItemLinks;
    DWORD ItemType;
    PVOID Base;
    DWORD FileLength;
    DWORD ActualSum;
    char FileName[MAX_PATH];
} WORK_ITEM, *PWORK_ITEM;


PHANDLE ThreadHandles;
CRITICAL_SECTION GenerateCrit;

VOID
WriteCheckSumEntry(
    FileName,
    Sum,
    FileLength
    )
{
    char lOutputLine[512];
    int LineLength;

    LineLength = sprintf(lOutputLine,"%s %x %x\n",FileName,Sum,FileLength);
    if ( fVerbose ) {
        fprintf(stdout,"Id %d %s",GetCurrentThreadId(),lOutputLine);
        }
    EnterCriticalSection(&GenerateCrit);
    fwrite(lOutputLine,1,LineLength,GlobalCheckFile);
    LeaveCriticalSection(&GenerateCrit);
}


DWORD
WorkerThread(
    LPVOID WhoCares
    )
{
    HANDLE Objects[2];
    PWORK_ITEM Item;
    PLIST_ENTRY Entry;
    int FilesProcessed = 0;

    Objects[0] = ThreadListMutex;
    Objects[1] = ThreadListSemaphore;

    SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL);

    //
    // Wait for and entry on the list, and exclusive ownership of the listhead
    //

    while(TRUE) {
        WaitForMultipleObjects(2,Objects,TRUE,INFINITE);


        Entry = RemoveHeadList(&WorkList);
        Item = (PWORK_ITEM)(CONTAINING_RECORD(Entry,WORK_ITEM,ItemLinks));

        ReleaseMutex(ThreadListMutex);

        switch ( Item->ItemType ) {
            case ITEM_TYPE_VALIDATE :
                FilesProcessed++;
                break;

            case ITEM_TYPE_GENERATE :
                FilesProcessed++;
                    {
                        DWORD Sum;
                        Sum = (DWORD)CheckSum(0,Item->Base,(Item->FileLength+1) >> 1);
                        UnmapViewOfFile(Item->Base);
                        WriteCheckSumEntry(Item->FileName,Sum,Item->FileLength);
                        break;
                    }
                break;

            case ITEM_TYPE_EXIT :
            default:
                fprintf(stdout,"Id %d Processed %d Files\n",GetCurrentThreadId(),FilesProcessed);
                ExitThread(1);

            }
            LocalFree(Item);
        }
    return 0;
}




#endif

INT __cdecl
main( argc, argv )
int argc;
LPSTR argv[];
{

    if (!ProcessParameters( argc, argv )) {
        fUsage = TRUE;
        }

    if (fUsage) {
        fprintf( stderr, "usage: checkrel [-?] display this message\n" );
        fprintf( stderr, "                [-r pathname] supply release root\n" );
        fprintf( stderr, "                [-v] verbose output\n" );
        fprintf( stderr, "                [-g] generate check file\n" );
        fprintf( stderr, "                [-t n] use n threads to process the data\n" );
        }
    else {
        //
        // if we are generating a check file, then generate it,
        // otherwise just check the release
        //

        if ( fGenerateCheck ) {
            GenerateCheckFile();
#ifndef COMPILED_FORDOS
            if ( ThreadCount ) {
                int i;
                PWORK_ITEM Item;
                for(i=0;i<ThreadCount;i++){
                    Item = LocalAlloc(LMEM_ZEROINIT,sizeof(*Item));
                    Item->ItemType = ITEM_TYPE_EXIT;
                    WaitForSingleObject(ThreadListMutex,INFINITE);
                    InsertTailList(&WorkList,&Item->ItemLinks);
                    ReleaseSemaphore(ThreadListSemaphore,1,NULL);
                    ReleaseMutex(ThreadListMutex);
                    }
                WaitForMultipleObjects(ThreadCount,ThreadHandles,TRUE,INFINITE);
                }
#endif

            }
        else {
            ValidateCheckFile();
            }
        }
    return( 0 );
}


BOOL
ProcessParameters(
    int argc,
    LPSTR argv[]
    )
{
    char c, *p;
    BOOL Result;
    char *WhoCares;
    int i;

    Result = TRUE;
    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
            case '?':
                fUsage = TRUE;
                break;

            case 'R': {

                argc--;
                argv++;

                RootOfTree = *argv;
                GetFullPathName(RootOfTree,sizeof(RootBuffer),RootBuffer,&WhoCares);
                RootOfTree = RootBuffer;
                break;
            }

            case 'G':
                fGenerateCheck = TRUE;
                break;

            case 'V':
                fVerbose = TRUE;
                break;

#ifndef COMPILED_FORDOS
            case 'T': {
                DWORD ThreadId;

                argc--;
                argv++;

                ThreadCount = atoi(*argv);
                InitializeListHead(&WorkList);
                ThreadListMutex = CreateMutex(NULL,FALSE,NULL);
                ThreadListSemaphore = CreateSemaphore(NULL,0,0x70000000,NULL);
                InitializeCriticalSection(&GenerateCrit);
                if ( ThreadListMutex && ThreadListSemaphore ) {
                    ThreadHandles = LocalAlloc(LMEM_ZEROINIT,sizeof(HANDLE)*ThreadCount);
                    if ( ThreadHandles ) {
                        for(i=0;i<ThreadCount;i++) {
                            ThreadHandles[i] = CreateThread(
                                                    NULL,
                                                    0,
                                                    WorkerThread,
                                                    NULL,
                                                    0,
                                                    &ThreadId
                                                    );
                            if ( !ThreadHandles[i] ) {
                                ThreadCount = 0;
                                break;
                                }
                            }
                        }
                    else {
                        ThreadCount = 0;
                        }
                    }
                else {
                    ThreadCount = 0;
                    }

                break;
            }
#endif

            default:
                fprintf( stderr, "checkrel: Invalid switch - /%c\n", c );
                Result = FALSE;
                break;
                }
            }
        }
    return( Result );
}

VOID
WalkTree(
    FILE *CheckFile,
    LPSTR SubDir
    )
{
    char NextSubDir[MAX_PATH];
    DWORD FindHandle;
    char FindPattern[MAX_PATH];
    char FindName[MAX_PATH];
    DWORD FindSize;
    BOOL b;
    BOOL IsDir;

    //
    // recursively walk the system searching all files
    //

    //
    // build the find pattern
    //

    strcpy(FindPattern,RootOfTree);
    if ( SubDir ) {
        strcat(FindPattern,"\\");
        strcat(FindPattern,SubDir);
        }
    strcat(FindPattern,"\\*.*");

    if ( fVerbose ) {
        fprintf(stdout,"WalkTree %s \n",FindPattern);
        }

    FindHandle = PortFindFirstFile(FindPattern,FindName,&IsDir,&FindSize);
    if ( FindHandle == -1 ) {
        fprintf(stderr,"checkrel: FindFirst(%s) failed %d\n",FindPattern,errno);
        return;
        }

    b = TRUE;
    while(b) {

        _strlwr(FindName);

        //
        // recurse if we are at a directory
        //

        if ( IsDir ) {

            //
            // if name is . or .., skip to findnext
            //

            if ( !strcmp(FindName,".") || !strcmp(FindName,"..") ) {
                goto findnext;
                }

            //
            // if name is w32x86 or w32mips, skip to findnext
            //

            if ( !strcmp(FindName,"w32mips") || !strcmp(FindName,"w32x86") ) {
                goto findnext;
                }


            NextSubDir[0] = '\0';
            if ( SubDir ) {
                strcat(NextSubDir,SubDir);
                strcat(NextSubDir,"\\");
                }
            strcat(NextSubDir,FindName);
            WalkTree(CheckFile,NextSubDir);
            }
        else {
            NextSubDir[0] = '\0';
            if ( SubDir ) {
                strcat(NextSubDir,SubDir);
                strcat(NextSubDir,"\\");
                }
            strcat(NextSubDir,FindName);
            b = ComputeEntry(CheckFile,NextSubDir,FindSize);
            }

        if ( !b ) {
            fprintf(stderr,"checkrel: ComputeEntry faild\n");
            return;
            }
findnext:
        b = PortFindNextFile(FindHandle,FindName,&IsDir,&FindSize);
        }
    PortFindClose(FindHandle);
}


VOID
GenerateCheckFile( VOID )
{
    FILE *CheckFile;

    CheckFile = OpenCheckFile();
    if ( !CheckFile ) {
        return;
        }

    WalkTree(CheckFile,NULL);
}

VOID
ValidateCheckFile( VOID )
{
    FILE *CheckFile;
    DWORD CheckSize, CheckSum;
    char CheckName[MAX_PATH];
    DWORD n;
    LPSTR PathName;
    FILE *FileHandle;
    DWORD ActualSize;
    DWORD ActualSum;

    CheckFile = OpenCheckFile();
    if ( !CheckFile ) {
        return;
        }


    PathName = malloc(strlen(RootOfTree)+MAX_PATH+1);

    if ( !PathName ) {
        fprintf(stderr,"checkrel: memory allocation for %d bytes failed\n",strlen(RootOfTree)+MAX_PATH+1);
        return;
        }

    n = fscanf(CheckFile,"%s %x %x",CheckName,&CheckSum,&CheckSize);
    while ( n != EOF ) {
        if ( n != 3 ) {
            fprintf(stderr,"checkrel: error in format\n");
            return;
            }

        //
        // Now form the file and do the checksum compare
        //

        strcpy(PathName,RootOfTree);
        strcat(PathName,"\\");
        strcat(PathName,CheckName);

        FileHandle = fopen(PathName,"rb");
        if ( !FileHandle ) {
            fprintf(stderr,"checkrel: failed to open file %s %d\n",PathName,errno);
            }
        else {
            ActualSize = _filelength(_fileno(FileHandle));

            if ( ActualSize == 0xffffffff ) {
                fprintf(stderr,"checkrel: unable to get file size for file %s %d\n",PathName,errno);
                fclose(FileHandle);
                }
            else {
                if ( ActualSize != CheckSize ) {
                    fprintf(stderr,"checkrel: FileSizes Differ for %s Actual %x vs. %x\n",PathName,ActualSize,CheckSize);
                    }
                ActualSum = CheckSumFile(FileHandle,PathName,ActualSize,NULL);
                if ( ActualSum ) {
                    if ( ActualSum != CheckSum ) {
                        fprintf(stderr,"checkrel: CheckSums Differ for %s Actual %x vs. %x\n",PathName,ActualSum,CheckSum);
                        }
                    }
                if ( fVerbose ) {
                    fprintf(stdout,"%s Sum(%x vs %x) Size(%x vs %x)\n",PathName,ActualSum,CheckSum,ActualSize,CheckSize);
                    }
                }
            }
        n = fscanf(CheckFile,"%s %x %x",CheckName,&CheckSum,&CheckSize);
        }
}

FILE *
OpenCheckFile()
{
    FILE *CheckFile;

    GlobalCheckFile = (FILE *)-1;
    CheckFileName = malloc(strlen(RootOfTree)+strlen(CHECK_NAME)+1);
    if ( !CheckFileName ) {
        return (FILE *)-1;
        }

    strcpy(CheckFileName,RootOfTree);
    strcat(CheckFileName,CHECK_NAME);

    if ( fVerbose ) {
        fprintf(stdout,"checkrel: check name %s\n",CheckFileName);
        }

    CheckFile = fopen(CheckFileName,fGenerateCheck ? "wt" : "rt");

    if ( !CheckFile ) {
        fprintf(stderr,"checkrel: open %s failed %d\n",CheckFileName,errno);
        }
    GlobalCheckFile = CheckFile;
    return CheckFile;
}


BOOL
ComputeEntry(
    FILE *CheckFile,
    LPSTR FileName,
    DWORD FileLength
    )
{
    char PathName[MAX_PATH];
    DWORD CheckSum;
    DWORD LineLength;

    strcpy(PathName,RootOfTree);
    strcat(PathName,"\\");
    strcat(PathName,FileName);

    CheckSum = CheckSumFile(NULL,PathName,FileLength,FileName);

    if ( CheckSum ) {
        LineLength = sprintf(OutputLine,"%s %x %x\n",FileName,CheckSum,FileLength);
        if ( fVerbose ) {
            fprintf(stdout,"%s",OutputLine);
            }
        fwrite(OutputLine,1,LineLength,CheckFile);
        }
    return TRUE;
}

DWORD
CheckSumFile(
    FILE *InputHandle,
    LPSTR PathName,
    DWORD FileLength,
    LPSTR FileName
    )

{

    FILE *FileHandle;
    DWORD Sum;
    signed char *pb;
    LPDWORD pul;
    PVOID Base;
    DWORD cbread, cbreadtotal;

    if ( InputHandle ){
        FileHandle = InputHandle;
        }
    else {
        FileHandle = fopen(PathName,"rb");
        if ( !FileHandle ) {
            fprintf(stderr,"checkrel: failed to open file %s %d\n",PathName,errno);
            return 0;
            }

#ifndef COMPILED_FORDOS
        if ( ThreadCount ) {
            PWORK_ITEM Item;
            HANDLE Win32FileHandle;
            HANDLE MappingHandle;

            //
            // Queue the generate request to a worker thread
            //

            Item = LocalAlloc(LMEM_ZEROINIT,sizeof(*Item));

            if (!Item) {
                goto bail;
                }
            Win32FileHandle = (HANDLE)_get_osfhandle(_fileno(FileHandle));
            MappingHandle = CreateFileMapping(
                                Win32FileHandle,
                                NULL,
                                PAGE_READONLY,
                                0,
                                0,
                                NULL
                                );
            if ( !MappingHandle ) {
                fprintf(stderr,"checkrel: failed to map file %s %d\n",PathName,GetLastError());
                fclose(FileHandle);
                return 0;
                }
            Base = MapViewOfFile(
                        MappingHandle,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );
            CloseHandle(MappingHandle);
            if ( !Base ) {
                fprintf(stderr,"checkrel: failed to map view of file %s %d\n",PathName,GetLastError());
                fclose(FileHandle);
                return 0;
                }
            fclose(FileHandle);


            Item->ItemType = ITEM_TYPE_GENERATE;
            Item->Base = Base;
            Item->FileLength = FileLength;
            strcpy(&Item->FileName[0],FileName);
            WaitForSingleObject(ThreadListMutex,INFINITE);
            InsertTailList(&WorkList,&Item->ItemLinks);
            ReleaseSemaphore(ThreadListSemaphore,1,NULL);
            ReleaseMutex(ThreadListMutex);
            return 0;
            }
bail:;
#endif
        }
#ifdef COMPILED_FORDOS
    Base = ReadBuffer;

    //
    // Read the file in large blocks and compute the checksum.
    //

    Sum = 0;
    cbreadtotal = 0;
    while (cbread = fread(ReadBuffer, 1, READ_BUFFER_SIZE, FileHandle)) {
        cbreadtotal += cbread;
        pb = Base;

        //
        // Make sure the last byte of the buffer is zero in case a
        // partial buffer was read with an odd number of bytes in the
        // buffer.
        //

        ((PBYTE)ReadBuffer)[cbread] = 0;

        //
        // Compute the checksum using the same algorithm used for
        // tcp/ip network packets. This is a word checksum with all
        // carries folded back into the sum.
        //

        Sum = (DWORD)CheckSum(Sum, (LPWORD)ReadBuffer, (cbread + 1) >> 1);
        }
#else
    {
        HANDLE Win32FileHandle;
        HANDLE MappingHandle;

        Win32FileHandle = (HANDLE)_get_osfhandle(_fileno(FileHandle));
        MappingHandle = CreateFileMapping(
                            Win32FileHandle,
                            NULL,
                            PAGE_READONLY,
                            0,
                            0,
                            NULL
                            );
        if ( !MappingHandle ) {
            fprintf(stderr,"checkrel: failed to map file %s %d\n",PathName,GetLastError());
            fclose(FileHandle);
            return 0;
            }
        Base = MapViewOfFile(
                    MappingHandle,
                    FILE_MAP_READ,
                    0,
                    0,
                    0
                    );
        CloseHandle(MappingHandle);
        if ( !Base ) {
            fprintf(stderr,"checkrel: failed to map view of file %s %d\n",PathName,GetLastError());
            fclose(FileHandle);
            return 0;
            }
        Sum = (DWORD)CheckSum(0,Base,(FileLength+1) >> 1);
        UnmapViewOfFile(Base);
    }
#endif
    fclose(FileHandle);

    if (Sum == 0) {
        Sum = FileLength;
        }

    return(Sum);
}



#ifndef COMPILED_FORDOS
DWORD
PortFindFirstFile(
    LPSTR FindPattern,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    HANDLE FindHandle;
    WIN32_FIND_DATA FindFileData;

    FindHandle = FindFirstFile(FindPattern,&FindFileData);
    if ( FindHandle != INVALID_HANDLE_VALUE ) {
        strcpy(FindName,FindFileData.cFileName);
        *FindSize = FindFileData.nFileSizeLow;
        *IsDir = FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        }
    return (DWORD)FindHandle;
}


BOOL
PortFindNextFile(
    DWORD FindHandle,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    BOOL b;
    WIN32_FIND_DATA FindFileData;

    b = FindNextFile((HANDLE)FindHandle,&FindFileData);
    if ( b ) {
        strcpy(FindName,FindFileData.cFileName);
        *FindSize = FindFileData.nFileSizeLow;
        *IsDir = FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        }
    return b;
}

VOID
PortFindClose(
    DWORD FindHandle
    )
{
    FindClose((HANDLE)FindHandle);
}
#else
DWORD
PortFindFirstFile(
    LPSTR FindPattern,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    struct find_t *FindHandle;
    int error;

    FindHandle = malloc(sizeof(*FindHandle));

    error = _dos_findfirst(FindPattern,_A_RDONLY | _A_NORMAL | _A_DIR, FindHandle);
    if ( error ) {
    	free(FindHandle);
    	return -1;
    	}
    strcpy(FindName,FindHandle->name);
    *FindSize = FindHandle->size;
    *IsDir = FindHandle->attrib & 0x10;
    return (DWORD)FindHandle;
}


BOOL
PortFindNextFile(
    DWORD FindHandle,
    LPSTR FindName,
    LPBOOL IsDir,
    LPDWORD FindSize
    )
{
    BOOL b;
    int error;
    struct find_t *xxFindHandle;

    xxFindHandle = (struct find_t *)FindHandle;
    error = _dos_findnext( xxFindHandle );
    if ( error ) {
    	return FALSE;
    	}
    strcpy(FindName,xxFindHandle->name);
    *FindSize = xxFindHandle->size;
    *IsDir = FindHandle->attrib & 0x10;
    return TRUE;
}

VOID
PortFindClose(
    DWORD FindHandle
    )
{
    free((int *)FindHandle);
}

WORD
CheckSum(
    DWORD PartialSum,
    LPWORD Source,
    DWORD Length
    )

{

	register unsigned long t = PartialSum;
	register unsigned long r;

	while(Length--) {
		t += *Source++;
   }

	while (r = (t & 0xFFFF0000) {
		t &= 0x0000FFFF;
		t += (r >> 16);
	}

	return t;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\delayload.cpp ===
// DelayLoad.cpp: implementation of the CDelayLoad class.
//
//////////////////////////////////////////////////////////////////////

#include "DelayLoad.h"
#include "UtilityFunctions.h"
#include "stdlib.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDelayLoad::CDelayLoad()
{
	// DBGHELP
	m_hDBGHELP = NULL;
	m_fDBGHELPInitialized = false;
	m_fDBGHELPInitializedAttempted = false;
	m_lpfMakeSureDirectoryPathExists = NULL;

	// PSAPI
	m_hPSAPI = NULL;
	m_fPSAPIInitialized = false;
	m_fPSAPIInitializedAttempted = false;
	m_lpfEnumProcesses = NULL;
	m_lpfEnumProcessModules = NULL;
	m_lpfGetModuleFileNameEx = NULL;
	m_lpfEnumDeviceDrivers = NULL;
	m_lpfGetDeviceDriverFileName = NULL;

	// TOOLHELP32
	m_hTOOLHELP32 = NULL;
	m_fTOOLHELP32Initialized = false;
	m_fTOOLHELP32InitializedAttempted = false;
	m_lpfCreateToolhelp32Snapshot = NULL;
	m_lpfProcess32First = NULL;
	m_lpfProcess32Next = NULL;
	m_lpfModule32First = NULL;
	m_lpfModule32Next = NULL;

	// SYMSRV
	m_hSYMSRV = NULL;
	m_fSYMSRVInitialized = false;
	m_fSYMSRVInitializedAttempted = false;
	m_tszSymSrvDLL = NULL;
	m_lpfSymbolServer = NULL;
	m_lpfSymbolServerClose = NULL;
}

CDelayLoad::~CDelayLoad()
{
	if (m_hDBGHELP)
		FreeLibrary(m_hDBGHELP);

	if (m_hPSAPI)
		FreeLibrary(m_hPSAPI);

	if (m_hTOOLHELP32)
		FreeLibrary(m_hTOOLHELP32);

	if (m_hSYMSRV)
		FreeLibrary(m_hSYMSRV);

	if (m_tszSymSrvDLL)
	{
		delete [] m_tszSymSrvDLL;
	}
}

bool CDelayLoad::Initialize_DBGHELP()
{
	m_fDBGHELPInitialized = false;
	m_fDBGHELPInitializedAttempted = true;

	// Load library on DBGHELP.DLL and get the procedures explicitly.
	m_hDBGHELP = LoadLibrary( TEXT("DBGHELP.DLL") );

	if( m_hDBGHELP == NULL )
	{
		// This is fatal, since we need this for cases where we are searching
		// for DBG files, and creation of directories...
		_tprintf(TEXT("\nERROR: Unable to load DBGHELP.DLL, which is required for proper operation.\n"));
		_tprintf(TEXT("You should ensure that a copy of this DLL is on your system path, or in the\n"));
		_tprintf(TEXT("same directory as this utility.\n"));
		goto exit;
	} else
	{
		// Get procedure addresses.
		m_lpfMakeSureDirectoryPathExists = (PfnMakeSureDirectoryPathExists) GetProcAddress( m_hDBGHELP, "MakeSureDirectoryPathExists");

		if( (m_lpfMakeSureDirectoryPathExists == NULL) )
		{
			// Consider this fatal
			_tprintf(TEXT("\nWARNING:  The version of DBGHELP.DLL being loaded doesn't have required\n"));
			_tprintf(TEXT("functions!.  Please update this module with a newer version and try again.\n"));
			FreeLibrary( m_hDBGHELP ) ;
			m_hDBGHELP = NULL;
			goto exit;
		}
	}
	m_fDBGHELPInitialized = true;

exit:
	return m_fDBGHELPInitialized; 
}

BOOL CDelayLoad::MakeSureDirectoryPathExists(LPTSTR DirPath)
{
	// If we've never initialized DBGHELP, do so now...
	if (!m_fDBGHELPInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_DBGHELP())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fDBGHELPInitialized)
	{
		return FALSE;
	}

	if (!m_lpfMakeSureDirectoryPathExists)
		return FALSE;

	// This API normally takes ASCII strings only...
	char szDirPath[_MAX_PATH];
	CUtilityFunctions::CopyTSTRStringToAnsi(DirPath, szDirPath, _MAX_PATH);

	// Invoke and return...
	return m_lpfMakeSureDirectoryPathExists(szDirPath);
}


// PSAPI.DLL - APIs
bool CDelayLoad::Initialize_PSAPI()
{
	m_fPSAPIInitialized = false;
	m_fPSAPIInitializedAttempted = true;

	// Load library on DBGHELP.DLL and get the procedures explicitly.
	m_hPSAPI = LoadLibrary( TEXT("PSAPI.DLL") );

	if( m_hPSAPI == NULL )
	{
		// This may/may not be fatal... we can always fall back to TOOLHELP32 for Win2000/Win98
		goto exit;
	} else
	{
		// Get procedure addresses.
		m_lpfEnumProcesses = (PfnEnumProcesses) GetProcAddress( m_hPSAPI, "EnumProcesses" ) ;
		m_lpfEnumProcessModules = (PfnEnumProcessModules) GetProcAddress( m_hPSAPI, "EnumProcessModules" );
	
#ifdef UNICODE
		m_lpfGetModuleFileNameEx =(PfnGetModuleFileNameEx) GetProcAddress(m_hPSAPI, "GetModuleFileNameExW" );
		m_lpfGetDeviceDriverFileName = (PfnGetDeviceDriverFileName) GetProcAddress(m_hPSAPI, "GetDeviceDriverFileNameW");
#else
		m_lpfGetModuleFileNameEx =(PfnGetModuleFileNameEx) GetProcAddress(m_hPSAPI, "GetModuleFileNameExA" );
		m_lpfGetDeviceDriverFileName = (PfnGetDeviceDriverFileName) GetProcAddress(m_hPSAPI, "GetDeviceDriverFileNameA");
#endif
		m_lpfEnumDeviceDrivers = (PfnEnumDeviceDrivers) GetProcAddress(m_hPSAPI, "EnumDeviceDrivers" );

		if( m_lpfEnumProcesses == NULL || 
			m_lpfEnumProcessModules == NULL || 
			m_lpfGetModuleFileNameEx == NULL ||
			m_lpfEnumDeviceDrivers == NULL ||
			m_lpfGetDeviceDriverFileName == NULL
		  )
		{
			_tprintf(TEXT("The version of PSAPI.DLL being loaded doesn't have required functions!.\n"));
			FreeLibrary( m_hPSAPI ) ;
			m_hPSAPI = NULL;
			goto exit;
		}
	}
	m_fPSAPIInitialized = true;

exit:
	return m_fPSAPIInitialized; 
}


DWORD CDelayLoad::GetModuleFileNameEx(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfGetModuleFileNameEx)
		return FALSE;

	return m_lpfGetModuleFileNameEx(hHandle, hModule, lpFilename, nSize);
}

BOOL CDelayLoad::EnumProcessModules(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfEnumProcessModules)
		return FALSE;

	return m_lpfEnumProcessModules(hProcess, lphModule, cb, lpcbNeeded);
}

BOOL CDelayLoad::EnumProcesses(DWORD *lpidProcess, DWORD cb, DWORD *cbNeeded)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfEnumProcesses)
		return FALSE;

	return m_lpfEnumProcesses(lpidProcess, cb, cbNeeded);
}

BOOL CDelayLoad::EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfEnumDeviceDrivers)
		return FALSE;

	return m_lpfEnumDeviceDrivers(lpImageBase, cb, lpcbNeeded);
}



DWORD CDelayLoad::GetDeviceDriverFileName(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize)
{
	// If we've never initialized PSAPI, do so now...
	if (!m_fPSAPIInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_PSAPI())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fPSAPIInitialized)
	{
		return FALSE;
	}

	if (!m_lpfGetDeviceDriverFileName)
		return FALSE;

	return m_lpfGetDeviceDriverFileName(ImageBase, lpFilename, nSize);
}

// TOOLHELP32.DLL - APIs

bool CDelayLoad::Initialize_TOOLHELP32()
{
	m_fTOOLHELP32Initialized = false;
	m_fTOOLHELP32InitializedAttempted = true;

	// Load library on DBGHELP.DLL and get the procedures explicitly.
	m_hTOOLHELP32 = LoadLibrary( TEXT("KERNEL32.DLL") );

	if( m_hTOOLHELP32 == NULL )
	{
		// This may/may not be fatal... we can always fall back to TOOLHELP32 for Win2000/Win98
		goto exit;
	} else
	{
		//
		// BUG 523 - GREGWI - Unicode version fails to enumerate processes correctly...
		// (Code added to enumerate the correct DLL entrypoints in KERNEL32.DLL)
		//
		// Get procedure addresses based on UNICODE or ANSI
		m_lpfCreateToolhelp32Snapshot = (PfnCreateToolhelp32Snapshot) GetProcAddress( m_hTOOLHELP32, "CreateToolhelp32Snapshot" );
#ifdef UNICODE
		m_lpfProcess32First = (PfnProcess32First) GetProcAddress( m_hTOOLHELP32, "Process32FirstW" );
		m_lpfProcess32Next =  (PfnProcess32Next)  GetProcAddress( m_hTOOLHELP32, "Process32NextW" );
		m_lpfModule32First =  (PfnModule32First)  GetProcAddress( m_hTOOLHELP32, "Module32FirstW" );
		m_lpfModule32Next =	  (PfnModule32Next)   GetProcAddress( m_hTOOLHELP32, "Module32NextW" );
#else
		m_lpfProcess32First = (PfnProcess32First) GetProcAddress( m_hTOOLHELP32, "Process32First" );
		m_lpfProcess32Next =  (PfnProcess32Next)  GetProcAddress( m_hTOOLHELP32, "Process32Next" );
		m_lpfModule32First =  (PfnModule32First)  GetProcAddress( m_hTOOLHELP32, "Module32First" );
		m_lpfModule32Next =	  (PfnModule32Next)   GetProcAddress( m_hTOOLHELP32, "Module32Next" );
#endif
		if (!m_lpfCreateToolhelp32Snapshot ||
			!m_lpfProcess32First || 
			!m_lpfProcess32Next ||
			!m_lpfModule32First ||
			!m_lpfModule32Next)

		{
			// Free our handle to KERNEL32.DLL
			FreeLibrary(m_hTOOLHELP32);
			m_hTOOLHELP32 = NULL;
			goto exit;
		}

	}
	m_fTOOLHELP32Initialized = true;

exit:
	return m_fTOOLHELP32Initialized; 
}

HANDLE WINAPI CDelayLoad::CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return INVALID_HANDLE_VALUE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return INVALID_HANDLE_VALUE;
	}

	if (!m_lpfCreateToolhelp32Snapshot)
		return INVALID_HANDLE_VALUE;

	return m_lpfCreateToolhelp32Snapshot(dwFlags, th32ProcessID);
}

BOOL WINAPI CDelayLoad::Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfProcess32First)
		return FALSE;

	return m_lpfProcess32First(hSnapshot, lppe);
}

BOOL WINAPI CDelayLoad::Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfProcess32Next)
		return FALSE;

	return m_lpfProcess32Next(hSnapshot, lppe);
}

BOOL WINAPI CDelayLoad::Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfModule32First)
		return FALSE;

	return m_lpfModule32First(hSnapshot, lpme);
}

BOOL WINAPI CDelayLoad::Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme)
{
	// If we've never initialized TOOLHELP32, do so now...
	if (!m_fTOOLHELP32InitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_TOOLHELP32())
			return FALSE;
	}

	// If we've attempted, but we failed... then bail now...
	if (!m_fTOOLHELP32Initialized)
	{
		return FALSE;
	}

	if (!m_lpfModule32Next)
		return FALSE;

	return m_lpfModule32Next(hSnapshot, lpme);
}

bool CDelayLoad::Initialize_SYMSRV(LPCTSTR tszSymSrvDLL)
{
	m_fSYMSRVInitialized = false;
	m_fSYMSRVInitializedAttempted = true;

	// If we're loading a new SYMSRV DLL file (SYMSRV.DLL or some other Symbol DLL)
	if (m_hSYMSRV)
	{
		// Compare... is this file the same as the last... if so... don't worry about it...
		if (_tcscmp(tszSymSrvDLL, m_tszSymSrvDLL))
		{
			FreeLibrary(m_hSYMSRV);
			m_hSYMSRV = NULL;
			delete [] m_tszSymSrvDLL; // Free the previous string...
		}
	}
	// Load library on SYMSRV.DLL and get the procedures explicitly.
	m_hSYMSRV = LoadLibrary( tszSymSrvDLL );

	if( m_hSYMSRV == NULL )
	{
		// This is fatal, since we need this for cases where we are searching
		// for DBG files, and creation of directories...
		_tprintf(TEXT("\nERROR: Unable to load %s, which is required for proper operation.\n"), tszSymSrvDLL);
		_tprintf(TEXT("You should ensure that a copy of this DLL is on your system path, or in the\n"));
		_tprintf(TEXT("same directory as this utility.\n"));
		goto exit;
	} else
	{
		// Get procedure addresses.
		m_lpfSymbolServer = (PfnSymbolServer) GetProcAddress( m_hSYMSRV, "SymbolServer");
		m_lpfSymbolServerClose = (PfnSymbolServerClose) GetProcAddress( m_hSYMSRV, "SymbolServerClose");

		if( (m_lpfSymbolServer == NULL) ||
			(m_lpfSymbolServerClose == NULL)
		  )
		{
			// Consider this fatal
			_tprintf(TEXT("\nWARNING:  The version of %s being loaded doesn't have required\n"), tszSymSrvDLL);
			_tprintf(TEXT("functions!.  Please update this module with a newer version and try again.\n"));
			FreeLibrary( m_hSYMSRV ) ;
			m_hSYMSRV = NULL;
			goto exit;
		}

		// Copy the provided string
		m_tszSymSrvDLL = new TCHAR[_tcslen(tszSymSrvDLL)+1];
		
		if (NULL == m_tszSymSrvDLL)
			goto exit;

		_tcscpy(m_tszSymSrvDLL, tszSymSrvDLL);
	}
	m_fSYMSRVInitialized = true;

exit:
	return m_fSYMSRVInitialized; 
}

BOOL WINAPI CDelayLoad::SymbolServer(LPCSTR params, LPCSTR filename, DWORD num1, DWORD num2, DWORD num3, LPSTR path)
{
	/*
	// If we've never initialized SYMSRV, do so now...
	if (!m_fSYMSRVInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_SYMSRV())
			return FALSE;
	}
	*/

	// If we've attempted, but we failed... then bail now...
	if (!m_fSYMSRVInitialized)
	{
		return FALSE;
	}

	if (!m_lpfSymbolServer)
		return FALSE;

	return m_lpfSymbolServer(params, filename, num1, num2, num3, path);
}


BOOL WINAPI CDelayLoad::SymbolServerClose(VOID)
{
	/*
	// If we've never initialized SYMSRV, do so now...
	if (!m_fSYMSRVInitializedAttempted)
	{
		// Initialize the DLL if needed...
		if (FALSE == Initialize_SYMSRV())
			return FALSE;
	}
	*/

	// If we've attempted, but we failed... then bail now...
	if (!m_fSYMSRVInitialized)
	{
		return FALSE;
	}

	if (!m_lpfSymbolServerClose)
		return FALSE;

	return m_lpfSymbolServerClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\dmpfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dmpfile.h
//
//--------------------------------------------------------------------------

// DmpFile.h: interface for the CDmpFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DMPFILE_H__8BCD59C6_0CEA_11D3_84F0_000000000000__INCLUDED_)
#define AFX_DMPFILE_H__8BCD59C6_0CEA_11D3_84F0_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <windows.h>
#include <tchar.h>
#include "globals.h"

// Forward Declarations
class CProcessInfo;
class CModules;
class CModuleInfoCache;
class CFileData;

// Let's implement the DebugOutputCallback for the DBGENG... it'll be cool to have the debugger
// spit out info to us when it is running...

class OutputCallbacks : public IDebugOutputCallbacks
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    
    // This method is only called if the supplied mask
    // is allowed by the clients output control.
    // The return value is ignored.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

class CDmpFile  
{
public:
	CDmpFile();
	virtual ~CDmpFile();
	bool Initialize(CFileData * lpOutputFile);
	bool CollectData(CProcessInfo ** lplpProcessInfo, CModules ** lplpModules, CModuleInfoCache * lpModuleInfoCache); 

	inline bool IsUserDmpFile() {
		return (m_DumpClass == DEBUG_CLASS_USER_WINDOWS);
		};

	IDebugSymbols * m_pIDebugSymbols;
	IDebugDataSpaces * m_pIDebugDataSpaces;

protected:
	bool					m_fDmpInitialized;
	CFileData *				m_lpOutputFile;

	LPSTR					m_szDmpFilePath;
	LPSTR					m_szSymbolPath;

	IDebugClient * m_pIDebugClient;
	IDebugControl * m_pIDebugControl;
	ULONG m_DumpClass;
	ULONG m_DumpClassQualifier;

//	LPTSTR EnumerateModulesFromDump(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile);
	bool EumerateModulesFromDmp(CModuleInfoCache * lpModuleInfoCache, CProcessInfo * lpProcessInfo, CModules * lpModules);
};

#endif // !defined(AFX_DMPFILE_H__8BCD59C6_0CEA_11D3_84F0_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\dmpfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dmpfile.cpp
//
//--------------------------------------------------------------------------

// DmpFile.cpp: implementation of the CDmpFile class.
//
//////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>

#include "DmpFile.h"
#include "Globals.h"
#include "UtilityFunctions.h"
#include "ProgramOptions.h"
#include "ProcessInfo.h"
#include "Modules.h"
#include "FileData.h"
#include "ModuleInfoCache.h"
#include "ModuleInfo.h"

// Let's implement the DebugOutputCallback for the DBGENG... it'll be cool to have the debugger
// spit out info to us when it is running...
STDMETHODIMP
OutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
OutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
OutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
OutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    HRESULT Status = S_OK;

	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) && (Mask & DEBUG_OUTPUT_NORMAL))
	{
		printf(Text);
	}

    return Status;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDmpFile::CDmpFile()
{
	m_szDmpFilePath = NULL;
	m_szSymbolPath = NULL;
	m_fDmpInitialized = false;
	m_pIDebugClient = NULL;
	m_pIDebugControl = NULL;
	m_pIDebugSymbols = NULL;
	m_pIDebugDataSpaces = NULL;
	m_DumpClass = DEBUG_CLASS_UNINITIALIZED;
	m_DumpClassQualifier = 0;
}

CDmpFile::~CDmpFile()
{
	if (m_fDmpInitialized)
	{
	    // Let's ensure that our debug output is set to normal (at least)
		//m_pIDebugClient->GetOutputMask(&OutMask);
		//OutMask = ~DEBUG_OUTPUT_NORMAL;
		m_pIDebugClient->SetOutputMask(0);

		// Let's be as least intrusive as possible...
		m_pIDebugClient->EndSession(DEBUG_END_ACTIVE_DETACH);
	}

	if (m_szDmpFilePath)
		delete [] m_szDmpFilePath;

	if (m_szSymbolPath)
		delete [] m_szSymbolPath;
}

OutputCallbacks g_OutputCb;

bool CDmpFile::Initialize(CFileData * lpOutputFile)
{
	HRESULT Hr;
	ULONG g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
	LPTSTR tszExpandedString = NULL;
	bool fReturn = false;

	// Let's save off big objects so we don't have to keep passing this to
	// our methods...
	m_lpOutputFile = lpOutputFile;

	// The DBGENG is somewhat ANSI oriented...
	m_szDmpFilePath = CUtilityFunctions::CopyTSTRStringToAnsi(g_lpProgramOptions->GetDmpFilePath(), m_szDmpFilePath, 0);

	// Create our interface pointer to do our Debug Work...
	if (FAILED(Hr = DebugCreate(IID_IDebugClient, (void **)&m_pIDebugClient)))
		goto cleanup;

	// Let's query for IDebugControl interface (we need it to determine debug type easily)...
	// Let's query for IDebugSymbols interface as we need it to receive module info...
	// Let's query for IDebugDataSpaces interface as we need it to read DMP memory...
	if (
		FAILED(Hr = m_pIDebugClient->QueryInterface(IID_IDebugControl,(void **)&m_pIDebugControl)) ||
		FAILED(Hr = m_pIDebugClient->QueryInterface(IID_IDebugSymbols,(void **)&m_pIDebugSymbols)) ||
		FAILED(Hr = m_pIDebugClient->QueryInterface(IID_IDebugDataSpaces,(void **)&m_pIDebugDataSpaces))
	   )
	{
		_tprintf(TEXT("Error: DBGENG Interfaces required were not found!\n"));
		goto cleanup;
	}

	// Set callbacks.
    if (FAILED(Hr = m_pIDebugClient->SetOutputCallbacks(&g_OutputCb)) //||
		//FAILED(Hr = m_pIDebugClient->SetEventCallbacks(&g_DebugEventCallbacks))
		)
	{
		//
		//
		//
		_tprintf(TEXT("Error: DBGENG - Unable to SetOutputCallbacks!\n"));
		goto cleanup;
	}

    DWORD OutMask;

    // Let's ensure that our debug output is set to normal (at least)
    OutMask = m_pIDebugClient->GetOutputMask(&OutMask);
    m_pIDebugClient->SetOutputMask(OutMask | DEBUG_OUTPUT_NORMAL);

	// Set our symbol path... this is required prior to a "reload" of modules... 

	// The DBGENG is somewhat ASCII oriented... we need an environment-expanded string converted
	// to an ASCII string...
	tszExpandedString = CUtilityFunctions::ExpandPath(g_lpProgramOptions->GetSymbolPath());

	if (!tszExpandedString)
		goto cleanup;

	m_szSymbolPath = CUtilityFunctions::CopyTSTRStringToAnsi( tszExpandedString, m_szSymbolPath, 0);
		
	// It's a bit premature to set this now... but it's required by DBGENG.DLL before a reload...
	if (FAILED(Hr = m_pIDebugSymbols->SetSymbolPath(m_szSymbolPath)))
	{
		goto cleanup;
	}

	// Let's open the dump...
	if (FAILED(Hr = m_pIDebugClient->OpenDumpFile(m_szDmpFilePath)))
	{
		goto cleanup;
	}

	// Get Initial Execution state.
    if (FAILED(Hr = m_pIDebugControl->GetExecutionStatus(&g_ExecStatus)))
    {
		_tprintf(TEXT("Unable to get execution status!  Hr=0x%x\n"), Hr);
		goto cleanup;
    }

	if (g_ExecStatus != DEBUG_STATUS_NO_DEBUGGEE)
	{
		// I think we'll work just fine?
		_tprintf(TEXT("Debug Session is already active!\n"));
		// goto cleanup; 
	}

	// What type of dump did we get?
	if (FAILED(Hr = m_pIDebugControl->GetDebuggeeType(&m_DumpClass, &m_DumpClassQualifier)))
	{
		goto cleanup;
	}

	//
    m_pIDebugClient->SetOutputMask(0); // Temporarily suppress this stuff...

	//
	// All the good stuff happens here... modules load, etc.. we could suppress all the output
	// but it's cool to watch...
	//
	if (FAILED(Hr = m_pIDebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)))
	{
		goto cleanup;
	}

	// Restore output!
    m_pIDebugClient->SetOutputMask(OutMask | DEBUG_OUTPUT_NORMAL);

	// Yee haa... we got something...
	m_fDmpInitialized = true;

	fReturn = true;

cleanup:
	if (tszExpandedString)
		delete [] tszExpandedString;

	return fReturn;
}

bool CDmpFile::CollectData(CProcessInfo ** lplpProcessInfo, CModules ** lplpModules, CModuleInfoCache * lpModuleInfoCache)
{
	bool fReturn = false;
	// Okay... first order of business is to decide what we need to collect...

	// Collect information from the file based on it's type...
	if (IsUserDmpFile())
	{
		// Second, order of business is to prepare for collecting info about the
		// process in the USER.DMP file...
		(*lplpProcessInfo) = new CProcessInfo();

		if ((*lplpProcessInfo) == NULL)
			goto cleanup;

		if (!(*lplpProcessInfo)->Initialize(lpModuleInfoCache, NULL, m_lpOutputFile, this))
			goto cleanup;
	} else
	{
		(*lplpModules) = new CModules();

		if ((*lplpModules) == NULL)
			goto cleanup;

		if (!(*lplpModules)->Initialize(lpModuleInfoCache, NULL, m_lpOutputFile, this))
			goto cleanup;
	}

	if (!EumerateModulesFromDmp(lpModuleInfoCache, *lplpProcessInfo, *lplpModules))
		goto cleanup;

	fReturn = true;

cleanup:

	return fReturn;
}

//
// Combined DMP Enumeration Code
//
bool CDmpFile::EumerateModulesFromDmp(CModuleInfoCache * lpModuleInfoCache, CProcessInfo * lpProcessInfo, CModules * lpModules)
{
	//
	// Consult DumpModuleTable in Ntsym.cpp for ideas...
	//
	CModuleInfo * lpModuleInfo;
	HRESULT Hr;
	ULONG ulNumberOfLoadedModules;
	ULONG ulNumberOfUnloadedModules;
	ULONG64 Base;
	char szImageNameBuffer[_MAX_PATH];
	TCHAR tszModulePath[_MAX_PATH];
//	TCHAR tszModuleFilePath[_MAX_PATH];
	TCHAR tszModuleFileName[_MAX_FNAME];
	TCHAR tszModuleFileExtension[_MAX_EXT];
	bool fNew, fProcessNameFound = false;
	bool fUserDmp = IsUserDmpFile();

	// How many modules were found?
	if (FAILED(Hr = m_pIDebugSymbols->GetNumberModules(&ulNumberOfLoadedModules, &ulNumberOfUnloadedModules)))
	{
		_tprintf(TEXT("Unable to enumerate any modules in the DMP file!\n"));
		return false;
	}

	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
	{
		_tprintf(TEXT("\n%-8s %-8s  %-30s %s\n"), TEXT("Start"),
												 TEXT("End"),
												 TEXT("Module Name"),
												 TEXT("Time/Date"));
	}

	//
	// Enumerate through the modules in the DMP file...
	//
	for (unsigned int i = 0; i < ulNumberOfLoadedModules; i++)
	{
		// First, we get the Base address by our index
		if (FAILED(Hr = m_pIDebugSymbols->GetModuleByIndex(i, &Base)))
		{
			_tprintf(TEXT("Failed getting base address of module number %d\n"), i);
			continue; // try the next?
		}

		// Second, we get the name from our base address
		ULONG ulImageNameSize;

		//
		// This can return both the ImageNameBuffer and a ModuleNameBuffer...
		// The ImageNameBuffer typically contains the entire module name like (MODULE.DLL),
		// whereas the ModuleNameBuffer is typically just the module name like (MODULE).
		//
		if (FAILED(Hr = m_pIDebugSymbols->GetModuleNames(	DEBUG_ANY_ID,		// Use Base address
															Base, 				// Base address from above
															szImageNameBuffer,
															_MAX_PATH, 
															&ulImageNameSize, 
															NULL,
															0,
															NULL,
															NULL,
															0,
															NULL)))
		{
			_tprintf(TEXT("Failed getting name of module at base 0x%x\n"), Base);
			continue; // try the next?
		}

		// Convert the string to something we can use...
		CUtilityFunctions::CopyAnsiStringToTSTR(szImageNameBuffer, tszModulePath, _MAX_PATH);
		
		// Third, we can now get whatever we want from memory...

		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
			continue;

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...

		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			if (fUserDmp )
			{
				lpProcessInfo->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			} else
			{
				lpModules->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			}
			
			continue;
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(NULL, m_lpOutputFile, this))
		{
			return false; // Hmmm... memory error?
		}

		//
		// Okay, get the module info from the DMP file...
		//
		if (lpModuleInfo->GetModuleInfo(tszModulePath, true, Base) )
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			if (fUserDmp)
			{
				lpProcessInfo->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			} else
			{
				lpModules->AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			}
		} else
		{
			// Continue back to try another module on error...
			continue;
		}

		// Try and patch up the original name of the module...

		// Save the current module path as the DBG stuff

		// We'll tack on .DBG to roll through our own code correctly...
		_tsplitpath(tszModulePath, NULL, NULL, tszModuleFileName, tszModuleFileExtension);

		//_tcscpy(tszModulePath, tszModuleFileName);

		//_tcscpy(tszModuleFileName, tszModulePath);

/*		if (*tszModuleFileExtension == '\0')
		{
			_tcscat(tszModulePath, TEXT(".DBG"));
		} else
		{
			_tcscat(tszModulePath, tszModuleFileExtension);
		}
*/
		if ( (lpModuleInfo->GetPESymbolInformation() == CModuleInfo::SYMBOLS_DBG) ||
			(lpModuleInfo->GetPESymbolInformation() == CModuleInfo::SYMBOLS_DBG_AND_PDB) )
		{
			// Append .DBG to our module name
			_tcscat(tszModuleFileName, TEXT(".DBG"));

			lpModuleInfo->SetDebugDirectoryDBGPath(tszModuleFileName);
		
/*

			// Ordinarily this seems very dangerous.. but the size of the new string
			// will be less than the original, so this should be safe... we hope?!
			if (_tcsicmp(&tszModulePath[_tcslen(tszModulePath)-4], TEXT(".DBG")) == 0) 
			{
				_tsplitpath(tszModulePath, NULL, tszModuleFilePath, tszModuleFileName, NULL);

				if (_tcslen(tszModuleFilePath)==4) 
				{
					tszModuleFilePath[_tcslen(tszModuleFilePath)-1] = 0;
					_tcscpy(tszModulePath, tszModuleFileName);
					_tcscat(tszModulePath, TEXT("."));
					_tcscat(tszModulePath, tszModuleFilePath);

				} else if ( lpModuleInfo->IsDLL() ) 
				{
					_tcscpy(tszModulePath, tszModuleFileName);
					_tcscat(tszModulePath, TEXT(".DLL"));

				} else 
				{
					_tcscpy(tszModulePath, tszModuleFileName);
					_tcscat(tszModulePath, TEXT(".EXE"));
				}
			} else
			{
				// We didn't find a .DBG extension... let's tack on a guess...
				if ( lpModuleInfo->IsDLL() ) 
				{
					_tcscat(tszModulePath, TEXT(".DLL"));

				} else 
				{
					_tcscat(tszModulePath, TEXT(".EXE"));
				}
			}
*/
		} else if (lpModuleInfo->GetPESymbolInformation() == CModuleInfo::SYMBOLS_PDB)
		{
			if (lpModuleInfo->GetDebugDirectoryPDBPath())
			{
/*				// Try and translate the module name to something friendlier
				_tsplitpath(lpModuleInfo->GetDebugDirectoryPDBPath(), NULL, NULL, tszModuleFileName, NULL);

				// Compose the name by appending the extension (we hope if it is not a EXE it will
				// be a DLL (with that extension)..
				if ( lpModuleInfo->IsDLL() ) 
				{
					_tcscpy(tszModulePath, tszModuleFileName);
					_tcscat(tszModulePath, TEXT(".DLL"));

				} else 
				{
					_tcscpy(tszModulePath, tszModuleFileName);
					_tcscat(tszModulePath, TEXT(".EXE"));
				}
*/
			} else
			{
				//
				// Unfortunately, we can't find the PDB Imagepath in the DMP file... so we'll
				// just guess what it would be...
				//
				// Append .PDB to our module name
				_tcscat(tszModuleFileName, TEXT(".PDB"));

				lpModuleInfo->SetPEDebugDirectoryPDBPath(tszModuleFileName);


				// Compose the name by appending the extension (we hope if it is not a EXE it will
				// be a DLL (with that extension)... Also, by this point we MAY have found an image
				// name like EXE\MODULE.DBG... we want to strip off the trailing .DBG before appending...
/*				unsigned int cbModulePathLength = _tcslen(tszModulePath);

				if ( cbModulePathLength > 4) // Look to see if this exceeds chars before doing this next operation..
				{
					if (_tcsicmp(&tszModulePath[cbModulePathLength-4], TEXT(".DBG")) == 0)
					{
						// We found a .DBG extension... let's nuke it...
						tszModulePath[cbModulePathLength-4] = '\0';
					}
				}

				// Append the appropriate extension...
				if ( lpModuleInfo->IsDLL() ) 
				{
					_tcscat(tszModulePath, TEXT(".DLL"));

				} else 
				{
					_tcscat(tszModulePath, TEXT(".EXE"));
				}
*/
			}
		}

		// Now, let's remove the extra path bits...
		_tsplitpath(tszModulePath, NULL, NULL, tszModuleFileName, tszModuleFileExtension);

		_tcscpy(tszModulePath, tszModuleFileName);
		_tcscat(tszModulePath, tszModuleFileExtension);

		// Save the current module path as the DBG stuff
		lpModuleInfo->SetPEImageModulePath(tszModulePath);

		// Save the current module name as well...
		lpModuleInfo->SetPEImageModuleName(tszModulePath);

		// Hey... if this is not a DLL, then it's probably the EXE!!!
		if (fUserDmp && !fProcessNameFound)
		{
			if (!lpModuleInfo->IsDLL() )
			{
				lpProcessInfo->SetProcessName(tszModulePath);
				fProcessNameFound = true;
			}
		}

		// Filter out garbage.
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
		{
			time_t time = lpModuleInfo->GetPEImageTimeDateStamp();

			if (time)
			{
				_tprintf(TEXT("%08x %08x  %-30s %s"), (ULONG)Base,
												 (ULONG)Base+(ULONG)lpModuleInfo->GetPEImageSizeOfImage(),
												 tszModulePath,
												 _tctime(&time));


			} else
			{
				_tprintf(TEXT("%08x %08x  %-30s Unknown\n"), (ULONG)Base,
												 (ULONG)Base+(ULONG)lpModuleInfo->GetPEImageSizeOfImage(),
												 tszModulePath);

			}
		}


	}

	return (ulNumberOfLoadedModules != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\dbghelpfunctions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbghelpfunctions.h
//
//--------------------------------------------------------------------------

// DBGHelpFunctions.h: interface for the CDBGHelpFunctions class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DBGHELPFUNCTIONS_H__FF495236_E9FD_11D2_849F_000000000000__INCLUDED_)
#define AFX_DBGHELPFUNCTIONS_H__FF495236_E9FD_11D2_849F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CDBGHelpFunctions  
{
public:
	CDBGHelpFunctions();
	virtual ~CDBGHelpFunctions();

	// Initialization...
	bool Initialize();

	// DBGHELP Functions (Publicly accessible for ease of use)
	BOOL MakeSureDirectoryPathExists(LPTSTR DirPath);

private:

	HINSTANCE m_hDBGHELP;

	// DBGHELP functions TypeDef'ed for simplicity
	typedef BOOL (WINAPI *PfnMakeSureDirectoryPathExists)(PCSTR DirPath);

	// DBGHELP Function Pointers
	BOOL  (WINAPI *m_lpfMakeSureDirectoryPathExists)(PCSTR DirPath);
};

#endif // !defined(AFX_DBGHELPFUNCTIONS_H__FF495236_E9FD_11D2_849F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\dbghelpfunctions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbghelpfunctions.cpp
//
//--------------------------------------------------------------------------

// DBGHelpFunctions.cpp: implementation of the CDBGHelpFunctions class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include <STDIO.H>
#include <stdlib.h>

#include "DBGHelpFunctions.h"
#include "UtilityFunctions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDBGHelpFunctions::CDBGHelpFunctions()
{
	m_hDBGHELP = NULL;
	m_lpfMakeSureDirectoryPathExists = NULL;
}

CDBGHelpFunctions::~CDBGHelpFunctions()
{
	if (m_hDBGHELP)
		FreeLibrary(m_hDBGHELP);

}

BOOL CDBGHelpFunctions::MakeSureDirectoryPathExists(LPTSTR DirPath)
{
	if (!m_lpfMakeSureDirectoryPathExists)
		return FALSE;


	char szDirPath[_MAX_PATH];

	CUtilityFunctions::CopyTSTRStringToAnsi(DirPath, szDirPath, _MAX_PATH);

	return m_lpfMakeSureDirectoryPathExists(szDirPath);
}

bool CDBGHelpFunctions::Initialize()
{
	// Load library on DBGHELP.DLL and get the procedures explicitly.
	m_hDBGHELP = LoadLibrary( TEXT("DBGHELP.DLL") );

	if( m_hDBGHELP == NULL )
	{
		// This is fatal, since we need this for cases where we are searching
		// for DBG files, and creation of directories...
		_tprintf(TEXT("\nERROR: Unable to load DBGHELP.DLL, which is required for proper operation.\n"));
		_tprintf(TEXT("You should ensure that a copy of this DLL is on your system path, or in the\n"));
		_tprintf(TEXT("same directory as this utility.\n"));
		return false;
	} else
	{
		// Get procedure addresses.
		m_lpfMakeSureDirectoryPathExists = (PfnMakeSureDirectoryPathExists) GetProcAddress( m_hDBGHELP, "MakeSureDirectoryPathExists");

		if( (m_lpfMakeSureDirectoryPathExists == NULL) )
		{
			// Consider this fatal
			_tprintf(TEXT("\nWARNING:  The version of DBGHELP.DLL being loaded doesn't have required\n"));
			_tprintf(TEXT("functions!.  Please update this module with a newer version and try again.\n"));
			FreeLibrary( m_hDBGHELP ) ;
			m_hDBGHELP = NULL;
		}
	}

	return true; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\delayload.h ===
// DelayLoad.h: interface for the CDelayLoad class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DELAYLOAD_H__7DFF0A14_DD50_4E3A_AC8D_5B89BD2D5A3B__INCLUDED_)
#define AFX_DELAYLOAD_H__7DFF0A14_DD50_4E3A_AC8D_5B89BD2D5A3B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include <TLHELP32.H>

class CDelayLoad  
{
public:
	CDelayLoad();
	virtual ~CDelayLoad();

	// DBGHELP Functions (Publicly accessible for ease of use)
	bool Initialize_DBGHELP();
	BOOL MakeSureDirectoryPathExists(LPTSTR DirPath);

	// PSAPI Functions (Publicly accessible for ease of use)
	bool Initialize_PSAPI();
	BOOL  WINAPI EnumProcesses(DWORD * lpidProcess, DWORD cb, DWORD * cbNeeded);
	BOOL  WINAPI EnumProcessModules(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
	DWORD WINAPI GetModuleFileNameEx(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
	BOOL  WINAPI EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
	DWORD WINAPI GetDeviceDriverFileName(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize);

	// TOOLHELP32 Functions (Publicly accessible for ease of use)
	bool Initialize_TOOLHELP32();
	HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
	BOOL   WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
	BOOL   WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

	// SYMSRV Functions (Publicly accessible for each of use)
	bool Initialize_SYMSRV(LPCTSTR tszSymSrvDLL);

	LPTSTR inline GetCurrentSymSrvDLL() { return m_tszSymSrvDLL; };
	BOOL WINAPI SymbolServer(LPCSTR params, LPCSTR filename, DWORD num1, DWORD num2, DWORD num3, LPSTR path);
	BOOL WINAPI SymbolServerClose(VOID);

private:

	// DBGHELP functions
	HINSTANCE m_hDBGHELP;
	bool m_fDBGHELPInitialized;
	bool m_fDBGHELPInitializedAttempted;

	// DBGHELP functions TypeDef'ed for simplicity
	typedef BOOL (WINAPI *PfnMakeSureDirectoryPathExists)(PCSTR DirPath);
	
	// DBGHELP Function Pointers
	BOOL  (WINAPI *m_lpfMakeSureDirectoryPathExists)(PCSTR DirPath);

	// Windows NT 4.0/2000 Support for Querying Processes and Modules

	// PSAPI functions
	HINSTANCE m_hPSAPI;
	bool m_fPSAPIInitialized;
	bool m_fPSAPIInitializedAttempted;

	// PSAPI functions TypeDef'ed for simplicity
	typedef BOOL  (WINAPI *PfnEnumProcesses)(DWORD * lpidProcess, DWORD cb, DWORD * cbNeeded);
	typedef BOOL  (WINAPI *PfnEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
	typedef DWORD (WINAPI *PfnGetModuleFileNameEx)(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
	typedef	BOOL  (WINAPI *PfnEnumDeviceDrivers)(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
	typedef DWORD (WINAPI *PfnGetDeviceDriverFileName)(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize);
	
	// PSAPI Function Pointers
	BOOL  (WINAPI *m_lpfEnumProcesses)(DWORD * lpidProcess, DWORD cb, DWORD * cbNeeded);
	BOOL  (WINAPI *m_lpfEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
	DWORD (WINAPI *m_lpfGetModuleFileNameEx)(HANDLE hHandle, HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
	BOOL  (WINAPI *m_lpfEnumDeviceDrivers)(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
	DWORD (WINAPI *m_lpfGetDeviceDriverFileName)(LPVOID ImageBase, LPTSTR lpFilename, DWORD nSize);
	
	// Windows 95 / Windows 2000 Support for Querying Processes and Modules
	
	// TOOLHELP32 functions
	HINSTANCE m_hTOOLHELP32;
	bool m_fTOOLHELP32Initialized;
	bool m_fTOOLHELP32InitializedAttempted;

	// TOOLHELP32 functions TypeDef'ed for simplicity
	typedef HANDLE (WINAPI *PfnCreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
	typedef BOOL   (WINAPI *PfnProcess32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	typedef BOOL   (WINAPI *PfnProcess32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	typedef BOOL   (WINAPI *PfnModule32First)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
	typedef BOOL   (WINAPI *PfnModule32Next)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

	// TOOLHELP32 Function Pointers
	HANDLE (WINAPI *m_lpfCreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
	BOOL   (WINAPI *m_lpfProcess32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   (WINAPI *m_lpfProcess32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
	BOOL   (WINAPI *m_lpfModule32First)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
	BOOL   (WINAPI *m_lpfModule32Next)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

	// SYMSRV functions
	HINSTANCE m_hSYMSRV;
	bool m_fSYMSRVInitialized;
	bool m_fSYMSRVInitializedAttempted;
	LPTSTR m_tszSymSrvDLL;
	
	// SYMSRV functions TypeDef'ed for simplicity
	typedef BOOL (WINAPI *PfnSymbolServer)(LPCSTR params, LPCSTR filename, DWORD num1, DWORD num2, DWORD num3, LPSTR path);
//	typedef BOOL (WINAPI *PfnSymbolServerOpen)(VOID);
	typedef BOOL (WINAPI *PfnSymbolServerClose)(VOID);
	
	// SYMSRV Function Pointers
	BOOL (WINAPI *m_lpfSymbolServer)(LPCSTR params, LPCSTR filename, DWORD num1, DWORD num2, DWORD num3, LPSTR path);
//	BOOL (WINAPI *m_lpfSymbolServerOpen)(VOID);
	BOOL (WINAPI *m_lpfSymbolServerClose)(VOID);
};

#endif // !defined(AFX_DELAYLOAD_H__7DFF0A14_DD50_4E3A_AC8D_5B89BD2D5A3B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\filedata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       filedata.h
//
//--------------------------------------------------------------------------

// FileData.h: interface for the CFileData class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILEDATA_H__A7830023_AF56_11D2_83E6_000000000000__INCLUDED_)
#define AFX_FILEDATA_H__A7830023_AF56_11D2_83E6_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <windows.h>
#include <tchar.h>
#include <time.h>

// Forward Declarations
class CProcesses;
class CProcessInfo;
class CModules;
class CModuleInfoCache;


class CFileData  
{
public:
	CFileData();
	virtual ~CFileData();

	bool OpenFile(DWORD dwCreateOption = CREATE_NEW, bool fReadOnlyMode = false);
	bool CreateFileMapping();
	bool CloseFile();
	bool EndOfFile();

	void PrintLastError();

	// Filepath methods
	bool SetFilePath(LPTSTR tszFilePath);
	LPTSTR GetFilePath();
	bool VerifyFileDirectory();
	
	// Checksym output methods...
	bool WriteFileHeader();
	bool WriteTimeDateString(time_t Time);
	bool WriteFileTimeString(FILETIME ftFileTime);

	bool WriteTimeDateString2(time_t Time);
	bool WriteFileTimeString2(FILETIME ftFileTime);

	bool WriteString(LPTSTR tszString, bool fHandleQuotes = false);
	bool WriteDWORD(DWORD dwNumber);

	// Checksym input methods...
	bool ReadFileHeader();
	bool ReadFileLine();
	DWORD ReadString(LPSTR szStringBuffer = NULL, DWORD iStringBufferSize = 0);
	bool ResetBufferPointerToStart();
	bool ReadDWORD(LPDWORD lpDWORD);
	
	bool DispatchCollectionObject(CProcesses ** lplpProcesses, CProcessInfo ** lplpProcess, CModules ** lplpModules, CModules ** lplpKernelModeDrivers, CModuleInfoCache * lpModuleInfoCache, CFileData * lpOutputFile);

	// Define a constant for our "private" buffer...
	enum {LINE_BUFFER_SIZE = 4096};		  
	char m_szLINEBUFFER[LINE_BUFFER_SIZE]; // This saves us tons of create/free stuff...
	
protected:
	bool CopyCharIfRoom(DWORD iStringBufferSize, LPSTR szStringBuffer, LPDWORD piBytesCopied, bool * pfFinished);

	LPSTR m_lpCurrentLocationInLINEBUFFER;
	LPSTR m_lpCurrentFilePointer;
	LPVOID m_lpBaseAddress;
	HANDLE m_hFileMappingObject;
	 
	// Error methods
	inline DWORD GetLastError() { return m_dwGetLastError; };
	inline void SetLastError() { m_dwGetLastError = ::GetLastError(); };

	LPTSTR m_tszFilePath;
	HANDLE m_hFileHandle;
	DWORD m_dwGetLastError;
};

#endif // !defined(AFX_FILEDATA_H__A7830023_AF56_11D2_83E6_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\globals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       Globals.cpp
//
//--------------------------------------------------------------------------
#define INITGUID

#include "Globals.h"

CDelayLoad * g_lpDelayLoad;
CProgramOptions * g_lpProgramOptions;

// Global String Structure
CollectionStruct g_tszCollectionArray[] = {

	// PROCESSES (used for -P)
	TEXT("System Process(es)"), 
	TEXT("CSV System Process(es)"),
	TEXT("[PROCESSES]"),
	TEXT(",Process Name,Process ID,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n"),

	// PROCESS (used for -Z USER.DMP file)
	TEXT("Process"),
	TEXT("CSV Process"),
	TEXT("[PROCESS]"),
	TEXT(",Process Name,Process ID,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n"),
	
	// MODULES (used for -F <filespec>)
	TEXT("Filesystem Modules"),
	TEXT("CSV Filesystem Modules"),
	TEXT("[FILESYSTEM MODULES]"),
	TEXT(",,,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n"),

	// DEVICE DRIVERS (used for both -Z MEMORY.DMP files, and -D option)
	TEXT("Kernel-Mode Driver(s)"),
	TEXT("CSV Kernel-Mode Driver(s)"),
	TEXT("[KERNEL-MODE DRIVERS]"),
	TEXT(",,,Module Path,Symbol Status,Checksum,Time/Date Stamp,Time/Date String,Size Of Image,DBG Pointer,PDB Pointer,PDB Signature,PDB Age,Product Version,File Version,Company Name,File Description,File Size,File Time/Date Stamp (High),File Time/Date Stamp (Low),File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\globals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       Globals.h
//
//--------------------------------------------------------------------------
#if !defined(GLOBALS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_)
#define GLOBALS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

//
// Speculating as to what the _VC_VER value should be... should this be _MSC_VER
//
#ifndef _VC_VER_INC
#define _VC_VER_INC
#ifndef _VC_VER
#define _VC_VER 620
#endif
#endif

#pragma warning (push)
#pragma warning ( disable : 4100 4201 4710)
#include <dbgeng.h>
#pragma warning (pop)

// Implement a few objects as globals to greatly simplify access to the objects...
// When we multi-thread ourselves with different user-contexts... we'll likely
// need to use _cdecl (thread) to provide per-user/thread global contexts...

#include "DelayLoad.h"
#include "ProgramOptions.h"

enum CollectionTypes { Processes, Process, Modules, KernelModeDrivers };

struct CollectionStruct
{
	LPTSTR tszLocalContext;		// When collected locally, what should we say...
	LPTSTR tszCSVContext;		// When collected from a CSV file, what should we say...
	LPTSTR tszCSVLabel;			// CSV file label, what should we look for...
	LPTSTR tszCSVColumnHeaders;	// CSV file headers...
}; 

extern CDelayLoad * g_lpDelayLoad;
extern CProgramOptions * g_lpProgramOptions;

// Global String Structure
extern CollectionStruct g_tszCollectionArray[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\filedata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       filedata.cpp
//
//--------------------------------------------------------------------------

// FileData.cpp: implementation of the CFileData class.
//
//////////////////////////////////////////////////////////////////////


#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <wtypes.h>
#include <winnt.h>

#include <time.h>
#include "FileData.h"
#include "Globals.h"
#include "Version.h"
#include "Processes.h"
#include "ProcessInfo.h"
#include "Modules.h"
#include "UtilityFunctions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileData::CFileData()
{
	m_dwGetLastError = 0;
	m_hFileHandle = INVALID_HANDLE_VALUE;
	m_tszFilePath = NULL;
	m_szLINEBUFFER[0] = 0;
	m_hFileMappingObject = NULL;
	m_lpBaseAddress = NULL;
	m_lpCurrentFilePointer = NULL;
	m_lpCurrentLocationInLINEBUFFER = NULL;
}

CFileData::~CFileData()
{
	if (m_tszFilePath)
		delete [] m_tszFilePath;

	if (m_lpBaseAddress)
		UnmapViewOfFile(m_lpBaseAddress);

	if (m_hFileMappingObject)
		CloseHandle(m_hFileMappingObject);
}

bool CFileData::SetFilePath(LPTSTR tszFilePath)
{
	// Did we get a proper string?
	if (!tszFilePath)
		return false;

	if (m_tszFilePath)
		delete [] m_tszFilePath;

	m_tszFilePath = new TCHAR[(_tcsclen(tszFilePath)+1)];

	if (!m_tszFilePath)
		return false;

	_tcscpy(m_tszFilePath, tszFilePath);
	return true;
}

LPTSTR CFileData::GetFilePath()
{
	return m_tszFilePath;
}

bool CFileData::VerifyFileDirectory()
{
	if (!m_tszFilePath)
		return false;

	TCHAR tszDrive[_MAX_DRIVE];
	TCHAR tszDirectory[_MAX_DIR];

	TCHAR tszDirectoryPath[_MAX_PATH];

	// Get just the directory...
	_tsplitpath(m_tszFilePath, tszDrive, tszDirectory, NULL, NULL);

	// Now, recompose this into a directory path...
	_tcscpy(tszDirectoryPath, tszDrive);
	_tcscat(tszDirectoryPath, tszDirectory);
	_tcscat(tszDirectoryPath, TEXT("*.*"));

	WIN32_FIND_DATA FindFileData;

	HANDLE hDirectoryHandle = FindFirstFile(tszDirectoryPath, &FindFileData);
	
	if (hDirectoryHandle == INVALID_HANDLE_VALUE)
	{
		// Failure to find the directory...
		SetLastError();
		return false;
	}

	// Close this now that we're done...
	FindClose(hDirectoryHandle);
	return true;
}

/*
DWORD CFileData::GetLastError()
{
	return m_dwGetLastError;
}
*/
bool CFileData::OpenFile(DWORD dwCreateOption, bool fReadOnlyMode)
{
	if (!m_tszFilePath)
	{
		return false;
	}

	// Open the file for read/write
	m_hFileHandle = CreateFile(m_tszFilePath, 
							  fReadOnlyMode ? ( GENERIC_READ )
										    : ( GENERIC_READ | GENERIC_WRITE ),
							  0,	// Not shareable
							  NULL, // Default security descriptor
							  dwCreateOption,
							  FILE_ATTRIBUTE_NORMAL,
							  NULL);

	if (m_hFileHandle == INVALID_HANDLE_VALUE)
	{
		SetLastError();
		return false;
	}

	return true;
}

bool CFileData::CloseFile()
{
	if (m_hFileHandle == INVALID_HANDLE_VALUE)
	{
		return false;
	}

	if (!CloseHandle(m_hFileHandle))
	{
		SetLastError();
		return false;
	}
	
	m_hFileHandle = INVALID_HANDLE_VALUE;
	return true;
}

bool CFileData::WriteString(LPTSTR tszString, bool fHandleQuotes /* = false */)
{
	DWORD dwByteCount = 0;
	DWORD dwBytesWritten;
	LPSTR szStringBuffer = NULL; // Pointer to the ANSI string (after conversion if necessary)
	bool fReturn = false;

	if (m_hFileHandle == INVALID_HANDLE_VALUE)
	{
		goto cleanup;
	}

	// We'll first convert the string if we need to...

	szStringBuffer = CUtilityFunctions::CopyTSTRStringToAnsi(tszString);

	if (!szStringBuffer)
		goto cleanup;

	dwByteCount = _tcsclen(tszString); // This is the number of characters (not bytes!)

	// See if we were asked to handle quotes, and if there exists a comma or quote in the string
	if ( fHandleQuotes == true && ((strchr(szStringBuffer, ',') || strchr(szStringBuffer, '"' ))) )
	{
		unsigned int iQuotedStringIndex = 0;
		unsigned int iStringBufferIndex = 0;
		
		// Special processing is required... this doesn't happen often, so this 
		// allocation which I'm about to make won't be done regularly...
		LPSTR szQuotedStringBuffer = new char[1024];

		// Did we successfully allocate storage?
		if (!szQuotedStringBuffer)
			goto cleanup;
			
		// Keep going until we're at the end of the string...

		// We start by adding a quote (since we know that we have a comma or quote somewhere...

		szQuotedStringBuffer[iQuotedStringIndex++] = '\"';

		// Keep going until the end of the string...
		while (szStringBuffer[iStringBufferIndex] != '\0')
		{
			// We found a quote
			if (szStringBuffer[iStringBufferIndex] == '"')
			{
				// We found a quote... I'll copy another quote in, and the quote already here
				// will ensure we have two quotes together "" which in a CSV file represents a
				// single quote...
				szQuotedStringBuffer[iQuotedStringIndex++] = '\"';
			}

			// Copy the source char to the dest...
			szQuotedStringBuffer[iQuotedStringIndex++] = szStringBuffer[iStringBufferIndex++];
		}

		// Append the final quote (and \0)...
		szQuotedStringBuffer[iQuotedStringIndex++] = '\"';
		szQuotedStringBuffer[iQuotedStringIndex++] = '\0';

		// Just write out the data the nice, fast way...
		if (!WriteFile(m_hFileHandle, szQuotedStringBuffer, strlen(szQuotedStringBuffer), &dwBytesWritten, NULL))
		{
			delete [] szQuotedStringBuffer;
			goto cleanup;
		}

		delete [] szQuotedStringBuffer;
	} else
	{
		// Just write out the data the nice, fast way...
		if (!WriteFile(m_hFileHandle, szStringBuffer, dwByteCount, &dwBytesWritten, NULL))
		{
			goto cleanup;
		}
	}

	fReturn = true;

cleanup:

	if (szStringBuffer)
		delete [] szStringBuffer;

	return fReturn;
}

bool CFileData::WriteDWORD(DWORD dwNumber)
{
	TCHAR tszBuffer[10+1]; // 0xFFFFFFFF == 4294967295 (10 characters) + 1 for the \0

	_stprintf(tszBuffer, TEXT("%u"), dwNumber);
	
	if (!WriteString(tszBuffer))
		return false;

	return true;
}

bool CFileData::WriteTimeDateString(time_t Time)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];
	struct tm * localTime = localtime(&Time);

	if (localTime)
	{
		// This top version seems to be better Y2K friendly as I spit out the full year...
		_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%B %d, %Y %H:%M:%S"), localTime);
		//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%c"), localtime(&Time));

		if (!WriteString(tszBuffer, true))
			return false;
	} else
	{	// A bad TimeDate stamp was provided
		if (!WriteString(TEXT("<INVALID DATE>"), true))
			return false;
	}
	
	return true;
}

bool CFileData::WriteFileHeader()
{
	enum {BUFFERSIZE = 128};
	TCHAR tszBuffer[BUFFERSIZE];
	DWORD dwNum = BUFFERSIZE;

	// Write the Checksym version info...
	_stprintf(tszBuffer, TEXT("CHECKSYM, (%d.%d:%d.%d)\r\n"), VERSION_FILEVERSION);

	if (!WriteString(tszBuffer))
		return false;

	// Write the current date/time info...

	if (!WriteString(TEXT("Created:,")))
		return false;

	time_t Time;
	time(&Time);

	if (!WriteTimeDateString(Time))
		return false;

	// Write the carriage-return line-feed combo... 
	if (!WriteString(TEXT("\r\n")))
		return false;

	// Spit out the computername
	if (!GetComputerName(tszBuffer, &dwNum))
		return false;

	if (!WriteString(TEXT("Computer:,")))
		return false;

	if (!WriteString(tszBuffer))
		return false;

	// Write the carriage-return line-feed combo... (a couple of times)...
	if (!WriteString(TEXT("\r\n")))
		return false;


	return true;
}

void CFileData::PrintLastError()
{
	CUtilityFunctions::PrintMessageString(GetLastError());
}

bool CFileData::CreateFileMapping()
{
	m_hFileMappingObject = ::CreateFileMapping(m_hFileHandle,
											   NULL,
											   PAGE_READONLY | SEC_COMMIT,
											   0,
											   0,
											   NULL);

	if (m_hFileMappingObject == NULL)
	{
		SetLastError();
		return false;
	}

	// Okay, we'll map the view as well...
	m_lpBaseAddress = MapViewOfFile(m_hFileMappingObject,
							   	    FILE_MAP_READ,
									0,
									0,
									0);

	if (m_lpBaseAddress == NULL)
	{
		SetLastError();
		return false;
	}

	m_lpCurrentFilePointer = (LPSTR) m_lpBaseAddress;

	return true;
}

bool CFileData::ReadFileHeader()
{
	// For starters, let's read a line...
	if (!ReadFileLine())
	     return false;

	enum { BUFFER_SIZE = 128};
	char szTemporaryBuffer[BUFFER_SIZE];
	DWORD cbBytesRead;
		
	cbBytesRead = ReadString(szTemporaryBuffer, BUFFER_SIZE);

	// We gotta read something?
	if (0 == cbBytesRead)
		return false;

	// Look for our "Magic" Value
	if (_stricmp(szTemporaryBuffer, "CHECKSYM"))
	{
		_tprintf(TEXT("Error: Input file has invalid header.  Missing CHECKSYM keyword!\n"));
		return false;
	}

	// Read version number
	// We'll do this later if needed...

	// Read Created Time
	if (!ReadFileLine())
	     return false;

	// Read Computer this was created on
	if (!ReadFileLine())
	     return false;

	return true;
}

bool CFileData::ReadFileLine()
{
	// We're ansi oriented (since this is a CSV file -- in case you were wondering)
	size_t pos;

	// Find the first \r or \n character (if we're point to \0, we'll figure that out)
	pos = strcspn(m_lpCurrentFilePointer, "\r\n");

	// Hmm... we don't read a line that starts on \r\n very well...
	if (pos == 0)
	{
		m_szLINEBUFFER[0] = '\0';
		ResetBufferPointerToStart();
		return false; 
	}

	// Read the line into our buffer
	strncpy(m_szLINEBUFFER, m_lpCurrentFilePointer, pos);

	// Null terminate for ease of use...
	m_szLINEBUFFER[pos] = '\0'; 

	ResetBufferPointerToStart();

	// Advance the current file pointer to just beyond the last character we read...
	// This should advance to the \r\n or \0
	m_lpCurrentFilePointer += pos;

	// We want this file pointer to advance beyond any \r \n chars we may have found...
	while (*m_lpCurrentFilePointer)
	{
		// Advance pointer to non- \r or \n
		if ( (*m_lpCurrentFilePointer == '\r') ||
			 (*m_lpCurrentFilePointer == '\n') )
		{
			 m_lpCurrentFilePointer++;
		}
		else
		{
			break; // Found either the \0 or something else...
		}
	}

	return true;
}

DWORD CFileData::ReadString(LPSTR szStringBuffer, DWORD iStringBufferSize)
{
	// If we give a buffer size, we have to give a buffer...
	if ( szStringBuffer == NULL && iStringBufferSize )
		return 0;

	// The ReadFileLine() call puts us at the start of a line (after
	// the \r \n combinations...  It's possible that we're at the
	// end...

	// If we're pointing to the end of the file, let's bail...
	if (*m_lpCurrentLocationInLINEBUFFER == '\0')
		return 0;

	DWORD iBytesCopied = 0;
	bool fFinished = false;
	bool fFoundSeparatorChars = false; // These might be '\r', '\n', or ','
	bool fQuoteMode = false;

	while (!fFinished)
	{
		switch (*m_lpCurrentLocationInLINEBUFFER)
		{
			case '"':
				// Okay, we found a quote... that's cool.. but are we quoting a quote,
				// or... are we in quote mode?

				// Probe ahead... is the next char a '"' also?
				if ( *(m_lpCurrentLocationInLINEBUFFER+1) == '"')
				{
					// Yes it is... so go ahead and copy the quote
					CopyCharIfRoom(iStringBufferSize, szStringBuffer, &iBytesCopied, &fFinished);
					if (!fFinished)
						*(m_lpCurrentLocationInLINEBUFFER++);	// Skip the quote
				}
				else
				{
					*(m_lpCurrentLocationInLINEBUFFER++);
					fQuoteMode = !fQuoteMode; // Toggle the quote mode...
					continue;
				}

			case '\0':
				fFinished = true;
				break;

			case ',':
				if (!fQuoteMode)
				{   // If we're not in quote mode, then this marks the end of a field...
					fFinished = true;
					fFoundSeparatorChars = true;
					*(m_lpCurrentLocationInLINEBUFFER++);
				}
				else
				{
					// Okay, this marks a new character that happens to be a comma...
					CopyCharIfRoom(iStringBufferSize, szStringBuffer, &iBytesCopied, &fFinished);
				}
				break;

			case '\r':
			case '\n':
				// We note that we found these, and simply advance the pointer...
				fFoundSeparatorChars = true;
				*(m_lpCurrentLocationInLINEBUFFER++);
				break;

			default:

				if (fFoundSeparatorChars)
				{
					// We were scanning... found a separator after some data... so we bail
					fFinished = true;
					break;
				}

				CopyCharIfRoom(iStringBufferSize, szStringBuffer, &iBytesCopied, &fFinished);
		}
	}

	if (iStringBufferSize) // We only NULL terminate a buffer if one was provided...
		szStringBuffer[iBytesCopied] = '\0'; // Null terminate this puppy...

	return iBytesCopied;
}

//
// This function is responsible for reading through the CSV file and creating any necessary
// objects and populating them with data...
//
bool CFileData::DispatchCollectionObject(CProcesses ** lplpProcesses, CProcessInfo ** lplpProcess, CModules ** lplpModules, CModules ** lplpKernelModeDrivers, CModuleInfoCache * lpModuleInfoCache, CFileData * lpOutputFile)
{
	enum { BUFFER_SIZE = 128};
	char szTemporaryBuffer[BUFFER_SIZE];
	TCHAR tszTemporaryBuffer[BUFFER_SIZE];
	DWORD cbBytesRead;
	bool fContinueReading = true;

	// Read the Output Type
	if (!ReadFileLine())
		 return false;

	while (fContinueReading)
	{
		// If this is the second iteration (or more) we may not be at the
		// start of our buffer (causing the read of the output type to fail)
		ResetBufferPointerToStart();

		// Read the Output Type line...
		cbBytesRead = ReadString(szTemporaryBuffer, BUFFER_SIZE);

		// We gotta read something?
		if (0 == cbBytesRead)
			return true;
		
		// I hate to do this... but we read this stuff as ASCII... may need to
		// convert to a TCHAR format to be neutral...
		CUtilityFunctions::CopyAnsiStringToTSTR(szTemporaryBuffer, tszTemporaryBuffer, cbBytesRead+1);

		// Printout the section we're attempting to read...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
			_tprintf(TEXT("  Reading %s data...\n"), tszTemporaryBuffer);

		if ( _tcsicmp(g_tszCollectionArray[Processes].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[PROCESSES]
			*/

			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a Processes Object
			if (*lplpProcesses == NULL)
			{
				// Allocate a structure for our Processes Object.
				*lplpProcesses = new CProcesses();
				
				if (!*lplpProcesses)
				{
					_tprintf(TEXT("Unable to allocate memory for the processes object!\n"));
					goto cleanup;
				}

				// The Processes Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpProcesses)->Initialize(lpModuleInfoCache, this, lpOutputFile))
				{
					_tprintf(TEXT("Unable to initialize Processes Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Process Data...
			(*lplpProcesses)->GetProcessesData();

		} else
		if ( _tcsicmp(g_tszCollectionArray[Process].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[PROCESS]
			*/
			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a ProcessInfo Object
			if (*lplpProcess== NULL)
			{
				// Allocate a structure for our ProcessInfo Object.
				*lplpProcess = new CProcessInfo();
				
				if (!*lplpProcess)
				{
					_tprintf(TEXT("Unable to allocate memory for the processinfo object!\n"));
					goto cleanup;
				}

				// The Modules Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpProcess)->Initialize(lpModuleInfoCache, this, lpOutputFile, NULL))
				{
					_tprintf(TEXT("Unable to initialize Modules Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Process Data
			(*lplpProcess)->GetProcessData();
		} else
		if ( _tcsicmp(g_tszCollectionArray[Modules].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[MODULES]
			*/
			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a Modules Object
			if (*lplpModules == NULL)
			{
				// Allocate a structure for our Modules Object.
				*lplpModules = new CModules();
				
				if (!*lplpModules)
				{
					_tprintf(TEXT("Unable to allocate memory for the modules object!\n"));
					goto cleanup;
				}

				// The Modules Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpModules)->Initialize(lpModuleInfoCache, this, lpOutputFile, NULL))
				{
					_tprintf(TEXT("Unable to initialize Modules Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Modules Data (collected from the filesystem)
			(*lplpModules)->GetModulesData(CProgramOptions::InputModulesDataFromFileSystemMode, true);
		} else
		if ( _tcsicmp(g_tszCollectionArray[KernelModeDrivers].tszCSVLabel, tszTemporaryBuffer) == 0 )
		{
			/*
				[KERNEL-MODE DRIVERS]
			*/
			// Read to the end of the line
			if (!ReadFileLine())
				return false;

			// Yup, it is... let's create a Modules Object
			if (*lplpKernelModeDrivers == NULL)
			{
				// Allocate a structure for our Modules Object.
				*lplpKernelModeDrivers = new CModules();
				
				if (!*lplpKernelModeDrivers)
				{
					_tprintf(TEXT("Unable to allocate memory for the modules object!\n"));
					goto cleanup;
				}

				// The Modules Object will init differently depending on what
				// Command-Line arguments have been provided... 
				if (!(*lplpKernelModeDrivers)->Initialize(lpModuleInfoCache, this, lpOutputFile, NULL))
				{
					_tprintf(TEXT("Unable to initialize Modules Object!\n"));
					goto cleanup;
				}
			}

			// Okay, go get the Modules Data (collected from the filesystem)
			(*lplpKernelModeDrivers)->GetModulesData(CProgramOptions::InputDriversFromLiveSystemMode, true);
		} else
		{
			_tprintf(TEXT("Unrecognized section %s found!\n"), tszTemporaryBuffer);
			return false;
		}
	}

cleanup:
	return false;
}

bool CFileData::ReadDWORD(LPDWORD lpDWORD)
{
	char szTempBuffer[10+1]; // 0xFFFFFFFF == 4294967295 (10 characters) + 1 for the \0

	if (!ReadString(szTempBuffer, 10+1))
		return false;

	// Convert it... baby...
	*lpDWORD = atoi(szTempBuffer);

	return true;
}

bool CFileData::CopyCharIfRoom(DWORD iStringBufferSize, LPSTR szStringBuffer, LPDWORD piBytesCopied, bool *pfFinished)
{
	if (iStringBufferSize)
	{
		// If we have room to copy the data... let's do it...
		if (*piBytesCopied < iStringBufferSize)
		{
			szStringBuffer[(*piBytesCopied)++] = *(m_lpCurrentLocationInLINEBUFFER++);
		} else
		{
			// No room... we're done.
			*pfFinished = true;
		}
	} else
	{
		// Just advance the pointer... we have no buffer to copy to...
		*(m_lpCurrentLocationInLINEBUFFER++);
	}

	return true;
}

bool CFileData::ResetBufferPointerToStart()
{
	// Reset the Pointer with our line buffer to the start of this buffer
	m_lpCurrentLocationInLINEBUFFER = m_szLINEBUFFER;

	return true;
}

bool CFileData::EndOfFile()
{
	//return (*m_lpCurrentFilePointer == '\0');
	return (*m_lpCurrentLocationInLINEBUFFER == '\0');
}

bool CFileData::WriteFileTimeString(FILETIME ftFileTime)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];
	FILETIME ftLocalFileTime;
	SYSTEMTIME lpSystemTime;
	int cch = 0;

	// Let's convert this to a local file time first...
	if (!FileTimeToLocalFileTime(&ftFileTime, &ftLocalFileTime))
		return false;

	FileTimeToSystemTime( &ftLocalFileTime, &lpSystemTime );

	
	cch = GetDateFormat( LOCALE_USER_DEFAULT,
						 0,
						 &lpSystemTime,
						 TEXT("MMMM d',' yyyy"),
						 tszBuffer,
						 BUFFERSIZE );

	if (!cch)
		return false;

	tszBuffer[cch-1] = TEXT(' '); 

	// 
    // Get time and format to characters 
    // 
 
    GetTimeFormat( LOCALE_USER_DEFAULT, 
				   0, 
				   &lpSystemTime,   // use current time 
				   NULL,   // use default format 
				   tszBuffer + cch, 
				   BUFFERSIZE - cch ); 
 

	// <Full Month Name> <day>, <Year with Century> <Hour>:<Minute>:<Second>
	//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%B %d, %Y %H:%M:%S"), localtime(&Time));
	//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%c"), localtime(&Time));

	if (!WriteString(tszBuffer, true))
		return false;

	return true;
}

// Exception Monitor prefers a MM/DD/YYYY HH:MM:SS format...
bool CFileData::WriteTimeDateString2(time_t Time)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];

	// This top version seems to be better Y2K friendly as I spit out the full year...
	_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%m/%d/%Y %H:%M:%S"), localtime(&Time));
	//_tcsftime(tszBuffer, BUFFERSIZE, TEXT("%c"), localtime(&Time));

	if (!WriteString(tszBuffer, true))
		return false;

	return true;
}

// Exception Monitor prefers a MM/DD/YYYY HH:MM:SS format...
bool CFileData::WriteFileTimeString2(FILETIME ftFileTime)
{
	enum {BUFFERSIZE = 128};

	TCHAR tszBuffer[BUFFERSIZE];
	FILETIME ftLocalFileTime;
	SYSTEMTIME lpSystemTime;
	int cch = 0;

	// Let's convert this to a local file time first...
	if (!FileTimeToLocalFileTime(&ftFileTime, &ftLocalFileTime))
		return false;

	FileTimeToSystemTime( &ftLocalFileTime, &lpSystemTime );

	
	cch = GetDateFormat( LOCALE_USER_DEFAULT,
						 0,
						 &lpSystemTime,
						 TEXT("MM/dd/yyyy"),
						 tszBuffer,
						 BUFFERSIZE );

	if (!cch)
		return false;

	tszBuffer[cch-1] = TEXT(' '); 

	// 
    // Get time and format to characters 
    // 
 
    GetTimeFormat( LOCALE_USER_DEFAULT, 
				   0, 
				   &lpSystemTime,   // use current time 
				   TEXT("HH:mm:ss"),   // use default format 
				   tszBuffer + cch, 
				   BUFFERSIZE - cch ); 

	if (!WriteString(tszBuffer, true))
		return false;

	return true;
}

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\main.h ===
// Main.h

#if !defined(AFX_MAIN_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_)
#define AFX_MAIN_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------
#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "Globals.h"
#include "DelayLoad.h"
#include "ProgramOptions.h"
#include "Processes.h"
#include "ProcessInfo.h"
#include "SymbolVerification.h"
#include "ModuleInfoCache.h"
#include "FileData.h"
#include "Modules.h"
#include "UtilityFunctions.h"
#include "DmpFile.h"

//#if ( _MSC_VER < 1200 )
//extern "C"
//{
//#endif


#ifdef CHECKSYM_TEST
#include "CheckSym_test.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//#ifdef _UNICODE
// Adding support for Unicode on Ansi systems (Win9x)
//#include "CheckSym_UAPI.h"
//#endif

#ifndef CHECKSYM_TEST

// Normal startup!
int _cdecl _tmain(int argc, TCHAR *argv[])
{
	int iReturnCode = EXIT_FAILURE;

#else

// Startup for testing... no command-line is interpreted...
int _tmain()
{
	// We'll populate this below for every test run...
	int argc = 0;
	TCHAR ** argv = NULL;
	LPTSTR tszPointerToCurrentArgument = NULL;
	int iArgvIndex;
	LPTSTR tszCopyOfTestString = NULL;
	bool fFoundNextArgument, fQuoteMode;
	int iReturnCode = EXIT_FAILURE;

	int iTotalNumberOfTests = sizeof(g_TestArguments) / sizeof(g_TestArguments[0]);

	_tprintf(TEXT("\n\n"));
	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("ABOUT TO BEGIN %d TESTS!\n"), iTotalNumberOfTests);
	CUtilityFunctions::OutputLineOfStars();

	for (int iTestNumber = 0; iTestNumber < iTotalNumberOfTests; iTestNumber++)
	{
		_tprintf(TEXT("\n\n\n"));
		CUtilityFunctions::OutputLineOfStars();
		CUtilityFunctions::OutputLineOfStars();
			_tprintf(TEXT("TESTING [%3d]: %s\n"), iTestNumber, g_TestArguments[iTestNumber].tszTestDescription );
		CUtilityFunctions::OutputLineOfStars();
		CUtilityFunctions::OutputLineOfStars();
		_tprintf(TEXT("\n\n"));
#endif

	// Initialize our object pointers...
	CSymbolVerification * lpSymbolVerification = NULL;
		
	// Processes/Modules data collected on this machine
	CProcesses * lpLocalSystemProcesses = NULL;			// -P Option
	CModules * lpLocalFileSystemModules = NULL;			// -F Option
	CModules * lpKernelModeDrivers = NULL;				// -D Option

	// CSV File Support
	CFileData * lpCSVInputFile = NULL;					// -I Option
	CFileData * lpCSVOutputFile = NULL;					// -O Option

	CProcesses * lpCSVProcesses = NULL;					// [PROCESSES]
	CProcessInfo * lpCSVProcess = NULL;					// [PROCESS]
	CModules *	 lpCSVModulesFromFileSystem = NULL;		// [FILESYSTEM MODULES]
	CModules *	 lpCSVKernelModeDrivers = NULL;			// [KERNEL-MODE DRIVERS]

	//
	// Module Caches (these implement separate name spaces for the modules collected)
	//
	// It is important that we separate the modules in these caches because a module
	// from a CSV file should not be assumed to be the same module if you also happen
	// to collect it from a DMP file... or your local system...
	
	CModuleInfoCache * lpLocalSystemModuleInfoCache = NULL; // Contains Local System modules
	CModuleInfoCache * lpCSVModuleInfoCache = NULL;			// Contains CSV modules
	CModuleInfoCache * lpDmpModuleInfoCache = NULL;			// Contains user.dmp & kernel.dmp modules
	
	long lTotalNumberOfModulesVerified = 0;
	long lTotalNumberOfVerifyErrors = 0;

	// Support for Dmp Files...
	CDmpFile * lpDmpFile = NULL;	// This object allows a Dump file (user/kernel) to be manipulated
	CProcessInfo * lpDmpFileUserModeProcess = NULL; // User.dmp files use this object to contain modules
	CModules   * lpDmpFileKernelModeDrivers = NULL; // Memory.dmp files use this object to contain modules

	// Allocate local values
	bool fQuietMode = false;

//#ifdef _UNICODE
	// First, we need to enable the Unicode APIs (if this is a Win9x machine)...
//	if (!InitUnicodeAPI())
//	{
//		goto cleanup;
//	}
//#endif

	// Let's populate our Globals!
	g_lpDelayLoad = new CDelayLoad();
	g_lpProgramOptions = new CProgramOptions();

	if (!g_lpDelayLoad && !g_lpProgramOptions)
		goto cleanup;
	
	// Initialize Options to their defaults...
	if (!g_lpProgramOptions->Initialize())
	{
		_tprintf(TEXT("Unable to initialize Program Options!\n"));
		goto cleanup;
	}

#ifdef CHECKSYM_TEST
	// Okay, we need to create the appearance of a true argc, and argv (argc is easy)...
	argc = g_TestArguments[iTestNumber].nArguments;

	argv = new LPTSTR[argc];

	if (!argv)
		goto cleanup;

	// Okay, we need to populate the argv with pointers...

	tszCopyOfTestString = CUtilityFunctions::CopyString(g_TestArguments[iTestNumber].tszCommandLineArguments);

	if (!tszCopyOfTestString)
		goto cleanup;

	tszPointerToCurrentArgument = tszCopyOfTestString;

	for (iArgvIndex = 0; iArgvIndex < argc; iArgvIndex++)
	{
		// Hey... if the first character is a quote skip it and enter quote mode...
		if (*tszPointerToCurrentArgument == '\"')
		{
			// Advance to next character..
			tszPointerToCurrentArgument = _tcsinc(tszPointerToCurrentArgument);
			fQuoteMode = true;
		} else
		{
			fQuoteMode = false;
		}

		// We should be pointing to our next argument...
		argv[iArgvIndex] = tszPointerToCurrentArgument;

		fFoundNextArgument = false;

		// Keep hunting for the next argument and leave our pointer pointing to it...
		while (!fFoundNextArgument)
		{
			// Now, we need to find the next argument... look for either a quote or a space...
			tszPointerToCurrentArgument = _tcspbrk( tszPointerToCurrentArgument, TEXT(" \"") );
			
			// If this returns NULL, then we're at the end...
			if (!tszPointerToCurrentArgument)
			{
				break;
			}
			// If we found a space... then we have our next argument if we're not in quote mode..
			if (*tszPointerToCurrentArgument == ' ')
			{
				if (fQuoteMode == true)
				{
					// We're in quote mode...

					// Advance to next argument..
					tszPointerToCurrentArgument = _tcsinc(tszPointerToCurrentArgument);
					continue;
				} else
				{
					// Hey, we found our argument!
					fFoundNextArgument = true;
					
					// Null terminate our last argument
					*tszPointerToCurrentArgument = '\0';
					
					// Advance to next argument..
					tszPointerToCurrentArgument = _tcsinc(tszPointerToCurrentArgument);
					continue;
				}
			} else if (*tszPointerToCurrentArgument == '\"')
			{
				// If the next character happens to be a space... then this is the final
				// quote in a quoted argument... go ahead and nuke it and skip to next
				// argument...
				if (fQuoteMode && *_tcsinc(tszPointerToCurrentArgument) == ' ')
				{
					*tszPointerToCurrentArgument = NULL;
				}

				// Reverse the value of our mode...
				fQuoteMode = !fQuoteMode;

				// Advance to next argument..
				tszPointerToCurrentArgument = _tcsinc(tszPointerToCurrentArgument);
			}
		}
	}
#endif
	// Take care of the commandline...
	if (!g_lpProgramOptions->ProcessCommandLineArguments(argc, argv))
	{
		// An error occurred, simply comment about how to get more assistance
		_tprintf(TEXT("\n"));
		_tprintf(TEXT("For simple help, type:   CHECKSYM -?\n"));
		_tprintf(TEXT("For extended help, type: CHECKSYM -???\n"));
		goto cleanup;
	}

	// Do we need to display help?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::HelpMode) ) 
	{
		g_lpProgramOptions->DisplayHelp();
		goto cleanup;
	}

	// Do we need to display simple help?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::SimpleHelpMode) )
	{
		g_lpProgramOptions->DisplaySimpleHelp();
		goto cleanup;
	}
	
#ifdef _UNICODE
	// It's unsupported running the UNICODE version on a Windows Platform
	if (g_lpProgramOptions->IsRunningWindows())
	{
		_tprintf(TEXT("The UNICODE version of CHECKSYM does not work on a Windows platform!\n"));
		_tprintf(TEXT("You require the ANSI version.\n"));
		goto cleanup;
	}
#endif

	// Let's suppress nasty critical errors (like... there's no
	// disk in the cd-rom drive, etc...)
	SetErrorMode(SEM_FAILCRITICALERRORS);

	// Let's save this for ease of access...
	fQuietMode = g_lpProgramOptions->GetMode(CProgramOptions::QuietMode);

	// Dump the program arguments (so it's obvious what we're going to do)
	g_lpProgramOptions->DisplayProgramArguments();

	// DBGHELP FUNCTIONS?
	// Do we need to instantiate a CDBGHelpFunctions Object?  We do if we need to call...
	// - MakeSureDirectoryPathExists()   Used for the -B (build symbol tree) option
	if ( g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		// Now, we need to build the symbol tree root...
		if ( !g_lpDelayLoad->MakeSureDirectoryPathExists(g_lpProgramOptions->GetSymbolTreeToBuild()) )
		{
			_tprintf(TEXT("ERROR: Unable to create symbol tree root [%s]\n"), g_lpProgramOptions->GetSymbolTreeToBuild() );
			CUtilityFunctions::PrintMessageString(GetLastError());
			goto cleanup;
		}
	}
	
	//  VERIFICATION OPTION: -V (verification)?
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		// Allocate a structure for our symbol verification object.
		lpSymbolVerification = new CSymbolVerification();

		if (!lpSymbolVerification)
		{
			_tprintf(TEXT("Unable to allocate memory for a verification symbol object!\n"));
			goto cleanup;
		}

		// Initialize Symbol Verification (if necessary)
		if (!lpSymbolVerification->Initialize())
		{
			_tprintf(TEXT("Unable to initialize Symbol Verification object!\n"));
			goto cleanup;
		}
	}

	//
	// Allocate a structure for our ModuleInfoCache if we're getting anything from the local system
	//
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode) ||
		 g_lpProgramOptions->GetMode(CProgramOptions::InputDriversFromLiveSystemMode) ||
		 g_lpProgramOptions->GetMode(CProgramOptions::InputModulesDataFromFileSystemMode) )
	{
		lpLocalSystemModuleInfoCache= new CModuleInfoCache();

		// Check for out of memory condition...
		if ( lpLocalSystemModuleInfoCache == NULL )
		{
			_tprintf(TEXT("Unable to allocate memory for the ModuleInfoCache object!\n"));
			goto cleanup;
		}

		// Initialize Options to their defaults...
		if (!lpLocalSystemModuleInfoCache->Initialize(lpSymbolVerification))
		{
			_tprintf(TEXT("Unable to initialize ModuleInfoCache!\n"));
			goto cleanup;
		}
	}

	//
	// Allocate a structure for our CSVModuleInfoCache (if needed)... we need a separate
	// ModuleInfoCache space because the location of files on a remote system
	// files and we don't want to clash...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		// We need a Module Info Cache for these CSV data (it all was collected from
		// the same system (supposedly)
		lpCSVModuleInfoCache= new CModuleInfoCache();

		// Check for out of memory condition...
		if ( lpCSVModuleInfoCache == NULL )
		{
			_tprintf(TEXT("Unable to allocate memory for the CSVModuleInfoCache object!\n"));
			goto cleanup;
		}

		// Initialize Options to their defaults...
		if (!lpCSVModuleInfoCache->Initialize(lpSymbolVerification))
		{
			_tprintf(TEXT("Unable to initialize CSVModuleInfoCache!\n"));
			goto cleanup;
		}
	}

	//
	// Since we're going to read in a file... try and open it now...
	// This has the advantage of detecting problems accessing the file
	// when we've spent tons of time collecting data...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		// Create the file object
		lpCSVInputFile = new CFileData();

		if (!lpCSVInputFile)
		{
			_tprintf(TEXT("Unable to allocate memory for an input file object!\n"));
			goto cleanup;
		}

		// Set the input file path
		if (!lpCSVInputFile->SetFilePath(g_lpProgramOptions->GetInputFilePath()))
		{
			_tprintf(TEXT("Unable set input file path in the file data object!  Out of memory?\n"));
			goto cleanup;
		}

		// If we are going to produce an input file... try to do that now...
		if (!lpCSVInputFile->OpenFile(OPEN_EXISTING, true)) // Must exist, read only mode...
		{
			_tprintf(TEXT("Unable to open the input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}

		// Reading is so much easier in memory mapped mode...
		if (!lpCSVInputFile->CreateFileMapping())
		{
			_tprintf(TEXT("Unable to CreateFileMapping of the input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}

		// Go ahead and read in the header of the file (validate it).
		// Reading is so much easier in memory mapped mode...
		if (!lpCSVInputFile->ReadFileHeader())
		{
			_tprintf(TEXT("Invalid header found on input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}
	}

	// If we specified an output file, this is where we go ahead and allocate memory 
	// for the object
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Allocate a structure for our output fileData Object...
		lpCSVOutputFile = new CFileData();

		if (!lpCSVOutputFile )
		{
			_tprintf(TEXT("Unable to allocate memory for an output file object!\n"));
			goto cleanup;
		}
	}

	// INPUT METHOD: -Z Option?  (Dump files?)
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputDmpFileMode))
	{
		if (!fQuietMode)
			_tprintf(TEXT("\nReading Data from DMP File...\n"));

		// Create a Module Info Cache namespace to contain any modules found...
		lpDmpModuleInfoCache = new CModuleInfoCache();

		// Check for out of memory condition...
		if ( lpDmpModuleInfoCache == NULL )
		{
			_tprintf(TEXT("Unable to allocate memory for the DmpModuleInfoCache object!\n"));
			goto cleanup;
		}

		// Initialize Options to their defaults...
		if (!lpDmpModuleInfoCache->Initialize(lpSymbolVerification))
		{
			_tprintf(TEXT("Unable to initialize DmpModuleInfoCache!\n"));
			goto cleanup;
		}
		// Create the DMP File object
		lpDmpFile = new CDmpFile();

		if (!lpDmpFile)
		{
			_tprintf(TEXT("Unable to allocate memory for a DMP file object!\n"));
			goto cleanup;
		}

		// Initialize the DMP File
		if (!lpDmpFile->Initialize(lpCSVOutputFile))
		{
			_tprintf(TEXT("ERROR: Unable to initialize DMP file!\n"));
			goto cleanup;
		}
	
		// Header is good... so let's go ahead and get some data...
		if (!lpDmpFile->CollectData(&lpDmpFileUserModeProcess, &lpDmpFileKernelModeDrivers, lpDmpModuleInfoCache) )
		{
			_tprintf(TEXT("ERROR: Unable to collect data from the DMP file!\n"));
		}
	}
	
	// INPUT METHOD: -i Option?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		if (!fQuietMode)
			_tprintf(TEXT("\nReading Data from Input File...\n"));

		// Header is good... so let's go ahead and dispatch
		if (!lpCSVInputFile->DispatchCollectionObject(&lpCSVProcesses, &lpCSVProcess, &lpCSVModulesFromFileSystem, &lpCSVKernelModeDrivers, lpCSVModuleInfoCache, lpCSVOutputFile))
		{
			_tprintf(TEXT("Failure reading data collection from input file %s.\n"), lpCSVInputFile->GetFilePath());
			lpCSVInputFile->PrintLastError();
			goto cleanup;
		}
	}

	// INPUT METHOD: -p Option?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode) )
	{
		// Allocate a structure for our Processes Object.
		lpLocalSystemProcesses = new CProcesses();
		
		if (!lpLocalSystemProcesses)
		{
			_tprintf(TEXT("Unable to allocate memory for the processes object!\n"));
			goto cleanup;
		}

		// The Processes Object will init differently depending on what
		// Command-Line arguments have been provided... 
		if (!lpLocalSystemProcesses->Initialize(lpLocalSystemModuleInfoCache, NULL, lpCSVOutputFile))
		{
			_tprintf(TEXT("Unable to initialize Processes Object!\n"));
			goto cleanup;
		}

		// Mention the delay...
		if (!( fQuietMode || 
			   g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode)
           ) )
			_tprintf(TEXT("\nCollecting Process Data.... (this may take a few minutes)\n"));
		
		// Get the goods from the local system!
		lpLocalSystemProcesses->GetProcessesData();
	}

	// INPUT METHOD: -f OPTION?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputModulesDataFromFileSystemMode) )
	{
		// Allocate a structure for our CModules collection (a generic collection of
		// files from the filesystem)

		// Allocate a structure for our Processes Object.
		lpLocalFileSystemModules = new CModules();
		
		if (!lpLocalFileSystemModules)
		{
			_tprintf(TEXT("Unable to allocate memory for the CModules object!\n"));
			goto cleanup;
		}

		if (!lpLocalFileSystemModules->Initialize(lpLocalSystemModuleInfoCache, NULL, lpCSVOutputFile, NULL))
		{
			_tprintf(TEXT("Unable to initialize FileSystemModules Object!\n"));
			goto cleanup;
		}

		if (!fQuietMode)
			_tprintf(TEXT("\nCollecting Modules Data from file path.... (this may take a few minutes)\n"));
		
		lpLocalFileSystemModules->GetModulesData(CProgramOptions::InputModulesDataFromFileSystemMode);
	}

	// INPUT METHOD: -d OPTION?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::InputDriversFromLiveSystemMode) )
	{
		// Allocate a structure for our CModules collection (a generic collection of
		// files from the filesystem)

		// Allocate a structure for our Processes Object.
		lpKernelModeDrivers = new CModules();
		
		if (!lpKernelModeDrivers)
		{
			_tprintf(TEXT("Unable to allocate memory for the CModules object!\n"));
			goto cleanup;
		}

		if (!lpKernelModeDrivers->Initialize(lpLocalSystemModuleInfoCache, NULL, lpCSVOutputFile, NULL))
		{
			_tprintf(TEXT("Unable to initialize Modules Object!\n"));
			goto cleanup;
		}

		if (!fQuietMode)
			_tprintf(TEXT("\nCollecting Device Driver Data.... (this may take a few minutes)\n"));
		
		lpKernelModeDrivers->GetModulesData(CProgramOptions::InputDriversFromLiveSystemMode);
	}

	// If we specified an output file, this is where we go ahead and allocate memory 
	// for the object
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Do we have any data to output?  If we have any data in cache... we should...
		if ( ( lpLocalSystemModuleInfoCache && lpLocalSystemModuleInfoCache->GetNumberOfModulesInCache() ) ||
			 ( lpCSVModuleInfoCache && lpCSVModuleInfoCache->GetNumberOfModulesInCache() ) ||
			 ( lpDmpModuleInfoCache && lpDmpModuleInfoCache->GetNumberOfModulesInCache() )
		   )
		{
			// Set the output file path
			if (!lpCSVOutputFile->SetFilePath(g_lpProgramOptions->GetOutputFilePath()))
			{
				_tprintf(TEXT("Unable set output file path in the file data object!  Out of memory?\n"));
				goto cleanup;
			}

			// Verify the output file directory...
			if (!lpCSVOutputFile ->VerifyFileDirectory())
			{
				_tprintf(TEXT("Directory provided is invalid!\n"));
				lpCSVOutputFile->PrintLastError();
				goto cleanup;
			}

			// If we are going to produce an output file... try to do that now...
			if ( !lpCSVOutputFile->OpenFile(g_lpProgramOptions->GetMode(CProgramOptions::OverwriteOutputFileMode) ? CREATE_ALWAYS : CREATE_NEW) )
			{
				_tprintf(TEXT("Unable to create the output file %s.\n"), lpCSVOutputFile->GetFilePath());
				lpCSVOutputFile->PrintLastError();
				goto cleanup;
			}

			// We skip output of the file header if -E was specified...
			if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
			{
				// Write the file header!
				if (!lpCSVOutputFile->WriteFileHeader())
				{
					_tprintf(TEXT("Unable to write the output file header.\n"));
					lpCSVOutputFile->PrintLastError();
					goto cleanup;
				}
			}
		} else
		{
			// Nothing to output... do not enable this mode...
			g_lpProgramOptions->SetMode(CProgramOptions::OutputCSVFileMode, false);
		}
	}

	// Do we verify symbols on this machine?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode) && 
		 ( lpLocalSystemModuleInfoCache || lpCSVModuleInfoCache || lpDmpModuleInfoCache) )
	{
		// If there is any data in any of our caches... we need to verify them...

		// Do a Verify on the ModuleCache... (We'll be quiet in QuietMode or when Building a Symbol Tree)
		if (lpLocalSystemModuleInfoCache)
		{
			if (!fQuietMode)
				_tprintf(TEXT("\nVerifying %d Modules from this System...\n"), lpLocalSystemModuleInfoCache->GetNumberOfModulesInCache());

			lpLocalSystemModuleInfoCache->VerifySymbols( fQuietMode ||
											  g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode)
											 );

			// Update our stats...
			lTotalNumberOfModulesVerified = lTotalNumberOfModulesVerified + lpLocalSystemModuleInfoCache->GetNumberOfModulesVerified();
			lTotalNumberOfVerifyErrors = lTotalNumberOfVerifyErrors + lpLocalSystemModuleInfoCache->GetNumberOfVerifyErrors();
		}

		// Do a Verify on the ModuleCache... (We'll be quiet in QuietMode or when Building a Symbol Tree)
		if (lpCSVModuleInfoCache)
		{
			if (!fQuietMode)
				_tprintf(TEXT("\nVerifying %d Modules from the CSV file...\n"), lpCSVModuleInfoCache->GetNumberOfModulesInCache());

			lpCSVModuleInfoCache->VerifySymbols( fQuietMode ||
										  g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode)
										 );

			// Update our stats...
			lTotalNumberOfModulesVerified = lTotalNumberOfModulesVerified + lpCSVModuleInfoCache->GetNumberOfModulesVerified();
			lTotalNumberOfVerifyErrors = lTotalNumberOfVerifyErrors + lpCSVModuleInfoCache->GetNumberOfVerifyErrors();
		}

		// Do a Verify on the ModuleCache... (We'll be quiet in QuietMode or when Building a Symbol Tree)
		if (lpDmpModuleInfoCache)
		{
			if (!fQuietMode)
				_tprintf(TEXT("\nVerifying %d Modules from the DMP file...\n"), lpDmpModuleInfoCache->GetNumberOfModulesInCache());

			lpDmpModuleInfoCache->VerifySymbols( fQuietMode ||
										  g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode)
										 );

			// Update our stats...
			lTotalNumberOfModulesVerified = lTotalNumberOfModulesVerified + lpDmpModuleInfoCache->GetNumberOfModulesVerified();
			lTotalNumberOfVerifyErrors = lTotalNumberOfVerifyErrors + lpDmpModuleInfoCache->GetNumberOfVerifyErrors();
		}

	}

	// OUTPUT Phase!

	//
	// PROCESS COLLECTIONS FIRST!!!!
	//

	// Let's output local system processes first!
	if (lpLocalSystemProcesses)
		lpLocalSystemProcesses->OutputProcessesData(Processes, false);

	// Let's output CSV Processes next...
	if (lpCSVProcesses)
		lpCSVProcesses->OutputProcessesData(Processes, true);
	
	// If we're going to Dump to a USER.DMP file... do it...

	// Dump the data from a USER.DMP file... if we have one...
	if (lpDmpFileUserModeProcess)
		lpDmpFileUserModeProcess->OutputProcessData(Process, false, true);

	// let's output CSV Process next...
	if (lpCSVProcess)
		lpCSVProcess->OutputProcessData(Processes, true);

	//
	// MODULE COLLECTIONS SECOND!!!!
	//
	
	// Dump modules we found from our local file system first...
	if (lpLocalFileSystemModules)
		lpLocalFileSystemModules->OutputModulesData(Modules, false);
	
	// Dump modules from the CSV file second...
	if (lpCSVModulesFromFileSystem)
		lpCSVModulesFromFileSystem->OutputModulesData(Modules, true);
	
	// Dump device drivers from our local system first
	if (lpKernelModeDrivers)
		lpKernelModeDrivers->OutputModulesData(KernelModeDrivers, false);
	
	if (lpDmpFileKernelModeDrivers)
		lpDmpFileKernelModeDrivers->OutputModulesData(KernelModeDrivers, false);
	
	if (lpCSVKernelModeDrivers)
		lpCSVKernelModeDrivers->OutputModulesData(KernelModeDrivers, true);

	// Dump device drivers from our CSV file second...
	// ISSUE-2000/07/24-GREGWI: Add support for Device Drivers here...
	//
	
	// DISPLAY RESULTS (IF VERIFICATION WAS USED)
	//

	// Dump the verification results...
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode) &&
		!fQuietMode)
	{
		long lPercentageSuccessfullyVerified = 0;

		if (lTotalNumberOfModulesVerified)
			lPercentageSuccessfullyVerified = (lTotalNumberOfModulesVerified - lTotalNumberOfVerifyErrors) * 100 / lTotalNumberOfModulesVerified;

		_tprintf(TEXT("RESULTS: %d Total Files Checked, Total %d Verification Errors Found\n"), lTotalNumberOfModulesVerified , lTotalNumberOfVerifyErrors );
		_tprintf(TEXT("RESULTS: Percentage Verified Successfully = %d%%\n"), lPercentageSuccessfullyVerified);

		// Return an error level equal to the number of errors found (0 == EXIT_SUCCESS)
		iReturnCode = lTotalNumberOfVerifyErrors;

	} else
	{
		// Success!
		iReturnCode = EXIT_SUCCESS;
	}


cleanup:

	// If we specified an output file, this is where we close it...
	if (lpCSVOutputFile)
	{
		// Try and close the file this object is bound to...
		lpCSVOutputFile->CloseFile();

		// Free the memory...
		delete lpCSVOutputFile;
		lpCSVOutputFile = NULL;
	}

	// If we specified an input file, this is where we close it...
	if (lpCSVInputFile)
	{
		// Try and close the file this object is bound to...
		lpCSVInputFile->CloseFile();

		// Free the memory...
		delete lpCSVInputFile;
		lpCSVInputFile = NULL;
	}

	if (g_lpDelayLoad)
	{
		delete g_lpDelayLoad;
		g_lpDelayLoad = NULL;
	}

	if (g_lpProgramOptions)
	{
		delete g_lpProgramOptions;
		g_lpProgramOptions = NULL;
	}

	if (lpLocalSystemProcesses)
	{
		delete lpLocalSystemProcesses;
		lpLocalSystemProcesses = NULL;
	}

	if (lpSymbolVerification)
	{
		delete lpSymbolVerification;
		lpSymbolVerification = NULL;
	}

	if (lpCSVKernelModeDrivers)
	{
		delete lpCSVKernelModeDrivers;
		lpCSVKernelModeDrivers = NULL;
	}

	if (lpCSVProcesses)
	{
		delete lpCSVProcesses;
		lpCSVProcesses = NULL;
	}

	if (lpCSVProcess)
	{
		delete lpCSVProcess;
		lpCSVProcess = NULL;
	}

	if (lpCSVModulesFromFileSystem)
	{
		delete lpCSVModulesFromFileSystem;
		lpCSVModulesFromFileSystem = NULL;
	}

	if (lpLocalSystemModuleInfoCache)
	{
		delete lpLocalSystemModuleInfoCache;
		lpLocalSystemModuleInfoCache = NULL;
	}

	if (lpCSVModuleInfoCache)
	{
		delete lpCSVModuleInfoCache;
		lpCSVModuleInfoCache = NULL;
	}

	if (lpDmpModuleInfoCache)
	{
		delete lpDmpModuleInfoCache;
		lpDmpModuleInfoCache = NULL;
	}

	if (lpLocalFileSystemModules)
	{
		delete lpLocalFileSystemModules;
		lpLocalFileSystemModules = NULL;
	}

	if (lpKernelModeDrivers)
	{
		delete lpKernelModeDrivers;
		lpKernelModeDrivers = NULL;
	}

	if (lpDmpFile)
	{
		delete lpDmpFile;
		lpDmpFile = NULL;
	}

	if (lpDmpFileUserModeProcess)
	{
		delete lpDmpFileUserModeProcess;
		lpDmpFileUserModeProcess = NULL;
	}

	if (lpDmpFileKernelModeDrivers)
	{
		delete lpDmpFileKernelModeDrivers;
		lpDmpFileKernelModeDrivers = NULL;
	}

#ifdef CHECKSYM_TEST
		if (argv)
		{
			delete [] argv;
			argv = NULL;
		}

		if (tszCopyOfTestString)
		{
			delete [] tszCopyOfTestString;
			tszCopyOfTestString = NULL;
		}

	} // Return for more tests?
#endif
	
	return iReturnCode;
}

//#if ( _MSC_VER < 1200 )
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\moduleinfocache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfocache.h
//
//--------------------------------------------------------------------------

// ModuleInfoCache.h: interface for the CModuleInfoCache class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULEINFOCACHE_H__2D4FCE63_C369_11D2_842B_0010A4F1B732__INCLUDED_)
#define AFX_MODULEINFOCACHE_H__2D4FCE63_C369_11D2_842B_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <windows.h>

// Forward declarations
class CModuleInfo;
class CModuleInfoNode;
class CSymbolVerification;

class CModuleInfoCache  
{
public:
	CModuleInfoCache();
	virtual ~CModuleInfoCache();

	bool Initialize(CSymbolVerification * lpSymbolVerification);
	CModuleInfo * AddNewModuleInfoObject(LPTSTR tszModulePath, bool * pfNew);
	bool VerifySymbols(bool fQuietMode);

	inline DWORD GetNumberOfModulesInCache() { return m_iModulesInCache; };
	inline long GetNumberOfVerifyErrors() { return m_iNumberOfErrors; };
	inline long GetNumberOfModulesVerified() { return m_iTotalNumberOfModulesVerified; };

protected:
	HANDLE m_hModuleInfoCacheMutex;
	long m_iModulesInCache;
	long m_iTotalNumberOfModulesVerified;
	CModuleInfoNode * m_lpModuleInfoNodeHead;
	CSymbolVerification * m_lpSymbolVerification;
	long m_iNumberOfErrors;  // Used to return error level...

	CModuleInfo * SearchForModuleInfoObject(LPTSTR tszModulePath);
};

#endif // !defined(AFX_MODULEINFOCACHE_H__2D4FCE63_C369_11D2_842B_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\moduleinfocache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfocache.cpp
//
//--------------------------------------------------------------------------

// ModuleInfoCache.cpp: implementation of the CModuleInfoCache class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>

#include "ModuleInfoCache.h"
#include "ModuleInfo.h"
#include "ModuleInfoNode.h"
#include "ProgramOptions.h"
#include "Globals.h"
#include "UtilityFunctions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModuleInfoCache::CModuleInfoCache()
{
	m_iModulesInCache = 0;
	m_iNumberOfErrors = 0;
	m_iTotalNumberOfModulesVerified = 0;
	m_lpModuleInfoNodeHead = NULL;
}

CModuleInfoCache::~CModuleInfoCache()
{
	// Delete all the Module Info Objects...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead)
	{
		CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoNodeHead;
		CModuleInfoNode * lpModuleInfoNodePointerToDelete = m_lpModuleInfoNodeHead;

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
			
			// Delete the Module Info Object we have...
			delete lpModuleInfoNodePointerToDelete->m_lpModuleInfo;

			// Delete the Module Info Node Object behind us...
			delete lpModuleInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpModuleInfoNodePointerToDelete = lpModuleInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...
		m_lpModuleInfoNodeHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoCacheMutex);

	// Now, close the Mutex
	if (m_hModuleInfoCacheMutex)
	{
		CloseHandle(m_hModuleInfoCacheMutex);
		m_hModuleInfoCacheMutex = NULL;
	}
}

// Search for the provided module path, return a pointer to the
// ModuleInfo object if we find it...
CModuleInfo * CModuleInfoCache::SearchForModuleInfoObject(LPTSTR tszModulePath)
{
	if (tszModulePath == NULL)
		return NULL;

	CModuleInfo * lpModuleInfoObjectToReturn = NULL;

	// Search all the Module Info Objects...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead)
	{

		CModuleInfoNode * lpCurrentModuleInfoNodePointer = m_lpModuleInfoNodeHead;
		CModuleInfoNode * lpParentModuleInfoNodePointer = NULL;

		DWORD dwParentModuleInfoRefCount = 0;
		DWORD dwModuleInfoRefCount = 0;

		// Traverse the linked list to the end..
		while (lpCurrentModuleInfoNodePointer )
		{	
			// Do we have a match?
			if ( 0 == _tcscmp(tszModulePath, lpCurrentModuleInfoNodePointer->m_lpModuleInfo->GetModulePath()) )
			{
				// Yee haa... We have a match!!!
				lpModuleInfoObjectToReturn = lpCurrentModuleInfoNodePointer->m_lpModuleInfo;

				// Increment the refcount... of the new Object...
				dwModuleInfoRefCount = lpModuleInfoObjectToReturn->AddRef();

#ifdef _DEBUG_MODCACHE
				_tprintf(TEXT("MODULE CACHE: Module FOUND in Cache [%s] (New Ref Count = %d)\n"), tszModulePath, dwModuleInfoRefCount);
#endif
				// If we have a parent... and we find that it's refcount is below ours
				// we'll want to move ourself into the correct position...
				if ( lpParentModuleInfoNodePointer && 
					( dwParentModuleInfoRefCount < dwModuleInfoRefCount ) 
				   )
				{
					// First... pop us off the list...
					lpParentModuleInfoNodePointer->m_lpNextModuleInfoNode = 
						lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;

					// Set the Parent Node pointer to NULL (so we can tell if there is a parent)
					lpParentModuleInfoNodePointer = NULL;

					// Now, starting from the top of the list... figure out where to stuff us...
					CModuleInfoNode * lpTempModuleInfoNodePointer = m_lpModuleInfoNodeHead;

					// Keep looking...
					while (lpTempModuleInfoNodePointer)
					{
						// We're looking for a place where our ref count is greater than
						// the node we're pointing at...
						if ( dwModuleInfoRefCount >
							lpTempModuleInfoNodePointer->m_lpModuleInfo->GetRefCount())
						{
							// Bingo...

							// Do we have the highest refcount?
							if (lpParentModuleInfoNodePointer == NULL)
							{
								// We are to become the head...

								// Make our node point to where the head currently points.
								lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode = m_lpModuleInfoNodeHead;

								// Set the current NodeHead to ours...
								m_lpModuleInfoNodeHead = lpCurrentModuleInfoNodePointer;

							} else
							{
								// We're not the head...

								// Save where the parent currently points...
								lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode = lpParentModuleInfoNodePointer->m_lpNextModuleInfoNode;

								// Set the parent to point to us...
								lpParentModuleInfoNodePointer->m_lpNextModuleInfoNode = lpCurrentModuleInfoNodePointer;
							}
							goto cleanup;
						}

						// Save the old pointer (it's now the parent)
						lpParentModuleInfoNodePointer = lpTempModuleInfoNodePointer;

						// Let's try the next one...
						lpTempModuleInfoNodePointer = lpTempModuleInfoNodePointer->m_lpNextModuleInfoNode;
					}
				}
				break;
			}

			// Save parent location (we need it for popping our object from the list)
			lpParentModuleInfoNodePointer = lpCurrentModuleInfoNodePointer ; 
			
			// Save our parent's ref count...
			dwParentModuleInfoRefCount = lpCurrentModuleInfoNodePointer->m_lpModuleInfo->GetRefCount();
			
			// Advance to the next object...
			lpCurrentModuleInfoNodePointer  = lpCurrentModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}
	}

cleanup:
	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoCacheMutex);

#ifdef _DEBUG_MODCACHE
		if (!lpModuleInfoObjectToReturn)
			_tprintf(TEXT("MODULE CACHE: Module not found in Cache [%s]\n"), tszModulePath);
#endif

	return lpModuleInfoObjectToReturn;
}

/***
** CModuleInfoCache::AddNewModuleInfoObject()
**
** This routine accepts a path to the module, and either returns the 
** Module Info object from the cache, or creates a new object that needs
** to be populated.
*/

CModuleInfo * CModuleInfoCache::AddNewModuleInfoObject(LPTSTR tszModulePath, bool * pfNew)
{
	if (tszModulePath == NULL)
		return NULL;

	CModuleInfo * lpModuleInfoObjectToReturn = NULL;
	CModuleInfoNode * lpModuleInfoNode = NULL;
	*pfNew = false;

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	_tcsupr(tszModulePath); // Upper case the module path... makes it faster on search...

	lpModuleInfoObjectToReturn = SearchForModuleInfoObject(tszModulePath);

	if (lpModuleInfoObjectToReturn)
	{
		// Success... since it already exists, we just return this object...
		goto cleanup;		
	}

	// We need to create a new object then...
	lpModuleInfoObjectToReturn = new CModuleInfo();

	if (NULL == lpModuleInfoObjectToReturn)
		goto error_cleanup;		// This is bad... get out...

	// Set the module path (that's the only thing we have to set at this exact moment
	if (!lpModuleInfoObjectToReturn->SetModulePath(tszModulePath))
		goto cleanup;
	
	*pfNew = true;

	// Now, create a new ModuleInfoNode, and add this new object to it...
	lpModuleInfoNode = new CModuleInfoNode(lpModuleInfoObjectToReturn);

	if (NULL == lpModuleInfoNode)
		goto error_cleanup;

	if (!lpModuleInfoNode->AddModuleInfoNodeToTail(&m_lpModuleInfoNodeHead))
		goto error_cleanup;

#ifdef _DEBUG_MODCACHE
	_tprintf(TEXT("MODULE CACHE: Module added to Cache [%s]\n"), tszModulePath);
#endif

	InterlockedIncrement(&m_iModulesInCache);
	// Success...
	goto cleanup;

error_cleanup:
	if (lpModuleInfoObjectToReturn)
	{
		delete lpModuleInfoObjectToReturn;
		lpModuleInfoObjectToReturn = NULL;
	}



cleanup:
	// Release the Mutex...
	ReleaseMutex(m_hModuleInfoCacheMutex);

	return lpModuleInfoObjectToReturn;
}

bool CModuleInfoCache::Initialize(CSymbolVerification * lpSymbolVerification)
{
	// Let's save the symbol verification object here...
	m_lpSymbolVerification = lpSymbolVerification;

	m_hModuleInfoCacheMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_hModuleInfoCacheMutex == NULL)
		return false;

	return true;
}

bool CModuleInfoCache::VerifySymbols(bool fQuietMode)
{
	enum { iTotalNumberOfDotsToPrint = 60 };
	unsigned int iDotsPrinted = 0;
	unsigned int iDotsToPrint;
	long iTotalNumberOfModulesProcessed = 0;
	unsigned int iTotalNumberOfModules = GetNumberOfModulesInCache();
	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();
	bool fBadSymbol = true;

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoCacheMutex, INFINITE);

	if (m_lpModuleInfoNodeHead) 
	{
		CModuleInfoNode * lpCurrentModuleInfoNode = m_lpModuleInfoNodeHead;

		while (lpCurrentModuleInfoNode)
		{
			fBadSymbol = true;

			// We have a node... verify the Module Info for it...
			if (lpCurrentModuleInfoNode->m_lpModuleInfo)
			{
#ifdef _DEBUG_MODCACHE
				_tprintf(TEXT("MODULE CACHE: Verifying Symbols for [%s] (Refcount=%d)\n"), 
						lpCurrentModuleInfoNode->m_lpModuleInfo->GetModulePath(),
						lpCurrentModuleInfoNode->m_lpModuleInfo->GetRefCount() );
#endif
				if (fDebugSearchPaths && lpCurrentModuleInfoNode->m_lpModuleInfo->GetPESymbolInformation() != CModuleInfo::SYMBOL_INFORMATION_UNKNOWN)
				{
					CUtilityFunctions::OutputLineOfDashes();
					_tprintf(TEXT("Verifying Symbols for [%s]\n"), lpCurrentModuleInfoNode->m_lpModuleInfo->GetModulePath());
					CUtilityFunctions::OutputLineOfDashes();
				}

				// Invoke the ModuleInfo's VerifySymbols method... the cache doesn't know
				// how to verify symbols, but the ModuleInfo knows how to get this done...
				fBadSymbol = !lpCurrentModuleInfoNode->m_lpModuleInfo->VerifySymbols(m_lpSymbolVerification) || !lpCurrentModuleInfoNode->m_lpModuleInfo->GoodSymbolNotFound();

				// Increment total number of modules verified
				iTotalNumberOfModulesProcessed++;

				// Increment total number of modules verified for actual PE images... only...
				if (lpCurrentModuleInfoNode->m_lpModuleInfo->GetPESymbolInformation() != CModuleInfo::SYMBOL_INFORMATION_UNKNOWN)
				{						
					InterlockedIncrement(&m_iTotalNumberOfModulesVerified);

					if (fBadSymbol)
						InterlockedIncrement(&m_iNumberOfErrors);
				}

				if (!fQuietMode && !fDebugSearchPaths)
				{
					// Let's see if we should print a status dot... there will be room for 80 dots
					// but we'll just print 60 for now...
					
					iDotsToPrint = (iTotalNumberOfDotsToPrint * iTotalNumberOfModulesProcessed) / iTotalNumberOfModules;

					// Print out any dots if we need to...
					while (iDotsToPrint > iDotsPrinted)
					{
						_tprintf(TEXT("."));
						iDotsPrinted++;
					}
				}
			}

			lpCurrentModuleInfoNode = lpCurrentModuleInfoNode->m_lpNextModuleInfoNode;
		}

		if (!fQuietMode && iDotsPrinted && !fDebugSearchPaths)
			_tprintf(TEXT("\n\n"));
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoCacheMutex);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\moduleinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfo.cpp
//
//--------------------------------------------------------------------------

// ModuleInfo.cpp: implementation of the CModuleInfo class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>

#include <time.h>
#include "ModuleInfo.h"
#include "Globals.h"
#include "ProgramOptions.h"
#include "SymbolVerification.h"
#include "FileData.h"
#include "UtilityFunctions.h"
#include "DmpFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModuleInfo::CModuleInfo()
{
	m_dwRefCount = 1;
	m_dwCurrentReadPosition = 0;

	m_lpInputFile = NULL;
	m_lpOutputFile = NULL;
	m_lpDmpFile = NULL;

	// File version information
	m_fPEImageFileVersionInfo = false;
	m_tszPEImageFileVersionDescription = NULL;
	m_tszPEImageFileVersionCompanyName = NULL;
	
	m_tszPEImageFileVersionString = NULL;
	m_dwPEImageFileVersionMS = 0;
	m_dwPEImageFileVersionLS = 0;
	
	m_tszPEImageProductVersionString = NULL;
	m_dwPEImageProductVersionMS = 0;
	m_dwPEImageProductVersionLS = 0;

	// PE Image Properties
	m_tszPEImageModuleName = NULL;			// Module name (eg. notepad.exe)
	m_tszPEImageModuleFileSystemPath = NULL;			// Full path to module (eg. C:\winnt\system32\notepad.exe)
	m_dwPEImageFileSize = 0;
	m_ftPEImageFileTimeDateStamp.dwLowDateTime  = 0;
	m_ftPEImageFileTimeDateStamp.dwHighDateTime = 0;
	m_dwPEImageCheckSum = 0;
	m_dwPEImageTimeDateStamp = 0;
	m_dwPEImageSizeOfImage = 0;
	m_enumPEImageType = PEImageTypeUnknown;	// We need to track what ImageType we have (PE32/PE64/???)
	m_dw64BaseAddress = 0;

	m_wPEImageMachineArchitecture = 0;
	m_wCharacteristics = 0;						// These are the PE image characteristics

	// PE Image has a reference to DBG file
	m_enumPEImageSymbolStatus = SYMBOLS_NO;	// Assume there are no symbols for this module
	m_tszPEImageDebugDirectoryDBGPath = NULL;			// Path to DBG (found in PE Image)
	
	// PE Image has internal symbols
	m_dwPEImageDebugDirectoryCoffSize = 0;
	m_dwPEImageDebugDirectoryFPOSize = 0;
	m_dwPEImageDebugDirectoryCVSize = 0;
	m_dwPEImageDebugDirectoryOMAPtoSRCSize = 0;
	m_dwPEImageDebugDirectoryOMAPfromSRCSize = 0;
	
	// PE Image has a reference to PDB file...
	m_tszPEImageDebugDirectoryPDBPath = NULL;
	m_dwPEImageDebugDirectoryPDBFormatSpecifier = 0;
	m_dwPEImageDebugDirectoryPDBSignature = 0;				// PDB Signature (unique (across PDB instances) signature)
	m_dwPEImageDebugDirectoryPDBAge = 0;					// PDB Age (Number of times this instance has been updated)
	m_tszPEImageDebugDirectoryPDBGuid = NULL;

	// DBG Symbol information
	m_enumDBGModuleStatus = SYMBOL_NOT_FOUND;	// Status of the DBG file
	m_tszDBGModuleFileSystemPath = NULL;					// Path to the DBG file (after searching)
	m_dwDBGTimeDateStamp = 0;
	m_dwDBGCheckSum = 0;
	m_dwDBGSizeOfImage = 0;
	m_dwDBGImageDebugDirectoryCoffSize = 0;
	m_dwDBGImageDebugDirectoryFPOSize = 0;
	m_dwDBGImageDebugDirectoryCVSize = 0;
	m_dwDBGImageDebugDirectoryOMAPtoSRCSize = 0;
	m_dwDBGImageDebugDirectoryOMAPfromSRCSize = 0;
	
	// DBG File has a reference to a PDB file...
	m_tszDBGDebugDirectoryPDBPath = NULL;
	m_dwDBGDebugDirectoryPDBFormatSpecifier = 0;		// NB10, RSDS, etc...
	m_dwDBGDebugDirectoryPDBAge = 0;
	m_dwDBGDebugDirectoryPDBSignature = 0;
	m_tszDBGDebugDirectoryPDBGuid = NULL;

	// PDB File Information
	m_enumPDBModuleStatus = SYMBOL_NOT_FOUND; // Status of the PDB file
	m_tszPDBModuleFileSystemPath = NULL;		// Path to the PDB file (after searching)
	m_dwPDBFormatSpecifier = 0;
	m_dwPDBSignature = 0;
	m_dwPDBAge = 0;
	m_tszPDBGuid = NULL;
	m_dwPDBTotalBytesOfLineInformation = 0;
	m_dwPDBTotalBytesOfSymbolInformation = 0;
	m_dwPDBTotalSymbolTypesRange = 0;
}

CModuleInfo::~CModuleInfo()
{
	// Let's cleanup a bit...
	if (m_tszPEImageFileVersionDescription)
		delete [] m_tszPEImageFileVersionDescription;

	if (m_tszPEImageFileVersionCompanyName)
		delete [] m_tszPEImageFileVersionCompanyName;
	
	if (m_tszPEImageFileVersionString)
		delete [] m_tszPEImageFileVersionString;
		
	if (m_tszPEImageProductVersionString)
		delete [] m_tszPEImageProductVersionString;

	if (m_tszPEImageModuleName)
		delete [] m_tszPEImageModuleName;

	if (m_tszPEImageModuleFileSystemPath)
		delete [] m_tszPEImageModuleFileSystemPath;

	if (m_tszPEImageDebugDirectoryDBGPath)
		delete [] m_tszPEImageDebugDirectoryDBGPath;

	if (m_tszPEImageDebugDirectoryPDBPath)
		delete [] m_tszPEImageDebugDirectoryPDBPath;

	if (m_tszPEImageDebugDirectoryPDBGuid)
		delete [] m_tszPEImageDebugDirectoryPDBGuid;

	if (m_tszDBGModuleFileSystemPath)
		delete [] m_tszDBGModuleFileSystemPath;

	if (m_tszDBGDebugDirectoryPDBPath)
		delete [] m_tszDBGDebugDirectoryPDBPath;

	if (m_tszDBGDebugDirectoryPDBGuid)
		delete [] m_tszDBGDebugDirectoryPDBGuid;

	if (m_tszPDBModuleFileSystemPath)
		delete [] m_tszPDBModuleFileSystemPath;

	if (m_tszPDBGuid)
		delete [] m_tszPDBGuid;
}

//bool CModuleInfo::Initialize(CProgramOptions * lpProgramOptions, CFileData * lpInputFile, CFileData * lpOutputFile)
bool CModuleInfo::Initialize(CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile)
{
	// Let's save off the Program Options so we don't have to pass it to every method...
	m_lpInputFile =  lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpDmpFile = lpDmpFile;

	return true;
}

bool CModuleInfo::GetModuleInfo(LPTSTR tszModulePath, bool fDmpFile, DWORD64 dw64ModAddress, bool fGetDataFromCSVFile)
{
	bool fReturn = true;

	if (fGetDataFromCSVFile)
	{
		fReturn = GetModuleInfoFromCSVFile(tszModulePath);
	} else
	{
		fReturn = GetModuleInfoFromPEImage(tszModulePath, fDmpFile, dw64ModAddress);
	}

	return fReturn;
}

LPTSTR CModuleInfo::GetModulePath()
{
	return m_tszPEImageModuleFileSystemPath;
}

bool CModuleInfo::OutputData(LPTSTR tszProcessName, DWORD iProcessID, unsigned int dwModuleNumber)
{
	// Output to STDOUT?
	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
	{
		if (!OutputDataToStdout(dwModuleNumber))
			return false;
	}	

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputDataToFile(tszProcessName, iProcessID))
			return false;
	}	

	return true;
}

bool CModuleInfo::fCheckPDBSignature(bool fDmpFile, HANDLE hModuleHandle, OMFSignature *pSig, PDB_INFO *ppdb)
{
	if (!DoRead(fDmpFile, hModuleHandle, pSig, sizeof(*pSig)))
		return false;

	if ( (pSig->Signature[0] != 'N') ||
         (pSig->Signature[1] != 'B') ||
         (!isdigit(pSig->Signature[2])) ||
         (!isdigit(pSig->Signature[3]))) 

	{
         //
         // If this is a DMP file (fDmpFile), odds are good that this was not compiled with
         // a linker 6.20 or higher (which marks the PDB path in the PE image such
         // that it gets mapped into the virtual address space (and will be in the user.dmp
         // file).
         //
         
        return false;
    }

	// This switch statement is reminiscent of some windbg code...don't shoot me
	// (I modified it slightly since the NB signature isn't super important to me)...
    switch (*(LONG UNALIGNED *)(pSig->Signature))
	{
        case sigNB10:	// OMF Signature, and hopefully some PDB INFO
			{
				if (!DoRead(fDmpFile, hModuleHandle, ppdb, sizeof(PDB_INFO)))
					break;
			}

		default:
            break;
    }

	// Before returning true (since we have some form of NB## symbols), we'll save this...
/*
#ifdef _UNICODE
			// Source is in ANSI, dest is in _UNICODE... need to convert...
			MultiByteToWideChar(CP_ACP,
								MB_PRECOMPOSED,
								pSig->Signature,
								4,
								m_tszPEImageDebugDirectoryNBInfo,
								4);
#else
			// Copy the ANSI string over...
			strncpy(m_tszPEImageDebugDirectoryNBInfo, pSig->Signature, 4);
#endif

	m_tszPEImageDebugDirectoryNBInfo[4] = '\0';
*/
	return true;
}

bool CModuleInfo::VerifySymbols(CSymbolVerification * lpSymbolVerification)
{
	bool fReturn = false;

	if (!m_tszPEImageModuleName)
		goto cleanup;

	// Find/Verify a DBG file...
	if (m_enumPEImageSymbolStatus == SYMBOLS_DBG)
	{
		if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPath) )
		{
			fReturn = GetDBGModuleFileUsingSymbolPath(g_lpProgramOptions->GetSymbolPath());
		}

		// Do we want to try an alternate method to find symbols?
		if ( m_enumDBGModuleStatus != SYMBOL_MATCH )
		{
			// Try SQL server next...
			if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSQLServer) )
			{
				fReturn = GetDBGModuleFileUsingSQLServer(lpSymbolVerification);
			}
			// Try SQL2 server next ... mjl 12/14/99			
			if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSQLServer2) )
			{
				fReturn = GetDBGModuleFileUsingSQLServer2(lpSymbolVerification);
			}
		}
	}
	
	// Note, it is possible that the m_enumPEImageSymbolStatus will have changed from SYMBOLS_DBG
	// to SYMBOLS_DBG_AND_PDB after the DBG file is found above...
	if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) ||
		 (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
	{
		// This gets populated with the PDB filename (obtained from the DBG or PE Image)
//		if (m_tszDebugDirectoryPDBPath)
		if (GetDebugDirectoryPDBPath())
		{
			if (!lpSymbolVerification)
			{
				m_enumPDBModuleStatus = SYMBOL_NO_HELPER_DLL;
				goto cleanup;
			}

			fReturn = GetPDBModuleFileUsingSymbolPath();

			// Do we want to try an alternate method to find symbols?
			if ( m_enumPDBModuleStatus != SYMBOL_MATCH )
			{
				// Search for PDB in SQL2 if enabled - mjl 12/14/99
				if ( g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSQLServer2) )
				{
					fReturn = GetPDBModuleFileUsingSQLServer2(lpSymbolVerification);
				}
			}

		}
	}

cleanup:

	return fReturn;
}

bool CModuleInfo::GetDBGModuleFileUsingSymbolPath(LPTSTR tszSymbolPath)
{
	HANDLE hModuleHandle = INVALID_HANDLE_VALUE;
	TCHAR tszDebugModulePath[_MAX_PATH+1];
	TCHAR tszDrive[_MAX_DRIVE];
	TCHAR tszDir[_MAX_DIR];
	TCHAR tszExtModuleName[_MAX_EXT];
	TCHAR tszDBGModuleName[_MAX_FNAME];
	TCHAR tszSymbolPathWithModulePathPrepended[_MAX_PATH+_MAX_PATH+1];
	TCHAR tszPEImageModuleName[_MAX_FNAME+_MAX_EXT+1];

	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();

	// We have two options on the name of the DBG file...
	//
	// We compose the name of the DBG file we're searching for and pass that as the
	// first parameter (we could grab that which is in the MISC section but the
	// debuggers do not tend to do that...
	//
	// or
	//
	// We actually grab the MISC section and pull the name from there...

	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeUsingDBGInMISCSection))
	{
		// We search for this PE Image by it's actual name...
		_tcscpy(tszPEImageModuleName, m_tszPEImageModuleName);

		// Compose the DBG filename from the PE Image Name
		_tsplitpath(m_tszPEImageModuleName, NULL, NULL, tszDBGModuleName, NULL);
		_tcscat(tszDBGModuleName, TEXT(".DBG"));

	} else
	{
		// If we're told to grab the DBG name from the MISC section... and there isn't one...
		// bail!
		if (!m_tszPEImageDebugDirectoryDBGPath)
			goto cleanup;

		// Okay, the user wants us to look in the MISC section of the Debug Directories
		// to figure out the DBG file location... though the FindDebugInfoFileEx() takes
		// as an argument the name of the DBG file... if you provide the PE Image name
		// instead, it performs a search that is more "broad"...

		// Split the DBG file info found in the MISC section into components...
		_tsplitpath(m_tszPEImageDebugDirectoryDBGPath, NULL, NULL, tszDBGModuleName, tszExtModuleName);

		// Save the module name found here...
		_tcscpy(tszPEImageModuleName, tszDBGModuleName);

		// Append the DBG extension back on...
		_tcscat(tszDBGModuleName, tszExtModuleName);

		// Grab the extension of the PE Image and add it to end of our DBG module name..
		_tsplitpath(m_tszPEImageModuleName, NULL, NULL, NULL, tszExtModuleName);
		_tcscat(tszPEImageModuleName, tszExtModuleName);
	}

//	_tcsupr(tszDBGModuleName);

	tszSymbolPathWithModulePathPrepended[0] = '\0'; // Fast way to empty this string ;)

	if (fDebugSearchPaths)
	{
		_tprintf(TEXT("DBG Search - Looking for [%s] Using Symbol Path...\n"), tszDBGModuleName);
	};

	if (g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("DBG Search - SEARCH in Symbol Tree We're Building!\n"));
		};

		// When we are constructing a build symbol tree... we should first
		// search there to see if our symbol is already present...
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx(tszPEImageModuleName, g_lpProgramOptions->GetSymbolTreeToBuild(), tszDebugModulePath, VerifyDBGFile, this);

		// Close handle if one is returned...
		if (hModuleHandle != NULL)
		{
			CloseHandle(hModuleHandle);
		}

		// Hey, if we found it, we're done...
		if (GetDBGSymbolModuleStatus() == SYMBOL_MATCH)
		{
			goto cleanup;
		}
	}

	// Okay, we're not building a symbol tree... or we didn't find our symbol match in
	// the symbol tree... keep looking...
	
	// Well... let's search the SymbolPath provided for the DBG file...
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathRecursion))
	{
		// Do we use recursion???
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("DBG Search - SEARCH Symbol path with recursion!\n"));
			// ISSUE-2000/07/24-GREGWI: Does FindDebugInfoFileEx2 support SYMSRV?
		};
	
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx2(tszDBGModuleName, tszSymbolPath, VerifyDBGFile, this);

	} else
	{
		// Only do this if we're doing the standard file search mechanism...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly))
		{
			// Don't do this block here if VerifySymbolsModeWithSymbolPathOnly option has been set...

			// Hmm... Windbg changed behavior and now prepends the module path to the
			// front of the symbolpath before called FindDebugInfoFileEx()...
			_tsplitpath(m_tszPEImageModuleFileSystemPath, tszDrive, tszDir, NULL, NULL);

			_tcscat(tszSymbolPathWithModulePathPrepended, tszDrive);
			_tcscat(tszSymbolPathWithModulePathPrepended, tszDir);
			_tcscat(tszSymbolPathWithModulePathPrepended, TEXT(";"));
		}
		
		_tcscat(tszSymbolPathWithModulePathPrepended, tszSymbolPath);

		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("DBG Search - SEARCH Symbol path!\n"));
		};

		// Do we do the standard thing?
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx(tszPEImageModuleName, tszSymbolPathWithModulePathPrepended, tszDebugModulePath, VerifyDBGFile, this);
	}

cleanup:
	// If we have a hModuleHandle... free it now..
	if (hModuleHandle != NULL)
	{
		CloseHandle(hModuleHandle);
	}

	// We found the following path
	if (m_tszDBGModuleFileSystemPath)
	{
		// Okay, let's clean up any "strangeness" added by FindDebugInfoFileEx()
		// If a symbol is found in the same directory as the module, it will be
		// returned with an extra \.\ combination (which is superfluous normally)...
		LPTSTR tszLocationOfExtraJunk = _tcsstr(m_tszDBGModuleFileSystemPath, TEXT("\\.\\"));

		if ( tszLocationOfExtraJunk )
		{
			// Remember where we were...
			LPTSTR tszPreviousLocation = tszLocationOfExtraJunk;

			// Skip the junk...
			tszLocationOfExtraJunk = CharNext(tszLocationOfExtraJunk);  // '\\'
			tszLocationOfExtraJunk = CharNext(tszLocationOfExtraJunk);  // '.'

			// While we have data... copy to the old location...
			while (*tszLocationOfExtraJunk)
			{
				*tszPreviousLocation = *tszLocationOfExtraJunk;
				tszLocationOfExtraJunk = CharNext(tszLocationOfExtraJunk);
				tszPreviousLocation    = CharNext(tszPreviousLocation);
			}

			// Null terminate the module path...
			*tszPreviousLocation = '\0';
		}

	}

	if (fDebugSearchPaths)
	{
		if (GetDBGSymbolModuleStatus() == SYMBOL_MATCH)
		{
			_tprintf(TEXT("DBG Search - Debug Module Found at [%s]\n\n"), m_tszDBGModuleFileSystemPath);
		} else
		{
			_tprintf(TEXT("DBG Search - Debug Module Not Found.\n\n"));
		}
	}

	return true;
}

bool CModuleInfo::GetDBGModuleFileUsingSQLServer(CSymbolVerification * lpSymbolVerification)
{
	// Do we need to initialize the SQL Server Connection?
	if (!lpSymbolVerification->SQLServerConnectionInitialized() &&
		!lpSymbolVerification->SQLServerConnectionAttempted())
	{
		if (!lpSymbolVerification->InitializeSQLServerConnection( g_lpProgramOptions->GetSQLServerName() ) )
			return false;
	}

	// Let's only use the SQL Server if it was initialized properly...
	if ( lpSymbolVerification->SQLServerConnectionInitialized() )
	{
		if (!lpSymbolVerification->SearchForDBGFileUsingSQLServer(m_tszPEImageModuleName, m_dwPEImageTimeDateStamp, this))
			return false;
	}
	return true;
}

// begin SQL2 - mjl 12/14/99
bool CModuleInfo::GetDBGModuleFileUsingSQLServer2(CSymbolVerification * lpSymbolVerification)
{
	// Do we need to initialize the SQL Server Connection?
	if (!lpSymbolVerification->SQLServerConnectionInitialized2() &&
		!lpSymbolVerification->SQLServerConnectionAttempted2())
	{
		if (!lpSymbolVerification->InitializeSQLServerConnection2( g_lpProgramOptions->GetSQLServerName2() ) )
			return false;
	}

	// Let's only use the SQL Server if it was initialized properly...
	if ( lpSymbolVerification->SQLServerConnectionInitialized2() )
	{
		if (!lpSymbolVerification->SearchForDBGFileUsingSQLServer2(m_tszPEImageModuleName, m_dwPEImageTimeDateStamp, this))
			return false;
	}
	return true;
}

bool CModuleInfo::GetPDBModuleFileUsingSQLServer2(CSymbolVerification * lpSymbolVerification)
{
	// Do we need to initialize the SQL Server Connection?
	if (!lpSymbolVerification->SQLServerConnectionInitialized2() &&
		!lpSymbolVerification->SQLServerConnectionAttempted2())
	{
		if (!lpSymbolVerification->InitializeSQLServerConnection2( g_lpProgramOptions->GetSQLServerName2() ) )
			return false;
	}

	// Let's only use the SQL Server if it was initialized properly...
	if ( lpSymbolVerification->SQLServerConnectionInitialized2() )
	{
		if (!lpSymbolVerification->SearchForPDBFileUsingSQLServer2(m_tszPEImageModuleName, m_dwPEImageDebugDirectoryPDBSignature, this))
			return false;
	}
	return true;
}
// end SQL2 - mjl 12/14/99

bool CModuleInfo::fValidDBGCheckSum()
{
	if (m_enumDBGModuleStatus == SYMBOL_MATCH)
		return true;

	if ((g_lpProgramOptions->GetVerificationLevel() == 1) && fValidDBGTimeDateStamp())
		return true;

	if (m_enumDBGModuleStatus == SYMBOL_POSSIBLE_MISMATCH)
		return (m_dwPEImageCheckSum == m_dwDBGCheckSum);

	return false;
}

bool CModuleInfo::fValidDBGTimeDateStamp()
{
	return ( (m_enumDBGModuleStatus == SYMBOL_POSSIBLE_MISMATCH) ||
			 (m_enumDBGModuleStatus == SYMBOL_MATCH) )
			? (m_dwPEImageTimeDateStamp == m_dwDBGTimeDateStamp ) : false;
}

bool CModuleInfo::GetPDBModuleFileUsingSymbolPath()
{
	enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
	};

	HANDLE hModuleHandle = NULL;
	TCHAR tszSymbolPathWithModulePathPrepended[_MAX_PATH+_MAX_PATH+1];
	bool fSuccess = false;
    TCHAR tszRefPath[_MAX_PATH];
    TCHAR tszImageExt[_MAX_EXT] = {0}; 	// In case there is no extension we need to null terminate now...
    char szPDBOut[cbErrMax];
	TCHAR tszPDBModuleName[_MAX_FNAME];
	LPTSTR pcEndOfPath = NULL;
	tszPDBModuleName[0] = '\0';
	tszSymbolPathWithModulePathPrepended[0] = '\0';
	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();

    _tsplitpath(m_tszPEImageModuleFileSystemPath, NULL, NULL, NULL, tszImageExt);

	// Copy the symbol name we're searching for from the Debug Directories
	//LPTSTR lptszPointerToPDBName = _tcsrchr(m_tszDebugDirectoryPDBPath, '\\');
	LPTSTR lptszPointerToPDBName = _tcsrchr(GetDebugDirectoryPDBPath(), '\\');

	// If we don't find a \ char, then go ahead and copy the PDBPath directly...
	if (lptszPointerToPDBName == NULL)
	{
		//_tcscpy(tszPDBModuleName, m_tszDebugDirectoryPDBPath);
		_tcscpy(tszPDBModuleName, GetDebugDirectoryPDBPath());
	} else
	{
		// Advance past the \ char...
		lptszPointerToPDBName = CharNext(lptszPointerToPDBName);
		_tcscpy(tszPDBModuleName, lptszPointerToPDBName);
	}

	if (fDebugSearchPaths)
	{
		//_tprintf(TEXT("PDB Search - Looking for [%s] Using Symbol Path...\n"), g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : m_tszDebugDirectoryPDBPath);
		_tprintf(TEXT("PDB Search - Looking for [%s] Using Symbol Path...\n"), g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath());
	};

	if (g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		// When we are constructing a build symbol tree... we should first
		// search there to see if our symbol is already present...
		
		// Do we do the standard thing?
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - SEARCH in Symbol Tree We're Building!\n"));
		};
		
		//fSuccess = LocatePdb(g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : m_tszDebugDirectoryPDBPath,
		fSuccess = LocatePdb(g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath(),
							 m_dwPEImageDebugDirectoryPDBAge, 
							 m_dwPEImageDebugDirectoryPDBSignature, 
							 g_lpProgramOptions->GetSymbolTreeToBuild(), 
							 &tszImageExt[1], 
							 false);

		// Hey, if we found it, we're done...
		if (fSuccess)
		{
			goto cleanup;
		}
	}

	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly))
	{
		// Hey, we better have one or the other...
		if (!m_tszDBGModuleFileSystemPath && !m_tszPEImageModuleFileSystemPath)
			goto cleanup;

		// figure out the home directory of the EXE/DLL or DBG file - pass that along to
		// OpenValidate this will direct to dbi to search for it in that directory.
		_tfullpath(tszRefPath, m_tszDBGModuleFileSystemPath ? m_tszDBGModuleFileSystemPath : m_tszPEImageModuleFileSystemPath, sizeof(tszRefPath)/sizeof(TCHAR));
		pcEndOfPath = _tcsrchr(tszRefPath, '\\');
		*pcEndOfPath = '\0';        // null terminate it
		*szPDBOut = '\0';

		if (_MAX_PATH+_MAX_PATH+1 < (_tcsclen(tszRefPath) + _tcsclen(g_lpProgramOptions->GetSymbolPath())+2))
			goto cleanup;	// Buffer isn't big enough... sigh...

		_tcscat(tszSymbolPathWithModulePathPrepended, tszRefPath);
		_tcscat(tszSymbolPathWithModulePathPrepended, TEXT(";"));
	}

    _tcscat(tszSymbolPathWithModulePathPrepended, g_lpProgramOptions->GetSymbolPath());

	// Well... let's search the SymbolPath provided for the PDB file...
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathRecursion))
	{
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - SEARCH Symbol path with recursion!\n"));
			// ISSUE-2000/07/24-GREGWI: Does FindDebugInfoFileEx2 support SYMSRV?
		};

		// Do we use recursion??? 
		// ISSUE-2000/07/24-GREGWI - Are we passing the right first arg?  Is this supported?
		hModuleHandle = CUtilityFunctions::FindDebugInfoFileEx2(tszPDBModuleName, tszSymbolPathWithModulePathPrepended, VerifyPDBFile, this);

		if (hModuleHandle != NULL)
		{
			CloseHandle(hModuleHandle);
		}

		fSuccess = false;
	} else
	{
		if (fDebugSearchPaths)
		{
			_tprintf(TEXT("PDB Search - SEARCH Symbol path!\n"));
		};

		// Search for the PDB file the old fashioned way...
		
//		fSuccess = LocatePdb(g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : m_tszDebugDirectoryPDBPath,
		if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
		{
			fSuccess = LocatePdb(g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath(),
								 m_dwPEImageDebugDirectoryPDBAge, 
								 m_dwPEImageDebugDirectoryPDBSignature, 
								 tszSymbolPathWithModulePathPrepended, 
								 &tszImageExt[1], 
								 false);
		} else
		{
			fSuccess = LocatePdb(g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly) ? tszPDBModuleName : GetDebugDirectoryPDBPath(),
								 m_dwDBGDebugDirectoryPDBAge, 
								 m_dwDBGDebugDirectoryPDBSignature, 
								 tszSymbolPathWithModulePathPrepended, 
								 &tszImageExt[1], 
								 false);
		}
	}

cleanup:

	if (fDebugSearchPaths)
	{
		if (GetPDBSymbolModuleStatus() == SYMBOL_MATCH)
		{
			_tprintf(TEXT("PDB Search - Debug Module Found at [%s]\n\n"), m_tszPDBModuleFileSystemPath);
		} else
		{
			_tprintf(TEXT("PDB Search - Debug Module Not Found.\n\n"));
		}
	}

	return fSuccess;
}

BOOL CModuleInfo::VerifyPDBFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData)
{
	PDB * lpPdb = NULL;
    EC  ec = 0;
	char szError[cbErrMax] = "";
	bool fPdbModuleFound = false;
	char szFileName[_MAX_FNAME+1];
	hFileHandle = INVALID_HANDLE_VALUE;

	// Let's grab the data passed to us...
	CModuleInfo * lpModuleInfo = (CModuleInfo *) CallerData;		// mjl

	CUtilityFunctions::CopyTSTRStringToAnsi(tszFileName, szFileName, _MAX_FNAME+1);

	PDBOpenValidate(szFileName, NULL, pdbRead, lpModuleInfo->m_dwPEImageDebugDirectoryPDBSignature, lpModuleInfo->m_dwPEImageDebugDirectoryPDBAge, &ec, szError, &lpPdb);

	// Based on the return code, the path may be saved, and the PDB Module Status
	// updated...
	fPdbModuleFound = lpModuleInfo->HandlePDBOpenValidateReturn(lpPdb, tszFileName, ec);

	if (lpPdb)
	{
		PDBClose(lpPdb);
		lpPdb = NULL;
	}

	return fPdbModuleFound ? (ec == EC_OK) : FALSE;
}

bool
CModuleInfo::LocatePdb(
    LPTSTR tszPDB,
    ULONG PdbAge,
    ULONG PdbSignature,
    LPTSTR tszSymbolPath,
	LPTSTR tszImageExt,
    bool fImagePathPassed
    )
{
    PDB  *lpPdb = NULL;
    EC    ec = 0;
    char  szError[cbErrMax] = "";
	TCHAR tszPDBSansPath[_MAX_FNAME];
	TCHAR tszPDBExt[_MAX_EXT];
	TCHAR tszPDBLocal[_MAX_PATH];
	char szPDBLocal[_MAX_PATH];
	LPTSTR ptszSemiColon;
    DWORD pass;
    BOOL  symsrv = TRUE;
	TCHAR tszPDBName[_MAX_PATH];
	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();

	// We're pessimistic initially...
	m_enumPDBModuleStatus = SYMBOL_NOT_FOUND;
	bool fPdbModuleFound = false;

	// szSymbolPath is a semicolon delimited path (reference path first)

    _tcscpy(tszPDBLocal, tszPDB);
    _tsplitpath(tszPDBLocal, NULL, NULL, tszPDBSansPath, tszPDBExt);

    do {
        ptszSemiColon = _tcschr(tszSymbolPath, ';');

        if (ptszSemiColon) {
            *ptszSemiColon = '\0';
        }
 
        if (fImagePathPassed) {
            pass = 2;
            fImagePathPassed = 0;
        } else {
            pass = 0;
        }
 
        if (tszSymbolPath) {
do_again:
            if (!_tcsnicmp(tszSymbolPath, TEXT("SYMSRV*"), 7)) {
                
                *tszPDBLocal = 0;
                _stprintf(tszPDBName, TEXT("%s%s"), tszPDBSansPath, TEXT(".pdb"));

                if (symsrv) {

					if (fDebugSearchPaths)
					{
						_tprintf(TEXT("PDB Search - SYMSRV [%s,0x%x,0x%x]\n"),
								 tszSymbolPath, 
								 PdbSignature,
								 PdbAge);
					}

                    CUtilityFunctions::GetSymbolFileFromServer(tszSymbolPath, 
                                            tszPDBName, 
                                            PdbSignature,
                                            PdbAge,
                                            0,
                                            tszPDBLocal);
                    symsrv = FALSE;
                }
            
            } else {
            
                _tcscpy(tszPDBLocal, tszSymbolPath);
                CUtilityFunctions::EnsureTrailingBackslash(tszPDBLocal);
                
                // search order is ...
                //
                //   %dir%\symbols\%ext%\%file%
                //   %dir%\%ext%\%file%
                //   %dir%\%file%
                
                switch (pass)
                {
                case 0:
                    _tcscat(tszPDBLocal, TEXT("symbols"));
                    CUtilityFunctions::EnsureTrailingBackslash(tszPDBLocal);
                    // pass through
                case 1:
                    _tcscat(tszPDBLocal, tszImageExt);
                    // pass through
                default:
                    CUtilityFunctions::EnsureTrailingBackslash(tszPDBLocal);
                    break;
                }
    
                _tcscat(tszPDBLocal, tszPDBSansPath);
                _tcscat(tszPDBLocal, tszPDBExt);
            }

			// Okay... at this point we may have a path to a PDB file to examine...
			// If so, then issue the PDBOpenValidate() and attempt to verify it...
            if (*tszPDBLocal) 
            {
				CUtilityFunctions::CopyTSTRStringToAnsi(tszPDBLocal, szPDBLocal, _MAX_PATH);

				if (fDebugSearchPaths)
				{
					_tprintf(TEXT("PDB Search - Search here [%s]\n"), tszPDBLocal);
				}

				PDBOpenValidate(szPDBLocal, NULL, "r", PdbSignature, PdbAge, &ec, szError, &lpPdb);

				if (lpPdb)
				{
					fPdbModuleFound = true;
				}

				// Based on the return code, the path may be saved, and the PDB Module Status
				// updated...
				if ( !HandlePDBOpenValidateReturn(lpPdb, tszPDBLocal, ec) )
					goto cleanup;

	            if (fPdbModuleFound) 
	            {
					PDBClose(lpPdb);
					lpPdb = NULL;						            	
	            	break;
				} else 
				{
					if (pass < 2) 
					{
	                	pass++;
						goto do_again;
					}
				}
			}
        }

		// If we found a semicolon before... then restore the semi... and move just beyond it...
		// Enable our symsrv searching again...
        if (ptszSemiColon) {
            *ptszSemiColon = ';';
             ptszSemiColon++;
             symsrv = TRUE;
        }

		// Reset the tszSymbolPath to the new location...
        tszSymbolPath = ptszSemiColon;

    } while (ptszSemiColon);

	// Only try this last check if we're not bound to our Symbol Path Only
	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsModeWithSymbolPathOnly))
	{
		// Okay... if pdb is still not found... then try the tszPDB location...
		if (!lpPdb) 
		{
			// ISSUE-2000/07/24-GREGWI: Is it required to copy the tszPDB string here?
			_tcscpy(tszPDBLocal, tszPDB); 
			CUtilityFunctions::CopyTSTRStringToAnsi(tszPDBLocal, szPDBLocal, _MAX_PATH);

			if (fDebugSearchPaths)
			{
				_tprintf(TEXT("PDB Search - Search here [%s]\n"), tszPDBLocal);
			}

			PDBOpenValidate(szPDBLocal, NULL, "r", PdbSignature, PdbAge, &ec, szError, &lpPdb);
			
			if ( !HandlePDBOpenValidateReturn(lpPdb, tszPDBLocal, ec) )
				goto cleanup;
			
			if (lpPdb)
			{
				fPdbModuleFound = true;
				PDBClose(lpPdb);
				lpPdb = NULL;
			}

		}
	}

cleanup:
    return fPdbModuleFound;
}

BOOL CModuleInfo::VerifyDBGFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData)
{
	CModuleInfo * lpModuleInfo = (CModuleInfo * )CallerData;
	WORD wMagic;				// Read to identify a DBG file...
	bool fPerfectMatch = false;	// Assume we don't have a good DBG match...

	// DBG Image Locals
	IMAGE_SEPARATE_DEBUG_HEADER ImageSeparateDebugHeader;

	// Start at the top of the image...
	lpModuleInfo->SetReadPointer(false, hFileHandle, 0, FILE_BEGIN);

	// Read in a signature word... is this a DBG file?
	if ( !lpModuleInfo->DoRead(false, hFileHandle, &wMagic, sizeof(wMagic) ) )
		goto cleanup;

	// No sense in going further since we're expecting a DBG image file...
	if (wMagic != IMAGE_SEPARATE_DEBUG_SIGNATURE)
		goto cleanup;

	// Start at the top of the image...
	lpModuleInfo->SetReadPointer(false, hFileHandle, 0, FILE_BEGIN);

	// Read in the full Separate Debug Header
	if ( !lpModuleInfo->DoRead(false, hFileHandle, &ImageSeparateDebugHeader, sizeof(ImageSeparateDebugHeader) ) )
		goto cleanup;

	//
	// We have a more stringent requirement for matching the checksum if the verification level is set...
	//
	if ( (lpModuleInfo->m_dwPEImageTimeDateStamp == ImageSeparateDebugHeader.TimeDateStamp ) &&
		(lpModuleInfo->m_dwPEImageSizeOfImage == ImageSeparateDebugHeader.SizeOfImage ) )
	{
		if (g_lpProgramOptions->GetVerificationLevel() == 2)
		{
			if (lpModuleInfo->m_dwPEImageCheckSum == ImageSeparateDebugHeader.CheckSum)
				fPerfectMatch = true;
		} else
		{
			fPerfectMatch = true;
		}
	}

	//
	// We're going to perform some action below unless this is not a perfect match
	// and we've already picked up a "bad" DBG file reference...
	//
	if (!fPerfectMatch && lpModuleInfo->m_tszDBGModuleFileSystemPath)
		goto cleanup;

	//
	// Take action based on our results...
	// 1. If we have a perfect match... save our stuff!
	// 2. If we don't already have a DBG, go ahead and save (even if wrong)
	//

	// Save off the checksum/linker information...
	lpModuleInfo->m_dwDBGTimeDateStamp = ImageSeparateDebugHeader.TimeDateStamp;
	lpModuleInfo->m_dwDBGCheckSum = ImageSeparateDebugHeader.CheckSum;
	lpModuleInfo->m_dwDBGSizeOfImage = ImageSeparateDebugHeader.SizeOfImage;
	
	// If we already had a path to a wrong DBG file, delete it...
	if (lpModuleInfo->m_tszDBGModuleFileSystemPath)
	{
		delete [] lpModuleInfo->m_tszDBGModuleFileSystemPath;
		lpModuleInfo->m_tszDBGModuleFileSystemPath = NULL;
	}

	// Save the Module Path now that we know we have a match...
	// Okay, let's save off the path to the DBG file...
	lpModuleInfo->m_tszDBGModuleFileSystemPath = (LPTSTR)CUtilityFunctions::CopyString(tszFileName);

	// Delete any PDB reference we may have found in our last DBG file (if any)...
	if (lpModuleInfo->m_tszDBGDebugDirectoryPDBPath)
	{
		delete [] lpModuleInfo->m_tszDBGDebugDirectoryPDBPath;
		lpModuleInfo->m_tszDBGDebugDirectoryPDBPath = NULL;
	}

	//
	// At this point, we only continue on if we've made a perfect "hit"
	//
	if (!fPerfectMatch)
	{
		// Not a perfect symbol.. record the status and exit...
		lpModuleInfo->m_enumDBGModuleStatus = SYMBOL_POSSIBLE_MISMATCH;

		goto cleanup;
	}

	// Good symbol.. record this...
	lpModuleInfo->m_enumDBGModuleStatus = SYMBOL_MATCH;

	// Now that we're done verifying the module... do we save the symbol in
	// our tree?
	if ( g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
	{
		// Yup...
		CUtilityFunctions::CopySymbolFileToSymbolTree(lpModuleInfo->m_tszPEImageModuleName, &lpModuleInfo->m_tszDBGModuleFileSystemPath, g_lpProgramOptions->GetSymbolTreeToBuild());
	}

	//
	// Okay, now with a good symbol let's extract the goods...
	//

	// If there's no debug info, we can't continue further.
	if (ImageSeparateDebugHeader.DebugDirectorySize == 0)
	{
		goto cleanup;
	}

	// Okay, we need to advance by the IMAGE_SECTION_HEADER...
	lpModuleInfo->SetReadPointer(false, hFileHandle, (ImageSeparateDebugHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)), FILE_CURRENT);

	// Skip over the exported names.
	if (ImageSeparateDebugHeader.ExportedNamesSize)
	{
		lpModuleInfo->SetReadPointer(false, hFileHandle, ImageSeparateDebugHeader.ExportedNamesSize, FILE_CURRENT);
	}
		
	if (!lpModuleInfo->ProcessDebugDirectory(false, false, hFileHandle, ImageSeparateDebugHeader.DebugDirectorySize, lpModuleInfo->GetReadPointer()))
		goto cleanup;

cleanup:

	return (fPerfectMatch ? TRUE : FALSE);
}

bool CModuleInfo::OutputDataToFile(LPTSTR tszProcessName, DWORD iProcessID)
{

	LPTSTR tszString = NULL;

	bool fReturn = false;

	// We remove the first three columns if -E was specified...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		// Let's skip the first column to make room for the tag in the first column...
		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		// Process Name
		//
		if (tszProcessName)
		{
			if (!m_lpOutputFile->WriteString(tszProcessName, true))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		// BUG 524 - GREGWI - CheckSym - Unable to read CSV file generated on Windows 2000 Machine
		// (I changed the code to emit the PID no matter what it's value, I was special casing 0)
		//
		// Process ID
		//
		// ISSUE-2000/07/24-GREGWI: Put conditional write back in (only emit if this is PROCESSES collection
		// ISSUE-2000/07/24-GREGWI: we don't want to see 0 as the PID for any other collection....
		if (tszProcessName) 
		{
			// Let's only emit the PID if there is a process name...
			if (!m_lpOutputFile->WriteDWORD(iProcessID))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	// if -E is specified, we only spit out if the module has a problem
	if ( g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode) )
	{

		switch (m_enumPEImageSymbolStatus)
		{
			case SYMBOLS_DBG:
				if ( m_enumDBGModuleStatus == SYMBOL_MATCH)
				{
					// Don't print this out.. it matches...
					fReturn = true;
					goto cleanup;
				}
				break;

			case SYMBOLS_DBG_AND_PDB:
				if ( m_enumDBGModuleStatus == SYMBOL_MATCH &&
					 m_enumPDBModuleStatus == SYMBOL_MATCH )
				{
					// Don't print this out.. it matches...
					fReturn = true;
					goto cleanup;
				}
				
				break;

			case SYMBOLS_PDB:
				if ( m_enumPDBModuleStatus == SYMBOL_MATCH)
				{
					// Don't print this out.. it matches...
					fReturn = true;
					goto cleanup;
				}
				break;
		}
	}

	//
	//  Module Path
	//
	if (m_tszPEImageModuleFileSystemPath)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageModuleFileSystemPath, true))
			goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	//
	// Symbol Status
	//
	if (m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN)
	{
		tszString = SymbolInformationString(m_enumPEImageSymbolStatus);

		if (tszString)
		{
			if (!m_lpOutputFile->WriteString(tszString))
				goto cleanup;
		}
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	// We remove this column if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		//
		//  Checksum
		//
		if ( m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageCheckSum))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;
		
		//
		//  Time/Date Stamp
		//
		if ( m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageTimeDateStamp))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	//
	//  Time/Date String
	//
	// If -E is specified we'll use version2 of the output format...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		if ( m_enumPEImageSymbolStatus != SYMBOL_INFORMATION_UNKNOWN )
		{
			if (!m_lpOutputFile->WriteTimeDateString(m_dwPEImageTimeDateStamp))
				goto cleanup;
		}
	} else
	{
			if (!m_lpOutputFile->WriteTimeDateString2(m_dwPEImageTimeDateStamp))
				goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	// We remove these columns if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		//
		// Size Of Image (internal PE value) - used for SYMSRV support
		//
		if (!m_lpOutputFile->WriteDWORD(m_dwPEImageSizeOfImage))
			goto cleanup;

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  DBG Pointer
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_DBG ||
			 m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB )
		{
			// Output the Path	
			if (m_tszPEImageDebugDirectoryDBGPath)
			{
				if (!m_lpOutputFile->WriteString(m_tszPEImageDebugDirectoryDBGPath, true))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  PDB Pointer
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_PDB )
		{
			// Output the Path	
			if (GetDebugDirectoryPDBPath())
			{
				if (!m_lpOutputFile->WriteString(GetDebugDirectoryPDBPath(), true))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  PDB Signature
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_PDB )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageDebugDirectoryPDBSignature))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  PDB Age
		//
		if ( m_enumPEImageSymbolStatus == SYMBOLS_PDB )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageDebugDirectoryPDBAge))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	//
	//  Product Version
	//
	// We remove these columns if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		if (m_fPEImageFileVersionInfo && m_tszPEImageProductVersionString)
		{
			if (!m_lpOutputFile->WriteString(m_tszPEImageProductVersionString))
				goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;
	}

	//
	//  File Version
	//
	if (m_fPEImageFileVersionInfo && m_tszPEImageFileVersionString)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageFileVersionString))
			goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;
	
	//
	//  Company Name
	//
	if (m_fPEImageFileVersionInfo && m_tszPEImageFileVersionCompanyName)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageFileVersionCompanyName, true))
				goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	//
	//   File Description
	//
	if (m_fPEImageFileVersionInfo && m_tszPEImageFileVersionDescription)
	{
		if (!m_lpOutputFile->WriteString(m_tszPEImageFileVersionDescription, true))
				goto cleanup;
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	// We remove these columns if -E is specified
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
	{
		//
		// File Size (in bytes)
		//
		if ( m_dwPEImageFileSize )
		{
			if (!m_lpOutputFile->WriteDWORD(m_dwPEImageFileSize))
					goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		// File Date High Word
		if ( m_ftPEImageFileTimeDateStamp.dwLowDateTime ||
			 m_ftPEImageFileTimeDateStamp.dwHighDateTime )
		{
			if (!m_lpOutputFile->WriteDWORD(m_ftPEImageFileTimeDateStamp.dwHighDateTime))
					goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		// File Date Low Word
		if ( m_ftPEImageFileTimeDateStamp.dwLowDateTime ||
			 m_ftPEImageFileTimeDateStamp.dwHighDateTime )
		{
			if (!m_lpOutputFile->WriteDWORD(m_ftPEImageFileTimeDateStamp.dwLowDateTime))
					goto cleanup;
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

	}

	// File Date String
	if ( m_ftPEImageFileTimeDateStamp.dwLowDateTime ||
		 m_ftPEImageFileTimeDateStamp.dwHighDateTime )
	{
		// If -E is specified we'll use version2 of the output format...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
		{
			if (!m_lpOutputFile->WriteFileTimeString(m_ftPEImageFileTimeDateStamp))
				goto cleanup;
		} else
		{
			if (!m_lpOutputFile->WriteFileTimeString2(m_ftPEImageFileTimeDateStamp))
				goto cleanup;
		}
	}

	if (!m_lpOutputFile->WriteString(TEXT(",")))
		goto cleanup;

	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		//
		//  Local DBG Status
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG) || (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) )
		{

			tszString = SymbolModuleStatusString(m_enumDBGModuleStatus);

			if (tszString)
			{
				if (!m_lpOutputFile->WriteString(tszString))
					goto cleanup;
			}

		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  Local DBG
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG) || (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) )
		{
			if (m_tszDBGModuleFileSystemPath)
			{
				if (!m_lpOutputFile->WriteString(m_tszDBGModuleFileSystemPath, true))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  Local PDB Status
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) || (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
		{
			tszString = SymbolModuleStatusString(m_enumPDBModuleStatus);
		
			if (tszString)
			{
				if (!m_lpOutputFile->WriteString(tszString))
					goto cleanup;
			}
		}

		if (!m_lpOutputFile->WriteString(TEXT(",")))
			goto cleanup;

		//
		//  Local PDB
		//
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) || (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
		{
			if (m_tszPDBModuleFileSystemPath)
			{
				if (!m_lpOutputFile->WriteString(m_tszPDBModuleFileSystemPath, true))
					goto cleanup;
			}
		}
	}
	// Write the carriage-return line-feed at the end of the line...
	if (!m_lpOutputFile->WriteString(TEXT("\r\n")))
		goto cleanup;

	fReturn = true; // Success

cleanup:

	if (!fReturn)
	{
		_tprintf(TEXT("Error: Failure writing module data!\n"));
		m_lpOutputFile->PrintLastError();
	}
		
	return fReturn;
}

bool CModuleInfo::OutputDataToStdout(DWORD dwModuleNumber)
{
	//
	// Do we output this module?
	//
	if (!OutputDataToStdoutThisModule())
		return false;
	
	//
	// First, Output Module Info
	//
	OutputDataToStdoutModuleInfo(dwModuleNumber);

	bool fPrintCarriageReturn = false;

	//
	// Second, if we were to collect symbol info, but NOT verify... dump out what we
	// discovered about the symbol info...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode) &&
	   !g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		fPrintCarriageReturn = true;

		switch (m_enumPEImageSymbolStatus)
		{
			case SYMBOL_INFORMATION_UNKNOWN:
				_tprintf(TEXT("  Module symbol information was not collected!\n"));
				break;

			case SYMBOLS_NO:
				_tprintf(TEXT("  Module has NO symbols!\n"));
				break;

			case SYMBOLS_LOCAL:
				//
				// This module has ONLY local symbols...
				//
				_tprintf(TEXT("  Module has internal symbols only! %s\n"), SourceEnabledPEImage());
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
				break;

			case SYMBOLS_DBG:

				//
				// This module may have Internal Symbols but has a DBG file...
				//
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

				//
				// Output the DBG Symbol Information
				//
				OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);

				//
				// Output the DBG Internal Symbol Information
				//
				OutputDataToStdoutInternalSymbolInfo(m_dwDBGImageDebugDirectoryCoffSize, m_dwDBGImageDebugDirectoryFPOSize, m_dwDBGImageDebugDirectoryCVSize, m_dwDBGImageDebugDirectoryOMAPtoSRCSize, m_dwDBGImageDebugDirectoryOMAPfromSRCSize);
				break;

			case SYMBOLS_PDB:
				//
				// Output any internal symbols (that should be "splitsym'ed out")
				//
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

				//
				// In this case, we have a PE Image with a PDB file...
				//
				OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, m_tszPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
				break;
		}
	}

	//
	// Third, if we were to verify symbol info, display the results...
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		fPrintCarriageReturn = true;

		switch (m_enumPEImageSymbolStatus)
		{
			case SYMBOL_INFORMATION_UNKNOWN:
				_tprintf(TEXT("  Module symbol information was not collected!\n"));
				break;

			case SYMBOLS_NO:
				_tprintf(TEXT("  Module has NO symbols\n"));
				break;

			case SYMBOLS_LOCAL:
				_tprintf(TEXT("  Module has internal symbols only! %s\n"), SourceEnabledPEImage());
				OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
				break;

			case SYMBOLS_DBG:
			case SYMBOLS_DBG_AND_PDB:
				switch (m_enumDBGModuleStatus)
				{
					case SYMBOL_MATCH:
						
						// Did they want the debug/symbol info for the PE image itself?
						if(g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode))
						{
							OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
						}

						if(m_tszDBGModuleFileSystemPath )
						{
							_tprintf(TEXT("  DBG File = %s [VERIFIED] %s\n"), m_tszDBGModuleFileSystemPath, SourceEnabledDBGImage());
						}
						
						if(g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode))
						{
							OutputDataToStdoutInternalSymbolInfo(m_dwDBGImageDebugDirectoryCoffSize, m_dwDBGImageDebugDirectoryFPOSize, m_dwDBGImageDebugDirectoryCVSize, m_dwDBGImageDebugDirectoryOMAPtoSRCSize, m_dwDBGImageDebugDirectoryOMAPfromSRCSize);
						}
						break;

					case SYMBOL_NOT_FOUND:
						OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
						OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						_tprintf(TEXT("  DBG File NOT FOUND!\n"));
						break; // If we didn't find the DBG file... we don't bother with the PDB...

					case SYMBOL_POSSIBLE_MISMATCH:
						OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

						OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						OutputDataToStdoutDbgSymbolInfo(m_tszDBGModuleFileSystemPath, m_dwDBGTimeDateStamp, m_dwDBGCheckSum, m_dwDBGSizeOfImage, TEXT("DISCREPANCY"), m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						OutputDataToStdoutInternalSymbolInfo(m_dwDBGImageDebugDirectoryCoffSize, m_dwDBGImageDebugDirectoryFPOSize, m_dwDBGImageDebugDirectoryCVSize, m_dwDBGImageDebugDirectoryOMAPtoSRCSize, m_dwDBGImageDebugDirectoryOMAPfromSRCSize);
						break;
				};

				//
				// Intentional fall through to SYMBOLS_PDB (we might have one)
				//

			case SYMBOLS_PDB:

				// These two cases should have a PDB file... if we can find it...
				//
				if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) ||
					 (m_enumPEImageSymbolStatus == SYMBOLS_PDB) )
				{
					//
					// If we have a DebugDirectoryPDBPath... then display the goods...
					//
					if (GetDebugDirectoryPDBPath())
					{
						switch(m_enumPDBModuleStatus)
						{
							case SYMBOL_NOT_FOUND:
								OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);

								// Output PDB info as appropriate
								if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
								{
									OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, m_tszPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
								}
								else
								{
									OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, m_tszDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
								}

								_tprintf(TEXT("  NO PDB FILE FOUND!!\n"));
								break;

							case SYMBOL_MATCH:
								// Did they want the debug/symbol info for the PE image itself?
								if(m_tszPDBModuleFileSystemPath )
									_tprintf(TEXT("  PDB File = %s [VERIFIED] %s\n"), m_tszPDBModuleFileSystemPath, SourceEnabledPDB());

								// BUGBUG: Testing...
								if (g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode))
								{
									if (m_dwPDBTotalBytesOfLineInformation)
										_tprintf(TEXT("    Module PDB Bytes of Lines     = 0x%x\n"), m_dwPDBTotalBytesOfLineInformation);

									if (m_dwPDBTotalBytesOfSymbolInformation)
										_tprintf(TEXT("    Module PDB Bytes of Symbols   = 0x%x\n"), m_dwPDBTotalBytesOfSymbolInformation);

									if (m_dwPDBTotalSymbolTypesRange)
										_tprintf(TEXT("    Module PDB Symbol Types Range = 0x%x\n"), m_dwPDBTotalSymbolTypesRange);
								}
									
								break;

							case SYMBOL_POSSIBLE_MISMATCH:
								if(m_tszPDBModuleFileSystemPath )
								{
									// Output PDB info as appropriate
									if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, m_tszPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
									}
									else
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, m_tszDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
									}

									//
									// Output the PDB data itself...
									//
									OutputDataToStdoutPdbSymbolInfo(m_dwPDBFormatSpecifier, m_tszPDBModuleFileSystemPath, m_dwPDBSignature, m_tszPDBGuid, m_dwPDBAge, TEXT("DISCREPANCY"));
								}
								break;

							case SYMBOL_INVALID_FORMAT:
								if(m_tszPDBModuleFileSystemPath )
								{
									// Output PDB info as appropriate
									if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, m_tszPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
									}
									else
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, m_tszDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
									}
								
									_tprintf(TEXT("  PDB File = %s [INVALID_FORMAT]\n"), m_tszPDBModuleFileSystemPath );
								}
								break;

							case SYMBOL_NO_HELPER_DLL:
								if(m_tszPDBModuleFileSystemPath )
								{
									// Output PDB info as appropriate
									if (m_enumPEImageSymbolStatus == SYMBOLS_PDB)
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwPEImageDebugDirectoryPDBFormatSpecifier, m_tszPEImageDebugDirectoryPDBPath, m_dwPEImageDebugDirectoryPDBSignature, m_tszPEImageDebugDirectoryPDBGuid, m_dwPEImageDebugDirectoryPDBAge);
									}
									else
									{
										OutputDataToStdoutPdbSymbolInfo(m_dwDBGDebugDirectoryPDBFormatSpecifier, m_tszDBGDebugDirectoryPDBPath, m_dwDBGDebugDirectoryPDBSignature, m_tszDBGDebugDirectoryPDBGuid, m_dwDBGDebugDirectoryPDBAge);
									}
								
									_tprintf(TEXT("  PDB File = %s [Unable to Validate]\n"), m_tszPDBModuleFileSystemPath );
								}
								break;
						}
					} else
					{
						OutputDataToStdoutInternalSymbolInfo(m_dwPEImageDebugDirectoryCoffSize, m_dwPEImageDebugDirectoryFPOSize, m_dwPEImageDebugDirectoryCVSize, m_dwPEImageDebugDirectoryOMAPtoSRCSize, m_dwPEImageDebugDirectoryOMAPfromSRCSize);
						OutputDataToStdoutDbgSymbolInfo(m_tszPEImageDebugDirectoryDBGPath, m_dwPEImageTimeDateStamp, m_dwPEImageCheckSum, m_dwPEImageSizeOfImage);
						_tprintf(TEXT("  Module has PDB File\n"));
						_tprintf(TEXT("  Module Pointer to PDB = [UNKNOWN] (Could not find in PE Image)\n"));
					};
				};
			}
	}

	// Should we tack an extra carriage-return?
	if ( fPrintCarriageReturn )
		_tprintf(TEXT("\n"));

	return true;
}

LPTSTR CModuleInfo::SymbolModuleStatusString(enum SymbolModuleStatus enumModuleStatus)
{
	LPTSTR tszStringPointer = NULL;

	// Output the Symbol Information for the PE module
	switch (enumModuleStatus)
	{
		case SYMBOL_NOT_FOUND:
			tszStringPointer = TEXT("SYMBOL_NOT_FOUND");
			break;

		case SYMBOL_MATCH:
			tszStringPointer = TEXT("SYMBOL_MATCH");
			break;

		case SYMBOL_POSSIBLE_MISMATCH:
			tszStringPointer = TEXT("SYMBOL_POSSIBLE_MISMATCH");
			break;

		case SYMBOL_INVALID_FORMAT:
			tszStringPointer = TEXT("SYMBOL_INVALID_FORMAT");
			break;

		case SYMBOL_NO_HELPER_DLL:
			tszStringPointer = TEXT("SYMBOL_NO_HELPER_DLL");
			break;

		default:
			tszStringPointer = NULL;
	}

	return tszStringPointer;
}

LPTSTR CModuleInfo::SymbolInformationString(enum SymbolInformationForPEImage enumSymbolInformationForPEImage)
{
	LPTSTR tszStringPointer = NULL;

	// Ouput the Symbol Information for the PE module
	switch (enumSymbolInformationForPEImage)
	{
		case SYMBOL_INFORMATION_UNKNOWN:
			tszStringPointer = TEXT("SYMBOL_INFORMATION_UNKNOWN");
			break;

		case SYMBOLS_NO:
			tszStringPointer = TEXT("SYMBOLS_NO");
			break;

		case SYMBOLS_LOCAL:
			tszStringPointer = TEXT("SYMBOLS_LOCAL");
			break;
		
		case SYMBOLS_DBG:
			tszStringPointer = TEXT("SYMBOLS_DBG");
			break;
		
		case SYMBOLS_DBG_AND_PDB:
			tszStringPointer = TEXT("SYMBOLS_DBG_AND_PDB");
			break;

		case SYMBOLS_PDB:
			tszStringPointer = TEXT("SYMBOLS_PDB");
			break;

		default:
			tszStringPointer = NULL;
	}

	return tszStringPointer;
}

bool CModuleInfo::GetModuleInfoFromPEImage(LPTSTR tszModulePath, const bool fDmpFile, const DWORD64 dw64ModAddress)
{
	HANDLE hModuleHandle = 		INVALID_HANDLE_VALUE;
	bool fReturn = false;

	// PE File Version
	TCHAR tszFileName[_MAX_FNAME];
	TCHAR tszFileExtension[_MAX_EXT];
	DWORD dwVersionInfoSize = 0;
	DWORD dwHandle = 0;
	LPBYTE lpBuffer = NULL;
	VS_FIXEDFILEINFO * lpFixedFileInfo = NULL;
	DWORD * pdwLang = NULL;
	unsigned int cbLang = 0;
	unsigned int uint = 0;
	TCHAR achName[256];
	LPTSTR psz = NULL;
	
	// PE Image Locals
	IMAGE_DOS_HEADER    		ImageDosHeader;
	DWORD 				  		dwMagic;
	IMAGE_FILE_HEADER    		ImageFileHeader;
	IMAGE_DATA_DIRECTORY 		DebugImageDataDirectory;
	IMAGE_OPTIONAL_HEADER64 	ImageOptionalHeader64;
	PIMAGE_OPTIONAL_HEADER32 	lpImageOptionalHeader32 = NULL;
	PIMAGE_SECTION_HEADER 		lpImageSectionHeader = NULL;
	ULONG				 		OffsetImageDebugDirectory;


	unsigned long				ul;
//	bool						fDBGSymbolStrippedFromImage = false;
	bool						fCodeViewSectionFound = false;
//	unsigned long				NumDebugDirs;
	
	// Save the base address so that all DmpFile reads become relative to this...
	m_dw64BaseAddress = dw64ModAddress;

	// We don't know anything about symbols yet... (we may not when we exit if the user
	// didn't ask us to look...)
	m_enumPEImageSymbolStatus = SYMBOL_INFORMATION_UNKNOWN;

	if (!fDmpFile)
	{
		// Copy the Module Name to the ModuleInfo Object...
		_tsplitpath(m_tszPEImageModuleFileSystemPath, NULL, NULL, tszFileName, tszFileExtension);

		if (tszFileName && tszFileExtension)
		{
			// Compose the module name...
			m_tszPEImageModuleName = new TCHAR[_tcsclen(tszFileName)+_tcsclen(tszFileExtension)+1];
			
			if (!m_tszPEImageModuleName)
				goto cleanup;

			_tcscpy(m_tszPEImageModuleName, tszFileName);
			_tcscat(m_tszPEImageModuleName, tszFileExtension);
		}

		// Let's open the file... we use this for both Version Info and Symbol Info
		// gathering...
		hModuleHandle = CreateFile(   tszModulePath,
									  GENERIC_READ ,
									  FILE_SHARE_READ,
									  NULL,
									  OPEN_EXISTING,
									  0,
									  0);

		if (hModuleHandle == INVALID_HANDLE_VALUE)
		{
			goto cleanup;
		}
	}
	
	// Did the user request version information?
	if (g_lpProgramOptions->GetMode(CProgramOptions::CollectVersionInfoMode) && !fDmpFile)
	{

		// Now, get CheckSum, TimeDateStamp, and other Image properties...
		BY_HANDLE_FILE_INFORMATION lpFileInformation;

		if ( GetFileInformationByHandle(hModuleHandle, &lpFileInformation) )
		{
			// Get the file size...
			m_dwPEImageFileSize = lpFileInformation.nFileSizeLow;

			m_ftPEImageFileTimeDateStamp = lpFileInformation.ftLastWriteTime;
		}

		// First, is there any FileVersionInfo at all?
		dwVersionInfoSize = GetFileVersionInfoSize(m_tszPEImageModuleFileSystemPath, &dwHandle);

		if (dwVersionInfoSize != 0)
		{
			// Allocate a buffer to read into...
			lpBuffer = new BYTE[dwVersionInfoSize];
			
			if (lpBuffer)
			{
				// Okay... query to get this version info...
				if (GetFileVersionInfo(m_tszPEImageModuleFileSystemPath, dwHandle, dwVersionInfoSize, lpBuffer))
				{
					// Well, we returned the buffer...
					m_fPEImageFileVersionInfo = true;

						// Get the VS_FIXEDFILEINFO structure which carries version info...
					if (VerQueryValue(lpBuffer, TEXT("\\"), (LPVOID *)&lpFixedFileInfo, &uint))
					{
						m_dwPEImageFileVersionMS = lpFixedFileInfo->dwFileVersionMS;
						m_dwPEImageFileVersionLS = lpFixedFileInfo->dwFileVersionLS;

						m_dwPEImageProductVersionMS = lpFixedFileInfo->dwProductVersionMS;
						m_dwPEImageProductVersionLS = lpFixedFileInfo->dwProductVersionLS;

						// Okay, before we go allocating a version string... let's ensure
						// we actually have a version number worth reporting...
						if ( m_dwPEImageFileVersionMS || m_dwPEImageFileVersionLS )
						{
							m_tszPEImageFileVersionString = new TCHAR[1+5+1+5+1+5+1+5+1+1]; // Format will be (#.#:#.#) where each # is a word

							if (m_tszPEImageFileVersionString) // Okay, blitz the data into place...
								_stprintf( m_tszPEImageFileVersionString, TEXT("(%d.%d:%d.%d)"), HIWORD(m_dwPEImageFileVersionMS), LOWORD(m_dwPEImageFileVersionMS), HIWORD(m_dwPEImageFileVersionLS), LOWORD(m_dwPEImageFileVersionLS) );
						}

						// Okay, before we go allocating a version string... let's ensure
						// we actually have a version number worth reporting...
						if ( m_dwPEImageProductVersionMS || m_dwPEImageProductVersionLS )
						{
							m_tszPEImageProductVersionString = new TCHAR[1+5+1+5+1+5+1+5+1+1]; // Format will be (#.#:#.#) where each # is a word

							if (m_tszPEImageProductVersionString) // Okay, blitz the data into place...
								_stprintf( m_tszPEImageProductVersionString, TEXT("(%d.%d:%d.%d)"), HIWORD(m_dwPEImageFileVersionMS), LOWORD(m_dwPEImageFileVersionMS), HIWORD(m_dwPEImageProductVersionLS), LOWORD(m_dwPEImageProductVersionLS) );
						}

					}

					// Get the language and codepage information for the CompanyName and
					// FileDescription string table resources...
					if (VerQueryValue(lpBuffer, TEXT("\\VarFileInfo\\Translation"), (LPVOID *)&pdwLang, &cbLang))
					{
						_stprintf(achName,TEXT("\\StringFileInfo\\%04x%04x\\CompanyName"),
										LOWORD(*pdwLang),
										HIWORD(*pdwLang));

						if (VerQueryValue(lpBuffer, achName, (LPVOID *)&psz, &uint))
						{
							// Cool, we have a Company Name...
							if (psz && *psz)
							{
								m_tszPEImageFileVersionCompanyName = new TCHAR[_tcslen(psz)+1];

								if (m_tszPEImageFileVersionCompanyName)
									_tcscpy(m_tszPEImageFileVersionCompanyName, psz);
							}

						}

						_stprintf(achName,TEXT("\\StringFileInfo\\%04x%04x\\FileDescription"),
										LOWORD(*pdwLang),
										HIWORD(*pdwLang));

						if (VerQueryValue(lpBuffer, achName, (LPVOID *)&psz, &uint))
						{
							// Cool, we have a Company Name...
							if (psz && *psz)
							{
								m_tszPEImageFileVersionDescription = new TCHAR[_tcslen(psz)+1];
								if (m_tszPEImageFileVersionDescription)
									_tcscpy(m_tszPEImageFileVersionDescription, psz);
							}

						}

						// If we still don't have a proper file version... just try
						// and grab the FileVersion string and hope it's good...
						if ( !m_dwPEImageFileVersionMS && !m_dwPEImageFileVersionLS )
						{
							_stprintf(achName,TEXT("\\StringFileInfo\\%04x%04x\\FileVersion"),
											LOWORD(*pdwLang),
											HIWORD(*pdwLang));

							if (VerQueryValue(lpBuffer, achName, (LPVOID *)&psz, &uint))
							{
								// Cool, we have a FileVersion String...
								if (psz && *psz)
								{
									m_tszPEImageFileVersionString = new TCHAR[_tcslen(psz)+1];
									if (m_tszPEImageFileVersionString)
										_tcscpy(m_tszPEImageFileVersionString, psz);
								}
							}
						}
						// If we still don't have a proper file version... just try
						// and grab the ProductVersion string and hope it's good...
						if ( !m_dwPEImageProductVersionMS && !m_dwPEImageProductVersionLS )
						{
							_stprintf(achName,TEXT("\\StringFileInfo\\%04x%04x\\ProductVersion"),
											LOWORD(*pdwLang),
											HIWORD(*pdwLang));

							if (VerQueryValue(lpBuffer, achName, (LPVOID *)&psz, &uint))
							{
								// Cool, we have a FileVersion String...
								if (psz && *psz)
								{
									m_tszPEImageProductVersionString = new TCHAR[_tcslen(psz)+1];
									if (m_tszPEImageProductVersionString)
										_tcscpy(m_tszPEImageProductVersionString, psz);
								}
							}
						}
					}
				}
			}
		}
	}
	
	// If the user chose not to collect or verify symbol information, then bail out of here...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::OutputSymbolInformationMode) &&
 	   !g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
	{
		fReturn = true;
		goto cleanup;
	}
	
	// Start at the top of the image...
	SetReadPointer(fDmpFile, hModuleHandle, 0, FILE_BEGIN);

	// Read in a dos exe header
	if ( !DoRead(fDmpFile, hModuleHandle, &ImageDosHeader, sizeof(ImageDosHeader) ) )
		goto cleanup;
	
	if (ImageDosHeader.e_magic != IMAGE_DOS_SIGNATURE)
	{	// No sense in going further since we're expecting a PE image file...
		goto cleanup;
	}

	if (ImageDosHeader.e_lfanew == 0)
	{ // This is a DOS program... very odd...
		goto cleanup;
	}

	// Great, we have a valid DOS_SIGNATURE... now read in the NT_SIGNATURE?!
	SetReadPointer(fDmpFile, hModuleHandle, ImageDosHeader.e_lfanew, FILE_BEGIN);

	// Read in a DWORD to see if this is an image worth looking at...
	if ( !DoRead(fDmpFile, hModuleHandle, &dwMagic, sizeof(DWORD)) )
		goto cleanup;

	// Probe to see if this is a valid image... we only handle NT images (PE/PE64)
	if (dwMagic != IMAGE_NT_SIGNATURE)
		goto cleanup;

	// Now read the ImageFileHeader...
	if ( !DoRead(fDmpFile, hModuleHandle, &ImageFileHeader, sizeof(IMAGE_FILE_HEADER)) )
		goto cleanup;	

	// Okay, we have a PE Image!!!!

	// Save the Time Date Stamp
	m_dwPEImageTimeDateStamp = ImageFileHeader.TimeDateStamp;

	// Save the Machine Architecture
	m_wPEImageMachineArchitecture = ImageFileHeader.Machine;

	// Save the PE Image Characteristics
	m_wCharacteristics = ImageFileHeader.Characteristics;

	// The OptionalHeader is necessary to get the SizeOfImage and to find the DebugDirectoryInfo.
	if (ImageFileHeader.SizeOfOptionalHeader == 0)
		goto cleanup;

	// Now... the size of the Optional Header is DIFFERENT between PE32 and PE64...
	// The only items we need from the option header are:
	//
	// ULONG CheckSum
	// ULONG SizeOfImage
	// IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG]
	//
	// We'll read as a PE64 (since it's larger) and cast to PE32 if required...
	if ( !DoRead(fDmpFile, hModuleHandle, &ImageOptionalHeader64, sizeof(IMAGE_OPTIONAL_HEADER64)) )
		goto cleanup;

	switch (ImageOptionalHeader64.Magic)
	{
		case IMAGE_NT_OPTIONAL_HDR32_MAGIC:

			m_enumPEImageType = PE32;

			lpImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&ImageOptionalHeader64;

			// Save the Checksum info (though it's not very relavent to identifying symbols)
			m_dwPEImageCheckSum = lpImageOptionalHeader32->CheckSum;

			// Save the SizeOfImage info...
			m_dwPEImageSizeOfImage = lpImageOptionalHeader32->SizeOfImage;

			// Get the preferred load address (but only if we don't already have one)
			if (m_dw64BaseAddress != 0)
			{
				m_dw64BaseAddress = lpImageOptionalHeader32->ImageBase;
			}
			
			DebugImageDataDirectory.Size = lpImageOptionalHeader32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
			DebugImageDataDirectory.VirtualAddress = lpImageOptionalHeader32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
			
			break;

		case IMAGE_NT_OPTIONAL_HDR64_MAGIC:

			m_enumPEImageType = PE64;

			// Save the Checksum info (though it's not very relavent to identifying symbols)
			m_dwPEImageCheckSum = ImageOptionalHeader64.CheckSum;

			// Save the SizeOfImage info...
			m_dwPEImageSizeOfImage = ImageOptionalHeader64.SizeOfImage;

			// Get the preferred load address (but only if we don't already have one)
			if (m_dw64BaseAddress != 0)
			{
				m_dw64BaseAddress = ImageOptionalHeader64.ImageBase;
			}
			
			DebugImageDataDirectory.Size = ImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
			DebugImageDataDirectory.VirtualAddress = ImageOptionalHeader64.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
				
			break;

		default:
			goto cleanup;

	}

	// Let's quickly look to see if there is even a Debug Directory in the PE image!
	if (DebugImageDataDirectory.Size == 0)
	{
		m_enumPEImageSymbolStatus = SYMBOLS_NO;
		fReturn = true;
		goto cleanup; // No Debug Directory found...
	}

	// Now, go ahead and allocate the storage...
	lpImageSectionHeader = (PIMAGE_SECTION_HEADER) new IMAGE_SECTION_HEADER[ImageFileHeader.NumberOfSections];

	if (lpImageSectionHeader == NULL)
		goto cleanup;

 	// Set the pointer to the start of the Section Headers... (we may need to back up if we  read
	// PE64 Optional Headers and this is a PE32 image...
	if (m_enumPEImageType == PE32)
	{
		SetReadPointer(fDmpFile, hModuleHandle, (LONG)(sizeof(IMAGE_OPTIONAL_HEADER32)-sizeof(IMAGE_OPTIONAL_HEADER64)), FILE_CURRENT);
	}

	// Read in the Section Headers...
	if (!DoRead(fDmpFile, hModuleHandle, lpImageSectionHeader, (ImageFileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER))))
		goto cleanup;

	// Let's walk through these Section Headers...

	// For PE images, walk the section headers looking for the
	// one that's got the debug directory.
	for (ul=0; ul < ImageFileHeader.NumberOfSections; ul++) {

		// If the virtual address for the Debug Entry falls into this section header, then we've found it!
		if ( DebugImageDataDirectory.VirtualAddress >= lpImageSectionHeader[ul].VirtualAddress &&
			 DebugImageDataDirectory.VirtualAddress < lpImageSectionHeader[ul].VirtualAddress + lpImageSectionHeader[ul].SizeOfRawData )
		{
			break;
		}
	}

	// Assuming we haven't exhausted the list of section headers, we should have the debug directory now.
	if (ul >= ImageFileHeader.NumberOfSections)
	{
		m_enumPEImageSymbolStatus = SYMBOLS_NO;
		fReturn = true;
		goto cleanup; // No Debug Directory found...
	}

	// For a DmpFile, the address is based on the Section Header's Virtual Address, not PointerToRawData
	if (fDmpFile)
	{
		OffsetImageDebugDirectory = ((DebugImageDataDirectory.VirtualAddress - lpImageSectionHeader[ul].VirtualAddress) + lpImageSectionHeader[ul].VirtualAddress);

	} else
	{
		OffsetImageDebugDirectory = ((DebugImageDataDirectory.VirtualAddress - lpImageSectionHeader[ul].VirtualAddress) + lpImageSectionHeader[ul].PointerToRawData);
	}
	
//	NumDebugDirs = DebugImageDataDirectory.Size / sizeof(IMAGE_DEBUG_DIRECTORY);

	if (!ProcessDebugDirectory(true, fDmpFile, hModuleHandle, DebugImageDataDirectory.Size, OffsetImageDebugDirectory))
		goto cleanup;

	fReturn = true;

//	fDBGSymbolStrippedFromImage		= (ImageFileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) == IMAGE_FILE_DEBUG_STRIPPED;
//	fIMAGE_FILE_LOCAL_SYMS_STRIPPED = (ImageFileHeader.Characteristics & IMAGE_FILE_LOCAL_SYMS_STRIPPED) == IMAGE_FILE_LOCAL_SYMS_STRIPPED;

	/**
	**
	**	What type of symbols were found to be present...
	**
	**	NO SYMBOLS
	**	=============
	**	No Debug Directory
	**	NO Debug information stripped
	**	Symbols stripped
	**
	**	LOCAL SYMBOLS
	**	=============
	**	Debug Directory
	**	NO Debug information stripped
	**	NO Symbols stripped
	**
	**	PDB SYMBOL
	**	=============
	**	Debug Directory
	**	NO Debug information stripped
	**	Symbols stripped
	**
	**	DBG SYMBOL
	**	=============
	**	Debug Directory (assumed)
	**	BOTH - YES/NO Debug information stripped
	**	NO Symbols stripped
	**
	 **/

	if ((ImageFileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) == IMAGE_FILE_DEBUG_STRIPPED)
	{ // Debug Information Stripped!  (A DBG file is assumed)
		m_enumPEImageSymbolStatus = SYMBOLS_DBG;
	} else
	{ 
		// Debug Information NOT stripped! (Either a PDB exists, or symbols are local, or both...)
		if ( ( m_tszPEImageDebugDirectoryPDBPath) || (fDmpFile && fCodeViewSectionFound) )
		{	// If we find PDB data, a PDB file is assumed...
			// Starting with LINK.EXE 6.2 and higher, we'll find PDB data in USER.DMP files....
			m_enumPEImageSymbolStatus = SYMBOLS_PDB;
		} else
		{ // Symbols NOT stripped (Symbols appear to be local to the PE Image)
			m_enumPEImageSymbolStatus = SYMBOLS_LOCAL;
		}
	}

cleanup:

		if (hModuleHandle != INVALID_HANDLE_VALUE)
		CloseHandle(hModuleHandle);

	if (lpImageSectionHeader)
		delete [] lpImageSectionHeader;

	return fReturn;

}

bool CModuleInfo::GetModuleInfoFromCSVFile(LPTSTR tszModulePath)
{
	TCHAR tszFileName[_MAX_FNAME];
	TCHAR tszFileExtension[_MAX_EXT];

	// Copy the Module Name to the ModuleInfo Object...
	_tsplitpath(tszModulePath, NULL, NULL, tszFileName, tszFileExtension);

	if (tszFileName && tszFileExtension)
	{
		// Compose the module name...
		m_tszPEImageModuleName = new TCHAR[_tcsclen(tszFileName)+_tcsclen(tszFileExtension)+1];
		
		if (!m_tszPEImageModuleName)
			return false;

		_tcscpy(m_tszPEImageModuleName, tszFileName);
		_tcscat(m_tszPEImageModuleName, tszFileExtension);
	}

	// Get the symbol status
	enum {BUFFER_SIZE = 32};
	char szSymbolStatus[BUFFER_SIZE];

	m_lpInputFile->ReadString(szSymbolStatus, BUFFER_SIZE);

	// Get the enum value for this string...
	m_enumPEImageSymbolStatus = SymbolInformation(szSymbolStatus);
	
	// Reset the symbol status if it is DBG/PDB (that may have
	// applied on the other machine where the data was captured,
	// but on this machine we'll have to find the DBG file
	// first, then see if a PDB file exists...
	if (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB)
		m_enumPEImageSymbolStatus = SYMBOLS_DBG;

	m_lpInputFile->ReadDWORD(&m_dwPEImageCheckSum);

	m_lpInputFile->ReadDWORD((LPDWORD)&m_dwPEImageTimeDateStamp);

	// Skip the time/date string...
	m_lpInputFile->ReadString();

	m_lpInputFile->ReadDWORD(&m_dwPEImageSizeOfImage);

	char szBuffer[_MAX_PATH+1];

	DWORD dwStringLength;

	// Read in the DBG Module Path
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good path... allocate space for it...

		m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageDebugDirectoryDBGPath)
			return false;
	}

	// Read in the PDB Module Path
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good path... allocate space for it...
		m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageDebugDirectoryPDBPath)
			return false; // Failure allocating...
	}

	m_lpInputFile->ReadDWORD(&m_dwPEImageDebugDirectoryPDBSignature);
	
	m_lpInputFile->ReadDWORD(&m_dwPEImageDebugDirectoryPDBAge);

	// Read in the Product Version String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageProductVersionString = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageProductVersionString )
			return false; // Failure allocating...
	}

	// Read in the File Version String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageFileVersionString = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if (!m_tszPEImageFileVersionString )
			return false; // Failure allocating...
	}
	
	// Read in the File Version Company String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageFileVersionCompanyName = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if ( !m_tszPEImageFileVersionCompanyName )
			return false; // Failure allocating...
	}
	
	// Read in the File Version Description String
	dwStringLength = m_lpInputFile->ReadString(szBuffer, _MAX_PATH+1);

	if (dwStringLength)
	{
		// Okay, if we found a good version... allocate space for it...
		m_tszPEImageFileVersionDescription = CUtilityFunctions::CopyAnsiStringToTSTR(szBuffer);

		if ( !m_tszPEImageFileVersionDescription )
			return false; // Failure allocating...
	}
	
	m_lpInputFile->ReadDWORD(&m_dwPEImageFileSize);
	
	m_lpInputFile->ReadDWORD(&m_ftPEImageFileTimeDateStamp.dwHighDateTime);

	m_lpInputFile->ReadDWORD(&m_ftPEImageFileTimeDateStamp.dwLowDateTime);

	// Okay... read to the start of the next line...
	m_lpInputFile->ReadFileLine();

	return true;
}

// This function is for ANSI strings explicitly because we only need to map these from
// ANSI strings read from a file, to an enum...
CModuleInfo::SymbolInformationForPEImage CModuleInfo::SymbolInformation(LPSTR szSymbolInformationString)
{
	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_DBG"))
		return SYMBOLS_DBG;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_PDB"))
		return SYMBOLS_PDB;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_DBG_AND_PDB"))
		return SYMBOLS_DBG_AND_PDB;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_NO"))
		return SYMBOLS_NO;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOLS_LOCAL"))
		return SYMBOLS_LOCAL;

	if (0 == _stricmp(szSymbolInformationString, "SYMBOL_INFORMATION_UNKNOWN"))
		return SYMBOL_INFORMATION_UNKNOWN;

	return SYMBOL_INFORMATION_UNKNOWN;
}

bool CModuleInfo::OutputFileTime(FILETIME ftFileTime, LPTSTR tszFileTime, int iFileTimeBufferSize)
{

	// Thu Oct 08 15:37:22 1998

	FILETIME ftLocalFileTime;
	SYSTEMTIME lpSystemTime;
	int cch = 0, cch2 = 0;

	// Let's convert this to a local file time first...
	if (!FileTimeToLocalFileTime(&ftFileTime, &ftLocalFileTime))
		return false;

	FileTimeToSystemTime( &ftLocalFileTime, &lpSystemTime );
	
	cch = GetDateFormat( LOCALE_USER_DEFAULT,
						 0,
						 &lpSystemTime,
						 TEXT("ddd MMM dd"),
						 tszFileTime,
						 iFileTimeBufferSize );

	if (!cch)
		return false;

	// Let's keep going...
	tszFileTime[cch-1] = TEXT(' ');

	//
    // Get time and format to characters
    //
     cch2 = GetTimeFormat( LOCALE_USER_DEFAULT,
						   NULL,
						   &lpSystemTime,
						   TEXT("HH':'mm':'ss"),
						   tszFileTime + cch,
						   iFileTimeBufferSize - cch );

	// Let's keep going... we have to tack on the year...
	tszFileTime[cch + cch2 - 1] = TEXT(' ');

	GetDateFormat( LOCALE_USER_DEFAULT,
					 0,
					 &lpSystemTime,
					 TEXT("yyyy"),
					 tszFileTime + cch + cch2,
					 iFileTimeBufferSize - cch - cch2);
	return true;
}

bool CModuleInfo::SetModulePath(LPTSTR tszModulePath)
{
	// Copy the Module Path to the ModuleInfo Object...
	if (!tszModulePath) {
		return false;
	}

	if (m_tszPEImageModuleFileSystemPath)
		delete [] m_tszPEImageModuleFileSystemPath;

	m_tszPEImageModuleFileSystemPath = new TCHAR[(_tcsclen(tszModulePath)+1)];

	if (!m_tszPEImageModuleFileSystemPath)
		return false;

	_tcscpy(m_tszPEImageModuleFileSystemPath, tszModulePath);
	return true;
}

bool CModuleInfo::HandlePDBOpenValidateReturn(PDB * lpPdb, LPTSTR tszPDBLocal, EC ec)
{
	char szPDBLocal[_MAX_PATH+1];

	// What we do now is based on the return from PDBOpenValidate()
	switch (ec)
	{
		case EC_NOT_FOUND:
			break; // Not here, go back for more...
		
		case EC_OK:
			// Yee haa... save the data for sure...
			m_enumPDBModuleStatus = SYMBOL_MATCH;

			// On a perfect match, these must be equal...
			m_dwPDBSignature = m_dwPEImageDebugDirectoryPDBSignature;
			m_dwPDBAge = m_dwPEImageDebugDirectoryPDBAge;

			// We're saving this... delete an existing one if found...
			if (m_tszPDBModuleFileSystemPath)
			{
				delete [] m_tszPDBModuleFileSystemPath;
				m_tszPDBModuleFileSystemPath = NULL;
			}

			m_tszPDBModuleFileSystemPath = CUtilityFunctions::CopyString(tszPDBLocal);

			_tcscpy(m_tszPDBModuleFileSystemPath, tszPDBLocal);

			if (!m_tszPDBModuleFileSystemPath)
				return false;

			// Now that we're done verifying the module... do we save the symbol in
			// our tree?
			if ( g_lpProgramOptions->GetMode(CProgramOptions::BuildSymbolTreeMode) )
			{
				// Yup...
				CUtilityFunctions::CopySymbolFileToSymbolTree(m_tszPEImageModuleName, &m_tszPDBModuleFileSystemPath, g_lpProgramOptions->GetSymbolTreeToBuild());
			}

			//
			// Is there any Private Information (Source Enabled?)
			//
			if (!ProcessPDBSourceInfo(lpPdb))
				return false;
			
			break;

		case EC_FORMAT:
			// This deserves an error of its own...
			m_enumPDBModuleStatus = SYMBOL_INVALID_FORMAT;

			// We'll only save this if we don't already have one...
			if (m_tszPDBModuleFileSystemPath == NULL)
			{
				m_tszPDBModuleFileSystemPath = CUtilityFunctions::CopyString(tszPDBLocal);

				if (!m_tszPDBModuleFileSystemPath)
					return false;
			}
			break;
		
		case EC_INVALID_SIG:
		case EC_INVALID_AGE:
			// We'll save the location only for interests sake (and only if we
			// don't have a PDB path already...

			// Maybe we need to be more granular?
			m_enumPDBModuleStatus = SYMBOL_POSSIBLE_MISMATCH;

			// We'll only save this if we don't already have one...
			if (m_tszPDBModuleFileSystemPath == NULL)
			{
				m_tszPDBModuleFileSystemPath = CUtilityFunctions::CopyString(tszPDBLocal);

				if (!m_tszPDBModuleFileSystemPath)
					return false;
			}

			// Okay, we know that we had a bad match, but we don't know why... let's
			// go ahead and figure it out...
			EC ec;
			char szError[cbErrMax];
			PDB *pPdb;

			CUtilityFunctions::CopyTSTRStringToAnsi(tszPDBLocal, szPDBLocal, _MAX_PATH+1);

			if ( PDBOpen(szPDBLocal,
						  pdbRead,
				          m_dwPEImageDebugDirectoryPDBSignature,
						  &ec,
						  szError,
						  &pPdb) )
			{
				// We opened it...

				// Get the goods...
				m_dwPDBFormatSpecifier = sigNB10;	// TEMPORARY ASSUMPTION!!!
				m_dwPDBSignature = PDBQuerySignature(pPdb);
				m_dwPDBAge = PDBQueryAge(pPdb);
				
				PDBClose(pPdb);
			}
			break;

		case EC_USAGE:
			
			m_enumPDBModuleStatus = SYMBOL_NO_HELPER_DLL;

			// We'll only save this if we don't already have one...
			if (m_tszPDBModuleFileSystemPath == NULL)
			{
				m_tszPDBModuleFileSystemPath = CUtilityFunctions::CopyString(tszPDBLocal);

				if (!m_tszPDBModuleFileSystemPath)
					return false;
			}
			break;

		default:
			break;
	}

	return true;
}

ULONG CModuleInfo::SetReadPointer(bool fDmpFile, HANDLE hModuleHandle, LONG cbOffset, int iFrom)
{
    if (fDmpFile)
	{
        switch( iFrom )
		{
			case FILE_BEGIN:
				m_dwCurrentReadPosition = cbOffset;
				break;

			case FILE_CURRENT:
				m_dwCurrentReadPosition += cbOffset;
				break;

			default:
				break;
        }
	} else
	{
        m_dwCurrentReadPosition = SetFilePointer(hModuleHandle, cbOffset, NULL, iFrom);
    }

    return m_dwCurrentReadPosition;
}

bool CModuleInfo::DoRead(bool fDmpFile, HANDLE hModuleHandle, LPVOID lpBuffer, DWORD cbNumberOfBytesToRead)
{
    DWORD       cbActuallyRead;
	bool fReturn = false;

    if (fDmpFile)
	{
		if (m_lpDmpFile)
		{
			HRESULT Hr;

			if (FAILED(Hr = m_lpDmpFile->m_pIDebugDataSpaces->ReadVirtual(m_dw64BaseAddress+(DWORD64)m_dwCurrentReadPosition,
				lpBuffer,
				cbNumberOfBytesToRead,
				&cbActuallyRead)))
			{
				goto exit;
			}

			if (cbActuallyRead != cbNumberOfBytesToRead)
			{
				goto exit;
			}

		} else
		{
			goto exit;
		}

		m_dwCurrentReadPosition += cbActuallyRead;

    } else if ( (ReadFile(hModuleHandle, lpBuffer, cbNumberOfBytesToRead, &cbActuallyRead, NULL) == 0) ||
                (cbNumberOfBytesToRead != cbActuallyRead) )
	{
        goto exit;
    }

	fReturn = true;

exit:
    return fReturn;
}

bool CModuleInfo::SetDebugDirectoryDBGPath(LPTSTR tszNewDebugDirectoryDBGPath)
{
	if (m_tszPEImageDebugDirectoryDBGPath)
		delete [] m_tszPEImageDebugDirectoryDBGPath;

	m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyString(tszNewDebugDirectoryDBGPath);

	return true;
}

bool CModuleInfo::SetPEDebugDirectoryPDBPath(LPTSTR tszNewDebugDirectoryPDBPath)
{
	if (m_tszPEImageDebugDirectoryPDBPath)
		delete [] m_tszPEImageDebugDirectoryPDBPath;

	m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyString(tszNewDebugDirectoryPDBPath);

	return true;
}

bool CModuleInfo::SetPEImageModulePath(LPTSTR tszNewPEImageModulePath)
{
	if (m_tszPEImageModuleFileSystemPath)
		delete [] m_tszPEImageModuleFileSystemPath;

	m_tszPEImageModuleFileSystemPath = CUtilityFunctions::CopyString(tszNewPEImageModulePath);

	_tcsupr(m_tszPEImageModuleFileSystemPath);

	return true;
}

bool CModuleInfo::SetPEImageModuleName(LPTSTR tszNewModuleName)
{
	if (m_tszPEImageModuleName)
		delete [] m_tszPEImageModuleName;

	m_tszPEImageModuleName = CUtilityFunctions::CopyString(tszNewModuleName);

	_tcsupr(m_tszPEImageModuleName);

	return true;
}


// Evaluate whether we've found the symbolic information for this module
// that the user is looking for.
bool CModuleInfo::GoodSymbolNotFound()
{
	bool fBadSymbol = true;

	// Well, we evaluate success based on the type of symbol we're looking for 
	// and whether it was successfully found.
	switch (GetPESymbolInformation())
	{
		// This is bad... consider this fatal...
		case SYMBOL_INFORMATION_UNKNOWN:
			break;

		// Is this bad?  I think so... but if you inherit a module as an import should you
		// be punished for the ills of another?  Hmm....  For now we'll say it's okay...
		case SYMBOLS_NO:
			fBadSymbol = false;
			break;

		// While this is wasteful, we have symbolic info... so that's cool
		case SYMBOLS_LOCAL:
			fBadSymbol = false;
			break;

		case SYMBOLS_DBG:
			fBadSymbol = SYMBOL_MATCH == GetDBGSymbolModuleStatus();
			break;

		case SYMBOLS_DBG_AND_PDB:
			fBadSymbol = (SYMBOL_MATCH == GetDBGSymbolModuleStatus()) &&
						 (SYMBOL_MATCH == GetPDBSymbolModuleStatus());
			break;
		
		case SYMBOLS_PDB:
			fBadSymbol = SYMBOL_MATCH == GetPDBSymbolModuleStatus();
			break;

		default:
			break;
	}
	return fBadSymbol;
}

//
// Process the DebugDirectory data for a PE image (or a DBG file)
//
bool CModuleInfo::ProcessDebugDirectory(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, unsigned int iDebugDirectorySize, ULONG OffsetImageDebugDirectory)
{
	unsigned int iNumberOfDebugDirectoryEntries = iDebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
	
	//
	// Let's loop through the debug directories and collect the relavent info...
	//
    while (iNumberOfDebugDirectoryEntries--) 
    {
        IMAGE_DEBUG_DIRECTORY ImageDebugDirectory;

 		// Set the pointer to the DebugDirectories entry
		SetReadPointer(fDmpFile, hModuleHandle, OffsetImageDebugDirectory, FILE_BEGIN);

		// Read the DebugDirectoryImage
		if (!DoRead(fDmpFile, hModuleHandle, &ImageDebugDirectory, sizeof(IMAGE_DEBUG_DIRECTORY)))
			goto cleanup;

		//
		// Processing of the Debug Directory is dependent on the type
		//
		switch (ImageDebugDirectory.Type)
		{
			//
			// This is our preferred debug format as it offers full source level debugging (typically)
			//
			case IMAGE_DEBUG_TYPE_CODEVIEW:
				ProcessDebugTypeCVDirectoryEntry(fPEImage, fDmpFile, hModuleHandle, &ImageDebugDirectory);
				break;

			//
			// COFF symbols are okay... CV is better :)
			//
			case IMAGE_DEBUG_TYPE_COFF:
				ProcessDebugTypeCoffDirectoryEntry(fPEImage, &ImageDebugDirectory);
				break;
				
			//
			// MISC implies that a DBG file is created...
			//
			case IMAGE_DEBUG_TYPE_MISC:
				ProcessDebugTypeMiscDirectoryEntry(fPEImage, fDmpFile, hModuleHandle, &ImageDebugDirectory);
				break;
				
			//
			// FPO info is important for working with functions with FPO
			//
			case IMAGE_DEBUG_TYPE_FPO:
				ProcessDebugTypeFPODirectoryEntry(fPEImage, &ImageDebugDirectory);
				break;
				
			case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
			case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
				ProcessDebugTypeOMAPDirectoryEntry(fPEImage, &ImageDebugDirectory);
				break;
				
			case IMAGE_DEBUG_TYPE_UNKNOWN:
			case IMAGE_DEBUG_TYPE_EXCEPTION:
			case IMAGE_DEBUG_TYPE_FIXUP:
			case IMAGE_DEBUG_TYPE_BORLAND:
			case IMAGE_DEBUG_TYPE_RESERVED10:
			case IMAGE_DEBUG_TYPE_CLSID:
				break;

			default:
				break;
		}

        OffsetImageDebugDirectory += sizeof(IMAGE_DEBUG_DIRECTORY);
    }
	
cleanup:

	return true;
}


bool CModuleInfo::ProcessDebugTypeMiscDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	bool				fReturnValue = false;
	PIMAGE_DEBUG_MISC 	lpImageDebugMisc = NULL, lpCurrentImageDebugMiscPointer = NULL;
	ULONG	 			OffsetImageDebugDirectory = NULL;
	unsigned long 		ulSizeOfMiscDirectoryEntry = lpImageDebugDirectory->SizeOfData;

	//
	// DBG files tend to store the EXE name here... not too useful for now...
	//
	if (!fPEImage)
	{
		fReturnValue = true;
		goto cleanup;
	}

	//
	// Allocate storage for the MISC data...
	//
	lpImageDebugMisc = (PIMAGE_DEBUG_MISC) new BYTE[ulSizeOfMiscDirectoryEntry];

	if (lpImageDebugMisc == NULL)
		goto cleanup;
	
	// Calculate the location/size so we can load it.
	if (fDmpFile)
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->AddressOfRawData;
	} else
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->PointerToRawData;
	}

	// Advance to the location of the Debug Info
	SetReadPointer(fDmpFile, hModuleHandle, OffsetImageDebugDirectory, FILE_BEGIN);

	// Read the data...
	if (!DoRead(fDmpFile, hModuleHandle, lpImageDebugMisc, ulSizeOfMiscDirectoryEntry))
		goto cleanup;

	// Set our pointer to the start of our data...
	lpCurrentImageDebugMiscPointer = lpImageDebugMisc;
	
	//
	// The logic of this routine will skip past bad sections of the MISC datastream...
	//
	while(ulSizeOfMiscDirectoryEntry > 0)
	{
		//
		// Hopefully we have a string here...
		//
		if (lpCurrentImageDebugMiscPointer->DataType == IMAGE_DEBUG_MISC_EXENAME)
		{
			LPSTR lpszExeName;

            lpszExeName = (LPSTR)&lpCurrentImageDebugMiscPointer->Data[ 0 ];
					
			// Save off the DBG Path...
			if (m_tszPEImageDebugDirectoryDBGPath)
				delete [] m_tszPEImageDebugDirectoryDBGPath;

			if (lpCurrentImageDebugMiscPointer->Unicode)
			{
				// Is this a Unicode string?
				m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyUnicodeStringToTSTR((LPWSTR)lpszExeName);
			} else
			{
				// Is this an ANSI string?
				m_tszPEImageDebugDirectoryDBGPath = CUtilityFunctions::CopyAnsiStringToTSTR(lpszExeName);
			}

			if (!m_tszPEImageDebugDirectoryDBGPath)
				goto cleanup;

				break;
		
	
		} else
		{
			// Beware of corrupt images
			if (lpCurrentImageDebugMiscPointer->Length == 0)
			{
				break;
			}

			// Decrement the ulSizeOfMiscDirectoryEntry by the length of this "stuff"
    		ulSizeOfMiscDirectoryEntry -= lpCurrentImageDebugMiscPointer->Length;

			// If our new value exceeds the SizeOfData we need to bail...
            if (ulSizeOfMiscDirectoryEntry > lpImageDebugDirectory->SizeOfData)
			{
				ulSizeOfMiscDirectoryEntry = 0; // Avoid AV on bad exe
            	break;
            }
            
            lpCurrentImageDebugMiscPointer = (PIMAGE_DEBUG_MISC) (lpCurrentImageDebugMiscPointer + lpCurrentImageDebugMiscPointer->Length);
			
		}
	
	}

	fReturnValue = true;

cleanup:
	
	if (lpImageDebugMisc)
	{
		delete [] lpImageDebugMisc;
		lpImageDebugMisc = NULL;
	}
	
	return fReturnValue;
}

bool CModuleInfo::ProcessDebugTypeCoffDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	//
	// The only thing we really care about is the size right now...
	//
	if (fPEImage)
	{
		m_dwPEImageDebugDirectoryCoffSize = lpImageDebugDirectory->SizeOfData;
	} else
	{
		m_dwDBGImageDebugDirectoryCoffSize = lpImageDebugDirectory->SizeOfData;
	}

	return true;
}

bool CModuleInfo::ProcessDebugTypeFPODirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	//
	// The only thing we really care about is the size right now...
	//
	if (fPEImage)
	{
		m_dwPEImageDebugDirectoryFPOSize = lpImageDebugDirectory->SizeOfData;
	} else
	{
		m_dwDBGImageDebugDirectoryFPOSize = lpImageDebugDirectory->SizeOfData;
	}

	return true;

}

bool CModuleInfo::ProcessDebugTypeCVDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	bool		fReturnValue = false;
	ULONG		OffsetImageDebugDirectory;
	DWORD 		dwCVFormatSpecifier;
	char		szPdb[_MAX_PATH * 3];	// Must this be so large?
	
	// Calculate the location/size so we can load it.
	if (fDmpFile)
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->AddressOfRawData;
	} else
	{
		OffsetImageDebugDirectory = lpImageDebugDirectory->PointerToRawData;
	}

	// Advance to the location of the Debug Info
	SetReadPointer(fDmpFile, hModuleHandle, OffsetImageDebugDirectory, FILE_BEGIN);

	// Read the data...
	if (!DoRead(fDmpFile, hModuleHandle, &dwCVFormatSpecifier, sizeof(DWORD)))
		goto cleanup;

	if (fPEImage)
	{
		m_dwPEImageDebugDirectoryPDBFormatSpecifier = dwCVFormatSpecifier;
	} else
	{
		m_dwDBGDebugDirectoryPDBFormatSpecifier = dwCVFormatSpecifier;
	}

	switch (dwCVFormatSpecifier)
	{
		case sigNB09:
		case sigNB11:
			//
			// The only thing we really care about is the size right now...
			//
			if (fPEImage)
			{
				m_dwPEImageDebugDirectoryCVSize = lpImageDebugDirectory->SizeOfData;
			} else
			{
				m_dwDBGImageDebugDirectoryCVSize = lpImageDebugDirectory->SizeOfData;
			}
			break;
			
		case sigNB10:

            NB10I nb10i;

			// Read the data...
			if (!DoRead(fDmpFile, hModuleHandle, &nb10i.off, sizeof(NB10I) - sizeof(DWORD)))
				goto cleanup;

			if (fPEImage)
			{
				// Save away the PDB Signature...
				m_dwPEImageDebugDirectoryPDBSignature = nb10i.sig;

				// Save away the PDB Age...
				m_dwPEImageDebugDirectoryPDBAge = nb10i.age;
			} else
			{
				// Save away the PDB Signature...
				m_dwDBGDebugDirectoryPDBSignature = nb10i.sig;

				// Save away the PDB Age...
				m_dwDBGDebugDirectoryPDBAge = nb10i.age;
			}

 			// Read the data...
			if (!DoRead(fDmpFile, hModuleHandle, szPdb, (lpImageDebugDirectory->SizeOfData) - sizeof(NB10I)))
				goto cleanup;

			if (szPdb[0] != '\0')
			{
				// Save the data (as appropriate)
				if (fPEImage)
				{
					// Copy the PDB path away...
					m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyAnsiStringToTSTR(szPdb);

					if (!m_tszPEImageDebugDirectoryPDBPath)
						goto cleanup;
				} else 
				{
					// Copy the PDB path away...
					m_tszDBGDebugDirectoryPDBPath = CUtilityFunctions::CopyAnsiStringToTSTR(szPdb);

					if (!m_tszDBGDebugDirectoryPDBPath)
						goto cleanup;

					// We now know that we have a DBG/PDB combination...
					m_enumPEImageSymbolStatus = SYMBOLS_DBG_AND_PDB;
				}
			}
			break;

		case sigRSDS:
			
            RSDSI rsdsi;

            // Read the RSDSI structure (except for the rsds DWORD at the beginning).
			if (!DoRead(fDmpFile, hModuleHandle, &rsdsi.guidSig, sizeof(RSDSI) - sizeof(DWORD)))
				goto cleanup;

            wchar_t wszGuid[39];

            StringFromGUID2(rsdsi.guidSig, wszGuid, sizeof(wszGuid)/sizeof(wchar_t));

			if (fPEImage)
			{
				// Save away the PDB Age...
				m_dwPEImageDebugDirectoryPDBAge = rsdsi.age;

				// Copy the GUID...
				m_tszPEImageDebugDirectoryPDBGuid = CUtilityFunctions::CopyUnicodeStringToTSTR(wszGuid);
			} else
			{
				// Save away the PDB Age...
				m_dwDBGDebugDirectoryPDBAge = rsdsi.age;

				// Copy the GUID...
				m_tszDBGDebugDirectoryPDBGuid = CUtilityFunctions::CopyUnicodeStringToTSTR(wszGuid);
			}

			// Now, read in the PDB path... apparently it's in UTF8 format...
			if (!DoRead(fDmpFile, hModuleHandle, szPdb, (lpImageDebugDirectory->SizeOfData) - sizeof(RSDSI)))
				goto cleanup;
			
			if (szPdb[0] != '\0')
			{
				// Save the data (as appropriate)
				if (fPEImage)
				{
					wchar_t wszPdb[_MAX_PATH];
					CUtilityFunctions::UTF8ToUnicode(szPdb, wszPdb, sizeof(wszPdb));

					// Copy the PDB path away...
					m_tszPEImageDebugDirectoryPDBPath = CUtilityFunctions::CopyUnicodeStringToTSTR(wszPdb);
					
					if (!m_tszPEImageDebugDirectoryPDBPath)
						goto cleanup;
				} else
				{
					wchar_t wszPdb[_MAX_PATH];
					CUtilityFunctions::UTF8ToUnicode(szPdb, wszPdb, sizeof(wszPdb));

					// Copy the PDB path away...
					m_tszDBGDebugDirectoryPDBPath = CUtilityFunctions::CopyUnicodeStringToTSTR(wszPdb);
					
					if (!m_tszDBGDebugDirectoryPDBPath)
						goto cleanup;
				}
			}
            break;

		// Unknown CV format...
		default:
			break;
	}

	fReturnValue = true;

cleanup:

	return fReturnValue;
}

bool CModuleInfo::ProcessDebugTypeOMAPDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory)
{
	DWORD dwSize = lpImageDebugDirectory->SizeOfData;
	
	//
	// The only thing we really care about is the size right now...
	//
	switch (lpImageDebugDirectory->Type)
	{
		case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
			if (fPEImage)
			{
				m_dwPEImageDebugDirectoryOMAPtoSRCSize = dwSize;
			} else
			{
				m_dwDBGImageDebugDirectoryOMAPtoSRCSize = dwSize;
			}
			
			break;
			
		case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
			if (fPEImage)
			{
				m_dwPEImageDebugDirectoryOMAPfromSRCSize = dwSize;
			} else
			{
				m_dwDBGImageDebugDirectoryOMAPfromSRCSize = dwSize;
			}
			break;
	}

	return true;
}

bool CModuleInfo::OutputDataToStdoutInternalSymbolInfo(DWORD dwCoffSize, DWORD dwFPOSize, DWORD dwCVSize, DWORD dwOMAPtoSRC, DWORD dwOMAPfromSRC)
{
//	_tprintf(TEXT("  Module has internal symbols.\n"));

	if (dwCoffSize)
	{
		_tprintf(TEXT("    Internal COFF   Symbols - Size 0x%08x bytes\n"), dwCoffSize);
	}

	if (dwFPOSize)
	{
		_tprintf(TEXT("    Internal FPO    Symbols - Size 0x%08x bytes\n"), dwFPOSize);
	}

	if (dwCVSize)
	{
		_tprintf(TEXT("    Internal CV     Symbols - Size 0x%08x bytes\n"), dwCVSize);
	}

	if (dwOMAPtoSRC)
	{
		_tprintf(TEXT("    Internal -> SRC Symbols - Size 0x%08x bytes\n"), dwOMAPtoSRC);
	}

	if (dwOMAPfromSRC)
	{
		_tprintf(TEXT("    Internal SRC -> Symbols - Size 0x%08x bytes\n"), dwOMAPfromSRC);
	}

	
	return true;
}

//
// Dump DBG information
//
bool CModuleInfo::OutputDataToStdoutDbgSymbolInfo(LPCTSTR tszModulePointerToDbg, DWORD dwTimeDateStamp, DWORD dwChecksum, DWORD dwSizeOfImage, LPCTSTR tszDbgComment, DWORD dwExpectedTimeDateStamp, DWORD dwExpectedChecksum, DWORD dwExpectedSizeOfImage)
{
	if (!tszDbgComment)
	{
		// Dump out the pointer to the DBG file from the PE Image
		if (tszModulePointerToDbg)
		{
			_tprintf(TEXT("  Module Pointer to DBG = [%s]\n"), tszModulePointerToDbg);
		} else
		{
			_tprintf(TEXT("  Module had DBG File stripped from it.\n"));
		}

		time_t time = dwTimeDateStamp;
		_tprintf(TEXT("    Module TimeDateStamp = 0x%08x - %s"), dwTimeDateStamp, _tctime(&time));
		_tprintf(TEXT("    Module Checksum      = 0x%08x\n"), dwChecksum);
		_tprintf(TEXT("    Module SizeOfImage   = 0x%08x\n"), dwSizeOfImage);

	} else
	{
		TCHAR tszBuffer[2*_MAX_PATH]; // This should be large enough ;)
		size_t tszStringLength;

		// Is this discrepancy stuff...
		if (tszModulePointerToDbg)
		{
			_tprintf(TEXT("  DBG File = [%s] [%s]\n"), tszModulePointerToDbg, tszDbgComment);
		}

		time_t time = dwTimeDateStamp;
		_stprintf(tszBuffer, TEXT("    DBG TimeDateStamp    = 0x%08x - %s"), dwTimeDateStamp, _tctime(&time));

		// If our TimeDateStamps don't match... we have some fixup to do...
		if (dwTimeDateStamp != dwExpectedTimeDateStamp)
		{
			tszStringLength = _tcslen(tszBuffer);
			if (tszBuffer[tszStringLength-1] == '\n')
				tszBuffer[tszStringLength-1] = '\0';
		}
		
		_tprintf(tszBuffer);
		
		// If our TimeDateStamps don't match... we have some fixup to do...
		if (dwTimeDateStamp != dwExpectedTimeDateStamp)
		{
			_tprintf(TEXT(" [%s]!\n"), (dwTimeDateStamp > dwExpectedTimeDateStamp) ? TEXT("NEWER") : TEXT("OLDER"));
		}

		_tprintf(TEXT("    DBG Checksum         = 0x%08x [%s]\n"), dwChecksum, ( (dwChecksum == dwExpectedChecksum) ? TEXT("MATCHED"):TEXT("UNMATCHED")) );
		_tprintf(TEXT("    DBG SizeOfImage      = 0x%08x [%s]\n"), dwSizeOfImage, ( ( dwSizeOfImage == dwExpectedSizeOfImage) ? TEXT("MATCHED"):TEXT("UNMATCHED")) );
	}


	return true;
}

bool CModuleInfo::OutputDataToStdoutPdbSymbolInfo(DWORD dwPDBFormatSpecifier, LPTSTR tszModulePointerToPDB, DWORD dwPDBSignature, LPTSTR tszPDBGuid, DWORD dwPDBAge, LPCTSTR tszPdbComment)
{

	if (tszModulePointerToPDB)
	{
		if (!tszPdbComment)
		{
			_tprintf(TEXT("  Module Pointer to PDB = [%s]\n"), tszModulePointerToPDB);
		} else
		{
			_tprintf(TEXT("  PDB File = [%s] [%s]\n"), tszModulePointerToPDB, tszPdbComment);
		}
		switch (dwPDBFormatSpecifier)
		{
			case sigNB10:
				_tprintf(TEXT("    Module PDB Signature = 0x%x\n"), dwPDBSignature);
				break;
				
			case sigRSDS:
				_tprintf(TEXT("    Module PDB Guid = %s\n"), tszPDBGuid);
				break;
				
			default:
				_tprintf(TEXT("    UNKNOWN PDB Format!\n"));
				break;
		}
		
		_tprintf(TEXT("    Module PDB Age = 0x%x\n"), dwPDBAge);
	} else
	{
		_tprintf(TEXT("  Module has PDB File\n"));
		_tprintf(TEXT("  Module Pointer to PDB = [UNKNOWN] (Could not find in PE Image)\n"));
	}

	return true;
}

bool CModuleInfo::OutputDataToStdoutModuleInfo(DWORD dwModuleNumber)
{
	_tprintf(TEXT("Module[%3d] [%s] %s\n"), dwModuleNumber, m_tszPEImageModuleFileSystemPath, (m_dwPEImageDebugDirectoryCVSize ? TEXT("(Source Enabled)") : TEXT("")));

//	LPTSTR lpMachineArchitecture;
//
//	switch(m_wPEImageMachineArchitecture)
//	{
//		case IMAGE_FILE_MACHINE_I386:
//			lpMachineArchitecture = TEXT("Binary Image for Intel Machines");
//			break;
//
//		case IMAGE_FILE_MACHINE_ALPHA64:
//			lpMachineArchitecture = TEXT("Binary Image for Alpha Machines");
//			break;
//
//		default:
//			lpMachineArchitecture = TEXT("Binary Image for Unknown Machine Architecture");
//	}
//
//	if (m_wPEImageMachineArchitecture) _tprintf(TEXT("  %s\n"), lpMachineArchitecture);

	//
	// First, let's output version information if requested
	//
	if (g_lpProgramOptions->GetMode(CProgramOptions::CollectVersionInfoMode) )
	{
		// Version Information
		if (m_tszPEImageFileVersionCompanyName)	_tprintf(TEXT("  Company Name:      %s\n"), m_tszPEImageFileVersionCompanyName);
		if (m_tszPEImageFileVersionDescription)	_tprintf(TEXT("  File Description:  %s\n"), m_tszPEImageFileVersionDescription);
		if (m_tszPEImageProductVersionString)	_tprintf(TEXT("  Product Version:   %s\n"), m_tszPEImageProductVersionString);
		if (m_tszPEImageFileVersionString)	    _tprintf(TEXT("  File Version:      %s\n"), m_tszPEImageFileVersionString);
		if (m_dwPEImageFileSize)				_tprintf(TEXT("  File Size (bytes): %d\n"), m_dwPEImageFileSize);
		
		if ( m_ftPEImageFileTimeDateStamp.dwHighDateTime || m_ftPEImageFileTimeDateStamp.dwLowDateTime)
		{
			enum { FILETIME_BUFFERSIZE = 128 };
			TCHAR tszFileTime[FILETIME_BUFFERSIZE];
			
			if (OutputFileTime(m_ftPEImageFileTimeDateStamp, tszFileTime, FILETIME_BUFFERSIZE))
				_tprintf(TEXT("  File Date:         %s\n"), tszFileTime);
		}
	}

	return true;
}

bool CModuleInfo::OutputDataToStdoutThisModule()
{
	//
	// If we're not doing "Discrepancies Only" then we output this module unconditionally...
	//
	if (!g_lpProgramOptions->GetMode(CProgramOptions::OutputDiscrepanciesOnly))
		return true;

	//
	// If we're not in verification mode, then we output everything...
	//
	if (!g_lpProgramOptions->GetMode(CProgramOptions::VerifySymbolsMode))
		return true;
	
	//
	// This is "Discrepancy Only" mode, so check for discrepancies...
	//
	bool fAnyDiscrepancies = false;

	// Hey, if they only want to dump out modules with discrepancies... check to see
	// if this qualifies...
	switch (m_enumPEImageSymbolStatus)
	{
		// Consider these normal status codes...
		case SYMBOLS_DBG:
		case SYMBOLS_DBG_AND_PDB:
		case SYMBOLS_PDB:
		case SYMBOLS_LOCAL:
			break;

		// Anything else is worth reporting...
		default:
			fAnyDiscrepancies = true;
	}

	// If we don't have a discrepancy yet... let's look further...
	if (!fAnyDiscrepancies)
	{
		// Is there a DBG file?
		if ( (m_enumPEImageSymbolStatus == SYMBOLS_DBG) ||
			 (m_enumPEImageSymbolStatus == SYMBOLS_DBG_AND_PDB) )
		{
			// Does it match?
			if ( m_enumDBGModuleStatus != SYMBOL_MATCH )
				fAnyDiscrepancies = true;
		}

		// Is there a PDB file?
		if ( GetDebugDirectoryPDBPath() )
		{
			if (m_enumPDBModuleStatus != SYMBOL_MATCH )
				fAnyDiscrepancies = true;
		}
	}

	return fAnyDiscrepancies;
}

bool CModuleInfo::ProcessPDBSourceInfo(PDB *lpPdb)
{
	bool fReturnValue = false;
	DBI* lpDbi = NULL;

	// Module variables...
    Mod * 		lpMod = NULL;
    Mod * 		lpPrevMod = NULL;
    long 		cb;

    // Type variables...
    TPI * 		lpTpi = NULL;
    TI			tiMin;
    TI			tiMac;

	// Summary variables
	m_dwPDBTotalBytesOfLineInformation = 0;
	m_dwPDBTotalBytesOfSymbolInformation = 0;
	m_dwPDBTotalSymbolTypesRange = 0;

    if (!PDBOpenDBI(lpPdb, pdbRead, NULL, &lpDbi))
		goto cleanup;

	//
	// Enumerate through the modules in the Dbi interface we opened...
	//
    while (DBIQueryNextMod(lpDbi, lpMod, &lpMod) && lpMod) 
    {
    	// If we had a Module Previously... close it...
        if (lpPrevMod)
        {
        	ModClose(lpPrevMod);
        	lpPrevMod = NULL;
        }

        // Check that Source line info is removed
        ModQueryLines(lpMod, NULL, &cb);

		// If we have lines... add these to our total...
		m_dwPDBTotalBytesOfLineInformation+= cb;

        // Check that local symbols are removed
        ModQuerySymbols(lpMod, NULL, &cb);

		// If we have symbols for this module... add these to our total...
		m_dwPDBTotalBytesOfSymbolInformation+= cb;

        // Save the current module (so we can close it if needed)...
        lpPrevMod = lpMod;
    }

	//
	// Attempt to open the Tpi Interface
	// 
	PDBOpenTpi(lpPdb, pdbRead, &lpTpi);

	// If we
	if(lpTpi)
	{
		// Find the Min and Max Index...
		tiMin = TypesQueryTiMinEx(lpTpi);
		tiMac = TypesQueryTiMacEx(lpTpi);

		if (tiMin < tiMac)
		{
			m_dwPDBTotalSymbolTypesRange = tiMac - tiMin;
		}

	}

	fReturnValue = true;

cleanup:
	if (lpTpi)
	{
	    TypesClose(lpTpi);
		lpTpi = NULL;
	}
	
    if (lpMod)
    {
    	ModClose(lpMod);
    	lpMod = NULL;
    }
    
    if (lpPrevMod)
    {
    	ModClose(lpPrevMod);
    	lpPrevMod = NULL;
    }
    
	if (lpDbi)
	{
		DBIClose(lpDbi);
	}

    return fReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\modules.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       modules.h
//
//--------------------------------------------------------------------------

// Modules.h: interface for the CModules class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULES_H__04AC8803_D1FA_11D2_8454_0010A4F1B732__INCLUDED_)
#define AFX_MODULES_H__04AC8803_D1FA_11D2_8454_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include "DmpFile.h"
#include "ProgramOptions.h"

// Forward Declarations
class CModuleInfoCache;
class CModuleInfoNode;
class CFileData;
class CModuleInfo;

class CModules  
{

public:

	CModules();
	virtual ~CModules();

	bool Initialize(CModuleInfoCache *lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile);
	bool OutputModulesData(CollectionTypes enumCollectionType, bool fCSVFileContext);
	bool GetModulesData(CProgramOptions::ProgramModes enumProgramModes, bool fGetDataFromCSVFile = false);
//	bool EnumerateModulesFromMemoryDmpFile();
	bool AddNewModuleInfoObject(CModuleInfo *lpModuleInfo);

protected:

	HANDLE m_hModuleInfoHeadMutex;
	enum { MAX_RECURSE_DEPTH = 30 };
	long m_iNumberOfModules;
	bool m_fInitialized;

	CModuleInfoCache * m_lpModuleInfoCache;
	CFileData * m_lpInputFile;
	CFileData * m_lpOutputFile;
	CModuleInfoNode * m_lpModuleInfoHead;
	CDmpFile * m_lpDmpFile;

	bool GetModulesDataFromDeviceDrivers();
	bool GetModulesDataFromFile();
	bool ScavengeForFiles(LPCTSTR tszSymbolPathStart, int iRecurseDepth);
	bool GetModulesDataFromFileSystem();
	bool OutputModulesDataToFile(CollectionTypes enumCollectionType);
	bool OutputModulesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext);

};

#endif // !defined(AFX_MODULES_H__04AC8803_D1FA_11D2_8454_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\moduleinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfo.h
//
//--------------------------------------------------------------------------

// ModuleInfo.h: interface for the CModuleInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULEINFO_H__0D2E8509_A01A_11D2_83A8_000000000000__INCLUDED_)
#define AFX_MODULEINFO_H__0D2E8509_A01A_11D2_83A8_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <windows.h>
#include <tchar.h>
#include <time.h>
#include <stdlib.h>
#include "globals.h"

//
//#include "oemdbi.h"
//
// Bug MSINFO V4.1:655
#define PDB_LIBRARY
#pragma warning( push )
#pragma warning( disable : 4201 )		// Disable "nonstandard extension used : nameless struct/union" warning
#include "PDB.H"
#pragma warning( pop )					// Enable

const ULONG sigRSDS = 'SDSR';
const ULONG sigNB09 = '90BN';
const ULONG sigNB10 = '01BN';
const ULONG sigNB11 = '11BN';
	
// Forward declarations
//class CProgramOptions;
class CSymbolVerification;
class CFileData;
class CDmpFile;

class CModuleInfo
{
	// Definition of Class Constants
	enum { MAX_SEARCH_PATH_LEN=512 };

	//  CodeView Debug OMF signature.  The signature at the end of the file is
	//  a negative offset from the end of the file to another signature.  At
	//  the negative offset (base address) is another signature whose filepos
	//  field points to the first OMFDirHeader in a chain of directories.
	//  The NB05 signature is used by the link utility to indicated a completely
	//  unpacked file.  The NB06 signature is used by ilink to indicate that the
	//  executable has had CodeView information from an incremental link appended
	//  to the executable.  The NB08 signature is used by cvpack to indicate that
	//  the CodeView Debug OMF has been packed.  CodeView will only process
	//  executables with the NB08 signature.

	typedef struct OMFSignature
	{
		char Signature[4];   // "NBxx"
		long filepos;        // offset in file
	};

	typedef struct PDB_INFO
	{
		unsigned long sig;
		unsigned long age;
		char sz[_MAX_PATH];
	};

	//
	// These types are likely to be defined in a header file I include later for the latest
	// OEMDBI toolkit...
	//
	struct NB10I                           // NB10 debug info
	{
		DWORD   nb10;                      // NB10
		DWORD   off;                       // offset, always 0
		DWORD   sig;
		DWORD   age;
	};

	struct RSDSI                           // RSDS debug info
	{
		DWORD   rsds;                      // RSDS
		GUID    guidSig;
		DWORD   age;
	};

public:
	CModuleInfo();
	virtual ~CModuleInfo();

	bool GoodSymbolNotFound();
	bool SetPEImageModuleName(LPTSTR tszNewModuleName);
	bool SetPEImageModulePath(LPTSTR tszNewPEImageModulePath);
	bool SetDebugDirectoryDBGPath(LPTSTR tszNewDebugDirectoryDBGPath);
	bool SetPEDebugDirectoryPDBPath(LPTSTR tszNewDebugDirectoryPDBPath);

	bool Initialize(CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile);

	bool SetModulePath(LPTSTR tszModulePath);
	
	bool VerifySymbols(CSymbolVerification * lpSymbolVerification);
	static BOOL VerifyDBGFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData);
	static BOOL VerifyPDBFile(HANDLE hFileHandle, LPTSTR tszFileName, PVOID CallerData);
	bool OutputData(LPTSTR tszProcessName, DWORD iProcessID, unsigned int dwModuleNumber);
	bool GetModuleInfo(LPTSTR tszModulePath, bool fDmpFile = false, DWORD64 dw64ModAddress = 0, bool fGetDataFromCSVFile = false);
	LPTSTR GetModulePath();

	enum SymbolModuleStatus { SYMBOL_NOT_FOUND, SYMBOL_MATCH, SYMBOL_POSSIBLE_MISMATCH, SYMBOL_INVALID_FORMAT, SYMBOL_NO_HELPER_DLL };
	enum SymbolInformationForPEImage {SYMBOL_INFORMATION_UNKNOWN, SYMBOLS_NO, SYMBOLS_LOCAL, SYMBOLS_DBG, SYMBOLS_DBG_AND_PDB, SYMBOLS_PDB};
	
	// INLINE Methods!
	inline enum SymbolInformationForPEImage GetPESymbolInformation() { return m_enumPEImageSymbolStatus; };
	inline enum SymbolModuleStatus GetDBGSymbolModuleStatus() { return m_enumDBGModuleStatus; };
	inline enum SymbolModuleStatus GetPDBSymbolModuleStatus() { return m_enumPDBModuleStatus; };
	inline DWORD GetRefCount() { return m_dwRefCount; };
	inline DWORD AddRef() { return InterlockedIncrement((long *)&m_dwRefCount); };
	inline bool IsDLL() { return (m_wCharacteristics & IMAGE_FILE_DLL) == IMAGE_FILE_DLL; };
	inline DWORD GetPEImageTimeDateStamp() { return m_dwPEImageTimeDateStamp; };
	inline DWORD GetPEImageSizeOfImage() { return m_dwPEImageSizeOfImage; };
	inline LPTSTR GetPDBModulePath() { return m_tszPDBModuleFileSystemPath; };
	inline LPTSTR GetDebugDirectoryPDBPath() { return (m_tszPEImageDebugDirectoryPDBPath == NULL) ? m_tszDBGDebugDirectoryPDBPath : m_tszPEImageDebugDirectoryPDBPath; };
	inline DWORD GetReadPointer() { return m_dwCurrentReadPosition; };
	inline LPTSTR SourceEnabledPEImage() { return ( (m_dwPEImageDebugDirectoryPDBFormatSpecifier == sigNB09) || (m_dwPEImageDebugDirectoryPDBFormatSpecifier == sigNB11) )  ? TEXT("(Source Enabled)") : TEXT(""); };
	inline LPTSTR SourceEnabledDBGImage() { return ( (m_dwDBGDebugDirectoryPDBFormatSpecifier == sigNB09) || (m_dwDBGDebugDirectoryPDBFormatSpecifier == sigNB11) )  ? TEXT("(Source Enabled)") : TEXT(""); };
//		return (m_dwPEImageDebugDirectoryOMAPtoSRCSize && m_dwPEImageDebugDirectoryOMAPfromSRCSize) || (m_dwDBGImageDebugDirectoryOMAPtoSRCSize && m_dwDBGImageDebugDirectoryOMAPfromSRCSize) ? TEXT("(Source Enabled)") : TEXT(""); 
	inline LPTSTR SourceEnabledPDB() { return (m_dwPDBTotalBytesOfLineInformation && m_dwPDBTotalBytesOfSymbolInformation && m_dwPDBTotalSymbolTypesRange) ? TEXT("(Source Enabled)") : TEXT("");};

protected:
	bool FSourceEnabledPdb(void);
	enum VerificationLevels {IGNORE_BAD_CHECKSUM, IGNORE_NOTHING};
	enum PEImageType {PEImageTypeUnknown, PE32, PE64};

	DWORD	m_dwCurrentReadPosition;
	DWORD m_dwRefCount;
	
	CFileData * m_lpInputFile;
	CFileData *	m_lpOutputFile;
	CDmpFile * m_lpDmpFile;
	
	// PE Image File Version Information
	bool	m_fPEImageFileVersionInfo;
	LPTSTR	m_tszPEImageFileVersionDescription;
	LPTSTR	m_tszPEImageFileVersionCompanyName;
	
	LPTSTR	m_tszPEImageFileVersionString;
	DWORD	m_dwPEImageFileVersionMS;
	DWORD	m_dwPEImageFileVersionLS;

	LPTSTR	m_tszPEImageProductVersionString;
	DWORD	m_dwPEImageProductVersionMS;
	DWORD	m_dwPEImageProductVersionLS;

	// PE Image Properties
	LPTSTR	m_tszPEImageModuleName;
	LPTSTR	m_tszPEImageModuleFileSystemPath;
	DWORD	m_dwPEImageFileSize;
	FILETIME m_ftPEImageFileTimeDateStamp;
	DWORD	m_dwPEImageCheckSum;
	DWORD	m_dwPEImageTimeDateStamp;
	DWORD	m_dwPEImageSizeOfImage;	// New for SYMSRV support
	PEImageType m_enumPEImageType;	
	DWORD64	m_dw64BaseAddress;

	WORD	m_wPEImageMachineArchitecture;
	WORD	m_wCharacteristics;
	
	// PE Image has a reference to DBG file
	SymbolInformationForPEImage m_enumPEImageSymbolStatus;
	LPTSTR	m_tszPEImageDebugDirectoryDBGPath;

	// PE Image has internal symbols
	DWORD	m_dwPEImageDebugDirectoryCoffSize;
	DWORD	m_dwPEImageDebugDirectoryFPOSize;
	DWORD	m_dwPEImageDebugDirectoryCVSize;
	DWORD	m_dwPEImageDebugDirectoryOMAPtoSRCSize;
	DWORD	m_dwPEImageDebugDirectoryOMAPfromSRCSize;
	
	// PE Image has a reference to PDB file...
	LPTSTR	m_tszPEImageDebugDirectoryPDBPath;
	DWORD	m_dwPEImageDebugDirectoryPDBFormatSpecifier;		// NB10, RSDS, etc...
	DWORD	m_dwPEImageDebugDirectoryPDBAge;
	DWORD	m_dwPEImageDebugDirectoryPDBSignature;
	LPTSTR	m_tszPEImageDebugDirectoryPDBGuid;

	// DBG File Information
	SymbolModuleStatus m_enumDBGModuleStatus;
	LPTSTR	m_tszDBGModuleFileSystemPath;									// Actual path
	DWORD	m_dwDBGTimeDateStamp;
	DWORD	m_dwDBGCheckSum;
	DWORD	m_dwDBGSizeOfImage;
	DWORD	m_dwDBGImageDebugDirectoryCoffSize;
	DWORD	m_dwDBGImageDebugDirectoryFPOSize;
	DWORD	m_dwDBGImageDebugDirectoryCVSize;
	DWORD	m_dwDBGImageDebugDirectoryOMAPtoSRCSize;
	DWORD	m_dwDBGImageDebugDirectoryOMAPfromSRCSize;
	
	// DBG File has a reference to a PDB file...
	LPTSTR	m_tszDBGDebugDirectoryPDBPath;
	DWORD	m_dwDBGDebugDirectoryPDBFormatSpecifier;		// NB10, RSDS, etc...
	DWORD	m_dwDBGDebugDirectoryPDBAge;
	DWORD	m_dwDBGDebugDirectoryPDBSignature;
	LPTSTR	m_tszDBGDebugDirectoryPDBGuid;
	
	// PDB File Information
	SymbolModuleStatus m_enumPDBModuleStatus;
	LPTSTR	m_tszPDBModuleFileSystemPath;
	DWORD	m_dwPDBFormatSpecifier;
	DWORD	m_dwPDBSignature;
	DWORD	m_dwPDBAge;
	LPTSTR	m_tszPDBGuid;
	DWORD	m_dwPDBTotalBytesOfLineInformation;
	DWORD	m_dwPDBTotalBytesOfSymbolInformation;
	DWORD	m_dwPDBTotalSymbolTypesRange;

	// Conversion routines...
	LPTSTR SymbolInformationString(enum SymbolInformationForPEImage enumSymbolInformationForPEImage);
	LPTSTR SymbolModuleStatusString(enum SymbolModuleStatus enumModuleStatus);
	SymbolInformationForPEImage SymbolInformation(LPSTR szSymbolInformationString);

	bool DoRead(bool fDmpFile, HANDLE hModuleHandle, LPVOID lpBuffer, DWORD cNumberOfBytesToRead);
	ULONG SetReadPointer(bool fDmpFile, HANDLE hModuleHandle, LONG cbOffset, int iFrom);
	bool GetModuleInfoFromCSVFile(LPTSTR tszModulePath);
	bool GetModuleInfoFromPEImage(LPTSTR tszModulePath, const bool fDmpFile, const DWORD64 dw64ModAddress);

	//
	// Output Methods
	//
	bool OutputDataToStdout(DWORD dwModuleNumber);
	bool OutputDataToStdoutThisModule();
	bool OutputDataToStdoutModuleInfo(DWORD dwModuleNumber);
	bool OutputDataToStdoutInternalSymbolInfo(DWORD dwCoffSize, DWORD dwFPOSize, DWORD dwCVSize, DWORD dwOMAPtoSRC, DWORD dwOMAPfromSRC);
	bool OutputDataToStdoutDbgSymbolInfo(LPCTSTR tszModulePointerToDbg, DWORD dwTimeDateStamp, DWORD dwChecksum, DWORD dwSizeOfImage, LPCTSTR tszDbgComment = NULL, DWORD dwExpectedTimeDateStamp = 0, DWORD dwExpectedChecksum = 0, DWORD dwExpectedSizeOfImage = 0);
	bool OutputDataToStdoutPdbSymbolInfo(DWORD dwPDBFormatSpecifier, LPTSTR tszModulePointerToPDB, DWORD dwPDBSignature, LPTSTR tszPDBGuid, DWORD dwPDBAge, LPCTSTR tszPdbComment = NULL);
	bool OutputDataToFile(LPTSTR tszProcessName, DWORD iProcessID);
	bool OutputFileTime(FILETIME ftFileTime,  LPTSTR tszFileTime, int iFileTimeBufferSize);

	bool fCheckPDBSignature(bool fDmpFile, HANDLE hModuleHandle, OMFSignature *pSig, PDB_INFO *ppdb);
	bool LocatePdb(LPTSTR tszPDB, ULONG PdbAge, ULONG PdbSignature, LPTSTR tszSymbolPath, LPTSTR tszImageExt, bool fImagePathPassed);
	bool GetPDBModuleFileUsingSymbolPath();
	bool HandlePDBOpenValidateReturn(PDB * lpPdb, LPTSTR tszPDBLocal, EC ec);
	bool ProcessDebugDirectory(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, unsigned int iDebugDirectorySize, ULONG OffsetImageDebugDirectory);
	bool ProcessDebugTypeCVDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeFPODirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeCoffDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeMiscDirectoryEntry(const bool fPEImage, const bool fDmpFile, const HANDLE hModuleHandle, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessDebugTypeOMAPDirectoryEntry(const bool fPEImage, const PIMAGE_DEBUG_DIRECTORY lpImageDebugDirectory);
	bool ProcessPDBSourceInfo(PDB *lpPdb);
	
	bool fValidDBGTimeDateStamp();
	bool fValidDBGCheckSum();
	bool GetDBGModuleFileUsingSymbolPath(LPTSTR tszSymbolPath);
	bool GetDBGModuleFileUsingSQLServer(CSymbolVerification * lpSymbolVerification);
	// SQL2 - mjl 12/14/99
	bool GetDBGModuleFileUsingSQLServer2(CSymbolVerification * lpSymbolVerification);
	bool GetPDBModuleFileUsingSQLServer2(CSymbolVerification * lpSymbolVerification);
};

#endif // !defined(AFX_MODULEINFO_H__0D2E8509_A01A_11D2_83A8_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\moduleinfonode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfonode.h
//
//--------------------------------------------------------------------------

// ModuleInfoNode.h: interface for the CModuleInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MODULEINFONODE_H__1F4C77B3_A085_11D2_83AB_000000000000__INCLUDED_)
#define AFX_MODULEINFONODE_H__1F4C77B3_A085_11D2_83AB_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CModuleInfo;	// Forward Declarations

class CModuleInfoNode  
{
public:
	CModuleInfoNode(CModuleInfo * lpModuleInfo);
	virtual ~CModuleInfoNode();
	
	bool AddModuleInfoNodeToTail(CModuleInfoNode ** lplpModuleInfoNode);

	CModuleInfo * m_lpModuleInfo;
	CModuleInfoNode * m_lpNextModuleInfoNode;
};

#endif // !defined(AFX_MODULEINFONODE_H__1F4C77B3_A085_11D2_83AB_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\moduleinfonode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       moduleinfonode.cpp
//
//--------------------------------------------------------------------------

// ModuleInfoNode.cpp: implementation of the CModuleInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#include "ModuleInfoNode.h"
#include "ModuleInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModuleInfoNode::CModuleInfoNode(CModuleInfo * lpModuleInfo)
{
	// Save the Module Info object in our node...
	m_lpModuleInfo = lpModuleInfo;
	m_lpNextModuleInfoNode = NULL;
}

CModuleInfoNode::~CModuleInfoNode()
{
}

/***
** CModuleInfoNode::AddModuleInfoNodeToTail()
**
** This routine takes the current ModuleInfoNode, and adds it to the end of a linked
** list of these objects provided with an initial ModuleInfoNode (the head)
*/
bool CModuleInfoNode::AddModuleInfoNodeToTail(CModuleInfoNode ** lplpModuleInfoNode)
{
	if (NULL == *lplpModuleInfoNode)
	{
		*lplpModuleInfoNode = this;
		return true;
	}

	CModuleInfoNode * lpModuleInfoNodePointer = *lplpModuleInfoNode;

	// Add to the cache...

	// Traverse the linked list to the end..
	while (lpModuleInfoNodePointer->m_lpNextModuleInfoNode)
	{	// Keep looking for the end...
		lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
	}
	
	lpModuleInfoNodePointer->m_lpNextModuleInfoNode = this;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\modules.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       modules.cpp
//
//--------------------------------------------------------------------------

// Modules.cpp: implementation of the CModules class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>

#include "Globals.h"
#include "Modules.h"
#include "ProgramOptions.h"
#include "UtilityFunctions.h"
#include "ModuleInfo.h"
#include "ModuleInfoNode.h"
#include "ModuleInfoCache.h"
#include "FileData.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CModules::CModules()
{
	m_lpModuleInfoHead = NULL;
	m_hModuleInfoHeadMutex = NULL;
	m_lpDmpFile = NULL;

	m_fInitialized = false;
	m_iNumberOfModules = 0;
}

CModules::~CModules()
{
	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	// If we have Module Info Objects... nuke them now...
	if (m_lpModuleInfoHead)
	{

		CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;
		CModuleInfoNode * lpModuleInfoNodePointerToDelete = m_lpModuleInfoHead;

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
			
			// Delete the one behind us...
			delete lpModuleInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpModuleInfoNodePointerToDelete = lpModuleInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...
		m_lpModuleInfoHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	// Now, close the Mutex
	if (m_hModuleInfoHeadMutex)
	{
		CloseHandle(m_hModuleInfoHeadMutex);
		m_hModuleInfoHeadMutex = NULL;
	}
}

bool CModules::Initialize(CModuleInfoCache *lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile)
{
	// We need the following objects to do business...
	if ( lpModuleInfoCache == NULL)
		return false;

	m_lpModuleInfoCache = lpModuleInfoCache;
	m_lpInputFile =  lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpDmpFile = lpDmpFile;

	m_hModuleInfoHeadMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_hModuleInfoHeadMutex == NULL)
		return false;

	m_fInitialized = true;
	return true;
}

bool CModules::GetModulesData(CProgramOptions::ProgramModes enumProgramModes, bool fGetDataFromCSVFile)
{
	switch (enumProgramModes)
	{
		case CProgramOptions::InputModulesDataFromFileSystemMode:

			if (fGetDataFromCSVFile)
			{
				GetModulesDataFromFile();
			} else
			{
				GetModulesDataFromFileSystem();
			}
			break;

		case CProgramOptions::InputDriversFromLiveSystemMode:

			if (fGetDataFromCSVFile)
			{
				GetModulesDataFromFile();	// ISSUE-2000/07/24-GREGWI: I think we can use the same method as above ????
			} else
			{
				GetModulesDataFromDeviceDrivers();
			}
			break;

		default:
			break;
	}

	return true;
}

bool CModules::GetModulesDataFromFileSystem()
{
	bool fProcessPath = true;

	// Okay... here we go...
//#ifdef _DEBUG
//	_tprintf(TEXT("Processing the path [%s]\n"), m_lpProgramOptions->GetInputModulesDataFromFileSystemPath());
//#endif

	LPTSTR tszExpandedSymbolPath= NULL, tszSymbolPathStart, tszSymbolPathEnd;

	// Mark the start of the path to process
	tszSymbolPathStart = g_lpProgramOptions->GetInputModulesDataFromFileSystemPath();

	// Find the end of the path
	tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

	// If tszSymbolPathEnd is non-zero, then there is another path following...
	if (tszSymbolPathEnd) 
		*tszSymbolPathEnd = '\0'; // Change the ';' to a Null temporarily...
	
	while (fProcessPath)
	{
//#ifdef _DEBUG
//		_tprintf(TEXT("\n\nProcessing Path [%s]\n"), tszSymbolPathStart);
//#endif

		// Begin the "madness"... ;)
		ScavengeForFiles(tszSymbolPathStart, 1);

		// Post processing... replace the null if necessary, and advance to next string
		if (tszSymbolPathEnd) 
		{
			*tszSymbolPathEnd = ';';
			tszSymbolPathStart = tszSymbolPathEnd + 1;
			
			tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

			if (tszSymbolPathEnd) {
				*tszSymbolPathEnd = '\0';
			}
		} else
			fProcessPath = false;
	}

    if (tszExpandedSymbolPath) 
	{
        delete [] tszExpandedSymbolPath;
    }
	return true;
}

bool CModules::ScavengeForFiles(LPCTSTR tszSymbolPathStart, int iRecurseDepth)
{
	// Bale if we're in too deep...
	if (iRecurseDepth > MAX_RECURSE_DEPTH)
		return true;

	TCHAR tszFileBuffer[MAX_PATH+1];
	TCHAR drive[_MAX_DRIVE];
	TCHAR dir[_MAX_DIR];
	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];
	bool fNew;
	CModuleInfo * lpModuleInfo;

	_tsplitpath(tszSymbolPathStart, drive, dir, fname, ext);

	WIN32_FIND_DATA lpFindFileData;

	HANDLE hFileOrDirectoryHandle = FindFirstFile(tszSymbolPathStart, &lpFindFileData);

	while ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
	{
		// Compose the path to the file or directory...
		_tmakepath(tszFileBuffer, drive, dir, NULL, NULL);
		_tcscat(tszFileBuffer, lpFindFileData.cFileName);

		if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			// Check to see if we've got the . or .. directories!
			if ( ( 0 == _tcscmp(lpFindFileData.cFileName, TEXT(".")) ) ||
				 ( 0 == _tcscmp(lpFindFileData.cFileName, TEXT("..")) )
			   )
			{
				// Skip this one...
				if (!FindNextFile(hFileOrDirectoryHandle, &lpFindFileData))
					break;

				// Go up for more fun...
				continue;
			}

//#ifdef _DEBUG
//			_tprintf(TEXT("DIRECTORY FOUND: [%s]\n"), tszFileBuffer);
//#endif
			// If this is a directory, and no wild card was provided.. then use *.*
			if ( CUtilityFunctions::ContainsWildCardCharacter(tszSymbolPathStart) )
			{
				// We need to preserve the Wild Char stuff...
				_tcscat(tszFileBuffer,TEXT("\\"));
				_tcscat(tszFileBuffer,fname);
				_tcscat(tszFileBuffer, ext);
			} else
			{
				// Append the *.*
				_tcscat(tszFileBuffer, TEXT("\\*.*"));
			}

			ScavengeForFiles(tszFileBuffer, iRecurseDepth+1);

		} else
		{
//#ifdef _DEBUG
//			_tprintf(TEXT("FILE FOUND: [%s]\n"), tszFileBuffer);
//#endif 
			fNew = false;

			TCHAR tszFullFileBuffer[_MAX_PATH+1];
			LPTSTR tszFileNamePointer;
			DWORD cbBytesCopied = GetFullPathName(tszFileBuffer , _MAX_PATH+1, tszFullFileBuffer, &tszFileNamePointer);

			if (cbBytesCopied)
			{
				// If "-MATCH" was specified, look to see if this filename meets our criteria
				// before we save this away in our module cache...
				if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszFileBuffer))
					goto getnextmodule;

				// Okay, let's go ahead and get a ModuleInfo Object from our cache...
				// If pfNew returns TRUE, then this object is new and we'll need
				// to populate it with data...
				lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszFullFileBuffer, &fNew);

				if (false == fNew)
				{
					// We may have the object in the cache... now we need to
					// save a pointer to this object in our Process Info list
					AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

					// We save having to get the module info again for this module...
					goto getnextmodule;
				}

				// Not in the cache... so we need to init it, and get the module info...

				// Okay, let's create a ModuleInfo object and pass this down
				// routines that will populate it full of data...
				if (lpModuleInfo->Initialize(NULL, m_lpOutputFile, NULL))
				{

					// Let's do it!! Populate the ModuleInfo object with data!!!!
					if (lpModuleInfo->GetModuleInfo(tszFileBuffer))
					{
							// Start obtaining information about the modules...
/*
#ifdef _DEBUG
							_tprintf(TEXT("Module[%3d] = [%s]\n"), i+1, szFileName);
#endif
*/
							// We may have the object in the cache... now we need to
							// save a pointer to this object in our Process Info list
							if (AddNewModuleInfoObject(lpModuleInfo))
							{   
							}
					}
				}

			}
		}

getnextmodule:

		if (!FindNextFile(hFileOrDirectoryHandle, &lpFindFileData))
			break;
	}

	if ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
		FindClose(hFileOrDirectoryHandle);

	return true;
}

bool CModules::AddNewModuleInfoObject(CModuleInfo *lpModuleInfo)
{
	if (!m_fInitialized)
	return false;

	// First, create a ModuleInfoNode object and then attach it to the bottom of the
	// linked list of nodes...
	CModuleInfoNode * lpModuleInfoNode = new CModuleInfoNode(lpModuleInfo);

//#ifdef _DEBUG
//	_tprintf(TEXT("Adding Module Info Object for [%s]\n"), lpModuleInfo->GetModulePath());
//#endif

	if (lpModuleInfoNode == NULL)
		return false; // Couldn't allocate memory..

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;

	if (lpModuleInfoNodePointer) {

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer->m_lpNextModuleInfoNode)
		{	// Keep looking for the end...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}
		
		lpModuleInfoNodePointer->m_lpNextModuleInfoNode = lpModuleInfoNode;

	}
	else
	{ // First time through, the Process Info Head pointer is null...
		m_lpModuleInfoHead = lpModuleInfoNode;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	InterlockedIncrement(&m_iNumberOfModules);

	return true;
}

//bool CModules::OutputModulesData(LPCTSTR tszOutputContext)
bool CModules::OutputModulesData(CollectionTypes enumCollectionType, bool fCSVFileContext)
{
	// Are we in quiet mode?
	if ( !g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) )
	{
		// Output to Stdout?
		if (!OutputModulesDataToStdout(enumCollectionType, fCSVFileContext))
			return false;
	}	

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputModulesDataToFile(enumCollectionType))
			return false;
	}	

	if (m_lpModuleInfoHead) {
		CModuleInfoNode * lpCurrentModuleInfoNode = m_lpModuleInfoHead;
		
		DWORD dwModuleNumber = 1;

		while (lpCurrentModuleInfoNode)
		{
			// We have a node... print out Module Info for it, then the Modules Data...
			if (lpCurrentModuleInfoNode->m_lpModuleInfo)
			{
				lpCurrentModuleInfoNode->m_lpModuleInfo->OutputData(NULL, 0, dwModuleNumber);
				dwModuleNumber++;
			}

			lpCurrentModuleInfoNode = lpCurrentModuleInfoNode->m_lpNextModuleInfoNode;
		}

	}
	return true;

}

bool CModules::OutputModulesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext)
{
	_tprintf(TEXT("\n"));
	CUtilityFunctions::OutputLineOfStars();

	// Output to stdout...
	if (m_iNumberOfModules)
	{
		_tprintf(TEXT("%s - Printing Module Information for %d Modules.\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, m_iNumberOfModules);
		_tprintf(TEXT("%s - Context: %s\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, fCSVFileContext ? g_tszCollectionArray[enumCollectionType].tszCSVContext : g_tszCollectionArray[enumCollectionType].tszLocalContext);

	} else
	{
		_tprintf(TEXT("\n%s - No modules were found!\n\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel);
	}

	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("\n"));

	return true;

}

bool CModules::OutputModulesDataToFile(CollectionTypes enumCollectionType)
{	
	// Don't write anything if there are no processes to report...
	if (0 == m_iNumberOfModules)
		return true;

	// Write out the Modules tag so I can detect this output format...
	if (!m_lpOutputFile->WriteString(TEXT("\r\n")) ||
		!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVLabel) ||
		!m_lpOutputFile->WriteString(TEXT("\r\n"))
	   )
	{
		_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
		m_lpOutputFile->PrintLastError();
		return false;
	}

	// Write out the [Modules] header...
	if (!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVColumnHeaders))
	{
		_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
		m_lpOutputFile->PrintLastError();
		return false;
	}

	return true;

}

bool CModules::GetModulesDataFromFile()
{
	CModuleInfo * lpModuleInfo;

	// Read the Modules Header Line
	if (!m_lpInputFile->ReadFileLine())
		return false;

	// I need these near the end when I probe to see if the next module
	// is for this process...
	enum { BUFFER_SIZE = 128};

	// Unfortunately, when reading from the CSV file, the data is MBCS... so I need
	// to convert...

	// Read the first field (should be blank, unless this is a new collection type
	if (m_lpInputFile->ReadString())
		return true;

	// Read the second field (should be blank)
	if (m_lpInputFile->ReadString())
		return true;

	// Read the second field (should be blank)
	if (m_lpInputFile->ReadString())
		return true;

	// Local buffer for reading data...
	char szModulePath[_MAX_PATH+1];
	TCHAR tszModulePath[_MAX_PATH+1];
	bool fDone = false;
	bool fNew = false;

	while (!fDone)
	{
		// Read in the Module Path
		if (!m_lpInputFile->ReadString(szModulePath, _MAX_PATH+1))
			return true;

		CUtilityFunctions::CopyAnsiStringToTSTR(szModulePath, tszModulePath, _MAX_PATH+1);

		// If "-MATCH" was specified, look to see if this filename meets our criteria
		// before we save this away in our module cache...
		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
		{
			// Okay... read to the start of the next line...
			if (!m_lpInputFile->ReadFileLine())
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

			// Okay... read to the start of the next line...
			if ( !m_lpInputFile->ReadFileLine() )
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(m_lpInputFile, m_lpOutputFile, NULL))
		{
			return false; // Hmmm... memory error?
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (!lpModuleInfo->GetModuleInfo(tszModulePath, false, 0, true))
		{
			// Well, we tried and failed... 
			return false;
		}

		// Start obtaining information about the modules...
		if (!AddNewModuleInfoObject(lpModuleInfo))
		{   // Failure adding the node.... This is pretty serious...
			return false;
		}
		
		// Okay, let's go ahead and probe to see what's coming...

probe_line:
		if ( m_lpInputFile->EndOfFile() )
			goto cleanup;

		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			goto cleanup;

		// Read the second field (should be blank)
		if (m_lpInputFile->ReadString())
			return true;

		// Read the second field (should be blank)
		if (m_lpInputFile->ReadString())
			return true;
	}

cleanup:
	// We need to reset out pointer so the functions above us can re-read
	// them (they expect to)...
	m_lpInputFile->ResetBufferPointerToStart();
	return true;
}

// We need to enumerate device drivers on this system
bool CModules::GetModulesDataFromDeviceDrivers()
{
	LPVOID * lpImageBaseArray = NULL;
	DWORD    dwImageBaseArraySizeUsed, dwImageBaseArraySize, dwNumberOfDeviceDrivers, dwIndex;
	TCHAR    tszModulePath[_MAX_PATH];
	CModuleInfo * lpModuleInfo = NULL;
	bool	 fReturn = false, fNew = false;

	// NOTE: In the documentation, the third parameter of
	// EnumProcesses is named cbNeeded, which implies that you
	// can call the function once to find out how much space to
	// allocate for a buffer and again to fill the buffer.
	// This is not the case. The cbNeeded parameter returns
	// the number of PIDs returned, so if your buffer size is
	// zero cbNeeded returns zero.

	dwImageBaseArraySize = 256 * sizeof( LPVOID ) ;

	do
	{
		if( lpImageBaseArray )
		{ 	// Hmm.. we've been through this loop already, double the HeapSize and try again.

			delete [] lpImageBaseArray;
			dwImageBaseArraySize *= 2 ;
		}

		lpImageBaseArray = (LPVOID *) new DWORD[dwImageBaseArraySize];
		
		if( lpImageBaseArray == NULL )
		{
			goto error_cleanup;
		}

		// Query the system for the total number of processes
		if( !g_lpDelayLoad->EnumDeviceDrivers(lpImageBaseArray, dwImageBaseArraySize, &dwImageBaseArraySizeUsed ) )
		{
			// It's bad if we can't enum device drivers... no place to go but to bail out...
			goto error_cleanup;
		}
	} while( dwImageBaseArraySizeUsed == dwImageBaseArraySize );

	// How many DeviceDrivers did we get?
	dwNumberOfDeviceDrivers = dwImageBaseArraySizeUsed / sizeof( LPVOID ) ;

	// Loop through each Device Drivers
	for(dwIndex = 0 ; dwIndex < dwNumberOfDeviceDrivers; dwIndex++ )
	{
		// Spin until we get a device driver filename!
		if (!g_lpDelayLoad->GetDeviceDriverFileName(lpImageBaseArray[dwIndex], tszModulePath, _MAX_PATH))
			continue;

		CUtilityFunctions::UnMungePathIfNecessary(tszModulePath);

		// For some reason, even though GetDeviceDriverFileName() is supposed to return the fullpath to the device
		// driver... it don't always... sometimes it returns only the base file name...
		CUtilityFunctions::FixupDeviceDriverPathIfNecessary(tszModulePath, _MAX_PATH);

		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
			continue;

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
			continue; // We save having to get the module info again for this module...
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(m_lpInputFile, m_lpOutputFile, NULL))
		{
			continue;
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (!lpModuleInfo->GetModuleInfo(tszModulePath, false, 0, false))
		{
			// Well, we tried and failed... 
			continue;
		}

		// We may have the object in the cache... now we need to
		// save a pointer to this object in our Process Info list
		if (!AddNewModuleInfoObject(lpModuleInfo))
		{   // Failure adding the node.... This is pretty serious...
			continue;
		}
	}

	fReturn = true;
	goto cleanup;

error_cleanup:


cleanup:

	if (lpImageBaseArray)
	{
		delete [] lpImageBaseArray;
	}

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\processes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processes.h
//
//--------------------------------------------------------------------------

// Processes.h: interface for the CProcesses class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSES_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_)
#define AFX_PROCESSES_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include "globals.h"

//#include "ProgramOptions.h"

// Forward Declarations
//class CProgramOptions;
class CProcessInfo;
class CProcessInfoNode;
class CFileData;
class CModuleInfoCache;

class CProcesses  
{
public:
	CProcesses();
	virtual ~CProcesses();

	bool Initialize(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile); 

//	bool OutputProcessesData(LPCTSTR tszOutputContext, bool fDumpHeader = true);
	bool OutputProcessesData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader = true);
	bool GetProcessesData();
	
	// Public functions for exporting functions in dynamically loaded DLLs...
	enum ProcessCollectionMethod { NO_METHOD, TOOLHELP32_METHOD, PSAPI_METHOD };
	ProcessCollectionMethod GetProcessCollectionMethod();

	inline long GetNumberOfProcesses() {
		return m_iNumberOfProcesses; 
	};

protected:
	bool GetProcessesDataFromFile();
	bool GetProcessesDataForRunningProcessesUsingTOOLHELP32();
	bool GetProcessesDataForRunningProcessesUsingPSAPI();
	bool OutputProcessesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader = true);
	bool OutputProcessesDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader = true);

	CFileData * m_lpOutputFile;
	CFileData * m_lpInputFile;
	CModuleInfoCache * m_lpModuleInfoCache;
//	CProgramOptions * m_lpProgramOptions;
	CProcessInfoNode * m_lpProcessInfoHead;

	HANDLE m_ProcessInfoHeadMutex;

	long m_iNumberOfProcesses;
	bool m_fInitialized; // We need to ensure initialization since a mutex is involved...

	// Protected Methods
	bool AddNewProcessInfoObject(CProcessInfo * lpProcessInfo);
	bool SetPrivilege(HANDLE hToken, LPCTSTR Privilege, bool bEnablePrivilege);

	ProcessCollectionMethod m_enumProcessCollectionMethod;
};

#endif // !defined(AFX_PROCESSES_H__3CE003F7_9F5D_11D2_83A4_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\newtypes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       newtypes.h
//
//--------------------------------------------------------------------------

#if !defined(__midl) && defined(_X86_) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif

//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
#if ( 501 < __midl )

//    typedef [public] __int3264 INT_PTR, *PINT_PTR;
//    typedef [public] unsigned __int3264 UINT_PTR, *PUINT_PTR;

    typedef [public] __int3264 LONG_PTR, *PLONG_PTR;
    typedef [public] unsigned __int3264 ULONG_PTR, *PULONG_PTR;

#else  // midl64
// old midl and C++ compiler

#if defined(_WIN64)
//    typedef __int64 INT_PTR, *PINT_PTR;
//    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int64

#else
//    typedef _W64 int INT_PTR, *PINT_PTR;
//    typedef _W64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef _W64 long LONG_PTR, *PLONG_PTR;
    typedef _W64 unsigned long ULONG_PTR, *PULONG_PTR;

    #define __int3264   __int32

#endif
#endif // midl64

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt


#ifdef VC_DEV

typedef struct LIST_ENTRY32 {
    ULONG Flink;
    ULONG Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;

#endif

typedef struct _STRING32 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONG  Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;



typedef struct _STRING64 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONGLONG  Buffer;
} STRING64;
typedef STRING64 *PSTRING64;

typedef STRING64 UNICODE_STRING64;
typedef UNICODE_STRING64 *PUNICODE_STRING64;

typedef STRING64 ANSI_STRING64;
typedef ANSI_STRING64 *PANSI_STRING64;

// begin_winnt begin_ntndis

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NTAPI __stdcall
#else
#define _cdecl
#define NTAPI
#endif

typedef LONG NTSTATUS;
/*lint -e624 */  // Don't complain about different typedefs.   // winnt
typedef NTSTATUS *PNTSTATUS;
/*lint +e624 */  // Resume checking for different typedefs.    // winnt

// begin_ntndis
//
// Counted String
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\processinfonode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfonode.cpp
//
//--------------------------------------------------------------------------

// ProcessInfoNode.cpp: implementation of the CProcessInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#include "ProcessInfoNode.h"
#include "ProcessInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcessInfoNode::CProcessInfoNode(CProcessInfo * lpProcessInfo)
{
	// Save the Process Info object in our node...
	m_lpProcessInfo = lpProcessInfo;
	m_lpNextProcessInfoNode = NULL;
}

CProcessInfoNode::~CProcessInfoNode()
{
	//  Cleanup our process info object if necessary...
	if (m_lpProcessInfo)
		delete m_lpProcessInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\processinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfo.h
//
//--------------------------------------------------------------------------

// ProcessInfo.h: interface for the CProcessInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSINFO_H__213C3A76_9FBB_11D2_83A7_000000000000__INCLUDED_)
#define AFX_PROCESSINFO_H__213C3A76_9FBB_11D2_83A7_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include "globals.h"

// Forward declarations
class CProcesses;
class CModuleInfo;
class CModuleInfoNode;
class CModuleInfoCache;
class CFileData;
class CDmpFile;

class CProcessInfo  
{
public:
	bool GetProcessData();
//	bool EnumerateModulesFromUserDmpFile();
	CProcessInfo();
	virtual ~CProcessInfo();

	bool Initialize(CModuleInfoCache *lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile);

	LPTSTR GetProcessName();
	bool EnumerateModules(DWORD iProcessID, CProcesses * lpProcesses, LPTSTR tszProcessName);
	
	bool OutputProcessData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader = true);

	bool SetProcessName(LPTSTR tszFileName);
	bool AddNewModuleInfoObject(CModuleInfo * lpModuleInfo);

protected:
	bool GetProcessDataFromFile();
	// Process Info Objects Required
	CFileData * m_lpInputFile;
	CFileData * m_lpOutputFile;
	CDmpFile * m_lpDmpFile;
	CModuleInfoNode * m_lpModuleInfoHead;
	CModuleInfoCache * m_lpModuleInfoCache;

	// Process Info Data
	LPTSTR m_tszProcessName;
	HANDLE m_hModuleInfoHeadMutex;
	DWORD m_iProcessID;
	long m_iNumberOfModules;
	bool m_fInitialized;

	// Process Info Methods
	bool EnumerateModulesFromFile(DWORD iProcessID, LPTSTR tszProcessName);
	bool EnumerateModulesForRunningProcessUsingPSAPI(DWORD iProcessID);
	bool EnumerateModulesForRunningProcessUsingTOOLHELP32(DWORD iProcessID, LPTSTR tszProcessName);
	bool fIsProcessName(LPTSTR tszFileName);
	bool fModuleNameMatches(LPTSTR tszProcessName, LPTSTR tszModulePath);
	bool OutputProcessDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader);
	bool OutputProcessDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader);
};

#endif // !defined(AFX_PROCESSINFO_H__213C3A76_9FBB_11D2_83A7_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\processes.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processes.cpp
//
//--------------------------------------------------------------------------

// Processes.cpp: implementation of the CProcesses class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>
#include <stdlib.h>

#include "Globals.h"
#include "Processes.h"
#include "ProcessInfo.h"
#include "ProcessInfoNode.h"
#include "FileData.h"
#include "UtilityFunctions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcesses::CProcesses()
{
	m_fInitialized = false;
	m_iNumberOfProcesses = 0;

	m_enumProcessCollectionMethod = NO_METHOD;

	// Contained Objects
	m_lpProcessInfoHead = NULL;
	m_ProcessInfoHeadMutex = NULL;
//	m_lpProgramOptions = NULL;
	m_lpModuleInfoCache = NULL;
	m_lpOutputFile = NULL;
	m_lpInputFile = NULL;
}

CProcesses::~CProcesses()
{
	WaitForSingleObject(m_ProcessInfoHeadMutex, INFINITE);

	// If we have Process Info Objects... nuke them now...
	if (m_lpProcessInfoHead)
	{

		CProcessInfoNode * lpProcessInfoNodePointer = m_lpProcessInfoHead;
		CProcessInfoNode * lpProcessInfoNodePointerToDelete = m_lpProcessInfoHead;

		// Traverse the linked list to the end..
		while (lpProcessInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpProcessInfoNodePointer = lpProcessInfoNodePointer->m_lpNextProcessInfoNode;
			
			// Delete the one behind us...
			delete lpProcessInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpProcessInfoNodePointerToDelete = lpProcessInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...

		m_lpProcessInfoHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_ProcessInfoHeadMutex);

	// Now, close the Mutex
	if (m_ProcessInfoHeadMutex)
	{
		CloseHandle(m_ProcessInfoHeadMutex);
		m_ProcessInfoHeadMutex = NULL;
	}
}

//bool CProcesses::Initialize(CProgramOptions * lpProgramOptions, CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile)
bool CProcesses::Initialize(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile)
{
	// We need the following objects to do business...
//	if ( lpProgramOptions == NULL || lpModuleInfoCache == NULL)
	if ( lpModuleInfoCache == NULL)
		return false;

	// Let's save away our program options (beats passing it as an
	// argument to every method...)
//	m_lpProgramOptions = lpProgramOptions;
	m_lpInputFile = lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpModuleInfoCache = lpModuleInfoCache;

	m_ProcessInfoHeadMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_ProcessInfoHeadMutex == NULL)
		return false;

	// We only need to grab these exported functions if we intend to
	// actively query our local machine's processes directly...
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode))
	{
		// PSAPI.DLL API's ARE NOW PREFERRED!!
		// It doesn't tend to hang when enumerating modules for a process that is being debugged.
		// The Toolhelp32 APIs seem to hang occasionally taking a snapshot of a process being debugged
		// and this impacts Exception Monitor (which runs from a script against a process under
		// windbg)

		if ( g_lpProgramOptions->IsRunningWindowsNT() )
		{
			// Get the functions for Windows NT 4.0/2000

			// Load library and get the procedures explicitly. We do
			// this so that we don't have to worry about modules using
			// this code failing to load under Windows 95, because
			// it can't resolve references to the PSAPI.DLL.

			if (g_lpDelayLoad->Initialize_PSAPI())
			{
				m_enumProcessCollectionMethod = PSAPI_METHOD;
			} else
			{
				_tprintf(TEXT("Unable to load PSAPI.DLL, which may be required for enumeration of processes.\n"));
			}
		}

		if ( m_enumProcessCollectionMethod == NO_METHOD )
		{
			if (g_lpDelayLoad->Initialize_TOOLHELP32())
			{
				m_enumProcessCollectionMethod = TOOLHELP32_METHOD;
			} else
			{
				_tprintf(TEXT("KERNEL32.DLL is missing required function entry points!!\n"));
			}

		}

		// On Windows NT, we need to enable SeDebugPrivilege to open some processes...
		if ( ( m_enumProcessCollectionMethod != NO_METHOD ) &&
			   g_lpProgramOptions->IsRunningWindowsNT() )
		{
			HANDLE		hOurProcessToken = 0;
			bool		fPrivilegeSet = false;
			
			// To permit as much access to obtain a process handle as possible,
			// we need to set the SeDebugPrivilege on our process handle, we can
			// then open nearly any process...

			if(OpenProcessToken(	GetCurrentProcess(),
									TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,            
									&hOurProcessToken))
			{
				// We got our Process Token...

	 			if(SetPrivilege(hOurProcessToken, SE_DEBUG_NAME, TRUE))    
				{
					fPrivilegeSet = true;
				}
			}
			
			if (!fPrivilegeSet)
			{
				_tprintf(TEXT("\nWARNING: A required privilege (SeDebugPrivilege) is not held by the user\n"));
				_tprintf(TEXT("running this program.  Due to security, some processes running on this\n"));
				_tprintf(TEXT("system may not be accessible.  An administrator of this machine can grant\n"));
				_tprintf(TEXT("you this privilege by using User Manager to enable the advanced User Right\n"));
				_tprintf(TEXT("\"Debug Programs\" to enable complete access to this system.\n"));
			}

			if (hOurProcessToken)
				CloseHandle(hOurProcessToken);
		}

		// We are initialized if we were able to enable a Process Collection Method
		m_fInitialized = ( m_enumProcessCollectionMethod != NO_METHOD );

	} else
	{
		m_fInitialized = true;
	}

	
	return m_fInitialized;
}

bool CProcesses::GetProcessesDataForRunningProcessesUsingPSAPI()
{
	LPDWORD        lpdwPIDs = NULL;
	DWORD          dwProcessIDHeapSizeUsed, dwProcessIDHeapSize, dwIndex ;
	CProcessInfo * lpProcessInfo = NULL;
	bool fRetval = false;

	if (!m_fInitialized)
		return false;

	// It's possible the user provided a PID directly... if so,
	// we can circumvent the whole search of PIDs on the system...
	if (g_lpProgramOptions->GetProcessID())
	{
		// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
		lpProcessInfo = new CProcessInfo();
		if (lpProcessInfo == NULL)
			goto error_cleanup;

		if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
		{
			goto error_cleanup;
		}

		if (lpProcessInfo->EnumerateModules(g_lpProgramOptions->GetProcessID(), this, NULL))
		{
			// Success... add this to the Processes Object...
			if (!AddNewProcessInfoObject(lpProcessInfo))
			{ // Failure adding the node...
				goto error_cleanup; // For now, let's just error on out...
			}

		} else
		{
			// Failure enumerating modules on the only PID of interest... very bad...
			goto error_cleanup;
		}
	} 
	else
	{	// Nope, we brute force this baby...

		// Call the PSAPI function EnumProcesses to get all of the
		// ProcID's currently in the system.

		// NOTE: In the documentation, the third parameter of
		// EnumProcesses is named cbNeeded, which implies that you
		// can call the function once to find out how much space to
		// allocate for a buffer and again to fill the buffer.
		// This is not the case. The cbNeeded parameter returns
		// the number of PIDs returned, so if your buffer size is
		// zero cbNeeded returns zero.

		// NOTE: The loop here ensures that we
		// actually allocate a buffer large enough for all the
		// PIDs in the system.
		dwProcessIDHeapSize = 256 * sizeof( DWORD ) ;
		lpdwPIDs = NULL ;

		do
		{
			if( lpdwPIDs )
			{ // Hmm.. we've been through this loop already, double the HeapSize and try again.
				delete [] lpdwPIDs;
				dwProcessIDHeapSize *= 2 ;
			}

			lpdwPIDs = (LPDWORD) new DWORD[dwProcessIDHeapSize];
			
			if( lpdwPIDs == NULL )
			{
				goto error_cleanup;
			}

			// Query the system for the total number of processes
			if( !g_lpDelayLoad->EnumProcesses( lpdwPIDs, dwProcessIDHeapSize, &dwProcessIDHeapSizeUsed ) )
			{
				// It's bad if we can't enum processes... no place to go but to bail out...
				goto error_cleanup;
			}
		} while( dwProcessIDHeapSizeUsed == dwProcessIDHeapSize );

		// How many ProcID's did we get?
		DWORD dwNumberOfPIDs = dwProcessIDHeapSizeUsed / sizeof( DWORD ) ;

		// Loop through each ProcID.
		for( dwIndex = 0 ; dwIndex < dwNumberOfPIDs; dwIndex++ )
		{
			// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
			// Each Process gets its own 
			lpProcessInfo = new CProcessInfo();
			if (lpProcessInfo == NULL)
				goto error_cleanup;

			if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
			{	// Failure initializing the ProcessInfo object?!?
				delete lpProcessInfo;
				lpProcessInfo = NULL;
				continue;
			}

			if (lpProcessInfo->EnumerateModules(lpdwPIDs[dwIndex], this, NULL))
			{
				// Success... add this to the Processes Object...
				if (!AddNewProcessInfoObject(lpProcessInfo))
				{ // Failure adding the node...
					delete lpProcessInfo;
					lpProcessInfo = NULL;
					continue;
				}
				// For now, let's error out...

			} else
			{
				// An error enumerating modules might be normal...
				delete lpProcessInfo;
				lpProcessInfo = NULL;
				continue;
			}
		}
	}
	fRetval = true;
	goto cleanup;

error_cleanup:
	if (lpProcessInfo)
		delete lpProcessInfo;

cleanup:
	if (lpdwPIDs)
	{
		delete [] lpdwPIDs;
	}

	return fRetval;
}

bool CProcesses::AddNewProcessInfoObject(CProcessInfo * lpProcessInfo)
{
	if (!m_fInitialized)
		return false;

	// First, create a ProcessInfoNode object and then attach it to the bottom of the
	// linked list of nodes...
	CProcessInfoNode * lpProcessInfoNode = new CProcessInfoNode(lpProcessInfo);
/*
#ifdef _DEBUG
	_tprintf(TEXT("Adding Process Info Object for [%s]\n"), lpProcessInfo->m_tszProcessName);
#endif
*/
	if (lpProcessInfoNode == NULL)
		return false; // Couldn't allocate memory..

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_ProcessInfoHeadMutex, INFINITE);

	CProcessInfoNode * lpProcessInfoNodePointer = m_lpProcessInfoHead;

	if (lpProcessInfoNodePointer) {

		// Traverse the linked list to the end..
		while (lpProcessInfoNodePointer->m_lpNextProcessInfoNode)
		{	// Keep looking for the end...
			lpProcessInfoNodePointer = lpProcessInfoNodePointer->m_lpNextProcessInfoNode;
		}
		
		lpProcessInfoNodePointer->m_lpNextProcessInfoNode = lpProcessInfoNode;

	}
	else
	{ // First time through, the Process Info Head pointer is null...
		m_lpProcessInfoHead = lpProcessInfoNode;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_ProcessInfoHeadMutex);

	InterlockedIncrement(&m_iNumberOfProcesses);

	return true;
}

bool CProcesses::SetPrivilege(HANDLE hToken, LPCTSTR Privilege, bool bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious = {0};
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return false;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return false;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return false;

    return true;
}

bool CProcesses::OutputProcessesData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	// Output to file?
	if ( !g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) &&
		 !g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode) )
	{
		// Output to Stdout?
		if (!OutputProcessesDataToStdout(enumCollectionType, fCSVFileContext, fDumpHeader))
			return false;
	}	

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputProcessesDataToFile(enumCollectionType, fDumpHeader))
			return false;
	}	

	if (m_lpProcessInfoHead) {
		CProcessInfoNode * lpCurrentProcessInfoNode = m_lpProcessInfoHead;

		while (lpCurrentProcessInfoNode)
		{
			// We have a node... print out Process Info for it, then the Modules Data...
			if (lpCurrentProcessInfoNode->m_lpProcessInfo)
			{
				lpCurrentProcessInfoNode->m_lpProcessInfo->OutputProcessData(enumCollectionType, fCSVFileContext, false);
			}

			lpCurrentProcessInfoNode = lpCurrentProcessInfoNode->m_lpNextProcessInfoNode;
		}

	}
	return true;
}

bool CProcesses::OutputProcessesDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	if (fDumpHeader)
	{
		// Output to stdout...
		_tprintf(TEXT("\n"));
		CUtilityFunctions::OutputLineOfStars();
		_tprintf(TEXT("%s - Printing Process Information for %d Processes.\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, m_iNumberOfProcesses);
		_tprintf(TEXT("%s - Context: %s\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, fCSVFileContext ? g_tszCollectionArray[enumCollectionType].tszCSVContext : g_tszCollectionArray[enumCollectionType].tszLocalContext);
		CUtilityFunctions::OutputLineOfStars();
	}
	return true;
}

bool CProcesses::OutputProcessesDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader)
{
	// Don't write anything if there are no processes to report...
	if (0 == m_iNumberOfProcesses)
		return true;

	if (fDumpHeader)
	{
		// We skip output of the [PROCESSES] header if -E was specified...
		if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
		{
			// Write out the Processes tag so I can detect this output format...
			if (!m_lpOutputFile->WriteString(TEXT("\r\n")) ||
				!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVLabel) ||
				!m_lpOutputFile->WriteString(TEXT("\r\n"))
			   )
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}
		}

		// We have different output for -E
		if (g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode))
		{
			// Write out the header... for the -E option...
			if (!m_lpOutputFile->WriteString(TEXT("Module Path,Symbol Status,Time/Date String,File Version,Company Name,File Description,File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n")))
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}

		} else
		{
			// Write out the Processes Header
			if (!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVColumnHeaders))
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}
		}
	}
	return true;
}

bool CProcesses::GetProcessesData()
{
	// Is this being collected interactively?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode))
	{
		// Invoke the correct Process Collection Method
		if (GetProcessCollectionMethod() == TOOLHELP32_METHOD)
		{
			GetProcessesDataForRunningProcessesUsingTOOLHELP32();
		}
		else if (GetProcessCollectionMethod() == PSAPI_METHOD)
		{
			GetProcessesDataForRunningProcessesUsingPSAPI();
		}
	}

	// Is this being collected from a file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
		GetProcessesDataFromFile();

	return true;
}

bool CProcesses::GetProcessesDataFromFile()
{
	CProcessInfo * lpProcessInfo = NULL;

	char szProcessNameToMatch[_MAX_FNAME+1];
	
	// In case we're matching against these...
	LPTSTR tszProcessNameToMatch = g_lpProgramOptions->GetProcessName();
	DWORD dwProcessIDToMatch = g_lpProgramOptions->GetProcessID();

	// If we're going to be matching on a process name, go ahead and grab it
	// once now, convert to ANSI if necessary (since it comes from the CSV
	// file in ANSI), and upper case it...
	if ( ( g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesWithMatchingNameOrPID) ) &&
		 ( tszProcessNameToMatch ) 
	   )
	{

		// Let's save away the Process Name...
		CUtilityFunctions::CopyTSTRStringToAnsi(tszProcessNameToMatch, szProcessNameToMatch, _MAX_FNAME+1);

		// Upper case the process name... we should be ready to match on this now...
		_strupr(szProcessNameToMatch);
	}

	// Read the Process Header Line
	if (!m_lpInputFile->ReadFileLine())
		return false;

	// Currently, we don't actually read the data...

	enum { BUFFER_SIZE = 128};
	char szProcessName[BUFFER_SIZE];

	TCHAR tszProcessName[BUFFER_SIZE];	

	DWORD iProcessID;

	// Read the first field (should be blank, unless this is a new collection type
	if (m_lpInputFile->ReadString())
		return true;

	bool fReturn = true;
	while (fReturn == true)
	{
		// Read the process name...
		if (0 == m_lpInputFile->ReadString(szProcessName, BUFFER_SIZE))
			break;

		if (!m_lpInputFile->ReadDWORD(&iProcessID))
		{
			fReturn = false;
			break;
		}

		if ( g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesWithMatchingNameOrPID) )
		{
			// Okay, the user has provided us something to match against our data...
			if ( tszProcessNameToMatch )
			{
				// Process name provided... does it match?
				if ( strcmp(szProcessNameToMatch, szProcessName) )
				{
					// Nope... well then, we should nuke this line...
					m_lpInputFile->ReadFileLine();

					// Then, jump to the next line processing...
					goto ReadNewLine;
				}
#ifdef _DEBUG
				else
				{
					printf("DEBUG: MATCH FOUND ON Process Name [%s]\n", szProcessName);
				}
#endif
			} else
			{
				if ( dwProcessIDToMatch != iProcessID )
				{
					// Nope... well then, we should nuke this line...
					m_lpInputFile->ReadFileLine();

					// Then, jump to the next line processing...
					goto ReadNewLine;
				}
#ifdef _DEBUG
				else
				{
					_tprintf(TEXT("DEBUG: MATCH FOUND ON Process ID [%d]\n"), iProcessID);
				}
#endif
			}
		}

		// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
		// Each Process gets its own 
		lpProcessInfo = new CProcessInfo();

		if (lpProcessInfo == NULL)
		{
			fReturn = false;
			break;
		}

		if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, m_lpInputFile, m_lpOutputFile, NULL))
		{	// Failure initializing the ProcessInfo object?!?
			delete lpProcessInfo;
			lpProcessInfo = NULL;
			fReturn = false;
			break;
		}

		// We need to convert this to Unicode possibly... (it will be copied in EnumModules())
		CUtilityFunctions::CopyAnsiStringToTSTR(szProcessName, tszProcessName, BUFFER_SIZE);

		// Save the process name...
		lpProcessInfo->SetProcessName(tszProcessName);

		// Enumerate the modules for the process
		if (!lpProcessInfo->EnumerateModules(iProcessID, this, tszProcessName))
		{
			fReturn = false;
			break;
		}

		// Success... add this to the Processes Object...
		if (!AddNewProcessInfoObject(lpProcessInfo))
		{ // Failure adding the node...
			delete lpProcessInfo;
			lpProcessInfo = NULL;
			return false;
		}

ReadNewLine:
		
		// Before we read a new line... are we already pointing to the end?
		if (m_lpInputFile->EndOfFile())
		{
			break;
		}

		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			break;
	}
	// We don't expect to find anything...

	return fReturn;
}

CProcesses::ProcessCollectionMethod CProcesses::GetProcessCollectionMethod()
{
	return m_enumProcessCollectionMethod;
}

bool CProcesses::GetProcessesDataForRunningProcessesUsingTOOLHELP32()
{
	CProcessInfo * lpProcessInfo = NULL;
	HANDLE hSnapShot = NULL;
	bool fReturn = false;

	if (!m_fInitialized)
		return false;

	// It's possible the user provided a PID directly... if so,
	// we can circumvent the whole search of PIDs on the system...
	if (g_lpProgramOptions->GetProcessID())
	{
		// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()

		lpProcessInfo = new CProcessInfo();
		if (lpProcessInfo == NULL)
			goto error_cleanup;

		if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
		{
			goto error_cleanup;
		}

		if (lpProcessInfo->EnumerateModules(g_lpProgramOptions->GetProcessID(), this, NULL))
		{
			// Success... add this to the Processes Object...
			if (!AddNewProcessInfoObject(lpProcessInfo))
			{ // Failure adding the node...
				goto error_cleanup; // For now, let's just error on out...
			}

		} else
		{
			// Failure enumerating modules on the only PID of interest... very bad...
			goto error_cleanup;
		}
	}
	else
	{
		PROCESSENTRY32 procentry;
		BOOL bFlag;

        // Get a handle to a Toolhelp snapshot of the systems processes.
        hSnapShot = g_lpDelayLoad->CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

        if( hSnapShot == INVALID_HANDLE_VALUE )
        {
			goto error_cleanup ;
		}

		// Clear this structure
		memset(&procentry, 0, sizeof(procentry));

		// Get the first process' information.
		procentry.dwSize = sizeof(PROCESSENTRY32) ;
		bFlag = g_lpDelayLoad->Process32First( hSnapShot, &procentry ) ;

		// While there are processes, keep looping.
		while( bFlag )
		{
			// Okay, let's create a ProcessInfo object and pass this down to EnumerateModules()
			// Each Process gets its own 
			lpProcessInfo = new CProcessInfo();
			if (lpProcessInfo == NULL)
				goto error_cleanup;

			if (!lpProcessInfo->Initialize(m_lpModuleInfoCache, NULL, m_lpOutputFile, NULL))
			{	
				// Failure initializing the ProcessInfo object?!?
				delete lpProcessInfo;
				lpProcessInfo = NULL;
				
				// Clear this structure
				memset(&procentry, 0, sizeof(procentry));

				// Get the next Process...
				procentry.dwSize = sizeof(PROCESSENTRY32) ;
				bFlag = g_lpDelayLoad->Process32Next( hSnapShot, &procentry );
				continue;
			}

			// Enumerate the modules for this process...
			if (lpProcessInfo->EnumerateModules(procentry.th32ProcessID, this, procentry.szExeFile))
			{
				// Success... add this to the Processes Object...
				if (!AddNewProcessInfoObject(lpProcessInfo))
				{ 
					// Failure adding the node...
					delete lpProcessInfo;
					lpProcessInfo = NULL;
				}

			} else
			{
				// An error enumerating modules might be normal...
				delete lpProcessInfo;
				lpProcessInfo = NULL;
			}

			// Get the next Process...
			procentry.dwSize = sizeof(PROCESSENTRY32) ;
			bFlag = g_lpDelayLoad->Process32Next( hSnapShot, &procentry );
		}
	}

	fReturn =  true;
	goto cleanup;

error_cleanup:
	if (lpProcessInfo)
		delete lpProcessInfo;

cleanup:
	if (hSnapShot != INVALID_HANDLE_VALUE)
		CloseHandle(hSnapShot);

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\processinfonode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfonode.h
//
//--------------------------------------------------------------------------

// ProcessInfoNode.h: interface for the CProcessInfoNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSINFONODE_H__0D2E8503_A01A_11D2_83A8_000000000000__INCLUDED_)
#define AFX_PROCESSINFONODE_H__0D2E8503_A01A_11D2_83A8_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CProcessInfo;	// Forward Declarations

class CProcessInfoNode  
{
public:
	CProcessInfoNode(CProcessInfo * lpProcessInfo);
	virtual ~CProcessInfoNode();

	CProcessInfoNode * m_lpNextProcessInfoNode;
	CProcessInfo * m_lpProcessInfo;

};

#endif // !defined(AFX_PROCESSINFONODE_H__0D2E8503_A01A_11D2_83A8_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\processinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       processinfo.cpp
//
//--------------------------------------------------------------------------

// ProcessInfo.cpp: implementation of the CProcessInfo class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>
#include <TIME.H>

#include "Globals.h"
#include "ProcessInfo.h"
#include "ProcessInfoNode.h"
#include "ProgramOptions.h"
#include "Processes.h"
#include "ModuleInfo.h"
#include "ModuleInfoNode.h"
#include "ModuleInfoCache.h"
#include "FileData.h"
#include "UtilityFunctions.h"
#include "DmpFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProcessInfo::CProcessInfo()
{
	m_fInitialized = false;
	m_tszProcessName= NULL;
	m_iProcessID = 0;
	m_lpModuleInfoHead = NULL;
	m_hModuleInfoHeadMutex = NULL;
	m_iNumberOfModules = 0;
	m_lpInputFile = NULL;
	m_lpOutputFile = NULL;
	m_lpModuleInfoCache = NULL;
	m_hModuleInfoHeadMutex = NULL;
	m_lpDmpFile = NULL;
}

CProcessInfo::~CProcessInfo()
{
	if (m_tszProcessName)
		delete [] m_tszProcessName;

	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	// If we have Module Info Objects... nuke them now...
	if (m_lpModuleInfoHead)
	{

		CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;
		CModuleInfoNode * lpModuleInfoNodePointerToDelete = m_lpModuleInfoHead;

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer)
		{	// Keep looking for the end...
			// Advance our pointer to the next node...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
			
			// Delete the one behind us...
			delete lpModuleInfoNodePointerToDelete;

			// Set the node to delete to the current...
			lpModuleInfoNodePointerToDelete = lpModuleInfoNodePointer;
		}
			
		// Now, clear out the Head pointer...
		m_lpModuleInfoHead = NULL;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	// Now, close the Mutex
	if (m_hModuleInfoHeadMutex)
	{
		CloseHandle(m_hModuleInfoHeadMutex);
		m_hModuleInfoHeadMutex = NULL;
	}

}

//bool CProcessInfo::Initialize(CProgramOptions *lpProgramOptions, CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile)
bool CProcessInfo::Initialize(CModuleInfoCache * lpModuleInfoCache, CFileData * lpInputFile, CFileData * lpOutputFile, CDmpFile * lpDmpFile)
{
	if (lpModuleInfoCache == NULL)
		return false;

	// Let's save off big objects so we don't have to keep passing this to
	// our methods...
	m_lpInputFile = lpInputFile;
	m_lpOutputFile = lpOutputFile;
	m_lpModuleInfoCache = lpModuleInfoCache;
	m_lpDmpFile = lpDmpFile;
	m_hModuleInfoHeadMutex = CreateMutex(NULL, FALSE, NULL);

	if (m_hModuleInfoHeadMutex == NULL)
		return false;

	m_fInitialized = true;
	return true;
}

bool CProcessInfo::EnumerateModules(DWORD iProcessID, CProcesses * lpProcesses, LPTSTR tszProcessName)
{
	bool fReturn = true;

	// Is this being collected interactively?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputProcessesFromLiveSystemMode))
	{
		// Invoke the correct Process Collection Method
		if (lpProcesses->GetProcessCollectionMethod() == CProcesses::TOOLHELP32_METHOD)
		{
			fReturn = EnumerateModulesForRunningProcessUsingTOOLHELP32(iProcessID, tszProcessName); 
		}
		else if (lpProcesses->GetProcessCollectionMethod() == CProcesses::PSAPI_METHOD)
		{
			fReturn = EnumerateModulesForRunningProcessUsingPSAPI(iProcessID);
		}
	}

	// Is this being collected from a file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
	{
		fReturn = EnumerateModulesFromFile(iProcessID, tszProcessName);
	}

	return fReturn;
}

bool CProcessInfo::fModuleNameMatches(LPTSTR tszProcessName, LPTSTR tszModulePath)
{
	if (!tszProcessName || !tszModulePath)
		return false;

	TCHAR fname1[_MAX_FNAME], fname2[_MAX_FNAME];
	TCHAR ext1[_MAX_EXT], ext2[_MAX_EXT];

	_tsplitpath( tszProcessName, NULL, NULL, fname1, ext1 );
	_tsplitpath( tszModulePath,  NULL, NULL, fname2, ext2 );

	if (!ext1 && _tcsicmp(ext1, ext2))
		return false; // Extensions must match (if provided on process name)
	
	if (_tcsicmp(fname1, fname2))
		return false; // Filename must match

	// Do we care about a full path?  If so, we can add in drive and dir vars...
	
	return true;
}

//
// This function takes a provided tszFileName, and looks to see if it has an
// extension of EXE.  If it does, it's saved off...
bool CProcessInfo::fIsProcessName(LPTSTR tszFileName)
{
	if (!tszFileName)
		return false;

	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];

	_tsplitpath( tszFileName,  NULL, NULL, fname, ext );

	if (!ext || _tcsicmp(ext, TEXT(".EXE")))
		return false; // Extensions must match (if provided on process name)
	
	// Let's save off the process name...
	m_tszProcessName = new TCHAR[_tcsclen(fname)+_tcsclen(ext)+1]; 

	if (m_tszProcessName == NULL)
		return false;

	_stprintf(m_tszProcessName, TEXT("%s%s"), _tcsupr(fname), _tcsupr(ext));

	// Yup! It's the Process Name...
	return true;
}

bool CProcessInfo::AddNewModuleInfoObject(CModuleInfo *lpModuleInfo)
{
	if (!m_fInitialized)
	return false;

	// First, create a ModuleInfoNode object and then attach it to the bottom of the
	// linked list of nodes...
	CModuleInfoNode * lpModuleInfoNode = new CModuleInfoNode(lpModuleInfo);

	if (lpModuleInfoNode == NULL)
		return false; // Couldn't allocate memory..

	// Acquire Mutex object to protect the linked-list...
	WaitForSingleObject(m_hModuleInfoHeadMutex, INFINITE);

	CModuleInfoNode * lpModuleInfoNodePointer = m_lpModuleInfoHead;

	if (lpModuleInfoNodePointer) {

		// Traverse the linked list to the end..
		while (lpModuleInfoNodePointer->m_lpNextModuleInfoNode)
		{	// Keep looking for the end...
			lpModuleInfoNodePointer = lpModuleInfoNodePointer->m_lpNextModuleInfoNode;
		}
		
		lpModuleInfoNodePointer->m_lpNextModuleInfoNode = lpModuleInfoNode;

	}
	else
	{ // First time through, the Process Info Head pointer is null...
		m_lpModuleInfoHead = lpModuleInfoNode;
	}

	// Be a good citizen and release the Mutex
	ReleaseMutex(m_hModuleInfoHeadMutex);

	InterlockedIncrement(&m_iNumberOfModules);

	return true;
}

bool CProcessInfo::OutputProcessData(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	if (g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode))
	{	
		if ( g_lpProgramOptions->IsRunningWindowsNT() )
		{
			// Provide TLIST like output (though no window text info)
			_tprintf(TEXT("%4d %s\n"), m_iProcessID, m_tszProcessName);
		} else
		{
			// Provide TLIST like output (though no window text info)
			_tprintf(TEXT("%9d %s\n"), m_iProcessID, m_tszProcessName);
		}
		return true;
	}

	// Output to STDOUT?
	if ( !g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) )
	{
		// Output to Stdout?
		if (!OutputProcessDataToStdout(enumCollectionType, fCSVFileContext, fDumpHeader))
			return false;
	}	

	if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
	{
		CUtilityFunctions::OutputLineOfDashes();
		// Output to STDOUT
		_tprintf(TEXT("\nProcess Name [%s] - PID=%d (0x%x) - "), m_tszProcessName, m_iProcessID, m_iProcessID);
	}

	// Output to file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::OutputCSVFileMode))
	{
		// Try and output to file...
		if (!OutputProcessDataToFile(enumCollectionType, fDumpHeader))
			return false;
	}	

	if (m_lpModuleInfoHead) {
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode))
		{
			_tprintf(TEXT("%d modules recorded\n\n"), m_iNumberOfModules);
			CUtilityFunctions::OutputLineOfDashes();
			_tprintf(TEXT("\n"));
		}

		CModuleInfoNode * lpCurrentModuleInfoNode = m_lpModuleInfoHead;

		unsigned int dwModuleNumber = 1;

		while (lpCurrentModuleInfoNode)
		{
			// We have a node... print out Module Info for it...
			if (lpCurrentModuleInfoNode->m_lpModuleInfo)
			{
				lpCurrentModuleInfoNode->m_lpModuleInfo->OutputData(m_tszProcessName, m_iProcessID, dwModuleNumber);
				dwModuleNumber++;
			}

			lpCurrentModuleInfoNode = lpCurrentModuleInfoNode->m_lpNextModuleInfoNode;
		}

	}
	else
	{
		if (!g_lpProgramOptions->GetMode(CProgramOptions::QuietMode) && fDumpHeader)
		{
			_tprintf(TEXT("no recorded modules\n\n"));
			CUtilityFunctions::OutputLineOfDashes();
			_tprintf(TEXT("\n"));
		}
	}
		
	return true;
}

//bool CProcessInfo::OutputProcessDataToStdout(LPCTSTR tszOutputContext, bool fDumpHeader)
bool CProcessInfo::OutputProcessDataToStdout(CollectionTypes enumCollectionType, bool fCSVFileContext, bool fDumpHeader)
{
	if (fDumpHeader)
	{
		CUtilityFunctions::OutputLineOfStars();
		_tprintf(TEXT("%s - Printing Process Information for 1 Process.\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel);
		_tprintf(TEXT("%s - Context: %s\n"), g_tszCollectionArray[enumCollectionType].tszCSVLabel, fCSVFileContext ? g_tszCollectionArray[enumCollectionType].tszCSVContext : g_tszCollectionArray[enumCollectionType].tszLocalContext);
		CUtilityFunctions::OutputLineOfStars();
	}

	return true;
}

bool CProcessInfo::OutputProcessDataToFile(CollectionTypes enumCollectionType, bool fDumpHeader)
{
	// We skip output of the [processes ]header if -E was specified...
	if (!g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode) && fDumpHeader)
	{
		// Write out the Process tag so I can detect this output format...
		if (!m_lpOutputFile->WriteString(TEXT("\r\n")) ||
			!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVLabel) ||
			!m_lpOutputFile->WriteString(TEXT("\r\n"))
		   )
		{
			_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
			m_lpOutputFile->PrintLastError();
			return false;
		}
	}

	// We skip output of the [processes ]header if -E was specified...
	if (g_lpProgramOptions->GetMode(CProgramOptions::ExceptionMonitorMode) && fDumpHeader)
	{
		// Write out the header... for the -E option...
		if (!m_lpOutputFile->WriteString(TEXT("Module Path,Symbol Status,Time/Date String,File Version,Company Name,File Description,File Time/Date String,Local DBG Status,Local DBG,Local PDB Status,Local PDB\r\n")))
		{
			_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
			m_lpOutputFile->PrintLastError();
			return false;
		}

	} else
	{
		if (fDumpHeader)
		{
			// Write out the Process Header
			if (!m_lpOutputFile->WriteString(g_tszCollectionArray[enumCollectionType].tszCSVColumnHeaders))
			{
				_tprintf(TEXT("Failure writing CSV header to file [%s]!"), m_lpOutputFile->GetFilePath());
				m_lpOutputFile->PrintLastError();
				return false;
			}
		}
	}

	return true;
}

bool CProcessInfo::EnumerateModulesForRunningProcessUsingPSAPI(DWORD iProcessID)
{
	HMODULE        hMod[1024] ;
	HANDLE         hProcess = NULL;
	TCHAR          tszFileName[_MAX_PATH] ;
	DWORD cbNeeded;
	bool fReturn = true; // Optimisim ;)
	tszFileName[0] = 0 ;
	CModuleInfo * lpModuleInfo = NULL;
	
	// Open the process (if we can... security does not
	// permit every process in the system).

	if (iProcessID)
	{
		// Only try to open a Process ID if it's not 0
		hProcess = OpenProcess(
			PROCESS_QUERY_INFORMATION| PROCESS_VM_READ,
			FALSE, 
			iProcessID ) ;
	}
	
	if( hProcess != NULL )
	{
		// Save off our PID (in case we need it later?)
		m_iProcessID = iProcessID;

		// Now, get a handle to each of the modules
		// in our target process...

		// Here we call EnumProcessModules to get only the
		// first module in the process this is important,
		// because this will be the .EXE module for which we
		// will retrieve the full path name in a second.
		if( g_lpDelayLoad->EnumProcessModules( hProcess, hMod, sizeof( hMod ), &cbNeeded ) )
		{
			int iNumberOfModules = cbNeeded / sizeof(HMODULE);
			bool fProcessNameFound = false;
			bool fNew = false;
			
			for(int i=0; i<iNumberOfModules; i++)
			{
				// Get Full pathname!
				if( !g_lpDelayLoad->GetModuleFileNameEx( hProcess, hMod[i], tszFileName, sizeof( tszFileName ) ) )
				{
					tszFileName[0] = 0 ;
				} else	{

					CUtilityFunctions::UnMungePathIfNecessary(tszFileName);

					// We need a full path to the module to do anything useful with it...
					// At this point, let's ... party...
					if (!fProcessNameFound)
						fProcessNameFound = fIsProcessName(tszFileName);
					
					// First, if we were provided a Process name on the commandline, we
					// need to look for a match on the 1st module...
					if (i == 0  && g_lpProgramOptions->GetProcessName())
					{

						if (!fModuleNameMatches(g_lpProgramOptions->GetProcessName(), tszFileName))
						{
							// Bail if this is not a match, and we requested one...
							fReturn = false;
							goto cleanup;
						}
					}

					// Are we ONLY interested in the process list?  
					if (g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode))
					{	
						// All we want is process name.. bail before collecting module info...
						fReturn = true;
						goto cleanup;
					}

					// If "-MATCH" was specified, look to see if this filename meets our criteria
					// before we save this away in our module cache...
					if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszFileName))
						continue;

					// Okay, let's go ahead and get a ModuleInfo Object from our cache...
					// If pfNew returns TRUE, then this object is new and we'll need
					// to populate it with data...
					lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszFileName, &fNew);

					if (false == fNew)
					{
						// We may have the object in the cache... now we need to
						// save a pointer to this object in our Process Info list
						AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...
						continue; // We save having to get the module info again for this module...
					}

					// Not in the cache... so we need to init it, and get the module info...

					// Okay, let's create a ModuleInfo object and pass this down
					// routines that will populate it full of data...
					if (!lpModuleInfo->Initialize(NULL, m_lpOutputFile, NULL))
					{
						continue; // Hmmm... memory error?
					}

					// Let's do it!! Populate the ModuleInfo object with data!!!!
					if (!lpModuleInfo->GetModuleInfo(tszFileName))
					{
						// Well, for now we've at least got the path to the module...
						// Go ahead and get another module..
						continue;
					}

					// Start obtaining information about the modules...

					// We may have the object in the cache... now we need to
					// save a pointer to this object in our Process Info list
					if (!AddNewModuleInfoObject(lpModuleInfo))
					{   // Failure adding the node.... This is pretty serious...
						continue;
					}

				}
			}
			
			fReturn = true;	// Looks good...
		}
		else
		{
			fReturn = false;

			if (!g_lpProgramOptions->GetProcessName())
			{
				// Let's not be so hasty... we couldn't enum modules, but to be friendly we can probably put a name
				// to the Process (based on the Process ID)...
				//
				// This Process ID tends to be "System"
				//
				// On Windows 2000, the Process ID tends to be 8
				//
				// On Windows NT 4.0, this Process ID tends to be 2
				switch (m_iProcessID)
				{
					case 2:
					case 8:
						SetProcessName(TEXT("SYSTEM"));
						fReturn = true;
						break;

					default:
						// Couldn't enumerate modules...
						fReturn = false;
				}
			}
		}
cleanup:
		CloseHandle( hProcess ) ;
	
	} else
	{  // Gotta be able to open the process to look at it...

		fReturn = false;

		if (!g_lpProgramOptions->GetProcessName())
		{
			// Let's not be so hasty... we couldn't enum modules, but to be friendly we can probably put a name
			// to the Process (based on the Process ID)...
			//
			// On Windows 2000, the only Process ID we can't open at all tends to be the "System Idle Process"
			switch (m_iProcessID)
			{
				case 0:
					SetProcessName(TEXT("[SYSTEM PROCESS]"));
					fReturn = true;
					break;

				default:
					// Couldn't enumerate modules...
					fReturn = false;
			}
		}
	}

	return fReturn;
}

bool CProcessInfo::EnumerateModulesFromFile(DWORD iProcessID, LPTSTR tszProcessName)
{
	CModuleInfo * lpModuleInfo;

	// I need these near the end when I probe to see if the next module
	// is for this process...
	enum { BUFFER_SIZE = 128};
	char szTempProcessName[BUFFER_SIZE];
	char szProcessName[BUFFER_SIZE];
	DWORD iTempProcessID;

	// Let's save away the Process Name...

	// Unfortunately, when reading from the CSV file, the data is MBCS... so I need
	// to convert...
	CUtilityFunctions::CopyTSTRStringToAnsi(tszProcessName, szProcessName, BUFFER_SIZE);

	// Copy the Process ID
	m_iProcessID = iProcessID;

	// Local buffer for reading data...
	char szModulePath[_MAX_PATH+1];
	TCHAR tszModulePath[_MAX_PATH+1];
	bool fDone = false;
	bool fNew = false;

	while (!fDone)
	{
		// Read in the Module Path
		if (!m_lpInputFile->ReadString(szModulePath, _MAX_PATH+1))
			return true;

		CUtilityFunctions::CopyAnsiStringToTSTR(szModulePath, tszModulePath, _MAX_PATH+1);

		// If "-MATCH" was specified, look to see if this filename meets our criteria
		// before we save this away in our module cache...
		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszModulePath))
		{
			// Okay... read to the start of the next line...
			if (!m_lpInputFile->ReadFileLine())
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszModulePath, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

			// Okay... read to the start of the next line...
			if (!m_lpInputFile->ReadFileLine())
				goto cleanup;

			goto probe_line; // We save having to get the module info again for this module...
		}

		// Not in the cache... so we need to init it, and get the module info...
		if (!lpModuleInfo->Initialize(m_lpInputFile, m_lpOutputFile, NULL))
		{
			return false; // Hmmm... memory error?
		}

		// Let's do it!! Populate the ModuleInfo object with data!!!!
		if (!lpModuleInfo->GetModuleInfo(tszModulePath, false, 0, true) )
		{
			// Well, we tried and failed... 
			return false;
		}

		// Start obtaining information about the modules...
		if (!AddNewModuleInfoObject(lpModuleInfo))
		{   // Failure adding the node.... This is pretty serious...
			return false;
		}
		
		// Okay, let's go ahead and probe to see what's coming...

probe_line:
		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			goto cleanup;

		// Read the Process Name...
		if (!m_lpInputFile->ReadString(szTempProcessName, BUFFER_SIZE))
			goto cleanup;

		// Compare the process name to the current process...
		if (_stricmp(szTempProcessName, szProcessName))
			goto cleanup;

		// Read the Process ID
		if (!m_lpInputFile->ReadDWORD(&iTempProcessID))
			goto cleanup;

		// Compare the process ID to the current process ID
		if (iTempProcessID != iProcessID)
			goto cleanup;
	}

cleanup:
	// We need to reset out pointer so the functions above us can re-read
	// them (they expect to)...
	m_lpInputFile->ResetBufferPointerToStart();
	return true;
}

bool CProcessInfo::EnumerateModulesForRunningProcessUsingTOOLHELP32(DWORD iProcessID, LPTSTR tszProcessName)
{
	BOOL bFlag;
	MODULEENTRY32 modentry;
	TCHAR tszFileName[_MAX_PATH];
	bool fProcessNameFound = false;
	bool fProcessNameProvided = false;
	bool fReturn = false;
	bool fNew = false;
	int iNumberOfModules = 0;
	HANDLE hSnapShot = INVALID_HANDLE_VALUE;
	CModuleInfo * lpModuleInfo = NULL;

	// Save off our PID (in case we need it later?)
	m_iProcessID = iProcessID;

	if (tszProcessName && SetProcessName(tszProcessName))
	{	
		fProcessNameProvided = true;
	}

	// If we were provided a process name to match, we can do it here...
	if ( fProcessNameProvided && g_lpProgramOptions->GetProcessName() )
	{
		// Let's go ahead and look to see if this is a module name match
		fProcessNameFound = fModuleNameMatches(g_lpProgramOptions->GetProcessName(), GetProcessName());

		// Quit now if we can...
		if (fProcessNameFound == false)
			goto cleanup;
	}

	// If we're doing this for TLIST output... then we already have the process name...
	// We're done!
	if (g_lpProgramOptions->GetMode(CProgramOptions::PrintTaskListMode))
	{
		fReturn = true;
		goto cleanup;
	}

	// Get a handle to a Toolhelp snapshot of the systems processes.
    hSnapShot = g_lpDelayLoad->CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, iProcessID);

    if( hSnapShot == INVALID_HANDLE_VALUE )
    {
		goto cleanup;
	}

	// Get the first process' information.
	modentry.dwSize = sizeof(MODULEENTRY32) ;
	bFlag = g_lpDelayLoad->Module32First( hSnapShot, &modentry ) ;

	// While there are modules, keep looping.
	while( bFlag )
	{
		// We have a new module for this process!
		iNumberOfModules++;

		// Copy the path!
		_tcscpy(tszFileName, modentry.szExePath);

//#ifdef _DEBUG
//		_tprintf(TEXT("[%d] Module = %s\n"), iNumberOfModules, tszFileName);
//#endif

		CUtilityFunctions::UnMungePathIfNecessary(tszFileName);

		// If "-MATCH" was specified, look to see if this filename meets our criteria
		// before we save this away in our module cache...
		if (!g_lpProgramOptions->fDoesModuleMatchOurSearch(tszFileName))
			goto getnextmodule;
		
		// Okay, let's go ahead and get a ModuleInfo Object from our cache...
		// If pfNew returns TRUE, then this object is new and we'll need
		// to populate it with data...
		lpModuleInfo = m_lpModuleInfoCache->AddNewModuleInfoObject(tszFileName, &fNew);

		if (false == fNew)
		{
			// We may have the object in the cache... now we need to
			// save a pointer to this object in our Process Info list
			AddNewModuleInfoObject(lpModuleInfo);  // Just do our best...

			// We save having to get the module info again for this module...
			goto getnextmodule;
		}

		// Not in the cache... so we need to init it, and get the module info...

		// Okay, let's create a ModuleInfo object and pass this down
		// routines that will populate it full of data...
		if (lpModuleInfo->Initialize(NULL, m_lpOutputFile, NULL))
		{

			// Let's do it!! Populate the ModuleInfo object with data!!!!
			if (lpModuleInfo->GetModuleInfo(tszFileName))
			{
					// Start obtaining information about the modules...

					// We may have the object in the cache... now we need to
					// save a pointer to this object in our Process Info list
					if (AddNewModuleInfoObject(lpModuleInfo))
					{   
					}
			}
		}
	
getnextmodule:
		// Get the next Module...
		modentry.dwSize = sizeof(MODULEENTRY32) ;
		bFlag = g_lpDelayLoad->Module32Next( hSnapShot, &modentry );
	}

	fReturn = true;
	
cleanup:
	if (hSnapShot != INVALID_HANDLE_VALUE)
		CloseHandle(hSnapShot);

return fReturn;
}

bool CProcessInfo::SetProcessName(LPTSTR tszFileName)
{
	// Confirm we were given a process name...
	if (!tszFileName)
		return false;

	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];
	TCHAR tszTempFileName[_MAX_FNAME+_MAX_EXT+1];

	// Let's extract the filename from the module path
	_tsplitpath( tszFileName,  NULL, NULL, fname, ext );

	// Reconstruct the filename...
	_stprintf(tszTempFileName, TEXT("%s%s"), _tcsupr(fname), _tcsupr(ext));

	// Let's free anything that's already here...
	if (m_tszProcessName)
		delete [] m_tszProcessName;

	// No conversion necessary... copy over...
	m_tszProcessName = new TCHAR[_tcslen(tszTempFileName)+1];
				
	if (!m_tszProcessName)
		return false;

	_tcscpy(m_tszProcessName, tszTempFileName);

	return true;
}

LPTSTR CProcessInfo::GetProcessName()
{
	return m_tszProcessName;
}

bool CProcessInfo::GetProcessData()
{
	// Is this being collected from a file?
	if (g_lpProgramOptions->GetMode(CProgramOptions::InputCSVFileMode))
		GetProcessDataFromFile();

	return true;
}

bool CProcessInfo::GetProcessDataFromFile()
{
	// Read the Process Header Line
	if (!m_lpInputFile->ReadFileLine())
		return false;

	// Currently, we don't actually read the data...

	enum { BUFFER_SIZE = 128};
	char szProcessName[BUFFER_SIZE];

	TCHAR tszProcessName[BUFFER_SIZE];	

	DWORD iProcessID;

	// Read the first field (should be blank, unless this is a new collection type
	if (m_lpInputFile->ReadString())
		return true;

	bool fReturn = true;
	while (fReturn == true)
	{
		// Read the process name...
		if (0 == m_lpInputFile->ReadString(szProcessName, BUFFER_SIZE))
			break;

		if (!m_lpInputFile->ReadDWORD(&iProcessID))
		{
			fReturn = false;
			break;
		}

		// We need to convert this to Unicode possibly... (it will be copied in EnumModules())
		CUtilityFunctions::CopyAnsiStringToTSTR(szProcessName, tszProcessName, BUFFER_SIZE);

		// Save the process name...
		SetProcessName(tszProcessName);

		// Enumerate the modules for the process
		if (!EnumerateModules(iProcessID, NULL, tszProcessName))
		{
			fReturn = false;
			break;
		}

		// Before we read a new line... are we already pointing to the end?
		if (m_lpInputFile->EndOfFile())
		{
			break;
		}

		// Read the first field (should be blank, unless this is a new collection type
		if (m_lpInputFile->ReadString())
			break;
	}
	// We don't expect to find anything...

	return fReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CheckSym.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\symbolverification.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       symbolverification.h
//
//--------------------------------------------------------------------------

// SymbolVerification.h: interface for the CSymbolVerification class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SYMBOLVERIFICATION_H__1643E486_AD71_11D2_83DE_0010A4F1B732__INCLUDED_)
#define AFX_SYMBOLVERIFICATION_H__1643E486_AD71_11D2_83DE_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include <comdef.h>

//
//#include "oemdbi.h"
//
// Bug MSINFO V4.1:655 - Link to static msdbi60l.lib
#define PDB_LIBRARY
#pragma warning( push )
#pragma warning( disable : 4201 )		// Disable "nonstandard extension used : nameless struct/union" warning
#include "PDB.H"
#pragma warning( pop )

typedef char *          SZ;

// ADO Import
// #define INITGUID
// #import "C:\temp\msado15.dll" no_namespace rename("EOF", "EndOfFile")
#include "msado15.tlh"

//
// Q177939 - INFO: Changes in ADO 1.5 That Affect Visual C++/J++ Programmers[adobj]
//
// #include <initguid.h>    // Newly Required for ADO 1.5.
// #include <adoid.h>
// #include <adoint.h>

// Forward Declarations
class CModuleInfo;

class CSymbolVerification  
{
public:
	CSymbolVerification();
	virtual ~CSymbolVerification();

	bool Initialize();

	bool InitializeSQLServerConnection(LPTSTR tszSQLServerName);
	bool InitializeSQLServerConnection2(LPTSTR tszSQLServerName);  // mjl

	inline bool SQLServerConnectionInitialized() {
		return m_fSQLServerConnectionInitialized;
		};
	inline bool SQLServerConnectionInitialized2() {
		return m_fSQLServerConnectionInitialized2;
		};

	inline bool SQLServerConnectionAttempted() {
		return m_fSQLServerConnectionAttempted;
		};
	inline bool SQLServerConnectionAttempted2() {
		return m_fSQLServerConnectionAttempted2;
		};

	bool SearchForDBGFileUsingSQLServer(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo * lpModuleInfo);
	bool SearchForDBGFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo * lpModuleInfo);
	bool SearchForPDBFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPDBSignature, CModuleInfo * lpModuleInfo);
	bool TerminateSQLServerConnection();
	bool TerminateSQLServerConnection2();

protected:
	bool m_fComInitialized;
	bool m_fSQLServerConnectionAttempted;
	bool m_fSQLServerConnectionAttempted2;  // SQL2 - mjl 12/14/99

	void DumpCOMException(_com_error &e);

	bool m_fSQLServerConnectionInitialized;
	bool m_fSQLServerConnectionInitialized2;	// SQL2 - mjl 12/14/99

	_ConnectionPtr m_lpConnectionPointer;
	_RecordsetPtr  m_lpRecordSetPointer;

	_ConnectionPtr m_lpConnectionPointer2;		// SQL2 - mjl 12/14/99
	_RecordsetPtr  m_lpRecordSetPointer2;		// SQL2 - mjl 12/14/99
};

#endif // !defined(AFX_SYMBOLVERIFICATION_H__1643E486_AD71_11D2_83DE_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\programoptions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       programoptions.h
//
//--------------------------------------------------------------------------

// ProgramOptions.h: interface for the CProgramOptions class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROGRAMOPTIONS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_)
#define AFX_PROGRAMOPTIONS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>

class CProgramOptions  
{
	static const LPTSTR g_DefaultSymbolPath;

public:
	bool fDoesModuleMatchOurSearch(LPCTSTR tszModulePathToTest);
	void DisplaySimpleHelp();
	void DisplayHelp();
	CProgramOptions();
	virtual ~CProgramOptions();

	bool Initialize();
	
	bool ProcessCommandLineArguments(int argc, TCHAR *argv[]);

	// We're going to perform bitwise operations on any number after the -Y switch
	// to determine what type of symbol path searching is desired...
	enum SymbolPathSearchAlgorithms
	{
		enumSymbolPathNormal =					 0x0,
		enumSymbolPathOnly =					 0x1,
		enumSymbolPathRecursion =				 0x2,
		enumSymbolsModeUsingDBGInMISCSection =   0x4
	};

	enum DebugLevel
	{
		enumDebugSearchPaths = 0x1
	};

	enum ProgramModes { 
						// Help Modes
						SimpleHelpMode,
						HelpMode,
						
						// Input Methods
						InputProcessesFromLiveSystemMode, 			// Querying live processes
						InputDriversFromLiveSystemMode, 			// Querying live processes
						InputProcessesWithMatchingNameOrPID,		// Did the user provide a PID or Process Name?
						InputModulesDataFromFileSystemMode,			// Input Modules Data from File System
						InputCSVFileMode,							// Input Data from CSV File
						InputDmpFileMode,							// Input Data from DMP File
						
						// Collection Options
						CollectVersionInfoMode, 

						// Matching Options
						MatchModuleMode,
						
						// Verification Modes
						VerifySymbolsMode,
						VerifySymbolsModeWithSymbolPath, 
						VerifySymbolsModeWithSymbolPathOnly,
						VerifySymbolsModeWithSymbolPathRecursion,
						VerifySymbolsModeUsingDBGInMISCSection,
						VerifySymbolsModeWithSQLServer,
						VerifySymbolsModeWithSQLServer2,			// SQL2 - mjl 12/14/99
						
						// Output Methods
						OutputSymbolInformationMode,    
						BuildSymbolTreeMode,
						PrintTaskListMode,
						QuietMode,	// No output to stdout... 
						OutputCSVFileMode,
						OverwriteOutputFileMode,
						OutputDiscrepanciesOnly,

						ExceptionMonitorMode
	}; 

	bool GetMode(enum ProgramModes mode);
	bool SetMode(enum ProgramModes mode, bool fState);
	bool DisplayProgramArguments();

	// INLINE Methods!

#ifdef _UNICODE
	inline bool IsRunningWindows() { // If Windows 9x
		return (m_osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
		};
#endif

	inline bool IsRunningWindowsNT() { // If Windows NT
		return (m_osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
		};

	inline LPTSTR GetProcessName() {
		return m_tszProcessName;
		};

	inline LPTSTR GetModuleToMatch() {
		return m_tszModuleToMatch;
		};

	inline LPTSTR GetOutputFilePath() {
		return m_tszOutputCSVFilePath;
		};

	inline LPTSTR GetSQLServerName() {
		return m_tszSQLServer;
		};

	inline LPTSTR GetSQLServerName2() {
		return m_tszSQLServer2;
		};

	inline LPTSTR GetSymbolPath() {
		return m_tszSymbolPath;
		};

	inline LPTSTR GetInputFilePath() {
		return m_tszInputCSVFilePath;
		};

	inline LPTSTR GetDmpFilePath() {
		return m_tszInputDmpFilePath;
	};

	inline LPTSTR GetSymbolTreeToBuild() {
		return m_tszSymbolTreeToBuild;
	};

	inline LPTSTR GetInputModulesDataFromFileSystemPath() {
		return m_tszInputModulesDataFromFileSystemPath;
		};

	inline DWORD GetProcessID() {
		return m_iProcessID;
		};

	inline bool fDebugSearchPaths()
	{
		return (m_dwDebugLevel & enumDebugSearchPaths) == enumDebugSearchPaths;
	};

	inline unsigned int GetVerificationLevel() {
		return m_iVerificationLevel;
		};
	
protected:
	OSVERSIONINFOA m_osver;
	bool VerifySemiColonSeparatedPath(LPTSTR tszPath);
	bool SetProcessID(DWORD iPID);

	unsigned int m_iVerificationLevel;

	DWORD m_iProcessID;
	DWORD m_dwDebugLevel;

	LPTSTR m_tszInputCSVFilePath;
	LPTSTR m_tszInputDmpFilePath;

	LPTSTR m_tszOutputCSVFilePath;
	LPTSTR m_tszProcessName;
	LPTSTR m_tszModuleToMatch;
	LPTSTR m_tszSymbolPath;
	LPTSTR m_tszSymbolTreeToBuild;
	LPTSTR m_tszInputModulesDataFromFileSystemPath;
	LPTSTR m_tszSQLServer;
	LPTSTR m_tszSQLServer2;	// SQL2 - mjl 12/14/99

	bool m_fSimpleHelpMode;
	bool m_fHelpMode;

	bool m_fInputProcessesFromLiveSystemMode;
	bool m_fInputDriversFromLiveSystemMode;
	bool m_fInputProcessesWithMatchingNameOrPID;
	bool m_fInputCSVFileMode;
	bool m_fInputDmpFileMode;

	bool m_fInputModulesDataFromFileSystemMode;
	bool m_fMatchModuleMode;
	bool m_fOutputSymbolInformationMode;
	bool m_fCollectVersionInfoMode;
	
	bool m_fVerifySymbolsMode;
	bool m_fVerifySymbolsModeWithSymbolPath;
	bool m_fVerifySymbolsModeWithSymbolPathOnly;
	bool m_fVerifySymbolsModeWithSymbolPathRecursion;
	bool m_fVerifySymbolsModeUsingDBGInMISCSection;
	bool m_fVerifySymbolsModeWithSQLServer;
	bool m_fVerifySymbolsModeWithSQLServer2; // SQL2 - mjl 12/14/99
	
	bool m_fSymbolTreeToBuildMode;
	bool m_fPrintTaskListMode;
	bool m_fQuietMode;
	bool m_fOutputCSVFileMode;
	bool m_fOutputDiscrepanciesOnly;
	bool m_fOverwriteOutputFileMode;

	bool m_fExceptionMonitorMode;
};

#endif // !defined(AFX_PROGRAMOPTIONS_H__D0C1E0B9_9F50_11D2_83A2_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\symbolverification.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       symbolverification.cpp
//
//--------------------------------------------------------------------------

// SymbolVerification.cpp: implementation of the CSymbolVerification class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <TCHAR.H>
#include <STDIO.H>

#include "globals.h"
#include "SymbolVerification.h"
#include "ModuleInfo.h"
#include "UtilityFunctions.h"

#pragma warning (push)
#pragma warning ( disable : 4710)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSymbolVerification::CSymbolVerification()
{
	m_fComInitialized = false;

	m_fSQLServerConnectionAttempted = false;
	m_fSQLServerConnectionInitialized = false;

	// SQL2 - mjl 12/14/99
	m_fSQLServerConnectionAttempted2   = false;
	m_fSQLServerConnectionInitialized2 = false;

	// Initialize ADO Connection Object to NULL
	m_lpConnectionPointer  = NULL;
	m_lpConnectionPointer2 = NULL;	// SQL2 - mjl 12/14/99
}

CSymbolVerification::~CSymbolVerification()
{
	if (SQLServerConnectionInitialized())
	{
		TerminateSQLServerConnection();
	}

	if (SQLServerConnectionInitialized2())
	{
		TerminateSQLServerConnection2();
	}

	if (m_fComInitialized)
		::CoUninitialize();
}

bool CSymbolVerification::Initialize()
{
	HRESULT hr = S_OK;

	// Initialize COM
	hr = ::CoInitialize(NULL); 

	if (FAILED(hr))
	{
		_tprintf(TEXT("Failed Initializing COM!\n"));
		return false;
	}

	// Com is initialized!
	m_fComInitialized = true;

	return true; 
}

bool CSymbolVerification::InitializeSQLServerConnection(LPTSTR tszSQLServerName)
{
	HRESULT hr = S_OK;
	TCHAR tszConnectionString[256];
	
	m_fSQLServerConnectionAttempted = true;

	_tprintf(TEXT("\nAttempting connection to SQL Server [%s]..."), tszSQLServerName);
	
	// Compose the Connection String
	// ie. "driver={SQL Server};server=<servername>;database=Symbols"
	_tcscpy(tszConnectionString, TEXT("driver={SQL Server};server="));
	_tcscat(tszConnectionString, tszSQLServerName);
	_tcscat(tszConnectionString, TEXT(";uid=GUEST;pwd=guest;database=Symbols"));

	try 
	{
		// Okay, we need a BSTR
		_bstr_t bstrConnectionString( tszConnectionString );

   		// Okay, let's try and actually create this Connection Pointer...
		hr = m_lpConnectionPointer.CreateInstance( __uuidof( Connection ) );

		if (FAILED(hr))
			goto error;

		// Now, let's use the Connection Pointer object to actually get connected...
		hr = m_lpConnectionPointer->Open( bstrConnectionString, "", "", -1);

		if (FAILED(hr))
			goto error;

		
		// Now, let's create a RecordSet for use later...
		hr = m_lpRecordSetPointer.CreateInstance( __uuidof( Recordset ) );

		if (FAILED(hr))
			goto error;

		m_fSQLServerConnectionInitialized = true;

		_tprintf(TEXT("SUCCESS!\n\n"));

	}	

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE!\n\n") );
		DumpCOMException(e);
		goto error;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE!\n\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto error;
	}
	
	goto cleanup;

error:
	if (m_lpConnectionPointer)
		m_lpConnectionPointer = NULL;

	_tprintf(TEXT("\nFAILURE Attempting SQL Server Connection!  Error = 0x%x\n"), hr);

	switch (hr)
	{
		case E_NOINTERFACE:
		case REGDB_E_CLASSNOTREG:
			_tprintf(TEXT("\nThe most likely reason for this is that your system does not have\n"));
			_tprintf(TEXT("the necessary ADO components installed.  You should install the\n"));
			_tprintf(TEXT("latest Microsoft Data Access Component (MDAC) release available on\n"));
			_tprintf(TEXT("http://www.microsoft.com/data/download.htm\n"));

			break;
	}


cleanup:
	return 	m_fSQLServerConnectionInitialized;
}

void CSymbolVerification::DumpCOMException(_com_error &e)
{
	_tprintf( TEXT("\tCode = %08lx\n"), e.Error());
	_tprintf( TEXT("\tCode meaning = %s\n"), e.ErrorMessage());

	_bstr_t bstrSource(e.Source());
	_bstr_t bstrDescription(e.Description());

	_tprintf( TEXT("\tSource = %s\n"), (LPCSTR) bstrSource);
	_tprintf( TEXT("\tDescription = %s\n"), (LPCSTR) bstrDescription);
}

bool CSymbolVerification::TerminateSQLServerConnection()
{
	// Free the Connection
	if (m_lpConnectionPointer)
		m_lpConnectionPointer = NULL;

	if (m_lpRecordSetPointer)
		m_lpRecordSetPointer = NULL;

	m_fSQLServerConnectionInitialized = false;

	return true;	
}

bool CSymbolVerification::SearchForDBGFileUsingSQLServer(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo *lpModuleInfo)
{
	HRESULT hr = S_OK;
	FieldPtr		lpFieldSymbolPath = NULL;
	_variant_t		vSymbolPath;

	wchar_t			wszSymbolPath[_MAX_PATH+1];
	wchar_t			wszReturnedDBGFile[_MAX_FNAME];
	wchar_t			wszReturnedDBGFileExtension[_MAX_EXT];
	
	TCHAR			tszCommandText[256];
	TCHAR			tszLinkerDate[64]; // Plenty big...
	TCHAR			tszDBGFileName[_MAX_FNAME];
	
	HANDLE			hFileHandle;

	_tsplitpath(tszPEImageModuleName, NULL, NULL, tszDBGFileName, NULL);

#ifdef _UNICODE
	
	LPTSTR wszDBGFileName = tszDBGFileName;

#else

	wchar_t wszDBGFileName[_MAX_FNAME];

	MultiByteToWideChar(	CP_ACP,
							MB_PRECOMPOSED,
							tszDBGFileName,
							-1,
							wszDBGFileName,
							_MAX_FNAME);
#endif

	// Compose the Connection String
	// ie. "driver={SQL Server};server=<servername>;database=Symbols"
	_tcscpy(tszCommandText, TEXT("SELECT FILENAME FROM Symbols WHERE TIMESTAMP = '"));

	_stprintf(tszLinkerDate, TEXT("%x"), dwPEImageTimeDateStamp);
	_tcscat(tszCommandText, tszLinkerDate);

	_tcscat(tszCommandText, TEXT("'"));

	try {
		_bstr_t bstrCommandText( tszCommandText );

		m_lpRecordSetPointer = m_lpConnectionPointer->Execute(bstrCommandText, NULL, adCmdText);

		lpFieldSymbolPath = m_lpRecordSetPointer->Fields->GetItem(_variant_t( "FILENAME" ));

#ifdef _DEBUG
		_tprintf(TEXT("Searching SQL Server for matching symbol for [%s]\n"), tszPEImageModuleName);
#endif

		while (VARIANT_FALSE == m_lpRecordSetPointer->EndOfFile)
		{
			vSymbolPath.Clear();

			vSymbolPath = lpFieldSymbolPath->Value;

			wcscpy(wszSymbolPath, vSymbolPath.bstrVal);

			_wsplitpath(wszSymbolPath, NULL, NULL, wszReturnedDBGFile, wszReturnedDBGFileExtension);

			// 
			if ( (_wcsicmp(wszReturnedDBGFile, wszDBGFileName) == 0 ) &&
				 (_wcsicmp(wszReturnedDBGFileExtension, L".DBG") == 0 )
			   )
			{
#ifdef _DEBUG
				wprintf(L"Module path = %s\n", wszSymbolPath);
#endif
#ifdef _UNICODE
				wchar_t * tszSymbolPath = wszSymbolPath;
#else
				char   tszSymbolPath[_MAX_PATH+1];

				WideCharToMultiByte(CP_ACP,
						0,
						wszSymbolPath,
						-1,
						tszSymbolPath,
						_MAX_PATH+1,
					    NULL,
						NULL);
#endif
				// Okay, let's validate the DBG file we are pointing to...
				hFileHandle = CreateFile(	tszSymbolPath,
											GENERIC_READ,
											(FILE_SHARE_READ | FILE_SHARE_WRITE),
											NULL,
											OPEN_EXISTING,
											0,
											NULL);

				// Does the returned handle look good?
				if (hFileHandle != INVALID_HANDLE_VALUE)
				{
					lpModuleInfo->VerifyDBGFile(hFileHandle, tszSymbolPath, lpModuleInfo);
				} else
				{
					_tprintf(TEXT("\nERROR: Searching for [%s]!\n"), tszSymbolPath);
					CUtilityFunctions::PrintMessageString(GetLastError());
				}

				CloseHandle(hFileHandle);

				if (lpModuleInfo->GetDBGSymbolModuleStatus() == CModuleInfo::SymbolModuleStatus::SYMBOL_MATCH)
				{
					// Cool... it really does match...
					hr = m_lpRecordSetPointer->Close();
					goto cleanup;
				}
			}

			m_lpRecordSetPointer->MoveNext();
		}

		hr = m_lpRecordSetPointer->Close();

		if (FAILED(hr))
			goto error;

	}

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
		DumpCOMException(e);
		goto cleanup;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto cleanup;
	}
	
	goto cleanup;

error:

	TerminateSQLServerConnection();

	_tprintf(TEXT("FAILURE Attempting to query the SQL Server!\n"));

cleanup:
	return true;
}

/////////////////////////// mjl //////////////////////////////////////////

bool CSymbolVerification::InitializeSQLServerConnection2(LPTSTR tszSQLServerName)
{
	HRESULT hr = S_OK;
	TCHAR tszConnectionString[256];
	
	m_fSQLServerConnectionAttempted2 = true;

	_tprintf(TEXT("\nAttempting connection to SQL Server [%s]..."), tszSQLServerName);

	// Compose the Connection String
	// ie. "driver={SQL Server};server=<servername>;database=Symbols"
	_tcscpy(tszConnectionString, TEXT("driver={SQL Server};server="));
	_tcscat(tszConnectionString, tszSQLServerName);
	_tcscat(tszConnectionString, TEXT(";uid=GUEST;pwd=guest;database=Symbols2"));

	try 
	{
		// Okay, we need a BSTR
		_bstr_t bstrConnectionString( tszConnectionString );

   		// Okay, let's try and actually create this Connection Pointer...
		hr = m_lpConnectionPointer2.CreateInstance( __uuidof( Connection ) );

		if (FAILED(hr))
			goto error;

		// Now, let's use the Connection Pointer object to actually get connected...
		hr = m_lpConnectionPointer2->Open( bstrConnectionString, "", "", -1);

		if (FAILED(hr))
			goto error;

		
		// Now, let's create a RecordSet for use later...
		hr = m_lpRecordSetPointer2.CreateInstance( __uuidof( Recordset ) );

		if (FAILED(hr))
			goto error;

		_tprintf(TEXT("Complete\n"));

		m_fSQLServerConnectionInitialized2 = true;
	}	

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
		DumpCOMException(e);
		goto error;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto error;
	}
	
	goto cleanup;

error:
	if (m_lpConnectionPointer2)
		m_lpConnectionPointer2 = NULL;

	_tprintf(TEXT("\nFAILURE Attempting SQL Server Connection!  Error = 0x%x\n"), hr);

	switch (hr)
	{
		case E_NOINTERFACE:
		case REGDB_E_CLASSNOTREG:
			_tprintf(TEXT("\nThe most likely reason for this is that your system does not have\n"));
			_tprintf(TEXT("the necessary ADO components installed.  You should install the\n"));
			_tprintf(TEXT("latest Microsoft Data Access Component (MDAC) release available on\n"));
			_tprintf(TEXT("http://www.microsoft.com/data/download.htm\n"));

			break;
	}

cleanup:
	return 	m_fSQLServerConnectionInitialized2;
}


bool CSymbolVerification::TerminateSQLServerConnection2()
{
	// Free the Connection
	if (m_lpConnectionPointer2)
		m_lpConnectionPointer2 = NULL;

	if (m_lpRecordSetPointer2)
		m_lpRecordSetPointer2 = NULL;

	m_fSQLServerConnectionInitialized2 = false;

	return true;	
}

bool CSymbolVerification::SearchForDBGFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPEImageTimeDateStamp, CModuleInfo *lpModuleInfo)
{
	HRESULT hr = S_OK;
	FieldPtr		lpFieldSymbolPath = NULL;
	_variant_t		vSymbolPath;

	_bstr_t			sFieldSymbolPath;
	wchar_t			wszSymbolPath[_MAX_PATH+1];
	wchar_t			wszReturnedDBGFile[_MAX_FNAME];
	wchar_t			wszReturnedDBGFileExtension[_MAX_EXT];
	
	TCHAR			tszCommandText[512];
	TCHAR			tszDBGFileName[_MAX_FNAME];
	
	HANDLE			hFileHandle;

	_tsplitpath(tszPEImageModuleName, NULL, NULL, tszDBGFileName, NULL);

#ifdef _UNICODE
	
	LPTSTR wszDBGFileName = tszDBGFileName;

#else

	wchar_t wszDBGFileName[_MAX_FNAME];

	MultiByteToWideChar(	CP_ACP,
							MB_PRECOMPOSED,
							tszDBGFileName,
							-1,
							wszDBGFileName,
							_MAX_FNAME);
#endif

	// Compose the Query String
	_stprintf(tszCommandText, TEXT("SELECT tblDBGModulePaths.DBGModulePath FROM tblDBGModules,tblDBGModulePaths WHERE tblDBGModules.DBGFilename='%s.DBG' AND tblDBGModules.TimeDateStamp='%d' AND tblDBGModules.DBGModuleID = tblDBGModulePaths.DBGModuleID"),tszDBGFileName,dwPEImageTimeDateStamp);
	try {
		_bstr_t bstrCommandText( tszCommandText );

		m_lpRecordSetPointer2 = m_lpConnectionPointer2->Execute(bstrCommandText, NULL, adCmdText);

	    while ( !m_lpRecordSetPointer2->EndOfFile )
		{
			vSymbolPath = m_lpRecordSetPointer2->Fields->GetItem("DBGModulePath")->Value;
 		    lpFieldSymbolPath = m_lpRecordSetPointer2->Fields->GetItem(_variant_t( "DBGModulePath" ));

#ifdef _DEBUG
		    _tprintf(TEXT("Searching SQL Server for matching symbol for [%s]\n"), tszPEImageModuleName);
#endif
			vSymbolPath.Clear();

			vSymbolPath = lpFieldSymbolPath->Value;

			wcscpy(wszSymbolPath, vSymbolPath.bstrVal);

			_wsplitpath(wszSymbolPath, NULL, NULL, wszReturnedDBGFile, wszReturnedDBGFileExtension);

			// 
			if ( (_wcsicmp(wszReturnedDBGFile, wszDBGFileName) == 0 ) &&
				 (_wcsicmp(wszReturnedDBGFileExtension, L".DBG") == 0 )
			   )
			{
#ifdef _DEBUG
				wprintf(L"Module path = %s\n", wszSymbolPath);
#endif
#ifdef _UNICODE
				wchar_t * tszSymbolPath = wszSymbolPath;
#else
				char   tszSymbolPath[_MAX_PATH+1];

				WideCharToMultiByte(CP_ACP,
						0,
						wszSymbolPath,
						-1,
						tszSymbolPath,
						_MAX_PATH+1,
					    NULL,
						NULL);
#endif
				// Okay, let's validate the DBG file we are pointing to...
				hFileHandle = CreateFile(	tszSymbolPath,
											GENERIC_READ,
											(FILE_SHARE_READ | FILE_SHARE_WRITE),
											NULL,
											OPEN_EXISTING,
											0,
											NULL);

				// Does the returned handle look good?
				if (hFileHandle != INVALID_HANDLE_VALUE)
				{
					lpModuleInfo->VerifyDBGFile(hFileHandle, tszSymbolPath, lpModuleInfo);
				} else
				{
					_tprintf(TEXT("\nERROR: Searching for [%s]!\n"), tszSymbolPath);
					CUtilityFunctions::PrintMessageString(GetLastError());
				}

				CloseHandle(hFileHandle);

				if (lpModuleInfo->GetDBGSymbolModuleStatus() == CModuleInfo::SymbolModuleStatus::SYMBOL_MATCH)
				{
					// Cool... it really does match...
					hr = m_lpRecordSetPointer2->Close();
					goto cleanup;
				}
			}

			m_lpRecordSetPointer2->MoveNext();
		}

		hr = m_lpRecordSetPointer2->Close();

		if (FAILED(hr))
			goto error;

	}

	catch (_com_error &e )
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
		DumpCOMException(e);
		goto cleanup;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto cleanup;
	}
	
	goto cleanup;

error:

	TerminateSQLServerConnection();

	_tprintf(TEXT("FAILURE Attempting to query the SQL Server!\n"));

cleanup:
	return true;
}

bool CSymbolVerification::SearchForPDBFileUsingSQLServer2(LPTSTR tszPEImageModuleName, DWORD dwPDBSignature, CModuleInfo *lpModuleInfo)
{
	HRESULT hr = S_OK;
	FieldPtr		lpFieldSymbolPath = NULL;
	_variant_t		vSymbolPath;

	_bstr_t			sFieldSymbolPath;
	wchar_t			wszSymbolPath[_MAX_PATH+1];
	wchar_t			wszReturnedPDBFile[_MAX_FNAME];
	wchar_t			wszReturnedPDBFileExtension[_MAX_EXT];
	
	TCHAR			tszCommandText[512];
	TCHAR			tszPDBFileName[_MAX_FNAME];
	
	HANDLE			hFileHandle;

	_tsplitpath(tszPEImageModuleName, NULL, NULL, tszPDBFileName, NULL);

#ifdef _UNICODE
	
	LPTSTR wszPDBFileName = tszPDBFileName;

#else

	wchar_t wszPDBFileName[_MAX_FNAME];

	MultiByteToWideChar(	CP_ACP,
							MB_PRECOMPOSED,
							tszPDBFileName,
							-1,
							wszPDBFileName,
							_MAX_FNAME);
#endif

	// Compose the Query String
	_stprintf(tszCommandText, TEXT("SELECT tblPDBModulePaths.PDBModulePath FROM tblPDBModules,tblPDBModulePaths WHERE tblPDBModules.PDBFilename='%s.PDB' AND tblPDBModules.PDBSignature='%d' AND tblPDBModules.PDBModuleID = tblPDBModulePaths.PDBModuleID"),tszPDBFileName,dwPDBSignature);
	try {
		_bstr_t bstrCommandText( tszCommandText );

		m_lpRecordSetPointer2 = m_lpConnectionPointer2->Execute(bstrCommandText, NULL, adCmdText);

	    while ( !m_lpRecordSetPointer2->EndOfFile )
		{
			vSymbolPath = m_lpRecordSetPointer2->Fields->GetItem("PDBModulePath")->Value;
 		    lpFieldSymbolPath = m_lpRecordSetPointer2->Fields->GetItem(_variant_t( "PDBModulePath" ));

#ifdef _DEBUG
		    _tprintf(TEXT("Searching SQL Server for matching symbol for [%s]\n"), tszPEImageModuleName);
#endif

			vSymbolPath.Clear();

			vSymbolPath = lpFieldSymbolPath->Value;

			wcscpy(wszSymbolPath, vSymbolPath.bstrVal);

			_wsplitpath(wszSymbolPath, NULL, NULL, wszReturnedPDBFile, wszReturnedPDBFileExtension);

			if ( (_wcsicmp(wszReturnedPDBFile, wszPDBFileName) == 0 ) &&
				 (_wcsicmp(wszReturnedPDBFileExtension, L".PDB") == 0 )
			   )
			{
#ifdef _DEBUG
				wprintf(L"Module path = %s\n", wszSymbolPath);
#endif
#ifdef _UNICODE
				wchar_t * tszSymbolPath = wszSymbolPath;
#else
				char   tszSymbolPath[_MAX_PATH+1];

				WideCharToMultiByte(CP_ACP,
						0,
						wszSymbolPath,
						-1,
						tszSymbolPath,
						_MAX_PATH+1,
					    NULL,
						NULL);
#endif
				// Okay, let's validate the DBG file we are pointing to...
				hFileHandle = CreateFile(	tszSymbolPath,
											GENERIC_READ,
											(FILE_SHARE_READ | FILE_SHARE_WRITE),
											NULL,
											OPEN_EXISTING,
											0,
											NULL);

				// Does the returned handle look good?
				if (hFileHandle != INVALID_HANDLE_VALUE)
				{
					lpModuleInfo->VerifyPDBFile(hFileHandle, tszSymbolPath, lpModuleInfo);
				} else
				{
					_tprintf(TEXT("\nERROR: Searching for [%s]!\n"), tszSymbolPath);
					CUtilityFunctions::PrintMessageString(GetLastError());
				}

				CloseHandle(hFileHandle);

				if (lpModuleInfo->GetPDBSymbolModuleStatus() == CModuleInfo::SymbolModuleStatus::SYMBOL_MATCH)
				{
					// Cool... it really does match...
					hr = m_lpRecordSetPointer2->Close();
					goto cleanup;
				}
			}

			m_lpRecordSetPointer2->MoveNext();
		}

		hr = m_lpRecordSetPointer2->Close();

		if (FAILED(hr))
			goto error;

	}

	catch (_com_error &e )
	{
		_tprintf( TEXT("\nFAILURE Attempting SQL2 Server Connection!\n") );
		DumpCOMException(e);
		goto cleanup;
	}

	catch (...)
	{
		_tprintf( TEXT("FAILURE Attempting SQL2 Server Connection!\n") );
	    _tprintf( TEXT("Caught an exception of unknown type\n" ) );
		goto cleanup;
	}
	
	goto cleanup;

error:

	TerminateSQLServerConnection2();

	_tprintf(TEXT("FAILURE Attempting to query the SQL Server!\n"));

cleanup:
	return true;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\programoptions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       programoptions.cpp
//
//--------------------------------------------------------------------------

// ProgramOptions.cpp: implementation of the CProgramOptions class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>
#include <stdlib.h>

#include "ProgramOptions.h"
#include "UtilityFunctions.h"
#include "Version.h"

const LPTSTR CProgramOptions::g_DefaultSymbolPath = TEXT("%systemroot%\\symbols");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CProgramOptions::CProgramOptions()
{
	// Initialize default modes
	m_fSimpleHelpMode = false;
	m_fHelpMode = false;

	m_fInputProcessesFromLiveSystemMode = false;
	m_fInputDriversFromLiveSystemMode = false;
	m_fInputProcessesWithMatchingNameOrPID = false;
	m_fInputModulesDataFromFileSystemMode = false;
	m_fInputDmpFileMode = false;

	m_fMatchModuleMode = false;
	
	m_fPrintTaskListMode = false;
	m_fOutputSymbolInformationMode = false;
	m_fCollectVersionInfoMode = false;

	m_fVerifySymbolsMode = false;
	m_fVerifySymbolsModeWithSymbolPath = false;
	m_fVerifySymbolsModeWithSymbolPathOnly = false;
	m_fVerifySymbolsModeWithSymbolPathRecursion = false;
	m_fVerifySymbolsModeWithSQLServer = false;
	m_fVerifySymbolsModeWithSQLServer2 = false;		// SQL2 - mjl 12/14/99
	m_iVerificationLevel = 1;
	
	m_fSymbolTreeToBuildMode = false;
	m_fInputCSVFileMode = false;
	m_fOutputCSVFileMode = false;
	m_fOutputDiscrepanciesOnly = false;
	m_fOverwriteOutputFileMode = false;
	m_fQuietMode = false;

	m_tszSymbolTreeToBuild = NULL;
	m_tszSymbolPath = NULL;
	m_tszProcessName = NULL;
	m_tszModuleToMatch = NULL;
	m_tszOutputCSVFilePath = NULL;
	m_tszInputCSVFilePath = NULL;
	m_tszInputDmpFilePath = NULL;

	m_tszInputModulesDataFromFileSystemPath = NULL;
	m_tszSQLServer = NULL;

	m_iProcessID = 0;
	m_dwDebugLevel = 0;

	m_fExceptionMonitorMode = false;
}

CProgramOptions::~CProgramOptions()
{
	if (m_tszSymbolPath)
		delete [] m_tszSymbolPath;

	if (m_tszProcessName)
		delete [] m_tszProcessName;

	if (m_tszModuleToMatch)
		delete [] m_tszModuleToMatch;

	if (m_tszOutputCSVFilePath)
		delete [] m_tszOutputCSVFilePath;

	if (m_tszInputCSVFilePath)
		delete [] m_tszInputCSVFilePath;

	if (m_tszInputDmpFilePath)
		delete [] m_tszInputDmpFilePath;

	if (m_tszInputModulesDataFromFileSystemPath)
		delete [] m_tszInputModulesDataFromFileSystemPath;

	if (m_tszSymbolTreeToBuild)
		delete [] m_tszSymbolTreeToBuild;

	if (m_tszSQLServer)
		delete [] m_tszSQLServer;
}

// Intialize members that have to dynamically allocate memory...
bool CProgramOptions::Initialize()
{
	// Copy expanded default symbol search path (%systemroot%\symbols)
	m_tszSymbolPath = CUtilityFunctions::ExpandPath(g_DefaultSymbolPath);

	if (!m_tszSymbolPath)
		return false;

#ifdef _DEBUG
	_tprintf(TEXT("Default Symbol Path = [%s]\n"), m_tszSymbolPath);
#endif

	// Get the OS Version Info Stuff
	m_osver.dwOSVersionInfoSize = sizeof( m_osver ) ;

	if( !GetVersionExA( &m_osver ) )
	{
		_tprintf(TEXT("Couldn't figure out what version of Windows is running.\n"));
		return false ;
	}

	return true;
}

// This sets the mode requested, and returns the value it was set to (which is provided as input)
bool CProgramOptions::SetMode(enum ProgramModes mode, bool fState)
{
	switch (mode)
	{
		case HelpMode:
			m_fHelpMode = fState;
			break;

		case SimpleHelpMode:
			m_fSimpleHelpMode = fState;
			break;

		case InputProcessesFromLiveSystemMode:
			m_fInputProcessesFromLiveSystemMode = fState;
			break;

		case InputDriversFromLiveSystemMode:
			m_fInputDriversFromLiveSystemMode = fState;
			break;

		case InputProcessesWithMatchingNameOrPID:
			m_fInputProcessesWithMatchingNameOrPID = fState;
			break;

		case MatchModuleMode:
			m_fMatchModuleMode = fState;
			break;

		case InputModulesDataFromFileSystemMode:
			m_fInputModulesDataFromFileSystemMode = fState;
			break;

		case InputDmpFileMode:
			m_fInputDmpFileMode = fState;
			break;

		case PrintTaskListMode:
			m_fPrintTaskListMode = fState;
			break;

		case QuietMode:
			m_fQuietMode = fState;
			break;

		case OutputSymbolInformationMode:
			m_fOutputSymbolInformationMode = fState;
			break;

		case CollectVersionInfoMode:
			m_fCollectVersionInfoMode = fState;
			break;

		case VerifySymbolsMode:
			m_fVerifySymbolsMode = fState;
			break;

		case VerifySymbolsModeWithSymbolPath:
			m_fVerifySymbolsModeWithSymbolPath = fState;
			break;

		case VerifySymbolsModeWithSymbolPathOnly:
			m_fVerifySymbolsModeWithSymbolPathOnly = fState;
			break;

		case VerifySymbolsModeWithSymbolPathRecursion:
			m_fVerifySymbolsModeWithSymbolPathRecursion = fState;
			break;

		case VerifySymbolsModeUsingDBGInMISCSection:
			m_fVerifySymbolsModeUsingDBGInMISCSection = fState;
			break;

		case VerifySymbolsModeWithSQLServer:
			m_fVerifySymbolsModeWithSQLServer = fState;
			break;

		case VerifySymbolsModeWithSQLServer2:
			m_fVerifySymbolsModeWithSQLServer2 = fState;
			break;

		case BuildSymbolTreeMode:
			m_fSymbolTreeToBuildMode = fState;
			break;

		case OutputCSVFileMode:
			m_fOutputCSVFileMode = fState;
			break;

		case OutputDiscrepanciesOnly:
			m_fOutputDiscrepanciesOnly = fState;
			break;

		case OverwriteOutputFileMode:
			m_fOverwriteOutputFileMode = fState;
			break;

		case InputCSVFileMode:
			m_fInputCSVFileMode = fState;
			break;

		case ExceptionMonitorMode:
			m_fExceptionMonitorMode = fState;
			break;
	}

	return fState;
}

bool CProgramOptions::GetMode(enum ProgramModes mode)
{
	switch (mode)
	{
		case HelpMode:
			return m_fHelpMode;

		case SimpleHelpMode:
			return m_fSimpleHelpMode;

		case InputProcessesFromLiveSystemMode:
			return m_fInputProcessesFromLiveSystemMode;

		case InputDriversFromLiveSystemMode:
			return m_fInputDriversFromLiveSystemMode;

		case InputProcessesWithMatchingNameOrPID:
			return m_fInputProcessesWithMatchingNameOrPID;

		case MatchModuleMode:
			return m_fMatchModuleMode;

		case InputModulesDataFromFileSystemMode:
			return m_fInputModulesDataFromFileSystemMode;

		case InputDmpFileMode:
			return m_fInputDmpFileMode;

		case BuildSymbolTreeMode:
			return m_fSymbolTreeToBuildMode;
		
		case PrintTaskListMode:
			return m_fPrintTaskListMode;
		
		case QuietMode:
			return m_fQuietMode;

		case OutputSymbolInformationMode:
			return m_fOutputSymbolInformationMode;
		
		case CollectVersionInfoMode:
			return m_fCollectVersionInfoMode;
		
		case VerifySymbolsMode:
			return m_fVerifySymbolsMode;

		case VerifySymbolsModeWithSymbolPath:
			return m_fVerifySymbolsModeWithSymbolPath;

		case VerifySymbolsModeWithSymbolPathOnly:
			return m_fVerifySymbolsModeWithSymbolPathOnly;

		case VerifySymbolsModeWithSymbolPathRecursion:
			return m_fVerifySymbolsModeWithSymbolPathRecursion;

		case VerifySymbolsModeUsingDBGInMISCSection:
			return m_fVerifySymbolsModeUsingDBGInMISCSection;

		case VerifySymbolsModeWithSQLServer:
			return m_fVerifySymbolsModeWithSQLServer;
		
		case VerifySymbolsModeWithSQLServer2:
			return m_fVerifySymbolsModeWithSQLServer2;
		
		case OutputCSVFileMode:
			return m_fOutputCSVFileMode;

		case OutputDiscrepanciesOnly:
			return m_fOutputDiscrepanciesOnly;
		
		case OverwriteOutputFileMode:
			return m_fOverwriteOutputFileMode;

		case InputCSVFileMode:
			return m_fInputCSVFileMode;

		case ExceptionMonitorMode:
			return m_fExceptionMonitorMode;
	}

	// Should never get here...
#ifdef _DEBUG
	_tprintf(TEXT("ERROR! GetMode() - Unknown mode provided! %d"), mode);
#endif
	return false;
}

bool CProgramOptions::SetProcessID(DWORD iPID)
{
	m_iProcessID = iPID;
	return true;
}

bool CProgramOptions::ProcessCommandLineArguments(int argc, TCHAR *argv[])
{
	// Skip past the executible filename
	DWORD PID = 0;	// Process ID if specified
	int iArgumentNumber = 1;

	if (argc == 1)
	{
		// We'll now set some defaults
		SetMode(InputProcessesFromLiveSystemMode, true);
		SetMode(CollectVersionInfoMode, true);
		SetMode(VerifySymbolsMode, true);
		SetMode(VerifySymbolsModeWithSymbolPath, true);
		SetMode(OutputSymbolInformationMode, true);
		return true;
	}
	
	// Iterate through the arguments...
	while (iArgumentNumber < argc)
	{
#ifdef _DEBUG
		_tprintf(TEXT("Arg%d = %s\n"), iArgumentNumber+1, argv[iArgumentNumber]);
#endif
		if (argv[iArgumentNumber][0] == _T('-') || argv[iArgumentNumber][0] == _T('/'))
		{
			// Look for string matches first!
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("MATCH")) == 0)
			{
				// Get MATCH argument (the module to match against)
#ifdef _DEBUG
				_tprintf(TEXT("MATCH argument provided!\n"));
#endif
				iArgumentNumber++;

				if (iArgumentNumber < argc)
				{
					m_tszModuleToMatch = CUtilityFunctions::CopyString(argv[iArgumentNumber]);

					// Let's force upper-case matches for simplicity
					_tcsupr(m_tszModuleToMatch);
					
					if (!m_tszModuleToMatch)
						return false;

					SetMode(MatchModuleMode, true);
#ifdef _DEBUG
					_tprintf(TEXT("Module to match set to [%s]\n"), m_tszModuleToMatch);
#endif
				}
				else
				{ 
					_tprintf(TEXT("\nArgument Missing!  -MATCH option requires module to match against!\n"));
					// Not enough arguments...
					return false;
				}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("SQL2")) == 0)
			{
				// Get the SQL2 server name
#ifdef _DEBUG
				_tprintf(TEXT("SQL2 Server name provided!\n"));
#endif
				iArgumentNumber++;

				if (iArgumentNumber < argc)
				{
					m_tszSQLServer2 = CUtilityFunctions::CopyString(argv[iArgumentNumber]);
					if (!m_tszSQLServer2)
						return false;

					SetMode(VerifySymbolsMode, true);
					SetMode(VerifySymbolsModeWithSQLServer2, true);
#ifdef _DEBUG
					_tprintf(TEXT("SQL2 Server set to [%s]\n"), m_tszSQLServer2);
#endif
				}
				else
				{ 
					_tprintf(TEXT("\nArgument Missing!  -SQL2 option requires SQL Server Name value!\n"));
					// Not enough arguments...
					return false;
				}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("SQL")) == 0)
			{
				// Get the SQL server name
#ifdef _DEBUG
					_tprintf(TEXT("SQL Server name provided!\n"));
#endif
					iArgumentNumber++;

					if (iArgumentNumber < argc)
					{
						m_tszSQLServer = CUtilityFunctions::CopyString(argv[iArgumentNumber]);

						if (!m_tszSQLServer)
							return false;

						SetMode(VerifySymbolsMode, true);
						SetMode(VerifySymbolsModeWithSQLServer, true);
#ifdef _DEBUG
						_tprintf(TEXT("SQL Server set to [%s]\n"), m_tszSQLServer);
#endif
					}
					else
					{ 
						_tprintf(TEXT("\nArgument Missing!  -SQL option requires SQL Server Name value!\n"));
						// Not enough arguments...
						return false;
					}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("DEBUG")) == 0)
			{
				// Okay, we have the DEBUG switch... see what Debug Level is requested
				iArgumentNumber++;

				if (iArgumentNumber < argc)
				{
					// Save away the Debug Level
					m_dwDebugLevel = _ttoi(argv[iArgumentNumber]);
				}
				else
				{ 
					_tprintf(TEXT("\nArgument Missing!  -DEBUG option requires Debug Level!\n"));
					// Not enough arguments...
					return false;
				}
			} else
			if ( _tcsicmp(&argv[iArgumentNumber][1], TEXT("???")) == 0)
			{
				SetMode(HelpMode, true);
				return true;
			} else

			{
				// We found a command directive..
				switch (argv[iArgumentNumber][1])
				{
					case _T('?'):
					case _T('h'):
					case _T('H'):
						SetMode(SimpleHelpMode, true);
						iArgumentNumber = argc;
						return true;

					case _T('t'):
					case _T('T'):
						SetMode(PrintTaskListMode, true);
						SetMode(InputProcessesFromLiveSystemMode, true);
						break;

					case _T('s'):
					case _T('S'):
						SetMode(OutputSymbolInformationMode, true);
						break;

					case _T('i'):
					case _T('I'):
#ifdef _DEBUG
						_tprintf(TEXT("Input File path provided\n"));
#endif
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							m_tszInputCSVFilePath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);

							SetMode(InputCSVFileMode, true);
						}
						else
						{   // Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -I option requires an input file!\n"));
							return false;
						}
						break;

						// This special version supports a new mode...
					case _T('e'):
					case _T('E'):
						SetMode(ExceptionMonitorMode, true);
						break;

					case _T('o'):
					case _T('O'):
						// Check to see if they want to overwrite the file if it exists?
						if (argv[iArgumentNumber][2])
						{
							if ( 2 == _ttoi(&argv[iArgumentNumber][2]) )
							{
#ifdef _DEBUG
								_tprintf(TEXT("Overwrite Mode enabled!\n"));
#endif
								SetMode(OverwriteOutputFileMode, true);
							}
						}

#ifdef _DEBUG
						_tprintf(TEXT("Output File path provided\n"));
#endif
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							m_tszOutputCSVFilePath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
#ifdef _DEBUG
							_tprintf(TEXT("Output File Path set to [%s]\n"), GetOutputFilePath());
#endif
							// Enable OutputCSVFileMode
							SetMode(OutputCSVFileMode, true);
						}
						else
						{   // Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -O option requires an output file!\n"));
							return false;
						}
						break;

					case _T('q'):
					case _T('Q'):

						// Check to see if they only want to suppress matches?
						if (argv[iArgumentNumber][2])
						{
							if ( 2 == _ttoi(&argv[iArgumentNumber][2]) )
							{
								SetMode(OutputDiscrepanciesOnly, true);
							} else
							{
								SetMode(QuietMode, true);
							}
						} else
						{
							SetMode(QuietMode, true);
						}
						break;

					case _T('r'):
					case _T('R'):
						SetMode(CollectVersionInfoMode, true);
						break;
					
					case _T('v'):
					case _T('V'):

						SetMode(VerifySymbolsMode, true);

						if (argv[iArgumentNumber][2])
						{
							m_iVerificationLevel = _ttoi(&argv[iArgumentNumber][2]);

							if (m_iVerificationLevel == 0)
							{
								SetMode(HelpMode, true);
								iArgumentNumber = argc;
							}
						}
						break;

					case _T('f'):
					case _T('F'):
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							m_tszInputModulesDataFromFileSystemPath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							if (VerifySemiColonSeparatedPath(m_tszInputModulesDataFromFileSystemPath))
							{
								SetMode(InputModulesDataFromFileSystemMode, true);
							}
							else
							{
								_tprintf(TEXT("\nFile Path specified to search is too long\n"));
								return false;
							}

						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -F option requires a directory/file path!\n"));
							return false;
						}
						break;

					case _T('b'):
					case _T('B'):
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							SetMode(BuildSymbolTreeMode, true);

							// Okay, we have some string gymnastics below because we
							// want to expand any environment variables, and ensure
							// that we have a backslash appended...
							TCHAR tszPathBuffer[_MAX_PATH];
							LPTSTR tszExpandedPathBuffer = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							_tcscpy(tszPathBuffer, tszExpandedPathBuffer);
							delete [] tszExpandedPathBuffer;

							int cbLength = _tcsclen(tszPathBuffer);

							if (cbLength && tszPathBuffer[cbLength-1] != '\\')
							{
								_tcscat(tszPathBuffer, TEXT("\\"));
							}

							m_tszSymbolTreeToBuild = CUtilityFunctions::CopyString(tszPathBuffer);

							if (!m_tszSymbolTreeToBuild)
								return false;

							if (VerifySemiColonSeparatedPath(m_tszSymbolTreeToBuild))
							{
#ifdef _DEBUG
								_tprintf(TEXT("Building a Symbol Path Requested at [%s]\n"), m_tszSymbolTreeToBuild);
#endif
							}
							else
							{
								_tprintf(TEXT("\nPath provided to build symbol path is too long!\n"));
								return false;
							}

						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -B option requires a directory symbol path\n"));
							return false;
						}
						break;

					case _T('p'):
					case _T('P'):
#ifdef _DEBUG
						_tprintf(TEXT("Specific Process name (or PID) requested\n"));
#endif
						iArgumentNumber++;

						// Do we have another argument (we should)...
						if (iArgumentNumber < argc)
						{
							// Well... we know that we have been asked to query processes...
							SetMode(InputProcessesFromLiveSystemMode, true);
							
							// Is the next argument a number?  (Process ID)?
							if ((PID = _ttoi(argv[iArgumentNumber])) == 0)
							{ 
								// Process name provided!
#ifdef _DEBUG
								_tprintf(TEXT("Process name: [%s]\n"), argv[iArgumentNumber]);
#endif
								// Hey, wild-card matches everything... did they give us something else?
								if (*argv[iArgumentNumber] != '*') 
								{
									// Set Process Name, only if * isn't used.
									// Leaving process name == NULL is our clue
									// to dump all processes
									m_tszProcessName = CUtilityFunctions::CopyString(argv[iArgumentNumber]);
									if (!m_tszProcessName)
										return false;

									_tcsupr(m_tszProcessName);
									SetMode(InputProcessesWithMatchingNameOrPID, true);
								}

							} else
							{ // PID provided?
#ifdef _DEBUG
								_tprintf(TEXT("Process ID: [%d]\n"), PID);
#endif
								SetProcessID(PID);
								SetMode(InputProcessesWithMatchingNameOrPID, true);
							}
						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -P option requires *, a Process ID, or a Process Name!\n"));
							return false;
						}

						break;

					case _T('d'):
					case _T('D'):
						// Do we have another argument (we should)...
						// Well... we know that we have been asked to query device drivers...
						SetMode(InputDriversFromLiveSystemMode, true);

						break;

					case _T('y'):
					case _T('Y'):
#ifdef _DEBUG
						_tprintf(TEXT("Symbol path provided\n"));
#endif
						// Check to see if they want some flavor of symbol searching...
						if (argv[iArgumentNumber][2])
						{
							DWORD dwSymbolPathSearchOptions = _ttoi(&argv[iArgumentNumber][2]);

							if (dwSymbolPathSearchOptions & enumSymbolPathOnly)
							{
#ifdef _DEBUG
								_tprintf(TEXT("Symbol Path Searching ONLY mode enabled!\n"));
#endif
								SetMode(VerifySymbolsModeWithSymbolPathOnly, true);
							}

							if (dwSymbolPathSearchOptions & enumSymbolPathRecursion)
							{
#ifdef _DEBUG
								_tprintf(TEXT("Recursive Symbol Searching Mode enabled!\n"));
#endif
								SetMode(VerifySymbolsModeWithSymbolPathRecursion, true);
							}

							if (dwSymbolPathSearchOptions & enumSymbolsModeUsingDBGInMISCSection)
							{
								_tprintf(TEXT("Verify Symbols Using DBG files found in MISC Section of PE Image!\n"));

								SetMode(VerifySymbolsModeUsingDBGInMISCSection, true);
							}
						}
						iArgumentNumber++;

						if (iArgumentNumber < argc)
						{
							if (m_tszSymbolPath)
								delete [] m_tszSymbolPath;

							m_tszSymbolPath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							if (VerifySemiColonSeparatedPath(m_tszSymbolPath))
							{
								SetMode(VerifySymbolsModeWithSymbolPath, true);
#ifdef _DEBUG
								_tprintf(TEXT("Symbol Path set to [%s]\n"), GetSymbolPath());
#endif
							}
							else
							{
								_tprintf(TEXT("\nBad Symbol Path Provided!  Multiple paths are semi-colon delimited!\n"));
								return false;
							}
						}
						else
						{ 
							// Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -Y option requires a symbol path!\n"));
							return false;
						}
						break;

					case _T('z'):
					case _T('Z'):
#ifdef _DEBUG
						_tprintf(TEXT("DMP file provided!\n"));
#endif
						iArgumentNumber++;
						if (iArgumentNumber < argc)
						{
							m_tszInputDmpFilePath = CUtilityFunctions::ExpandPath(argv[iArgumentNumber]);
							
							SetMode(InputDmpFileMode, true);

#ifdef _DEBUG
							_tprintf(TEXT("Dmp File Path set to [%s]\n"), GetDmpFilePath());
#endif
						}
						else
						{   // Not enough arguments...
							_tprintf(TEXT("\nArgument Missing!  -DMP option requires a DMP file!\n"));
							return false;
						}
						break;

					default:
						_tprintf(TEXT("\nUnknown command specified! [%s]\n"), argv[iArgumentNumber]);
						iArgumentNumber = argc;
						return false;
				}
			}
		} else
		{
			_tprintf(TEXT("\nUnknown option specified! [%s]\n"), argv[iArgumentNumber]);
			return false;
		}

		// Increment to the next argument...
		iArgumentNumber++;
	}

	if ( !GetMode(InputCSVFileMode) && 
		 !GetMode(InputProcessesFromLiveSystemMode) &&
		 !GetMode(InputDriversFromLiveSystemMode) &&
		 !GetMode(InputModulesDataFromFileSystemMode) &&
		 !GetMode(InputDmpFileMode) )
	{
		_tprintf(TEXT("\nAt least one input method must be specified!\n"));
		return false;
	}

	// If the user provided both a -I and a -P option, then silently ignore querying locally
	// for active processes... this will leave the possibility, however, of matching on
	// process ID or process name in the -I data...
	if ( GetMode(InputCSVFileMode) && ( GetMode(InputProcessesFromLiveSystemMode)))
	{
		SetMode(InputProcessesFromLiveSystemMode, false);
	}

	// Ensure that the input and output files aren't the same...
	if ( GetMode(InputCSVFileMode) && GetMode(OutputCSVFileMode) )
	{
		if (_tcscmp(m_tszInputCSVFilePath, m_tszOutputCSVFilePath) == 0)
		{
			_tprintf(TEXT("\nInput file and output file must be different!\n"));
			return false;
		}
	}

	// Now... enforce any overrides as necessary...
	// Inspect commandline options (for changes to these defaults)
	if ( GetMode(PrintTaskListMode) )
	{
		// Task list mode requires that you obtain process data, and print it...
		SetMode(InputProcessesFromLiveSystemMode, true);
		SetMode(QuietMode, false);
		SetMode(CollectVersionInfoMode, false);
		SetMode(VerifySymbolsModeWithSymbolPath, false);
		SetMode(InputCSVFileMode, false);
		SetMode(OutputCSVFileMode, false); 
		SetMode(OutputSymbolInformationMode, false);
	}

	// We can't build a symbol tree without verifying symbols...
	if ( GetMode(BuildSymbolTreeMode) && !GetMode(VerifySymbolsMode) )
	{
		SetMode(VerifySymbolsMode, true);
	}

/*
	// If we're verifying, and we're not reading from a CSV file,
	// then we should go ahead and collect symbol information (since we'll need it).
	if ( GetMode(VerifySymbolsMode) && 
		!GetMode(InputCSVFileMode) )
	{
		SetMode(OutputSymbolInformationMode, true);
	}
*/

	// If we're reading a dump file, we should collect symbol information (and we do not
	// want to read from a CSV file at the same time...
	if ( GetMode(InputDmpFileMode) )
	{
//		SetMode(OutputSymbolInformationMode, true);
		SetMode(InputCSVFileMode, false);
	}

	// If we've enabled Symbol Verification, then we default to VerifySymbolsModeWithSymbolPath
	// if neither method were specified...
	if ( GetMode(VerifySymbolsMode) && 
		!GetMode(VerifySymbolsModeWithSymbolPath)  &&
		!GetMode(VerifySymbolsModeWithSQLServer) )
	{
		SetMode(VerifySymbolsModeWithSymbolPath, true);
	}

	return true;
}


bool CProgramOptions::VerifySemiColonSeparatedPath(LPTSTR tszPath)
{
	enum { MAX_PATH_ELEMENT_LENGTH = MAX_PATH-12 }; // We append \SYMBOLS\EXT to the end of the symbol path
	if (!tszPath)
		return false;

	TCHAR chTemp;
	int iLength;
	LPTSTR tszPointerToDelimiter;
	LPTSTR tszStartOfPathElement = tszPath;
	tszPointerToDelimiter = _tcschr(tszStartOfPathElement, ';');

	if (tszPointerToDelimiter == NULL)
	{
		iLength = _tcslen(tszStartOfPathElement);
#ifdef DEBUG
		_tprintf(TEXT("DEBUG: Path provided = %s\n"), tszStartOfPathElement);
		_tprintf(TEXT("DEBUG: Path length = %d\n"), iLength);
#endif
		return ( iLength <= MAX_PATH_ELEMENT_LENGTH ); 
	}

	while (tszPointerToDelimiter)
	{
		// Okay, we found a delimiter
		chTemp = *tszPointerToDelimiter;	// Save the char away...
		*tszPointerToDelimiter = '\0';		// Null terminate the path element

		iLength = _tcslen(tszStartOfPathElement);

#ifdef DEBUG
		_tprintf(TEXT("DEBUG: Path provided = %s\n"), tszStartOfPathElement);
		_tprintf(TEXT("DEBUG: Path length = %d\n"), iLength);
#endif
		if( iLength > MAX_PATH_ELEMENT_LENGTH )
		{
			_tprintf(TEXT("Path is too long for element [%s]\n"), tszStartOfPathElement);
			*tszPointerToDelimiter = chTemp;
			return false;
		}

		*tszPointerToDelimiter = chTemp;	// Restore the char...

		tszStartOfPathElement = CharNext(tszPointerToDelimiter); // Set new start of path element

		tszPointerToDelimiter = _tcschr(tszStartOfPathElement, ';'); // Look for next delimiter

	}
	
	// We will always have some part left to look at...
	iLength = _tcslen(tszStartOfPathElement);

#ifdef DEBUG
	_tprintf(TEXT("DEBUG: Path provided = %s\n"), tszStartOfPathElement);
	_tprintf(TEXT("DEBUG: Path length = %d\n"), iLength);
#endif

	return ( iLength <= MAX_PATH_ELEMENT_LENGTH );
}

bool CProgramOptions::fDoesModuleMatchOurSearch(LPCTSTR tszModulePathToTest)
{
	// If "-MATCH" was specified, look to see if this filename meets our criteria
	if (!GetMode(MatchModuleMode))
		return true;

	TCHAR tszTestBuffer[_MAX_PATH];

	// Before we copy to our string
	if (_tcslen(tszModulePathToTest) > _MAX_PATH)
		return false;

	// Copy to a read/write buffer...
	_tcscpy(tszTestBuffer, tszModulePathToTest);

	// Upper case for our test...
	_tcsupr(tszTestBuffer);

	return (_tcsstr(tszTestBuffer, GetModuleToMatch()) != NULL);
}

bool CProgramOptions::DisplayProgramArguments()
{
	if (GetMode(QuietMode) || GetMode(PrintTaskListMode))
		return false;

	CUtilityFunctions::OutputLineOfStars();
#ifdef _UNICODE
	_tprintf(TEXT("CHECKSYM V%S - Symbol Verification Program                                  \n"), VERSION_FILEVERSIONSTRING);
#else
	_tprintf(TEXT("CHECKSYM V%s - Symbol Verification Program                                  \n"), VERSION_FILEVERSIONSTRING);
#endif
	CUtilityFunctions::OutputLineOfStars();

	_tprintf(TEXT("\n***** COLLECTION OPTIONS *****\n"));
	
	// INPUT - FIRST, IF WE'RE LOOKING FOR LOCAL PROCESS DATA ON THIS MACHINE!
	if (GetMode(InputProcessesFromLiveSystemMode))
	{
		_tprintf(TEXT("\nCollect Information From Running Processes\n"));

		if (!GetMode(InputProcessesWithMatchingNameOrPID))
		{
			_tprintf(TEXT("\t-P *\t\t(Query all local processes)\n"));
		} else if (m_tszProcessName)
		{
			_tprintf(TEXT("\t-P %s\t\t(Query for specific process by name)\n"), m_tszProcessName);
		} else
		{
			_tprintf(TEXT("\t-P %d\t\t(Query for specific process ID)\n"), GetProcessID());
		}
	}

	if (GetMode(InputDriversFromLiveSystemMode))
	{
		_tprintf(TEXT("\t-D\t\t(Query all local device drivers)\n"));
	}
	// INPUT - SECOND, IF WE'RE SCAVENGING ON THE LOCAL FILE SYSTEM...
	if (GetMode(InputModulesDataFromFileSystemMode))
	{
		_tprintf(TEXT("\nCollect Information From File(s) Specified by the User\n"));
		_tprintf(TEXT("\t-F %s\n"), m_tszInputModulesDataFromFileSystemPath);
	}

	// INPUT - THIRD, CSV FILE
	if (GetMode(InputCSVFileMode))
	{
		_tprintf(TEXT("\nCollect Information from a Saved Checksym Generated CSV File\n"));
		_tprintf(TEXT("\t-I %s\n"), m_tszInputCSVFilePath);
	}

	// INPUT - FOURTH, DMP FILE
	if (GetMode(InputDmpFileMode))
	{
		_tprintf(TEXT("\nCollect Information from a User.Dmp or Memory.Dmp File\n"));
		_tprintf(TEXT("\t-Z %s\n"), m_tszInputDmpFilePath);
	}

	// MATCH - OPTIONS?
	if (GetMode(MatchModuleMode))
	{
		_tprintf(TEXT("\n***** MATCHING OPTIONS *****\n"));
		_tprintf(TEXT("\n"));
		_tprintf(TEXT("\nLook for Modules that Match the Provided Text\n"));
		_tprintf(TEXT("\t-MATCH %s\n"), m_tszModuleToMatch);
	}
	
	_tprintf(TEXT("\n***** INFORMATION CHECKING OPTIONS *****\n"));

	// INFO - FIRST, SYMBOL INFO
	if (GetMode(OutputSymbolInformationMode))
	{
		_tprintf(TEXT("\nOutput Symbol Information From Modules\n"));
		_tprintf(TEXT("\t-S\n"));
	}

	// INFO - FIRST, SYMBOL INFO
	if (GetMode(VerifySymbolsMode))
	{
		_tprintf(TEXT("\nVerify Symbols Locally Using Collected Symbol Information\n"));
		_tprintf(TEXT("\t-V\n"));
	}

	// INFO - SECOND, VERSION INFO
	if (GetMode(CollectVersionInfoMode))
	{
		_tprintf(TEXT("\nCollect Version and File-System Information From Modules\n"));
		_tprintf(TEXT("\t-R\n"));
	}

	// INFO - THIRD, VERIFY MODE (WITH SYMBOL PATH AND/OR SQL SERVER)
	if (GetMode(VerifySymbolsMode))
	{
		if (GetMode(VerifySymbolsModeWithSymbolPath))
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using Symbol Path\n"));
			_tprintf(TEXT("\t-Y %s\n"), m_tszSymbolPath);
		}

		if (GetMode(VerifySymbolsModeWithSQLServer))
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using SQL Server\n"));
			_tprintf(TEXT("\t-SQL %s\n"), m_tszSQLServer);
		}
		
		if (GetMode(VerifySymbolsModeWithSQLServer2))
		{
			_tprintf(TEXT("\nVerify Symbols for Modules Using SQL Server\n"));
			_tprintf(TEXT("\t-SQL2 %s\n"), m_tszSQLServer2);
		}
	}

	if (!GetMode(OutputSymbolInformationMode) &&
		!GetMode(CollectVersionInfoMode) &&
		!GetMode(VerifySymbolsMode)
	   )
	{
		_tprintf(TEXT("\nDump Module Paths\n"));
	}

	_tprintf(TEXT("\n***** OUTPUT OPTIONS *****\n"));

	if (!GetMode(QuietMode))
	{
		_tprintf(TEXT("\nOutput Results to STDOUT\n"));
	}

	if (GetMode(BuildSymbolTreeMode))
	{
		_tprintf(TEXT("\nBuild a Symbol Tree of Matching Symbols\n"));
		_tprintf(TEXT("\t-B %s\n"), m_tszSymbolTreeToBuild);
	}

	if (GetMode(OutputCSVFileMode))
	{
		if (GetMode(ExceptionMonitorMode))
		{
			_tprintf(TEXT("\nOutput Collected Module Information To a CSV File In Exception Monitor Format\n"));
		} else
		{
			_tprintf(TEXT("\nOutput Collected Module Information To a CSV File\n"));
		}

		_tprintf(TEXT("\t-O %s\n"), m_tszOutputCSVFilePath);
	}

	CUtilityFunctions::OutputLineOfDashes();
	return true;
}


void CProgramOptions::DisplayHelp()
{
	CUtilityFunctions::OutputLineOfStars();
#ifdef _UNICODE
	_tprintf(TEXT("CHECKSYM V%S - Symbol Verification Program                                  \n"), VERSION_FILEVERSIONSTRING);
#else
	_tprintf(TEXT("CHECKSYM V%s - Symbol Verification Program                                  \n"), VERSION_FILEVERSIONSTRING);
#endif
	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("\n"));
#ifdef _UNICODE
	_tprintf(TEXT("This version is supported for Windows NT 4.0 and Windows 2000\n"));
#else
	_tprintf(TEXT("This version is supported for Windows 98, Windows NT 4.0 and Windows 2000\n"));
#endif
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("DESCRIPTION:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("This program can be used to verify that you have proper symbol files\n"));
	_tprintf(TEXT("(*.DBG and/or *.PDB) on your system for the processes you have running, and\n"));
	_tprintf(TEXT("for symbol files on your filesystem.  This program can also be used to\n"));
	_tprintf(TEXT("collect information regarding these modules and output this to a file.\n"));
	_tprintf(TEXT("The output file can then be given to another party (Microsoft Product\n"));
	_tprintf(TEXT("Support Services) where they can use the file to verify that they have\n"));
	_tprintf(TEXT("proper symbols for debugging your environment.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Obtaining online help:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -?      : Simple help usage\n"));
	_tprintf(TEXT("CHECKSYM -???    : Complete help usage (this screen)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Usage:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM [COLLECTION OPTIONS] [INFORMATION CHECKING OPTIONS] [OUTPUT OPTIONS]\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** COLLECTION OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("At least one collection option must be specified.  The following options are\n"));
	_tprintf(TEXT("currently supported.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -P <Argument> : Collect Information From Running Processes\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   When used in conjunction with -O the output file will\n"));
	_tprintf(TEXT("                   contain information about your running system.  This\n"));
	_tprintf(TEXT("                   operation should not interfere with the operation of\n"));
	_tprintf(TEXT("                   running processes.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   <Argument> = [ * | Process ID (pid) | Process Name ]\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   To query all running processes, specify the wildcard\n"));
	_tprintf(TEXT("                   character '*'.  To specify a specific process, you can\n"));
	_tprintf(TEXT("                   provide the Process ID (as a decimal value), or the Process\n"));
	_tprintf(TEXT("                   Name (eg. notepad.exe).  If you use the Process Name as the\n"));
	_tprintf(TEXT("                   argument, and multiple instances of that process are\n"));
	_tprintf(TEXT("                   running they will all be inspected.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -D : Collect Information from Running Device Drivers\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will obtain information for all device drivers\n"));
	_tprintf(TEXT("                   (*.SYS files) running on the current system.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-F <File/Dir Path>:Collect Information From File(s) Specified by the User\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will allow you to obtain module information\n"));
	_tprintf(TEXT("                   for modules on the specified path.  Multiple paths may be\n"));
	_tprintf(TEXT("                   provided, separated by semicolons.  If the path provided is\n"));
	_tprintf(TEXT("                   a directory, then a recursive scan of files from that\n"));
	_tprintf(TEXT("                   directory will be used to obtain module information.  This\n"));
	_tprintf(TEXT("                   input method is useful for situations where the module(s) is\n"));
	_tprintf(TEXT("                   not loaded by an active process.  (Eg. Perhaps a process is\n"));
	_tprintf(TEXT("                   unable to start.)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("  -I <File Path> : Collect Information from a Saved Checksym Generated CSV File\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This input method is useful when you want to evaluate\n"));
	_tprintf(TEXT("                   whether you have proper symbols for modules on a different\n"));
	_tprintf(TEXT("                   system.  Most commonly this is useful for preparing to do a\n"));
	_tprintf(TEXT("                   remote debug of a remote system.  The use of -I prohibits\n"));
	_tprintf(TEXT("                   the use of other collection options.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("  -Z <File Path> : Collect Information from a DMP File\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This input method is useful when you have a DMP file and\n"));
	_tprintf(TEXT("                   to ensure that you have matching symbols for it.  Checksym\n"));
	_tprintf(TEXT("                   tries to determine as much information as possible to\n"));
	_tprintf(TEXT("                   in finding good symbols.  If a module name can not be\n"));
	_tprintf(TEXT("                   determined (mostly with modules that only use PDB files),\n"));
	_tprintf(TEXT("                   the module will be listed as \"IMAGE<Virtual Address>\".\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -MATCH <Text> : Collect Modules that match text only\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option allows you to restrict searching/collection to\n"));
	_tprintf(TEXT("                   include only those modules that match the provided text.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** INFORMATION CHECKING OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -S : Collect/Display Symbol Information From Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option is used to indicate that symbol information\n"));
	_tprintf(TEXT("                   should be collected and displayed from every module analyzed.\n"));
	_tprintf(TEXT("                   In order to verify proper symbols, symbol information must\n"));
	_tprintf(TEXT("                   be gathered.  It is possible to collect symbol information without\n"));
	_tprintf(TEXT("                   verifying it.  This case is usually used with the -O option\n"));
	_tprintf(TEXT("                   to produce a saved CheckSym generated CSV file.  Omitting\n"));
	_tprintf(TEXT("                   -S and -V could direct CheckSym to collect only version\n"));
	_tprintf(TEXT("                   information (if -R is specified), or no information (if\n"));
	_tprintf(TEXT("                   no information checking options are specified.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -R : Collect Version and File-System Information From Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option requests checksym to collect the following\n"));
	_tprintf(TEXT("                   information from the file-system and version information\n"));
	_tprintf(TEXT("                   structure (if any):\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                        File Version\n"));
	_tprintf(TEXT("                        Company Name\n"));
	_tprintf(TEXT("                        File Description\n"));
	_tprintf(TEXT("                        File Size (bytes)\n"));
	_tprintf(TEXT("                        File Date/Time\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT(" -V[<blank>|1|2] : Verify Symbols for Modules\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option uses the symbol information gathered (-S option)\n"));
	_tprintf(TEXT("                   to verify that proper symbols exist (as found along the\n"));
	_tprintf(TEXT("                   symbol path.  Use of -V implies -S when module collection is\n"));
	_tprintf(TEXT("                   initiated.  There are different levels of symbol\n"));
	_tprintf(TEXT("                   verification:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -V or -V1 : (Default) This treats symbol files that match\n"));
	_tprintf(TEXT("                               the module's time/date stamp, but have an wrong\n"));
	_tprintf(TEXT("                               checksum as valid symbols.  This is the default\n"));
	_tprintf(TEXT("                               behavior and these symbols are typically valid.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -V2       : Only if both checksum and time/date stamp match\n"));
	_tprintf(TEXT("                               is the symbol considered valid.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-Y[<blank>|1|2] <Symbol Path> : Verify Symbols Using This Symbol Path\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This is a semi-colon separated search path for looking for\n"));
	_tprintf(TEXT("                   symbols.  This path is searched with the -V option.  -Y now\n"));
	_tprintf(TEXT("                   supports the use of SYMSRV DLLs for symbol searching.  An\n"));
	_tprintf(TEXT("                   example usage would be a symbol path that resembles:\n"));
	_tprintf(TEXT("                   -Y SYMSRV*SYMSRV.DLL*\\\\SERVER\\SYMBOLS\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   The default value is %%systemroot%%\\symbols\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y or -Y1 : (Default) This searches for symbols in the\n"));
	_tprintf(TEXT("                               symbol paths using the behavior typical of the\n"));
	_tprintf(TEXT("                               debuggers.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Y2       : This searches for symbols in the symbol paths\n"));
	_tprintf(TEXT("                               provided using a recursive search algorithm.\n"));
	_tprintf(TEXT("                               This option is most useful when used with -B to\n"));
	_tprintf(TEXT("                               build a symbol tree.\n"));
	_tprintf(TEXT("\n"));
/*	
	// We're going to hide this option in the help text since this may go out to the public...

	_tprintf(TEXT("-SQL <servername>: Collect symbol file location from the provided SQL\n"));
	_tprintf(TEXT("                   servername.  A hardcoded username/password is currently\n"));
	_tprintf(TEXT("                   being used.  A SQL server you can point to is \"BPSYMBOLS\"\n"));
	_tprintf(TEXT("                   though this can change at anytime.\n"));
	_tprintf(TEXT("\n"));
*/
	_tprintf(TEXT("***** OUTPUT OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT(" -B <Symbol Dir> : Build a Symbol Tree of Matching Symbols\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   This option will create a new symbol tree for ALL matching\n"));
	_tprintf(TEXT("                   symbols that are found through the verification process\n"));
	_tprintf(TEXT("                   (-v option). This option is particularly useful when used\n"));
	_tprintf(TEXT("                   with the -Y option when many symbol paths are specified\n"));
	_tprintf(TEXT("                   and you want to build a single tree for a debug.\n"));
	
/*
	_tprintf(TEXT("                   with the -SQL option, or -Y option when many symbol paths\n"));
	_tprintf(TEXT("                   are specified and you want to build a single tree for a\n"));
	_tprintf(TEXT("                   debug.\n"));
*/
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -Q[<blank>|2] : Quiet modes (no screen output, or minimal screen output)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   The default behavior is to print out the data to the\n"));
	_tprintf(TEXT("                   console window (stdout).  If the process terminates with an\n"));
	_tprintf(TEXT("                   error, it will print out these (overriding -Q).\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -Q2       : This option prints out a module ONLY if a symbol\n"));
	_tprintf(TEXT("                               problem exists.  (Not completely quiet mode!)\n"));
/*
	// We're going to hide this option in the help text since this may go out to the public...
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -E : This modifier abreviates the output from this program\n"));
	_tprintf(TEXT("                   for the -O option.  It does the following:\n"));
	_tprintf(TEXT("                   * Removes the Checksym header\n"));
	_tprintf(TEXT("                   * Removes the first three columns of data\n"));
	_tprintf(TEXT("                   * Only prints out a module if there is a symbol verification problem\n"));
*/
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("-O[<blank>|1|2] <File Path> : Output Collected Module Information To a CSV File\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   For this file to to be used as input (-I) to verify good\n"));
	_tprintf(TEXT("                   symbols for this system, the -S option should also be used.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -O or -O1 : (Default)  This output mode requires that the\n"));
	_tprintf(TEXT("                               file does not exist.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   -O2       : Specifying a -O2 will allow the output file\n"));
	_tprintf(TEXT("                               to be OVERWRITTEN if it exists.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -T : Task List Output\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("                   Prints out a task list on the local machine (similar to the\n"));
	_tprintf(TEXT("                   TLIST utility).  This option implies the use of -P (querying\n"));
	_tprintf(TEXT("                   the local system for active processes.  You can provide the\n"));
	_tprintf(TEXT("                   -P command explicitly (if you want to provide an argument,\n"));
	_tprintf(TEXT("                   for instance).  If -P is not specified explicitly, then it\n"));
	_tprintf(TEXT("                   defaults to -P *.  Also, -T overrides -Q since TLIST\n"));
	_tprintf(TEXT("                   behavior is to print to the console window.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** TYPICAL USAGE EXAMPLES *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to verify the symbols for files in a directory (%%SYSTEMROOT%%\\SYSTEM32)\n"));
	_tprintf(TEXT("in the default symbol directory (%%SYSTEMROOT%%\\SYMBOLS)\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -F %%SYSTEMROOT%%\\SYSTEM32 -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to do the same search, but for only executables...\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -F %%SYSTEMROOT%%\\SYSTEM32\\*.EXE -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to search a directory using multiple symbol paths...\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -F %%SYSTEMROOT%%\\SYSTEM32\\ -V -Y V:\\nt40sp4;V:\\nt40rtm\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know what modules are loaded for a process (and the path to each)\n"));
	_tprintf(TEXT("Start NOTEPAD.EXE, and then type:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P NOTEPAD.EXE\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know if you have good symbols for a process (notepad.exe).\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P NOTEPAD.EXE -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know the file version for every module loaded by a process.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P NOTEPAD.EXE -R\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You want to know if you have good symbols for ALL processes on your machine.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P * -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** ADVANCED USAGE EXAMPLES *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("You are going to prepare to debug a remote system, and you want to ensure\n"));
	_tprintf(TEXT("that you have good symbols locally for debugging the remote system.  You want\n"));
	_tprintf(TEXT("to verify this prior to initiating the debug session.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Use checksym twice, once on the remote system to gather information and create\n"));
	_tprintf(TEXT("an output file, and then once on your system using the output file created\n"));
	_tprintf(TEXT("as an input argument.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("For example, run this on the remote system\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P * -S -R -O C:\\TEMP\\PROCESSES.CSV\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The C:\\TEMP\\PROCESSES.CSV file will contain a wealth of information about\n"));
	_tprintf(TEXT("the processes that were running, and the modules loaded by every process.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Now, get the output file from the remote system, and copy it locally.  Then\n\n"));
	_tprintf(TEXT("run CHECKSYM again, using the file as an input argument...\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -I C:\\TEMP\\PROCESSES.CSV -V\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Another useful option is -B (build a symbol tree).  It allows you to update\n"));
	_tprintf(TEXT("or create a symbol tree that contains matching symbols.  If you have to use\n"));
	_tprintf(TEXT("many symbol paths in order to have correct symbols available to a debugger,\n"));
	_tprintf(TEXT("can use the -B option to build a single symbol tree to simplify debugging.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("     CHECKSYM -P * -B C:\\MySymbols -V -Y V:\\Nt4;V:\\Nt4Sp6a;V:\\NtHotfixes\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** DEFAULT BEHAVIOR *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The default behavior of CHECKSYM when no arguments are provided is:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -P * -R -V -Y %%SYSTEMROOT%%\\SYMBOLS\n"));
}

void CProgramOptions::DisplaySimpleHelp()
{
	CUtilityFunctions::OutputLineOfStars();
#ifdef _UNICODE
	_tprintf(TEXT("CHECKSYM V%S - Symbol Verification Program                                  \n"), VERSION_FILEVERSIONSTRING);
#else
	_tprintf(TEXT("CHECKSYM V%s - Symbol Verification Program                                  \n"), VERSION_FILEVERSIONSTRING);
#endif
	CUtilityFunctions::OutputLineOfStars();
	_tprintf(TEXT("\n"));
#ifdef _UNICODE
	_tprintf(TEXT("This version supports Windows NT 4.0 and Windows 2000\n"));
#else
	_tprintf(TEXT("This version supports Windows 98, Windows NT 4.0 and Windows 2000\n"));
#endif
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Obtaining online help:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -?      : Simple help usage (this screen)\n"));
	_tprintf(TEXT("CHECKSYM -???    : Complete help usage\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("Usage:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM [COLLECTION OPTIONS] [INFORMATION CHECKING OPTIONS] [OUTPUT OPTIONS]\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** COLLECTION OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("At least one collection option must be specified.  The following options are\n"));
	_tprintf(TEXT("currently supported.\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("   -P <Argument> : Collect Information From Running Processes\n"));
	_tprintf(TEXT("              -D : Collect Information from Running Device Drivers\n"));
	_tprintf(TEXT("-F <File/Dir Path>:Collect Information From File(s) Specified by the User\n"));
	_tprintf(TEXT("  -I <File Path> : Collect Information from a Saved Checksym Generated CSV File\n"));
	_tprintf(TEXT("  -Z <File Path> : Collect Information from a DMP File\n"));
	_tprintf(TEXT("   -MATCH <Text> : Collect Modules that match text only\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** INFORMATION CHECKING OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -S : Collect Symbol Information From Modules\n"));
	_tprintf(TEXT("              -R : Collect Version and File-System Information From Modules\n"));
	_tprintf(TEXT(" -V[<blank>|1|2] : Verify Symbols for Modules\n"));
	_tprintf(TEXT(" -Y[<blank>|1|2] <Symbol Path> : Verify Symbols Using This Symbol Path\n"));

	_tprintf(TEXT("\n"));
/*	
	// We're going to hide this option in the help text since this may go out to the public...

	_tprintf(TEXT("-SQL <servername>: Collect symbol file location from the provided SQL\n"));
	_tprintf(TEXT("\n"));
*/
	_tprintf(TEXT("***** OUTPUT OPTIONS *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT(" -B <Symbol Dir> : Build a Symbol Tree of Matching Symbols\n"));
	_tprintf(TEXT("   -Q[<blank>|2] : Quiet modes (no screen output, or minimal screen output)\n"));
/*
	// We're going to hide this option in the help text since this may go out to the public...
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("              -E : This modifier abreviates the output from this program\n"));
*/
	_tprintf(TEXT("-O[<blank>|1|2] <File Path> : Output Collected Module Information To a CSV File\n"));
	_tprintf(TEXT("              -T : Task List Output\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("***** DEFAULT BEHAVIOR *****\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("The default behavior of CHECKSYM when no arguments are provided is:\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("CHECKSYM -P * -R -V -Y %%SYSTEMROOT%%\\SYMBOLS\n"));
	_tprintf(TEXT("\n"));
	_tprintf(TEXT("For more usage information run CHECKSYM -???\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\utilityfunctions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       utilityfunctions.cpp
//
//--------------------------------------------------------------------------

// UtilityFunctions.cpp: implementation of the CUtilityFunctions class.
//
//////////////////////////////////////////////////////////////////////

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>
#include <stdlib.h>

#include "Globals.h"
#include "UtilityFunctions.h"
#include "ModuleInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
typedef struct 
{
	LPTSTR tszEnvironmentVariable;
	LPTSTR tszRegistryKey;
	LPTSTR tszRegistryValue;
} ENVBLOCK;

ENVBLOCK g_tszEnvironmentVariables[] = 
	{
		// Support for Exchange Server
		TEXT("EXCHSRVR"),	
		TEXT("SOFTWARE\\Microsoft\\Exchange\\Setup"), 
		TEXT("Services"),
		
		// Support for SNA Server
		TEXT("SNASERVER"),
		TEXT("SOFTWARE\\Microsoft\\Sna Server\\CurrentVersion"),
		TEXT("PathName"),

		// Support for SQL Server
		TEXT("SQLSERVER"),
		TEXT("SOFTWARE\\Microsoft\\MSSQLServer\\Setup"),
		TEXT("SQLPath"),

		// Support for SMS Server
		TEXT("SMSSERVER"),
		TEXT("SOFTWARE\\Microsoft\\SMS\\Identification"),
		TEXT("Installation Directory"),

		// Support for INETSRV Server
		TEXT("INETSRV"),
		TEXT("SOFTWARE\\Microsoft\\INetStp"),
		TEXT("InstallPath"),

		// Support for WSPSRV Server
		TEXT("WSPSRV"),
		TEXT("SYSTEM\\CurrentControlSet\\Services\\WSPSrv\\Parameters"),
		TEXT("InstallRoot"),

		NULL,				
		NULL,											
		NULL
	};

CUtilityFunctions::CUtilityFunctions()
{
}

CUtilityFunctions::~CUtilityFunctions()
{
}

/*++
Function Name

	LPTSTR CUtilityFunctions::ExpandPath(LPCTSTR tszInputPath)

Routine Description:
	
	This routine copies the provided tszInputPath to a new
	buffer which is returned to the caller.  Any environment variables (or
	pseudo-environment variables) included in the tszInputPath are expanded
	before being copied to the destination string.
	
	This routine allocates storage for the return string, it is the responsibility
	of the caller to release it.

Arguments:
	
	[IN]		LPCTSTR tszInputString - Input string

Return Value:

	[OUT ]		LPTSTR	Returns the new string

--*/
LPTSTR CUtilityFunctions::ExpandPath(LPCTSTR tszInputPath)
{
	// Pointer to our input path buffer
	LPCTSTR ptszInputPathPointer;
    
	// Buffer to hold pre-translated Environment Variable
    TCHAR   tszEnvironmentVariableBuffer[MAX_PATH];

    // Buffer to hold translated environment variables
	TCHAR   tszTranslatedEnvironmentVariable[MAX_PATH];
	LPTSTR	ptszTranslatedEnvironmentVariablePointer;
    
	// Generic counter variable
	ULONG iCharIndex;

	// Buffer to hold Output Path
	LPTSTR  tszOutputPathBuffer, ptszOutputPathPointer;
	ULONG   iOutputPathBufferSize;

    if (!tszInputPath) {
        return(NULL);
    }

	// Setup our pointer to our input buffer
    ptszInputPathPointer = tszInputPath;

#ifdef _DEBUG
	// This puts stress on the re-alloc code...
	iOutputPathBufferSize = MAX_PATH; // We need less stress here (numega has probs)
#else
	iOutputPathBufferSize = _tcslen(tszInputPath) + MAX_PATH + 1;
#endif
	
	// Create our output buffer...
//#ifdef _DEBUG
//	_tprintf(TEXT("ExpandPath() - Output Buffer created\n"));
//#endif

    ptszOutputPathPointer = tszOutputPathBuffer = new TCHAR[iOutputPathBufferSize];

    if (!tszOutputPathBuffer) 
	{
        return(NULL);
    }

	DWORD iTranslatedCharacters = 0;

	// Loop through our input buffer until we're done...
    while( ptszInputPathPointer && *ptszInputPathPointer) 
	{
		// We're searching for % to designate the start of an env. var...
        if (*ptszInputPathPointer == '%') 
		{
            iCharIndex = 0;

			// Advance to just beyond the % character
            ptszInputPathPointer++;

			// While we have more environment variable chars...
            while (ptszInputPathPointer && *ptszInputPathPointer && *ptszInputPathPointer != '%') 
			{
				// Copy the environment variable into our buffer
                tszEnvironmentVariableBuffer[iCharIndex++] = *ptszInputPathPointer++;
            }

			// Advanced to just beyond the closing % character
            ptszInputPathPointer++;

			// Null terminate our Environment Variable Buffer
            tszEnvironmentVariableBuffer[iCharIndex] = '\0';

			// Setup the Translated Env. Variable Buffer
		    ptszTranslatedEnvironmentVariablePointer = tszTranslatedEnvironmentVariable;
            *ptszTranslatedEnvironmentVariablePointer = 0;

            // Translate the Environment Variables!
			iTranslatedCharacters = GetEnvironmentVariable( tszEnvironmentVariableBuffer, ptszTranslatedEnvironmentVariablePointer, MAX_PATH );
            
			// If we didn't translate anything... we need to look for this as a special env. variable...
			if (iTranslatedCharacters == 0)
			{

				bool fSpecialEnvironmentVariable = false;

				// Scan our special variables...
				for (int i = 0; g_tszEnvironmentVariables[i].tszEnvironmentVariable && !fSpecialEnvironmentVariable; i++)
				{
					if (!_tcsicmp(g_tszEnvironmentVariables[i].tszEnvironmentVariable,
						          tszEnvironmentVariableBuffer) )
					{
						// MATCHES!!!!

						HKEY hKey;
						DWORD lpType = 0;
						LONG Results = ERROR_SUCCESS;
						DWORD lpcbData = MAX_PATH;
						BYTE outBuf[MAX_PATH];

						Results = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
												g_tszEnvironmentVariables[i].tszRegistryKey,
												0,
												KEY_READ || KEY_QUERY_VALUE,
												&hKey);

						fSpecialEnvironmentVariable = (Results == ERROR_SUCCESS);

						if (Results != ERROR_SUCCESS)
						{
							_tprintf(TEXT("ERROR: Unable to open registry key [%s]\n"), g_tszEnvironmentVariables[i].tszRegistryKey);
							_tprintf(TEXT("ERROR: Unable to open registry key - Error = 0x%x\n"), Results);
						}

						if (fSpecialEnvironmentVariable)
						{
							// Now, read the value that has our install path...
							Results = RegQueryValueEx(
												hKey,	// handle of key to query 
												g_tszEnvironmentVariables[i].tszRegistryValue,	// address of name of value to query 
												NULL,					// reserved 
												&lpType,	// address of buffer for value type 
												outBuf,		// address of data buffer 
												&lpcbData); 	// address of data buffer size 

							// Is it still succesful?
							fSpecialEnvironmentVariable = ( (Results == ERROR_SUCCESS) && 
															(lpType == REG_SZ) );

							if (Results != ERROR_SUCCESS)
							{
								_tprintf(TEXT("ERROR: Registry key opened [%s]\n"), g_tszEnvironmentVariables[i].tszRegistryKey);
								_tprintf(TEXT("ERROR: Unable to query registry value [%s]\n"), g_tszEnvironmentVariables[i].tszRegistryValue);
								_tprintf(TEXT("ERROR: Unable to query registry value - Error = 0x%x\n"), Results);
							}
							// Copy only if we got something?
							RegCloseKey(hKey);
						}


						if (fSpecialEnvironmentVariable)
						{
							// Copy the new data!!!
							_tcscpy(tszTranslatedEnvironmentVariable, (LPTSTR)outBuf);
						}
					}

				}

				if (!fSpecialEnvironmentVariable)
				{
#ifdef _DEBUG
					_tprintf(TEXT("Unrecognized Environment variable found! [%%%s%%]\n"), tszEnvironmentVariableBuffer);
#endif
					// Error copy the original environment variable provided back to the "translated env
					// buffer to be copied back below...
					_tcscpy(tszTranslatedEnvironmentVariable, TEXT("%"));
					_tcscat(tszTranslatedEnvironmentVariable, tszEnvironmentVariableBuffer);
					_tcscat(tszTranslatedEnvironmentVariable, TEXT("%"));
				}
			}

			// Iterate through the Translated Env. Variable Buffer, and copy to the output buffer
			while (ptszTranslatedEnvironmentVariablePointer && *ptszTranslatedEnvironmentVariablePointer) 
			{
				// ISSUE-2000/07/24-GREGWI: Check to ensure this works properly *var++ changed to *(var++)
				// Copy a char
				*(ptszOutputPathPointer++) = *(ptszTranslatedEnvironmentVariablePointer++);

				// If our output buffer is full, we need to allocate a new buffer...
				if (ptszOutputPathPointer >= tszOutputPathBuffer + iOutputPathBufferSize) 
				{
					// Bump up our new size by MAX_PATH
					iOutputPathBufferSize += MAX_PATH;

					// We need to enlarge the buffer our string is in...
					tszOutputPathBuffer = ReAlloc(tszOutputPathBuffer, &ptszOutputPathPointer, iOutputPathBufferSize);

					if (tszOutputPathBuffer == NULL)
						return NULL;
				}
			}
        }

		// Probe to see if we're pointing at a NULL... this can happen if we've just completed
		// environment variable expansion...
		if ( *ptszInputPathPointer == '\0')
			continue;

		// Before we copy the char we're looking at... we need to test
		// for a trailing backslash (\) on the end (which we'll silently remove)...

		if ( (*ptszInputPathPointer == '\\') &&												  // Do we have a slash
			 ( (*(ptszInputPathPointer+1) == ';') || (*(ptszInputPathPointer+1) == '\0') ) && // and the next char is a NULL or semi-colon?
			 ( ptszInputPathPointer != tszInputPath ) &&							  // and we're not on the first char
			 (  *(ptszInputPathPointer-1) != ':' )											  // and the previous char is not a colon...
		   )
		{
			// Advance the pointer only... (remove the trailing slash)
			*(ptszInputPathPointer++);
		}
		else
		{
			// ISSUE-2000/07/24-GREGWI:  Ensure this works.. changing *var++ to *(var++)
			// Copy a char from the input path, to the output path
			*(ptszOutputPathPointer++) = *(ptszInputPathPointer++);
		}

		// If our output buffer is full, we need to allocate a new buffer...
		if (ptszOutputPathPointer >= tszOutputPathBuffer + iOutputPathBufferSize) 
		{
			// Bump up our new size by MAX_PATH
            iOutputPathBufferSize += MAX_PATH;

			// We need to enlarge the buffer our string is in...
			tszOutputPathBuffer = ReAlloc(tszOutputPathBuffer, &ptszOutputPathPointer, iOutputPathBufferSize);

			if (tszOutputPathBuffer == NULL)
				return NULL;
        }
    }

	// Null terminate our output buffer
    *ptszOutputPathPointer = '\0';

	// Return our results...
    return tszOutputPathBuffer;
}

bool CUtilityFunctions::ContainsWildCardCharacter(LPCTSTR tszPathToSearch)
{
	if (!tszPathToSearch)
		return false;

	LPCTSTR ptszPointer = tszPathToSearch;

	while (*ptszPointer)
	{
		switch (*ptszPointer)
		{
		case '*':
		case '?':
			return true;
		}

		ptszPointer++;
	}

	return false;
}

/*
bool CUtilityFunctions::IsDirectoryPath(LPCTSTR tszFilePath)
{
	if (!tszFilePath)
		return false;

	WIN32_FIND_DATA lpFindFileData;

	HANDLE hFileOrDirectory = FindFirstFile(tszFilePath, &lpFindFileData);

	if (INVALID_HANDLE_VALUE == hFileOrDirectory)
		return false;

	FindClose(hFileOrDirectory);
	
	if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		return true;

	return false;
}
*/

void CUtilityFunctions::PrintMessageString(DWORD dwMessageId)
{
	// Define a constant for our "private" buffer...
	enum {MESSAGE_BUFFER_SIZE = 1024};

	TCHAR tszMessageBuffer[MESSAGE_BUFFER_SIZE];

	DWORD dwBytes =	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
								  NULL,
								  dwMessageId,
								  0,
								  tszMessageBuffer,
								  MESSAGE_BUFFER_SIZE,
								  NULL);

	if (dwBytes)
	{
		// We got something!

		// Should we null terminate?
		if ( (dwBytes > 2)  &&
			 (tszMessageBuffer[dwBytes-2] == '\r') &&
			 (tszMessageBuffer[dwBytes-1] == '\n') )
		{
			tszMessageBuffer[dwBytes-2] = 0; // Null terminate this puppy...
		}

		_tprintf(TEXT("Error = %d (0x%x)\n[%s]\n"), dwMessageId, dwMessageId, tszMessageBuffer);
	}

}

bool CUtilityFunctions::CopySymbolFileToSymbolTree(LPCTSTR tszImageModuleName, LPTSTR * lplptszOriginalPathToSymbolFile, LPCTSTR tszSymbolTreePath)
{
	// Before we start to copying... is the source location already in the symbol tree we're going to build?
	int iLengthOfFileName = _tcslen(*lplptszOriginalPathToSymbolFile);
	int iLengthOfSymbolTreeToBuild = _tcslen(tszSymbolTreePath);

	if (_tcsnicmp(*lplptszOriginalPathToSymbolFile, 
				  tszSymbolTreePath, 
				  iLengthOfFileName < iLengthOfSymbolTreeToBuild ?
				  iLengthOfFileName : iLengthOfSymbolTreeToBuild) )
	{
		// Okay, we need to take the original module name, and get the extension...
		TCHAR tszExtension[_MAX_EXT];
		TCHAR tszPathToCopySymbolFileTo[_MAX_PATH];

		_tsplitpath(tszImageModuleName, NULL, NULL, NULL, tszExtension);
		_tcscpy( tszPathToCopySymbolFileTo, tszSymbolTreePath);

		// This directory should exist already... let's tag on the extension directory (if one exists)...
		if (_tcsclen(tszExtension) > 1)
		{
			// Copy the extension (skipping the period)
			_tcscat( tszPathToCopySymbolFileTo, &tszExtension[1] );
			_tcscat( tszPathToCopySymbolFileTo, TEXT("\\") );

			// Now, we need to ensure this directory exists (we'll cache these checks so we don't need to
			// keep checking the same directory over and over...
			if (!g_lpDelayLoad->MakeSureDirectoryPathExists(tszPathToCopySymbolFileTo) )
			{
				_tprintf(TEXT("ERROR: Unable to create symbol subdirectory [%s]\n"), tszPathToCopySymbolFileTo );
				PrintMessageString(GetLastError());
			}
		}

		TCHAR tszSymbolFileName[_MAX_FNAME];
		TCHAR tszSymbolFileExt[_MAX_EXT];

		_tsplitpath(*lplptszOriginalPathToSymbolFile, NULL, NULL, tszSymbolFileName, tszSymbolFileExt);

		// Okay... it's time to copy the file!!!
		_tcscat( tszPathToCopySymbolFileTo, tszSymbolFileName );
		_tcscat( tszPathToCopySymbolFileTo, tszSymbolFileExt );

		// We don't know if the destination file exists.. but if it does, we'll change
		// the attributes (to remove the read-only bit at least

		DWORD dwFileAttributes = GetFileAttributes(tszPathToCopySymbolFileTo);

		if (dwFileAttributes != 0xFFFFFFFF)
		{
			if (dwFileAttributes & FILE_ATTRIBUTE_READONLY)
			{
				// The read-only attribute is set... we must remove it...
				dwFileAttributes = dwFileAttributes & (~FILE_ATTRIBUTE_READONLY);
				SetFileAttributes(tszPathToCopySymbolFileTo, dwFileAttributes);
			}
		}

		if ( CopyFile(*lplptszOriginalPathToSymbolFile, tszPathToCopySymbolFileTo, FALSE) )
		{

			// Success!!!  Let's go ahead and give a visual indicator as to where we copied
			// the file from...
			_tprintf(TEXT("VERIFIED: [%s] copied to Symbol Tree\n"), *lplptszOriginalPathToSymbolFile);

			// Okay, since we've copied this to our symbol tree... we should update
			// our modulepath...
			
			// Nuke the old one...
			delete [] *lplptszOriginalPathToSymbolFile;

			// Copy in the new one...
			*lplptszOriginalPathToSymbolFile = CopyString(tszPathToCopySymbolFileTo);
			
			if (!*lplptszOriginalPathToSymbolFile)
				return false;
		} else
		{
			_tprintf(TEXT("ERROR: Unable to copy symbol file to [%s]\n"), tszPathToCopySymbolFileTo );
			PrintMessageString(GetLastError());
		}
	}

	return true;
}

/*++
Function Name

	LPTSTR CUtilityFunctions::CopyString(LPCTSTR tszInputString)

Routine Description:
	
	This routine copies the provided tszInputString to the destination address.
	This routine allocates storage for the string, it is the responsibility
	of the caller to release it.

Arguments:
	
	[IN]		LPCTSTR tszInputString - Input string

Return Value:

	Returns the new string

--*/
LPTSTR CUtilityFunctions::CopyString(LPCTSTR tszInputString)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	LPTSTR tszDestinationString = new TCHAR[(_tcsclen(tszInputString)+1)];

	if (!tszDestinationString )
		return NULL;

	_tcscpy(tszDestinationString, tszInputString);

	return tszDestinationString;
}

LPTSTR CUtilityFunctions::CopyAnsiStringToTSTR(LPCSTR szInputString, LPTSTR tszOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!szInputString)
		return NULL;

	if (iBufferLength && !tszOutputBuffer)
		return NULL;

	LPTSTR tszDestinationString;

#ifdef _UNICODE

	// Get the size of the source of the Ansi string...
	// Saving the value keeps MultiByteToWideChar from having to
	// calculate it twice...
	unsigned int cbMultiByte = strlen(szInputString);

	DWORD cbStringLength = MultiByteToWideChar(	CP_ACP,
												MB_PRECOMPOSED,
												szInputString,
												cbMultiByte,
												NULL,
												0);

	if (!cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		// Allocate storage
		tszDestinationString = new TCHAR[cbStringLength+1];

		if (!tszDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}
	
	// Do the actual conversion
	cbStringLength = MultiByteToWideChar(	CP_ACP,
											MB_PRECOMPOSED,
											szInputString,
											cbMultiByte,
											tszDestinationString,
											(iBufferLength == 0) ? cbStringLength+1 : iBufferLength);

	if (!cbStringLength)
		return NULL;

	tszDestinationString[cbStringLength] = '\0';

#else
	
	unsigned int cbMultiByte = strlen(szInputString);
	
	if (iBufferLength == 0)
	{
		iBufferLength = strlen(szInputString)+1;
		
		tszDestinationString = new TCHAR[iBufferLength];
		
		if (!tszDestinationString)
			return NULL;

	} else
	{
		if (cbMultiByte+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}

	strncpy(tszDestinationString, szInputString, iBufferLength);

#endif
	
	return tszDestinationString;

}

LPTSTR CUtilityFunctions::CopyUnicodeStringToTSTR(LPCWSTR wszInputString, LPTSTR tszOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!wszInputString)
		return NULL;

	// Check for proper buffers and lengths if provided...
	if (iBufferLength && !tszOutputBuffer)
		return NULL;

	LPTSTR tszDestinationString;

#ifdef _UNICODE

	unsigned int cbMultiByte = wcslen(wszInputString);

	if (iBufferLength == 0)
	{
		tszDestinationString = new TCHAR[wcslen(wszInputString)+1];
	
		if (!tszDestinationString)
			return NULL;
	} else
	{
		if (cbMultiByte+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}

	wcscpy(tszDestinationString, wszInputString);

#else
	
	int cchWideChar = wcslen(wszInputString);

	DWORD cbStringLength = WideCharToMultiByte( CP_ACP,
												0,
												wszInputString,
												cchWideChar,
												NULL,
												0,
												NULL,
												NULL);

	if (cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		tszDestinationString = new TCHAR[cbStringLength+1];

		if (!tszDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		tszDestinationString = tszOutputBuffer;
	}

	// Do the actual conversion...
	cbStringLength = WideCharToMultiByte(	CP_ACP, 
											0,
											wszInputString,
											cchWideChar,
											tszDestinationString,
											(iBufferLength == 0) ? cbStringLength+1 : iBufferLength,
										    NULL,
											NULL);

	if (!cbStringLength)
		return NULL;

	tszDestinationString[cbStringLength] = '\0';

#endif
	
	return tszDestinationString;
}

//
// CUtilityFunctions::CopyTSTRStringToAnsi()
//
// This routine copies from a TSTR source to an ANSI destination with optional allocation
// of the destination buffer... the default is to allocate storage, but if you provide
// a buffer length, we will assume it's available...
//

LPSTR CUtilityFunctions::CopyTSTRStringToAnsi(LPCTSTR tszInputString, LPSTR szOutputBuffer, unsigned int iBufferLength)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	if (iBufferLength && !szOutputBuffer)
		return NULL;

	LPSTR szDestinationString;

#ifdef _UNICODE

	// Get the size of the source of the Unicode string...
	// Saving the value keeps WideCharToMultiByte from having to
	// calculate it twice...
	unsigned int cchWideChar = wcslen(tszInputString);
	
	// This is a probe to see how much we'll be copying...
	DWORD	cbStringLength = WideCharToMultiByte(	CP_ACP,
													0,
													tszInputString,
													cchWideChar,
													NULL,
													0,
													NULL,
													NULL);
	if (!cbStringLength)
		return NULL;

	// Do we need to allocate storage???
	if (iBufferLength == 0)
	{
		// Allocate storage
		szDestinationString = new char[cbStringLength+1];

		if (!szDestinationString)
			return NULL;
	} else
	{
		if ( cbStringLength+1 > iBufferLength )
			return NULL;

		// Set the two strings to the same buffer...
		szDestinationString = szOutputBuffer;
	}
	
	// Do the actual conversion
	cbStringLength = WideCharToMultiByte(	CP_ACP, 
											0,
											tszInputString,
											cchWideChar,
											szDestinationString,
											(iBufferLength == 0) ? cbStringLength+1 : iBufferLength,
										    NULL,
											NULL);

	if (!cbStringLength)
		return NULL;

	szDestinationString[cbStringLength] = '\0';

#else

	unsigned int cchAnsiChar = strlen(tszInputString);
	
	if (iBufferLength == 0)
	{
		szDestinationString = new char[cchAnsiChar+1]; // One extra for the NULL

		if (!szDestinationString)
			return NULL;
	} else
	{
		if (cchAnsiChar+1 > iBufferLength)
			return NULL;

		// Set the two strings to the same buffer...
		szDestinationString = szOutputBuffer;
	}

	strcpy(szDestinationString, tszInputString);

#endif

	return szDestinationString;
}

LPWSTR CUtilityFunctions::CopyTSTRStringToUnicode(LPCTSTR tszInputString)
{
	// Did we get a proper input string?
	if (!tszInputString)
		return NULL;

	LPWSTR wszDestinationString;

#ifdef _UNICODE

	wszDestinationString = new TCHAR[wcslen(tszInputString)+1];
	
	if (!wszDestinationString)
		return NULL;

	wcscpy(wszDestinationString, tszInputString);

#else
	
	int cbMultiByte = strlen(tszInputString);

	DWORD cbStringLength = MultiByteToWideChar(	CP_ACP,
												MB_PRECOMPOSED,
												tszInputString,
												cbMultiByte,
												NULL,
												0);

	if (!cbStringLength)
		return NULL;

	wszDestinationString = new wchar_t[cbStringLength+1];

	if (!wszDestinationString)
		return NULL;

	cbStringLength = MultiByteToWideChar(	CP_ACP,
											MB_PRECOMPOSED,
											tszInputString,
											cbMultiByte,
											wszDestinationString,
											cbStringLength+1);

	wszDestinationString[cbStringLength] = '\0';

#endif
	
	return wszDestinationString;
}

/*++

  HANDLE CUtilityFunctions::FindDebugInfoFileEx2(
			[IN] LPTSTR tszFileName, 
			[IN] LPTSTR SymbolPath, 
			[IN] PFIND_DEBUG_FILE_CALLBACK Callback, 
			[IN] PVOID CallerData

Routine Description:

 The rules are, the name of the DBG/PDB file being searched for is provided,
 and when found the routine returns a file handle to it... if a callback is
 provided then the callback is invoked and a decision is made to return the
 file handle based on the callback response...

 Arguments:
    tszFileName - Supplies a symbol name to search for.
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

Return Value:

  The handle for the DBG/PDB file if any...
  In an effort to emulate FindDebugInfoFile(), this function will return 0 on failure or
  the handle to the file otherwise...

--*/

HANDLE CUtilityFunctions::FindDebugInfoFileEx2(LPTSTR tszFileName, LPTSTR SymbolPath, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData)
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
	bool fProcessPath = true;
	bool fScavengeSuccessful = false;

	LPTSTR tszSymbolPathStart, tszSymbolPathEnd;

	tszSymbolPathStart = SymbolPath;

	// Find the end of the path
	tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

	// If tszSymbolPathEnd is non-zero, then there is another path following...
	if (tszSymbolPathEnd) 
		*tszSymbolPathEnd = '\0'; // Change the ';' to a Null temporarily...
	
	while (fProcessPath)
	{
//#ifdef _DEBUG
//		_tprintf(TEXT("\n\nProcessing Path [%s]\n"), tszSymbolPathStart);
//#endif
		// Begin the "madness"... ;)

		// Search until we make a perfect hit... construct the directory path...
		TCHAR tszSymbolPath[_MAX_PATH];

		// Copy what we have...
		_tcscpy(tszSymbolPath, tszSymbolPathStart);

		// We should have at least a few chars to search on...
		if (_tcslen(tszSymbolPath) < 2)
		{
			// Repair the search string if needed...
			if (tszSymbolPathEnd) 
			{
				*tszSymbolPathEnd = ';';
			}
			break;
		};

		fScavengeSuccessful = ScavengeForSymbolFiles(tszSymbolPath, tszFileName, Callback, CallerData, &FileHandle, 1);

		// Repair the search string now!
		if (tszSymbolPathEnd) 
		{
			*tszSymbolPathEnd = ';';
		}

		// If were successful on our hunt or there is no symbol path left to search... break...
		if (fScavengeSuccessful || !tszSymbolPathEnd)
		{
			break;
		} else
		{
			// Advance to next string
			tszSymbolPathStart = tszSymbolPathEnd + 1;
				
			tszSymbolPathEnd = _tcschr( tszSymbolPathStart, ';' );

			if (tszSymbolPathEnd) 
			{
				*tszSymbolPathEnd = '\0';
			};
		}
	}

    return ( (FileHandle == INVALID_HANDLE_VALUE) ? 0 : FileHandle);
}

/*++

	bool CUtilityFunctions::ScavengeForSymbolFiles(
			[IN] LPCTSTR tszSymbolPathStart, 
			[IN] LPCTSTR tszSymbolToSearchFor, 
			[IN] PFIND_DEBUG_FILE_CALLBACK Callback, 
			[IN] PVOID CallerData, 
			[OUT] LPHANDLE lpFileHandle, 
			[IN] int iRecurseDepth )

Routine Description:

  This routine is used to perform a recursive search for a Symbol File
  (tszSymbolToSearchFor).  The routine will do a depth search, looking
  for the symbol at a current depth before going into sub-directories...
  If a Callback function is provided, then it will be invoked when the
  file we're looking for (by name) has been successfully opened.  It is
  unknown to this routine, however, if the file we found is actually the
  correct one... the callback function's responsibility is to perform this
  evaluation and return to use success/failure.  If failure (then we continue
  searching), if success (or no callback) then we return the filehandle
  associated with the file we found.

  It is the responsibility of the caller of this function to close any file
  handle returned.

 Arguments:
    tszSymbolPathStart - This is the directory to search
    tszSymbolToSearchFor - This is the symbol we're searching for
	Callback - May be NULL.  This is a function used to evaluate if the symbol found is correct.
	CallerData - May be NULL.  This data is passed to the callback (it is typically a CModuleInfo *)
	lpfileHandle - This is the file handle for the file found (if any)
	iRecurseDepth - This is the current depth of our search (defaults to 0)

Return Value:

  The handle for the DBG/PDB file if any...

--*/
bool CUtilityFunctions::ScavengeForSymbolFiles(LPCTSTR tszSymbolPathStart, LPCTSTR tszSymbolToSearchFor, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData, LPHANDLE lpFileHandle, int iRecurseDepth )
{
	bool fSuccess = false;

	// Bale if we're in too deep...
	if (iRecurseDepth > MAX_RECURSE_DEPTH)
		return fSuccess;

	TCHAR tszFileBuffer[MAX_PATH+1];

	//
	// First, we'll look to see if we can open the file we're looking for AT this directory location
	//
	_tcscpy(tszFileBuffer, tszSymbolPathStart);
	if (tszFileBuffer[_tcslen(tszFileBuffer)] != '\\') // Do we need a backslash separator?
		_tcscat(tszFileBuffer, TEXT("\\"));
	_tcscat(tszFileBuffer, tszSymbolToSearchFor);

	if (g_lpProgramOptions->fDebugSearchPaths())
	{
		_tprintf(TEXT("DBG/PDB Search - Search here [%s]\n"), tszFileBuffer);
	}

	// Attempt to open the file...
    *lpFileHandle = CreateFile( tszFileBuffer,
								GENERIC_READ,
								(FILE_SHARE_READ | FILE_SHARE_WRITE),
								NULL,
								OPEN_EXISTING,
								0,
								NULL
								);

	// Did we open it?
	if (*lpFileHandle != INVALID_HANDLE_VALUE)
	{
		// Yes!

		// If no callback... then we need to exit on out...
		if (!Callback)
		{
			// Assume success (well... we found a symbol file you asked for)
			fSuccess = true;
		} else
		{
				fSuccess = (TRUE == Callback(*lpFileHandle, tszFileBuffer, CallerData));
		}

		// Return from here only on success!
		if (fSuccess)
			return fSuccess;
	}

	// We either did NOT find the file, or we found a file but it was not the right one...
    
	//
	// Second, we search for sub-directories, invoking this function for each sub-dir we find...
	//
	TCHAR drive[_MAX_DRIVE];
	TCHAR dir[_MAX_DIR];
	TCHAR fname[_MAX_FNAME];
	TCHAR ext[_MAX_EXT];

	//
	// Compose the path to search...
	//
	_tcscpy(tszFileBuffer, tszSymbolPathStart);
	
	if (tszFileBuffer[_tcslen(tszFileBuffer)-1] != '\\') // Do we need a backslash separator?
		_tcscat(tszFileBuffer, TEXT("\\"));

	_tcscat(tszFileBuffer, TEXT("*.*"));

	// We want the component parts for later (so we can compose the full path)
	_tsplitpath(tszFileBuffer, drive, dir, fname, ext);

	WIN32_FIND_DATA lpFindFileData;

	// Okay, begin the search...
	HANDLE hFileOrDirectoryHandle = FindFirstFile(tszFileBuffer, &lpFindFileData);

	while ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
	{
		if (lpFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			// Check to see if we've got the . or .. directories!
			if ( ( 0 == _tcscmp(lpFindFileData.cFileName, TEXT(".")) ) ||
				 ( 0 == _tcscmp(lpFindFileData.cFileName, TEXT("..")) )
			   )
			{
					goto getnextmodule;
			}

			// Compose the path to the directory...
			_tmakepath(tszFileBuffer, drive, dir, NULL, NULL);
			_tcscat(tszFileBuffer, lpFindFileData.cFileName);

			// Look to see if we can find the file we're after!
			fSuccess = ScavengeForSymbolFiles(tszFileBuffer, tszSymbolToSearchFor, Callback, CallerData, lpFileHandle, iRecurseDepth+1 );

			// On success from ScavengeForSymbolFiles, we have a file handle (hopefully the right one).
			// We want to terminate our recursive search
			if (fSuccess)
				break;
		};

getnextmodule:

		if (!FindNextFile(hFileOrDirectoryHandle, &lpFindFileData))
			break;
	}

	if ( INVALID_HANDLE_VALUE != hFileOrDirectoryHandle )
		FindClose(hFileOrDirectoryHandle);

	return fSuccess;
}

LPTSTR CUtilityFunctions::ReAlloc(LPTSTR tszOutputPathBuffer, LPTSTR * ptszOutputPathPointer, size_t size)
{
	// Save our old size... and position in the buffer...
	UINT iOldOutputPathBufferSize = (*ptszOutputPathPointer)-tszOutputPathBuffer;

	// Allocate our new bigger buffer...
	LPTSTR ptszNewOutputPathBuffer = new TCHAR[size];

	// Did we fail to allocate the new buffer?
	if (ptszNewOutputPathBuffer == NULL) 
		return(NULL);

#ifdef _DEBUG
	// This bogus code is here to protect a string copy which should always work...
	// but Numega Bounds Checker will sometimes AV in here... and we have to protect
	// ourselves or else it will appear we're leaking way above...
	__try 
	{
#endif

		// Now, we should copy from the old to the new buffer...
	_tcsncpy(ptszNewOutputPathBuffer, tszOutputPathBuffer, iOldOutputPathBufferSize);

#ifdef _DEBUG
    } __except(EXCEPTION_EXECUTE_HANDLER) 
	{
		_tprintf(TEXT("ReAlloc() - Exception Hit during stringcopy!!!\n"));
    }
#endif

	// Calculate our position in our new buffer
	*ptszOutputPathPointer = ptszNewOutputPathBuffer + iOldOutputPathBufferSize;

	// Delete the old buffer
	delete [] tszOutputPathBuffer;

	return ptszNewOutputPathBuffer;
}

bool CUtilityFunctions::UnMungePathIfNecessary(LPTSTR tszPossibleBizarrePath)
{
	/*
	// We have three known odd-ball cases...

		\SystemRoot\System32\smss.exe
		\??\C:\WINNT\system32\winlogon.exe
		\WINNT\System32\ntoskrnl.exe
	*/

	if (tszPossibleBizarrePath[0] != '\\')
		return false; // Isn't a bizarre path (one we know about anyway)...

	// Setup Variables to Use
	TCHAR tszTempPath[_MAX_PATH], tszExpandedSystemRoot[_MAX_PATH];

	const TCHAR tszSystemRoot[] = TEXT("\\SystemRoot");
	const unsigned int iSystemRootLength = _tcslen(tszSystemRoot);

	const TCHAR tszNameSpace[] = TEXT("\\??\\");
	const unsigned int iNameSpaceLength = _tcslen(tszNameSpace);

	ExpandEnvironmentStrings(TEXT("%systemroot%"), tszExpandedSystemRoot, _MAX_PATH);
	const unsigned int iExpandedSystemRoot = _tcslen(tszExpandedSystemRoot);

/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path found!  [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	if ( _tcsnicmp(tszPossibleBizarrePath, tszSystemRoot, iSystemRootLength) == 0)
	{ // We have a match...
/*
#ifdef _DEBUG
	_tprintf(TEXT("Matches [%s] sequence...\n"), tszSystemRoot);
#endif
*/
		// We simply replace \systemroot with %systemroot% and expand the
		// environement variables
		LPTSTR tszPointer = tszPossibleBizarrePath;

		for (unsigned int i = 0; i < iSystemRootLength; i++)
		{
			// Advance by the name space length...
			tszPointer = CharNext(tszPointer);
		}

		_tcscpy(tszTempPath, TEXT("%systemroot%"));
		_tcscat(tszTempPath, tszPointer);
		
		ExpandEnvironmentStrings(tszTempPath, tszPossibleBizarrePath, _MAX_PATH);
/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path changed to [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	} else
	if (_tcsnicmp(tszPossibleBizarrePath, tszNameSpace, iNameSpaceLength) == 0)
	{ // We have a match...
/*
#ifdef _DEBUG
	_tprintf(TEXT("Matches [%s] sequence...\n"), tszNameSpace);
#endif
*/
		// We simply remove the \??\ sequence from the namespace...
		LPTSTR tszPointer = tszPossibleBizarrePath;

		for (unsigned int i = 0; i < iNameSpaceLength; i++)
		{
			// Advance by the name space length...
			tszPointer = CharNext(tszPointer);
		}

		// We have to do this double copy since the strings would overlap
		_tcscpy(tszTempPath, tszPointer);
		_tcscpy(tszPossibleBizarrePath, tszTempPath);

/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path changed to [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	} else
	if (( iExpandedSystemRoot > 2) && _tcsnicmp(tszPossibleBizarrePath, &tszExpandedSystemRoot[2], iExpandedSystemRoot-2) == 0)
	{ // We need to match on the SystemRoot (without the SystemDrive)
/*
#ifdef _DEBUG
	_tprintf(TEXT("Matches [%s] sequence...\n"), tszSystemRoot);
#endif
*/
		// This little algorithm assumes that the Drive Letter is a single char...
		_tcscpy(tszTempPath, tszExpandedSystemRoot);
		_tcscat(tszTempPath, &tszPossibleBizarrePath[iExpandedSystemRoot-2]);
		_tcscpy(tszPossibleBizarrePath, tszTempPath);
/*
#ifdef _DEBUG
	_tprintf(TEXT("Bizarre module path changed to [%s]\n"), tszPossibleBizarrePath);
#endif
*/
	}
	return true;
}


bool CUtilityFunctions::FixupDeviceDriverPathIfNecessary(LPTSTR tszPossibleBaseDeviceDriverName, unsigned int iBufferLength)
{
    TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];

	// First, split the device driver name up into it's component parts...
	_tsplitpath(tszPossibleBaseDeviceDriverName, drive, dir, fname, ext);

	// Second, look to see if it's missing the drive and dir...
	if ( _tcsicmp(drive, TEXT("")) || _tcsicmp(dir, TEXT("")) )
		return true;

	// Third, create a new path... assuming that we'll find device drivers in the %systemroot%\system32\drivers directory
	TCHAR tszTempBuffer[_MAX_PATH];

	_tcscpy(tszTempBuffer, TEXT("%systemroot%\\system32\\drivers\\"));
	_tcscat(tszTempBuffer, tszPossibleBaseDeviceDriverName);

	ExpandEnvironmentStrings(tszTempBuffer, tszPossibleBaseDeviceDriverName, iBufferLength);

	return true;
}

// This function is provided in a Windows 2000 (NT 5.0) Version of IMAGEHLP.DLL.  By adding
// this function manually, I should run fine on NT 4.0 (and possibly Win9x)
/*++

Routine Description:

 The rules are:
  if Filename doesn't have a .dbg extension
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     2. <SymbolPath>\Symbols\<ext>\<filename>.sym
     3. <SymbolPath>\<ext>\<filename>.dbg
     4. <SymbolPath>\<ext>\<filename>.sym
     5. <SymbolPath>\<filename>.dbg
     6. <SymbolPath>\<filename>.sym
     7. <FileNamePath>\<filename>.dbg
     8. <FileNamePath>\<filename>.sym
  if it does, skip the .sym lookup.

Arguments:
    tszFileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

Return Value:

  The name of the Symbol file (either .dbg or .sym) and a handle to that file.

--*/

HANDLE CUtilityFunctions::FindDebugInfoFileEx(LPTSTR tszFileName, LPTSTR SymbolPath, LPTSTR DebugFilePath, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData)
{

    return fnFindDebugInfoFileEx(tszFileName,
                                 SymbolPath,
                                 DebugFilePath,
                                 Callback,
                                 CallerData,
                                 0);
}

/*++

Routine Description:

 The rules are:
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     3. <SymbolPath>\<ext>\<filename>.dbg
     5. <SymbolPath>\<filename>.dbg
     7. <FileNamePath>\<filename>.dbg

Arguments:
    tszFileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file 
is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if 
the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

    Flag - indicates that PDBs shouldn't be searched for

Return Value:

  The name of the Symbol file (either .dbg or .sym) and a handle to that file.

--*/
HANDLE 
CUtilityFunctions::fnFindDebugInfoFileEx(
    IN  LPTSTR tszFileName,
    IN  LPTSTR SymbolPath,
    OUT LPTSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData,
    IN  DWORD flag
    )
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    LPTSTR ExpSymbolPath = NULL, SymPathStart, PathEnd;
    DWORD ShareAttributes, cnt;
    LPTSTR InitialPath = NULL, Sub1 = NULL, Sub2 = NULL;
    TCHAR FilePath[_MAX_PATH + 1];
    TCHAR Drive[_MAX_DRIVE], Dir[_MAX_DIR], FilePart[_MAX_FNAME], Ext[_MAX_EXT];
    TCHAR *ExtDir;

    BOOL  found = FALSE;
    BOOL  symsrv = TRUE;

	bool fDebugSearchPaths = g_lpProgramOptions->fDebugSearchPaths();

    //if (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) 
	if (g_lpProgramOptions->IsRunningWindowsNT()) 
    {
        ShareAttributes = (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE);
    } else {
        ShareAttributes = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    __try {
        *DebugFilePath = '\0';

        // Step 1.  What do we have?
        _tsplitpath(tszFileName, Drive, Dir, FilePart, Ext);

        if (!_tcsicmp(Ext, TEXT(".dbg"))) {
            // We got a filename of the form: ext\filename.dbg.  Dir holds the extension already.
            ExtDir = Dir;
        } else {
            // Otherwise, skip the period and null out the Dir.
            ExtDir = CharNext(Ext);
        }

        ExpSymbolPath = ExpandPath(SymbolPath);
        SymPathStart = ExpSymbolPath;
        cnt = 0;

        do {
	
			PathEnd = _tcschr( SymPathStart, ';' );

            if (PathEnd) {
                *PathEnd = '\0';
            }

            if (!_tcsnicmp(SymPathStart, TEXT("SYMSRV*"), 7)) {

                *DebugFilePath = 0;
                if (symsrv && CallerData) 
				{
                    _tcscpy(FilePath, FilePart);
                    _tcscat(FilePath, TEXT(".dbg"));
                    
					CModuleInfo * lpModuleInfo = (CModuleInfo *)CallerData;

					if (fDebugSearchPaths)
					{
						_tprintf(TEXT("DBG Search - SYMSRV [%s,0x%x,0x%x]\n"),
								 SymPathStart, 
								 lpModuleInfo->GetPEImageTimeDateStamp(),
								 lpModuleInfo->GetPEImageSizeOfImage());
					}
					
                    GetSymbolFileFromServer(SymPathStart,
                                            FilePath,
                                            lpModuleInfo->GetPEImageTimeDateStamp(),
                                            lpModuleInfo->GetPEImageSizeOfImage(),
                                            0,
                                            DebugFilePath);

                    symsrv = FALSE;
                }

            } else {

                switch (cnt) {

                case 0: // <SymbolPath>\symbols\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = TEXT("symbols");
                    Sub2 = ExtDir;
                    break;

                case 1: // <SymbolPath>\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = TEXT("");
                    Sub2 = ExtDir;
                    break;

                case 2: // <SymbolPath>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = TEXT("");
                    Sub2 = TEXT("");
                    break;

                case 3: // <FileNamePath>\<filename>.ext - A.K.A. what was passed to us
                    InitialPath = Drive;
                    Sub1 = TEXT("");
                    Sub2 = Dir;
                    // this stops us from checking out everything in the sympath
                    cnt++;
                    break;
                }

               // build fully-qualified filepath to look for

                _tcscpy(FilePath, InitialPath);
                EnsureTrailingBackslash(FilePath);
                _tcscat(FilePath, Sub1);
                EnsureTrailingBackslash(FilePath);
                _tcscat(FilePath, Sub2);
                EnsureTrailingBackslash(FilePath);
                _tcscat(FilePath, FilePart);

                _tcscpy(DebugFilePath, FilePath);
                _tcscat(DebugFilePath, TEXT(".dbg"));
            }

            // try to open the file

            if (*DebugFilePath) {
//#ifdef _DEBUG            
//                _tprintf(TEXT("FindDebugInfoFileEx-> Looking for %s... "), DebugFilePath);
//#endif                
				if (fDebugSearchPaths)
				{
					_tprintf(TEXT("DBG Search - Search here [%s]\n"), DebugFilePath);
				}
                FileHandle = CreateFile(DebugFilePath,
                                        GENERIC_READ,
                                        ShareAttributes,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL);

                // if the file opens, bail from this loop

                if (FileHandle != INVALID_HANDLE_VALUE) 
                {
                    found = TRUE;

                    // If a callback exists... call it...
                    if (!Callback) 
                    {
                        break;
                    } else if (Callback(FileHandle, DebugFilePath, CallerData)) 
					{
                        break;
                    } else {
//#ifdef _DEBUG            
//                      _tprintf(TEXT("mismatched timestamp\n"));
//#endif
						CloseHandle(FileHandle);
                        FileHandle = INVALID_HANDLE_VALUE;
                    }
                }
                // if file is open, bail from this loop too - else continue
                if (FileHandle != INVALID_HANDLE_VALUE)
                    break;
            }

            // go to next item in the sympath

            if (PathEnd) {
                *PathEnd = ';';
                SymPathStart = PathEnd + 1;
                symsrv = TRUE;
            } else {
                SymPathStart = ExpSymbolPath;
                cnt++;
            }
        } while (cnt < 4);

    } __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(FileHandle);
        }
        
        FileHandle = INVALID_HANDLE_VALUE;
    }

	if (ExpSymbolPath) 
	{
        delete [] ExpSymbolPath;
		ExpSymbolPath = NULL;
    }

    if (FileHandle == INVALID_HANDLE_VALUE) 
    {
        FileHandle = NULL;
        DebugFilePath[0] = '\0';
    }
    
    if (!FileHandle                 // if we didn't get the right file...
        && found                    // but we found some file...
        && (flag & fdifRECURSIVE))  // and we were told to run recursively...
    {
        // try again without timestamp checking
        FileHandle = fnFindDebugInfoFileEx(tszFileName,
                                           SymbolPath,
                                           FilePath,
                                           NULL,
                                           0,
                                           flag);
        if (FileHandle && FileHandle != INVALID_HANDLE_VALUE)
           _tcscpy(DebugFilePath, FilePath);
    }

    return FileHandle;
}

void
CUtilityFunctions::EnsureTrailingBackslash(
    LPTSTR tsz
    )
{
    int i;

    i = _tcslen(tsz);
    if (!i)
        return;

    if (tsz[i - 1] == '\\')
        return;

    tsz[i] = '\\';
    tsz[i + 1] = '\0';
}

bool CUtilityFunctions::GetSymbolFileFromServer(
    LPCTSTR tszServerInfo, 
    LPCTSTR tszFileName, 
    DWORD  num1,
    DWORD  num2,
    DWORD  num3,
    LPTSTR tszFilePath
    )
{
	TCHAR	tszSrvName[_MAX_PATH * 2];
    LPTSTR  tszParams;
    bool rc = false;

    LPSTR szParams = NULL;
    char szFilePath[_MAX_PATH+1]; // Temporary file buffer (for returned data)
    LPSTR szFileName = NULL; 

	// It's a little extra work... but let's extract the SYMSRV DLL name
	// so we can see if we're already loaded (by name)..

	// Copy the new server name in...
	_tcscpy(tszSrvName, &tszServerInfo[7]);
	
	if (!(*tszSrvName))
		goto cleanup;

	// Parameters start after the separator
	tszParams =	_tcschr(tszSrvName, '*');

	if (!tszParams)
		goto cleanup;
		
	// Null terminate and advance...
	*(tszParams++) = '\0';

    // Determine if this SYMSRV compatible DLL is the same
	// as the one we have loaded already... (if one is loaded)

	if( !g_lpDelayLoad->GetCurrentSymSrvDLL() || 
		_tcscmp(g_lpDelayLoad->GetCurrentSymSrvDLL(), tszSrvName))
	{
		if (!g_lpDelayLoad->Initialize_SYMSRV(tszSrvName))
			goto cleanup;
	}

    tszParams = _tcschr(tszServerInfo, '*');
    
	if (!tszParams)
		goto cleanup;
    
	tszParams = _tcschr(tszParams+1, '*');
    
	if (!tszParams)
		goto cleanup;

	// Ready to make the call... need to convert to lame ANSI for the function call...
	szParams = CopyTSTRStringToAnsi(tszParams+1);
	szFileName = CopyTSTRStringToAnsi(tszFileName);

	rc = (TRUE == g_lpDelayLoad->SymbolServer(szParams, szFileName, num1, num2, num3, szFilePath));

	if (rc)
	{
		tszFilePath = CopyAnsiStringToTSTR(szFilePath, tszFilePath, _MAX_PATH+1);
	}

cleanup:

	if (szParams)
		delete [] szParams;

	if (szFileName)
		delete [] szFileName;
		
    return rc;
}

//
// Taken from UTF8.CPP (from the VC Linker code)
// 

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)
#define LOWER_6_BIT(u)        ((u) & 0x003f)
#define HIGH_SURROGATE_START  0xd800
#define LOW_SURROGATE_START   0xdc00

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////
size_t CUtilityFunctions::UTF8ToUnicode(
    LPCSTR lpSrcStr,
    LPWSTR lpDestStr,
    size_t cchDest)
{
    return UTF8ToUnicodeCch(lpSrcStr, strlen(lpSrcStr) + 1, lpDestStr, cchDest);
}

#pragma warning( push )
#pragma warning( disable : 4244 )		// conversion from 'int' to 'unsigned short', possible loss of data

size_t CUtilityFunctions::UTF8ToUnicodeCch(
    LPCSTR lpSrcStr,
    size_t cchSrc,
    LPWSTR lpDestStr,
    size_t cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    size_t cchWC = 0;              // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar = 0;         // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest &&  cchSrc != (size_t)-1)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }

    //
    //  Return the number of Unicode characters written.
    //
    return cchWC;
}

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\utilityfunctions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       utilityfunctions.h
//
//--------------------------------------------------------------------------

// UtilityFunctions.h: interface for the CUtilityFunctions class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UTILITYFUNCTIONS_H__C97C8493_D457_11D2_845B_0010A4F1B732__INCLUDED_)
#define AFX_UTILITYFUNCTIONS_H__C97C8493_D457_11D2_845B_0010A4F1B732__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif /* NO_STRICT */

#include <WINDOWS.H>
#include <STDIO.H>
#include <TCHAR.H>

#define fdifRECURSIVE   0x1

class CUtilityFunctions  
{
public:
	static LPWSTR CopyTSTRStringToUnicode(LPCTSTR tszInputString);
	static LPSTR  CopyTSTRStringToAnsi(LPCTSTR tszInputString, LPSTR szOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPTSTR CopyUnicodeStringToTSTR(LPCWSTR wszInputString, LPTSTR tszOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPTSTR CopyAnsiStringToTSTR(LPCSTR szInputString, LPTSTR tszOutputBuffer = NULL, unsigned int iBufferLength = 0);
	static LPTSTR CopyString(LPCTSTR tszInputString);
	static size_t UTF8ToUnicode(LPCSTR lpSrcStr, LPWSTR lpDestStr, size_t cchDest);
	static size_t UTF8ToUnicodeCch(LPCSTR lpSrcStr, size_t cchSrc, LPWSTR lpDestStr, size_t cchDest);

	CUtilityFunctions();
	virtual ~CUtilityFunctions();

	static LPTSTR ExpandPath(LPCTSTR lpPath);
	static bool UnMungePathIfNecessary(LPTSTR tszPossibleBizarrePath);
	static bool FixupDeviceDriverPathIfNecessary(LPTSTR tszPossibleBaseDeviceDriverName, unsigned int iBufferLength);
	static bool ContainsWildCardCharacter(LPCTSTR tszPathToSearch);
	static bool CopySymbolFileToSymbolTree(LPCTSTR tszImageModuleName, LPTSTR * lplptszOriginalPathToSymbolFile, LPCTSTR tszSymbolTreePath);
//	static bool IsDirectoryPath(LPCTSTR tszFilePath);
	static void PrintMessageString(DWORD dwMessageId);

	// Define the callback method for FindDebugInfoFileEx()
	typedef BOOL (*PFIND_DEBUG_FILE_CALLBACK)(HANDLE FileHandle, LPTSTR tszFileName, PVOID CallerData);
	static HANDLE FindDebugInfoFileEx(LPTSTR tszFileName, LPTSTR SymbolPath, LPTSTR DebugFilePath, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData);
	static HANDLE fnFindDebugInfoFileEx(LPTSTR tszFileName, LPTSTR SymbolPath, LPTSTR DebugFilePath, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData, DWORD flag);
	static bool GetSymbolFileFromServer(LPCTSTR tszServerInfo, LPCTSTR tszFileName, DWORD num1, DWORD num2, DWORD num3, LPTSTR tszFilePath);

	static void EnsureTrailingBackslash(LPTSTR tsz);

    static HANDLE FindDebugInfoFileEx2(LPTSTR tszFileName, LPTSTR SymbolPath, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData);
	static bool   ScavengeForSymbolFiles(LPCTSTR tszSymbolPathStart, LPCTSTR tszSymbolToSearchFor, PFIND_DEBUG_FILE_CALLBACK Callback, PVOID CallerData, LPHANDLE lpFileHandle, int iRecurseDepth);

	// Output Assistance!
	static inline void OutputLineOfStars() {
		_tprintf(TEXT("*******************************************************************************\n"));
	};

	static inline void OutputLineOfDashes() {
		_tprintf(TEXT("-------------------------------------------------------------------------------\n"));
	};

protected:
	static LPTSTR ReAlloc(LPTSTR tszOutputPathBuffer, LPTSTR * ptszOutputPathPointer, size_t size);
	enum { MAX_RECURSE_DEPTH = 30 };
	static DWORD m_dwGetLastError;
};

#endif // !defined(AFX_UTILITYFUNCTIONS_H__C97C8493_D457_11D2_845B_0010A4F1B732__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\checksym\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Version Information

#define VERSION_FILEVERSION 		2,2,0,0
#define VERSION_FILEVERSIONSTRING 	"2.2.0\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\chksum\makefile.inc ===
$(O)\chkverfy.res: chkverfy.rc
$(O)\chksum.res: chksum.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\chmode\chmode.c ===
/* chmode - change mode/attribute of file
 *
 *   17-Apr-1986 daniel lipkie  add /R flag
 *   18-Jul-1986 daniel lipkie  add /N flag
 *   17-Jun-1987 bw  Hard-code '/' as switch char ( '-' conflicts with off )
 *   19-Oct-1990 w-barry Added forward function declaraions.
 *   27-Nov-1990 w-barry Began switch to Win32 API (including replacement of
 *                       getattr() with the Win32 equivalent.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tools.h>

#define ATTRLEN 8

flagType fSetAttr = FALSE;
flagType fRecurse = FALSE;
flagType fNondirOnly = FALSE;
char strPattern[MAX_PATH];
char strAttr[ATTRLEN];
DWORD maskOR  = FILE_ATTRIBUTE_NORMAL;
DWORD maskAND = 0xff;

// Forward Function Declartions...
void attr2str( char, char * );
void walkdir( char *, struct findType *, void * );
void walk( char *, struct findType *, void * );
int dochmode( char * );
void Usage( void );
int __cdecl main( int, char ** );


void
attr2str(
        char attr,
        char *pStr
        )
{
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_DIRECTORY ) ? 'd' : '-');
    *pStr++ = '-';
    *pStr++ = ' ';
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_HIDDEN ) ? 'H' : '-');
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_SYSTEM ) ? 'S' : '-');
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_ARCHIVE ) ? 'A' : '-');
    *pStr++ = (char)(HASATTR(attr, FILE_ATTRIBUTE_READONLY ) ? 'R' : '-');
    *pStr = '\0';
}


void
walkdir(
       char *p,
       struct findType *b,
       void *dummy
       )
{
    char *pBuf;

    if (!HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ||
        !strcmp (b->fbuf.cFileName, ".") || !strcmp (b->fbuf.cFileName, "..") ||
        (HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN) ||
         HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_SYSTEM)))
        /* do not enum "." and ".."
         * do not enum contents of non-directories
         * do not enum contents of hidden/system directories */
        return;
    if ((pBuf = malloc(MAX_PATH)) == NULL)
        return;
    strcpy(pBuf, p);
    if (!fPathChr((strend(pBuf))[-1]))
        strcat(pBuf, "\\");
    strcat(pBuf, strPattern);
    printf("subdirectory: %s\n", pBuf);
    dochmode(pBuf);
    free(pBuf);
}

void
walk (
     char *p,
     struct findType *b,
     void *dummy
     )
{
    if (TESTFLAG(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY) &&
        (!strcmp (b->fbuf.cFileName,".") || !strcmp (b->fbuf.cFileName, "..")))
        /* don't show mode of . and .. */
        return;

    if (fSetAttr) {
        if (TESTFLAG(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY) && fNondirOnly)
            /* Is a directory and /N flag so do NOT set attr */
            return;
        if (!SetFileAttributes(p, (b->fbuf.dwFileAttributes | maskOR) & maskAND) ) {
            attr2str( (char)((b->fbuf.dwFileAttributes | maskOR) & maskAND), strAttr);
            printf("error: attributes not set to %s  %s\n", strAttr, p);
        }
    } else {
        attr2str( (char)b->fbuf.dwFileAttributes, strAttr);
        printf("%s  %s\n", strAttr, p);
    }
    dummy;
}

int
dochmode(
        char *pstr
        )
{
    char *pBuf;

    if (!forfile (pstr, -1, walk, NULL))
        printf ("%s does not exist\n", pstr);
    if (fRecurse) {
        if ((pBuf = malloc(MAX_PATH)) == NULL)
            return( 0 );
        drive(pstr, pBuf);
        path(pstr, pBuf);
        /* do NOT append pathchar, we want to enum sub dir in this dir */
        strcat(pBuf, "*.*");
        forfile(pBuf, -1, walkdir, NULL);
        free(pBuf);
    }
    return 0;
}

void
Usage ()
{
    puts("Usage: CHMODE [/RN] {[-+][hsar]}+ {filespec}+\n"
         "    /R - Recurse to subdirectories\n"
         "    /N - Non-directory files only");
    exit( 1 );
}

int
__cdecl
main (
     int c,
     char *v[]
     )
{
    register char *p;
    char ch;
    DWORD attr;

    ConvertAppToOem( c, v );
    SHIFT (c,v);
    while (c > 0 && ((ch = *v[0]) == '-' || ch == '+' || ch == '/')) {
        p = *v;
        if (ch == '/') {
            while (*++p != '\0') {
                if (*p == 'R') {
                    fRecurse = TRUE;
                } else if (*p == 'N') {
                    fNondirOnly  = TRUE;
                } else {
                    Usage();
                }
            }
        } else {
            fSetAttr = TRUE;
            attr = 0;
            while (*++p != '\0')
                switch (*p) {
                    case 'h':
                        SETFLAG(attr, FILE_ATTRIBUTE_HIDDEN);
                        break;
                    case 's':
                        SETFLAG(attr, FILE_ATTRIBUTE_SYSTEM);
                        break;
                    case 'a':
                        SETFLAG(attr, FILE_ATTRIBUTE_ARCHIVE);
                        break;
                    case 'r':
                        SETFLAG(attr, FILE_ATTRIBUTE_READONLY);
                        break;
                    default:
                        Usage ();
                }
            if (ch == '+')
                SETFLAG(maskOR, attr);
            else
                RSETFLAG(maskAND, attr);
        }
        SHIFT(c,v);
    }

    if (c == 0) {
        if (fSetAttr) {
            /* if switches set then require filenames */
            Usage();
        } else {
            strcpy(strPattern, "*.*");
            dochmode("*.*");
        }
    } else while (c) {
            if (!fileext(*v, strPattern)) {
                strcpy(strPattern, "*.*");
            }
            dochmode(*v);
            SHIFT(c, v);
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\clearmem\clearmem.h ===
/*** clearmem.h- Public defines and structure definitions for cache flusher.
 *
 *
 * Title:
 *	Cache flusher include file used by all
 *
 *      Copyright (c) 1990, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Modification History:
 *	90.03.08 - RussBl -- Created
 *
 */



/* * * * * * * * *   N T   C o m m o n   D e f i n e s   * * * * * * * * * */

#define RC        NTSTATUS


/* * * * * * * *   C o m m o n   M i s c .   D e f i n e s   * * * * * * * */

// Runtime flags
//
// #define STATIC static   // This is defined so all the defined STATIC 
   #define STATIC          // functions can easily become non-static by        
                           // changing this define to "".  Remember that
                           // static functions are not visiable by the
			   // kernel debugger.

   #define RESERVED_NULL NULL // Reserved null fields

// #define CF_DEBUG_L1	   // Flag indicating display of debug info - Level1
                           // (Level 1:  Displays process/thread arguments
// #define CF_DEBUG_L2	   // Flag indicating display of debug info - Level2
                           // (Level 2:  Displays thread start/completion info
// #define CF_DEBUG_L3	   // Flag indicating display of debug info - Level3
			   // (Level 3:  Displays CF cycle states' info
// #define CF_DEBUG_L4	   // Flag indicating display of debug info - Level4
			   // (Level 4:  Displays CF cycle timing info



// User defined error codes
//
#define     LOGIC_ERR  0x7FFFFF01L  // Error code indicating logic error
                                    // is encountered
#define INPUTARGS_ERR  0x7FFFFF02L  // Error code for invalid number of
                                    // input arguments
#define   FILEARG_ERR  0x7FFFFF03L  // Error code for invalid input file
                                    // argument
#define   TIMEARG_ERR  0x7FFFFF04L  // Error code for invalid trail time
                                    // argument
#define  INSUFMEM_ERR  0x7FFFFF05L  // Error code indicating memory can't
                                    // be allocated by MALLOC/REALLOC
#define  MEANSDEV_ERR  0x7FFFFF06L  // Error code for invalid mean and/or
                                    // standard deviation
#define     FSEEK_ERR  0x7FFFFF07L  // Error code indicating fseek()
                                    // failure
#define    FCLOSE_ERR  0x7FFFFF08L  // Error code indicating fclose()
                                    // failure
#define    FFLUSH_ERR  0x7FFFFF09L  // Error code indicating fflush()
                                    // failure
#define     FOPEN_ERR  0x7FFFFF0AL  // Error code indicating fopen()
                                    // failure
#define  PRCSETUP_ERR  0x7FFFFF0BL  // Error code indicating error during
                                    // child process setup/initialization
#define  THDSETUP_ERR  0x7FFFFF0CL  // Error code indicating error during
				    // thread setup/initialization
#define  PROCINFO_ERR  0x7FFFFF0DL  // Error code indicating error during
				    // retrieval of process information
#define   SETWSET_ERR  0x7FFFFF0EL  // Error code indicating error during
				    // setting of working set information


// Maximu length defines
//
#define  FNAME_LEN		  256	// Maximum file name langth
#define   LINE_LEN                128   // Maximum input line length
#define  ULONG_LEN                 15   // Maximum length required to store
                                        // ULONG values in ASCII format
					// 10+1(null)=11

#define    ERR_NOFILE  0xFFFFFFFFL  // Failure from CreateFile

// String (EXEs & KEYs) constants
//
#define 	CF_EXE	     "CLEARMEM.EXE"	// CF's binary name


// Other defines
//

#define PAGESIZE		   4096    // Page size in bytes
#define SECTION_SIZE	   16*1024*1024L   // Size of data section for flushing
#define FLUSH_FILE_SIZE        256*1024L   // Size of flush file

// Next is max that cache will permit in WS at one time for each file,
// less 1 (or we reach into next private segment because of how we
// alternate read locations)

#define NUM_FLUSH_READS 	     63    // Number of pages to read:


#define LAZY_DELAY		   5000L   // Lazy Writer delay

#define NUM_FILES		      3    // Number of flush files

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\chksum\chkverfy.c ===
// Analyses the output from the new chkeckrel
// t-mhills

#include <direct.h>
#include <io.h>
#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define F_flag 1   //Values to store in the command line switches flag
#define I1_flag 2
#define I2_flag 4
#define X_flag 8

               // These codes should match the codes below in the usage description
#define par_err 6  //comand line parameter error exit code 5
#define exep_err 5 //error in the exception file
#define chk_err 4  //error in the one of the source files
#define mem_err 3  //memory allocation error
#define file_err 2 //file find/read error
#define comp_err 1 //comparison found differences
#define no_err 0   // files compared okay

#define exceptionfilelinelength 512  //These value used to control the size of temporary strings
#define chkfilelinelength 2048       //Ideally there would be no limit but file reads require static variables
#define maxpathlength 200

struct translatetable  //Used to store translate commands from the exception file.
{
  struct translatetable *next;
  char *source1name;
  char *source2name;
};

struct excludetable   //Used to store exclude commands from the exception file.
{
  struct excludetable *next;
  char *path;
};

struct checksums      //Used to store checksums with file names.
{
  struct checksums *next;
  long sum;
  char filename; // This structure is of variable length to accomodate any string length.
};

void error (char exitcode);                               //Ends program and returns exitcode to the system.

void showchecksumlist (struct checksums *list);           //Displays Checksums with filenames.

void showdualchecksumlist (struct checksums *list);       //Shows checksums in a format good for missmatched checksums.

char excluded (char *str, struct excludetable *ex);       //If any of the exclude strings are in str it returns true.

char *translate (char *str, struct translatetable *tran); //Make a copy of str with changes from exception file.

long readhex (char *str);                                 //Convert hex string to long.

char proccessline (char *tempstr, struct translatetable *translations, struct excludetable *exclusions,
                  char *startpath, char flags, char **filename, long *filesum);
                                                          //Parse line and apply all exceptions and flags

char loadsource1 (char *filename, struct checksums **sums,
                  struct translatetable *translations, struct excludetable * exclusions,
                  char *startpath, char flags);           //Load source1 into a checksum list.

char comparesource2 (char *filename, struct checksums **sums,
                     struct checksums **extrasource2, struct checksums **missmatched,
                     struct translatetable *translations, struct excludetable * exclusions,
                     char *startpath, char flags);        //Compare the second file to the checksum list.

void removewhitespace (char *str);                        //Removes whitespace from the end of a string.

char *strstrupcase (char *str1, char *str2);              //Case insensitive strstr.

char proccess_exception_file (char *filename, struct translatetable **trans, struct excludetable **exclude, char **path);
                                                          //Parse exception file.

char proccess_command_line (int argc, char *argv[ ], char **source1, char **source2, char *flags, char **exception);
                                                          //Parse command line arguments

void completehelp ();                                     //Show nearly complete documentation


// ******************************** MAIN ***************************
void __cdecl
main(
    int argc,
    char *argv[ ]
    )
{
  char errnum = 0;
  char *source1filename = NULL;
  char *source2filename = NULL;
  char *exceptionfilename = NULL;
  char flags;  // flags: /F=1=(F_flag); /I1=2=(I1_flag); /I2=4=(I2_flag); /X=8=(X_flag)

  struct translatetable *translations = NULL; //
  struct excludetable *exclusions = NULL;     //Information from exception file stored here.
  char *startpath = NULL;                     //

  struct checksums *source1checksums = NULL;  //List of extra files in Source1
  struct checksums *source2checksums = NULL;  //List of extra files in Source2
  struct checksums *missmatched = NULL;       //List of files with chechsums that don't match.

  struct translatetable *temp = NULL;         //
  struct checksums *temp2 = NULL;             //Temporary pointers used to help deallocate memory

  //Parse command line.
  if (errnum = proccess_command_line (argc, argv, &source1filename, &source2filename, &flags, &exceptionfilename))
  {
    goto freecommandline;  // skip to end and deallocate memory
  }

  //Show information obtained from command line.
  printf ("Source1 = %s\n", source1filename);
  printf ("Source2 = %s\n", source2filename);
  if (flags & F_flag)
    printf ("Comparing flat Share.\n");
  if (flags & I1_flag)
    printf ("Ignoring extra files in Source1.\n");
  if (flags & I2_flag)
    printf ("Ignoring extra files in Source2.\n");
  if (flags & X_flag)
    printf ("Exception file = %s\n", exceptionfilename);

  //Parse the excpetion file if it exists.
  if (flags & X_flag)
  {
    if (errnum = proccess_exception_file (exceptionfilename, &translations, &exclusions, &startpath))
    {
      goto freeexceptiontable; //skip to end and dealocate memory
    };

    //Display information from exception file.
    temp = translations;
    while (temp != NULL)
    {
      printf ("TRANSLATE %s --> %s\n", temp->source1name, temp->source2name);
      temp = temp->next;
    };
    temp = (struct translatetable *) exclusions;  //note: using wrong type to avoid making another temp pointer
    while (temp != NULL)
    {
      printf ("EXCLUDE %s\n", temp->source1name);
      temp = temp->next;
    };
    if (startpath != NULL)
      printf ("STARTPATH %s\n", startpath);
  };

  //Read source1 and store files and checksums in source1checksums.
  if (errnum = loadsource1 (source1filename, &source1checksums, translations, exclusions, startpath, flags))
  {
    goto freesource1checksums;
  };

  //printf ("\n\nSource1:\n\n");  //for debugging
  //showchecksumlist (source1checksums);

  //Read source2 and compare it to the files/checksums from source1.  Store differences.
  if (errnum = comparesource2 (source2filename, &source1checksums, &source2checksums, &missmatched,
                               translations, exclusions, startpath, flags))
  {
    goto freesource2checksums;
  };

  //Display extra files unless /I1 or /I2 was used in the command line.
  if ((!(flags & I1_flag)) & (source1checksums != NULL))
  {
    errnum = 1;
    printf ("\n********** Extra files in %s **********\n", source1filename);
    showchecksumlist (source1checksums);
  };
  if ((!(flags & I2_flag)) & (source2checksums != NULL))
  {
    errnum = 1;
    printf ("\n********** Extra files in %s **********\n", source2filename);
    showchecksumlist (source2checksums);
  };

  //Display missmatched checksums.
  if (missmatched != NULL)
  {
    errnum = 1;
    printf ("\n********** Checksums from %s != checksums from %s.**********\n", source1filename, source2filename);
    showdualchecksumlist (missmatched);
  };

  //Deallocate memory.
freesource2checksums:
  while (source2checksums != NULL)
  {
    temp2 = source2checksums;
    source2checksums = source2checksums->next;
    free (temp2);
  };
  while (missmatched != NULL)
  {
    temp2 = missmatched;
    missmatched = missmatched->next;
    free (temp2);
  };
freesource1checksums:
  while (source1checksums != NULL)
  {
    temp2 = source1checksums;
    source1checksums = source1checksums->next;
    free (temp2);
  };
freeexceptiontable:
  if (startpath != NULL)
    free (startpath);
  while (translations != NULL)
  {
    if (translations->source1name != NULL)
      free (translations->source1name);
    if (translations->source2name != NULL)
      free (translations->source2name);
    temp = translations;
    translations = translations->next;
    free (temp);
  };
  while (exclusions != NULL)
  {
    if (exclusions->path != NULL)
      free (exclusions->path);
    temp = (struct translatetable *) exclusions;
    exclusions = exclusions->next;
    free (temp);
  };

freecommandline:
  if (source1filename != NULL)
    free (source1filename);
  if (source2filename != NULL)
    free (source2filename);
  if (exceptionfilename != NULL)
    free (exceptionfilename);

  //End program and show help if needed.
  error (errnum);
};


void showchecksumlist (struct checksums *list)
{
  while (list != NULL)
  {
    printf ("%d  %s\n", list->sum, &(list->filename));
    list = list->next;
  };
};

void showdualchecksumlist (struct checksums *list)
//This can only be used with the missmatched checksums list since it assumes that the files
//come in pairs of identical filenames with different checksums.
{
  while (list != NULL)
  {
    if (list->next == NULL)
    {
      printf ("Error: list corruption detected in showdualchecksumlist function.\n");
      return;
    };
    printf ("%d != %d %s\n", list->sum, list->next->sum, &(list->filename));
    list = list->next->next;
  };
};

char excluded (char *str, struct excludetable *ex)   //If any of the exclude strings are in str it returns true.
{
  while (ex != NULL)
  {
    if (strstr (str, ex->path))
      return (1);
    ex = ex->next;
  }
  return (0);
};

char *translate (char *str, struct translatetable *tran)
{
  char *temp;
  char *newstr;

  while (tran != NULL)    //Search translate table.
  {
    if ((temp = strstr (str, tran->source1name)) != NULL)  //If we found one that needs translating
    {
      //Allocate memory for new string.
      if ((newstr = malloc (strlen (str) + strlen (tran->source2name) - strlen(tran->source1name) + 1))==NULL)
        return (NULL);
      strncpy(newstr, str, (size_t)(temp - str));            //Write part before translations.
      strcpy (&newstr [temp-str], tran->source2name);        //Add translated part
      strcat (newstr, &temp [strlen (tran->source1name)]);   //Add end of string
      return (newstr);
    };
    tran = tran->next;
  };
  return (_strdup (str)); //If didn't need to be translated, make a new copy anyway for uniformity.
};

long readhex (char *str)
{
  long temp = 0;
  int position = 0;
  for (position = 0; 1;position++)
  {
    if ((str[position] == ' ')|(str[position] == '\n')|(str[position] == '\x00'))
    {
      return (temp);
    }
    else
    {
      temp *= 16;
      if ((str [position] >= '0') & (str [position] <= '9'))
      {
        temp+=(str[position]-'0');
      }
      else if ((str [position] >= 'a') & (str [position] <= 'f'))
      {
        temp+=(str[position]-'a'+10);
      }
      else
        return (-1);
    };
  };
};

char proccessline (char *tempstr, struct translatetable *translations, struct excludetable *exclusions,
                  char *startpath, char flags, char **filename, long *filesum)
{
  char *name;
  char *newname;
  char *sumstr;

  *filename = NULL;                             //Make sure that if no name is returned this is blank
  removewhitespace (tempstr);

  //If it is a line that says "-  N0 files" then the sum is assigned to 0
  if ((sumstr = strstr (tempstr, "  -  No files")) != NULL)
  {
    *filesum=0;
    sumstr [0]=0;
  }
  //Otherwise find checksum
  else
  {
    sumstr = tempstr + strlen (tempstr);            //Find checksum by finding the last space in the line
    while ((sumstr [0] != ' ')&(sumstr != tempstr)) //
      sumstr--;                                     //
    if (sumstr==tempstr)                            //
    {
      printf ("Comment: %s", tempstr);            //If there is no space before the first character,
      return (chk_err);                           //the line is invalid.  Assume it is a comment.
    };
    sumstr [0] = 0;                               //Split string into path/filename and checksum
    sumstr++;                                     //

    //convert checksum string to a number
    if ((*filesum = readhex (sumstr))==-1)
    {
      printf ("Comment: %s %s\n", tempstr, sumstr); //If the checksum isn't a valid hex number
      return (chk_err);                             //assume the line is a commment.
    };
  };

  //Apply any translations that may be valid for this path/file.
  if ((name = translate (tempstr, translations)) == NULL)
  {
    printf ("Need memory.");
    return (mem_err);
  };

  //Make sure this file isn't excluded.
  if (!excluded (name, exclusions))
  {
    //If there isn't a startpath then all files will be proccessed
    //If there is a startpath then only the ones containing the path will be proccessed
    if (startpath == NULL)
    {
      newname = name;
      goto instartpath;
    }
    else if ((newname = strstr (name, startpath)) != NULL) //If this file is in startpath
    {
      newname = newname + strlen (startpath);     //Remove startpath

    instartpath:                   //This happens if one of the above conditions was true

      //Remove path if doing a flat compare.
      if (flags & F_flag)
      {
        while (strstr (newname, "\\") != NULL)    // Remove path
        {                                         //
          newname = strstr (newname, "\\");       //
          newname++;                              // and leading "\\"
        };
      };

      //Make a final copy of the path/file to return
      if ((*filename = _strdup (newname)) == NULL)
      {
        printf ("Memory err.");
        free (name);
        return (mem_err);
      };
    };
  };
  free (name);
  return (0);
};

char loadsource1 (char *filename, struct checksums **sums,
                  struct translatetable *translations, struct excludetable * exclusions,
                  char *startpath, char flags)
{
  FILE *chkfile;
  char tempstr [chkfilelinelength];
  char *name;
  char err;
  long tempsum;
  struct checksums *newsum;
  struct checksums **last;  //Used to keep trak of the end of the linked list.
  last = sums;

  if ((chkfile = fopen (filename, "r"))==NULL)
  {
    printf ("Error opening source1.\n\n");
    return (file_err);
  };

  //Proccess all lines
  while (fgets (tempstr, chkfilelinelength, chkfile) != NULL)
  {
    //Verify that the entire line was read in and not just part of it
    if (tempstr [strlen (tempstr)-1] != '\n')
    {
      printf ("Unexpected end of line.  chkfilelinelength may need to be larger.\n  %s\n", tempstr);
      fclose (chkfile);
      return (chk_err);
    };

    //Parse line
    if ((err = proccessline (tempstr, translations, exclusions, startpath, flags, &name, &tempsum)) == 0)
    {
      //If this line was excluded or not in the path don't do anything, just go on to the next line.
      if (name != NULL)
      {
        //Create a new structure and add it to the end of the linked list.
        if ((newsum = malloc (sizeof (struct checksums) + strlen (name))) == NULL)
        {                    //Note: this is a variable length structure to fit any size of string.
          printf ("Memory err.");
          fclose (chkfile);
          return (mem_err);
        };
        *last = newsum;
        newsum->next = NULL;
        newsum->sum = tempsum;
        strcpy(&(newsum->filename), name);
        last = &((*last)->next);

        //Free temporary storage.
        free (name);
      };
    }
    else
    {
      if (err != chk_err)  //Just skip line if it isn't understandable.
      {
        fclose (chkfile);
        return (err);
      };
    };
  };

  //Ckeck to make sure it quit because it was done and not because of file errors.
  if (ferror (chkfile))
  {
    printf ("Error reading source1.\n\n");
    return (file_err);
  };
  if (fclose (chkfile))
  {
    printf ("Error closing source1.\n\nContinuing anyway...");
  };
  return (0);
};

char notnull_strcmp (struct checksums *sum, char *str)
// perform short circuit evaluation of ((sum != NULL) & (strcmp (&(sum->filename), str) != 0)
{
  if (sum != NULL)
  {
    if (strcmp (&(sum->filename), str) != 0)
    {
      return (1);
    };
  };
  return (0);
};

char comparesource2 (char *filename, struct checksums **sums,
                     struct checksums **extrasource2, struct checksums **missmatched,
                     struct translatetable *translations, struct excludetable * exclusions,
                     char *startpath, char flags)
{
  FILE *chkfile;
  char tempstr [chkfilelinelength];
  char *name;
  char err;
  long tempsum;
  struct checksums *newsum;
  struct checksums *search;
  struct checksums **lastlink;

  if ((chkfile = fopen (filename, "r"))==NULL)
  {
    printf ("Error opening source2.\n\n");
    return (file_err);
  };
  while (fgets (tempstr, chkfilelinelength, chkfile) != NULL)
  {
    //Verify that the entire line was read.
    if (tempstr [strlen (tempstr)-1] != '\n')
    {
      printf ("Unexpected end of line.  chkfilelinelength may need to be larger.\n  %s\n", tempstr);
      fclose (chkfile);
      return (chk_err);
    };

    //Parse line
    if ((err = proccessline (tempstr, NULL, exclusions, startpath, flags, &name, &tempsum)) == 0)
    {
      //If file was skipped do nothing
      if (name != NULL)
      {
        //Prepare to look for a match
        search = *sums;
        lastlink = sums;
        //short circuit evaluation of:(search != NULL) & (strcmp (&(search->filename), name) != 0)
        while (notnull_strcmp (search, name))
        {
          search = search->next;
          lastlink = &((*lastlink)->next);
        };

        if (search != NULL)               //If a match was found
        {                                 // remove it from the sums list
          *lastlink = search->next;       // by linking around it
          if (search->sum == tempsum)     // If checksums match
          {                               //
            search->sum=0;
            free (search);                //  Deallocate memory
          }                               //
          else                            // If the checksums didn't match
          {                               //
            if ((newsum = malloc (sizeof (struct checksums) + strlen (name))) == NULL)
            {                             //  Add 2nd name and checksum to missmatched list
              printf ("Memory err.");     //
              fclose (chkfile);           //
              return (mem_err);           //
            };                            //
            newsum->next = *missmatched;  //
            newsum->sum = tempsum;        //
            strcpy(&(newsum->filename), name);
            *missmatched = newsum;        //
            search->next = *missmatched;  //  Add 1st name to the missmatched list
            *missmatched = search;        //
          };                              //
        }                                 //
        else                              //If no match was found
        {                                 // this needs to be added to extrasource2 list
          if ((newsum = malloc (sizeof (struct checksums) + strlen (name))) == NULL)
          {                  //Note: this is a variable length structure to fit any size of string.
            printf ("Memory err.");
            fclose (chkfile);
            return (mem_err);
          };
          newsum->next = *extrasource2;
          newsum->sum = tempsum;
          strcpy(&(newsum->filename), name);
          *extrasource2 = newsum;
        };

        //free temporary storage
        free (name);
      };
    }
    else
    {
      if (err != chk_err)   //Just skip the line (don't abort) if it is bad
      {
        fclose (chkfile);
        return (err);
      };
    };
  };
  if (ferror (chkfile))
  {
    printf ("Error reading source2.\n\n");
    return (file_err);
  };
  if (fclose (chkfile))
  {
    printf ("Error closing source2.\n\nContinuing anyway...");
  };
  return (0);
};

void removewhitespace (char *str)  // removes whitespace from the end of a string
{
  int end;
  end = strlen (str);
  while ((end > 0)&((str [end-1] == '\n')|(str [end-1] == ' ')))
   end--;
  str [end] = 0;
};

char *strstrupcase (char *str1, char *str2)
{
  char *temp;
  size_t count;
  size_t length;

  length = strlen (str2);
  for (temp = str1; strlen (temp) > length; temp++)
  {
    for (count = 0; (toupper (temp [count]) == toupper (str2 [count]))&(count < length); count++);
    if (count==length)
    {
      return (temp);
    };
  };
  return (NULL);
};

char proccess_exception_file (char *filename, struct translatetable **trans, struct excludetable **exclude, char **path)
{
  FILE *efile;
  char tempstr [exceptionfilelinelength];
  char *start;
  char *end;
  struct translatetable *temp;

  if ((efile = fopen (filename, "r"))==NULL)
  {
    printf ("Error opening excetion file.\n\n");
    return (file_err);
  }

  while (fgets (tempstr, exceptionfilelinelength, efile) != NULL)
  {
    start = tempstr;
    while (start [0] == ' ')  //Remove leading whitespace
      start++;

    //If it is a translate command
    if (strstrupcase (start, "TRANSLATE") == start)
    {
      start = start + 10;         //Go past translate
      while (start [0] == ' ')      //skip spaces
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n%s", tempstr);
        return (exep_err);
      };
      end = strstr (start, "-->");  //Find second part of string
      if (end == NULL)
      {
        printf ("Line: %s \nmust have two file names separated by -->", tempstr);
        return (exep_err);
      }
      end [0] = '\0';  //Split string
      removewhitespace (start);
      if ((temp = malloc (sizeof (struct translatetable))) == NULL)
      {
        printf ("Insufficient memory to load exception table.");
        return (mem_err);
      }
      if ((temp->source1name = _strdup (start)) == NULL)
      {
        printf ("Unable to allocate memory for char temp->source1name in proccess_exception_file.\n");
        free (temp);
        return (mem_err);
      }
      start = end + 3;
      while (start [0] == ' ')  //Remove leading whitespace
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n   %s", tempstr);
        free (temp->source1name);
        free (temp);
        return (exep_err);
      };
      removewhitespace (start);
      if ((temp->source2name = _strdup (start)) == NULL)
      {
        printf ("Unable to allocate memory for char temp->source1name in proccess_exception_file.\n");
        free (temp->source1name);
        free (temp);
        return (mem_err);
      }
      temp->next = *trans;
      *trans = temp;
    }

    //If it is an exclude command.
    else if (strstrupcase (start, "EXCLUDE") == start)
    {
      start = start + 7;         //Go past exclude
      while (start [0] == ' ')      //skip spaces
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n   %s", tempstr);
        return (exep_err);
      };
      removewhitespace (start);
      if ((temp = malloc (sizeof (struct excludetable))) == NULL)
      {
        printf ("Insufficient memory to load exception table.");
        return (mem_err);
      }
      if ((temp->source1name = _strdup (start)) == NULL)  //source1name coresponds to path
      {
        printf ("Unable to allocate memory for char temp->path in proccess_exception_file.\n");
        free (temp);
        return (mem_err);
      }
      temp->next = (struct translatetable *) *exclude;
      *exclude = (struct excludetable *) temp;
    }

    //If it is a startpath command
    else if (strstrupcase (start, "STARTPATH") == start)
    {
      if (*path != NULL)
      {
        printf ("Only one STARTPATH command is allowed in the exception file.\n");
        return (exep_err);
      };
      start = start + 9;         //Go past startpath
      while (start [0] == ' ')      //skip spaces
        start++;
      if (start [0] == 0)
      {
        printf ("Unexpected end of line in exception file:\n   %s", tempstr);
        return (exep_err);
      };
      removewhitespace (start);
      if ((*path = _strdup (start)) == NULL)
      {
        printf ("Unable to allocate memory for char path in proccess_exception_file.\n");
        return (mem_err);
      }
    }
    else if (!start [0] == ';') //if it's not a comment
    {
      printf ("Unexpected line in exception file:\n   %s", tempstr);
      return (exep_err);
    };
  };
  if (ferror (efile))
  {
    printf ("Error reading exception file.\n\n");
    return (file_err);
  };
  if (fclose (efile))
  {
    printf ("Error closing excetion file.\n\nContinuing anyway...");
  };
  return (0);
};

char proccess_command_line (int argc, char *argv[ ], char **source1, char **source2, char *flags, char **exception)
// flags: /F=1=(F_flag); /I1=2=(I1_flag); /I2=4=(I2_flag); /X=8=(X_flag)
{
  int argloop;
  *flags=0; //temporarily using 16=source1 found; 32=source2 found

  for (argloop = 1;argloop < argc; argloop++)
  {
    if (argv[argloop][0] == '/')
	  {							
	    if ((argv[argloop][1] == 'F')|(argv[argloop][1] == 'f')) //we got a /f
	    {
	      *flags|=F_flag;   //duplicate flags will not cause errors
	    }
      else if (argv[argloop][1] == '?')
      {
        completehelp ();
      }
	    else if ((argv[argloop][1] == 'I')|(argv[argloop][1] == 'i'))
      {
        if (argv[argloop][2] == '1')
        {
          *flags|=I1_flag;  //we got a /i1
        }
        else if (argv[argloop][2] == '2')
        {
          *flags|=I2_flag;  //we got a /i2
        }
        else
        {
          printf ("Unknown switch \"/I%c\" .\n\n", argv[argloop][2]);
          return (par_err);
        }
      }
      else if ((argv[argloop][1] == 'X')|(argv[argloop][1] == 'x'))
      {
        *flags|=X_flag; // we got a /x
        if (argloop+1 == argc)
        {
          printf ("Parameter /X must be followed by a filename.\n\n");
          return (par_err);
        };
        if ((*exception = _strdup (argv [argloop + 1]))==NULL)
        {
          printf ("Unable to allocate memory for char *exception in proccess_command_line.\n");
          error (mem_err);
        };
        argloop++; //to skip this parameter in the general parser
      }
      else
      {
        printf ("Unknown switch \"/%c\" .\n\n", argv[argloop][1]);
        return (par_err);
      }
  	}
  	else  // it must be a source filename
  	{
  	  if (!(*flags & 16)) //first source in command line
      {
        if ((*source1 = _strdup (argv [argloop]))==NULL)
        {
          printf ("Unable to allocate memory for char *source1 in proccess_command_line.\n");
          return (mem_err);
        };
        *flags|=16;
      }
      else if (!(*flags & 32)) //second source in command line
      {
        if ((*source2 = _strdup (argv [argloop]))==NULL)
        {
          printf ("Unable to allocate memory for char *source2 in proccess_command_line.\n");
          return (mem_err);
        };
        *flags|=32;
      }
      else
      {
        printf ("Too many source filenames in the command line.\n\n");
        return (par_err);
      };
    };
  };
  if (!(*flags & 32))
  {
    printf ("Command line must contain two source files.\n\n");
    return (par_err);
  };
  *flags|=(!(32+16)); // clear temporary source1 and source2 flags
  return (0);
};

void completehelp ()
{
  printf ("Usage:\n"
          "CHKVERFY <Source1> <Source2> [/F] [/X <exceptionfile>] [/I1] [/I2]\n"
          "     /F  = Flat share (ignore paths).\n"
          "     /I1 = Ignore extra files in Source1.\n"
          "     /I2 = Ignore extra files in Source2.\n"
          "     /X  = excetion file with the following commands.\n"
          "          TRANSLATE <Source1name> --> <Source2name>\n"
          "             Replaces <Source1name> with <Sourece2name> whereever found.\n"
          "             Note: make sure the filename you are using is only in the full\n"
          "             filename of the files you mant to translate.\n\n"
          "          EXCLUDE <pathsegment>\n"
          "             Any path and file containing this string will be ignored.\n\n"
          "          STARTPATH <directory name>\n"
          "             Files without this string in the path will be ignored.\n"
          "             The part of the path before this string will be ignored.\n\n"
          "         Note: These three commands are proccessed in the order shown above. \n"
          "               For example, the command \"TRANSLATE C:\\nt --> C:\\\" will\n"
          "               override the command \"EXCLUDE C:\\nt\".\n"
          "               The order of commands in the exception files doesn't matter\n"
          "               unless two commands both try to translate the same file.\n"
          "               In that case, the last command in the file takes precedence.\n"
          "Exit codes:\n"            // These code values should match the codes defined above.
          "     6 = Invalid command line arguments.\n"
          "     5 = Error in exception file format.\n"
          "     4 = Error in chkfile.\n"
          "     3 = Memory allocation error.\n"
          "     2 = File access error.\n"
          "     1 = No errors: Source1 and Source2 failed compare.\n"
          "     0 = No errors: Source1 and Source2 compared successfully.\n\n"
          );
  exit (0);
};

void error (char exitcode)
{
  if (exitcode >= exep_err)
  {
  printf ("Usage:\n"
          "CHKVERFY <Source1> <Source2> [/F] [/X <exceptionfile>] [/I1] [/I2]\n"
          "     /?  = Complete help.\n"
          "     /F  = Flat share (ignore paths).\n"
          "     /I1 = Ignore extra files in Source1.\n"
          "     /I2 = Ignore extra files in Source2.\n"
          "     /X  = excetion file with the following commands.\n"
          );
  };
  switch (exitcode)
  {
    case 0:
      printf ("\n\n(0) Files compare okay.\n");
      break;
    case 1:
      printf ("\n\n(1) Some files or checksums don't match.\n");
      break;
    case 2:
      printf ("\n\n(2) Terminated due to file access error.\n");
      break;
    case 3:
      printf ("\n\n(3) Terminated due to memory allocation error.\n");
      break;
    case 4:
      printf ("\n\n(4) The format of the source files was not as expected.\n");
      break;
    case 5:
      printf ("\n\n(5) Error in exception file format.\n");
      break;
    case 6:
      printf ("\n\n(6) Bad command line argument.\n");
      break;
  };
  exit (exitcode);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\chksum\chksum.c ===
/**************************************************************************************\
*  Chksum.c
*  Purpose: Print to stdout checksum of all files in current directory, and optionally
*           recurse from current directory.
*
*  Created 02-15-95.  DonBr
*
\**************************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <errno.h>
#include <string.h>
#include <io.h>
#include <imagehlp.h>
#include <direct.h>
#include <ctype.h>

// type definitions
#define exename "chksum"
#define MAX_EXCLUDE (30)
#define LISTSIZE 12000   // max allowable number of files and dirs in a flat directory

typedef struct List {
       char            Name[MAX_PATH];  // file or directory name
       unsigned long   Attributes;
       unsigned long   Size;
} List, *pList;

// Function prototypes
VOID CheckRel();
VOID CheckSum(List *rgpList, TCHAR *x); //, TCHAR *szDirectory);
int __cdecl CompFileAndDir( const void *elem1 , const void *elem2);
int __cdecl CompName( const void *elem1 , const void *elem2);
int MyGetFullPathName( IN const CHAR *InPath, IN OUT CHAR *FullPath);
VOID CreateOutputPath(char *CurrentDir, char *NewDir);
VOID ParseArgs(int *pargc, char **argv);
VOID Usage();

// Variable declarations

BOOL fRecurse = FALSE;
BOOL fPathOverride = FALSE;
BOOL fFileOut = FALSE;
BOOL fExclude = FALSE;
BOOL fFileIn = FALSE;
int  DirNum = 1,DirNameSize = 0, ProcessedFiles=0, endchar=0, ExclCounter=0;
int  grc=0;  // global return code
char szRootDir[MAX_PATH];
char szRootDir2[MAX_PATH];
char *szFileOut;
char szFileOutFullPath[MAX_PATH];
char *szExclude[MAX_EXCLUDE];
char *szFileIn;
CHAR szDirectory[MAX_PATH] = {"."};  // default to current directory
FILE* fout;
FILE* fin;


// Begin main program
VOID __cdecl
main(
    INT argc,
    LPSTR argv[]
    )

{
    TCHAR CWD[MAX_PATH];
    HANDLE logfh;

    ParseArgs(&argc, argv);

    // Create File if fFileOut==TRUE
    if (fFileOut) {
       fout = fopen(szFileOut, "w");
       if (fout == NULL) {
          fprintf(stderr, "Output file %s could not be created.\n", szFileOut);
          exit(1);
       }

    }
    /*
    // Open File if fFileIn==TRUE
    if (fFileIn) {
       fin = fopen(szFileIn, "r");  // open check file
       if (fin == NULL) {
          fprintf(stderr, "Check file %s could not be opened.\n", szFileIn);
          exit(1);
       }
    }
    */

    // set root path
    if (fPathOverride) {

       // attempt to change directories
       if (_chdir(szRootDir) == -1){
          fprintf(stderr, "Path not found: %s\n", szRootDir);
          Usage();
       }
    }else{
       GetCurrentDirectory(MAX_PATH, szRootDir);
    }

    fprintf(fout==NULL? stdout : fout , "Processing %s\n", szRootDir);

    CheckRel();  // primary worker routine

    fprintf(stdout, "%d files processed in %d directories\n", ProcessedFiles, DirNum);

    if (fFileOut) {
       fclose(fout);
    }

    exit(grc);
}

/**************************************************************************************\
*  Checkrel
*  Purpose: Create an array of List structures containing file data for the current
*           directory, sort the array alphabetically placing Files first and
*           directories last, and finally process the array contents.  Another instance
*           of checkrel is started for directories, and checksum is called for files.
\**************************************************************************************/

VOID CheckRel()
{
    HANDLE fh;
    TCHAR CurrentDir[MAX_PATH] = {"\0"};
    TCHAR NewDir[MAX_PATH] = {"\0"};

    WIN32_FIND_DATA *pfdata;
    BOOL fFilesInDir=FALSE;
    BOOL fDirsFound=FALSE;
    int iArrayMember=0, cNumDir=0, i=0, Length=0;
    pList *rgpList = NULL;  // a pointer to an array of pointers to List structures
    CHAR cFileNameFullPath[MAX_PATH];

    pfdata = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!pfdata) {
       fprintf(stderr, "Not enough memory.\n");
       grc++;
       return;
    }

    // Find the first file
    fh = FindFirstFile("*.*", pfdata);
    if (fh == INVALID_HANDLE_VALUE) {
       fprintf(fout==NULL? stdout : fout , "\t No files found\n");
       free(pfdata);
       grc++;
       return;
    }

    // Allocate an array of pointers to List structures
    rgpList = (pList *) malloc(LISTSIZE * sizeof(pList));
    if (!rgpList) {
       fprintf(stderr, "Not enough memory allocating rgpList[].\n");
       free(pfdata);
       FindClose(fh);      // close the file handle
       grc++;
       return;
    }

    //
    // DoWhile loop to find all files and directories in current directory
    // and copy pertinent data to individual List structures.
    //
    do {              // while (FindNextFile(fh, pfdata))

       if (strcmp(pfdata->cFileName, ".") && strcmp(pfdata->cFileName, "..")) {  // skip . and ..

          //
          // If excluding files and current file matches any excluded file 
          // (case insensitively), then don't process current file
          //
          if (fExclude) {
             for (i=0; i < ExclCounter; i++) {
                if (!_strcmpi(pfdata->cFileName, szExclude[i])) {
                   goto excludefound;

                }
             }
          }

          //
          // If current file matches output file name, then don't process current file
          //
          if ((fFileOut) && (!strcmp(szFileOut, pfdata->cFileName)) ) {

             // File names match.  If full paths match, ignore the output file.

             MyGetFullPathName(pfdata->cFileName, cFileNameFullPath);
             if ( !_strcmpi( szFileOutFullPath, cFileNameFullPath) ) {
                goto excludefound;
             }
          }

          rgpList[iArrayMember] = (pList)malloc(sizeof(List));  // allocate the memory

          if (!rgpList[iArrayMember]) {
             fputs("Not enough memory.\n", stderr);
             free(pfdata);
             FindClose(fh);      // close the file handle
             for (i=0; i<iArrayMember; i++) free(rgpList[i]);
             free(rgpList);
             grc++;
             return;
          }

          strcpy(rgpList[iArrayMember]->Name, pfdata->cFileName);
          _strlwr(rgpList[iArrayMember]->Name);  // all lowercase for strcmp in CompName
          memcpy(&(rgpList[iArrayMember]->Attributes), &pfdata->dwFileAttributes, 4);
          memcpy(&(rgpList[iArrayMember]->Size), &pfdata->nFileSizeLow, 4);

          if (!(rgpList[iArrayMember]->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {  //If file
             fFilesInDir=TRUE;
          } else {
             if (rgpList[iArrayMember]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  //If directory
                fDirsFound=TRUE;
             }
             if (fRecurse) {  // if recursive increment directory counter
                cNumDir++;
             }
          }

          iArrayMember++;
          if (iArrayMember >= LISTSIZE) {
             GetCurrentDirectory(MAX_PATH, CurrentDir);
             fprintf(stderr, "More than %d files in %s. \nRebuild chksum.exe or eliminate some files from the root of this directory.\n", LISTSIZE, CurrentDir);
             free(pfdata);
             FindClose(fh);      // close the file handle
             for (i=0; i<iArrayMember; i++) free(rgpList[i]);
             free(rgpList);
             grc++;
             return;
          }
          excludefound: ;
       }


    } while (FindNextFile(fh, pfdata));

    if (pfdata) free(pfdata);
    if (fh) FindClose(fh);      // close the file handle

    //
    // if no directories or files found with exception of . and ..
    //
    if ( (iArrayMember==0) || (!fFilesInDir) ){

       GetCurrentDirectory(MAX_PATH, CurrentDir);

       CreateOutputPath(CurrentDir, NewDir);

       // fprintf(fout==NULL? stdout : fout , "%s  -  No files\n", NewDir);
    }

    // Sort Array arranging FILE entries at top
    qsort( (void *)rgpList, iArrayMember, sizeof(List *), CompFileAndDir);

    // Sort Array alphabetizing only FILE names
    qsort( (void *)rgpList, iArrayMember-cNumDir, sizeof(List *), CompName);

    // Sort Array alphabetizing only DIRectory names
    qsort( (void *)&rgpList[iArrayMember-cNumDir], cNumDir, sizeof(List *), CompName);

    //
    // Process newly sorted structures.
    // Checksum files or start another instance of checkrel() for directories
    //
    for (i=0; i < iArrayMember; ++i) {

       if (rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  // if Dir


          if (fRecurse) {                                        // if recursive

             if (_chdir(rgpList[i]->Name) == -1){   // cd into subdir and check for error
                fprintf(stderr, "Unable to change directory: %s  (error %d)\n", rgpList[i]->Name, GetLastError());
                grc++;

             } else {
                DirNum++;      // directory counter
                CheckRel();   // start another iteration of checkrel function in new directory
                _chdir(".."); // get back to previous directory when above iteration returns

             } // end if _chdir

          } // end if recurse

       } else {  // else if not Directory
             GetCurrentDirectory(MAX_PATH, CurrentDir);

             CreateOutputPath(CurrentDir, NewDir);

             CheckSum(rgpList[i], NewDir);
       }

    } // end for i < iArrayMember

    // Clean up the array and it's elements
    for (i=0; i<iArrayMember; i++) free(rgpList[i]);
    free(rgpList);

} // end CheckRel

/*************************************************************************************\
* CheckSum
* Purpose: uses MapFileAndCheckSum to determine file checksum and outputs data.
\*************************************************************************************/
VOID CheckSum(List *rgpList, TCHAR *x) {//TCHAR *szDirectory) {
    ULONG HeaderSum, CheckSum=0, status;

    if (rgpList->Size != 0) { //High != 0 || rgpList->nFileSizeLow != 0) {
       status = MapFileAndCheckSum(rgpList->Name, &HeaderSum, &CheckSum);
       if (status != CHECKSUM_SUCCESS) {
          fprintf(fout==NULL? stdout : fout , "\nCannot open or map file: %s (error %d)\n", rgpList->Name, GetLastError());
          grc++;
          return;
       }
    }

    fprintf(fout==NULL? stdout : fout , "%s\\%s %lx\n", x, rgpList->Name, CheckSum);//szDirectory, rgpList->Name, CheckSum);
    ProcessedFiles++;

} //CheckSum


/********************************************************************************************\
* CompFileAndDir
* Purpose: a comparision routine passed to QSort.  It compares elem1 and elem2
* based upon their attribute, i.e., is it a file or directory.
\********************************************************************************************/

int __cdecl
CompFileAndDir( const void *elem1 , const void *elem2 )
{
   pList p1, p2;
   // qsort passes a void universal pointer, use a typecast (List**)
   // so the compiler recognizes the data as a List structure.
   // Typecast pointer-to-pointer-to-List and dereference ONCE
   // leaving a pList.  I don't dereference the remaining pointer
   // in the p1 and p2 definitions to avoid copying the structure.
   p1 = (*(List**)elem1);
   p2 = (*(List**)elem2);

   if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return 0;
   } //both dirs
   if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return 0;
   } //both files
   if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return 1;
   } // elem1 is dir and elem2 is file
   if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
      return -1;
   } // elem1 is file and elem2 is dir

   return 0; // if none of above

}


/********************************************************************************************\
* CompName is another compare routine passed to QSort that compares the two Name strings     *
\********************************************************************************************/

int __cdecl
CompName( const void *elem1 , const void *elem2 )
{
   return strcmp( (*(List**)elem1)->Name, (*(List**)elem2)->Name );
}

/**********************************************************************************************\
* CreateOutputPath just formats NewDir, the path prepended to filename during checksum output  *
\**********************************************************************************************/
VOID CreateOutputPath(char *CurrentDir, char *NewDir)
{
             strcpy(NewDir, ".");

             // if rootdir ends in '\' and currentdir and szrootdir2 don't match
             // handles case where /p path override arg ends in a '\' char like "/p g:\"
             // files listed at the root don't need the extra '\' placed in NewDir, but
             // directories at the root DO need ".\" prepended to their name

             _strlwr(CurrentDir);
             //fprintf(stdout, "szrootdir: %s, szrootdir2: %s, currentdir: %s\n", szRootDir, szRootDir2, CurrentDir);

             if ( (szRootDir[strlen(szRootDir)-1] == '\\') &&  // if arg path ends in "\"
                (strcmp(CurrentDir, szRootDir2)) &&            // if they don't match
                (CurrentDir[strlen(CurrentDir)-1] != '\\') //&&  // if currentdir doesn't end with "\"
                //(szRootDir2[strlen(szRootDir2)-1] != ':') ){   // if arg path ends with ":"
             ){
                strcat(NewDir, "\\");
             }

             if (  (CurrentDir[strlen(CurrentDir)-2] !=':') && (CurrentDir[strlen(CurrentDir)-1] !='\\')  ){
                strcat(NewDir, &CurrentDir[(strlen(szRootDir))] );
             }

}

VOID
ParseArgs(int *pargc, char **argv) {

   CHAR cswitch, c, *p;
   int argnum = 1;

   while ( argnum < *pargc ) {
      _strlwr(argv[argnum]);
      cswitch = *argv[argnum];
      if (cswitch == '/' || cswitch == '-') {
         c = *(argv[argnum]+1);

         switch (c) {

         case '?':
            Usage();

         case 'r':
            fRecurse = TRUE;
            break;

         case 'p':
            if ( ((argnum+1) < *pargc) && (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum; // increment to next arg string
               strcpy(szRootDir, argv[argnum]);
               if (szRootDir == NULL) {
                  fprintf(stderr, "out of memory for root dir.\n");
                  exit(1);
               }
               fPathOverride = TRUE;

               // Find the full path to the root
               if ( !MyGetFullPathName(argv[argnum], szRootDir) ) {
                  fprintf(stderr, "Cannot get full path for root dir %s\n", szRootDir);
                  exit(1);
               }
               _strlwr(szRootDir);

               strcpy(szRootDir2, szRootDir);
               // if path given ends in a "\", remove it...
               if (szRootDir2[strlen(szRootDir2)-1] == 92) szRootDir2[strlen(szRootDir2)-1] = '\0';
               break;

            } else {
               Usage();
            }

         case 'o':
            if ( ((argnum+1) < *pargc) && (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum;
               szFileOut = _strdup(argv[argnum]);
               if (szFileOut == NULL) {
                  fprintf(stderr, "Out of memory for output file.\n");
                  exit(1);
               }
               fFileOut = TRUE;

               // Find the full path to the output file
               if ( !MyGetFullPathName(szFileOut, szFileOutFullPath) ) {
                  fprintf(stderr, "Cannot get full path for output file %s\n", szFileOut);
                  exit(1);
               }
               _strlwr(szFileOutFullPath);  // lower case full path to output file
               _strlwr(szFileOut);          // lower case path to output file
               break;

            } else {
               Usage();
            }


         case 'x':                              // check number of args given
            if ( ((argnum+1) < *pargc) && (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum;
               szExclude[ExclCounter] = _strdup(argv[argnum]);
               if (szExclude[ExclCounter] == NULL) {
                  fprintf(stderr, "Out of memory for exclude name.\n");
                  exit(1);
               }
               fExclude = TRUE;
               _strlwr(szExclude[ExclCounter]);
               ExclCounter++;

               break;

            } else {
               Usage();
            }

         /*
         case 'i':
            if ( (*(argv[argnum]+2) == '\0') && (*(argv[argnum+1]) != '\0') ) {
               ++argnum;
               szFileIn = strdup(argv[argnum]);
               if (szFileIn == NULL) {
                  fprintf(stderr, "Out of memory for input file.\n");
                  exit(1);
               }
               fFileIn = TRUE;
               break;

            } else {
               Usage();
            }
         */
         default:
               fprintf(stderr, "\nInvalid argument: %s\n", argv[argnum]);
               Usage();
         } //switch

      } else {
         Usage();
      }  // if
      ++argnum;
   } // while
} // parseargs


LPSTR pszUsage =
    "Generates a listing of each file processed and its check sum.\n\n"
    "Usage: %s   [/?]          display this message\n"
    "                [/r]          recursive file check\n"
    "                [/p pathname] root path override\n"
    "                [/o filename] output file name\n"
    "                [/x name]     exclude file or directory\n\n"
    "Notes: If no /p path is given, the current directory is processed.\n"
    "       Exclude multiple files or directories with multiple /x arguments\n"
    "         e.g. - /x file1 /x file2\n\n"
    "Example: %s /r /p c:\\winnt351 /o %s.chk /x symbols /x dump\n"
    "";

VOID
Usage()
{
    fprintf(stderr, pszUsage, exename, exename, exename);
    exit(1);
}

int MyGetFullPathName( IN const CHAR *InPath, IN OUT CHAR *FullPath)
{
    int len;
    LPSTR FilePart;
    len = GetFullPathName(InPath, MAX_PATH, FullPath, &FilePart);
    return ( (len>0 && len<MAX_PATH) ? len : 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\clearmem\cmutl.h ===
/*** cmUtl.H - Function declarations/defines for cmUtl.C routines.
 *
 *
 * Title:
 *	cmUtl external function declarations/defines
 *
 *      Copyright (c) 1990, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Modification History:
 *	90.03.08  RezaB -- Created
 *
 */



/* * * *  E x t e r n a l   F u n c t i o n   D e c l a r a t i o n s  * * * */

extern BOOL  Failed (RC rc, LPSTR lpstrFname, WORD lineno, LPSTR lpstrMsg);

extern void  DisplayUsage (void);

extern RC    AddObjectHandle (LPHANDLE *plphandles, HANDLE handle);

extern long  FoldNormDist (long lMean, short sSDev, long lLoLimit,
                           long  lHiLimit);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\clearmem\cmutl.c ===
/*** cmUtl.C - Utility functions for Win 32 Clear Memory.
 *
 *
 * Title:
 *	cmUtl - Clear Memory Utility Routines
 *
 *      Copyright (c) 1990-1993, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Description:
 *
 *	This file includes all the utility functions used by the Win 32
 *	clear memory. (clearmem.c)
 *
 *
 * Design/Implementation Notes:
 *
 *
 * Modification History:
 *	90.03.08  RussBl -- Created
 * 93.05.12  HonWahChan -- removed timer related error msgs.
 *
 */



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "clearmem.h"



/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */
/* none */



/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

#include "cmUtl.h"



/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */
/* none */



/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/*******************************  F a i l e d  *******************************
 *
 *      Failed(rc, lpstrFname, lineno, lpstrMsg) -
 *              Checks the RC for an error type if an error has occured,
 *              prints the appropriate error message.  It logs the error
 *              message to the testlog file.
 *
 *      ENTRY   rc         - return code from the last API call
 *              lpstrFname - contains file name of where error occured
 *              lineno     - contains line number of failed API call
 *              lpstrMsg   - contains a general purpose message about the error
 *
 *      EXIT    -none-
 *
 *      RETURN  TRUE  - if API failed
 *              FALSE - if API successful
 *
 *      WARNING:  
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

BOOL Failed (RC rc, LPSTR lpstrFname, WORD lineno, LPSTR lpstrMsg)
{
    LPSTR lpstrErrMsg;


    if (rc != STATUS_SUCCESS) {

        switch (rc) {

            case (NTSTATUS)STATUS_INVALID_PARAMETER:
                lpstrErrMsg = "Invalid parameter";
                break;

            case STATUS_TIMEOUT:
                lpstrErrMsg = "TimeOut occured";
                break;

            case STATUS_INVALID_HANDLE:
                lpstrErrMsg = "Invalid handle";
                break;

            case STATUS_BUFFER_OVERFLOW:
                lpstrErrMsg = "Buffer overflow";
                break;

            case STATUS_ABANDONED:
                lpstrErrMsg = "Object abandoned";
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                lpstrErrMsg = "Not enough memory";
                break;

            case LOGIC_ERR:
                lpstrErrMsg = "Logic error encountered";
                break;

            case INPUTARGS_ERR:
                lpstrErrMsg = "Invalid number of input arguments";
                break;

            case FILEARG_ERR:
		          lpstrErrMsg = "Invalid cf data file argument";
                break;

            case TIMEARG_ERR:
                lpstrErrMsg = "Invalid trial time argument";
                break;

            case INSUFMEM_ERR:
                lpstrErrMsg = "Insufficient Memory";
                break;

            case FCLOSE_ERR:
                lpstrErrMsg = "fclose() failed";
                break;

            case FFLUSH_ERR:
                lpstrErrMsg = "fflush() failed";
                break;

            case FOPEN_ERR:
                lpstrErrMsg = "fopen() failed";
                break;

            case FSEEK_ERR:
                lpstrErrMsg = "fseek() failed";
                break;

            case MEANSDEV_ERR:
                lpstrErrMsg = "Invalid Mean and/or Standard Deviation";
                break;

            case PRCSETUP_ERR:
                lpstrErrMsg = "Child process setup/init failed";
                break;

            case THDSETUP_ERR:
                lpstrErrMsg = "Thread setup/init failed";
                break;

            default:
                lpstrErrMsg = "";

        } /* switch(rc) */

        printf(" **************************\n");
        printf(" * FAILure --> Line=%d File=%s (pid=0x%lX tid=0x%lX)\n",
               lineno, lpstrFname, GetCurrentProcessId(),
               GetCurrentThreadId());
        printf(" * RC=0x%lX (%s)\n", rc, lpstrErrMsg);
        printf(" * %s\n", lpstrMsg);
        printf(" **************************\n");

        return(TRUE);

    } /* if(rc..) */

    return(FALSE);

} /* Failed() */





/**************************  D i s p l a y U s a g e  ************************
 *
 *      DisplayUsage() -
 *		Displays usgae for Multi-Processor Response cf
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

void DisplayUsage (void)
{

    printf("\nUsage:  cf FlushFile\n");
    printf("    FlushFile - File used to flush the cache, should be 128kb\n");

    return;

} /* DisplayUsage() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\clearmem\clearmem.c ===
/*** ClearMem.C - Win 32 clear memory
 *
 *
 * Title:
 *
 *	ClearMem - Win 32 clear memory Main File
 *
 *      Copyright (c) 1990-1994, Microsoft Corporation.
 *	Russ Blake.
 *
 *
 * Description:
 *
 *	This is the main part of the clear memory tool.
 *	It takes as a parameter a file to use to flush the memory.
 *
 *	     Usage:  clearmem filename [-q] [-d]
 *
 *			filename: name of file to use to flush the
 *				  memory.  Should be at least 128kb.
 *
 *
 *	The Clear Memory is organized as follows:
 *
 *	     o ClearMem.c ........ Tools main body
 *	     o ClearMem.h
 *
 *	     o cmUtl.c ..... clear memory utility routines
 *	     o cmUtl.h
 *
 *
 *
 *
 *
 *
 * Modification History:
 *
 *	90.03.08  RussBl -- Created (copy of response probe)
 *	92.07.24  MarkLea -- Added -t -w -b switches
 *					  -- Modified AccessSection algorithm.
 * 93.05.12  HonWahChan
 *               -- used total physical memory (instead of SECTION_SIZE);
 *               -- used GetTickCount() instead of timer calls.
 *
 *
 */

char *VERSION = "1.17x  (93.05.12)";



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "clearmem.h"
#include "cmUtl.h"



/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */
/* none */



/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

       __cdecl main        (int argc, char *argv[]);
STATIC RC Initialize     (int argc, char *argv[]);
STATIC RC Cleanup	 (void);
STATIC RC FlushCache	 (void);
STATIC RC AccessSection  (void);
STATIC RC ReadFlushFile  (void);
     void ParseCmdLine   (int argc, char *argv[]);
	 void Usage          (char *argv[], char *);


/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */
BOOL   	bQuiet,
		bRead = TRUE,
		bWrite;
BOOL   	bDebugBreakOnEntry;
ULONG  	ulMemSize,
		ulPageCount,
		ulTouchCount = 1;

ULONG_PTR	ulSectionSize;
/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/*********************************  m a i n  **********************************
 *
 *      main(argc, argv)
 *
 *      ENTRY   argc - number of input arguments
 *              argv - contains command line arguments
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

__cdecl main (int argc, char *argv[])
{
    RC	    rc;
    DWORD    ulFlushTime;	     // Total time for flushing
		
    ParseCmdLine (argc, argv);
	if(ulMemSize){
		ulSectionSize = ulMemSize * 1024 * 1024;
	}
	else {
      // get total physical memory size in the system
      MEMORYSTATUS   MemStat;

      GlobalMemoryStatus (&MemStat);
      ulSectionSize = MemStat.dwTotalPhys;
	}

//	ExitProcess(STATUS_SUCCESS);

    if (bDebugBreakOnEntry)
        DebugBreak();
	
	if (!bQuiet) {
        //
        // set initial total flushing time
        //
        ulFlushTime = GetTickCount() ;
    }


    //
    // Do initialization
    //
    rc = Initialize(argc, argv);
    if (Failed(rc, __FILE__, __LINE__, "main() - Initialize")) {
        return(rc);
    }

    //
    // Now flush the cache
    //

	rc = FlushCache();

    if (Failed(rc, __FILE__, __LINE__, "main() - FlushCache")) {
        return(rc);
    }

    if (!bQuiet) {
        ulFlushTime = GetTickCount() - ulFlushTime;
        printf("Elapsed Time for Flushing: %lu milliseconds \n", ulFlushTime);
    }
    //
    // Cleanup
    //
    rc = Cleanup();
    if (Failed(rc, __FILE__, __LINE__, "main() - Cleanup")) {
        return(rc);
    }

#ifdef CF_DEBUG_L1
    if (!bQuiet) {
        printf("| ==> Exiting PROCESS:  %s \n", CF_EXE );
    }
#endif

    if (bDebugBreakOnEntry)
		DebugBreak();
    ExitProcess(STATUS_SUCCESS);

} /* main() */





/***************************  I n i t i a l i z e  ****************************
 *
 *      Initialize(argc, argv) -
 *              Performs basic initializations (getting input arguments,
 *              creating semaphores, display debug info, ...)
 *
 *      ENTRY   argc - number of input arguments
 *              argv - list of input arguments
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

STATIC RC Initialize (int argc, char *argv[])
{
    int        i;

    //
    // Sign on message
    //

    if (!bQuiet) {
        printf("\nNT Win 32 Clear Memory.\n"
               "Copyright 1990-1993, Microsoft Corporation.\n"
               "Version %s\n\n", VERSION);
    }

#ifdef CF_DEBUG_L1
    //
    // Display debugging info
    //
    if (!bQuiet) {
        printf("/-------------------------------\n");
        printf("| %s:\n", CF_EXE);
        printf("|\n");
        for (i=0; i<argc; i++) {
	          printf("|         o argv[%i]=%s\n", i, argv[i]);
        }
        printf("\\-------------------------------\n");
    }
#else
    i;      // Prevent compiler from complaining about unreferenced variable
#endif



    return(STATUS_SUCCESS);

} /* Initialize() */




/******************************  C l e a n u p  *******************************
 *
 *	Cleanup(void) -
 *              Basic cleanup. (closing semaphores, freeing memory, ...)
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

STATIC RC Cleanup (void)
{

    return(STATUS_SUCCESS);

} /* Cleanup() */




/************************  F l u s h C a c h e	 *****************************
 *
 *	FlushCache(void) -
 *		Flushes the file cache by createing a large data
 *		segment, and touching every page to shrink the cache
 *		to 128kb, then reading in a 128kb file to clear the
 *		remaining cache
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

RC FlushCache (void)
{

RC    rc;

    //
    // First touch all the data pages
    //

#ifdef CF_DEBUG_L1
    if (!bQuiet) {
       printf("| ==> Start Flushing:  Access Section of size: %lu \n",
	         ulSectionSize );
    }
#endif

    rc = AccessSection();
    if (Failed(rc, __FILE__, __LINE__, "FlushCache() - AccessSection")) {
        return(rc);
    }

    //
    // Next read the flushing file to what's left of the cache
    //

#ifdef CF_DEBUG_L1
    if (!bQuiet) {
        printf("| ==> Start Flushing:  Read File: %s \n",
	         "FLUSH1" );
    }
#endif
//	while (ulTouchCount) {
		rc = ReadFlushFile();
//		--ulTouchCount;

		if (Failed(rc, __FILE__, __LINE__, "FlushCache() - Read Flush File")) {
			return(rc);
		}
//	}



    return(STATUS_SUCCESS);

} /* FlushCache() */




/************************  A c c e s s S e c t i o n  ************************
 *
 *	AccessSection(void) -
 *		Touches every page in the data section
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

RC AccessSection (void)
{

	RC    rc;
	ULONG uli,
                  ulj;
	PULONG	puSectionData;			//Points to data section for flushing memory

    //
    // Allocate virtual memory
    //
    if ( (puSectionData = (PULONG)VirtualAlloc(NULL,	       // New allocation
				    ulSectionSize,      // Size in bytes
				    MEM_RESERVE | MEM_COMMIT,
				    PAGE_READWRITE)) == NULL ) {	//Changed to READWRITE
        rc = GetLastError();
	Failed(rc, __FILE__, __LINE__, "AccessSection() - VirtualAlloc");
        return(rc);
    }

    //
    // Now touch every page of the section
    //
	if(bWrite){
		
		while (ulTouchCount) {
			puSectionData = &puSectionData[0];
			for ( uli = 0; uli < (ulSectionSize-1); uli+=sizeof(ULONG)) {
				*puSectionData = 0xFFFFFFFF;
				++puSectionData;
			}
			--ulTouchCount;
		}
	}
	if(bRead) {
//        DbgBreakPoint();
                ulj = 0;
		while (ulTouchCount) {
			for ( uli = 0; uli < ulSectionSize; uli += PAGESIZE ) {
			 ulj += *(puSectionData+(uli/sizeof(ULONG)));
			}
			--ulTouchCount;
		}
	}

	return(STATUS_SUCCESS);

} /* AccessSection() */


/************************  R e a d F l u s h F i l e  ************************
 *
 *	ReadFlushFile(void) -
 *		Touches every page in the flush file, non-sequentially
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

CHAR  chBuffer[PAGESIZE];

RC ReadFlushFile (void)
{
	RC    rc;
	SHORT sNewPos;
	ULONG uli;
	ULONG ulNumReads,
		  ulNumBytesRead;
	BOOL  bFileCreated;
	SHORT sFile;				// Indicates which of the three
								// files is being used to flush
	CHAR  chFlushFileName1[] = "FLUSH1";
	CHAR  chFlushFileName2[] = "FLUSH2";
	CHAR  chFlushFileName3[] = "FLUSH3";

	CHAR *pchFlushFileName[3] = { chFlushFileName1,
								  chFlushFileName2,
								  chFlushFileName3 };
	FILE *pfFlushFile;			// Points to the file used for
								// flushing the cache
	FILE *pfSaveFile[3];		// Remembers them for the close
	CHAR  achErrMsg[LINE_LEN];

    //
    // Assume no file is created: all three already exist
    //

    bFileCreated = FALSE;

    for (sFile = 0; sFile < NUM_FILES; sFile++) {

	//
	// First attempt to create the file
	//

	if ( (pfFlushFile = CreateFile(pchFlushFileName[sFile],
				       GENERIC_WRITE,
				       FILE_SHARE_READ,
				       NULL,
				       CREATE_NEW,
				       0,
				       0))
		  == INVALID_HANDLE_VALUE ) {

	    //
	    // Could not create the file
	    //

	    rc = GetLastError();

	    if (!(rc == ERROR_FILE_EXISTS || rc == ERROR_ACCESS_DENIED)) {

		//
		// Cannot create a new file
		//

		sprintf(achErrMsg,
			"ReadFlushFile() - Error creating %s: %lu",
			pchFlushFileName[sFile], rc);
		Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
		return(FILEARG_ERR);
	    }
	}
	else {

	    //
	    // New file has been created without difficulty
	    // Fill it with data
	    //

	    bFileCreated = TRUE;

	    for (uli = 0; uli < FLUSH_FILE_SIZE; uli += PAGESIZE) {
		if (!WriteFile(pfFlushFile,
			       &chBuffer,
			       PAGESIZE,
			       &ulNumBytesRead,
			       RESERVED_NULL)) {
		    rc = GetLastError();
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - Write File Record to New File");
		    return(rc);
		}
	    }

	    //
	    // Now close it for write, so we can open it for read access
	    //

	    if (!CloseHandle(pfFlushFile)) {
		rc = GetLastError();
		sprintf(achErrMsg, "ReadFlushFile() - Error closing %s: %lu",
			pchFlushFileName[sFile], rc);
		Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
		return(FILEARG_ERR);
	    }
	}
    }

    if (bFileCreated) {

	//
	// Wrote at least 1 file: wait for lazy writer to flush
	// data to disk
	//

	Sleep(LAZY_DELAY);

    }

    for (sFile = 0; sFile < NUM_FILES; sFile++) {

	if ((pfFlushFile = CreateFile( pchFlushFileName[sFile],
				       GENERIC_READ,
				       FILE_SHARE_READ,
				       NULL,
				       OPEN_EXISTING,
				       0,
				       0))
		  == INVALID_HANDLE_VALUE) {

	    //
	    // Cannot open an existing file
	    //

	    rc = GetLastError();
	    sprintf(achErrMsg,
		    "ReadFlushFile() - Error opening %s: %lu",
		    pchFlushFileName[sFile], rc);
	    Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
	    return(FILEARG_ERR);
	}

	//
	// Remember the handle for the close
	//

	pfSaveFile[sFile] = pfFlushFile;

	//
	// Read first record
	//

	if (!ReadFile( pfFlushFile,
		       &chBuffer,
		       1,
		       &ulNumBytesRead,
		       RESERVED_NULL)) {
	    rc = GetLastError();
	    Failed(rc, __FILE__, __LINE__,
		   "ReadFlushFile() - Read First Record");
	    return(rc);
	}



	ulNumReads = 1;


	while (++ulNumReads <= ulPageCount) {
	    if (ulNumReads & 1) {

		//
		// Read an odd record: read previous record
		// Move backward to start of prior record: -1 (start of
		// this record) -4096 (start of previous record) = -4097
		//

		if (SetFilePointer( pfFlushFile, -4097, 0L, FILE_CURRENT) == (DWORD)-1) {
		    rc = GetLastError();
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - Read Odd Record");
		    return(rc);
		}

		if (!ReadFile( pfFlushFile,
			       &chBuffer,
			       1,
			       &ulNumBytesRead,
			       RESERVED_NULL)) {
		    rc = GetLastError();
		    if (rc == ERROR_HANDLE_EOF)
			break;
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - SetPos Odd Record");
		    return(rc);
		}
	    }
	    else {

		//
		// Read an even record: read the one after the next record
		// Move forward to end of this record (4095) + 2 more
		// (8192) = 12287.  (But second record is special, 'cause
		// can't set file pointer negative initially.)
		//

		sNewPos = (SHORT) (ulNumReads == 2L ? 8191 : 12287);


		if (SetFilePointer( pfFlushFile, sNewPos, 0L, FILE_CURRENT) == (DWORD) -1) {
		    rc = GetLastError();
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - Read Even Record");
		    return(rc);
		}

		if (!ReadFile( pfFlushFile,
			       &chBuffer,
			       1,
			       &ulNumBytesRead,
			       RESERVED_NULL)) {
		    rc = GetLastError();
		    if (rc == ERROR_HANDLE_EOF)
			break;
		    Failed(rc, __FILE__, __LINE__,
			   "ReadFlushFile() - SetPos Even Record");
		    return(rc);
		}
	    }
	}
    }

    for (sFile = 0; sFile < NUM_FILES; sFile++) {

	//
	// Close the files
	//

	if (!CloseHandle(pfSaveFile[sFile])) {
	    rc = GetLastError();
	    sprintf(achErrMsg, "ReadFlushFile() - Error closing %s: %lu",
		    pchFlushFileName[sFile], rc);
	    Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
	    return(FILEARG_ERR);
	}
    }

    return(STATUS_SUCCESS);

} /* ReadFlushFile() */

/************************  R e a d F l u s h F i l e  ************************
 *
 *	parseCmdLine(void) -
 *		For Parsing the command line switches
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

 VOID ParseCmdLine (int argc, char *argv[])
 {
     char     *pchParam;
     int      iParamCount;

     for ( iParamCount = 1; iParamCount < argc; iParamCount++) {

         if (argv[iParamCount][0] == '-') {    /* process options */

             pchParam = &(argv[iParamCount][1]);

             while (*pchParam) {
                 switch (*pchParam) {
                     case '?':
                         Usage (argv, " ");
                         break;

                     case 'Q':
                     case 'q':
                         pchParam++;
                         bQuiet = TRUE;
                         break;

                     case 'd':
                     case 'D':   /* print banner */
                         pchParam++;						
                         bDebugBreakOnEntry = TRUE;
                         break;

					 case 'm':
					 case 'M':
						 ulMemSize = (ULONG)atol(&pchParam[1]);
						 if (ulPageCount > 32) {
							 Usage (argv, "Mem size must be less than the amount of physical memory!");
						 }
						 pchParam += strlen(pchParam);
						 break;

					 case 'p':
					 case 'P':
						 ulPageCount = (ULONG)atol(&pchParam[1]);
						 if (ulPageCount > 63) {
							 Usage (argv, "Page Count must be 63 or less!");
						 }
						 pchParam += strlen(pchParam);
						 break;


					 case 't':
					 case 'T':