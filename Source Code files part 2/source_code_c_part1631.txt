define MLSE1_MaintenanceLoopRej        (Output_t) 95
#define MLSE1_OUT_RELEASE_request       (Output_t) 96
#define MLSE1_T102Expiry                (Output_t) 97
#define MLSE2_MaintenanceLoopRej        (Output_t) 98
#define MLSE2_OUT_RELEASE_request       (Output_t) 99

// In-coming Request Mode (MLSE_IN) state functions
#define MLSE0_MaintenanceLoopRequest    (Output_t)100
#define MLSE1_MaintenanceLoopRequest    (Output_t)101
#define MLSE1_MaintenanceLoopOffCommand (Output_t)102
#define MLSE1_LOOP_response             (Output_t)103
#define MLSE1_IN_RELEASE_request        (Output_t)104
#define MLSE2_MaintenanceLoopRequest    (Output_t)105
#define MLSE2_MaintenanceLoopOffCommand (Output_t)106

// Master Slave Determination (MSDSE) state functions
#define DetRequestIdle                  (Output_t)107
#define MSDetIdle                       (Output_t)108
#define MSDetAckOutgoing                (Output_t)109
#define MSDetOutgoing                   (Output_t)110
#define MSDetRejOutgoing                (Output_t)111
#define MSDetReleaseOutgoing            (Output_t)112
#define T106ExpiryOutgoing              (Output_t)113
#define MSDetAckIncoming                (Output_t)114
#define MSDetIncoming                   (Output_t)115
#define MSDetRejIncoming                (Output_t)116
#define MSDetReleaseIncoming            (Output_t)117
#define T106ExpiryIncoming              (Output_t)118

// Round Trip Delay (RTDSE) state functions
#define RTDSE0_TRANSFER_request         (Output_t)119
#define RTDSE0_RoundTripDelayRequest    (Output_t)120
#define RTDSE1_TRANSFER_request         (Output_t)121
#define RTDSE1_RoundTripDelayRequest    (Output_t)122
#define RTDSE1_RoundTripDelayResponse   (Output_t)123
#define RTDSE1_T105Expiry               (Output_t)124

#define NUM_OUTPUTS                               125



// State definitions
typedef unsigned char State_t;



// Lookup Key definition
typedef unsigned long Key_t;


             
typedef enum
{
    INDETERMINATE,
    MASTER,
    SLAVE
} MS_Status_t;

typedef struct Object_tag
{
    struct Object_tag *pNext;           // Linked list pointer
    struct InstanceStruct *pInstance;   // H.245 instance structure pointer
    DWORD           dwInst;             // H.245 instance identifier
    unsigned int    uNestLevel;         // StateMachine recursive calls
    DWORD           dwTransId;          // Transaction Id from API
    DWORD           dwTimerId;          // Associated timer id
    Key_t           Key;                // Lookup key, e.g. channel number
    Entity_t        Entity;             // State Entity type, e.g. LCSE_OUT
    State_t         State;              // Current Entity state
    unsigned char   byInSequence;       // In-coming sequence number
    union
    {
        struct
        {
            unsigned short  wLoopType;
        } mlse;
        struct
        {
            unsigned int    sv_SDNUM;
            unsigned int    sv_NCOUNT;
        } msdse;
        MultiplexEntrySendRelease       mtse;
        RequestMultiplexEntryRelease    rmese;
    } u;                                // Entity-specific data
} Object_t;



/*  an instance will carry a table of object pointers     */
/*  to be allocated in fsminit by calloc.                 */
/*  Each dwInst passed from API or SRP should invoke the  */
/*  appropriate instance that contain the object table of */
/*  the protocol entities for this H.245 instance       */

typedef struct Fsm_Struct_tag
{
    Object_t *          Object_tbl[NUM_ENTITYS];// H.245 Signalling Entities
    DWORD               dwInst;                 // H.245 Instance Identifier
    MS_Status_t         sv_STATUS;              // MSDSE Status
    unsigned char       sv_TT;                  // MSDSE Terminal Type
    unsigned char       byCeseOutSequence;      // CESE_OUT sequence number
    unsigned char       byMtseOutSequence;      // MTSE_OUT sequence number
    unsigned char       byMrseOutSequence;      // MRSE_OUT sequence number
    unsigned char       byRtdseSequence;        // RTDSE sequence number
} Fsm_Struct_t;



/* FSM function prototypes */

HRESULT
PduParseOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu,
               Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate);

HRESULT
PduParseIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu,
               Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate);

int
ObjectDestroy    (Object_t *pObject);

Object_t *
ObjectFind(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key);

HRESULT
StateMachine     (Object_t *pObject, PDU_t *pPdu, Event_t Event);

HRESULT
FsmTimerEvent(struct InstanceStruct *pInstance, DWORD dwTimerId, Object_t *pObject, Event_t Event);

#define FsmStartTimer(pObject,pfnCallback,uTicks) \
    {H245ASSERT((pObject)->dwTimerId == 0);       \
     (pObject)->dwTimerId=H245StartTimer((pObject)->pInstance,pObject,pfnCallback,uTicks);}

#define FsmStopTimer(pObject) \
    {H245StopTimer((pObject)->pInstance,(pObject)->dwTimerId); (pObject)->dwTimerId = 0;}

#endif // H245FSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\fsmexpor.h ===
/***********************************************************************
 *                                                                     *
 * Filename: FSMEXPOR.H                                                *
 * Module:   H245 SubSystem                                            *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMEXPOR.H  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/FSMEXPOR.H_v  $
 * 
 *    Rev 1.6   09 Dec 1996 13:40:44   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.5   19 Jul 1996 12:02:54   EHOWARDX
 * Eliminated event definitions. FSM functions now use same events as API,
 * which are defined in H245API.H.
 * 
 *    Rev 1.4   30 May 1996 23:38:14   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.3   29 May 1996 15:21:26   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.2   28 May 1996 14:09:52   EHOWARDX
 * Tel Aviv update.
 *
 ***********************************************************************/

#include "h245asn1.h"

typedef MltmdSystmCntrlMssg PDU_t;

/* FSM initialization */
HRESULT
Fsm_init    (struct InstanceStruct *pInstance);

/* FSM shutdown */
HRESULT
Fsm_shutdown(struct InstanceStruct *pInstance);

/* Process PDU received from remote peer */
HRESULT
FsmIncoming (struct InstanceStruct *pInstance, PDU_t *pPdu);

/* Process PDU from H.245 client */
HRESULT
FsmOutgoing (struct InstanceStruct *pInstance, PDU_t *pPdu, DWORD dwTransId);

/* send a confirm to API */
HRESULT
H245FsmConfirm    (PDU_t                 *pPdu,
                   DWORD                  dwEvent,
                   struct InstanceStruct *pInstance,
                   DWORD                  dwTransId,
                   HRESULT                lError);

/* send an indication to API */
HRESULT
H245FsmIndication (PDU_t                 *pPdu,
                   DWORD                  dwEvent,
                   struct InstanceStruct *pInstance,
                   DWORD                  dwTransId,
                   HRESULT                lError);



/*********************************/
/* Errors passed up to the API */
/*********************************/

/* Session initialization indications */
#define SESSION_INIT            2101 /* after first term cap exchange */
#define SESSION_FAILED          2102 /* 1st Term caps failed */

 /* finite state machine is successful */
#define FSM_OK                  0
 /* define one reject for all requests */
#define REJECT                  2100

/* define one timer expiry error for all signallling entities */
#define TIMER_EXPIRY            2200

/* master slave failed */
#define MS_FAILED               2105

/* open unidirectional/bidirectional errors */
#define ERROR_A_INAPPROPRIATE   2106    /* inappropriate message */
#define ERROR_B_INAPPROPRIATE   2107    /* inappropriate message */
#define ERROR_C_INAPPROPRIATE   2108    /* inappropriate message */
#define ERROR_D_TIMEOUT         2109    /* timeout               */
#define ERROR_E_INAPPROPRIATE   2110    /* inappropriate message */
#define ERROR_F_TIMEOUT         2111    /* Timer expiry at incoming BLCSE */

extern unsigned int     uN100;          // Master Slave Determination
extern unsigned int     uT101;          // Capability Exchange
extern unsigned int     uT102;          // Maintenance Loop
extern unsigned int     uT103;          // Logical Channel Signalling
extern unsigned int     uT104;          // H.223 Multiplex Table
extern unsigned int     uT105;          // Round Trip Delay
extern unsigned int     uT106;          // Master Slave Determination
extern unsigned int     uT107;          // Request Multiplex Entry
extern unsigned int     uT108;          // Send Logical Channel
extern unsigned int     uT109;          // Mode Request
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\h245sys.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				   
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245sys.h  $						
 *  $Revision:   1.0  $							
 *  $Modtime:   27 Feb 1996 09:50:50  $					
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/h245sys.h_v  $	
 * 
 *    Rev 1.0   09 May 1996 21:04:50   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   27 Feb 1996 09:50:50   DABROWN1
 * Removed file from project
 * 
 *    Rev 1.0   21 Feb 1996 16:25:06   DABROWN1
 * Initial revision.
 *  $Ident$
 *
 *****************************************************************************/

#ifndef H245SYS_H
#define H245SYS_H

#error "This file has bee removed from project and the struct MEMALLOC is included in-line"

/************************************/
/* MALLOC ABSTRACTION
/************************************/
typedef struct MEMALLOC {
	DWORD	dwSize;
	void	*pBuffer;
} MEMALLOC, *PMEMALLOC;

#endif //H245SYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\mrse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mrse.h                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MRSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MRSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:24   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:52   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:44:02   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:11:14   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mode (MRSE_OUT) state functions
HRESULT MRSE0_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeAckF           (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeRejF           (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_T109ExpiryF               (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mode (MRSE_OUT) state functions
HRESULT MRSE0_RequestModeF              (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeF              (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_RequestModeReleaseF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_TRANSFER_responseF        (Object_t *pObject, PDU_t *pPdu);
HRESULT MRSE1_REJECT_requestF           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\muxentry.h ===
/***********************************************************************
 *                                                                     *
 * Filename: muxentry.h                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MUXENTRY.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MUXENTRY.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:54   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.3.1.2   15 Apr 1996 10:44:00   EHOWARDX
 * Update.
 * 
 *    Rev 1.3.1.1   10 Apr 1996 21:07:32   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.3.1.0   05 Apr 1996 11:48:12   EHOWARDX
 * Branched.
 *
 *    Rev 1.3   29 Feb 1996 20:42:40   helgebax
 * No change.
 *
 *    Rev 1.2   28 Feb 1996 15:54:28   EHOWARDX
 * Completed first pass MTSE implementation.
 *                                                                     *
 ***********************************************************************/

// Out-going Multiplex Table (MTSE_OUT) state functions
HRESULT MTSE0_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_TRANSFER_requestF         (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendAckF    (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendRejF    (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_T104ExpiryF               (Object_t *pObject, PDU_t *pPdu);

// In-coming Multiplex Table (MTSE_OUT) state functions
HRESULT MTSE0_MultiplexEntrySendF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_MultiplexEntrySendReleaseF(Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_TRANSFER_responseF        (Object_t *pObject, PDU_t *pPdu);
HRESULT MTSE1_REJECT_requestF           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\rmese.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rmese.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RMESE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RMESE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:30   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:43:28   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:07:58   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mux Entry (RMESE_OUT) state functions
HRESULT RMESE0_SEND_requestF            (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_SEND_requestF            (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryAckF      (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryRejF      (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_T107ExpiryF              (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mux Entry (RMESE_OUT) state functions
HRESULT RMESE0_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_RequestMuxEntryReleaseF  (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_SEND_responseF           (Object_t *pObject, PDU_t *pPdu);
HRESULT RMESE1_REJECT_requestF          (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\openu.h ===
/***********************************************************************
 *                                                                     *
 * Filename: openu.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENU.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/OPENU.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:28   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   15 Apr 1996 10:43:56   EHOWARDX
 * Update.
 * 
 *    Rev 1.6.1.1   10 Apr 1996 21:06:40   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.6.1.0   05 Apr 1996 12:14:26   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Open Uni-directional Logical Channel Out-going state functions
HRESULT establishReleased               (Object_t *pObject, PDU_t *pPdu);
HRESULT openAckAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseAwaitingE                (Object_t *pObject, PDU_t *pPdu);
HRESULT t103AwaitingE                   (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseEstablished              (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejEstablished              (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAckEstablished             (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAckAwaitingR               (Object_t *pObject, PDU_t *pPdu);
HRESULT openRejAwaitingR                (Object_t *pObject, PDU_t *pPdu);
HRESULT t103AwaitingR                   (Object_t *pObject, PDU_t *pPdu);
HRESULT establishAwaitingR              (Object_t *pObject, PDU_t *pPdu);

// Open Uni-directional Logical Channel In-coming state functions
HRESULT openReleased                    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeReleased                   (Object_t *pObject, PDU_t *pPdu);
HRESULT responseAwaiting                (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseAwaiting                 (Object_t *pObject, PDU_t *pPdu);
HRESULT closeAwaiting                   (Object_t *pObject, PDU_t *pPdu);
HRESULT openAwaiting                    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeEstablished                (Object_t *pObject, PDU_t *pPdu);
HRESULT openEstablished                 (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\mlse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mlse.h                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MLSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MLSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:40:58   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:22   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:52   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.2   15 Apr 1996 10:43:08   EHOWARDX
 * Update.
 * 
 *    Rev 1.1   11 Apr 1996 13:21:10   EHOWARDX
 * Deleted unused function.
 * 
 *    Rev 1.0   10 Apr 1996 21:08:30   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Mode (MLSE_OUT) state functions
HRESULT MLSE0_LOOP_requestF             (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopAckF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_T102ExpiryF               (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Mode (MLSE_IN) state functions
HRESULT MLSE0_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_LOOP_responseF            (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE1_IN_RELEASE_requestF       (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT MLSE2_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\rqstcls.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rqstcls.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RQSTCLS.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RQSTCLS.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:06   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:32   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:58   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.3.1.2   15 Apr 1996 10:43:52   EHOWARDX
 * Update.
 * 
 *    Rev 1.3.1.1   10 Apr 1996 21:07:22   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.3.1.0   05 Apr 1996 11:48:24   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Out-going Request Close Logical Channel state functions
HRESULT closeRequestIdle                (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseAckAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseRejAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT t108ExpiryAwaitingR             (Object_t *pObject, PDU_t *pPdu);

// In-coming Request Close Logical Channel state functions
HRESULT requestCloseIdle                (Object_t *pObject, PDU_t *pPdu);
HRESULT closeResponseAwaitingR          (Object_t *pObject, PDU_t *pPdu);
HRESULT rejectRequestAwaitingR          (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseReleaseAwaitingR    (Object_t *pObject, PDU_t *pPdu);
HRESULT requestCloseAwaitingR           (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\mstrslv.h ===
/***********************************************************************
 *                                                                     *
 * Filename: mstrslv.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MSTRSLV.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/MSTRSLV.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:41:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:24   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:54   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.4.1.2   15 Apr 1996 10:43:40   EHOWARDX
 * Update.
 * 
 *    Rev 1.4.1.1   10 Apr 1996 21:08:34   EHOWARDX
 * Deleted No-op functions and moved state definitions to .C file.
 * 
 *    Rev 1.4.1.0   05 Apr 1996 12:14:32   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Master Slave Determination state functions
HRESULT detRequestIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetIdle                       (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetAckOutgoing                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetOutgoing                   (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetRejOutgoing                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetReleaseOutgoing            (Object_t *pObject, PDU_t *pPdu);
HRESULT t106ExpiryOutgoing              (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetAckIncoming                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetIncoming                   (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetRejIncoming                (Object_t *pObject, PDU_t *pPdu);
HRESULT msDetReleaseIncoming            (Object_t *pObject, PDU_t *pPdu);
HRESULT t106ExpiryIncoming              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\openb.h ===
/***********************************************************************
 *                                                                     *
 * Filename: openb.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENB.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/OPENB.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:42:52   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:56   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.4.1.3   09 May 1996 19:42:38   EHOWARDX
 * 
 * Removed gratuitious outgoing waiting for confirm state that was
 * not in the ITI SDLs.
 * 
 *    Rev 1.4.1.2   15 Apr 1996 10:44:10   EHOWARDX
 * Update.
 * 
 *    Rev 1.4.1.1   10 Apr 1996 21:07:14   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.4.1.0   05 Apr 1996 12:14:20   helgebax
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Open Bi-directional Logical Channel Out-going state functions
HRESULT establishReqBReleased           (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelAckBAwaitingE        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBAwaitingE        (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBOutAwaitingE         (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingE            (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBEstablished          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBEstablished      (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelAckBEstablished     (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelAckAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelRejBAwaitingR        (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingR            (Object_t *pObject, PDU_t *pPdu);
HRESULT establishReqAwaitingR           (Object_t *pObject, PDU_t *pPdu);

// Open Bi-directional Logical Channel In-coming state functions
HRESULT openChannelBReleased            (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBReleased           (Object_t *pObject, PDU_t *pPdu);
HRESULT establishResBAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT releaseReqBInAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBAwaitingE          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBAwaitingE           (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelConfirmBAwaitingE    (Object_t *pObject, PDU_t *pPdu);
HRESULT t103ExpiryBAwaitingC            (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelConfirmBAwaitingC    (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBAwaitingC          (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBAwaitingC           (Object_t *pObject, PDU_t *pPdu);
HRESULT closeChannelBEstablished        (Object_t *pObject, PDU_t *pPdu);
HRESULT openChannelBEstablished         (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\sr_api.h ===
/******************************************************************************
 *
 *  File:  sr_api.h
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   sr_api.h  $
 *  $Revision:   1.5  $
 *  $Modtime:   Mar 04 1997 17:32:54  $
 *  $History$
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/sr_api.h_v  $
 * 
 *    Rev 1.5   Mar 04 1997 17:52:48   tomitowx
 * process detach fix
 * 
 *    Rev 1.4   19 Jul 1996 12:04:34   EHOWARDX
 * 
 * Eliminated H245DLL #define (God only knows why Dan put it in this
 * file in the first place!)
 * 
 *    Rev 1.3   05 Jun 1996 17:20:20   EHOWARDX
 * Changed initializeASN1 and terminateASN1 prototypes back to int.
 * 
 *    Rev 1.2   05 Jun 1996 16:37:18   EHOWARDX
 * Further work in converting to HRESULT.
 * 
 *    Rev 1.1   30 May 1996 23:38:34   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:05:00   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.8   09 May 1996 19:38:18   EHOWARDX
 * Redesigned locking logic and added new functionality.
 *
 *    Rev 1.7   15 Apr 1996 13:00:14   DABROWN1
 *
 * Added SR initialize trace logging call
 *
 *    Rev 1.6   12 Apr 1996 10:27:40   dabrown1
 *
 * removed WINAPI/windows references
 *  $Ident$
 *
 *****************************************************************************/
#ifndef STRICT 
#define STRICT 
#endif

#ifndef _SR_API_H
#define _SR_API_H

#include "h245com.h"
#include "h245asn1.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

///////////////////////////////////////////////////////////////
///
/// TRACE Logging Defines
///
///////////////////////////////////////////////////////////////
#define H245_TRACE_ENABLED  TRUE


////////////////////////////////////////////////////////////////////
//
// Callback routines for Link Layer
//
////////////////////////////////////////////////////////////////////
void h245ReceiveComplete(DWORD    h245Instance,
                         HRESULT  dwMessage,
                         PBYTE    pbDataBuf,
                         DWORD    dwLength);

void h245SendComplete   (DWORD    h245Instance,
                         HRESULT  dwMessage,
                         PBYTE    pbDataBuf,
                         DWORD    dwLength);
HRESULT
sendRcvFlushPDUs
(
    struct InstanceStruct * pInstance,
    DWORD                   dwDirection,
    BOOL                    bShutdown
);

void
srInitializeLogging
(
    struct InstanceStruct * pInstance,
    BOOL                    bTracingEnabled
);

int     initializeASN1 (ASN1_CODER_INFO *);
int     terminateASN1  (ASN1_CODER_INFO *);
HRESULT sendRcvInit    (struct InstanceStruct * pInstance);
HRESULT sendRcvShutdown(struct InstanceStruct * pInstance);
HRESULT sendPDU        (struct InstanceStruct * pInstance, MltmdSystmCntrlMssg *pPdu);
HRESULT sendRcvShutdown_ProcessDetach(	struct InstanceStruct *pInstance, BOOL fProcessDetach);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _SRP_API_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\rtdse.h ===
/***********************************************************************
 *                                                                     *
 * Filename: rtdse.h                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RTDSE.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/RTDSE.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:06   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:32   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:04:58   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   15 Apr 1996 10:43:46   EHOWARDX
 * Update.
 * 
 *    Rev 1.0   10 Apr 1996 21:09:14   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

// Round Trip Delay (RTDSE) state functions
HRESULT RTDSE0_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE0_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_RoundTripDelayResponseF  (Object_t *pObject, PDU_t *pPdu);
HRESULT RTDSE1_T105ExpiryF              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\termcap.h ===
/***********************************************************************
 *                                                                     *
 * Filename: termcap.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   TERMCAP.H  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:42:50  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/TERMCAP.H_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:43:08   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   30 May 1996 23:38:34   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:05:00   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   15 Apr 1996 10:43:50   EHOWARDX
 * Update.
 * 
 *    Rev 1.6.1.1   10 Apr 1996 21:07:26   EHOWARDX
 * Deleted No-op functions; moved state defines to .C file.
 * 
 *    Rev 1.6.1.0   05 Apr 1996 11:47:56   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

// Terminal Capability Exchange (CESE) Out-going state functions
HRESULT requestCapIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapAckAwaiting              (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapRejAwaiting              (Object_t *pObject, PDU_t *pPdu);
HRESULT t101ExpiryAwaiting              (Object_t *pObject, PDU_t *pPdu);

// Terminal Capability Exchange (CESE) Out-going state functions
HRESULT termCapSetIdle                  (Object_t *pObject, PDU_t *pPdu);
HRESULT responseCapAwaiting             (Object_t *pObject, PDU_t *pPdu);
HRESULT rejectCapAwaiting               (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapReleaseAwaiting          (Object_t *pObject, PDU_t *pPdu);
HRESULT termCapSetAwaiting              (Object_t *pObject, PDU_t *pPdu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\api_up.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   api_up.c  $
 *  $Revision:   1.33  $
 *  $Modtime:   06 Feb 1997 14:37:24  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\api_up.c_v  $
 * 
 *    Rev 1.33   06 Feb 1997 18:14:22   SBELL1
 * took out ossDecoding of returnFunction in FunctionNotSupported PDU.
 * 
 *    Rev 1.32   05 Feb 1997 16:46:42   EHOWARDX
 * Was allocating nLength bytes, not WCHARS, for UserInputIndication
 * ASCII to Unicode conversion. Changed to allocate nLength WCHARs.
 * 
 *    Rev 1.31   06 Jan 1997 20:38:18   EHOWARDX
 * 
 * Changed H245_CONF_CLOSE and H245_CONF_REQ_CLOSE to fill in
 * AccRej with H245_REJ for any errors.
 * 
 *    Rev 1.30   19 Dec 1996 21:00:56   EHOWARDX
 * Oops! H245_IND_OPEN_CONF can occur from T103 timeout (it's unique among
 * indications; it's the only one that can happen in response to a timeout!)
 * 
 *    Rev 1.29   19 Dec 1996 17:18:22   EHOWARDX
 * Changed to use h245asn1.h definitions instead of _setof3 and _setof8.
 * 
 *    Rev 1.28   18 Dec 1996 16:33:18   EHOWARDX
 * 
 * Fixed bug in Master Slave Determination Kludge.
 * 
 *    Rev 1.27   17 Dec 1996 17:13:20   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 * 
 *    Rev 1.26   12 Dec 1996 15:57:12   EHOWARDX
 * Master Slave Determination kludge.
 * 
 *    Rev 1.25   21 Oct 1996 16:07:38   EHOWARDX
 * Modified to make sure H245_INDETERMINATE is returned and Master/Slave
 * status if determination fails.
 * 
 *    Rev 1.24   17 Oct 1996 18:17:14   EHOWARDX
 * Changed general string to always be Unicode.
 * 
 *    Rev 1.23   14 Oct 1996 14:01:12   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.22   27 Aug 1996 10:54:16   unknown
 * Deleted redundant lines.
 * 
 *    Rev 1.22   27 Aug 1996 10:52:28   unknown
 * Deleted redundant lines.
 * 
 *    Rev 1.22   27 Aug 1996 09:54:12   unknown
 * Deleted redundant lines.
 * 
 *    Rev 1.21   26 Aug 1996 14:19:18   EHOWARDX
 * Added code to send FunctionNotUnderstood indication to remote peer
 * if receive callback returns H245_ERROR_NOSUP.
 * 
 *    Rev 1.20   20 Aug 1996 14:44:40   EHOWARDX
 * Changed H245_IND_COMM_MODE_RESPONSE and H245_IND_COMM_MODE_COMMAND
 * callbacks to fill in DataType field in Cap as per Mike Andrews' request.
 * 
 *    Rev 1.19   15 Aug 1996 15:20:24   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 * 
 *    Rev 1.18   15 Aug 1996 09:34:20   EHOWARDX
 * Made TOTCAP and MUX structure in process_open_ind static since we are
 * accessing pointers to them after return from the function.
 * 
 *    Rev 1.17   29 Jul 1996 19:33:00   EHOWARDX
 * 
 * Fixed bug in flow control - missing break in restriction switch statement.
 * 
 *    Rev 1.16   19 Jul 1996 14:11:26   EHOWARDX
 * 
 * Added indication callback structure for CommunicationModeResponse
 * and CommunicationModeCommand.
 * 
 *    Rev 1.15   19 Jul 1996 12:48:00   EHOWARDX
 * 
 * Multipoint clean-up.
 * 
 *    Rev 1.14   09 Jul 1996 17:09:28   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 * 
 *    Rev 1.13   01 Jul 1996 22:13:04   EHOWARDX
 * 
 * Added Conference and CommunicationMode structures and functions.
 * 
 *    Rev 1.12   18 Jun 1996 14:50:28   EHOWARDX
 * 
 * Changed MLSE confirm handling.
 * 
 *    Rev 1.11   14 Jun 1996 18:57:52   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.10   10 Jun 1996 16:55:34   EHOWARDX
 * Removed #include "h245init.x"
 * 
 *    Rev 1.9   06 Jun 1996 18:45:52   EHOWARDX
 * Added check for null dwTransId to Tracker routines; changed to use
 * tracker routines instead of PLOCK macros.
 * 
 *    Rev 1.8   04 Jun 1996 13:56:46   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.7   30 May 1996 23:39:00   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.6   29 May 1996 15:20:06   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.5   28 May 1996 14:22:58   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.4   20 May 1996 22:17:58   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.3   16 May 1996 19:40:46   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.2   16 May 1996 15:59:24   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.1   13 May 1996 23:16:26   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.0   09 May 1996 21:06:08   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.23.1.11   09 May 1996 19:31:30   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.23.1.10   01 May 1996 19:30:32   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address types to H245_xxx.
 *
 *    Rev 1.23.1.9   29 Apr 1996 16:02:58   EHOWARDX
 * Changed callback to give second parameters as pointer to specific message
 * instead of pointer to general PDU structure.
 *
 *    Rev 1.23.1.8   27 Apr 1996 21:09:40   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.23.1.7   26 Apr 1996 15:54:34   EHOWARDX
 * Added H.225.0 Capability support; Changed Capability indication
 * to only callback once with PDU.
 *
 *    Rev 1.23.1.6   24 Apr 1996 20:53:56   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.23.1.5   23 Apr 1996 14:45:28   EHOWARDX
 * Disabled Curt's "Conflict Resolution".
 *
 *    Rev 1.23.1.4   19 Apr 1996 12:55:10   EHOWARDX
 * Updated to 1.29
 *
 *    Rev 1.23.1.3   17 Apr 1996 14:37:38   unknown
 * Added load_H222_param(), load_VGMUX_param(), and load_H2250_param() and
 * modified process_open_ind() to use them.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:10:32   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.23.1.1   03 Apr 1996 17:15:00   EHOWARDX
 * No change.
 *
 *    Rev 1.23.1.0   03 Apr 1996 15:54:04   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.23   01 Apr 1996 16:46:20   cjutzi
 *
 * - changed tracker structure
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.22   29 Mar 1996 14:54:28   cjutzi
 * - added UserInput,
 *
 *    Rev 1.21   28 Mar 1996 15:57:46   cjutzi
 * - removed ASSERT line 1290.. close can occur on any channel at any time
 *
 *    Rev 1.20   27 Mar 1996 08:36:40   cjutzi
 * - removed PDU from stack.. made them dynamically allocated
 *
 *    Rev 1.19   26 Mar 1996 13:48:30   cjutzi
 *
 * - dwPreserved in the callback routine was uninitialized..
 *
 *    Rev 1.18   18 Mar 1996 15:23:30   cjutzi
 *
 *
 *
 *    Rev 1.17   13 Mar 1996 14:14:02   cjutzi
 *
 * - clean up and added ASSERTs ..
 *
 *    Rev 1.16   13 Mar 1996 12:06:12   cjutzi
 *
 * - fixed .. CONFIRM open.. for hani.. It released the tracker..
 *     was supposed to simply update the state to IDLE..
 *
 *    Rev 1.15   13 Mar 1996 09:22:12   cjutzi
 *
 * - removed CRITICAL SECTIONS
 *
 *    Rev 1.14   12 Mar 1996 15:52:32   cjutzi
 *
 * - fixed master slave (forgot a break)
 * - fixed callback bug w/ cleanup on termcaps.
 * - implemented End Session
 * - fixed shutdown
 * - Implemented Locking (big changes here.. )
 *
 *    Rev 1.13   08 Mar 1996 14:04:18   cjutzi
 *
 * - implemented the upcall for mux table entries..
 * - implemented capabillity descriptor callback
 *
 *    Rev 1.12   05 Mar 1996 17:36:28   cjutzi
 *
 * - added MasterSlave indication message
 * - remove bzero/bcopy and changed free call
 * - implemented Mux Table down.. (not up)
 *
 *    Rev 1.11   01 Mar 1996 14:16:08   cjutzi
 *
 * - added hani's error messages.. MasterSlave_FAILED.. oppss.. Forgot..
 *
 *    Rev 1.10   01 Mar 1996 13:47:58   cjutzi
 *
 * - added hani's new fsm id's
 *
 *    Rev 1.9   29 Feb 1996 17:26:16   cjutzi
 * - bi-directional channel open working
 *
 *    Rev 1.8   27 Feb 1996 14:56:30   cjutzi
 *
 * - fixed termcap_ack.. pdu was not being zero'd out..
 * - cleaned up the code alittle..
 *
 *    Rev 1.7   26 Feb 1996 17:22:40   cjutzi
 *
 * - Misc Command Indication added
 *
 *    Rev 1.6   26 Feb 1996 11:05:48   cjutzi
 *
 * - lot's o-changes.. (sorry)
 *
 *    Rev 1.5   16 Feb 1996 13:01:54   cjutzi
 *
 *  - got open / close / request close working in both directions.
 *
 *    Rev 1.4   15 Feb 1996 14:11:46   cjutzi
 *
 * - added muxt table to incoming open..
 *
 *    Rev 1.3   15 Feb 1996 10:51:56   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - changed callback for IND_OPEN
 * - changed constants IND_OPEN/IND_OPEN_NEEDSRSP
 * - cleaned up the open.
 * - modified H223 stuff
 *
 *    Rev 1.2   09 Feb 1996 16:58:28   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "h245asn1.h"
#include "fsmexpor.h"
#include "api_util.x"
#include "pdu.x"



HRESULT
LoadUnicastAddress  (H245_TRANSPORT_ADDRESS_T *pOut,
                     UnicastAddress           *pIn)
{
  switch (pIn->choice)
  {
  case UnicastAddress_iPAddress_chosen:
    pOut->type = H245_IP_UNICAST;
    memcpy(pOut->u.ip.network,
           pIn->u.UnicastAddress_iPAddress.network.value,
           4);
    pOut->u.ip.tsapIdentifier = pIn->u.UnicastAddress_iPAddress.tsapIdentifier;
    break;

  case iPXAddress_chosen:
    pOut->type = H245_IPX_UNICAST;
    memcpy(pOut->u.ipx.node,
           pIn->u.iPXAddress.node.value,
           6);
    memcpy(pOut->u.ipx.netnum,
           pIn->u.iPXAddress.netnum.value,
           4);
    memcpy(pOut->u.ipx.tsapIdentifier,
           pIn->u.iPXAddress.tsapIdentifier.value,
           2);
    break;

  case UncstAddrss_iP6Address_chosen:
    pOut->type = H245_IP6_UNICAST;
    memcpy(pOut->u.ip6.network,
           pIn->u.UncstAddrss_iP6Address.network.value,
           16);
    pOut->u.ip6.tsapIdentifier = pIn->u.UncstAddrss_iP6Address.tsapIdentifier;
    break;

  case netBios_chosen:
    pOut->type = H245_NETBIOS_UNICAST;
    memcpy(pOut->u.netBios, pIn->u.netBios.value, 16);
    break;

  case iPSourceRouteAddress_chosen:
    switch (pIn->u.iPSourceRouteAddress.routing.choice)
    {
    case strict_chosen:
      pOut->type = H245_IPSSR_UNICAST;
      break;

    case loose_chosen:
      pOut->type = H245_IPLSR_UNICAST;
      break;

    default:
      return H245_ERROR_INVALID_DATA_FORMAT;
    } // switch
    memcpy(pOut->u.ipSourceRoute.network,
           pIn->u.iPSourceRouteAddress.network.value,
           4);
    pOut->u.ipSourceRoute.tsapIdentifier = pIn->u.iPSourceRouteAddress.tsapIdentifier;
    // TBD - handle route
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
  return H245_ERROR_OK;
} // LoadUnicastAddress()



HRESULT
LoadMulticastAddress(H245_TRANSPORT_ADDRESS_T *pOut,
                     MulticastAddress         *pIn)
{
  switch (pIn->choice)
  {
  case MltcstAddrss_iPAddress_chosen:
    pOut->type = H245_IP_MULTICAST;
    memcpy(pOut->u.ip.network,
           pIn->u.MltcstAddrss_iPAddress.network.value,
           4);
    pOut->u.ip.tsapIdentifier = pIn->u.MltcstAddrss_iPAddress.tsapIdentifier;
    break;

  case MltcstAddrss_iP6Address_chosen:
    pOut->type = H245_IP6_MULTICAST;
    memcpy(pOut->u.ip6.network,
           pIn->u.MltcstAddrss_iP6Address.network.value,
           16);
    pOut->u.ip6.tsapIdentifier = pIn->u.MltcstAddrss_iP6Address.tsapIdentifier;
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
  return H245_ERROR_OK;
} // LoadMulticastAddress()



HRESULT
LoadTransportAddress(H245_TRANSPORT_ADDRESS_T  *pOut,
                     TransportAddress          *pIn)
{
  switch (pIn->choice)
  {
  case unicastAddress_chosen:
    return LoadUnicastAddress  (pOut, &pIn->u.unicastAddress);

  case multicastAddress_chosen:
    return LoadMulticastAddress(pOut, &pIn->u.multicastAddress);

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
} // LoadTransportAddress()



HRESULT
LoadCommModeEntry(H245_COMM_MODE_ENTRY_T       *pOut,
                  CommunicationModeTableEntry  *pIn)
{
  HRESULT   lResult;

  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & CMTEy_nnStndrd_present)
  {
    pOut->pNonStandard = pIn->CMTEy_nnStndrd;
  }

  pOut->sessionID = (unsigned char)pIn->sessionID;

  if (pIn->bit_mask & CMTEy_assctdSssnID_present)
  {
    pOut->associatedSessionID = (unsigned char)pIn->CMTEy_assctdSssnID;
    pOut->associatedSessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & terminalLabel_present)
  {
    pOut->terminalLabel = pIn->terminalLabel;
    pOut->terminalLabelPresent = TRUE;
  }

  pOut->pSessionDescription       = pIn->sessionDescription.value;
  pOut->wSessionDescriptionLength = (WORD) pIn->sessionDescription.length;

  switch (pIn->dataType.choice)
  {
  case dataType_videoData_chosen:
    pOut->dataType.DataType = H245_DATA_VIDEO;
    break;

  case dataType_audioData_chosen:
    pOut->dataType.DataType = H245_DATA_AUDIO;
    break;

  case dataType_data_chosen:
    pOut->dataType.DataType = H245_DATA_DATA;
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch

  lResult = build_totcap_cap_n_client_from_capability ((struct Capability *)&pIn->dataType,
                                                       pOut->dataType.DataType,
                                                       pIn->dataType.u.dataType_videoData.choice,
                                                       &pOut->dataType);
  if (lResult != H245_ERROR_OK)
    return lResult;

  if (pIn->bit_mask & CMTEy_mdChnnl_present)
  {
    lResult = LoadTransportAddress(&pOut->mediaChannel, &pIn->CMTEy_mdChnnl);
    if (lResult != H245_ERROR_OK)
      return lResult;
    pOut->mediaChannelPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdGrntdDlvry_present)
  {
    pOut->mediaGuaranteed = pIn->CMTEy_mdGrntdDlvry;
    pOut->mediaGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdCntrlChnnl_present)
  {
    lResult = LoadTransportAddress(&pOut->mediaControlChannel, &pIn->CMTEy_mdCntrlChnnl);
    if (lResult != H245_ERROR_OK)
      return lResult;
    pOut->mediaControlChannelPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdCntrlGrntdDlvry_present)
  {
    pOut->mediaControlGuaranteed = pIn->CMTEy_mdCntrlGrntdDlvry;
    pOut->mediaControlGuaranteedPresent = TRUE;
  }

  return H245_ERROR_OK;
} // LoadCommModeEntry()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   load_H222_param
 *              load_H223_param
 *              load_VGMUX_param
 *              load_H2250_param
 *              load_H2250ACK_param
 *
 * DESCRIPTION
 *
 *              This routine builds local API-style Logical Parameters out of ASN.1
 *              structure passed to it
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
load_H222_param (H245_H222_LOGICAL_PARAM_T *    pOut,   /* output */
                 H222LogicalChannelParameters * pIn)    /* input  */
{
  /* See setup_H220_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->resourceID   = pIn->resourceID;
  pOut->subChannelID = pIn->subChannelID;
  if (pIn->bit_mask & pcr_pid_present)
  {
    pOut->pcr_pidPresent = TRUE;
    pOut->pcr_pid = pIn->pcr_pid;
  }
  if (pIn->bit_mask & programDescriptors_present)
  {
    pOut->programDescriptors.length = pIn->programDescriptors.length;
    pOut->programDescriptors.value  = pIn->programDescriptors.value;
  }
  if (pIn->bit_mask & streamDescriptors_present)
  {
    pOut->streamDescriptors.length = pIn->streamDescriptors.length;
    pOut->streamDescriptors.value  = pIn->streamDescriptors.value;
  }
  return H245_ERROR_OK;
} // load_H222_param()

static HRESULT
load_H223_param (H245_H223_LOGICAL_PARAM_T *    pOut,   /* output */
                 H223LogicalChannelParameters * pIn)    /* input  */
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H223_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->SegmentFlag = pIn->segmentableFlag;

  switch (pIn->adaptationLayerType.choice)
    {
    case H223LCPs_aLTp_nnStndrd_chosen:
      lError = CopyNonStandardParameter(&pOut->H223_NONSTD,
                                         &pIn->adaptationLayerType.u.H223LCPs_aLTp_nnStndrd);
      pOut->AlType = H245_H223_AL_NONSTD;
      break;
    case H223LCPs_aLTp_al1Frmd_chosen:
      pOut->AlType = H245_H223_AL_AL1FRAMED;
      break;
    case H223LCPs_aLTp_al1NtFrmd_chosen:
      pOut->AlType = H245_H223_AL_AL1NOTFRAMED;
      break;
    case H223LCPs_aLTp_a2WSNs_1_chosen:
      pOut->AlType = H245_H223_AL_AL2NOSEQ;
      break;
    case H223LCPs_aLTp_a2WSNs_2_chosen:
      pOut->AlType = H245_H223_AL_AL2SEQ;
      break;
    case H223LCPs_aLTp_al3_chosen:
      pOut->AlType = H245_H223_AL_AL3;
      pOut->CtlFldOctet = (unsigned char)pIn->adaptationLayerType.u.H223LCPs_aLTp_al3.controlFieldOctets;
      pOut->SndBufSize  = pIn->adaptationLayerType.u.H223LCPs_aLTp_al3.sendBufferSize;
      break;
    } /* switch */

  return lError;
} // load_H223_param()

static HRESULT
load_VGMUX_param(H245_VGMUX_LOGICAL_PARAM_T  *pOut,   /* output */
                 V76LogicalChannelParameters *pIn)    /* input  */
{
  /* See setup_VGMUX_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->crcLength             = pIn->hdlcParameters.crcLength.choice;
  pOut->n401                  = pIn->hdlcParameters.n401;
  pOut->loopbackTestProcedure = pIn->hdlcParameters.loopbackTestProcedure;
  pOut->suspendResume         = pIn->suspendResume.choice;
  pOut->uIH                   = pIn->uIH;
  pOut->mode                  = pIn->mode.choice;
  switch (pIn->mode.choice)
  {
  case eRM_chosen:
    pOut->windowSize          = pIn->mode.u.eRM.windowSize;
    pOut->recovery            = pIn->mode.u.eRM.recovery.choice;
    break;
  } // switch
  pOut->audioHeaderPresent    = pIn->v75Parameters.audioHeaderPresent;
  return H245_ERROR_OK;
} // load_VGMUX_param()

static HRESULT
load_H2250_param(H245_H2250_LOGICAL_PARAM_T *   pOut,   /* output */
                 H2250LogicalChannelParameters *pIn)    /* input  */
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H2250_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & H2250LCPs_nnStndrd_present)
  {
    pOut->nonStandardList = pIn->H2250LCPs_nnStndrd;
  }

  pOut->sessionID = (unsigned char) pIn->sessionID;

  if (pIn->bit_mask & H2250LCPs_assctdSssnID_present)
  {
    pOut->associatedSessionID = (unsigned char)pIn->H2250LCPs_assctdSssnID;
    pOut->associatedSessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_mdChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaChannel,
                           &pIn->H2250LCPs_mdChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCPs_mdGrntdDlvry_present)
  {
    pOut->mediaGuaranteed = pIn->H2250LCPs_mdGrntdDlvry;
    pOut->mediaGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_mdCntrlChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaControlChannel,
                                    &pIn->H2250LCPs_mdCntrlChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaControlChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCPs_mCGDy_present)
  {
    pOut->mediaControlGuaranteed = pIn->H2250LCPs_mCGDy;
    pOut->mediaControlGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & silenceSuppression_present)
  {
    pOut->silenceSuppression = pIn->silenceSuppression;
    pOut->silenceSuppressionPresent = TRUE;
  }

  if (pIn->bit_mask & destination_present)
  {
    pOut->destination = pIn->destination;
    pOut->destinationPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_dRTPPTp_present)
  {
    pOut->dynamicRTPPayloadType = (unsigned char)pIn->H2250LCPs_dRTPPTp;
    pOut->dynamicRTPPayloadTypePresent = TRUE;
  }

  if (pIn->bit_mask & mediaPacketization_present)
  {
    switch (pIn->mediaPacketization.choice)
    {
    case h261aVideoPacketization_chosen:
      pOut->h261aVideoPacketization = TRUE;
      break;

    default:
      return H245_ERROR_INVALID_DATA_FORMAT;
    } // switch
  }

  return lError;
} // load_H2250_param()

static HRESULT
load_H2250ACK_param(H245_H2250ACK_LOGICAL_PARAM_T *     pOut,
                    H2250LgclChnnlAckPrmtrs *           pIn)
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H2250ACK_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & H2250LCAPs_nnStndrd_present)
  {
    pOut->nonStandardList = pIn->H2250LCAPs_nnStndrd;
  }

  if (pIn->bit_mask & sessionID_present)
  {
    pOut->sessionID = (unsigned char) pIn->sessionID;
    pOut->sessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCAPs_mdChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaChannel,
                                    &pIn->H2250LCAPs_mdChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCAPs_mdCntrlChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaControlChannel,
                                     &pIn->H2250LCAPs_mdCntrlChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaControlChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCAPs_dRTPPTp_present)
  {
    pOut->dynamicRTPPayloadType = (unsigned char)pIn->H2250LCAPs_dRTPPTp;
    pOut->dynamicRTPPayloadTypePresent = TRUE;
  }

  return lError;
} // load_H2250ACK_param()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   build_element_list_from_mux -
 *
 * DESCRIPTION
 *              recursively build H245_MUX_ENTRY_ELEMENT_T list from
 *              ASN1 mux table descriptor entrys.
 *
 * RETURN:
 *
 *****************************************************************************/
static H245_MUX_ENTRY_ELEMENT_T *
build_element_list_from_mux (MultiplexElement *p_ASN_mux_el,
                             H245_ACC_REJ_T   *p_acc_rej)
{
  DWORD                     ii;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el_tmp = NULL;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el_lst = NULL;

  if (!(p_mux_el = (H245_MUX_ENTRY_ELEMENT_T *)H245_malloc(sizeof(H245_MUX_ENTRY_ELEMENT_T))))
    {
      /* too complicated.. ran out of memory */
      H245TRACE(0,1,"build_element_list_from_mux : H245_ERROR_NOMEM");
      *p_acc_rej = H245_REJ_MUX_COMPLICATED;
      return NULL;
    }

  /* zero it out */
  memset (p_mux_el, 0, sizeof(H245_MUX_ENTRY_ELEMENT_T));

  switch (p_ASN_mux_el->type.choice)
    {
    case typ_logicalChannelNumber_chosen:
      /* assign as a logical channel */
      p_mux_el->Kind = H245_MUX_LOGICAL_CHANNEL;
      p_mux_el->u.Channel = p_ASN_mux_el->type.u.typ_logicalChannelNumber;
      break;
    case subElementList_chosen:
      {
        /* if the sub element list doesn't exist .. no go           */
        /* if the sub element list has less than 2 entries.. no go. */
        if ((!p_ASN_mux_el->type.u.subElementList) ||
            (p_ASN_mux_el->type.u.subElementList->count < 2))
          {
            /* invalid Element list.. */
            H245TRACE(0,1,"build_element_list_from_mux : << ERROR >> Element Count < 2");
            *p_acc_rej = H245_REJ;
            free_mux_el_list (p_mux_el);
            return NULL;
          }

        /* assign as entry element */
        p_mux_el->Kind = H245_MUX_ENTRY_ELEMENT;

        /* ok.. for every sub element in the list */
        for (ii=0;ii<p_ASN_mux_el->type.u.subElementList->count;ii++)
          {
            if (!(p_mux_el_tmp = build_element_list_from_mux (&p_ASN_mux_el->type.u.subElementList->value[ii], p_acc_rej)))
              {
                /* *p_acc_rej is set from below */
                free_mux_el_list (p_mux_el);
                return NULL;
              }

            /* if first on the down sub element list.. assign to sub    */
            /* element  portion of mux_el                               */

            if (!p_mux_el_lst)
              p_mux_el->u.pMuxTblEntryElem = p_mux_el_tmp;
            /* otherwise.. just a list.. add it on.. */
            else
              p_mux_el_lst->pNext = p_mux_el_tmp;

            p_mux_el_lst = p_mux_el_tmp;
          }
      }
      break;
    default:
      /* Un supported structure */
      H245TRACE(0,1,"build_element_list_from_mux : INVALID MUX TABLE ENTRY PDU 'type.choice' unknown");
      *p_acc_rej = H245_REJ;
      free_mux_el_list (p_mux_el);
      return NULL;
    }

  switch (p_ASN_mux_el->repeatCount.choice)
    {
    case repeatCount_finite_chosen:
      p_mux_el->RepeatCount = p_ASN_mux_el->repeatCount.u.repeatCount_finite;
      break;
    case untilClosingFlag_chosen:
      p_mux_el->RepeatCount = 0;
      break;
    default:
      /* Un supported structure */
      H245TRACE(0,1,"build_element_list_from_mux : INVALID MUX TABLE ENTRY PDU 'repeatCount.choice' unknown");
      *p_acc_rej = H245_REJ;
      free_mux_el_list (p_mux_el);
      return NULL;
      break;
    }

  return p_mux_el;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_mux_table_ind
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/
static H245_MUX_TABLE_T *
process_mux_table_ind (MltmdSystmCntrlMssg      *p_pdu_ind,
                       unsigned short           *p_seq,
                       H245_ACC_REJ_MUX_T       rej_mux,
                       DWORD                    *p_rej_cnt,
                       DWORD                    *p_acc_cnt)
{
  UINT                          ii;                     /* generic counter */
  MultiplexEntrySend           *p_ASN_mux;              /* ans1 mux entry  */
  MultiplexEntryDescriptorLink  p_ASN_med_desc_lnk;     /* asn1 mux entry descriptor */
  int                           mux_entry;              /* current mux entry descc   */
  H245_MUX_TABLE_T             *p_mux_table_list = NULL;

  H245ASSERT(p_pdu_ind->choice == MltmdSystmCntrlMssg_rqst_chosen);
  H245ASSERT(p_pdu_ind->u.MltmdSystmCntrlMssg_rqst.choice == multiplexEntrySend_chosen);

  /* initialize rej_mux */
  for (ii=0;ii<15;ii++)
    {
      rej_mux[ii].AccRej = H245_ACC;
      rej_mux[ii].MuxEntryId = 0;
    }
  *p_rej_cnt = 0;
  *p_acc_cnt = 0;

  p_ASN_mux = &(p_pdu_ind->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend);

  /* get sequence number */
  *p_seq = p_ASN_mux->sequenceNumber;

  /* this should never happen.. */
  if (!(p_ASN_mux->multiplexEntryDescriptors))
    return NULL;

  /* for each descriptor.. ie mux table entry  */
  for (p_ASN_med_desc_lnk = p_ASN_mux->multiplexEntryDescriptors, mux_entry=0;
       p_ASN_med_desc_lnk;
       p_ASN_med_desc_lnk = p_ASN_med_desc_lnk->next, mux_entry++)
    {
      /* remove descriptor from table */
      H245_MUX_TABLE_T  *p_mux_table;
      H245_MUX_TABLE_T  *p_mux_table_lst = NULL;

      if (!(p_mux_table = (H245_MUX_TABLE_T *)H245_malloc(sizeof(H245_MUX_TABLE_T))))
        {
          /* houston.. we have a problem !!!!!!!! */
          /* rejet this one..                     */
          /* and move on..                        */

          rej_mux[mux_entry].MuxEntryId = p_ASN_med_desc_lnk->value.multiplexTableEntryNumber;
          rej_mux[mux_entry].AccRej  = H245_REJ;
          (*p_rej_cnt)++;
          continue;
        }

      /* zero it out */
      memset (p_mux_table, 0, sizeof(H245_MUX_TABLE_T));

      /* assign mux table entry */
      rej_mux[mux_entry].MuxEntryId = (DWORD)
        p_mux_table->MuxEntryId =
          p_ASN_med_desc_lnk->value.multiplexTableEntryNumber;

      /* if element is not present */
      if (p_ASN_med_desc_lnk->value.bit_mask != elementList_present)
        {
          p_mux_table->pMuxTblEntryElem = NULL;
          rej_mux[mux_entry].AccRej = H245_ACC;
          (*p_acc_cnt)++;
        }
      /* if element list present */
      else
        {
          H245_MUX_ENTRY_ELEMENT_T *p_mux_el_lst = NULL;
          H245_MUX_ENTRY_ELEMENT_T *p_mux_el_tmp = NULL;

          /* start if off.. w/ ok */
          rej_mux[mux_entry].AccRej = H245_ACC;

          /* for each element in the element list..    */
          /* build the subelements.. if error .. free  */
          /* what youve done so far.. and break out    */
          for (ii=0;
               ii < p_ASN_med_desc_lnk->value.elementList.count;
               ii++)
            {
              /* if any of the elements fail.. flag the entry w/ reject reason  */
              /*        (this is done inside the build_element_list..)          */
              /*   and break out.. continue on with the next descriptor         */
              if (!(p_mux_el_tmp = build_element_list_from_mux (&(p_ASN_med_desc_lnk->value.elementList.value[ii]),&(rej_mux[mux_entry].AccRej))))
                {
                  /* free the list.. */
                  free_mux_el_list (p_mux_table->pMuxTblEntryElem);
                  break;
                }

              /* ***************************** */
              /* LINK IN THE MUX ENTRY ELEMENT */
              /* ***************************** */

              /* if first time through         */
              if (!p_mux_el_lst)
                p_mux_table->pMuxTblEntryElem = p_mux_el_tmp;
              /* otherwize .. just tag on the end */
              else
                p_mux_el_lst->pNext = p_mux_el_tmp;

              p_mux_el_lst = p_mux_el_tmp;

            } /* for each element in descriptor list */

        } /* if element list present */

      /* if you've accepted the mux table entry descriptor */
      if (rej_mux[mux_entry].AccRej == H245_ACC)
        {
          /* indicate an accept */
          (*p_acc_cnt)++;

          /* ******************************** */
          /* LINK IN THE MUX TABLE DESCRIPTOR */
          /* ******************************** */

          /* first table entry on the list.. (first time through) */
          if (!p_mux_table_list)
            p_mux_table_list = p_mux_table;
          else
            p_mux_table_lst->pNext = p_mux_table;

          p_mux_table_lst = p_mux_table;
        }
      else
        {
          /* indicate a reject */
          (*p_rej_cnt)++;

          /* otherwise.. free it and move on to something better */
          H245_free(p_mux_table);
        }

    } /* for each desriptor in the list */

  return p_mux_table_list;

} /* procedure */



# pragma warning( disable : 4100 )

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__cap_table
 *
 * DESCRIPTION  allocates a new cap link and copies the capabiliites.
 *              links into the tiven capabilityTableLink, and if
 *              Parameters are NONSTANDARD does some gymnastics to copy
 *              data so it can be used..
 *
 *              NOTE: Copied data must be freed when capability is deleted.
 *                    see where the capability is deleted for exceptions
 *                    for "NONSTD" parameter sets .. (this is not pretty)
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
process_term_cap_set_ind__cap_table ( struct InstanceStruct        *pInstance,
                                      struct TerminalCapabilitySet *pTermCapSet,
                                      CapabilityTableLink           pCapLink,
                                      MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  H245_TOTCAP_T                 totcap;
  CapabilityTableLink           pNewLink;
  HRESULT                       lError;

  while (pCapLink)
  {
    if (build_totcap_from_captbl (&totcap,
                                  pCapLink,
                                  H245_REMOTE) == H245_ERROR_OK)
    {
      /* ok.. assume the CapId is set.. find it in the remote table  */
      /* if it exists, delete it so we can add new one in it's place */
      pNewLink = find_capid_by_entrynumber( pTermCapSet, totcap.CapId);
      if (pNewLink)
      {
        del_cap_link ( pTermCapSet, pNewLink );
      }

      /* ok.. if you've deleted the cap.. now see if there is a new one to take it's place */
      if (pCapLink->value.bit_mask & capability_present)
      {
        /* load and link into remote table entry */
        pNewLink = alloc_link_cap_entry (pTermCapSet);
        if (!pNewLink)
        {
          return H245_ERROR_NORESOURCE;
        }

        /* copy the cap over to the remote entry */
        pNewLink->value = pCapLink->value;

        // If it's nonstandard, the above didn't work, so fix it up...
        lError = H245_ERROR_OK;
        switch (pCapLink->value.capability.choice)
        {
        case Capability_nonStandard_chosen:
          lError = CopyNonStandardParameter(&pNewLink->value.capability.u.Capability_nonStandard,
                                             &pCapLink->value.capability.u.Capability_nonStandard);
          break;

        case receiveVideoCapability_chosen:
        case transmitVideoCapability_chosen:
        case rcvAndTrnsmtVdCpblty_chosen:
          if (pCapLink->value.capability.u.receiveVideoCapability.choice == VdCpblty_nonStandard_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard,
                                               &pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard);
          }
          break;

        case receiveAudioCapability_chosen:
        case transmitAudioCapability_chosen:
        case rcvAndTrnsmtAdCpblty_chosen:
          if (pCapLink->value.capability.u.receiveAudioCapability.choice == AdCpblty_nonStandard_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard,
                                               &pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard);
          }
          break;

        case rcvDtApplctnCpblty_chosen:
        case trnsmtDtApplctnCpblty_chosen:
        case rATDACy_chosen :
          if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice == DACy_applctn_nnStndrd_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd,
                                               &pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd);
          }
          break;

        } // switch
        if (lError != H245_ERROR_OK)
          return lError;
      } /* if capability_present */
    } /* if build_totcap_from_captbl succeeded */

    pCapLink = pCapLink->next;
  } /* for all entries in link */

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__cap_desc
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
process_term_cap_set_ind__cap_desc (struct InstanceStruct        *pInstance,
                                    struct TerminalCapabilitySet *pTermCapSet,
                                    CapabilityDescriptor         *pReqCapDesc,
                                    MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  unsigned int                  uCapDescNumber;
  CapabilityDescriptor         *pCapDesc;
  unsigned int                  uCapDesc;
  SmltnsCpbltsLink              pSimCap;
  SmltnsCpbltsLink              pReqSimCap;
  CapabilityDescriptor          TempCapDesc;
  unsigned int                  uSimCount;
  unsigned int                  uReqAltCount;
  unsigned int                  uReqAltCap;
  unsigned int                  uAltCap;
  HRESULT                        lError = H245_ERROR_OK;

  uCapDescNumber = pReqCapDesc->capabilityDescriptorNumber & 255;
  H245TRACE(pInstance->dwInst,20,"API:process_term_cap_set_ind - Remote Capability Descriptor #%d", uCapDescNumber);

  // Find corresponding capability descriptor
  pCapDesc = NULL;
  for (uCapDesc = 0; uCapDesc < pTermCapSet->capabilityDescriptors.count; ++uCapDesc)
  {
    if (pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber == uCapDescNumber)
    {
      // Deallocate old simultaneous capabilities
      pCapDesc = &pTermCapSet->capabilityDescriptors.value[uCapDesc];
      if (pCapDesc->smltnsCpblts)
        dealloc_simultaneous_cap(pCapDesc);
      break;
    } // if
  } // for

  if (pCapDesc == NULL)
  {
    // Allocate a new terminal capability descriptor
    H245ASSERT(pTermCapSet->capabilityDescriptors.count < 256);
    pCapDesc = &pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count++];
  }

  H245ASSERT(pCapDesc->smltnsCpblts == NULL);
  if (!(pReqCapDesc->bit_mask & smltnsCpblts_present))
  {
    // Delete the terminal capability descriptor
    pTermCapSet->capabilityDescriptors.count--;
    *pCapDesc = pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
    return H245_ERROR_OK;
  }

  // Make a copy of the (volatile) new capability descriptor
  pCapDesc->bit_mask                   = 0;
  pCapDesc->capabilityDescriptorNumber = (CapabilityDescriptorNumber)uCapDescNumber;
  pCapDesc->smltnsCpblts               = NULL;

  // We copy the linked list to a temporary so that it
  // gets reversed twice and ends up in same order
  TempCapDesc.smltnsCpblts = NULL;
  uSimCount = 0;
  pReqSimCap = pReqCapDesc->smltnsCpblts;
  while (pReqSimCap)
  {
    // Allocate a new simultaneous capability list element
    pSimCap = H245_malloc(sizeof(*pSimCap));
    if (pSimCap == NULL)
    {
      H245TRACE(pInstance->dwInst, 1,
                "API:process_term_cap_set_ind: malloc failed");
      lError = H245_ERROR_NOMEM;
      break;
    }

    // Verify that each alternative capability in the request
    // simultaneous capability is valid
    // if so, copy it
    uAltCap = 0;
    uReqAltCount  = pReqSimCap->value.count;
    for (uReqAltCap = 0; uReqAltCap < uReqAltCount; ++uReqAltCap)
    {
      // Is the Capability in the remote Capability Table?
      if (find_capid_by_entrynumber (pTermCapSet, pReqSimCap->value.value[uReqAltCap]) == NULL)
      {
        // can't find the Capability
        H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - Remote Capability Table Entry #%d not found",
                  pReqSimCap->value.value[uReqAltCap]);
        lError = H245_ERROR_UNKNOWN;
      }
      else if (uAltCap >= H245_MAX_ALTCAPS)
      {
        // Exceeded arbitrary limit
        H245TRACE(pInstance->dwInst,1,
                  "API:process_term_cap_set_ind - Too many alternative capabilities (%d)",
                  uAltCap);
        lError = H245_ERROR_NORESOURCE;
        break;
      }
      else
      {
        // Copy the capability number
        pSimCap->value.value[uAltCap++] = pReqSimCap->value.value[uReqAltCap];
      }
    } /* for alternative capbilities */

    if (uAltCap)
    {
      // Verify that we have not exceeded arbitrary limit
      if (++uSimCount > H245_MAX_SIMCAPS)
      {
        // Exceeded arbitrary limit
        H245TRACE(pInstance->dwInst, 1,
                  "API:process_term_cap_set_ind - Too many simultaneous capabilities (%d)",
                  uSimCount);
        H245_free(pSimCap);
        lError = H245_ERROR_NORESOURCE;
      }
      else
      {
        // Add new simultaneous capability to the temporary list
        pSimCap->value.count = (unsigned short)uAltCap;
        pSimCap->next = TempCapDesc.smltnsCpblts;
        TempCapDesc.smltnsCpblts = pSimCap;
      }
    }
    else
    {
      H245TRACE(pInstance->dwInst, 1,
                "API:process_term_cap_set_ind - No valid alternative capabilities found");
      H245_free(pSimCap);
      lError = H245_ERROR_UNKNOWN;
    }

    pReqSimCap = pReqSimCap->next;
  } // while

  while (TempCapDesc.smltnsCpblts)
  {
    // Move elements from temporary to final linked list
    pSimCap = TempCapDesc.smltnsCpblts;
    TempCapDesc.smltnsCpblts = pSimCap->next;
    pSimCap->next = pCapDesc->smltnsCpblts;
    pCapDesc->smltnsCpblts = pSimCap;
  }

  // Error if no simultaneous capabilities found
  if (pCapDesc->smltnsCpblts)
  {
    pCapDesc->bit_mask |= smltnsCpblts_present;
  }
  else
  {
    H245TRACE(pInstance->dwInst, 1,
              "API:process_term_cap_set_ind - No simultaneous capabilities found");
    lError = H245_ERROR_UNKNOWN;
  }

  return lError;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__mux_cap
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 * NOTES:
 *  We do a copy to set up a capability structure, then do another copy via
 *  H245CopyCap() to create a copy of the capability because the structure
 *  given to us by the ASN.1 decoded may contain pointers to data which will
 *  be deallocated upon return.
 *
 *****************************************************************************/
static HRESULT
process_term_cap_set_ind__mux_cap  (struct InstanceStruct        *pInstance,
                                    struct TerminalCapabilitySet *pTermCapSet,
                                    MultiplexCapability *        pReqMuxCap,
                                    MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  H245_TOTCAP_T         TotCap;

  // Initialize temporary capability structure
  memset(&TotCap, 0, sizeof(TotCap));
  TotCap.Dir      = H245_CAPDIR_RMTRXTX;
  TotCap.DataType = H245_DATA_MUX;

  // Get rid of old remote multiplex capability, if any
  if (pTermCapSet->bit_mask & multiplexCapability_present)
  {
    del_mux_cap(pTermCapSet);
  }

  switch (pReqMuxCap->choice)
  {
  case MltplxCpblty_nonStandard_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_NONSTD = pReqMuxCap->u.MltplxCpblty_nonStandard;
    TotCap.ClientType = H245_CLIENT_MUX_NONSTD;
    H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind__mux_cap - Nonstandard Mux not yet supported");
    break;

  case h222Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H222 = pReqMuxCap->u.h222Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H222;
    break;

  case h223Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H223 = pReqMuxCap->u.h223Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H223;
    break;

  case v76Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_VGMUX = pReqMuxCap->u.v76Capability;
    TotCap.ClientType = H245_CLIENT_MUX_VGMUX;
    break;

  case h2250Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H2250 = pReqMuxCap->u.h2250Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H2250;
    break;

  default:
    H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind__mux_cap - invalid mux cap type %d",
              &pReqMuxCap->choice);
    return H245_ERROR_NOSUP;
  }

  return set_mux_cap(pInstance, pTermCapSet, &TotCap);
}

# pragma warning( default : 4100 )

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind
 *
 * DESCRIPTION
 *
 **************************************************************
 *
 * (TBD) .. this module will ack all terminal capbilities
 *            need to build reject.. (maybe later??)
 *
 * THIS IS A BIG TBD
 *
 **************************************************************
 *
 * RETURN:
 *
 *****************************************************************************/
static HRESULT
process_term_cap_set_ind (struct InstanceStruct *pInstance,
                          MltmdSystmCntrlMssg   *p_pdu_req,
                          MltmdSystmCntrlMssg   *p_pdu_rsp)
{
  HRESULT                   lError = H245_ERROR_OK;
  TerminalCapabilitySet   *pTermCapSet;

  H245ASSERT (p_pdu_req->choice == MltmdSystmCntrlMssg_rqst_chosen);
  H245ASSERT (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.choice == terminalCapabilitySet_chosen);
  H245TRACE(pInstance->dwInst,10,"API:process_term_cap_set_ind <-");

  /* build ack response */
  p_pdu_rsp->choice = MSCMg_rspns_chosen;
  p_pdu_rsp->u.MSCMg_rspns.choice = terminalCapabilitySetAck_chosen;
  p_pdu_rsp->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber =
    p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;

  pTermCapSet = &pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  //***************************
  // Deal with Capability Table
  //***************************
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & capabilityTable_present)
  {
	CapabilityTableLink pCapTable = p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable;
	if (pCapTable->value.capability.choice == Capability_nonStandard_chosen &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice == h221NonStandard_chosen &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35CountryCode	 == 0xB5 && 
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35Extension	 == 0x42 &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == 0x8080)
    {
	  pInstance->bMasterSlaveKludge = TRUE;
	  pCapTable = pCapTable->next;
    }
    lError = process_term_cap_set_ind__cap_table(pInstance,
                                                  pTermCapSet,
                                                  pCapTable,
                                                  p_pdu_rsp);
    if (lError != H245_ERROR_OK)
    {
      H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - cap table error %s",map_api_error(lError));
      /* (TBC) need to reject somehow */
    }
  } /* if Capability Table Present */

  //**************************************
  // Deal with Capability Descriptor Table
  // i.e. simultaneous capabilities
  // NOTE: these are not held in the remote terminal capbility set
  //**************************************
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & capabilityDescriptors_present)
  {
    int des_cnt;
    int ii;

    des_cnt = p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityDescriptors.count;
    H245TRACE(pInstance->dwInst,20,"API:process_term_cap_set_ind - %d Simultaneous Capabilities",des_cnt);
    for (ii = 0; ii < des_cnt; ++ii)
    {
      lError = process_term_cap_set_ind__cap_desc (pInstance,
                                                    pTermCapSet,
                                                    &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.
                                                      terminalCapabilitySet.capabilityDescriptors.value[ii],
                                                    p_pdu_rsp);
      if (lError != H245_ERROR_OK)
      {
        H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - cap desc error %s",map_api_error(lError));
        /* (TBC) need to reject somehow */
      }
    } /* for each descriptor */
  } /* if capability descriptor present */

  /**************************************/
  /* Deal with Multiplex Capability set */
  /**************************************/
  /* NOTE: these are not held in the remote terminal capability set */
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & multiplexCapability_present)
  {
    /* send up the indication to the client for each new entry */
    lError = process_term_cap_set_ind__mux_cap(pInstance,
                                                pTermCapSet,
                                                &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.
                                                  terminalCapabilitySet.multiplexCapability,
                                                p_pdu_rsp);
    if (lError != H245_ERROR_OK)
    {
      H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - mux cap error %s",map_api_error(lError));
      /* (TBC) need to reject somehow */
    }
  }

  H245TRACE(pInstance->dwInst,10,"API:process_term_cap_set_ind -> OK");
  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_open_ind
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 * ASSUME:
 *              Callback must happen inside this routine since the
 *              datastructures passed back to the application are allocated
 *              in this moudle.
 *
 *              Application will <<<COPY>>> the needed data structures when
 *              callback occurs..
 *
 *****************************************************************************/

static HRESULT
process_open_ind (struct InstanceStruct *pInstance,
                  MltmdSystmCntrlMssg   *p_pdu_req,
                  unsigned short        *p_FwdChan,     /* for return on error */
                  H245_ACC_REJ_T        *p_AccRej,      /* for return error */
                  H245_CONF_IND_T       *p_conf_ind)    /* out */
{
  static H245_TOTCAP_T          rx_totcap;      /* for receive caps */
  static H245_TOTCAP_T          tx_totcap;      /* for transmit caps */
  static H245_MUX_T             RxMux;
  static H245_MUX_T             TxMux;
  unsigned short                choice;         /* tmp for type of cap to routine */
  HRESULT                       lError;
  Tracker_T                     *p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:process_open_ind <-");

  *p_AccRej = H245_ACC;

  /********************************/
  /* check for forward parameters */
  /********************************/

  /* get forward Rx channel id */
  p_conf_ind->u.Indication.u.IndOpen.RxChannel =
    *p_FwdChan =
      p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;

  H245TRACE(pInstance->dwInst,20,"API:process_open_ind - channel = %d",p_conf_ind->u.Indication.u.IndOpen.RxChannel);

  /* get port number */
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
        u.openLogicalChannel.forwardLogicalChannelParameters.bit_mask & fLCPs_prtNmbr_present)
    {
      p_conf_ind->u.Indication.u.IndOpen.RxPort =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.fLCPs_prtNmbr;
    }
  else
    p_conf_ind->u.Indication.u.IndOpen.RxPort = H245_INVALID_PORT_NUMBER;

  /* ok.. forward data type selection */
  switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.dataType.choice)
    {
    case DataType_nonStandard_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx nonStandard");
      /* (TBD) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
    case nullData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx nullData");
      /* (TBD) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
      break;
    case DataType_videoData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx videoData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_VIDEO;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_videoData.choice;
      break;
    case DataType_audioData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx audioData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_AUDIO;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_audioData.choice;
      break;
    case DataType_data_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx dataData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_DATA;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_data.application.choice;
      break;
    case encryptionData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx encryptionData");
      /* (TBC) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx encryptionData");
      /* (TBC) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_UNKNOWN;
      return H245_ERROR_NOSUP;
      break;
    }

  /* load the tot cap's capability and client from capability                   */
  /* this will give us the client type and the Capability for the indication    */
  if ((lError = build_totcap_cap_n_client_from_capability ((struct Capability *)
                          &(p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                            u.openLogicalChannel.forwardLogicalChannelParameters.dataType),
                          p_conf_ind->u.Indication.u.IndOpen.RxDataType,
                          choice,
                          &rx_totcap)) != H245_ERROR_OK)
    {
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return lError;
    }

  /* load it from the totcap you just built.. then toss it aside.. like an empty can of soda.. */
  p_conf_ind->u.Indication.u.IndOpen.RxClientType = rx_totcap.ClientType;
  p_conf_ind->u.Indication.u.IndOpen.pRxCap = &(rx_totcap.Cap);

  /* H.223/H.222 Mux table parameters for forward channel */
  p_conf_ind->u.Indication.u.IndOpen.pRxMux = &RxMux;
  switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.choice)
    {
    case fLCPs_mPs_h223LCPs_chosen:
      /* H.223 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H223;
      lError = load_H223_param(&RxMux.u.H223,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h223LCPs);
      if (lError != H245_ERROR_OK)
        {
          *p_AccRej = H245_REJ_AL_COMB;
          return lError;
        }
      break;

    case fLCPs_mPs_h222LCPs_chosen:
      /* H.222 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H222;
      lError = load_H222_param(&RxMux.u.H222,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs);
      break;

    case fLCPs_mPs_v76LCPs_chosen:
      /* VGMUX Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_VGMUX;
      lError =load_VGMUX_param(&RxMux.u.VGMUX,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_v76LCPs);
      break;

    case fLCPs_mPs_h2250LCPs_chosen:
      /* H.225.0 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H2250;
      lError = load_H2250_param(&RxMux.u.H2250,
                               &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h2250LCPs);
      break;

    default:
      lError = H245_ERROR_NOSUP;
    } // switch
  if (lError != H245_ERROR_OK)
    {
      *p_AccRej = H245_REJ;
      return lError;
    }

  /********************************/
  /* check for reverse parameters */
  /********************************/
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
    {
      switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.choice)
        {
        case DataType_nonStandard_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx nonStandard");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;

        case nullData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx nullData");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;
          break;

        case DataType_videoData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx videoData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_VIDEO;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_videoData.choice;
          break;

        case DataType_audioData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx audioData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_AUDIO;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_audioData.choice;
          break;

        case DataType_data_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx dataData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_DATA;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_data.application.choice;
          break;

        case encryptionData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx encryptionData");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;
          break;

        default:
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_UNKNOWN;
          H245TRACE(pInstance->dwInst,1,"API:process_open_ind - unknown choice %d",
                    p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.choice);
          return H245_ERROR_NOSUP;
        }

      /* load the tot cap's capability and client from capability */
      if ((lError = build_totcap_cap_n_client_from_capability ((struct Capability *)
                                      &(p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                                        u.openLogicalChannel.OLCl_rLCPs.dataType),
                                      p_conf_ind->u.Indication.u.IndOpen.TxDataType,
                                      choice,
                                      &tx_totcap)) != H245_ERROR_OK)
        {
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return lError;
        }

      p_conf_ind->u.Indication.u.IndOpen.TxClientType = tx_totcap.ClientType;
      p_conf_ind->u.Indication.u.IndOpen.pTxCap = &(tx_totcap.Cap);

      /* if H223/H222 Mux table parameters for reverse channel availalbe */
      if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.OLCl_rLCPs.bit_mask & OLCl_rLCPs_mltplxPrmtrs_present)
        {
          switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                  u.openLogicalChannel.OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice)
            {
            case rLCPs_mPs_h223LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_H223;
              lError = load_H223_param(&TxMux.u.H223,
                                      &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                        OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h223LCPs);
              if (lError != H245_ERROR_OK)
                {
                  *p_AccRej = H245_REJ_AL_COMB;
                  return H245_ERROR_NOSUP;
                }
              break;

            case rLCPs_mPs_v76LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_VGMUX;
              lError = load_VGMUX_param(&TxMux.u.VGMUX,
                                       &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                         OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_v76LCPs);
              break;

            case rLCPs_mPs_h2250LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_H2250;
              lError = load_H2250_param(&TxMux.u.H2250,
                                       &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                         OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h2250LCPs);
              break;

            default:
              lError = H245_ERROR_NOSUP;
            }
            if (lError != H245_ERROR_OK)
              {
                *p_AccRej = H245_REJ;
                return lError;
              }
        } /* if H223/H222 mux table reverse parameters */

    } /* if reverse parameters present */

    if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OpnLgclChnnl_sprtStck_present)
    {
      p_conf_ind->u.Indication.u.IndOpen.pSeparateStack =
        &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OpnLgclChnnl_sprtStck;
    }


  /* conflict resolution .. just do it now.. */
  /* only on opens.. of same data type ..    */

#if 0
#ifndef LOOPBACK
  /* if master */
  if (pInstance->API.MasterSlave == APIMS_Master)
    {
      p_tracker = NULL;
      while (p_tracker = find_tracker_by_type (dwInst, API_OPEN_CHANNEL_T, p_tracker))
        {
          /* if allocated locally .. and incoming */
          /* data type == outstanding incoming    */
          /* there is a conflict                      */

          if ((p_tracker->u.Channel.ChannelAlloc == API_CH_ALLOC_LCL) &&
              (p_tracker->u.Channel.DataType == p_conf_ind->u.Indication.u.IndOpen.RxDataType))
            {
              *p_AccRej = H245_REJ;
              return H245_ERROR_INVALID_OP;

            } /* if conflict */

        } /* while */

    } /* if master */

#endif /* LOOPBACK */
#endif
  /* setup a tracker for this guy. */
  p_tracker = alloc_link_tracker (pInstance,
                                  API_OPEN_CHANNEL_T,
                                  0,
                                  API_ST_WAIT_LCLACK,
                                  API_CH_ALLOC_RMT,
                                  (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                                   u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)?API_CH_TYPE_BI:API_CH_TYPE_UNI,
                                  p_conf_ind->u.Indication.u.IndOpen.RxDataType,
                                  H245_INVALID_CHANNEL,
                                  p_conf_ind->u.Indication.u.IndOpen.RxChannel,
                                  0);

  if (!(p_tracker))
    {
      H245TRACE(pInstance->dwInst,1,"API:process_open_ind -> %s",map_api_error(H245_ERROR_NOMEM));
      *p_AccRej = H245_REJ;
      return H245_ERROR_NOMEM;
    }

  H245TRACE(pInstance->dwInst,10,"API:process_open_ind -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_bi_open_rsp
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 * ASSUME:
 *              Callback must happen inside this routine since the
 *              datastructures passed back to the application are allocated
 *              in this moudle.
 *
 *              Application will <<<COPY>>> the needed data structures when
 *              callback occurs..
 *
 *****************************************************************************/

# pragma warning( disable : 4100 )

static HRESULT
process_bi_open_rsp (struct InstanceStruct *     pInstance,     /* in */
                     MltmdSystmCntrlMssg        *p_pdu_rsp,     /* in */
                     H245_MUX_T                 *p_RxMux,       /* in  */
                     DWORD                      *p_RxChannel,   /* out */
                     H245_CONF_IND_T            *p_conf_ind     /* out */
                     )
{
  H245TRACE(pInstance->dwInst,10,"API:process_bi_open_rsp <-");

  p_conf_ind->u.Confirm.Error = H245_ERROR_OK;

  // Get Reverse Logical Channel Number
  *p_RxChannel =
    p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.RxChannel =
      p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.reverseLogicalChannelNumber;

  // Get Reverse Port Number
  if (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.bit_mask & rLCPs_prtNmbr_present)
    {
      p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.RxPort =
        p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.rLCPs_prtNmbr;
    }

  if (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.bit_mask & OLCAk_rLCPs_mPs_present)
    {
      // Get Reverse Logical Channel ACK Parameters
      switch (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice)
       {
       case rLCPs_mPs_h222LCPs_chosen:
         p_RxMux->Kind = H245_H222;
         p_conf_ind->u.Confirm.Error = load_H222_param(&p_RxMux->u.H222,
           &p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.rLCPs_mPs_h222LCPs);
         p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.pRxMux = p_RxMux;
         break;

       case mPs_h2250LgclChnnlPrmtrs_chosen:
         p_RxMux->Kind = H245_H2250ACK;
         p_conf_ind->u.Confirm.Error = load_H2250_param(&p_RxMux->u.H2250,
           &p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.u. mPs_h2250LgclChnnlPrmtrs);
         p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.pRxMux = p_RxMux;
         break;

       default:
          H245TRACE(pInstance->dwInst,1,"API:process_bi_open_rsp - unknown choice %d",
                    p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice);
          p_conf_ind->u.Confirm.Error = H245_ERROR_NOSUP;
       } // switch
    }

  H245TRACE(pInstance->dwInst,10,"API:process_bi_open_rsp -> OK");
  return H245_ERROR_OK;
}

# pragma warning( default : 4100 )

WORD awObject[64];

unsigned int ArrayFromObject(WORD *pwObject, unsigned uSize, POBJECTID pObject)
{
  register unsigned int uLength = 0;
  while (pObject)
  {
    if (uLength >= uSize)
    {
           H245TRACE(0,1,"API:ArrayFromObject Object ID too long");
      return uLength;
    }
    pwObject[uLength++] = (WORD) pObject->value;
    pObject = pObject->next;
  }
  return uLength;
} // ArrayFromObject()

/*****************************************************************************
 *
 * TYPE:        Callback
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static Tracker_T *
TrackerValidate(struct InstanceStruct *pInstance, DWORD dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:ValidateTracker -> Tracker Not Found");
    return NULL;
  }

  return pTracker;
}

static DWORD
TranslateTransId(struct InstanceStruct *pInstance, DWORD dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateTransId -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateTransId -> Tracker Not Found");
    return 0;
  }

  return pTracker->TransId;
}

static void
TrackerFree(struct InstanceStruct *pInstance, DWORD dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerFree -> NULL Tracker");
    return;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerFree -> Tracker Not Found");
    return;
  }
  unlink_dealloc_tracker (pInstance, pTracker);
}

static DWORD
TranslateAndFree(struct InstanceStruct *pInstance, DWORD dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateAndFree -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateAndFree -> Tracker Not Found");
    return 0;
  }
  dwTransId = pTracker->TransId;
  unlink_dealloc_tracker (pInstance, pTracker);
  return dwTransId;
}

static void
TrackerNewState(struct InstanceStruct *pInstance, DWORD dwTransId, int nNewState)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerNewState -> NULL Tracker");
    return;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerNewState -> Tracker Not Found");
    return;
  }
  pTracker->State = nNewState;
}

static WORD
GetRxChannel(struct InstanceStruct *pInstance, DWORD dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetRxChannel -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetRxChannel -> Tracker Not Found");
    return 0;
  }

  return (WORD)pTracker->u.Channel.RxChannel;
}

static WORD
GetTxChannel(struct InstanceStruct *pInstance, DWORD dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetTxChannel -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetTxChannel -> Tracker Not Found");
    return 0;
  }

  return (WORD)pTracker->u.Channel.TxChannel;
}

H245FunctionNotUnderstood(struct InstanceStruct *pInstance, PDU_T *pPdu)
{
    MltmdSystmCntrlMssg Pdu = {0};

    Pdu.choice = indication_chosen;
    Pdu.u.indication.choice = functionNotUnderstood_chosen;
    Pdu.u.indication.u.functionNotUnderstood.choice = pPdu->choice;
    switch (pPdu->choice)
    {
    case FnctnNtUndrstd_request_chosen:
        Pdu.u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_request =
            pPdu->u.MltmdSystmCntrlMssg_rqst;
        break;

    case FnctnNtUndrstd_response_chosen:
        Pdu.u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_response =
            pPdu->u.MSCMg_rspns;
        break;

    case FnctnNtUndrstd_command_chosen:
        Pdu.u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_command =
            pPdu->u.MSCMg_cmmnd;
    default:
        return H245_ERROR_OK;
    }
    return sendPDU(pInstance, &Pdu);
} // H245FunctionNotUnderstood()

HRESULT
H245FsmConfirm    (PDU_t *                  pPdu,
                   DWORD                    dwEvent,
                   struct InstanceStruct *  pInstance,
                   DWORD                    dwTransId,
                   HRESULT                  lError)
{
  H245_CONF_IND_T               ConfInd;
  DWORD                         dwIndex;
  H245_MUX_T                    TxMux;
  H245_MUX_T                    RxMux;
  HRESULT                       lResult = H245_ERROR_OK;

  H245ASSERT(pInstance != NULL);
  H245ASSERT(pInstance->API.ConfIndCallBack != NULL);
  H245TRACE(pInstance->dwInst,4,"H245FsmConfirm <- Event=%s (%d)",
            map_fsm_event(dwEvent),dwEvent);

  memset (&ConfInd, 0, sizeof(ConfInd));
  ConfInd.Kind = H245_CONF;
  ConfInd.u.Confirm.Confirm = dwEvent;
  ConfInd.u.Confirm.dwPreserved = pInstance->API.dwPreserved;
  ConfInd.u.Confirm.dwTransId = dwTransId;
  ConfInd.u.Confirm.Error = lError;

  switch (dwEvent)
  {
    /******************************/
    /*                            */
    /* master slave determination */
    /*                            */
    /******************************/
  case  H245_CONF_INIT_MSTSLV:
    ConfInd.u.Confirm.dwTransId = TranslateAndFree(pInstance, dwTransId);

    /* handle errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == mstrSlvDtrmntnAck_chosen);
        pInstance->API.SystemState     = APIST_Connected;
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
          {
            pInstance->API.MasterSlave = APIMS_Master;
            ConfInd.u.Confirm.u.ConfMstSlv = H245_MASTER;
          }
        else
          {
            pInstance->API.MasterSlave = APIMS_Slave;
            ConfInd.u.Confirm.u.ConfMstSlv = H245_SLAVE;
          }
        break;

      case REJECT:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Master Slave Reject");
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
//      case MS_FAILED:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Master Slave Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;
      }
    break;

    /****************************************/
    /*                                      */
    /* Terminal Capability exchange confirm */
    /*                                      */
    /****************************************/
  case  H245_CONF_SEND_TERMCAP:
    ConfInd.u.Confirm.dwTransId = TranslateAndFree(pInstance, dwTransId);

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == terminalCapabilitySetAck_chosen);
        ConfInd.u.Confirm.u.ConfSndTcap.AccRej = H245_ACC;
        clean_cap_table(&pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
        break;

      case REJECT:
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfSndTcap.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Term Cap Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        break;
      }
    break;

    /***************************************/
    /*                                     */
    /* unidirectional logical channel open */
    /*                                     */
    /***************************************/
  case  H245_CONF_OPEN:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfOpen.TxChannel = GetTxChannel(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfOpen.RxPort = H245_INVALID_PORT_NUMBER;

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelAck_chosen);
        H245ASSERT((pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present) == 0);

        if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_sprtStck_present)
        {
          ConfInd.u.Confirm.u.ConfOpen.pSeparateStack =
            &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_sprtStck;
        }

        if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & frwrdMltplxAckPrmtrs_present)
        {
          switch (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.choice)
            {
            case h2250LgclChnnlAckPrmtrs_chosen:
              TxMux.Kind = H245_H2250ACK;
              load_H2250ACK_param(&TxMux.u.H2250ACK,
                                  &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs);
              ConfInd.u.Confirm.u.ConfOpen.pTxMux = &TxMux;
              break;

            } // switch
        }

        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_ACC;
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        break;

      case REJECT:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelReject_chosen);

        ConfInd.u.Confirm.Error             = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfOpen.AccRej =
          pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice;
        TrackerFree(pInstance,dwTransId);
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error             = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
        TrackerFree(pInstance,dwTransId);
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Open Channel Error %d", lError);
        ConfInd.u.Confirm.Error             = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
        TrackerFree(pInstance,dwTransId);
      }
    break;

    /***********************************************/
    /*                                             */
    /* bidirectional logical channel open (TBD)??? */
    /*                                             */
    /***********************************************/
  case  H245_CONF_NEEDRSP_OPEN:
    {
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      ConfInd.u.Confirm.dwTransId = pTracker->TransId;
      ConfInd.u.Confirm.u.ConfOpenNeedRsp.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
      ConfInd.u.Confirm.u.ConfOpenNeedRsp.RxPort = H245_INVALID_PORT_NUMBER;

      /* determine errors */
      switch (lError)
        {
        case H245_ERROR_OK:
          H245ASSERT(pPdu != NULL);
          H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
          H245ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelAck_chosen);
          H245ASSERT((pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present) != 0);

          ConfInd.u.Confirm.u.ConfOpenNeedRsp.AccRej = H245_ACC;

          if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_sprtStck_present)
          {
            ConfInd.u.Confirm.u.ConfOpenNeedRsp.pSeparateStack =
              &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_sprtStck;
          }

          if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & frwrdMltplxAckPrmtrs_present)
          {
            switch (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.choice)
              {
              case h2250LgclChnnlAckPrmtrs_chosen:
                TxMux.Kind = H245_H2250ACK;
                load_H2250ACK_param(&TxMux.u.H2250ACK,
                                    &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs);
                ConfInd.u.Confirm.u.ConfOpenNeedRsp.pTxMux = &TxMux;
                break;

              } // switch
          }

          /* NOTE Receive Channel is assigned  in this call */
          process_bi_open_rsp (pInstance,
                          pPdu,
                          &RxMux,
                          &(pTracker->u.Channel.RxChannel),
                          &ConfInd);

          /* NOTE: this is a special case since we have to assign   */
          /* the receive channel to the tracker.. otherwise we      */
          /* will not be able to find it later..                    */
          /* Here we have to update both the state, and the channel */
          pTracker->State = API_ST_WAIT_CONF;
          break;

        case REJECT:
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_OK;
          ConfInd.u.Confirm.u.ConfOpen.AccRej =
            pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice;
          unlink_dealloc_tracker (pInstance, pTracker);
          break;

        case TIMER_EXPIRY:
        case ERROR_D_TIMEOUT:
        case ERROR_F_TIMEOUT:
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_TIMEOUT;
          ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
          unlink_dealloc_tracker (pInstance, pTracker);
          break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
        default:
          H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Open Channel Error %d", lError);
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_UNKNOWN;
          ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
          unlink_dealloc_tracker (pInstance, pTracker);
      }
    }
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel close         */
    /*                                              */
    /* bidirection logical channel close            */
    /*                                              */
    /************************************************/
  case  H245_CONF_CLOSE:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfClose.Channel = GetTxChannel(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfClose.AccRej = H245_ACC;

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == closeLogicalChannelAck_chosen);
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_ACC;
        TrackerFree(pInstance,dwTransId);
        break;

      case REJECT:
        /* should never be rejected */
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Close Channel Rejected");
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Close Channel Error %d", lError);
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
      }
    break;

    /***************************/
    /*                         */
    /* request channel close   */
    /*                         */
    /***************************/
  case  H245_CONF_REQ_CLOSE:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfReqClose.Channel = GetRxChannel(pInstance, dwTransId);
    TrackerNewState(pInstance,dwTransId,API_ST_IDLE);

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == requestChannelCloseAck_chosen);
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_ACC;
        break;

      case REJECT:
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Request Channel Close Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
      }
    break;

    /*******************/
    /*                 */
    /* mux table entry */
    /*                 */
    /*******************/
  case  H245_CONF_MUXTBL_SND:
    {
      UINT ii;
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      ConfInd.u.Confirm.dwTransId = pTracker->TransId;

      switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == multiplexEntrySendAck_chosen);
        for (ii = 0;
             ii < pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck.multiplexTableEntryNumber.count;
             ii ++)
        {
          pTracker->u.MuxEntryCount--;
          ConfInd.u.Confirm.u.ConfMuxSnd.MuxEntryId =
            pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck.multiplexTableEntryNumber.value[ii];
          ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_ACC;

          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          pTracker = TrackerValidate(pInstance, dwTransId);
          if (pTracker == NULL)
            return H245_ERROR_OK;
        }
        if (pTracker->u.MuxEntryCount == 0)
        {                            
          unlink_dealloc_tracker (pInstance, pTracker);
        }
        pPdu = NULL;                    // Don't do callback again!
        break;

      case REJECT:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == multiplexEntrySendReject_chosen);
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        for (ii = 0;
             ii < pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.count;
             ++ii)
        {
          pTracker->u.MuxEntryCount--;
          ConfInd.u.Confirm.u.ConfMuxSnd.MuxEntryId =
            pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.value[ii].multiplexTableEntryNumber;

          switch (pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.value[ii].cause.choice)
          {
          default:
            H245PANIC();
          case MERDs_cs_unspcfdCs_chosen:
            ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_REJ; /* unspecified */
            break;
          case descriptorTooComplex_chosen:
            ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_REJ_MUX_COMPLICATED;
            break;
          }

          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          pTracker = TrackerValidate(pInstance, dwTransId);
          if (pTracker == NULL)
            return H245_ERROR_OK;
        }
        if (pTracker->u.MuxEntryCount == 0)
        {                            
          unlink_dealloc_tracker (pInstance, pTracker);
        }
        pPdu = NULL;                    // Don't do callback again!
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        unlink_dealloc_tracker (pInstance, pTracker);
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Mux Table Send Error %d", lError);
        unlink_dealloc_tracker (pInstance, pTracker);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
      } // switch
    }
    break;

  case  H245_CONF_RMESE:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == requestMultiplexEntryAck_chosen);
    ConfInd.u.Confirm.u.ConfRmese.dwCount =
      pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Confirm.u.ConfRmese.dwCount; ++dwIndex)
    {
      ConfInd.u.Confirm.u.ConfRmese.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.value[dwIndex];
    }
    break;

  case  H245_CONF_RMESE_REJECT:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == rqstMltplxEntryRjct_chosen);
    ConfInd.u.Confirm.u.ConfRmeseReject.dwCount =
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Confirm.u.ConfRmeseReject.dwCount; ++dwIndex)
    {
      ConfInd.u.Confirm.u.ConfRmeseReject.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].multiplexTableEntryNumber;
    }
    break;

  case  H245_CONF_RMESE_EXPIRED:
    H245ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_MRSE:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == requestModeAck_chosen);
    ConfInd.u.Confirm.u.ConfMrse =
      pPdu->u.MSCMg_rspns.u.requestModeAck.response.choice;
    break;

  case  H245_CONF_MRSE_REJECT:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == requestModeReject_chosen);
    ConfInd.u.Confirm.u.ConfMrseReject =
      pPdu->u.MSCMg_rspns.u.requestModeReject.cause.choice;
    break;

  case  H245_CONF_MRSE_EXPIRED:
    H245ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_MLSE:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == maintenanceLoopAck_chosen);
    ConfInd.u.Confirm.u.ConfMlse.LoopType =
      pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice;
    switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice)
    {
    case systemLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlse.Channel = 0;
      break;

    case mediaLoop_chosen:
    case logicalChannelLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlse.Channel =
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmConfirm: Invalid Maintenance Loop Ack type %d",
                pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_CONF_MLSE_REJECT:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == maintenanceLoopReject_chosen);
    ConfInd.u.Confirm.u.ConfMlseReject.LoopType =
      pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice;
    switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice)
    {
    case systemLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlseReject.Channel = 0;
      break;

    case mediaLoop_chosen:
    case logicalChannelLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlseReject.Channel =
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmConfirm: Invalid Maintenance Loop Reject type %d",
                pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_CONF_MLSE_EXPIRED:
    H245ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_RTDSE:
    H245ASSERT(pPdu != NULL);
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == roundTripDelayResponse_chosen);
    break;

  case  H245_CONF_RTDSE_EXPIRED:
    H245ASSERT(pPdu == NULL);
    break;

  default:
    /* Possible Error */
    H245TRACE(pInstance->dwInst, 1,
              "H245FsmConfirm -> Invalid Confirm Event %d",
              dwEvent);
    return H245_ERROR_SUBSYS;
  } // switch

  if (lResult == H245_ERROR_OK)
  {
    if (pPdu)
    {
      if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u) == H245_ERROR_NOSUP)
      {
        H245FunctionNotUnderstood(pInstance, pPdu);
      }
    }
    else
    {
      (*pInstance->API.ConfIndCallBack)(&ConfInd, NULL);
    }
    H245TRACE(pInstance->dwInst,4,"H245FsmConfirm -> OK");
  }
  else
  {
    H245TRACE(pInstance->dwInst,1,"H245FsmConfirm -> %s", map_api_error(lResult));
  }
  return lResult;
} // H245FsmConfirm()



HRESULT
H245FsmIndication (PDU_t *                  pPdu,
                   DWORD                    dwEvent,
                   struct InstanceStruct *  pInstance,
                   DWORD                    dwTransId,
                   HRESULT                  lError)
{
  H245_CONF_IND_T               ConfInd;
  DWORD                         dwIndex;
  MltmdSystmCntrlMssg          *pRsp;
  HRESULT                       lResult = H245_ERROR_OK;
#if 1
  int                           nLength;
  WCHAR *                       pwchar = NULL;
#endif

  H245ASSERT(dwEvent == H245_IND_OPEN_CONF || pPdu != NULL);
  H245ASSERT(pInstance != NULL);
  H245ASSERT(pInstance->API.ConfIndCallBack != NULL);
  H245TRACE(pInstance->dwInst,4,"H245FsmIndication <- Event=%s (%d)",
            map_fsm_event(dwEvent),dwEvent);

  memset (&ConfInd, 0, sizeof(ConfInd));
  ConfInd.Kind = H245_IND;
  ConfInd.u.Indication.Indicator = dwEvent;
  ConfInd.u.Indication.dwPreserved = pInstance->API.dwPreserved;

  switch (dwEvent)
  {
    /******************************/
    /*                            */
    /* master slave determination */
    /*                            */
    /******************************/
  case  H245_IND_MSTSLV:

    /* handle errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        H245ASSERT(pPdu != NULL);
        H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        H245ASSERT(pPdu->u.MSCMg_rspns.choice == mstrSlvDtrmntnAck_chosen);

        pInstance->API.SystemState = APIST_Connected;
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
        {
          pInstance->API.MasterSlave = APIMS_Master;
          ConfInd.u.Indication.u.IndMstSlv = H245_MASTER;
        }
        else
        {
          pInstance->API.MasterSlave = APIMS_Slave;
          ConfInd.u.Indication.u.IndMstSlv = H245_SLAVE;
        }
        break;

      case MS_FAILED:
      case REJECT:
      case TIMER_EXPIRY:
        ConfInd.u.Indication.u.IndMstSlv = H245_INDETERMINATE;
        break;

//      case ERROR_D_TIMEOUT:
//      case ERROR_F_TIMEOUT:
//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245PANIC();
        /* (TBC) */
        return H245_ERROR_OK;
      }
    break;

    /****************************************/
    /*                                      */
    /* Terminal Capability exchange         */
    /*                                      */
    /****************************************/
    /* decode_termcapset breaks the termcap set up and sends up     */
    /* a single indication to the client */
  case  H245_IND_CAP:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == terminalCapabilitySet_chosen);
    pRsp = (PDU_t *)H245_malloc(sizeof(*pPdu));
    if (pRsp == NULL)
    {
      H245TRACE(pInstance->dwInst,1,"H245FsmIndication TermCap: no memory for response");
      return H245_ERROR_NOMEM;
    }
    memset(pRsp, 0, sizeof(*pRsp));
    process_term_cap_set_ind (pInstance, pPdu, pRsp);
    FsmOutgoing(pInstance, pRsp, 0);
    H245_free (pRsp);
    break;

  case  H245_IND_CESE_RELEASE:
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel open          */
    /*                                              */
    /* bidirectional  logical channel open          */
    /*                                              */
    /************************************************/
  case  H245_IND_OPEN:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == openLogicalChannel_chosen);
    {
      unsigned short  forward_channel;
      H245_ACC_REJ_T  acc_rej;

      /* if error, process_open_ind will tell us what to send for reject */
      if (process_open_ind(pInstance,pPdu,&forward_channel,&acc_rej,&ConfInd) != H245_ERROR_OK)
      {
        // Reject the open
        pRsp = (PDU_t *)H245_malloc(sizeof(*pPdu));
        if (pRsp == NULL)
        {
          H245TRACE(pInstance->dwInst,1,"H245FsmIndication TermCap: no memory for response");
          return H245_ERROR_NOMEM;
        }
        memset(pRsp, 0, sizeof(*pRsp));
        pdu_rsp_open_logical_channel_rej(pRsp, forward_channel, (WORD)acc_rej);
        FsmOutgoing(pInstance, pRsp, 0);
        H245_free (pRsp);
      }
    }
    break;

    /************************************************/
    /*                                              */
    /* Confirm bi-directional open                  */
    /*                                              */
    /************************************************/
  case  H245_IND_OPEN_CONF:
#if defined(DBG)
    if (lError == H245_ERROR_OK)
    {
      H245ASSERT(pPdu != NULL);
      H245ASSERT(pPdu->choice == indication_chosen);
      H245ASSERT(pPdu->u.indication.choice == opnLgclChnnlCnfrm_chosen);
    }
#endif
    {
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      /* confirm processing */
      H245ASSERT(pTracker->State == API_ST_WAIT_CONF);
      H245ASSERT(pTracker->TrackerType == API_OPEN_CHANNEL_T);
      H245ASSERT(pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);
      H245ASSERT(pTracker->u.Channel.ChannelType == API_CH_TYPE_BI);

      ConfInd.u.Indication.u.IndOpenConf.RxChannel = (WORD)pTracker->u.Channel.RxChannel;
      ConfInd.u.Indication.u.IndOpenConf.TxChannel = (WORD)pTracker->u.Channel.TxChannel;

      pTracker->State = API_ST_IDLE;
    }
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel close         */
    /*                                              */
    /* bidirectional  logical channel close         */
    /*                                              */
    /************************************************/
  case  H245_IND_CLOSE:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == closeLogicalChannel_chosen);
    {
      Tracker_T *pTracker;

      ConfInd.u.Indication.u.IndClose.Channel =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
      ConfInd.u.Indication.u.IndClose.Reason =
        (pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.source.choice==user_chosen)?H245_USER:H245_LCSE;

      /* find the tracker */
      pTracker = find_tracker_by_rxchannel (pInstance,
                                           ConfInd.u.Indication.u.IndClose.Channel,
                                           API_CH_ALLOC_RMT);
      if (!pTracker)
        {
          H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> close indication - Tracker not found");
          return H245_ERROR_OK;
        }

      unlink_dealloc_tracker (pInstance, pTracker);
    }
    break;

    /************************************************/
    /*                                              */
    /* request channel close                        */
    /*                                              */
    /************************************************/
  case  H245_IND_REQ_CLOSE:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestChannelClose_chosen);
    {
      Tracker_T *pTracker;

      ConfInd.u.Indication.u.IndReqClose =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;

      /* find the tracker */
      pTracker = find_tracker_by_txchannel (pInstance,
                                           ConfInd.u.Indication.u.IndReqClose,
                                           API_CH_ALLOC_LCL);
      if (!pTracker)
        {
          H245TRACE(pInstance->dwInst,4,"H245FsmIndication Request Channel Close: Tracker not found");

          pRsp = (PDU_t *)H245_malloc(sizeof(*pPdu));
          if (pRsp == NULL)
          {
            H245TRACE(pInstance->dwInst,1,"H245FsmIndication Request Channel Close: no memory for response");
            return H245_ERROR_NOMEM;
          }
          memset(pRsp, 0, sizeof(*pRsp));

          /* can't find it.. must be closed.. respond anyway */
          pdu_rsp_request_channel_close_rej(pRsp, (WORD)ConfInd.u.Indication.u.IndReqClose,H245_REJ);
          FsmOutgoing(pInstance, pRsp, 0);
          H245_free(pRsp);
          /* Possible Error.. could have been removed from list or    */
          /* could have been allocated remotely... and this is a protocol */
          /* error                                                    */
          return H245_ERROR_OK;
        }

      H245ASSERT(pTracker->State == API_ST_IDLE);
      pTracker->State = API_ST_WAIT_LCLACK;
      pTracker->TrackerType = API_CLOSE_CHANNEL_T;
    }
    break;

    /************************************************/
    /*                                              */
    /* Release Close Request                        */
    /*                                              */
    /************************************************/
  case  H245_IND_CLCSE_RELEASE:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == rqstChnnlClsRls_chosen);
    {
      Tracker_T *pTracker;

      /* find tracker.. and set to LCLACK_CANCEL */
      /* this will tell api to notify user       */

      pTracker = find_tracker_by_txchannel (pInstance,
                                           pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber,
                                           API_CH_ALLOC_LCL);
      if (pTracker)
        {
          if (pTracker->State != API_ST_WAIT_LCLACK)
            {
              return H245_ERROR_INVALID_INST;
            }

          pTracker->State = API_ST_WAIT_LCLACK_CANCEL;
        }
      else
        {
          H245TRACE(pInstance->dwInst,1,"H245FsmIndication -> IND_REL_CLSE: Cancel.. NO TRACKER FOUND");
        }
    }
    break;

    /************************************************/
    /*                                              */
    /* mux table entry                              */
    /*                                              */
    /************************************************/
  case  H245_IND_MUX_TBL:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == multiplexEntrySend_chosen);
    {
      unsigned short          seq_num;
      H245_ACC_REJ_MUX_T      rej_mux;
      H245_MUX_TABLE_T       *p_mux_tbl;
      DWORD                   rej_cnt;
      DWORD                   acc_cnt;
      Tracker_T              *pTracker;

      /* process the mux table entry */
      p_mux_tbl = process_mux_table_ind(pPdu,&seq_num,rej_mux,&rej_cnt,&acc_cnt);

      if (rej_cnt)
        {
          /* build the reject pdu from the rej_mux table */
          if (!(pRsp = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
            return H245_ERROR_NOMEM;
          memset(pRsp, 0, sizeof(MltmdSystmCntrlMssg));

          pdu_rsp_mux_table_rej (pRsp,seq_num,rej_mux,(rej_cnt+acc_cnt));
          FsmOutgoing(pInstance, pRsp, 0);
          H245_free(pRsp);
        }

      /* if there are any left to send up. */
      if (p_mux_tbl)
        {
          if (!(pTracker = alloc_link_tracker (pInstance,
                                                API_RECV_MUX_T,
                                                /* use the TransId.. for the sequence number */
                                                seq_num,
                                                API_ST_WAIT_LCLACK,
                                                API_CH_ALLOC_UNDEF,
                                                API_CH_TYPE_UNDEF,
                                                0,
                                                H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                                0)))
            {
              free_mux_table_list (p_mux_tbl);
              H245TRACE(pInstance->dwInst,1,"API:process_open_ind -> %s",map_api_error(H245_ERROR_NOMEM));
              /* (TBC) this should be a fatal error */
              H245PANIC();
              break;
            }

          pTracker->u.MuxEntryCount = acc_cnt;
          ConfInd.u.Indication.u.IndMuxTbl.Count   = acc_cnt;
          ConfInd.u.Indication.u.IndMuxTbl.pMuxTbl = p_mux_tbl;
          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          free_mux_table_list (p_mux_tbl);
          return H245_ERROR_OK;
        }
    }
    break;

  case  H245_IND_MTSE_RELEASE:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == mltplxEntrySndRls_chosen);
    break;

  case  H245_IND_RMESE:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestMultiplexEntry_chosen);
    ConfInd.u.Indication.u.IndRmese.dwCount =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Indication.u.IndRmese.dwCount; ++dwIndex)
    {
      ConfInd.u.Indication.u.IndRmese.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.value[dwIndex];
    }
    break;

  case  H245_IND_RMESE_RELEASE:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == rqstMltplxEntryRls_chosen);
    break;

  case  H245_IND_MRSE:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestMode_chosen);
    ConfInd.u.Indication.u.IndMrse.pRequestedModes =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes;
    break;

  case  H245_IND_MRSE_RELEASE:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == requestModeRelease_chosen);
    break;

  case  H245_IND_MLSE:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == maintenanceLoopRequest_chosen);
    ConfInd.u.Indication.u.IndMlse.LoopType =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;
    if (ConfInd.u.Indication.u.IndMlse.LoopType == systemLoop_chosen)
      ConfInd.u.Indication.u.IndMlse.Channel = 0;
    else
      ConfInd.u.Indication.u.IndMlse.Channel =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
    break;

  case  H245_IND_MLSE_RELEASE:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice == mntnncLpOffCmmnd_chosen);
    break;

  case  H245_IND_NONSTANDARD_REQUEST:
  case  H245_IND_NONSTANDARD_RESPONSE:
  case  H245_IND_NONSTANDARD_COMMAND:
  case  H245_IND_NONSTANDARD:
    ConfInd.u.Indication.u.IndNonstandard.pData        = pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value;
    ConfInd.u.Indication.u.IndNonstandard.dwDataLength = pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length;
    switch (pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice)
    {
    case object_chosen:
      ConfInd.u.Indication.u.IndNonstandard.pwObjectId        = awObject;
      ConfInd.u.Indication.u.IndNonstandard.dwObjectIdLength  =
        ArrayFromObject(&awObject[0], sizeof(awObject)/sizeof(awObject[0]),
          pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.object);
      ConfInd.u.Indication.u.IndNonstandard.byCountryCode     = 0;
      ConfInd.u.Indication.u.IndNonstandard.byExtension       = 0;
      ConfInd.u.Indication.u.IndNonstandard.wManufacturerCode = 0;
      break;

    case h221NonStandard_chosen:
      ConfInd.u.Indication.u.IndNonstandard.pwObjectId        = NULL;
      ConfInd.u.Indication.u.IndNonstandard.dwObjectIdLength  = 0;
      ConfInd.u.Indication.u.IndNonstandard.byCountryCode     = (BYTE)
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode;
      ConfInd.u.Indication.u.IndNonstandard.byExtension       = (BYTE)
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension;
      ConfInd.u.Indication.u.IndNonstandard.wManufacturerCode =
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmIndication: unrecognized nonstandard identifier type %d",
                pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_MISC_COMMAND:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice  == miscellaneousCommand_chosen);
    break;

  case  H245_IND_MISC:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == miscellaneousIndication_chosen);
    break;

  case  H245_IND_COMM_MODE_REQUEST:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == communicationModeRequest_chosen);
    break;

  case  H245_IND_COMM_MODE_RESPONSE:
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == cmmnctnMdRspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.choice == communicationModeTable_chosen);
    {
      unsigned int                uCount;
      CommunicationModeTableLink  pLink;
      H245_COMM_MODE_ENTRY_T *    pTable;

      uCount = 0;
      pLink = pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable;
      while (pLink)
      {
        ++uCount;
        pLink = pLink->next;
      }

      pTable = H245_malloc(uCount * sizeof(*pTable)); 
      if (pTable)
      {
        ConfInd.u.Indication.u.IndCommRsp.pTable       = pTable;
        ConfInd.u.Indication.u.IndCommRsp.byTableCount = (BYTE)uCount; 
        pLink = pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable;
        while (pLink)
        {
          lResult = LoadCommModeEntry(pTable, &pLink->value);
          if (lResult != H245_ERROR_OK)
          {
            H245_free(pTable);
            return lResult;
          }
          ++pTable;
          pLink = pLink->next;
        }
        if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
        {
          H245FunctionNotUnderstood(pInstance, pPdu);
        }
        H245_free(pTable);
        H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
        return H245_ERROR_OK;
      }

      lResult = H245_ERROR_NOMEM;
    }
    break;

  case  H245_IND_COMM_MODE_COMMAND:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice == communicationModeCommand_chosen);
    {
      unsigned int                  uCount;
      CommunicationModeCommandLink  pLink;
      H245_COMM_MODE_ENTRY_T *      pTable;

      uCount = 0;
      pLink = pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable;
      while (pLink)
      {
        ++uCount;
        pLink = pLink->next;
      }

      pTable = H245_malloc(uCount * sizeof(*pTable)); 
      if (pTable)
      {
        ConfInd.u.Indication.u.IndCommCmd.pTable       = pTable;
        ConfInd.u.Indication.u.IndCommCmd.byTableCount = (BYTE)uCount; 
        pLink = pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable;
        while (pLink)
        {
          lResult = LoadCommModeEntry(pTable, &pLink->value);
          if (lResult != H245_ERROR_OK)
          {
            H245_free(pTable);
            return lResult;
          }
          ++pTable;
          pLink = pLink->next;
        }
      {
        H245FunctionNotUnderstood(pInstance, pPdu);
      }
        if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
        {
          H245FunctionNotUnderstood(pInstance, pPdu);
        }
        H245_free(pTable);
        H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
        return H245_ERROR_OK;
      }

      lResult = H245_ERROR_NOMEM;
    }
    break;

  case  H245_IND_CONFERENCE_REQUEST:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == conferenceRequest_chosen);
    ConfInd.u.Indication.u.IndConferReq.RequestType =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.choice;
    ConfInd.u.Indication.u.IndConferReq.byMcuNumber = (BYTE)
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.mcuNumber;
    ConfInd.u.Indication.u.IndConferReq.byTerminalNumber = (BYTE)
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.terminalNumber;
    break;

  case  H245_IND_CONFERENCE_RESPONSE:
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == conferenceResponse_chosen);
    ConfInd.u.Indication.u.IndConferRsp.ResponseType =
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice;
    switch (pPdu->u.MSCMg_rspns.u.conferenceResponse.choice)
    {
    case mCTerminalIDResponse_chosen:
    case terminalIDResponse_chosen:
    case conferenceIDResponse_chosen:
    case passwordResponse_chosen:
      ConfInd.u.Indication.u.IndConferRsp.byMcuNumber = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.mcuNumber;
      ConfInd.u.Indication.u.IndConferRsp.byTerminalNumber = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.terminalNumber;
      ConfInd.u.Indication.u.IndConferRsp.pOctetString =
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.value;
      ConfInd.u.Indication.u.IndConferRsp.byOctetStringLength = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.length;
      break;

    case terminalListResponse_chosen:
      ConfInd.u.Indication.u.IndConferRsp.pTerminalList =
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.value;
      ConfInd.u.Indication.u.IndConferRsp.wTerminalListCount = (WORD)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.count;
      break;

    case videoCommandReject_chosen:
    case terminalDropReject_chosen:
      break;

    case makeMeChairResponse_chosen:
      switch (pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice)
      {
      case grantedChairToken_chosen:
        ConfInd.u.Indication.u.IndConferRsp.ResponseType = H245_RSP_GRANTED_CHAIR_TOKEN;
        break;

      default:
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: Invalid make me chair response %d",
                  pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice);

      // Fall-through to next case

      case deniedChairToken_chosen:
        ConfInd.u.Indication.u.IndConferRsp.ResponseType = H245_RSP_DENIED_CHAIR_TOKEN;
      } // switch
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Conference Response type %d",
                pPdu->u.MSCMg_rspns.u.conferenceResponse.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_CONFERENCE_COMMAND:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice == conferenceCommand_chosen);
    ConfInd.u.Indication.u.IndConferCmd.CommandType =
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.choice;
    ConfInd.u.Indication.u.IndConferCmd.Channel =
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.brdcstMyLgclChnnl;
    ConfInd.u.Indication.u.IndConferCmd.byMcuNumber = (BYTE)
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.sendThisSource.mcuNumber;
    ConfInd.u.Indication.u.IndConferCmd.byTerminalNumber = (BYTE)
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.sendThisSource.terminalNumber;
    break;

  case  H245_IND_CONFERENCE:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == conferenceIndication_chosen);
    ConfInd.u.Indication.u.IndConfer.IndicationType =
      pPdu->u.indication.u.conferenceIndication.choice;
    ConfInd.u.Indication.u.IndConfer.bySbeNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.sbeNumber;
    ConfInd.u.Indication.u.IndConfer.byMcuNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.mcuNumber;
    ConfInd.u.Indication.u.IndConfer.byTerminalNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.terminalNumber;
    break;

  case  H245_IND_SEND_TERMCAP:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice == sndTrmnlCpbltySt_chosen);
    break;

  case  H245_IND_ENCRYPTION:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice == encryptionCommand_chosen);
    break;

  case  H245_IND_FLOW_CONTROL:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice == flowControlCommand_chosen);
    ConfInd.u.Indication.u.IndFlowControl.Scope =
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice;
    switch (pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice)
    {
    case FCCd_scp_lgclChnnlNmbr_chosen:
      ConfInd.u.Indication.u.IndFlowControl.Channel =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FCCd_scp_lgclChnnlNmbr;
      break;

    case FlwCntrlCmmnd_scp_rsrcID_chosen:
      ConfInd.u.Indication.u.IndFlowControl.wResourceID =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FlwCntrlCmmnd_scp_rsrcID;
      break;

    case FCCd_scp_whlMltplx_chosen:
      break;
    
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Flow Control restriction %d",
                pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    switch (pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice)
    {
    case maximumBitRate_chosen:
      ConfInd.u.Indication.u.IndFlowControl.dwRestriction =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.u.maximumBitRate;
      break;

    case noRestriction_chosen:
      ConfInd.u.Indication.u.IndFlowControl.dwRestriction = H245_NO_RESTRICTION;
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Flow Control restriction %d",
                pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_ENDSESSION:
    H245ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    H245ASSERT(pPdu->u.MSCMg_cmmnd.choice  == endSessionCommand_chosen);
    ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_DISCONNECT;
    switch (pPdu->u.MSCMg_cmmnd.u.endSessionCommand.choice)
    {
    case EndSssnCmmnd_nonStandard_chosen:
     ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_NONSTD,
     ConfInd.u.Indication.u.IndEndSession.SessionNonStd =
       pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.EndSssnCmmnd_nonStandard;
      break;
    case disconnect_chosen:
      break;
    case gstnOptions_chosen:
      switch (pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.gstnOptions.choice)
      {
      case telephonyMode_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_TELEPHONY;
        break;
      case v8bis_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V8BIS;
        break;
      case v34DSVD_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34DSVD;
        break;
      case v34DuplexFAX_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34DUPFAX;
        break;
      case v34H324_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34H324;
        break;
      default:
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: Invalid End Session GSTN options %d",
                  pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.gstnOptions.choice);
      } // switch
      break;
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid End Session type %d",
                pPdu->u.MSCMg_cmmnd.u.endSessionCommand.choice);
    } // switch
    break;

  case  H245_IND_FUNCTION_NOT_UNDERSTOOD:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == functionNotUnderstood_chosen);
    break;

  case  H245_IND_JITTER:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == jitterIndication_chosen);
    break;

  case  H245_IND_H223_SKEW:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == h223SkewIndication_chosen);
    ConfInd.u.Indication.u.IndH223Skew.LogicalChannelNumber1 =
      pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber1;
    ConfInd.u.Indication.u.IndH223Skew.LogicalChannelNumber2 =
      pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber2;
    ConfInd.u.Indication.u.IndH223Skew.wSkew =
      pPdu->u.indication.u.h223SkewIndication.skew;
    break;

  case  H245_IND_NEW_ATM_VC:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == newATMVCIndication_chosen);
    break;

  case  H245_IND_USERINPUT:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == userInput_chosen);
    ConfInd.u.Indication.u.IndUserInput.Kind =
      pPdu->u.indication.u.userInput.choice;
    switch (pPdu->u.indication.u.userInput.choice)
    {
    case UsrInptIndctn_nnStndrd_chosen:
      ConfInd.u.Indication.u.IndUserInput.u.NonStd =
        pPdu->u.indication.u.userInput.u.UsrInptIndctn_nnStndrd;
      break;
    case alphanumeric_chosen:
#if 1
      nLength = MultiByteToWideChar(CP_ACP,             // code page
                                    0,                  // dwFlags
                                    pPdu->u.indication.u.userInput.u.alphanumeric,
                                    -1,                 // ASCII string length (in bytes)
                                    NULL,               // Unicode string
                                    0);                 // max Unicode string length
      pwchar = H245_malloc(nLength * sizeof(WCHAR));
      if (pwchar == NULL)
      {
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: no memory for user input", 0);
        lResult = H245_ERROR_NOMEM;
      }
      else
      {
        nLength = MultiByteToWideChar(CP_ACP,             // code page
                                      0,                  // dwFlags
                                      pPdu->u.indication.u.userInput.u.alphanumeric,
                                      -1,                 // ASCII string length (in bytes)
                                      pwchar,             // Unicode string
                                      nLength);           // max Unicode string length
        ConfInd.u.Indication.u.IndUserInput.u.pGenString = pwchar;
      }
#else
      ConfInd.u.Indication.u.IndUserInput.u.pGenString =
        pPdu->u.indication.u.userInput.u.alphanumeric;
#endif
      break;
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: unrecognized user input type %d",
                pPdu->u.indication.u.userInput.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_H2250_MAX_SKEW:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == h2250MxmmSkwIndctn_chosen);
    ConfInd.u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber1 =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber1;
    ConfInd.u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2 =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber2;
    ConfInd.u.Indication.u.IndH2250MaxSkew.wSkew =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.maximumSkew;
    break;

  case  H245_IND_MC_LOCATION:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == mcLocationIndication_chosen);
    lResult = LoadTransportAddress(&ConfInd.u.Indication.u.IndMcLocation,
                                  &pPdu->u.indication.u.mcLocationIndication.signalAddress);
    break;

  case  H245_IND_VENDOR_ID:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == vendorIdentification_chosen);
    ConfInd.u.Indication.u.IndVendorId.Identifier =
      pPdu->u.indication.u.vendorIdentification.vendor;
    if (pPdu->u.indication.u.vendorIdentification.bit_mask & productNumber_present)
    {
      ConfInd.u.Indication.u.IndVendorId.pProductNumber =
        pPdu->u.indication.u.vendorIdentification.productNumber.value;
      ConfInd.u.Indication.u.IndVendorId.byProductNumberLength = (BYTE)
        pPdu->u.indication.u.vendorIdentification.productNumber.length;
    }
    if (pPdu->u.indication.u.vendorIdentification.bit_mask & versionNumber_present)
    {
      ConfInd.u.Indication.u.IndVendorId.pVersionNumber =
        pPdu->u.indication.u.vendorIdentification.versionNumber.value;
      ConfInd.u.Indication.u.IndVendorId.byVersionNumberLength = (BYTE)
        pPdu->u.indication.u.vendorIdentification.versionNumber.length;
    }
    break;

  case  H245_IND_FUNCTION_NOT_SUPPORTED:
    H245ASSERT(pPdu->choice == indication_chosen);
    H245ASSERT(pPdu->u.indication.choice == functionNotSupported_chosen);
    ConfInd.u.Indication.u.IndFns.Cause =
      pPdu->u.indication.u.functionNotSupported.cause.choice;
    ConfInd.u.Indication.u.IndFns.Type = UNKNOWN;

    // Due to OSS 4.2 <-> Oss 4.1.3 bug, and OSS crashing on incomplete PDUs,
    // Let's not decode the returned function. We don't use it anyway.
    /*if (pPdu->u.indication.u.functionNotSupported.bit_mask & returnedFunction_present)
    {
      int                  pduNum = MltmdSystmCntrlMssg_PDU;
      OssBuf               ossBuf;
      MltmdSystmCntrlMssg *pPduReturned;
      ossBuf.value  = pPdu->u.indication.u.functionNotSupported.returnedFunction.value; 
      ossBuf.length = pPdu->u.indication.u.functionNotSupported.returnedFunction.length; 
      if (ossDecode(pInstance->p_ossWorld,
                    &pduNum,
                    &ossBuf,
                    (void * *)&pPduReturned) == PDU_DECODED)
      {
        switch (pPduReturned->choice)
        {
        case MltmdSystmCntrlMssg_rqst_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MltmdSystmCntrlMssg_rqst.choice -
            RqstMssg_nonStandard_chosen + REQ_NONSTANDARD;
          break;
        case MSCMg_rspns_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MSCMg_rspns.choice -
            RspnsMssg_nonStandard_chosen + RSP_NONSTANDARD;
          break;
        case MSCMg_cmmnd_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MSCMg_cmmnd.choice -
            CmmndMssg_nonStandard_chosen + CMD_NONSTANDARD;
          break;
        case indication_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.indication.choice -
            IndctnMssg_nonStandard_chosen + IND_NONSTANDARD;
          break;
        default:
          H245TRACE(pInstance->dwInst, 1,
                    "H245FsmIndication: unrecognized FunctionNotSupported message type %d",
                    pPduReturned->choice);
          lResult = H245_ERROR_NOSUP;
        } // switch
        // Free the PDU
        if (ossFreePDU(pInstance->p_ossWorld, pduNum, pPduReturned))
        {
          H245TRACE(pInstance->dwInst, 1, "H245FsmIndication: FREE FAILURE");
        }
      }
    }
    */
    break;

  case  H245_IND_H223_RECONFIG:
    H245ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    H245ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == h223AnnxARcnfgrtn_chosen);
    break;

  case  H245_IND_H223_RECONFIG_ACK:
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == h223AnnxARcnfgrtnAck_chosen);
    break;

  case  H245_IND_H223_RECONFIG_REJECT:
    H245ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    H245ASSERT(pPdu->u.MSCMg_rspns.choice == h223AnnxARcnfgrtnRjct_chosen);
    break;

  default:
    /* Possible Error */
    H245TRACE(pInstance->dwInst, 1,
              "H245FsmIndication -> Invalid Indication Event %d", dwEvent);
    lResult = H245_ERROR_SUBSYS;
  } // switch

  if (lResult == H245_ERROR_OK)
  {
    if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
    {
      H245FunctionNotUnderstood(pInstance, pPdu);
    }
    H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
  }
  else
  {
    H245TRACE(pInstance->dwInst,1,"H245FsmIndication -> %s", map_api_error(lResult));
  }

#if 1
  if (pwchar)
    H245_free(pwchar);
#endif

  return lResult;
} // H245FsmIndication()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\api_debu.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   api_Debu.c  $
 *  $Revision:   1.4  $
 *  $Modtime:   10 Jun 1996 12:36:08  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_Debu.c_v  $
 * 
 *    Rev 1.4   10 Jun 1996 16:53:06   EHOWARDX
 * Eliminated #include "h245init.x"
 * 
 *    Rev 1.3   06 Jun 1996 18:51:14   EHOWARDX
 * Made tracker dump more aesthetically pleasing.
 *
 *    Rev 1.2   28 May 1996 14:25:36   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   20 May 1996 14:34:42   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.0   09 May 1996 21:06:06   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.7   09 May 1996 19:30:24   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.6   02 Apr 1996 10:14:08   cjutzi
 * - changed tracker structure
 *
 *    Rev 1.5   11 Mar 1996 14:28:48   cjutzi
 *
 * - removed oil debug include
 * d
 *
 *    Rev 1.4   06 Mar 1996 12:33:46   cjutzi
 * - renamed API_MUX_T to API_SEND_MUX_T
 *
 *    Rev 1.3   16 Feb 1996 13:00:30   cjutzi
 *
 * - added tracker dumper
 *
 *    Rev 1.2   15 Feb 1996 15:42:52   cjutzi
 *
 * - std.h and wtypes.h modified.. al'a Loren..
 *
 *    Rev 1.1   09 Feb 1996 16:58:08   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *  $Ident$
 *
 *****************************************************************************/

#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   dump_tracker
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/

void
dump_tracker(struct InstanceStruct *pInstance)
{
  register Tracker_T *p_tracker;
  register char      *p_str;

  H245ASSERT (pInstance != NULL);
  H245TRACE(pInstance->dwInst, 10, "************ TRACKER DUMP START ********");

  for (p_tracker = pInstance->API.pTracker; p_tracker; p_tracker = p_tracker->p_next)
    {
      if (p_tracker != pInstance->API.pTracker)
        H245TRACE(pInstance->dwInst, 10, "");
      H245TRACE(pInstance->dwInst, 10, "TransId           %04d(0x%04x)",p_tracker->TransId,p_tracker->TransId);
      switch (p_tracker->TrackerType)
        {
        case API_TERMCAP_T:             p_str="API_TERMCAP_T";      break;
        case API_OPEN_CHANNEL_T:        p_str="API_OPEN_CHANNEL_T"; break;
        case API_CLOSE_CHANNEL_T:       p_str="API_CLOSE_CHANNEL_T";break;
        case API_MSTSLV_T:              p_str="API_MSTSLV_T";       break;
        case API_SEND_MUX_T:            p_str="API_SEND_MUX_T";     break;
        case API_RECV_MUX_T:            p_str="API_RECV_MUX_T";     break;
        default:        p_str="<<UNKNOWN>>";        break;
        }
      H245TRACE(pInstance->dwInst, 10, "Tracker Type      %s",p_str);
      switch (p_tracker->State)
        {
        case API_ST_WAIT_RMTACK:        p_str="API_ST_WAIT_RMTACK"; break;
        case API_ST_WAIT_LCLACK:        p_str="API_ST_WAIT_LCLACK"; break;
        case API_ST_WAIT_LCLACK_CANCEL: p_str="API_ST_WAIT_LCLACK_CANCEL"; break;
        case API_ST_WAIT_CONF:          p_str="API_ST_WAIT_CONF";   break;
        case API_ST_IDLE:               p_str="API_ST_IDLE";        break;
        default:                        p_str="<<UNKNOWN>>";        break;
        }
      H245TRACE(pInstance->dwInst, 10, "Tracker State     %s",p_str);

      if (p_tracker->TrackerType == API_OPEN_CHANNEL_T ||
          p_tracker->TrackerType == API_CLOSE_CHANNEL_T)
        {
          switch (p_tracker->u.Channel.ChannelAlloc)
            {
            case API_CH_ALLOC_UNDEF:    p_str="API_CH_ALLOC_UNDEF"; break;
            case API_CH_ALLOC_LCL:      p_str="API_CH_ALLOC_LCL";   break;
            case API_CH_ALLOC_RMT:      p_str="API_CH_ALLOC_RMT";   break;
            default:                    p_str="<<UNKNOWN>>";        break;
            }
          H245TRACE(pInstance->dwInst, 10, "Channel Alloc     %s",p_str);
          switch (p_tracker->u.Channel.ChannelType)
            {
            case API_CH_TYPE_UNDEF:     p_str="API_CH_TYPE_UNDEF";  break;
            case API_CH_TYPE_UNI:       p_str="API_CH_TYPE_UNI";    break;
            case API_CH_TYPE_BI:        p_str="API_CH_TYPE_BI";     break;
            default:                    p_str="<<UNKNOWN>>";        break;
            }
          H245TRACE(pInstance->dwInst, 10, "Channel Type      %s",p_str);
          if (p_tracker->u.Channel.RxChannel == H245_INVALID_CHANNEL)
            H245TRACE(pInstance->dwInst, 10, "Channel Rx        H245_INVALID_CHANNEL");
          else
            H245TRACE(pInstance->dwInst, 10, "Channel Rx        %d",p_tracker->u.Channel.RxChannel);
          if (p_tracker->u.Channel.TxChannel == H245_INVALID_CHANNEL)
            H245TRACE(pInstance->dwInst, 10, "Channel Tx        H245_INVALID_CHANNEL");
          else
            H245TRACE(pInstance->dwInst, 10, "Channel Tx        %d",p_tracker->u.Channel.TxChannel);
        }
      else if (p_tracker->TrackerType == API_SEND_MUX_T ||
               p_tracker->TrackerType == API_RECV_MUX_T)
        {
          H245TRACE(pInstance->dwInst, 10, "MuxEntryCount     %d",p_tracker->u.MuxEntryCount);
        }
    }

  H245TRACE(pInstance->dwInst, 10, "************ TRACKER DUMP END **********");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\fsmapi.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsmapi.c                                                  *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMAPI.C  $
 * $Revision:   1.12  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\fsmapi.c_v $
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "h245deb.x"



extern char *EntityName[];



/*
 * This table maps FSM stateless events into H.245 API events
 */
static WORD StatelessTable[NUM_EVENTS - NUM_STATE_EVENTS] =
{
  H245_IND_NONSTANDARD_REQUEST,     // NonStandardRequestPDU
  H245_IND_NONSTANDARD_RESPONSE,    // NonStandardResponsePDU
  H245_IND_NONSTANDARD_COMMAND,     // NonStandardCommandPDU
  H245_IND_NONSTANDARD,             // NonStandardIndicationPDU
  H245_IND_MISC_COMMAND,            // MiscellaneousCommandPDU
  H245_IND_MISC,                    // MiscellaneousIndicationPDU
  H245_IND_COMM_MODE_REQUEST,       // CommunicationModeRequestPDU
  H245_IND_COMM_MODE_RESPONSE,      // CommunicationModeResponsePDU
  H245_IND_COMM_MODE_COMMAND,       // CommunicationModeCommandPDU
  H245_IND_CONFERENCE_REQUEST,      // ConferenceRequestPDU
  H245_IND_CONFERENCE_RESPONSE,     // ConferenceResponsePDU
  H245_IND_CONFERENCE_COMMAND,      // ConferenceCommandPDU
  H245_IND_CONFERENCE,              // ConferenceIndicationPDU
  H245_IND_SEND_TERMCAP,            // SendTerminalCapabilitySetPDU
  H245_IND_ENCRYPTION,              // EncryptionCommandPDU
  H245_IND_FLOW_CONTROL,            // FlowControlCommandPDU
  H245_IND_ENDSESSION,              // EndSessionCommandPDU
  H245_IND_FUNCTION_NOT_UNDERSTOOD, // FunctionNotUnderstoodIndicationPDU
  H245_IND_JITTER,                  // JitterIndicationPDU
  H245_IND_H223_SKEW,               // H223SkewIndicationPDU
  H245_IND_NEW_ATM_VC,              // NewATMVCIndicationPDU
  H245_IND_USERINPUT,               // UserInputIndicationPDU
  H245_IND_H2250_MAX_SKEW,          // H2250MaximumSkewIndicationPDU
  H245_IND_MC_LOCATION,             // MCLocationIndicationPDU
  H245_IND_VENDOR_ID,               // VendorIdentificationIndicationPDU
  H245_IND_FUNCTION_NOT_SUPPORTED,  // FunctionNotSupportedIndicationPDU
};



/*
 * Configurable counter values
 */

unsigned int    uN100 = 10;              // Master Slave Determination



/*
 * Configurable timer values
 */

unsigned int    uT101 = 30000;          // Capability Exchange
unsigned int    uT102 = 30000;          // Maintenance Loop
unsigned int    uT103 = 30000;          // Logical Channel Signalling
unsigned int    uT104 = 30000;          // H.223 Multiplex Table
unsigned int    uT105 = 30000;          // Round Trip Delay
unsigned int    uT106 = 30000;          // Master Slave Determination
unsigned int    uT107 = 30000;          // Request Multiplex Entry
unsigned int    uT108 = 30000;          // Send Logical Channel
unsigned int    uT109 = 30000;          // Mode Request



/*
 *  NAME
 *      ObjectCreate - create an State Entity object
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM instance data
 *      INPUT   Entity      State Entity represented by object, e.g. LCSE_OUT
 *      INPUT   Key         Lookup key for distinguish multiple instances of SE
 *      INPUT   dwTransId   Transaction identifier to be sent up to client
 *
 *  RETURN VALUE
 *      pObject     Function succeeded
 *      NULL        Memory allocation failed
 */

Object_t * 
ObjectCreate(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key, DWORD dwTransId)
{
    register Object_t * pObject;

#if defined(DBG)
    H245TRACE(pInstance->dwInst, 4, "ObjectCreate: Entity=%s(%d) Key=%d dwTransID=0x%x",
              EntityName[Entity], Entity, Key, dwTransId);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectCreate: Entity=%d Key=%d dwTransID=0x%x",
              Entity, Key, dwTransId);
#endif

    pObject = (Object_t *)H245_malloc(sizeof(*pObject));
    if (pObject == NULL)
    {
        H245TRACE(pInstance->dwInst, 1, "ObjectCreate: FSM Object memory allocation failed");
        return NULL;
    }
    memset(pObject, 0, sizeof(*pObject));

    /* copy primitive variables to my object */
    pObject->pInstance   = pInstance;
    pObject->dwInst      = pInstance->dwInst;
    pObject->dwTransId   = dwTransId;
    pObject->Key         = Key;
    pObject->Entity      = Entity;

    pObject->pNext       = pInstance->StateMachine.Object_tbl[Entity];
    pInstance->StateMachine.Object_tbl[Entity] = pObject;

    return pObject;
} // ObjectCreate()



/*
 *  NAME
 *      ObjectDestroy - deallocate an object created by ObjectCreate()
 *
 *
 *  PARAMETERS
 *  INPUT   pInst       pointer to FSM instance data
 *  INPUT   id          index into the object table
 *
 *  RETURN VALUE
 *      FALSE           object deallocated
 *      TRUE            object not found
 */

int 
ObjectDestroy(Object_t *pObject)
{
    struct InstanceStruct * pInstance;
    Object_t *              pSearch;
    Object_t *              pPrev;

    H245ASSERT(pObject != NULL);
    H245ASSERT(pObject->uNestLevel == 0);
    H245ASSERT(pObject->pInstance != NULL);
    pInstance = pObject->pInstance;

#if defined(DBG)
    H245TRACE(pInstance->dwInst, 4, "ObjectDestroy: Entity=%s(%d) Key=%d State=%d",
              EntityName[pObject->Entity], pObject->Entity, pObject->Key, pObject->State);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectDestroy: Entity=%d Key=%d State=%d",
              pObject->Entity, pObject->Key, pObject->State);
#endif

    if (pObject->dwTimerId)
    {
        H245TRACE(pObject->dwInst, 4, "ObjectDestroy: stoping timer");
        FsmStopTimer(pObject);
    }

    if (pInstance->StateMachine.Object_tbl[pObject->Entity] == NULL)
    {
        H245TRACE(pInstance->dwInst, 1, "ObjectDestroy: no State Entity of specified type found");
        return TRUE;
    }

    if (pInstance->StateMachine.Object_tbl[pObject->Entity] == pObject)
    {
        pInstance->StateMachine.Object_tbl[pObject->Entity] = pObject->pNext;
        H245_free(pObject);
        return FALSE;
    }

    pPrev = pInstance->StateMachine.Object_tbl[pObject->Entity];
    pSearch = pPrev->pNext;
    while (pSearch != NULL)
    {
        if (pSearch == pObject)
        {
            pPrev->pNext = pSearch->pNext;
            H245_free(pObject);
            return FALSE;
        }
        pPrev = pSearch;
        pSearch = pSearch->pNext;
    }

    H245TRACE(pInstance->dwInst, 1, "ObjectDestroy: State Entity not found");
    return TRUE;
} // ObjectDestroy()



/*
 *  NAME
 *      ObjectFind - given parsed information of a PDU, it searches the object table for
 *                         an object with a matching id, type and category
 *
 *
 *  PARAMETERS
 *  INPUT    pInst
 *  INPUT    Category       category of a given PDU
 *  INPUT    Type           type of the PDU
 *  INPUT    pdu_id         unique id shared by PDU and object (usually channel number or sequence number)
 *
 *  RETURN VALUE
 *      pObject   object found
 *      NULL      object not found
 */

Object_t * 
ObjectFind(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key)
{
    register Object_t * pObject;

    H245ASSERT(Entity < STATELESS);
    pObject = pInstance->StateMachine.Object_tbl[Entity];
    while (pObject != NULL)
    {
        if (pObject->Key == Key)
        {
#if defined(DBG)
            H245TRACE(pInstance->dwInst, 4, "ObjectFind(%s, %d) object found",
                      EntityName[Entity], Key);
#else
            H245TRACE(pInstance->dwInst, 4, "ObjectFind(%d, %d) object found",
                      Entity, Key);
#endif
            return pObject;
        }
        pObject = pObject->pNext;
    }

#if defined(DBG)
    H245TRACE(pInstance->dwInst, 4, "ObjectFind(%s, %d) object not found",
              EntityName[Entity], Key);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectFind(%d, %d) object not found",
              Entity, Key);
#endif
    return NULL;
} // ObjectFind()



/*
 *  NAME
 *      SendFunctionNotUnderstood - builds and sends Function Not Supported PDU
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst   Current H.245 instance
 *      INPUT   pPdu     Not supported PDU
 *
 *  RETURN VALUE
 *      H245_ERROR_OK
 */


HRESULT
SendFunctionNotUnderstood(struct InstanceStruct *pInstance, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    switch (pPdu->choice)
    {
    case MltmdSystmCntrlMssg_rqst_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_request_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_request =
          pPdu->u.MltmdSystmCntrlMssg_rqst;
        break;

    case MSCMg_rspns_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_response_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_response =
          pPdu->u.MSCMg_rspns;
        break;

    case MSCMg_cmmnd_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_command_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_command =
          pPdu->u.MSCMg_cmmnd;
        break;

    default:
        // Can't reply to unsupported indication...
        H245_free(pOut);
        return H245_ERROR_OK;
    } // switch (Type)

    pOut->choice = indication_chosen;
    pOut->u.indication.choice = functionNotUnderstood_chosen;
    lError = sendPDU(pInstance, pOut);
    H245_free(pOut);
    return lError;
} // SendFunctionNotUnderstood()



/*
 *  NAME
 *      FsmOutgoing - process outbound PDU
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM instance structure
 *      INPUT   pPdu        Pointer to PDU to send
 *      INPUT   dwTransId   Transaction identifier to use for response
 *
 *  RETURN VALUE
 *      Error codes defined in h245com.h
 */

HRESULT
FsmOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu, DWORD dwTransId)
{
    HRESULT             lError;
    Entity_t            Entity;
    Event_t             Event;
    Key_t               Key;
    int                 bCreate;
    Object_t *          pObject;

    H245ASSERT(pInstance != NULL);
    H245ASSERT(pPdu != NULL);
    H245TRACE(pInstance->dwInst, 4, "FsmOutgoing");

#if defined(DBG)
    if (check_pdu(pInstance, pPdu))
      return H245_ERROR_ASN1;
#endif // (DEBUG)

    lError = PduParseOutgoing(pInstance, pPdu, &Entity, &Event, &Key, &bCreate);
    if (lError != H245_ERROR_OK)
    {
        H245TRACE(pInstance->dwInst, 1,
          "FsmOutgoing: PDU not recognized; Error=%d", lError);
        return lError;
    }

    H245ASSERT(Entity < NUM_ENTITYS);

    if (Entity == STATELESS)
    {
        H245TRACE(pInstance->dwInst, 4, "FsmOutgoing: Sending stateless PDU");
        return sendPDU(pInstance, pPdu);
    }

    H245ASSERT(Event < NUM_STATE_EVENTS);

    pObject = ObjectFind(pInstance, Entity, Key);
    if (pObject == NULL)
    {
        if (bCreate == FALSE)
        {
#if defined(DBG)
            H245TRACE(pInstance->dwInst, 1,
                      "FsmOutgoing: State Entity %s(%d) not found; Key=%d",
                      EntityName[Entity], Entity, Key);
#else
            H245TRACE(pInstance->dwInst, 1,
                      "FsmOutgoing: State Entity %d not found; Key=%d",
                      Entity, Key);
#endif
            return H245_ERROR_PARAM;
        }
        pObject = ObjectCreate(pInstance, Entity, Key, dwTransId);
        if (pObject == NULL)
        {
            H245TRACE(pInstance->dwInst, 1, "FsmOutgoing: State Entity memory allocation failed");
            return H245_ERROR_NOMEM;
        }
    }
    else
    {
        pObject->dwTransId = dwTransId;
    }

    return StateMachine(pObject, pPdu, Event);
} // FsmOutgoing()



/*
 *  NAME
 *      FsmIncoming - process inbound PDU
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current H.245 instance
 *      INPUT   pPdu        pointer to a PDU structure
 *
 *  RETURN VALUE
 *      error codes defined in h245com.h (not checked)
 */

HRESULT
FsmIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu)
{
    HRESULT             lError;
    Entity_t            Entity;
    Event_t             Event;
    Key_t               Key;
    int                 bCreate;
    Object_t *          pObject;
    Object_t *          pObject1;

    H245ASSERT(pInstance != NULL);
    H245ASSERT(pPdu != NULL);
    H245TRACE(pInstance->dwInst, 4, "FsmIncoming");

    lError = PduParseIncoming(pInstance, pPdu, &Entity, &Event, &Key, &bCreate);
    if (lError != H245_ERROR_OK)
    {
        H245TRACE(pInstance->dwInst, 1,
          "FsmIncoming: Received PDU not recognized", lError);
        SendFunctionNotUnderstood(pInstance, pPdu);
        return lError;
    }

    H245ASSERT(Entity < NUM_ENTITYS);

    if (Entity == STATELESS)
    {
        H245TRACE(pInstance->dwInst, 4, "FsmIncoming: Received stateless PDU");
        return H245FsmIndication(pPdu, (DWORD)StatelessTable[Event - NUM_STATE_EVENTS], pInstance, 0, H245_ERROR_OK);
    }

    H245ASSERT(Event < NUM_STATE_EVENTS);

    if (Event == MaintenanceLoopOffCommandPDU)
    {
        // Special case MaintenanceLoopOff applies to ALL loops
        H245ASSERT(Entity == MLSE_IN);
        pObject = pInstance->StateMachine.Object_tbl[Entity];
        if (pObject == NULL)
        {
            return H245_ERROR_OK;
        }
        lError = StateMachine(pObject, pPdu, Event);
        pObject = pInstance->StateMachine.Object_tbl[Entity];
        while (pObject)
        {
            if (pObject->uNestLevel == 0)
            {
                pObject1 = pObject;
                pObject  = pObject->pNext;
                ObjectDestroy(pObject1);
            }
            else
            {
                pObject->State = 0;
                pObject = pObject->pNext;
            }
        }
        return lError;
    } // if

    pObject = ObjectFind(pInstance, Entity, Key);
    if (pObject == NULL)

    {
        if (bCreate == FALSE)
        {
#if defined(DBG)
            H245TRACE(pInstance->dwInst, 1,
                      "FsmIncoming: State Entity %s(%d) not found; Key=%d",
                      EntityName[Entity], Entity, Key);
#else
            H245TRACE(pInstance->dwInst, 1,
                      "FsmIncoming: State Entity %d not found; Key=%d",
                      Entity, Key);
#endif
            return H245_ERROR_PARAM;
        }
        pObject = ObjectCreate(pInstance, Entity, Key, 0);
        if (pObject == NULL)
        {
            H245TRACE(pInstance->dwInst, 1, "FsmIncoming: State Entity memory allocation failed");
            return H245_ERROR_NOMEM;
        }
    }

    return StateMachine(pObject, pPdu, Event);
} // FsmIncoming()



# pragma warning( disable : 4100 )

// CAVEAT: Need to save dwInst since StateMachine() might deallocate pObject!
HRESULT
FsmTimerEvent(struct InstanceStruct *pInstance, DWORD dwTimerId, Object_t *pObject, Event_t Event)
{
    H245ASSERT(pInstance != NULL);
    H245ASSERT(pObject   != NULL);
    H245ASSERT(pObject->pInstance == pInstance);
    H245ASSERT(pObject->dwTimerId == dwTimerId);
    H245TRACE(pInstance->dwInst, 4, "FsmTimerEvent");
    pObject->dwTimerId = 0;
    return StateMachine(pObject, NULL, Event);
} // FsmTimerEvent()

# pragma warning( default : 4100 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\fsm.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsm.c                                                     *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSM.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/FSM.C_v  $
 * 
 *    Rev 1.5   09 Dec 1996 13:34:28   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.4   02 Jul 1996 00:09:24   EHOWARDX
 * 
 * Added trace of state after state machine function called.
 * 
 *    Rev 1.3   30 May 1996 23:39:04   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.2   29 May 1996 15:20:12   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:48   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:12   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.16.1.4   09 May 1996 19:48:34   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.16.1.3   25 Apr 1996 17:00:18   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.16.1.2   15 Apr 1996 10:45:38   EHOWARDX
 * Update.
 *
 *    Rev 1.16.1.1   10 Apr 1996 21:16:06   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.16.1.0   05 Apr 1996 12:21:16   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openu.h"
#include "openb.h"
#include "rqstcls.h"
#include "termcap.h"
#include "muxentry.h"
#include "rmese.h"
#include "mrse.h"
#include "mlse.h"
#include "mstrslv.h"
#include "rtdse.h"



#if defined(DBG)

// Signalling Entity definitions
char *               EntityName[NUM_ENTITYS] =
{
// Per-channel Signalling Entities
       "LCSE_OUT",  //         0    Uni-directional Logical Channel signalling Signalling Entity - Outbound
       "LCSE_IN",   //         1    Uni-directional Logical Channel signalling Signalling Entity - Inbound
       "BLCSE_OUT", //         2    Bi-directional  Logical Channel signalling Signalling Entity - Outbound
       "BLCSE_IN",  //         3    Bi-directional  Logical Channel signalling Signalling Entity - Inbound
       "CLCSE_OUT", //         4    Close           Logical Channel signalling Signalling Entity - Outbound
       "CLCSE_IN",  //         5    Close           Logical Channel signalling Signalling Entity - Inbound

// Per H.245 Instance Signalling Entities
       "CESE_OUT",  //         6    Capability Exchange Signalling Entity - Out-going
       "CESE_IN",   //         7    Capability Exchange Signalling Entity - In-coming
       "MTSE_OUT",  //         8    Multiplex Table Signalling Entity - Out-going
       "MTSE_IN",   //         9    Multiplex Table Signalling Entity - In-coming
       "RMESE_OUT", //        10    Request Multiplex Entry Signalling Entity - Out-going
       "RMESE_IN",  //        11    Request Multiplex Entry Signalling Entity - In-coming
       "MRSE_OUT",  //        12    Mode Request Signalling Entity - Out-going
       "MRSE_IN",   //        13    Mode Request Signalling Entity - In-coming
       "MLSE_OUT",  //        14    Maintenance Loop Signalling Entity - Out-going
       "MLSE_IN",   //        15    Maintenance Loop Signalling Entity - In-coming
       "MSDSE",     //        16    Master Slave Determination Signalling Entity
       "RTDSE",     //        17    Round Trip Delay Signalling Entity
       "STATELESS", //        18    No state machine associated with PDU
};




// Event definitions
char *               EventName[NUM_EVENTS] =
{
// Out-going Uni-directional Logical Channel (LCSE_OUT) events
       "ReqUEstablish",                 //         0
       "OpenUChAckPDU",                 //         1
       "OpenUChRejectPDU",              //         2
       "CloseUChAckPDU",                //         3
       "ReqURelease",                   //         4
       "T103Expiry",                    //         5

// In-coming Uni-directional Logical Channel (LCSE_IN) events
       "OpenUChPDU",                    //         6
       "CloseUChPDU",                   //         7
       "ResponseUEstablish",            //         8
       "EstablishUReject",              //         9

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
       "ReqBEstablish",                 //        10
       "OpenBChAckPDU",                 //        11
       "OpenBChRejectPDU",              //        12
       "CloseBChAckPDU",                //        13
       "ReqClsBLCSE",                   //        14
       "RspConfirmBLCSE",               //        15
       "T103OutExpiry",                 //        16

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
       "OpenBChPDU",                    //        17
       "CloseBChPDU",                   //        18
       "ResponseBEstablish",            //        19
       "OpenBChConfirmPDU",             //        20
       "OpenRejectBLCSE",               //        21
       "T103InExpiry",                  //        22

// Out-going Request Close Logical Channel (CLCSE_OUT) events
       "ReqClose",                      //        23
       "ReqChCloseAckPDU",              //        24
       "ReqChCloseRejectPDU",           //        25
       "T108Expiry",                    //        26

// In-coming Request Close Logical Channel (CLCSE_IN) events
       "ReqChClosePDU",                 //        27
       "ReqChCloseReleasePDU",          //        28
       "CLCSE_CLOSE_response",          //        29
       "CLCSE_REJECT_request",          //        30

// Out-going Terminal Capablity Exchange (CESE_OUT) events
       "TransferCapRequest",            //        31
       "TermCapSetAckPDU",              //        32
       "TermCapSetRejectPDU",           //        33
       "T101Expiry",                    //        34

// In-coming Terminal Capablity Exchange (CESE_IN) events
       "TermCapSetPDU",                 //        35
       "TermCapSetReleasePDU",          //        36
       "CESE_TRANSFER_response",        //        37
       "CESE_REJECT_request",           //        38

// Out-going Multiplex Table (MTSE_OUT) events
       "MTSE_TRANSFER_request",         //        39
       "MultiplexEntrySendAckPDU",      //        40
       "MultiplexEntrySendRejectPDU",   //        41
       "T104Expiry",                    //        42

// In-coming Multiplex Table (MTSE_IN) events
       "MultiplexEntrySendPDU",         //        43
       "MultiplexEntrySendReleasePDU",  //        44
       "MTSE_TRANSFER_response",        //        45
       "MTSE_REJECT_request",           //        46

// Out-going Request Multiplex Entry (RMESE_OUT) events
       "RMESE_SEND_request",            //        47
       "RequestMultiplexEntryAckPDU",   //        48
       "RequestMultiplexEntryRejectPDU",//        49
       "T107Expiry",                    //        50

// In-coming Request Multiplex Entry (RMESE_IN) events
       "RequestMultiplexEntryPDU",      //        51
       "RequestMultiplexEntryReleasePDU",//       52
       "RMESE_SEND_response",           //        53
       "RMESE_REJECT_request",          //        54

// Out-going Mode Request (MRSE_OUT) events
       "MRSE_TRANSFER_request",         //        55
       "RequestModeAckPDU",             //        56
       "RequestModeRejectPDU",          //        57
       "T109Expiry",                    //        58

// In-coming Mode Request (MRSE_IN) events
       "RequestModePDU",                //        59
       "RequestModeReleasePDU",         //        60
       "MRSE_TRANSFER_response",        //        61
       "MRSE_REJECT_request",           //        62

// Out-going Maintenance Loop (MLSE_OUT) events
       "MLSE_LOOP_request",             //        63
       "MLSE_OUT_RELEASE_request",      //        64
       "MaintenanceLoopAckPDU",         //        65
       "MaintenanceLoopRejectPDU",      //        66
       "T102Expiry",                    //        67

// In-coming Maintenance Loop (MLSE_IN) events
       "MaintenanceLoopRequestPDU",     //        68
       "MaintenanceLoopOffCommandPDU",  //        69
       "MLSE_LOOP_response",            //        70
       "MLSE_IN_RELEASE_request",       //        71

// Master Slave Determination (MSDSE) events
       "MSDetReq",                      //        72
       "MSDetPDU",                      //        73
       "MSDetAckPDU",                   //        74
       "MSDetRejectPDU",                //        75
       "MSDetReleasePDU",               //        76
       "T106Expiry",                    //        77

// Round Trip Delay Delay (RTDSE) events
       "RTDSE_TRANSFER_request",        //        78
       "RoundTripDelayRequestPDU",      //        79
       "RoundTripDelayResponsePDU",     //        80
       "T105Expiry",                    //        81



// Events with no associated state entity
       "NonStandardRequestPDU",         //        82
       "NonStandardResponsePDU",        //        83
       "NonStandardCommandPDU",         //        84
       "NonStandardIndicationPDU",      //        85
       "MiscellaneousRequestPDU",       //        86
       "MiscellaneousResponsePDU",      //        87
       "MiscellaneousCommandPDU",       //        88
       "MiscellaneousIndicationPDU",    //        89
       "CommunicationModeRequestPDU",   //        90
       "CommunicationModeResponsePDU",  //        91
       "CommunicationModeCommandPDU",   //        92
       "SendTerminalCapabilitySetPDU",  //        93
       "EncryptionCommandPDU",          //        94
       "FlowControlCommandPDU",         //        95
       "EndSessionCommandPDU",          //        96
       "FunctionNotSupportedIndicationPDU",//       97
       "JitterIndicationPDU",           //        98
       "H223SkewIndicationPDU",         //        99
       "NewATMVCIndicationPDU",         //       100
       "UserInputIndicationPDU",        //       101
       "H2250MaximumSkewIndicationPDU", //       102
       "MCLocationIndicationPDU",       //       103
};




// Output function definitions
char *                OutputName[NUM_OUTPUTS] =
{
// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
       "EstablishReleased",             //          0
       "OpenAckAwaitingE",              //          1
       "OpenRejAwaitingE",              //          2
       "ReleaseAwaitingE",              //          3
       "T103AwaitingE",                 //          4
       "ReleaseEstablished",            //          5
       "OpenRejEstablished",            //          6
       "CloseAckEstablished",           //          7
       "CloseAckAwaitingR",             //          8
       "OpenRejAwaitingR",              //          9
       "T103AwaitingR",                 //         10
       "EstablishAwaitingR",            //         11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
       "OpenReleased",                  //         12
       "CloseReleased",                 //         13
       "ResponseAwaiting",              //         14
       "ReleaseAwaiting",               //         15
       "CloseAwaiting",                 //         16
       "OpenAwaiting",                  //         17
       "CloseEstablished",              //         18
       "OpenEstablished",               //         19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
       "EstablishReqBReleased",         //         20
       "OpenChannelAckBAwaitingE",      //         21
       "OpenChannelRejBAwaitingE",      //         22
       "ReleaseReqBOutAwaitingE",       //         23
       "T103ExpiryBAwaitingE",          //         24
       "ReleaseReqBEstablished",        //         25
       "OpenChannelRejBEstablished",    //         26
       "CloseChannelAckBEstablished",   //         27
       "CloseChannelAckAwaitingR",      //         28
       "OpenChannelRejBAwaitingR",      //         29
       "T103ExpiryBAwaitingR",          //         30
       "EstablishReqAwaitingR",         //         31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
       "OpenChannelBReleased",          //         32
       "CloseChannelBReleased",         //         33
       "EstablishResBAwaitingE",        //         34
       "ReleaseReqBInAwaitingE",        //         35
       "CloseChannelBAwaitingE",        //         36
       "OpenChannelBAwaitingE",         //         37
       "OpenChannelConfirmBAwaitingE",  //         38
       "T103ExpiryBAwaitingC",          //         39
       "OpenChannelConfirmBAwaitingC",  //         40
       "CloseChannelBAwaitingC",        //         41
       "OpenChannelBAwaitingC",         //         42
       "CloseChannelBEstablished",      //         43
       "OpenChannelBEstablished",       //         44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
       "CloseRequestIdle",              //         45
       "RequestCloseAckAwaitingR",      //         46
       "RequestCloseRejAwaitingR",      //         47
       "T108ExpiryAwaitingR",           //         48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
       "RequestCloseIdle",              //         49
       "CloseResponseAwaitingR",        //         50
       "RejectRequestAwaitingR",        //         51
       "RequestCloseReleaseAwaitingR",  //         52
       "RequestCloseAwaitingR",         //         53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
       "RequestCapIdle",                //         54
       "TermCapAckAwaiting",            //         55
       "TermCapRejAwaiting",            //         56
       "T101ExpiryAwaiting",            //         57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
       "TermCapSetIdle",                //         58
       "ResponseCapAwaiting",           //         59
       "RejectCapAwaiting",             //         60
       "TermCapReleaseAwaiting",        //         61
       "TermCapSetAwaiting",            //         62

// Out-going Multiplex Table (MTSE_OUT) state functions
       "MTSE0_TRANSFER_request",        //         63
       "MTSE1_TRANSFER_request",        //         64
       "MTSE1_MultiplexEntrySendAck",   //         65
       "MTSE1_MultiplexEntrySendRej",   //         66
       "MTSE1_T104Expiry",              //         67

// In-coming Multiplex Table (MTSE_IN) state functions
       "MTSE0_MultiplexEntrySend",      //         68
       "MTSE1_MultiplexEntrySend",      //         69
       "MTSE1_MultiplexEntrySendRelease",//        70
       "MTSE1_TRANSFER_response",       //         71
       "MTSE1_REJECT_request",          //         72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
       "RMESE0_SEND_request",           //         73
       "RMESE1_SEND_request",           //         74
       "RMESE1_RequestMuxEntryAck",     //         75
       "RMESE1_RequestMuxEntryRej",     //         76
       "RMESE1_T107Expiry",             //         77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
       "RMESE0_RequestMuxEntry",        //         78
       "RMESE1_RequestMuxEntry",        //         79
       "RMESE1_RequestMuxEntryRelease", //         80
       "RMESE1_SEND_response",          //         81
       "RMESE1_REJECT_request",         //         82

// Out-going Request Mode (MRSE_OUT) state functions
       "MRSE0_TRANSFER_request",        //         83
       "MRSE1_TRANSFER_request",        //         84
       "MRSE1_RequestModeAck",          //         85
       "MRSE1_RequestModeRej",          //         86
       "MRSE1_T109Expiry",              //         87

// In-coming Request Mode (MRSE_IN) state functions
       "MRSE0_RequestMode",             //         88
       "MRSE1_RequestMode",             //         89
       "MRSE1_RequestModeRelease",      //         90
       "MRSE1_TRANSFER_response",       //         91
       "MRSE1_REJECT_request",          //         92

// Out-going Request Mode (MLSE_OUT) state functions
       "MLSE0_LOOP_request",            //         93
       "MLSE1_MaintenanceLoopAck",      //         94
       "MLSE1_MaintenanceLoopRej",      //         95
       "MLSE1_OUT_RELEASE_request",     //         96
       "MLSE1_T102Expiry",              //         97
       "MLSE2_MaintenanceLoopRej",      //         98
       "MLSE2_OUT_RELEASE_request",     //         99

// In-coming Request Mode (MLSE_IN) state functions
       "MLSE0_MaintenanceLoopRequest",  //        100
       "MLSE1_MaintenanceLoopRequest",  //        101
       "MLSE1_MaintenanceLoopOffCommand",//       102
       "MLSE1_LOOP_response",           //        103
       "MLSE1_IN_RELEASE_request",      //        104
       "MLSE2_MaintenanceLoopRequest",  //        105
       "MLSE2_MaintenanceLoopOffCommand",//       106

// Master Slave Determination (MSDSE) state functions
       "DetRequestIdle",                //        107
       "MSDetIdle",                     //        108
       "MSDetAckOutgoing",              //        109
       "MSDetOutgoing",                 //        110
       "MSDetRejOutgoing",              //        111
       "MSDetReleaseOutgoing",          //        112
       "T106ExpiryOutgoing",            //        113
       "MSDetAckIncoming",              //        114
       "MSDetIncoming",                 //        115
       "MSDetRejIncoming",              //        116
       "MSDetReleaseIncoming",          //        117
       "T106ExpiryIncoming",            //        118

// Round Trip Delay (RTDSE) state functions
       "RTDSE0_TRANSFER_request",       //        119
       "RTDSE0_RoundTripDelayRequest",  //        120
       "RTDSE1_TRANSFER_request",       //        121
       "RTDSE1_RoundTripDelayRequest",  //        122
       "RTDSE1_RoundTripDelayResponse", //        123
       "RTDSE1_T105Expiry",             //        124
};
#endif  // (DBG)



typedef HRESULT (*STATE_FUNCTION)(Object_t *pObject, PDU_t *pPdu);

// Output function defintions
static STATE_FUNCTION StateFun[] =
{
// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
        establishReleased,              //          0
        openAckAwaitingE,               //          1
        openRejAwaitingE,               //          2
        releaseAwaitingE,               //          3
        t103AwaitingE,                  //          4
        releaseEstablished,             //          5
        openRejEstablished,             //          6
        closeAckEstablished,            //          7
        closeAckAwaitingR,              //          8
        openRejAwaitingR,               //          9
        t103AwaitingR,                  //         10
        establishAwaitingR,             //         11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
        openReleased,                   //         12
        closeReleased,                  //         13
        responseAwaiting,               //         14
        releaseAwaiting,                //         15
        closeAwaiting,                  //         16
        openAwaiting,                   //         17
        closeEstablished,               //         18
        openEstablished,                //         19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
        establishReqBReleased,          //         20
        openChannelAckBAwaitingE,       //         21
        openChannelRejBAwaitingE,       //         22
        releaseReqBOutAwaitingE,        //         23
        t103ExpiryBAwaitingE,           //         24
        releaseReqBEstablished,         //         25
        openChannelRejBEstablished,     //         26
        closeChannelAckBEstablished,    //         27
        closeChannelAckAwaitingR,       //         28
        openChannelRejBAwaitingR,       //         29
        t103ExpiryBAwaitingR,           //         30
        establishReqAwaitingR,          //         31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
        openChannelBReleased,           //         32
        closeChannelBReleased,          //         33
        establishResBAwaitingE,         //         34
        releaseReqBInAwaitingE,         //         35
        closeChannelBAwaitingE,         //         36
        openChannelBAwaitingE,          //         37
        openChannelConfirmBAwaitingE,   //         38
        t103ExpiryBAwaitingC,           //         39
        openChannelConfirmBAwaitingC,   //         40
        closeChannelBAwaitingC,         //         41
        openChannelBAwaitingC,          //         42
        closeChannelBEstablished,       //         43
        openChannelBEstablished,        //         44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
        closeRequestIdle,               //         45
        requestCloseAckAwaitingR,       //         46
        requestCloseRejAwaitingR,       //         47
        t108ExpiryAwaitingR,            //         48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
        requestCloseIdle,               //         49
        closeResponseAwaitingR,         //         50
        rejectRequestAwaitingR,         //         51
        requestCloseReleaseAwaitingR,   //         52
        requestCloseAwaitingR,          //         53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
        requestCapIdle,                 //         54
        termCapAckAwaiting,             //         55
        termCapRejAwaiting,             //         56
        t101ExpiryAwaiting,             //         57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
        termCapSetIdle,                 //         58
        responseCapAwaiting,            //         59
        rejectCapAwaiting,              //         60
        termCapReleaseAwaiting,         //         61
        termCapSetAwaiting,             //         62

// Out-going Multiplex Table (MTSE_OUT) state functions
        MTSE0_TRANSFER_requestF,        //         63
        MTSE1_TRANSFER_requestF,        //         64
        MTSE1_MultiplexEntrySendAckF,   //         65
        MTSE1_MultiplexEntrySendRejF,   //         66
        MTSE1_T104ExpiryF,              //         67

// In-coming Multiplex Table (MTSE_IN) state functions
        MTSE0_MultiplexEntrySendF,      //         68
        MTSE1_MultiplexEntrySendF,      //         69
        MTSE1_MultiplexEntrySendReleaseF,//        70
        MTSE1_TRANSFER_responseF,       //         71
        MTSE1_REJECT_requestF,          //         72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
        RMESE0_SEND_requestF,           //         73
        RMESE1_SEND_requestF,           //         74
        RMESE1_RequestMuxEntryAckF,     //         75
        RMESE1_RequestMuxEntryRejF,     //         76
        RMESE1_T107ExpiryF,             //         77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
        RMESE0_RequestMuxEntryF,        //         78
        RMESE1_RequestMuxEntryF,        //         79
        RMESE1_RequestMuxEntryReleaseF, //         80
        RMESE1_SEND_responseF,          //         81
        RMESE1_REJECT_requestF,         //         82

// Out-going Request Mode (MRSE_OUT) state functions
        MRSE0_TRANSFER_requestF,        //         83
        MRSE1_TRANSFER_requestF,        //         84
        MRSE1_RequestModeAckF,          //         85
        MRSE1_RequestModeRejF,          //         86
        MRSE1_T109ExpiryF,              //         87

// In-coming Request Mode (MRSE_OUT) state functions
        MRSE0_RequestModeF,             //         88
        MRSE1_RequestModeF,             //         89
        MRSE1_RequestModeReleaseF,      //         90
        MRSE1_TRANSFER_responseF,       //         91
        MRSE1_REJECT_requestF,          //         92

// Out-going Request Mode (MLSE_OUT) state functions
        MLSE0_LOOP_requestF,            //         93
        MLSE1_MaintenanceLoopAckF,      //         94
        MLSE1_MaintenanceLoopRejF,      //         95
        MLSE1_OUT_RELEASE_requestF,     //         96
        MLSE1_T102ExpiryF,              //         97
        MLSE2_MaintenanceLoopRejF,      //         98
        MLSE2_OUT_RELEASE_requestF,     //         99

// In-coming Request Mode (MLSE_IN) state functions
        MLSE0_MaintenanceLoopRequestF,  //        100
        MLSE1_MaintenanceLoopRequestF,  //        101
        MLSE1_MaintenanceLoopOffCommandF,//       102
        MLSE1_LOOP_responseF,           //        103
        MLSE1_IN_RELEASE_requestF,      //        104
        MLSE2_MaintenanceLoopRequestF,  //        105
        MLSE2_MaintenanceLoopOffCommandF,//       106

// Master Slave Determination (MSDSE) state functions
        detRequestIdle,                 //        107
        msDetIdle,                      //        108
        msDetAckOutgoing,               //        109
        msDetOutgoing,                  //        110
        msDetRejOutgoing,               //        111
        msDetReleaseOutgoing,           //        112
        t106ExpiryOutgoing,             //        113
        msDetAckIncoming,               //        114
        msDetIncoming,                  //        115
        msDetRejIncoming,               //        116
        msDetReleaseIncoming,           //        117
        t106ExpiryIncoming,             //        118

// Round Trip Delay (RTDSE) state functions
        RTDSE0_TRANSFER_requestF,       //        119
        RTDSE0_RoundTripDelayRequestF,  //        120
        RTDSE1_TRANSFER_requestF,       //        121
        RTDSE1_RoundTripDelayRequestF,  //        122
        RTDSE1_RoundTripDelayResponseF, //        123
        RTDSE1_T105ExpiryF,             //        124
};



/*********************************************
 *
 * State table for the finite state machine
 *
 *********************************************/

Output_t StateTable[NUM_STATE_EVENTS][MAXSTATES] =
{
// Out-going Uni-directional Logical Channel (LCSE_OUT) events
{EstablishReleased,IGNORE,           IGNORE,             EstablishAwaitingR},  // ReqUEstablish
{IGNORE,           OpenAckAwaitingE, IGNORE,             IGNORE            },  // OpenUChAckPDU
{IGNORE,           OpenRejAwaitingE, OpenRejEstablished, OpenRejAwaitingR  },  // OpenUChRejectPDU
{IGNORE,           IGNORE,           CloseAckEstablished,CloseAckAwaitingR },  // CloseUChAckPDU
{IGNORE,           ReleaseAwaitingE, ReleaseEstablished, IGNORE            },  // ReqURelease
{BAD,              T103AwaitingE,    BAD,                T103AwaitingR     },  // T103Expiry

// In-coming Uni-directional Logical Channel (LCSE_IN) events
{OpenReleased,     OpenAwaiting,     OpenEstablished,    BAD               },  // OpenUChPDU
{CloseReleased,    CloseAwaiting,    CloseEstablished,   BAD               },  // CloseUChPDU
{IGNORE,           ResponseAwaiting, IGNORE,             BAD               },  // ResponseUEstablish
{IGNORE,           ReleaseAwaiting,  IGNORE,             BAD               },  // EstablishUReject

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
{EstablishReqBReleased,IGNORE,                      IGNORE,                      EstablishReqAwaitingR   },// ReqBEstablish
{IGNORE,               OpenChannelAckBAwaitingE,    IGNORE,                      IGNORE                  },// OpenBChAckPDU
{IGNORE,               OpenChannelRejBAwaitingE,    OpenChannelRejBEstablished,  OpenChannelRejBAwaitingR},// OpenBChRejectPDU
{IGNORE,               IGNORE,                      CloseChannelAckBEstablished, CloseChannelAckAwaitingR},// CloseBChAckPDU
{IGNORE,               ReleaseReqBOutAwaitingE,     ReleaseReqBEstablished,      IGNORE                  },// ReqClsBLCSE
{IGNORE,               IGNORE,                      IGNORE,                      IGNORE                  },// RspConfirmBLCSE
{BAD,                  T103ExpiryBAwaitingE,        BAD,                         T103ExpiryBAwaitingR    },// T103OutExpiry

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
{OpenChannelBReleased, OpenChannelBAwaitingE,       OpenChannelBAwaitingC,       OpenChannelBEstablished },// OpenBChPDU
{CloseChannelBReleased,CloseChannelBAwaitingE,      CloseChannelBAwaitingC,      CloseChannelBEstablished},// CloseBChPDU
{IGNORE,               EstablishResBAwaitingE,      IGNORE,                      IGNORE                  },// ResponseBEstablish
{IGNORE,               OpenChannelConfirmBAwaitingE,OpenChannelConfirmBAwaitingC,IGNORE                  },// OpenBChConfirmPDU
{IGNORE,               ReleaseReqBInAwaitingE,      IGNORE,                      IGNORE                  },// OpenRejectBLCSE
{BAD,                  BAD,                         T103ExpiryBAwaitingC,        BAD                     },// T103InExpiry

// Out-going Request Close Logical Channel (CLCSE_OUT) events
{CloseRequestIdle,              IGNORE,                         BAD,BAD},   // ReqClose
{IGNORE,                        RequestCloseAckAwaitingR,       BAD,BAD},   // ReqChCloseAckPDU
{IGNORE,                        RequestCloseRejAwaitingR,       BAD,BAD},   // ReqChCloseRejectPDU
{BAD,                           T108ExpiryAwaitingR,            BAD,BAD},   // T108Expiry

// In-coming Request Close Logical Channel (CLCSE_IN) events
{RequestCloseIdle,              RequestCloseAwaitingR,          BAD,BAD},   // ReqChClosePDU
{IGNORE,                        RequestCloseReleaseAwaitingR,   BAD,BAD},   // ReqChCloseReleasePDU
{IGNORE,                        CloseResponseAwaitingR,         BAD,BAD},   // CLCSE_CLOSE_response
{IGNORE,                        RejectRequestAwaitingR,         BAD,BAD},   // CLCSE_REJECT_request

// Out-going Terminal Capablity Exchange (CESE_OUT) events
{RequestCapIdle,                IGNORE,                         BAD,BAD},   // TransferCapRequest
{IGNORE,                        TermCapAckAwaiting,             BAD,BAD},   // TermCapSetAckPDU
{IGNORE,                        TermCapRejAwaiting,             BAD,BAD},   // TermCapSetRejectPDU
{BAD,                           T101ExpiryAwaiting,             BAD,BAD},   // T101Expiry

// In-coming Terminal Capablity Exchange (CESE_IN) events
{TermCapSetIdle,                TermCapSetAwaiting,             BAD,BAD},   // TermCapSetPDU
{IGNORE,                        TermCapReleaseAwaiting,         BAD,BAD},   // TermCapSetRelPDU
{IGNORE,                        ResponseCapAwaiting,            BAD,BAD},   // CESE_TRANSFER_response
{IGNORE,                        RejectCapAwaiting,              BAD,BAD},   // CESE_REJECT_request

// Out-going Multiplex Table (MTSE_OUT) events
{MTSE0_TRANSFER_request,        MTSE1_TRANSFER_request,         BAD,BAD},   // TRANSFER_request
{IGNORE,                        MTSE1_MultiplexEntrySendAck,    BAD,BAD},   // MultiplexEntrySendAck
{IGNORE,                        MTSE1_MultiplexEntrySendRej,    BAD,BAD},   // MultiplexEntrySendReject
{BAD,                           MTSE1_T104Expiry,               BAD,BAD},   // T104Expiry

// In-coming Multiplex Table (MTSE_IN) events
{MTSE0_MultiplexEntrySend,      MTSE1_MultiplexEntrySend,       BAD,BAD},   // MultiplexEntrySend
{IGNORE,                        MTSE1_MultiplexEntrySendRelease,BAD,BAD},   // MultiplexEntrySendRelease
{IGNORE,                        MTSE1_TRANSFER_response,        BAD,BAD},   // MTSE_TRANSFER_response
{IGNORE,                        MTSE1_REJECT_request,           BAD,BAD},   // MTSE_REJECT_request

// Out-going Request Multiplex Entry (RMESE_OUT) events
{RMESE0_SEND_request,           RMESE1_SEND_request,            BAD,BAD},   // RMESE_SEND_request
{IGNORE,                        RMESE1_RequestMuxEntryAck,      BAD,BAD},   // RequestMultiplexEntryAck
{IGNORE,                        RMESE1_RequestMuxEntryRej,      BAD,BAD},   // RequestMultiplexEntryReject
{BAD,                           RMESE1_T107Expiry,              BAD,BAD},   // T107Expiry

// In-coming Request Multiplex Entry (RMESE_IN) events
{RMESE0_RequestMuxEntry,        RMESE1_RequestMuxEntry,         BAD,BAD},   // RequestMultiplexEntry
{IGNORE,                        RMESE1_RequestMuxEntryRelease,  BAD,BAD},   // RequestMultiplexEntryRelease
{BAD,                           RMESE1_SEND_response,           BAD,BAD},   // RMESE_SEND_response
{BAD,                           RMESE1_REJECT_request,          BAD,BAD},   // RMESE_REJECT_request

// Out-going Mode Request (MRSE_OUT) events
{MRSE0_TRANSFER_request,        MRSE1_TRANSFER_request,         BAD,BAD},   // MRSE_TRANSFER_request
{IGNORE,                        MRSE1_RequestModeAck,           BAD,BAD},   // RequestModeAck
{IGNORE,                        MRSE1_RequestModeRej,           BAD,BAD},   // RequestModeReject
{BAD,                           MRSE1_T109Expiry,               BAD,BAD},   // T109Expiry

// In-coming Mode Request (MRSE_IN) events
{MRSE0_RequestMode,             MRSE1_RequestMode,              BAD,BAD},   // RequestMode
{IGNORE,                        MRSE1_RequestModeRelease,       BAD,BAD},   // RequestModeRelease
{BAD,                           MRSE1_TRANSFER_response,        BAD,BAD},   // MRSE_TRANSFER_response
{BAD,                           MRSE1_REJECT_request,           BAD,BAD},   // MRSE_REJECT_request

// Out-going Maintenance Loop (MLSE_OUT) events
{MLSE0_LOOP_request,            BAD,                            BAD,                            BAD}, // MLSE_LOOP_request
{BAD,                           MLSE1_OUT_RELEASE_request,      MLSE2_OUT_RELEASE_request,      BAD}, // MLSE_OUT_RELEASE_request
{IGNORE,                        MLSE1_MaintenanceLoopAck,       IGNORE,                         BAD}, // MaintenanceLoopAck
{IGNORE,                        MLSE1_MaintenanceLoopRej,       MLSE2_MaintenanceLoopRej,       BAD}, // MaintenanceLoopReject
{BAD,                           MLSE1_T102Expiry,               BAD,                            BAD}, // T102Expiry

// In-coming Maintenance Loop (MLSE_IN) events
{MLSE0_MaintenanceLoopRequest,  MLSE1_MaintenanceLoopRequest,   MLSE2_MaintenanceLoopRequest,   BAD}, // MaintenanceLoopRequest
{IGNORE,                        MLSE1_MaintenanceLoopOffCommand,MLSE2_MaintenanceLoopOffCommand,BAD}, // MaintenanceLoopOffCommand
{BAD,                           MLSE1_LOOP_response,            BAD,                            BAD}, // MLSE_LOOP_response
{BAD,                           MLSE1_IN_RELEASE_request,       BAD,                            BAD}, // MLSE_IN_RELEASE_request

// Master Slave Determination (MSDSE) events
{DetRequestIdle,                IGNORE,                         IGNORE,              BAD}, // MSDetReq
{MSDetIdle,                     MSDetOutgoing,                  MSDetIncoming,       BAD}, // MSDetPDU
{IGNORE,                        MSDetAckOutgoing,               MSDetAckIncoming,    BAD}, // MSDetAckPDU
{IGNORE,                        MSDetRejOutgoing,               MSDetRejIncoming,    BAD}, // MSDetRejectPDU
{IGNORE,                        MSDetReleaseOutgoing,           MSDetReleaseIncoming,BAD}, // MSDetReleasePDU
{BAD,                           T106ExpiryOutgoing,             T106ExpiryIncoming,  BAD}, // T106Expiry

// Round Trip Delay Delay (RTDSE) events
{RTDSE0_TRANSFER_request,       RTDSE1_TRANSFER_request,        BAD,BAD},   // RTDSE_TRANSFER_request
{RTDSE0_RoundTripDelayRequest,  RTDSE0_RoundTripDelayRequest,   BAD,BAD},   // RoundTripDelayRequest
{IGNORE,                        RTDSE1_RoundTripDelayResponse,  BAD,BAD},   // RoundTripDelayResponse
{BAD,                           RTDSE1_T105Expiry,              BAD,BAD},   // T105Expiry
};



/*
 *  NAME
 *      StateMachine() - engine for finite state machine
 *
 *
 *  PARAMETERS
 *  INPUT       pObject        pointer to an FSM object structure
 *  INTPUT      event         input to the finite state machine
 *
 *  RETURN VALUE
 *   error codes defined in h245api.h
 */

HRESULT
StateMachine(Object_t *pObject, PDU_t *pPdu, Event_t Event)
{
    UINT                uFunction;
    HRESULT             lError;

    H245ASSERT(pObject != NULL);

    if (Event > NUM_EVENTS)
    {
        H245TRACE(pObject->dwInst, 1, "StateMachine: Invalid Event %d", Event);
        return H245_ERROR_PARAM;
    }

    if (pObject->State > MAXSTATES)
    {
        H245TRACE(pObject->dwInst, 1, "StateMachine: Invalid State %d", pObject->State);
        return H245_ERROR_INVALID_STATE;
    }

    ++(pObject->uNestLevel);

#if defined(DBG)
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%s(%d) State=%d Event=%s(%d)",
              EntityName[pObject->Entity], pObject->Entity,
              pObject->State,
              EventName[Event], Event);
#else
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d State=%d Event=%d",
              pObject->Entity, pObject->State, Event);
#endif

    uFunction = StateTable[Event][pObject->State];
    if (uFunction < (sizeof (StateFun) / sizeof(StateFun[0])))
    {
        /* indicating a valid transition */
#if defined(DBG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Function=%s(%d)",
                  OutputName[uFunction], uFunction);
#else   // (DBG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Function=%d", uFunction);
#endif  // (DBG)

        lError = (*StateFun[uFunction])(pObject, pPdu);

#if defined(DBG)
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%s(%d) New State=%d",
              EntityName[pObject->Entity], pObject->Entity, pObject->State);
#else
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d New State=%d",
              pObject->Entity, pObject->State);
#endif
    }
    else if (uFunction == IGNORE)
    {
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event ignored");
#if defined(DBG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Ignored; Entity=%s(%d) State=%d Event=%s(%d)",
                  EntityName[pObject->Entity], pObject->Entity,
                  pObject->State,
                  EventName[Event], Event);
#else
        H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d State=%d Event=%d",
                  pObject->Entity, pObject->State, Event);
#endif
        lError = H245_ERROR_OK;
    }
    else
    {
#if defined(DBG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Invalid; Entity=%s(%d) State=%d Event=%s(%d)",
                  EntityName[pObject->Entity], pObject->Entity,
                  pObject->State,
                  EventName[Event], Event);
#else
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Invalid; Entity=%d State=%d Event=%d",
                 pObject->Entity, pObject->State, Event);
#endif
        lError = H245_ERROR_INVALID_STATE;
    }

    if (--(pObject->uNestLevel) == 0 && pObject->State == 0)
    {
        ObjectDestroy(pObject);
    }

    return lError;
} // StateMachine()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\api_util.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  AUTHOR:     cjutzi (Curt Jutzi)
 *
 *  $Workfile:   api_util.c  $
 *  $Revision:   1.35  $
 *  $Modtime:   25 Feb 1997 10:36:12  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_util.c_v  $
 * 
 *    Rev 1.35   25 Feb 1997 11:18:44   MANDREWS
 * 
 * Fixed dynamic term cap ID generation; dynamic term cap IDs now
 * start at 32K + 1 and increase from there. Static term cap IDs
 * (specified by the client) are now restricted to the range of 1..32K.
 * 
 *    Rev 1.34   29 Jan 1997 16:25:06   EHOWARDX
 * Changed del_cap_descriptor() to match changes to set_cap_descriptor().
 * 
 *    Rev 1.33   29 Jan 1997 14:44:36   MANDREWS
 * Fixed warning that occured in release mode build.
 * 
 *    Rev 1.32   28 Jan 1997 14:46:58   EHOWARDX
 * Potential fix for capability descriptor problem.
 * 
 *    Rev 1.31   14 Oct 1996 14:01:20   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.30   16 Sep 1996 19:46:18   EHOWARDX
 * Added del_mux_cap for local and remote multiplex capability
 * to api_deinit to (hopefully) fix memory leak.
 * 
 *    Rev 1.29   11 Oct 1996 15:19:42   EHOWARDX
 * Fixed H245CopyCap() bug.
 * 
 *    Rev 1.28   28 Aug 1996 11:37:22   EHOWARDX
 * const changes.
 * 
 *    Rev 1.27   05 Aug 1996 15:31:42   EHOWARDX
 * 
 * Fixed error in CopyH2250Cap.
 * 
 *    Rev 1.26   02 Aug 1996 21:10:42   EHOWARDX
 * 
 * H.225.0 Mux cap bug second pass - see if this works.
 * 
 *    Rev 1.25   02 Aug 1996 20:34:20   EHOWARDX
 * First pass at H.225.0 Mux cap bug.
 * 
 *    Rev 1.24   19 Jul 1996 12:16:30   EHOWARDX
 * 
 * Rewrite of api_fsm_event() debug routine.
 * 
 *    Rev 1.23   16 Jul 1996 11:47:18   EHOWARDX
 * 
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET from debug error text function.
 * 
 *    Rev 1.22   09 Jul 1996 17:10:24   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 * 
 *    Rev 1.21   01 Jul 1996 22:12:42   EHOWARDX
 * 
 * Added Conference and CommunicationMode structures and functions.
 * 
 *    Rev 1.20   24 Jun 1996 12:27:02   EHOWARDX
 * 
 * Same as 1.17.1.0.
 * 
 *    Rev 1.19   17 Jun 1996 18:10:06   EHOWARDX
 * 
 * Changed first argument to build_totcap_cap_n_client_from_capability()
 * from VOID to struct capability *.
 * 
 *    Rev 1.18   14 Jun 1996 18:57:56   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.17   10 Jun 1996 16:56:56   EHOWARDX
 * Removed #include "h245init.x"
 * 
 *    Rev 1.16   06 Jun 1996 18:48:36   EHOWARDX
 * Fine-tuning tracker functions.
 * 
 *    Rev 1.15   04 Jun 1996 13:56:40   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.14   31 May 1996 18:21:08   EHOWARDX
 * Changed map_api_error to reflect updated error codes.
 * 
 *    Rev 1.13   30 May 1996 23:39:02   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.12   29 May 1996 15:20:10   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.11   28 May 1996 14:25:28   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.10   20 May 1996 22:15:46   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 * 
 *    Rev 1.9   20 May 1996 14:35:16   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 * 
 *    Rev 1.8   16 May 1996 19:40:48   EHOWARDX
 * Fixed multiplex capability bug.
 * 
 *    Rev 1.7   16 May 1996 16:53:58   EHOWARDX
 * Fixed bug in set_capability() - need to set capability entry number
 * AFTER doing load_cap().
 * 
 *    Rev 1.6   16 May 1996 15:59:26   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 * 
 *    Rev 1.5   15 May 1996 19:53:28   unknown
 * Fixed H245SetCapDescriptor.
 * 
 *    Rev 1.4   14 May 1996 13:58:04   EHOWARDX
 * Fixed capability list order (made fifo).
 * Added support for NonStandard and H.222 mux capabilities to set_cap_descrip
 * 
 *    Rev 1.3   14 May 1996 12:27:24   EHOWARDX
 * Check-in for integration.
 * Still need to fix non-standard and H.222 mux capabilities.
 * 
 *    Rev 1.2   13 May 1996 23:16:46   EHOWARDX
 * Fixed remote terminal capability handling.
 * 
 *    Rev 1.1   11 May 1996 20:33:08   EHOWARDX
 * Checking in for the night...
 * 
 *    Rev 1.0   09 May 1996 21:06:10   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.23.1.8   09 May 1996 19:30:56   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 * 
 *    Rev 1.23.1.7   27 Apr 1996 21:09:46   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 * 
 *    Rev 1.23.1.6   26 Apr 1996 15:53:52   EHOWARDX
 * Added H.225.0 Capability support; Changed Capability indication
 * to only callback once with PDU.
 * 
 *    Rev 1.23.1.5   24 Apr 1996 20:54:36   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 * 
 *    Rev 1.23.1.4   23 Apr 1996 14:47:20   EHOWARDX
 * Disabled dump_pdu.
 * 
 *    Rev 1.23.1.3   19 Apr 1996 12:54:18   EHOWARDX
 * Updated to 1.28.
 * 
 *    Rev 1.23.1.2   15 Apr 1996 15:10:52   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.23.1.1   03 Apr 1996 17:14:56   EHOWARDX
 * Integrated latest H.323 changes.
 *
 *    Rev 1.23.1.0   03 Apr 1996 15:54:26   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.22   01 Apr 1996 16:43:18   cjutzi
 *
 * - Completed ENdConnection, and made asynch.. rather
 *   than sync.. as before
 * - Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.21   29 Mar 1996 09:35:16   cjutzi
 *
 * -
 * - fixed ring3 build error message for check_pdu
 *
 *    Rev 1.20   27 Mar 1996 08:37:28   cjutzi
 *
 * - removed error from routine .. was unreferenced variable..
 *
 *    Rev 1.19   19 Mar 1996 20:31:06   cjutzi
 *
 * - added bi-directional channel stuff
 *
 *    Rev 1.18   13 Mar 1996 14:12:52   cjutzi
 *
 * - clean up..
 *
 *    Rev 1.17   13 Mar 1996 09:25:34   cjutzi
 *
 * - removed LPCRITICIAL -> CRITICAL SECTION *
 *
 *    Rev 1.16   12 Mar 1996 16:40:50   cjutzi
 *
 * - removed deadlock..
 *
 *    Rev 1.15   12 Mar 1996 15:51:08   cjutzi
 *
 * - added locking
 * - implented End Session
 * - fixed callback bug for deleting caps on cleanup..
 *
 *    Rev 1.14   08 Mar 1996 14:04:48   cjutzi
 *
 * - added mux table entry code.
 * - parse all mux table entries.. (as much as needed at this point)
 *
 *    Rev 1.13   06 Mar 1996 12:35:02   cjutzi
 *
 * - typeo.. :-).. for ANS1 error ..
 *
 *    Rev 1.12   06 Mar 1996 08:49:42   cjutzi
 *
 * - added H245_ERROR_ASN1
 * - #ifdef'ed the call to check pdu.. in api_fsm
 *
 *    Rev 1.11   05 Mar 1996 17:37:14   cjutzi
 *
 * - implemented Send Local Mux Table..
 * - removed bzero/bcopy and changed free api
 *
 *
 *    Rev 1.10   01 Mar 1996 13:49:00   cjutzi
 *
 * - added hani's new fsm id's
 * - added debug print for events.
 *
 *    Rev 1.9   29 Feb 1996 08:38:14   cjutzi
 *
 * - added error messages ..
 *
 *    Rev 1.8   26 Feb 1996 16:33:28   cjutzi
 *
 * - fixed GP for tracker.  p_prev was not initialized to NULL
 *
 *
 *    Rev 1.7   26 Feb 1996 11:06:18   cjutzi
 *
 * - added simltanious caps.. and fixed bugs..
 *   lot's o-changes..
 *
 *    Rev 1.6   16 Feb 1996 13:02:34   cjutzi
 *
 *  - got open / close / request close working in both directions.
 *
 *    Rev 1.5   15 Feb 1996 10:53:10   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - modifed H223 stuff
 * - cleaned up open
 *
 *    Rev 1.4   09 Feb 1996 16:58:40   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/


/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#undef UNICODE
#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "fsmexpor.h"
#include "api_util.x"
#include "api_debu.x"
#include "h245deb.x"



// This array is used to map user-specified Client Type into correct Data Type
BYTE DataTypeMap[] =
{
  H245_DATA_DONTCARE,           //  H245_CLIENT_DONTCARE,
  H245_DATA_NONSTD,             //  H245_CLIENT_NONSTD,

  H245_DATA_VIDEO,              //  H245_CLIENT_VID_NONSTD,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H261,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H262,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H263,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_IS11172,

  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_NONSTD,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ALAW64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ALAW56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ULAW64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ULAW56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_48,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G723,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G728,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G729,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_GDSVD,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_IS11172,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_IS13818,

  H245_DATA_DATA,               //  H245_CLIENT_DAT_NONSTD,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T120,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_DSMCC,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_USERDATA,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T84,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T434,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_H224,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_NLPID,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_DSVD,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_H222,

  H245_DATA_ENCRYPT_D,          //  H245_CLIENT_ENCRYPTION_TX,
  H245_DATA_ENCRYPT_D,          //  H245_CLIENT_ENCRYPTION_RX,
  H245_DATA_CONFERENCE,         //  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_DATA_MUX,                //  H245_CLIENT_MUX_NONSTD,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H222,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H223,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_VGMUX,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H2250
};

unsigned ObjectIdLength (const NonStandardIdentifier *pIdentifier)
{
  register unsigned   uLength = 0;
  register POBJECTID  pObject = pIdentifier->u.object;
  H245ASSERT(pIdentifier->choice == object_chosen);
  while (pObject)
  {
    ++uLength;
    pObject = pObject->next;
  }
  return uLength;
} // ObjectIdLength()



void FreeNonStandardIdentifier(NonStandardIdentifier *pFree)
{
  register POBJECTID    pObject;

  if (pFree->choice == object_chosen)
  {
    // Free Object Identifier
    while (pFree->u.object)
    {
      pObject = pFree->u.object;
      pFree->u.object = pObject->next;
      H245_free(pObject);
    }
  }
} // FreeNonStandardIdentifier()



HRESULT CopyNonStandardIdentifier(NonStandardIdentifier *pNew, const NonStandardIdentifier *pOld)
{

  // Copy the base structure
  *pNew = *pOld;

  if (pOld->choice == object_chosen)
  {
    // Copy Object Identifier
    POBJECTID                pObjectList;
    POBJECTID                pObjectOld;
    POBJECTID                pObjectNew;

    pNew->u.object = NULL;
    pObjectList = NULL;
    pObjectOld = pOld->u.object;
    while (pObjectOld)
    {
      // Allocate new structure
      pObjectNew = H245_malloc(sizeof(*pObjectNew));
      if (pObjectNew == NULL)
      {
        H245TRACE(0,1,"API:CopyNonStandardIdentifier - malloc failed");
        FreeNonStandardIdentifier(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      pObjectNew->value = pObjectOld->value;

      // Add new structure to list
      pObjectNew->next  = NULL;
      if (pNew->u.object == NULL)
      {
        pNew->u.object = pObjectNew;
      }
      else
      {
        pObjectList->next = pObjectNew;
      }
      pObjectList = pObjectNew;

      // Get next old structure to copy
      pObjectOld = pObjectOld->next;
    }
  }

  return H245_ERROR_OK;
} // CopyNonStandardIdentifier()



void FreeNonStandardParameter(NonStandardParameter *pFree)
{
  FreeNonStandardIdentifier(&pFree->nonStandardIdentifier);

  if (pFree->data.value)
  {
    H245_free(pFree->data.value);
    pFree->data.value = NULL;
  }
} // FreeNonStandardParameter()



HRESULT CopyNonStandardParameter(NonStandardParameter *pNew, const NonStandardParameter *pOld)
{
  // Copy the base structure
  *pNew = *pOld;

  if (pOld->nonStandardIdentifier.choice == object_chosen)
  {
    HRESULT lResult = CopyNonStandardIdentifier(&pNew->nonStandardIdentifier, &pOld->nonStandardIdentifier);
    if (lResult != H245_ERROR_OK)
    {
      pNew->data.value = NULL;
      return lResult;
    }
  }

  if (pOld->data.length && pOld->data.value)
  {
    // Copy value
    pNew->data.value = H245_malloc(pOld->data.length);
    if (pNew->data.value == NULL)
    {
      H245TRACE(0,1,"API:CopyNonStandardParameter - malloc failed");
      return H245_ERROR_NOMEM;
    }
    memcpy(pNew->data.value, pOld->data.value, pOld->data.length);
  }

  return H245_ERROR_OK;
} // CopyNonStandardParameter()



void FreeH222Cap(H222Capability *pFree)
{
  register VCCapabilityLink pVC;

  while (pFree->vcCapability)
  {
    pVC = pFree->vcCapability;
    pFree->vcCapability = pVC->next;
    H245_free(pVC);
  }
} // FreeH222Cap()



HRESULT CopyH222Cap(H222Capability *pNew, const H222Capability *pOld)
{
  VCCapabilityLink pVcNew;
  VCCapabilityLink pVcOld;
  VCCapabilityLink pVcList;

  pNew->numberOfVCs = pOld->numberOfVCs;
  pNew->vcCapability = NULL;
  pVcList = NULL;
  pVcOld = pOld->vcCapability;
  while (pVcOld)
  {
    // Allocate new structure
    pVcNew = H245_malloc(sizeof(*pVcNew));
    if (pVcNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH222Cap - malloc failed");
      FreeH222Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Copy old structure to new structure
    *pVcNew = *pVcOld;

    // Add new structure to list
    pVcNew->next = NULL;
    if (pNew->vcCapability == NULL)
    {
      pNew->vcCapability = pVcNew;
    }
    else
    {
      pVcList->next = pVcNew;
    }
    pVcList = pVcNew;

    // Get next old structure to copy
    pVcOld = pVcOld->next;
  }

  return H245_ERROR_OK;
} // CopyH222Cap()



void FreeMediaDistributionCap(MediaDistributionCapability *pFree)
{
  if (pFree->bit_mask & centralizedData_present)
  {
    register CentralizedDataLink  pLink;

    while (pFree->centralizedData)
    {
      pLink = pFree->centralizedData;
      pFree->centralizedData = pLink->next;
      switch (pLink->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          H245_free(pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLink->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      H245_free(pLink);
    }
  }

  if (pFree->bit_mask & distributedData_present)
  {
    register DistributedDataLink  pLink;

    while (pFree->distributedData)
    {
      pLink = pFree->distributedData;
      pFree->distributedData = pLink->next;
      switch (pLink->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          H245_free(pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLink->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      H245_free(pLink);
    }
  }
} // FreeMediaDistributionCap()



HRESULT CopyMediaDistributionCap(MediaDistributionCapability *pNew,
                           const MediaDistributionCapability *pOld)
{
  HRESULT lResult = H245_ERROR_OK;
  *pNew = *pOld;
  pNew->centralizedData = NULL;
  pNew->distributedData = NULL;

  if (pOld->bit_mask & centralizedData_present)
  {
    CentralizedDataLink pLinkList = NULL;
    CentralizedDataLink pLinkOld = pOld->centralizedData;
    CentralizedDataLink pLinkNew;

    while (pLinkOld)
    {
      // Allocate new structure
      pLinkNew = H245_malloc(sizeof(*pLinkNew));
      if (pLinkNew == NULL)
      {
        H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
        FreeMediaDistributionCap(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      *pLinkNew = *pLinkOld;

      // Add new structure to list
      pLinkNew->next = NULL;
      if (pNew->centralizedData == NULL)
      {
        pNew->centralizedData = pLinkNew;
      }
      else
      {
        pLinkList->next = pLinkNew;
      }
      pLinkList = pLinkNew;

      // Allocate new memory for each pointer in new structure
      switch (pLinkOld->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_nnStndrd,
                                           &pLinkOld->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value =
            H245_malloc(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
          if (pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value == NULL)
          {
            H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
            FreeMediaDistributionCap(pNew);
            return H245_ERROR_NOMEM;
          }
          memcpy(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLinkOld->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                             &pLinkOld->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      if (lResult != H245_ERROR_OK)
      {
        FreeMediaDistributionCap(pNew);
        return lResult;
      }

      // Get next old structure to copy
      pLinkOld = pLinkOld->next;
    }
  }

  if (pOld->bit_mask & distributedData_present)
  {
    DistributedDataLink pLinkList = NULL;
    DistributedDataLink pLinkOld = pOld->distributedData;
    DistributedDataLink pLinkNew;

    while (pLinkOld)
    {
      // Allocate new structure
      pLinkNew = H245_malloc(sizeof(*pLinkNew));
      if (pLinkNew == NULL)
      {
        H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
        FreeMediaDistributionCap(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      *pLinkNew = *pLinkOld;

      // Add new structure to list
      pLinkNew->next = NULL;
      if (pNew->distributedData == NULL)
      {
        pNew->distributedData = pLinkNew;
      }
      else
      {
        pLinkList->next = pLinkNew;
      }
      pLinkList = pLinkNew;

      // Allocate new memory for each pointer in new structure
      switch (pLinkOld->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_nnStndrd,
                                         &pLinkOld->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value =
            H245_malloc(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
          if (pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value == NULL)
          {
            H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
            FreeMediaDistributionCap(pNew);
            return H245_ERROR_NOMEM;
          }
          memcpy(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value,
               pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLinkOld->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                           &pLinkOld->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      if (lResult != H245_ERROR_OK)
      {
        FreeMediaDistributionCap(pNew);
        return lResult;
      }

      // Get next old structure to copy
      pLinkOld = pLinkOld->next;
    }
  }

  return H245_ERROR_OK;
} // CopyMediaDistributionCap()



void FreeH2250Cap(H2250Capability *pFree)
{
  register MediaDistributionCapabilityLink pLink;

  while (pFree->receiveMultipointCapability.mediaDistributionCapability)
  {
    pLink = pFree->receiveMultipointCapability.mediaDistributionCapability;
    pFree->receiveMultipointCapability.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    H245_free(pLink);
  }

  while (pFree->transmitMultipointCapability.mediaDistributionCapability)
  {
    pLink = pFree->transmitMultipointCapability.mediaDistributionCapability;
    pFree->transmitMultipointCapability.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    H245_free(pLink);
  }

  while (pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability)
  {
    pLink = pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability;
    pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    H245_free(pLink);
  }
} // FreeH2250Cap()



HRESULT CopyH2250Cap(H2250Capability *pNew, const H2250Capability *pOld)
{
  MediaDistributionCapabilityLink pLinkList;
  MediaDistributionCapabilityLink pLinkOld;
  MediaDistributionCapabilityLink pLinkNew;
  HRESULT lResult;

  // Copy base structure
  *pNew = *pOld;
  pNew->receiveMultipointCapability.mediaDistributionCapability  = NULL;
  pNew->transmitMultipointCapability.mediaDistributionCapability = NULL;
  pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability     = NULL;

  pLinkList = NULL;
  pLinkOld = pOld->receiveMultipointCapability.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = H245_malloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->receiveMultipointCapability.mediaDistributionCapability == NULL)
    {
      pNew->receiveMultipointCapability.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  pLinkList = NULL;
  pLinkOld = pOld->transmitMultipointCapability.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = H245_malloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->transmitMultipointCapability.mediaDistributionCapability == NULL)
    {
      pNew->transmitMultipointCapability.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  pLinkList = NULL;
  pLinkOld = pOld->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = H245_malloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability == NULL)
    {
      pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  return H245_ERROR_OK;
} // CopyH2250Cap()



HRESULT set_cap_descriptor(
                        struct InstanceStruct         *pInstance,
                        H245_CAPDESC_T                *pCapDesc,
                        H245_CAPDESCID_T              *pCapDescId,
                        struct TerminalCapabilitySet  *pTermCapSet)
{
  CapabilityDescriptor         *p_cap_desc;
  unsigned int                  uId;
  BOOL                          bNewDescriptor;
  unsigned int                  sim_cap;
  SmltnsCpbltsLink              p_sim_cap;
  SmltnsCpbltsLink              p_sim_cap_lst = NULL;
  unsigned int                  alt_cap;

  H245TRACE(pInstance->dwInst,10,"API:set_cap_descriptor");
  H245ASSERT(*pCapDescId < 256);

  /* Check if capability descriptor already exists */
  p_cap_desc = NULL;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == *pCapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL)
  {
    H245ASSERT(pTermCapSet->capabilityDescriptors.count < 256);
    p_cap_desc = &pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
    p_cap_desc->capabilityDescriptorNumber = *pCapDescId;
    bNewDescriptor = TRUE;
  }
  else
  {
    bNewDescriptor = FALSE;
  }
  if (p_cap_desc->smltnsCpblts)
    dealloc_simultaneous_cap (p_cap_desc);

  /* for every entry in the altcap list */
  for (sim_cap = 0; sim_cap < pCapDesc->Length; ++sim_cap)
  {
    /* check for out of bounds error or memory allocation failure */
    if ((pCapDesc->SimCapArray[sim_cap].Length > 256) ||
        (!(p_sim_cap = (SmltnsCpbltsLink)alloc_link(sizeof(*p_sim_cap)))))
    {
      if (p_cap_desc->smltnsCpblts)
        dealloc_simultaneous_cap (p_cap_desc);
      H245TRACE(pInstance->dwInst,1,"API:set_cap_descriptor - no memory");
      return H245_ERROR_NOMEM;
    }

    if (!p_cap_desc->smltnsCpblts)
    {
      /* first time through */
      p_cap_desc->smltnsCpblts = p_sim_cap;
    }
    else
    {
      /* every other time through */
      H245ASSERT (p_sim_cap_lst);
      p_sim_cap_lst->next = p_sim_cap;
    }

    /* setup for next time through */
    p_sim_cap_lst = p_sim_cap;

    /* load up the new simultanoius cap */
    for (alt_cap = 0; alt_cap < pCapDesc->SimCapArray[sim_cap].Length; ++alt_cap)
    {
      if (!(find_capid_by_entrynumber (&pInstance->API.PDU_LocalTermCap.TERMCAPSET,
                                   pCapDesc->SimCapArray[sim_cap].AltCaps[alt_cap])))
      {
        if (p_cap_desc->smltnsCpblts)
          dealloc_simultaneous_cap (p_cap_desc);
        return H245_ERROR_INVALID_CAPID;
      }

      /* assign Altcap */
      p_sim_cap->value.value[alt_cap] = (unsigned short)pCapDesc->SimCapArray[sim_cap].AltCaps[alt_cap];
    } /* for C*/

    /* set count */
    p_sim_cap->value.count = (unsigned short)pCapDesc->SimCapArray[sim_cap].Length;

  } /* for */

  /* Success! */
  /* Set the simultaneous capabilities present bit */
  /* Increment the capability descriptor count */
  /* Set the descriptors present bit even though it may already be set */
  p_cap_desc->bit_mask |= smltnsCpblts_present;
  if (bNewDescriptor)
    pTermCapSet->capabilityDescriptors.count++;
  pTermCapSet->bit_mask |= capabilityDescriptors_present;

  return H245_ERROR_OK;
}

# pragma warning( disable : 4100 )

HRESULT del_cap_descriptor (struct InstanceStruct        *pInstance,
                            H245_CAPDESCID_T              CapDescId,
                            struct TerminalCapabilitySet *pTermCapSet)
{
  CapabilityDescriptor         *p_cap_desc;
  unsigned int                  uId;

  /* Check if capability descriptor already exists and if it is valid */
  p_cap_desc = NULL;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == CapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL ||
      p_cap_desc->smltnsCpblts == NULL ||
      (p_cap_desc->bit_mask & smltnsCpblts_present) == 0)
    {
      H245TRACE(pInstance->dwInst,1,"API:del_cap_descriptor - invalid cap descriptor");
      return H245_ERROR_INVALID_CAPDESCID;
    }

  /* free up the list */
  dealloc_simultaneous_cap (p_cap_desc);

  pTermCapSet->capabilityDescriptors.count--;
  pTermCapSet->capabilityDescriptors.value[uId] =
    pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
  if (pTermCapSet->capabilityDescriptors.count == 0)
    pTermCapSet->bit_mask &= ~capabilityDescriptors_present;

  return H245_ERROR_OK;
}

# pragma warning( default : 4100 )

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   free_object_id
 *
 * DESCRIPTION
 *
 * RETURN:      none
 *
 * ASSUMES:     none
 *
 *****************************************************************************/
void
free_object_id (POBJECTID p_obj_id)
{
  register POBJECTID p_obj_tmp;

  /* free all the objects */
  while (p_obj_id != NULL)
    {
      p_obj_tmp = p_obj_id;
      p_obj_id = p_obj_id->next;
      H245_free (p_obj_tmp);
    }
}

/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   free_mux_element
 *
 * DESCRIPTION
 *              free mux element desciptor list
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_element (MultiplexElement *p_ASN_mux_el)
{
  int count = 0;

  if (p_ASN_mux_el->type.choice == subElementList_chosen)
    {
      if (p_ASN_mux_el->type.u.subElementList)
        {
          for (count = p_ASN_mux_el->type.u.subElementList->count;
               count;
               count--)
            {
              free_mux_element (&(p_ASN_mux_el->type.u.subElementList->value[count]));
            }
          H245_free (p_ASN_mux_el->type.u.subElementList);
        }
    }
}
/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   free_mux_desc_list
 *
 * DESCRIPTION
 *              free mux element desciptor list
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void
free_mux_desc_list (MultiplexEntryDescriptorLink p_ASN_med_link)
{
  MultiplexEntryDescriptorLink  p_ASN_med_link_tofree;

  /* free all entries on descriptor list */
  while (p_ASN_med_link)
    {
      int count = 0;

      for (count = p_ASN_med_link->value.elementList.count;
           count;
           count--)
        {
          free_mux_element (&(p_ASN_med_link->value.elementList.value[count]));
        }
      p_ASN_med_link_tofree = p_ASN_med_link;
      p_ASN_med_link = p_ASN_med_link->next;
      H245_free (p_ASN_med_link_tofree);
    }
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   alloc_link
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
H245_LINK_T  *
alloc_link (int size)
{
  H245_LINK_T *p_link = (H245_LINK_T *)H245_malloc (size);
  if (p_link)
    p_link->p_next = NULL;
  return p_link;
}


/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   alloc_new_capid -
 *
 * DESCRIPTION:
 *
 * ASSUMES:     Capability Table is locked before call
 *              Caller marks the bit_mask indicating when
 *                the table entry can be used.
 *
 * RETURN:              NULL     if not found
 *                      pCapLink if found
 *
 *****************************************************************************/
CapabilityTableLink
alloc_link_cap_entry ( struct TerminalCapabilitySet *pTermCapSet)
{
  register CapabilityTableLink  pCapLink;
  register CapabilityTableLink  pCapLinkSearch;

  H245ASSERT(pTermCapSet != NULL);

  pCapLink = (CapabilityTableLink)H245_malloc(sizeof(*pCapLink));
  if (pCapLink)
  {
    pCapLink->next = NULL;
    pCapLink->value.bit_mask = 0;
    pCapLinkSearch = pTermCapSet->capabilityTable;

    // Insert at END of linked list
    if (pCapLinkSearch)
    {
      while (pCapLinkSearch->next)
      {
        pCapLinkSearch = pCapLinkSearch->next;
      }
      pCapLinkSearch->next = pCapLink;
    }
    else
    {
      pTermCapSet->capabilityTable = pCapLink;
    }
  }

  return pCapLink;
} // alloc_link_cap_entry()


/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   dealloc_simultaneous_cap - deallocate alternative Cap Set
 *
 * DESCRIPTION
 *
 * RETURN:      N/A
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/

void dealloc_simultaneous_cap (CapabilityDescriptor *pCapdes)
{
  SmltnsCpbltsLink      p_sim_cap;
  SmltnsCpbltsLink      p_sim_cap_tmp;

  pCapdes->bit_mask &= ~smltnsCpblts_present;

  for (p_sim_cap = pCapdes->smltnsCpblts;
       p_sim_cap;
       )
    {
      p_sim_cap_tmp = p_sim_cap->next;
      H245_free (p_sim_cap);
      p_sim_cap = p_sim_cap_tmp;

    } /* for */

  pCapdes->smltnsCpblts = NULL;

} /* procedrue */

/*****************************************************************************
 *
 * TYPE:        local
 *
 * PROCEDURE:   find_capid_by_entrynumber -
 *
 * DESCRIPTION:
 *
 * RETURN:      NULL - if error
 *              capabiliytTableLink if ok
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
CapabilityTableLink
find_capid_by_entrynumber (
                           struct TerminalCapabilitySet *pTermCapSet,
                           H245_CAPID_T                  cap_id
                          )
{
  register CapabilityTableLink  pCapLink;

  H245ASSERT (pTermCapSet != NULL);

  for (pCapLink = pTermCapSet->capabilityTable;
       pCapLink;
       pCapLink = pCapLink->next)
  {
    if  (pCapLink->value.capabilityTableEntryNumber == cap_id &&
         pCapLink->value.bit_mask == capability_present)
    {
      return pCapLink;
    }
  }
  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   load_cap
 *
 * DESCRIPTION: Takes a totcap and loads a capability structure
 *              i.e. Input is the total capability
 *                   Output is the *pCapability
 *              NOTE: Non Standard Capabilities.. allocate memory
 *                    which needs to be free'd later..
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
load_cap (struct Capability   *pCapability,  /* output */
          const H245_TOTCAP_T *pTotCap )     /* input  */
{
  HRESULT                       lError = H245_ERROR_OK;

  H245TRACE(0,10,"API:laod_cap <-");

  switch (pTotCap->ClientType)
    {
    /* General NON Standard Cap */
    case H245_CLIENT_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.Capability_nonStandard,
                                        &pTotCap->Cap.H245_NonStd);
      break;

    /* VIDEO */
    case H245_CLIENT_VID_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard,
                                        &pTotCap->Cap.H245Vid_NONSTD);
      pCapability->u.receiveVideoCapability.choice = VdCpblty_nonStandard_chosen;
      break;
    case H245_CLIENT_VID_H261:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H261");
      pCapability->u.receiveVideoCapability.u.h261VideoCapability = pTotCap->Cap.H245Vid_H261;
      pCapability->u.receiveVideoCapability.choice = h261VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_H262:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H262");
      pCapability->u.receiveVideoCapability.u.h262VideoCapability = pTotCap->Cap.H245Vid_H262;
      pCapability->u.receiveVideoCapability.choice = h262VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_H263:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H263");
      pCapability->u.receiveVideoCapability.u.h263VideoCapability = pTotCap->Cap.H245Vid_H263;
      pCapability->u.receiveVideoCapability.choice = h263VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_IS11172:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_IS11172");
      pCapability->u.receiveVideoCapability.u.is11172VideoCapability = pTotCap->Cap.H245Vid_IS11172;
      pCapability->u.receiveVideoCapability.choice = is11172VideoCapability_chosen;
      break;

    /* AUDIO */
    case H245_CLIENT_AUD_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard,
                                        &pTotCap->Cap.H245Aud_NONSTD);
      pCapability->u.receiveAudioCapability.choice = AdCpblty_nonStandard_chosen;
      break;
    case H245_CLIENT_AUD_G711_ALAW64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ALAW64");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw64k = pTotCap->Cap.H245Aud_G711_ALAW64;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Alaw64k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ALAW56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ALAW56");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw56k = pTotCap->Cap.H245Aud_G711_ALAW56;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Alaw56k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ULAW64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ULAW64");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw64k = pTotCap->Cap.H245Aud_G711_ULAW64;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Ulaw64k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ULAW56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ULAW56");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw56k = pTotCap->Cap.H245Aud_G711_ULAW56;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Ulaw56k_chosen;
      break;
    case H245_CLIENT_AUD_G722_64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_64");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_64k = pTotCap->Cap.H245Aud_G722_64;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_64k_chosen;
      break;
    case H245_CLIENT_AUD_G722_56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_56");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_56k = pTotCap->Cap.H245Aud_G722_56;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_56k_chosen;
      break;
    case H245_CLIENT_AUD_G722_48:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_48");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_48k = pTotCap->Cap.H245Aud_G722_48;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_48k_chosen;
      break;
    case H245_CLIENT_AUD_G723:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G723");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g7231 = pTotCap->Cap.H245Aud_G723;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g7231_chosen;
      break;
    case H245_CLIENT_AUD_G728:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G728");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g728 = pTotCap->Cap.H245Aud_G728;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g728_chosen;
      break;
    case H245_CLIENT_AUD_G729:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G729");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g729 = pTotCap->Cap.H245Aud_G729;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g729_chosen;
      break;
    case H245_CLIENT_AUD_GDSVD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_GDSVD");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g729AnnexA = pTotCap->Cap.H245Aud_GDSVD;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g729AnnexA_chosen;
      break;
    case H245_CLIENT_AUD_IS11172:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_IS11172");
      pCapability->u.receiveAudioCapability.u.is11172AudioCapability = pTotCap->Cap.H245Aud_IS11172;
      pCapability->u.receiveAudioCapability.choice = is11172AudioCapability_chosen;
      break;
    case H245_CLIENT_AUD_IS13818:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_IS13818");
      pCapability->u.receiveAudioCapability.u.is13818AudioCapability = pTotCap->Cap.H245Aud_IS13818;
      pCapability->u.receiveAudioCapability.choice = is13818AudioCapability_chosen;
      break;

    /* DATA */
    case H245_CLIENT_DAT_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_NONSTD");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_NONSTD;
      lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd,
                                              &pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd);
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_nnStndrd_chosen;
      break;
    case H245_CLIENT_DAT_T120:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T120");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T120;
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t120_chosen;
      break;
    case H245_CLIENT_DAT_DSMCC:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_DSMCC");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_DSMCC;
      if (pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd,
                                                 &pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_dsm_cc_chosen;
      break;
    case H245_CLIENT_DAT_USERDATA:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_USERDATA");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_USERDATA;
      if (pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd,
                                              &pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_usrDt_chosen;
      break;
    case H245_CLIENT_DAT_T84:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T84");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T84;
      if (pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd,
                                                   &pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t84_chosen;
      break;
    case H245_CLIENT_DAT_T434:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T434");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T434;
      if (pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t434_chosen;
      break;
    case H245_CLIENT_DAT_H224:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_H224");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_H224;
      if (pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_h224_chosen;
      break;
    case H245_CLIENT_DAT_NLPID:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_NLPID");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_NLPID;
      if (pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd,
                                                 &pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
      }
      if (lError == H245_ERROR_OK && pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length != 0)
      {
        pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value =
          H245_malloc(pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
        if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value)
        {
          memcpy(pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
        }
        else
          lError = H245_ERROR_NOMEM;
      }
      else
        pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value = NULL;

      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_nlpd_chosen;
      break;
    case H245_CLIENT_DAT_DSVD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_DSVD");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_DSMCC;
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_dsvdCntrl_chosen;
      break;
    case H245_CLIENT_DAT_H222:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_H222");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_H222;
      if (pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_an_h222DtPrttnng_chosen ;
      break;
    default:
      H245TRACE(0,20,"API:load_cap - default");
      lError = H245_ERROR_NOSUP;
    } /* switch */

  if (lError != H245_ERROR_OK)
    H245TRACE(0,1,"API:load_cap -> %s",map_api_error(lError));
  else
    H245TRACE(0,10,"API:load_cap -> OK");
  return lError;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_from_mux
 *
 * DESCRIPTION:
 *              called by both top down , and bottom up..
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/

HRESULT
build_totcap_from_mux(H245_TOTCAP_T *pTotCap, MultiplexCapability *pMuxCap, H245_CAPDIR_T Dir)
{
  H245TRACE(0,10,"API:build_totcap_from_mux <-");

  /* initialize TotCap */
  pTotCap->Dir        = Dir;
  pTotCap->DataType   = H245_DATA_MUX;
  pTotCap->ClientType = H245_CLIENT_DONTCARE;
  pTotCap->CapId      = 0;

  switch (pMuxCap->choice)
  {
  case MltplxCpblty_nonStandard_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - MltplxCpblty_nonStandard_chosen");
    pTotCap->Cap.H245Mux_NONSTD = pMuxCap->u.MltplxCpblty_nonStandard;
    pTotCap->ClientType = H245_CLIENT_MUX_NONSTD;
    // TBD - copy nonstandard parameter
    H245PANIC();
    break;

  case h222Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h222Capability_chosen");
    pTotCap->Cap.H245Mux_H222 = pMuxCap->u.h222Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H222;
    break;

  case h223Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h223Capability_chosen");
    pTotCap->Cap.H245Mux_H223 = pMuxCap->u.h223Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H223;
    break;

  case v76Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - v76Capability_chosen");
    pTotCap->Cap.H245Mux_VGMUX = pMuxCap->u.v76Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_VGMUX;
    break;

  case h2250Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h2250Capability_chosen");
    pTotCap->Cap.H245Mux_H2250 = pMuxCap->u.h2250Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H2250;
    break;

  default:
    H245TRACE(0,20,"API:build_totcap_from_mux - unrecogized choice %d", pMuxCap->choice);
    return H245_ERROR_NOSUP;
  }

  H245TRACE(0,10,"API:build_totcap_from_mux -> OK");
  return H245_ERROR_OK;
}


/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_from_captbl
 *
 * DESCRIPTION:
 *              called by both top down , and bottom up..
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
build_totcap_from_captbl (H245_TOTCAP_T        *pTotCap,
                          CapabilityTableLink   pCapLink,
                          int                   lcl_rmt)
{
  unsigned short choice;
  DWORD          error;

  H245TRACE(0,10,"API:build_totcap_from_captbl <-");

  /* initialize TotCap */
  pTotCap->Dir        = H245_CAPDIR_DONTCARE;
  pTotCap->DataType   = H245_DATA_DONTCARE;
  pTotCap->ClientType = H245_CLIENT_DONTCARE;
  pTotCap->CapId      = 0;

  /* note.. this has to come first if using for deleted caps */
  /* capability entry number will be present, however if     */
  /* the capability is not present that indicates that the   */
  /* capability should be deleted                            */

  pTotCap->CapId = pCapLink->value.capabilityTableEntryNumber;

  if (!(pCapLink->value.bit_mask & capability_present))
    return H245_ERROR_OK;

  switch (pCapLink->value.capability.choice)
    {
    case Capability_nonStandard_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - Capability_nonStandard_chosen");
      pTotCap->DataType = H245_DATA_NONSTD;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = Capability_nonStandard_chosen;
      break;
    case receiveVideoCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - receiveVideoCapability_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.receiveVideoCapability.choice;
      break;
    case transmitVideoCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - transmitVideoCapability_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.transmitVideoCapability.choice;
      break;
    case rcvAndTrnsmtVdCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvAndTrnsmtVdCpblty_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      choice            = pCapLink->value.capability.u.rcvAndTrnsmtVdCpblty.choice;
      break;
    case receiveAudioCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - receiveAudioCapability_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.receiveAudioCapability.choice;
      break;
    case transmitAudioCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - transmitAudioCapability_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.transmitAudioCapability.choice;
      break;
    case rcvAndTrnsmtAdCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvAndTrnsmtAdCpblty_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      choice            = pCapLink->value.capability.u.rcvAndTrnsmtAdCpblty.choice;
      break;
    case rcvDtApplctnCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvDtApplctnCpblty_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice;
      break;
    case trnsmtDtApplctnCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - trnsmtDtApplctnCpblty_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.trnsmtDtApplctnCpblty.application.choice;
      break;
    case rATDACy_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rATDACy_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.rATDACy.application.choice;
      break;
    case h233EncryptnTrnsmtCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - h233EncryptnTrnsmtCpblty_chosen");
//    pTotCap->DataType = H245_DATA_ENCRYPT_D;
//    pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      H245TRACE(0,10,"API:build_totcap_from_captbl - ignoring CapId %d",pTotCap->CapId);
      return H245_ERROR_OK; // ignore unsupported termcap
      break;
    case h233EncryptnRcvCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - h233EncryptnRcvCpblty_chosen");
//    pTotCap->DataType = H245_DATA_ENCRYPT_D;
//    pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      H245TRACE(0,10,"API:build_totcap_from_captbl - ignoring CapId %d",pTotCap->CapId);
      return H245_ERROR_OK; // ignore unsupported termcap
      break;
    default:
      H245TRACE(0,20,"API:build_totcap_from_captbl - default");
      H245TRACE(0,10,"API:build_totcap_from_captbl - ignoring CapId %d",pTotCap->CapId);
      return H245_ERROR_OK; // ignore unsupported termcap
      break;
    }

  /* load the tot cap's capability and client from capability */
  if ((error = build_totcap_cap_n_client_from_capability (&pCapLink->value.capability,
                                                         pTotCap->DataType,
                                                         choice,
                                                         pTotCap)) != H245_ERROR_OK)
    {
      // ignore unsupported termcaps
      if (error == H245_ERROR_NOSUP) {

        H245TRACE(0,10,"API:build_totcap_from_captbl - ignoring CapId %d",pTotCap->CapId);

        // treat exactly like deleted termcap...
        pTotCap->Dir        = H245_CAPDIR_DONTCARE;
        pTotCap->DataType   = H245_DATA_DONTCARE;
        pTotCap->ClientType = H245_CLIENT_DONTCARE;

        return H245_ERROR_OK;

      } else {

        H245TRACE(0,1,"API:build_totcap_from_captbl -> %s",map_api_error(error));
        return error;
      }
    }

  H245TRACE(0,10,"API:build_totcap_from_captbl -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_n_client_from_capbility
 *
 * DESCRIPTION:
 *              Take a capability structure (pCapability),
 *              data type (audio/video/data) choice...
 *              Which is found in the pdu . and the totcap;
 *              NOTE: does not handle H245_DATA_MUX_T
 *
 * RETURN:
 *
 * ASSUMES:
 *              ONLY HANDLES Terminal Caps.. Does not handle MUX Caps.
 *
 *              totcap.DataType is defined
 *              totcap.CapId    is defined
 *              totcap.Cap      is non NULL
 *
 *****************************************************************************/
HRESULT
build_totcap_cap_n_client_from_capability (struct Capability    *pCapability,
                                          H245_DATA_T            data_type,
                                          unsigned short         choice,
                                          H245_TOTCAP_T         *pTotCap)
{
  H245TRACE(0,10,"API:build_totcap_cap_n_client_from_capability <-");

  switch (data_type)
    {
    case H245_DATA_NONSTD:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_NONSTD");
      pTotCap->ClientType = H245_CLIENT_NONSTD;
      pTotCap->Cap.H245_NonStd = pCapability->u.Capability_nonStandard;
      break;

    case H245_DATA_AUDIO:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_AUDIO");
      switch (choice)
        {
        case AdCpblty_nonStandard_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_nonStandard_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_NONSTD;
          pTotCap->Cap.H245Aud_NONSTD      = pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard;
          break;
        case AdCpblty_g711Alaw64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Alaw64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ALAW64;
          pTotCap->Cap.H245Aud_G711_ALAW64 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw64k;
          break;
        case AdCpblty_g711Alaw56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Alaw56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ALAW56;
          pTotCap->Cap.H245Aud_G711_ALAW56 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw56k;
          break;
        case AdCpblty_g711Ulaw64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Ulaw64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ULAW64;
          pTotCap->Cap.H245Aud_G711_ULAW64 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw64k;
          break;
        case AdCpblty_g711Ulaw56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Ulaw56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ULAW56;
          pTotCap->Cap.H245Aud_G711_ULAW56 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw56k;
          break;
        case AudioCapability_g722_64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_64;
          pTotCap->Cap.H245Aud_G722_64     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_64k;
          break;
        case AudioCapability_g722_56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_56;
          pTotCap->Cap.H245Aud_G722_56     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_56k;
          break;
        case AudioCapability_g722_48k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_48k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_48;
          pTotCap->Cap.H245Aud_G722_48     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_48k;
          break;
        case AudioCapability_g7231_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g7231_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G723;
          pTotCap->Cap.H245Aud_G723        = pCapability->u.receiveAudioCapability.u.AudioCapability_g7231;
          break;
        case AudioCapability_g728_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g728_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G728;
          pTotCap->Cap.H245Aud_G728        = pCapability->u.receiveAudioCapability.u.AudioCapability_g728;
          break;
        case AudioCapability_g729_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g729_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G729;
          pTotCap->Cap.H245Aud_G729        = pCapability->u.receiveAudioCapability.u.AudioCapability_g729;
          break;
        case AdCpblty_g729AnnexA_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g729AnnexA_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_GDSVD;
          pTotCap->Cap.H245Aud_GDSVD       = pCapability->u.receiveAudioCapability.u.AdCpblty_g729AnnexA;
          break;
        case is11172AudioCapability_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - is11172AudioCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_IS11172;
          pTotCap->Cap.H245Aud_IS11172     = pCapability->u.receiveAudioCapability.u.is11172AudioCapability;
          break;
        case is13818AudioCapability_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - is13818AudioCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_IS13818;
          pTotCap->Cap.H245Aud_IS13818     = pCapability->u.receiveAudioCapability.u.is13818AudioCapability;
          break;
        default:
          pTotCap->ClientType = 0;
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - default");
          return H245_ERROR_NOSUP;
          break;
        }
      break;

    case H245_DATA_VIDEO:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_VIDEO");

      switch (choice)
        {
        case VdCpblty_nonStandard_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - VdCpblty_nonStandard_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_NONSTD;
          pTotCap->Cap.H245Vid_NONSTD    = pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard;
          break;
        case h261VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h261VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H261;
          pTotCap->Cap.H245Vid_H261      = pCapability->u.receiveVideoCapability.u.h261VideoCapability;
          break;
        case h262VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h262VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H262;
          pTotCap->Cap.H245Vid_H262      = pCapability->u.receiveVideoCapability.u.h262VideoCapability;
          break;
        case h263VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h263VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H263;
          pTotCap->Cap.H245Vid_H263      = pCapability->u.receiveVideoCapability.u.h263VideoCapability;
          break;
        case is11172VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - is11172VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_IS11172;
          pTotCap->Cap.H245Vid_IS11172   = pCapability->u.receiveVideoCapability.u.is11172VideoCapability;
          break;
        default:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - default");
          pTotCap->ClientType = 0;
          return H245_ERROR_NOSUP;
          break;
        }
      break;

    case H245_DATA_DATA:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_DATA");

      pTotCap->Cap.H245Dat_NONSTD = pCapability->u.rcvDtApplctnCpblty;
      switch (choice)
        {
        case DACy_applctn_nnStndrd_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_nnStndrd_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_NONSTD;
          break;
        case DACy_applctn_t120_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t120_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T120;
          break;
        case DACy_applctn_dsm_cc_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_dsm_cc_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_DSMCC;
          break;
        case DACy_applctn_usrDt_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_usrDt_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_USERDATA;
          break;
        case DACy_applctn_t84_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t84_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T84;
          break;
        case DACy_applctn_t434_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t434_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T434;
          break;
        case DACy_applctn_h224_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_h224_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_H224;
          break;
        case DACy_applctn_nlpd_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_nlpd_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_NLPID;
          break;
        case DACy_applctn_dsvdCntrl_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_dsvdCntrl_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_DSVD;
          break;
        case DACy_an_h222DtPrttnng_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_an_h222DtPrttnng_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_H222;
          break;
        default:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - default");
          pTotCap->ClientType = 0;
          return H245_ERROR_NOSUP;
          break;
        }
      break;
    case H245_DATA_ENCRYPT_D:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_ENCRYPT_D");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
      break;
    case H245_DATA_MUX:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_MUX");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - default");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
    }

  H245TRACE(0,10,"API:build_totcap_cap_n_client_from_capability -> OK");
  return H245_ERROR_OK;
}
/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   del_link
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
HRESULT
del_link (
          H245_LINK_T   **pp_link_start,
          H245_LINK_T   *p_link
          )
{
  struct H245_LINK_T    *p_link_look = NULL;
  struct H245_LINK_T    *p_link_lst = NULL;

  H245TRACE(0,10,"API:del_link <-");
  /* get current count on table */

  for (p_link_look = *pp_link_start;
       p_link_look && (p_link_look != p_link);
       p_link_lst = p_link_look,
         p_link_look = p_link_look->p_next
       );

  /* cap was not in list */

  if (!p_link_look)
  {
    H245TRACE(0,1,"API:del_link -> link not found!");
    return H245_ERROR_PARAM;
  }

  /* modify entry in table */
  if (!p_link_lst)
    *pp_link_start = p_link_look->p_next;

  else
    p_link_lst->p_next = p_link_look->p_next;

  H245_free (p_link_look);

  H245TRACE(0,10,"API:del_link -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   del_cap_link
 *
 * DESCRIPTION:
 *
 * ASSUMES:     Capability Table is locked before call
 *
 * RETURN:      None
 *
 * ASSUME:      List is Locked
 *
 *
 *****************************************************************************/
HRESULT
del_cap_link (
               struct TerminalCapabilitySet    *pTermCapSet,  /* capabilty set */
               CapabilityTableLink              pCapLink
             )
{
  CapabilityTableLink           pCapLink_look = NULL;
  CapabilityTableLink           pCapLink_lst = NULL;
  CapabilityTableEntry         *pCap_entry = NULL;
  unsigned char                *p_char_to_free = NULL;
  POBJECTID                     p_objid_to_free = NULL;

  H245TRACE(0,10,"API:del_cap_link <-");

  H245ASSERT (pTermCapSet);
  H245ASSERT (pCapLink);

  /************************************************/
  /* BEGIN :  Non Standard Capability Special Case */
  /************************************************/
  switch (pCapLink->value.capability.choice)
    {
    case Capability_nonStandard_chosen:

      /* free nonstandard data value */
      p_char_to_free = pCapLink->value.capability.u.Capability_nonStandard.data.value;

      /* free the object id */
      if (pCapLink->value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice == object_chosen)
        p_objid_to_free = pCapLink->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.object;
      break;

    case receiveVideoCapability_chosen:
    case transmitVideoCapability_chosen:
    case rcvAndTrnsmtVdCpblty_chosen:

      /* free nonstandard data value */
      if (pCapLink->value.capability.u.receiveVideoCapability.choice == VdCpblty_nonStandard_chosen)
        {
          /* nonstd value */
          p_char_to_free = pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.data.value;
          /* free the object id */
          if (pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.nonStandardIdentifier.u.object;
        }

      break;

    case receiveAudioCapability_chosen:
    case transmitAudioCapability_chosen:
    case rcvAndTrnsmtAdCpblty_chosen:

      /* free nonstandard data value */
      if (pCapLink->value.capability.u.receiveAudioCapability.choice == AdCpblty_nonStandard_chosen)
        {
          /* nonstd value */
          p_char_to_free = pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.data.value;

          /* free the object id */
          if (pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.nonStandardIdentifier.u.object;
        }
      break;

    case rcvDtApplctnCpblty_chosen:
    case trnsmtDtApplctnCpblty_chosen:
    case rATDACy_chosen :

      if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice == DACy_applctn_nnStndrd_chosen)
        {
          /* free nonstandard data value */
          p_char_to_free = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.data.value;

          /* free the object id */
          if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object;
        }
      break;

    case h233EncryptnTrnsmtCpblty_chosen:
    case h233EncryptnRcvCpblty_chosen:
    default:
      break;
    }

  /* free the value if there is one */
  if (p_char_to_free)
    {
      H245TRACE(0,10,"TMPMSG: Free NonStandard Value");
      H245_free(p_char_to_free);
    }

  /* free the objectid */
  if (p_objid_to_free)
    {
      H245TRACE(0,10,"TMPMSG: Free NonStandard ID");
      free_object_id (p_objid_to_free);
    }

  /************************************************/
  /* END :  Non Standard Capability Special Case  */
  /************************************************/

  H245TRACE(0,10,"API:del_cap_link -> OK");
  return del_link(&((H245_LINK_T *) pTermCapSet->capabilityTable),
           (H245_LINK_T *) pCapLink);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   dealloc_link_cap_list
 *
 * DESCRIPTION: deallocs the entire list of capabilities from a capabiltiy
 *              set
 *
 * ASSUMES:     Capability Table is locked before call
 *              del_cap_link updates pTermCapSet->capabilityTable
 *                   correctly.
 *
 *****************************************************************************/
void
dealloc_link_cap_list ( struct TerminalCapabilitySet *pTermCapSet)
{
  while (pTermCapSet->capabilityTable)
    del_cap_link  (pTermCapSet, pTermCapSet->capabilityTable);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   clean_cap_table - clean out all unused cap entries
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:     on entry.. table locked
 *
 *****************************************************************************/
void
clean_cap_table( struct TerminalCapabilitySet *pTermCapSet )
{
  CapabilityTableLink   pCapLink;
  CapabilityTableLink   pCap_nxt;

  H245TRACE(0,10,"API:clean_cap_table <-");
  /* traverse through the list.. delete all where capabilities are not set */

  for (pCapLink = pTermCapSet->capabilityTable;
       pCapLink;)
    {
      pCap_nxt = pCapLink->next;

      if (!(pCapLink->value.bit_mask & capability_present))
        {
          H245TRACE(0,20,"API:clean_cap_table - deleting CapId = %d",
                    pCapLink->value.capabilityTableEntryNumber);
          del_cap_link ( pTermCapSet, pCapLink );
        }
      pCapLink = pCap_nxt;
    }

  /* if no tercaps present unset flag */
  if (!pTermCapSet->capabilityTable)
    pTermCapSet->bit_mask &= ~capabilityTable_present;

  H245TRACE(0,10,"API:clean_cap_table -> OK");
}


/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   alloc_link_tracker
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
alloc_link_tracker (struct InstanceStruct *     pInstance,
                    API_TRACKER_T               TrackerType,
                    DWORD                       dwTransId,
                    API_TRACKER_STATE_T         State,
                    API_TRACKER_CH_ALLOC_T      ChannelAlloc,
                    API_TRACKER_CH_T            ChannelType,
                    H245_DATA_T                 DataType,
                    H245_CHANNEL_T              wTxChannel,
                    H245_CHANNEL_T              wRxChannel,
                    DWORD                       MuxEntryCount
                    )
{
  Tracker_T *p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:alloc_link_tracker <-");
  /* allocate tracker object */

  if (!(p_tracker = (Tracker_T *)H245_malloc(sizeof(Tracker_T))))
  {
    H245TRACE(pInstance->dwInst,1,"API:alloc_link_trakcer -> No memory");
    return NULL;
  }

  p_tracker->TrackerType            = TrackerType;
  p_tracker->TransId                = dwTransId;
  p_tracker->State                  = State;
  switch (TrackerType)
  {
  case API_OPEN_CHANNEL_T:
  case API_CLOSE_CHANNEL_T:
    p_tracker->u.Channel.ChannelAlloc = ChannelAlloc;
    p_tracker->u.Channel.ChannelType  = ChannelType;
    p_tracker->u.Channel.DataType     = DataType;
    p_tracker->u.Channel.TxChannel    = wTxChannel;
    p_tracker->u.Channel.RxChannel    = wRxChannel;
    break;

  case API_SEND_MUX_T:
  case API_RECV_MUX_T:
    p_tracker->u.MuxEntryCount        = MuxEntryCount;
    break;

  default:
    break;
  } // switch

  p_tracker->p_next                 = pInstance->API.pTracker;
  if (p_tracker->p_next)
  {
    p_tracker->p_prev = p_tracker->p_next->p_prev;
    p_tracker->p_next->p_prev = p_tracker;
  }
  else
  {

    p_tracker->p_prev = NULL;
  }
  pInstance->API.pTracker = p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:alloc_link_tracker -> %x", p_tracker);
  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void
unlink_dealloc_tracker (struct InstanceStruct *pInstance,  Tracker_T *p_tracker)
{
  H245TRACE(pInstance->dwInst,4,"API:unlink_dealloc_tracker - type = %s",map_tracker_type (p_tracker->TrackerType));

  if (p_tracker->p_next)
    p_tracker->p_next->p_prev = p_tracker->p_prev;

  /* if not first on the list */
  if (p_tracker->p_prev)
    p_tracker->p_prev->p_next = p_tracker->p_next;
  else
    pInstance->API.pTracker = p_tracker->p_next;

  H245_free (p_tracker);
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_txchannel
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_txchannel (struct InstanceStruct *pInstance, DWORD dwChannel, API_TRACKER_CH_ALLOC_T ChannelAlloc)
{
  register Tracker_T *p_tracker;

  H245ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;p_tracker;p_tracker = p_tracker->p_next)
  {
    if (p_tracker->u.Channel.TxChannel    == dwChannel &&
        p_tracker->u.Channel.ChannelAlloc == ChannelAlloc)
    {
      return p_tracker;
    }
  }

  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_rxchannel
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_rxchannel (struct InstanceStruct *pInstance, DWORD dwChannel, API_TRACKER_CH_ALLOC_T ChannelAlloc)
{
  register Tracker_T *p_tracker;

  H245ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;p_tracker;p_tracker = p_tracker->p_next)
  {
    if (p_tracker->u.Channel.RxChannel    == dwChannel &&
        p_tracker->u.Channel.ChannelAlloc == ChannelAlloc)
    {
      return p_tracker;
    }
  }

  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_pointer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_pointer (struct InstanceStruct *pInstance, Tracker_T *p_tracker_look)
{
  Tracker_T *p_tracker;

  H245ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;
       ((p_tracker) && (p_tracker != p_tracker_look));
       p_tracker = p_tracker->p_next);

  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_type
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:     table MUST be locked before this call on this call ..
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_type (struct InstanceStruct *pInstance,
                      API_TRACKER_T tracker_type,
                      Tracker_T *p_tracker_start)
{
  Tracker_T *p_tracker;

  H245ASSERT (pInstance != NULL);
  if (p_tracker_start)
    p_tracker = p_tracker_start;
  else
    p_tracker = pInstance->API.pTracker;

  for (;
       ((p_tracker) && (p_tracker->TrackerType != tracker_type));
       p_tracker = p_tracker->p_next);

  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   set_capability -
 *
 * DESCRIPTION:
 *              NOTE: capid in the TotCap structure is
 *                    ignored.
 *
 * RETURN:
 *              NewCapId            if no error
 *              H245_INVALID_CAPID  if error
 *
 * ASSUMES:
 *              Assumes the H245_INST_T is valid and has been checked
 *
 *****************************************************************************/
void del_mux_cap(struct TerminalCapabilitySet *pTermCapSet)
{
  if (pTermCapSet->bit_mask & multiplexCapability_present)
  {
    switch (pTermCapSet->multiplexCapability.choice)
    {
    case MltplxCpblty_nonStandard_chosen:
      FreeNonStandardParameter(&pTermCapSet->multiplexCapability.u.MltplxCpblty_nonStandard);
      break;

    case h222Capability_chosen:
      FreeH222Cap(&pTermCapSet->multiplexCapability.u.h222Capability);
      break;

    case h2250Capability_chosen:
      FreeH2250Cap(&pTermCapSet->multiplexCapability.u.h2250Capability);
      break;

    } // switch
    pTermCapSet->bit_mask &= ~multiplexCapability_present;
  }
} // del_mux_cap()

# pragma warning( disable : 4100 )

HRESULT set_mux_cap(struct InstanceStruct        *pInstance,
                    struct TerminalCapabilitySet *pTermCapSet,
                    H245_TOTCAP_T                *pTotCap)
{
  HRESULT                   lError;

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_MUX_NONSTD:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - NONSTD");
    lError = CopyNonStandardParameter(&pTermCapSet->multiplexCapability.u.MltplxCpblty_nonStandard,
                                        &pTotCap->Cap.H245Mux_NONSTD);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = MltplxCpblty_nonStandard_chosen;
    break;

  case H245_CLIENT_MUX_H222:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H222");
    lError = CopyH222Cap(&pTermCapSet->multiplexCapability.u.h222Capability,
                           &pTotCap->Cap.H245Mux_H222);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = h222Capability_chosen;
    break;

  case H245_CLIENT_MUX_H223:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H223");
    pTermCapSet->multiplexCapability.u.h223Capability = pTotCap->Cap.H245Mux_H223;
    pTermCapSet->multiplexCapability.choice = h223Capability_chosen;
    break;

  case H245_CLIENT_MUX_VGMUX:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - VGMUX");
    pTermCapSet->multiplexCapability.u.v76Capability = pTotCap->Cap.H245Mux_VGMUX;
    pTermCapSet->multiplexCapability.choice = v76Capability_chosen;
    break;

  case H245_CLIENT_MUX_H2250:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H2250");
    lError = CopyH2250Cap(&pTermCapSet->multiplexCapability.u.h2250Capability,
                          &pTotCap->Cap.H245Mux_H2250);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = h2250Capability_chosen;
    break;

  default:
    H245TRACE(pInstance->dwInst,1,"API:set_mux_cap - Unrecognized Client Type %d", pTotCap->ClientType);
    return H245_ERROR_NOSUP;
  }

  pTermCapSet->bit_mask |= multiplexCapability_present;
  return H245_ERROR_OK;
} // set_mux_cap()

HRESULT
set_capability (
                struct InstanceStruct        *pInstance,
                struct TerminalCapabilitySet *pTermCapSet,
                H245_TOTCAP_T                *pTotCap         /* tot capability for update*/
                )
{
  CapabilityTableEntry         *pCapEntry;
  Capability                   *pCapability;
  CapabilityTableLink           pCapLink;
  HRESULT                       lError;

  H245ASSERT(pInstance   != NULL);
  H245ASSERT(pTermCapSet != NULL);
  H245ASSERT(pTotCap     != NULL);

  /* if the table entry is currently in the table, */
  /* then  delete it and add a new entry with the same entry number */
  pCapLink = find_capid_by_entrynumber (pTermCapSet, pTotCap->CapId);
  if (pCapLink)
  {
    del_cap_link (pTermCapSet, pCapLink);
  } /* if pCapLink */

  /* allocate an entry for the new terminal capbaility  */
  pCapLink = alloc_link_cap_entry (pTermCapSet);
  if (pCapLink == NULL)
  {
    return H245_ERROR_NOMEM;
  }

  /* make it easier to deal with the Asn1 structures */
  pCapEntry   = &pCapLink->value;
  pCapability = &pCapEntry->capability;
  pCapability->choice = 0;
  switch (pTotCap->DataType)
  {
  case H245_DATA_NONSTD:
    pCapability->choice = Capability_nonStandard_chosen;
    break;

  case H245_DATA_VIDEO:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = transmitVideoCapability_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = receiveVideoCapability_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rcvAndTrnsmtVdCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_AUDIO:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = transmitAudioCapability_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = receiveAudioCapability_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rcvAndTrnsmtAdCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_DATA:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = trnsmtDtApplctnCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = rcvDtApplctnCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rATDACy_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_ENCRYPT_D:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = h233EncryptnTrnsmtCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = h233EncryptnRcvCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_CONFERENCE:
    pCapability->choice = conferenceCapability_chosen;
    break;

  } // switch (DataType)

  /* if error occured, free cap, unlock, and return */
  if (pCapability->choice == 0)
  {
    H245TRACE(pInstance->dwInst,1,"API:set_capability -> Invalid capability");
    del_cap_link (pTermCapSet, pCapLink);
    return H245_ERROR_PARAM;
  }

  /* load total cap into Capability Set */
  /* if load cap returns error, free cap, unlock, and return */
  lError = load_cap(pCapability, pTotCap);
  if (lError != H245_ERROR_OK)
  {
    del_cap_link (pTermCapSet, pCapLink);
    return lError;
  }

  /* mark the entry as in use */
  pCapEntry->bit_mask = capability_present;
  pCapEntry->capabilityTableEntryNumber = pTotCap->CapId;

  /* set termcapTable  present */
  pTermCapSet->bit_mask |= capabilityTable_present;

  return H245_ERROR_OK;
}

# pragma warning( default : 4100 )

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   build_object_id
 *
 * DESCRIPTION
 *
 * RETURN:      linked list of Object ID structures
 *
 * ASSUMES:     Input string is a valid "<n>.<n>.<n>..."
 *
 *****************************************************************************/
static POBJECTID
build_object_id (const char *p_str)
{
  POBJECTID p_obj_id             = NULL;
  POBJECTID p_obj_id_first       = NULL;
  POBJECTID p_obj_id_lst         = NULL;
  int    value = 0;
  int    fset = FALSE;

  /* if no sting.. forget it */

  if (!p_str)
    return NULL;

  H245TRACE(0,20,"API:Object Id %s",p_str);

  /* while there is a string left.. */

  while (*p_str != '\0')
    {
      /* while there is a string left, and it's not a '.' */

      value = 0;
      fset = FALSE;

      while ((*p_str != '\0') && (*p_str != '.'))
        {
          fset = TRUE;
          value = value*10+(*p_str-'0');
          p_str++;
        }
      /* must ahve been a "." or an end string */

      if (fset)
        {
          if (*p_str != '\0')
            p_str++;

          /* allocate the first object */
          if (!(p_obj_id = (POBJECTID) H245_malloc (sizeof(*p_obj_id))))
            {
              free_object_id (p_obj_id_first);

              return NULL;

            } /* if alloc failes */

          /* if first objected allocated */
          if (!p_obj_id_first)
            p_obj_id_first = p_obj_id;
          else
            p_obj_id_lst->next = p_obj_id;

          p_obj_id->value = (unsigned short) value;
          p_obj_id->next = NULL;
          p_obj_id_lst = p_obj_id;
        }

    } /* while  */

  return p_obj_id_first;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   free_mux_table_list - recursively free mux table list
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_table_list (H245_MUX_TABLE_T *p_mux_tbl)
{
  if (!p_mux_tbl)
    return;

  free_mux_table_list (p_mux_tbl->pNext);
  free_mux_el_list (p_mux_tbl->pMuxTblEntryElem);
  H245_free (p_mux_tbl);
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   free_mux_el_list - recursively free mux element list
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_el_list (H245_MUX_ENTRY_ELEMENT_T *p_mux_el)
{
  if (!p_mux_el)
    return;

  if (p_mux_el->Kind == H245_MUX_ENTRY_ELEMENT)
    free_mux_el_list (p_mux_el->u.pMuxTblEntryElem);

  free_mux_el_list (p_mux_el->pNext);
  H245_free (p_mux_el);
}
/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   api_init ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
api_init (struct InstanceStruct *pInstance)
{
  H245ASSERT (pInstance != NULL);

  H245TRACE(pInstance->dwInst,10,"API:api_init <-");

  /**************************/
  /* Terminal Cap TABLE     */
  /**************************/
  pInstance->API.PDU_LocalTermCap.choice = MltmdSystmCntrlMssg_rqst_chosen;
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.choice =
    terminalCapabilitySet_chosen;
  pInstance->API.PDU_RemoteTermCap.choice = MltmdSystmCntrlMssg_rqst_chosen;
  pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.choice =
    terminalCapabilitySet_chosen;

  /**************************/
  /* MULTIPLEX TABLE CAP's  */
  /**************************/

  switch (pInstance->Configuration)
    {
    case H245_CONF_H324:
      {
        H223Capability *p_H223;
        /* set h223 capabilities */
        pInstance->API.PDU_LocalTermCap.
          u.MltmdSystmCntrlMssg_rqst.
            u.terminalCapabilitySet.multiplexCapability.choice =
              h223Capability_chosen;

        p_H223 = &(pInstance->API.PDU_LocalTermCap.
                   u.MltmdSystmCntrlMssg_rqst.
                    u.terminalCapabilitySet.multiplexCapability.
                     u.h223Capability);

        /* (TBC) how do we communicate this to the API */
        /* booleans.. */
        p_H223->transportWithI_frames;
        p_H223-> videoWithAL1 = FALSE;
        p_H223-> videoWithAL2 = FALSE;
        p_H223-> videoWithAL3 = TRUE;
        p_H223-> audioWithAL1 = FALSE;
        p_H223-> audioWithAL2 = TRUE;
        p_H223-> audioWithAL3 = FALSE;
        p_H223-> dataWithAL1 = FALSE;
        p_H223-> dataWithAL2 = FALSE;
        p_H223-> dataWithAL3 = FALSE;
        /* ushort's */
        p_H223-> maximumAl2SDUSize = 2048;
        p_H223-> maximumAl3SDUSize = 2048;
        p_H223-> maximumDelayJitter = 0;
        /* enhanced/Basic */
        p_H223->h223MultiplexTableCapability.choice = h223MltplxTblCpblty_bsc_chosen;
      }
      break;
    case H245_CONF_H323:
      break;
    case H245_CONF_H310:
    case H245_CONF_GVD:
    default:
      return H245_ERROR_NOSUP;
      break;

    } /* switch */

  /* setup Object Id for Terminal Cap Set */
  /* (TBC) where do we get/set the protocolIdentifier */
  pInstance->API.PDU_LocalTermCap.
    u.MltmdSystmCntrlMssg_rqst.
      u.terminalCapabilitySet.protocolIdentifier = build_object_id (H245_PROTOID);

  pInstance->API.MasterSlave = APIMS_Undef;
  pInstance->API.SystemState = APIST_Inited;

  pInstance->API.LocalCapIdNum = H245_MAX_CAPID + 1;
  pInstance->API.LocalCapDescIdNum = 0;

  H245TRACE(pInstance->dwInst,10,"API:api_init -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   api_deinit ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
api_deinit (struct InstanceStruct *pInstance)
{
  Tracker_T *pTracker;
  int        nCount;

  H245TRACE(pInstance->dwInst,10,"API:api_deinit <-");

  /* free structures and act on outstanding links in structure */
#if defined(DBG)
  dump_tracker(pInstance);
#endif
  free_object_id (pInstance->API.PDU_LocalTermCap.
                  u.MltmdSystmCntrlMssg_rqst.
                  u.terminalCapabilitySet.protocolIdentifier);

  /* free simultaneous capabilities */
  for (nCount = 0; nCount < 256; ++nCount)
  {
    if (pInstance->API.PDU_LocalTermCap.TERMCAPSET.capabilityDescriptors.value[nCount].smltnsCpblts)
      dealloc_simultaneous_cap (&pInstance->API.PDU_LocalTermCap.TERMCAPSET.capabilityDescriptors.value[nCount]);
    if (pInstance->API.PDU_RemoteTermCap.TERMCAPSET.capabilityDescriptors.value[nCount].smltnsCpblts)
      dealloc_simultaneous_cap (&pInstance->API.PDU_RemoteTermCap.TERMCAPSET.capabilityDescriptors.value[nCount]);
  }

  /* free capabilities */
  del_mux_cap(&pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
  del_mux_cap(&pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
  dealloc_link_cap_list ( &pInstance->API.PDU_LocalTermCap.TERMCAPSET);
  dealloc_link_cap_list ( &pInstance->API.PDU_RemoteTermCap.TERMCAPSET);

  while ((pTracker = pInstance->API.pTracker) != NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:api_deinit -> %s Tracker Still Pending",
              map_tracker_type(pTracker->TrackerType));
    unlink_dealloc_tracker (pInstance, pTracker);
  }

  H245TRACE(pInstance->dwInst,10,"API:api_deinit -> OK");
  return H245_ERROR_OK;
}

#if defined(DBG)

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   map_api_error ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/

LPSTR map_api_error (HRESULT lError)
{
  static TCHAR szBuf[128];

  switch (lError)
  {
  case  H245_ERROR_OK:                  return "H245_ERROR_OK";
  case  H245_ERROR_INVALID_DATA_FORMAT: return "H245_ERROR_INVALID_DATA_FORMAT";
  case  H245_ERROR_NOMEM:               return "H245_ERROR_NOMEM";
  case  H245_ERROR_NOSUP:               return "H245_ERROR_NOSUP";
  case  H245_ERROR_PARAM:               return "H245_ERROR_PARAM";
  case  H245_ERROR_ALREADY_INIT:        return "H245_ERROR_ALREADY_INIT";
  case  H245_ERROR_NOT_CONNECTED:       return "H245_ERROR_NOT_CONNECTED";



  case  H245_ERROR_NORESOURCE:          return "H245_ERROR_NORESOURCE";
  case  H245_ERROR_NOTIMP:              return "H245_ERROR_NOTIMP";
  case  H245_ERROR_SUBSYS:              return "H245_ERROR_SUBSYS";
  case  H245_ERROR_FATAL:               return "H245_ERROR_FATAL";
  case  H245_ERROR_MAXTBL:              return "H245_ERROR_MAXTBL";
  case  H245_ERROR_CHANNEL_INUSE:       return "H245_ERROR_CHANNEL_INUSE";
  case  H245_ERROR_INVALID_CAPID:       return "H245_ERROR_INVALID_CAPID";
  case  H245_ERROR_INVALID_OP:          return "H245_ERROR_INVALID_OP";
  case  H245_ERROR_UNKNOWN:             return "H245_ERROR_UNKNOWN";
  case  H245_ERROR_NOBANDWIDTH:         return "H245_ERROR_NOBANDWIDTH";
  case  H245_ERROR_LOSTCON:             return "H245_ERROR_LOSTCON";
  case  H245_ERROR_INVALID_MUXTBLENTRY: return "H245_ERROR_INVALID_MUXTBLENTRY";
  case  H245_ERROR_INVALID_INST:        return "H245_ERROR_INVALID_INST";
  case  H245_ERROR_INPROCESS:           return "H245_ERROR_INPROCESS";
  case  H245_ERROR_INVALID_STATE:       return "H245_ERROR_INVALID_STATE";
  case  H245_ERROR_TIMEOUT:             return "H245_ERROR_TIMEOUT";
  case  H245_ERROR_INVALID_CHANNEL:     return "H245_ERROR_INVALID_CHANNEL";
  case  H245_ERROR_INVALID_CAPDESCID:   return "H245_ERROR_INVALID_CAPDESCID";
  case  H245_ERROR_CANCELED:            return "H245_ERROR_CANCELED";
  case  H245_ERROR_MUXELEMENT_DEPTH:    return "H245_ERROR_MUXELEMENT_DEPTH";
  case  H245_ERROR_MUXELEMENT_WIDTH:    return "H245_ERROR_MUXELEMENT_WIDTH";
  case  H245_ERROR_ASN1:                return "H245_ERROR_ASN1";
  case  H245_ERROR_NO_MUX_CAPS:         return "H245_ERROR_NO_MUX_CAPS";
  case  H245_ERROR_NO_CAPDESC:          return "H245_ERROR_NO_CAPDESC";
  default:
    wsprintf (szBuf,"**** UNKNOWN ERROR *** %d (0x%x)",lError,lError);
    return szBuf;
  }
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   map_fsm_event -
 *
 * DESpCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
LPSTR map_fsm_event (DWORD event)
{
  static TCHAR szBuf[128];

  switch (event)
  {
  case  H245_IND_MSTSLV:                 return "H245_IND_MSTSLV";
  case  H245_IND_CAP:                    return "H245_IND_CAP";
  case  H245_IND_OPEN:                   return "H245_IND_OPEN";
  case  H245_IND_OPEN_CONF:              return "H245_IND_OPEN_CONF";
  case  H245_IND_CLOSE:                  return "H245_IND_CLOSE";
  case  H245_IND_REQ_CLOSE:              return "H245_IND_REQ_CLOSE";
  case  H245_IND_MUX_TBL:                return "H245_IND_MUX_TBL";
  case  H245_IND_MTSE_RELEASE:           return "H245_IND_MTSE_RELEASE";
  case  H245_IND_RMESE:                  return "H245_IND_RMESE";
  case  H245_IND_RMESE_RELEASE:          return "H245_IND_RMESE_RELEASE";
  case  H245_IND_MRSE:                   return "H245_IND_MRSE";
  case  H245_IND_MRSE_RELEASE:           return "H245_IND_MRSE_RELEASE";
  case  H245_IND_MLSE:                   return "H245_IND_MLSE";
  case  H245_IND_MLSE_RELEASE:           return "H245_IND_MLSE_RELEASE";
  case  H245_IND_NONSTANDARD_REQUEST:    return "H245_IND_NONSTANDARD_REQUEST";
  case  H245_IND_NONSTANDARD_RESPONSE:   return "H245_IND_NONSTANDARD_RESPONSE";
  case  H245_IND_NONSTANDARD_COMMAND:    return "H245_IND_NONSTANDARD_COMMAND";
  case  H245_IND_NONSTANDARD:            return "H245_IND_NONSTANDARD";
  case  H245_IND_MISC_COMMAND:           return "H245_IND_MISC_COMMAND";
  case  H245_IND_MISC:                   return "H245_IND_MISC";
  case  H245_IND_COMM_MODE_REQUEST:      return "H245_IND_COMM_MODE_REQUEST";
  case  H245_IND_COMM_MODE_RESPONSE:     return "H245_IND_COMM_MODE_RESPONSE";
  case  H245_IND_COMM_MODE_COMMAND:      return "H245_IND_COMM_MODE_COMMAND";
  case  H245_IND_CONFERENCE_REQUEST:     return "H245_IND_CONFERENCE_REQUEST";
  case  H245_IND_CONFERENCE_RESPONSE:    return "H245_IND_CONFERENCE_RESPONSE";
  case  H245_IND_CONFERENCE_COMMAND:     return "H245_IND_CONFERENCE_COMMAND";
  case  H245_IND_CONFERENCE:             return "H245_IND_CONFERENCE";
  case  H245_IND_SEND_TERMCAP:           return "H245_IND_SEND_TERMCAP";
  case  H245_IND_ENCRYPTION:             return "H245_IND_ENCRYPTION";
  case  H245_IND_FLOW_CONTROL:           return "H245_IND_FLOW_CONTROL";
  case  H245_IND_ENDSESSION:             return "H245_IND_ENDSESSION";
  case  H245_IND_FUNCTION_NOT_UNDERSTOOD:return "H245_IND_FUNCTION_NOT_UNDERSTOOD:";
  case  H245_IND_JITTER:                 return "H245_IND_JITTER";
  case  H245_IND_H223_SKEW:              return "H245_IND_H223_SKEW";
  case  H245_IND_NEW_ATM_VC:             return "H245_IND_NEW_ATM_VC";
  case  H245_IND_USERINPUT:              return "H245_IND_USERINPUT";
  case  H245_IND_H2250_MAX_SKEW:         return "H245_IND_H2250_MAX_SKEW";
  case  H245_IND_MC_LOCATION:            return "H245_IND_MC_LOCATION";
  case  H245_IND_VENDOR_ID:              return "H245_IND_VENDOR_ID";
  case  H245_IND_FUNCTION_NOT_SUPPORTED: return "H245_IND_FUNCTION_NOT_SUPPORTED";
  case  H245_IND_H223_RECONFIG:          return "H245_IND_H223_RECONFIG";
  case  H245_IND_H223_RECONFIG_ACK:      return "H245_IND_H223_RECONFIG_ACK";
  case  H245_IND_H223_RECONFIG_REJECT:   return "H245_IND_H223_RECONFIG_REJECT";
  case  H245_CONF_INIT_MSTSLV:           return "H245_CONF_INIT_MSTSLV";
  case  H245_CONF_SEND_TERMCAP:          return "H245_CONF_SEND_TERMCAP";
  case  H245_CONF_OPEN:                  return "H245_CONF_OPEN";
  case  H245_CONF_NEEDRSP_OPEN:          return "H245_CONF_NEEDRSP_OPEN";
  case  H245_CONF_CLOSE:                 return "H245_CONF_CLOSE";
  case  H245_CONF_REQ_CLOSE:             return "H245_CONF_REQ_CLOSE";
  case  H245_CONF_MUXTBL_SND:            return "H245_CONF_MUXTBL_SND";
  case  H245_CONF_RMESE:                 return "H245_CONF_RMESE";
  case  H245_CONF_RMESE_REJECT:          return "H245_CONF_RMESE_REJECT";
  case  H245_CONF_RMESE_EXPIRED:         return "H245_CONF_RMESE_EXPIRED";
  case  H245_CONF_MRSE:                  return "H245_CONF_MRSE";
  case  H245_CONF_MRSE_REJECT:           return "H245_CONF_MRSE_REJECT";
  case  H245_CONF_MRSE_EXPIRED:          return "H245_CONF_MRSE_EXPIRED";
  case  H245_CONF_MLSE:                  return "H245_CONF_MLSE";
  case  H245_CONF_MLSE_REJECT:           return "H245_CONF_MLSE_REJECT";
  case  H245_CONF_MLSE_EXPIRED:          return "H245_CONF_MLSE_EXPIRED";
  case  H245_CONF_RTDSE:                 return "H245_CONF_RTDSE";
  case  H245_CONF_RTDSE_EXPIRED:         return "H245_CONF_RTDSE_EXPIRED";
  default:
    wsprintf (szBuf,"**** UNKNOWN EVENT *** %d (0x%x)",event,event);
    return szBuf;
  }
}

LPSTR map_tracker_type (API_TRACKER_T tracker_type)
{
  static TCHAR szBuf[128];

  switch (tracker_type)
  {
  case  API_TERMCAP_T:       return "API_TERMCAP_T";
  case  API_OPEN_CHANNEL_T:  return "API_OPEN_CHANNEL_T";
  case  API_CLOSE_CHANNEL_T: return "API_CLOSE_CHANNEL_T";
  case  API_MSTSLV_T:        return "API_MSTSLV_T";
  case  API_SEND_MUX_T:      return "API_SEND_MUX_T";
  case  API_RECV_MUX_T:      return "API_RECV_MUX_T";
  default:
    wsprintf (szBuf,"**** UNKNOWN TRACKER TYPE *** %d (0x%x)",tracker_type,tracker_type);
    return szBuf;
  }
}

#endif // (DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\fsminit.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsminit.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMINIT.C  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/FSMINIT.C_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:34:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   29 May 1996 15:20:16   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.0   09 May 1996 21:06:16   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.11.1.3   09 May 1996 19:48:42   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.11.1.2   15 Apr 1996 10:46:12   EHOWARDX
 * Update.
 *
 *    Rev 1.11.1.1   10 Apr 1996 21:15:38   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.11.1.0   05 Apr 1996 12:32:40   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"



/*
 *  NAME
 *      Fsm_init - allocate and initialize memory for FSM instance
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current instance
 *
 *  RETURN VALUE
 *      H245_ERROR_OK           function succeeded
 *      H245_ERROR_ALREADY_INIT FSM instance exists for specified dwInst
 */

HRESULT
Fsm_init(struct InstanceStruct *pInstance)
{
    pInstance->StateMachine.sv_STATUS = INDETERMINATE;
    return H245_ERROR_OK;
}



/*
 *  NAME
 *      Fsm_shutdown - cleanup FSM instance and deallocate instance memory
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current instance
 *
 *  RETURN VALUE
 *      H245_ERROR_OK           function succeeded
 *      H245_ERROR_INVALID_INST on FSM instance exists for specified dwInst
 */


HRESULT
Fsm_shutdown(struct InstanceStruct *pInstance)
{
    register int            i;

    for (i = 0; i < NUM_ENTITYS; ++i)
    {
        while (pInstance->StateMachine.Object_tbl[i])
        {
            H245TRACE(pInstance->dwInst, 2, "Fsm_shutdown: deallocating state entity %d", i);
            ObjectDestroy(pInstance->StateMachine.Object_tbl[i]);
        }
    }
    return H245_ERROR_OK;
} // Fsm_shutdown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245init.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				   
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245init.c  $						
 *  $Revision:   1.2  $							
 *  $Modtime:   29 May 1996 13:12:46  $					
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245init.c_v  $	
 * 
 *    Rev 1.2   29 May 1996 15:20:18   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:40   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:22   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.16   09 May 1996 19:35:34   EHOWARDX
 * Added new locking logic and changed timer.
 * 
 *    Rev 1.15   09 Apr 1996 15:53:36   dabrown1
 * 
 * Added srflush.x for queue flush bitmap
 * 
 *    Rev 1.14   05 Apr 1996 10:56:58   dabrown1
 * Asynchronous/Synchronous shutdown support
 * 
 *    Rev 1.13   04 Apr 1996 18:17:06   dabrown1
 * 
 * - changed parameter for DeInitTimer.. 
 * 
 *    Rev 1.12   02 Apr 1996 15:00:12   dabrown1
 * 
 * SendRcv EndSession asynchronous support
 * 
 *    Rev 1.11   18 Mar 1996 12:36:28   cjutzi
 * - added timer init and de-init
 * 
 *    Rev 1.10   13 Mar 1996 15:08:26   helgebax
 * added Fsm_shutdown(Instance) to clear FSM context
 * 
 *    Rev 1.9   06 Mar 1996 13:10:42   DABROWN1
 * Flush send receive transmit buffers at system shutdown
 * 
 *    Rev 1.8   28 Feb 1996 17:23:38   EHOWARDX
 * Added #include "fsmexpor.h" for Fsm_init prototype.
 * 
 *    Rev 1.7   27 Feb 1996 13:41:56   DABROWN1
 * removed mal/h223 initialization code
 * 
 *    Rev 1.6   26 Feb 1996 11:17:36   cjutzi
 * - moved api_deinit.. to EndSystemClose
 * 
 *    Rev 1.5   21 Feb 1996 13:23:12   DABROWN1
 * 
 * check return codes for SR and FSM on initialization
 * 
 *    Rev 1.4   13 Feb 1996 14:48:50   DABROWN1
 * 
 * Removed SPOX only include files from mainline path
 * 
 *    Rev 1.3   09 Feb 1996 16:00:22   cjutzi
 * 
 * - cleaned up the startup...
 * - added the mal and h223 startup to the configuration as was 
 *   determined to be correct.. (still some issues with handles)
 *  $Ident$
 *
 *****************************************************************************/

#define STRICT 

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "sr_api.h"
//#include "h223api.h"
#include "fsmexpor.h"
#include "h245sys.x"

#if defined(H324)
/*****************************************************************************
 *									      
 * Type:	LOCAL							      
 *									      
 * PROCEDURE: 	setup_from_H245_ini - setup using conmgr.ini file 
 *									      
 * DESCRIPTION:							      	      
 *									      
 *****************************************************************************/ 

static 
void setup_from_H245_ini (int *p_dbg_lvl)
{
  char		*p_ini = "h245.ini";			
  char		*p_H245 ="H245";

  p_ini        	= "h245.ini";				
  p_H245       	= "H245";				

#ifdef OIL
  OIL_GetPrivateProfileInt(p_H245, "TraceLvl", 0, p_ini, p_dbg_lvl);
#else
  *p_dbg_lvl = GetPrivateProfileInt (p_H245, "TraceLvl", 0, p_ini);	
#endif
}
#endif  // (H324)

/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	StartSystemInitilize - Initialize Sub Systems
 *									      
 * DESCRIPTION:							      	      
 *
 *		This is called on entry to the H245_Init API Call
 *
 *
 *		This procedure initializes all the subsystems in H245. Errors
 *		must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD StartSystemInit (struct InstanceStruct *pInstance)
{
  HRESULT lError;

  /* Timer Initialization */
//  H245InitTimer(pInstance);

  /* API Subsystem Initialization */
  lError = api_init(pInstance);
  if (lError != H245_ERROR_OK)
    return lError;

  /* Send Receive Subsystem Initialization */
  lError = sendRcvInit(pInstance);
  if (lError != H245_ERROR_OK)
    return lError;

  /* State Machine Subsystem Initialization */
  return Fsm_init(pInstance);
}

# pragma warning( disable : 4100 )

/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	EndSystemInitilize - Initialize Sub Systems
 *									      
 * DESCRIPTION:							      	      
 *
 *		This is called on exit from H245 System Initialization
 *
 *
 *		This procedure initializes all the subsystems in H245. Errors
 *		must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD EndSystemInit (struct InstanceStruct *pInstance)
{
  /* API Subsystem Initialization */

  // -- TBD

  /* Send Receive Subsystem Initialization */

  // -- TBD

  /* State Machine Subsystem Initialization */

  // -- TBD

  return H245_ERROR_OK;
}


/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	StartSessionClose
 *									      
 * DESCRIPTION:							      	      
 *
 *		This procedure is called when H245_Shutdown occurs
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD StartSystemClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Shutdown Initiation */
  
  // TBD

  /* Send Receive Shutdown Initiation */

  // TBD

  /* State Machine Shutdown Initiation */
  Fsm_shutdown(pInstance);

  return (H245_ERROR_OK);
}


/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	StartSessionClose
 *									      
 * DESCRIPTION:							      	      
 *
 *		This procedure is called when H245_Shutdown completes asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD EndSystemClose (struct InstanceStruct *pInstance)
{

  /* Send Receive Shutdown Completion */
  sendRcvShutdown(pInstance);

  /* API Subsystem Shutdown Completion */

  api_deinit(pInstance);

  /* State Machine Shutdown Completion */

  // -- TBD

  /* Timer Shutdown */
//  H245DeInitTimer(pInstance);

  return (H245_ERROR_OK);
}



/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	StartSessionInit
 *									      
 * DESCRIPTION:							      	      
 *
 *		This procedure is called when an H245_BeginConnection is called.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD StartSessionInit (struct InstanceStruct *pInstance)
{

  /* API Subsystem Initialization */


  /* Send Receive  Initialization */


  /* State Machine Initialization */


  return H245_ERROR_OK;
}

/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	EndSessionInit 
 *									      
 * DESCRIPTION:							      	      
 *
 *		This procedure is called when an H245_BeginConnection call is
 *		completed.. Asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD EndSessionInit (struct InstanceStruct *pInstance)
{

  /* API Subsystem Initialization */


  /* Send Receive Initialization */


  /* Master Slave Initialization */


  return H245_ERROR_OK;
}

/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	StartSessionClose
 *									      
 * DESCRIPTION:							      	      
 *
 *		This procedure is called when H245_EndConnection occurs
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD StartSessionClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Session Close */

  /* Send Receive Session Close */
  /* Dequeue any buffers posted in the data link transmit queue */
  if (sendRcvFlushPDUs(pInstance,
		       DATALINK_TRANSMIT,
		       TRUE))				{
    H245TRACE(pInstance->dwInst, 1, "Flush Buffer Failure");
  }

  /* State Machine Session Close */

  return H245_ERROR_OK;
}


/*****************************************************************************
 *									      
 * Type:	GLOBAL
 *									      
 * PROCEDURE: 	EndSessionClose
 *									      
 * DESCRIPTION:							      	      
 *
 *		This procedure is called when H245_EndConnection completes 
 *		asynchroniously.
 *
 *		Errors must be mapped to an appropriate H245_ERROR_xxx allowing the 
 *		initialization error to be propogated to through the API to the
 *		H245 Client.  As your subsystem initializes, if errors occur
 *		you are responsable for doing the mapping from your subsystem to 
 *		the appropriate H245_ERROR_xxx.  If there is no appropriate error
 *		please contact the programmer in charge of the API indicating 
 *		your new error return value so that h245api.h can be updated, 
 *		as well as the new error documented in the API/EPS.. 
 *
 *
 *		returns - H245_ERROR_OK 	if no error has occured.. 
 *		returns - H245_ERROR_xxxx	indicating error
 *									      
 *****************************************************************************/ 

DWORD EndSessionClose (struct InstanceStruct *pInstance)
{
  /* API Subsystem Session Close */


  /* Send Receive  Session Close */


  /* State Machine Session Close */

  return H245_ERROR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245deb.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				   
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245deb.c  $						
 *  $Revision:   1.5  $							
 *  $Modtime:   14 Oct 1996 13:25:50  $					
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245deb.c_v  $	
 * 
 *    Rev 1.5   14 Oct 1996 14:01:32   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.4   14 Oct 1996 12:08:08   EHOWARDX
 * Backed out Mike's changes.
 * 
 *    Rev 1.3   01 Oct 1996 11:05:54   MANDREWS
 * Removed ISR_ trace statements for operation under Windows NT.
 * 
 *    Rev 1.2   01 Jul 1996 16:13:34   EHOWARDX
 * Changed to use wvsprintf to stop bounds checker from complaining
 * about too many arguements.
 * 
 *    Rev 1.1   28 May 1996 14:25:46   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:20   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.12.1.3   09 May 1996 19:40:10   EHOWARDX
 * Changed trace to append linefeeds so trace string need not include them.
 * 
 *    Rev 1.13   29 Apr 1996 12:54:48   EHOWARDX
 * Added timestamps and instance-specific short name.
 * 
 *    Rev 1.12.1.2   25 Apr 1996 20:05:08   EHOWARDX
 * Changed mapping between H.245 trace level and ISRDBG32 trace level.
 * 
 *    Rev 1.12.1.1   15 Apr 1996 15:16:16   unknown
 * Updated.
 * 
 *    Rev 1.12.1.0   02 Apr 1996 15:34:02   EHOWARDX
 * Changed to use ISRDBG32 if not _IA_SPOX_.
 * 
 *    Rev 1.12   01 Apr 1996 08:47:30   cjutzi
 * 
 * - fixed NDEBUG build problem
 * 
 *    Rev 1.11   18 Mar 1996 14:59:00   cjutzi
 * 
 * - fixed and verified ring zero tracking.. 
 * 
 *    Rev 1.10   18 Mar 1996 13:40:32   cjutzi
 * - fixed spox trace
 * 
 *    Rev 1.9   15 Mar 1996 16:07:44   DABROWN1
 * 
 * SYS_printf format changes
 * 
 *    Rev 1.8   13 Mar 1996 14:09:08   cjutzi
 * 
 * - added ASSERT Printout to the trace when it occurs.. 
 * 
 *    Rev 1.7   13 Mar 1996 09:46:00   dabrown1
 * 
 * modified Sys__printf to SYS_printf for Ring0
 * 
 *    Rev 1.6   11 Mar 1996 14:27:46   cjutzi
 * 
 * - addes sys_printf for SPOX 
 * - removed oildebug et.al..
 * 
 *    Rev 1.5   06 Mar 1996 12:10:40   cjutzi
 * - put ifndef SPOX around check_pdu, and dump_pdu..
 * 
 *    Rev 1.4   05 Mar 1996 16:49:46   cjutzi
 * - removed check_pdu from dump_pdu
 * 
 *    Rev 1.3   29 Feb 1996 08:22:04   cjutzi
 * - added pdu check constraints.. and (start but not complete.. )
 *   pdu tracing.. (tbd when Init includes print function )
 * 
 *    Rev 1.2   21 Feb 1996 12:14:20   EHOWARDX
 * 
 * Changed TraceLevel to DWORD.
 * 
 *    Rev 1.1   15 Feb 1996 14:42:20   cjutzi
 * - fixed the inst/Trace stuff.. 
 * 
 *    Rev 1.0   13 Feb 1996 15:00:42   DABROWN1
 * Initial revision.
 * 
 *    Rev 1.4   09 Feb 1996 15:45:08   cjutzi
 * - added h245trace
 * - added h245Assert
 *  $Ident$
 *
 *****************************************************************************/
#undef UNICODE
#ifndef STRICT 
#define STRICT 
#endif 
/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <memory.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


#include "h245asn1.h"
#include "isrg.h"
#include "h245com.h"
#include <stdio.h>

#if defined(DBG)

DWORD g_dwH245DbgLevel = 0;
BOOL  g_fH245DbgInitialized = FALSE;

void H245DbgInit() {

#define H323_REGKEY_ROOT \
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\H323TSP")

#define H323_REGVAL_DEBUGLEVEL \
    TEXT("DebugLevel")

#define H323_REGVAL_H245DEBUGLEVEL \
    TEXT("H245DebugLevel")

    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    LPSTR pszValue;
    LPSTR pszKey = H323_REGKEY_ROOT;

    // only call this once
    g_fH245DbgInitialized = TRUE;

    // open registry subkey
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus != ERROR_SUCCESS) {
        return; // bail...
    }
    
    // initialize values
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // retrieve h245 debug level
    pszValue = H323_REGVAL_H245DEBUGLEVEL;

    // query for registry value
    lStatus = RegQueryValueEx(
                hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // initialize values
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // retrieve tsp debug level
        pszValue = H323_REGVAL_DEBUGLEVEL;

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );
    }

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // update debug level
        g_dwH245DbgLevel = dwValue;
    }
}

/*****************************************************************************
 *									      
 * TYPE:	Global System
 *									      
 * PROCEDURE: 	H245TRACE 
 *
 * DESCRIPTION:	
 *
 *		Trace function for H245
 *		
 *		INPUT:
 *			inst   - dwInst
 *			level  - qualify trace level
 *			format - printf/sprintf string format 1-N parameters
 *
 * 			Trace Level Definitions:
 * 
 *			0 - no trace on at all
 *			1 - only errors
 *			2 - PDU tracking
 *			3 - PDU and SendReceive packet tracing
 *			4 - Main API Module level tracing
 *			5 - Inter Module level tracing #1
 *			6 - Inter Module level tracing #2
 *			7 - <Undefined>
 *			8 - <Undefined>
 *			9 - <Undefined>
 *			10- and above.. free for all, you call .. i'll haul
 *
 * RETURN:								      
 *		N/A
 *									      
 *****************************************************************************/


void H245TRACE (DWORD dwInst, DWORD dwLevel, LPSTR pszFormat, ...)
{
#define DEBUG_FORMAT_HEADER     "H245 "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "

#define MAXDBG_STRLEN        512

    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAXDBG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // make sure initialized
    if (g_fH245DbgInitialized == FALSE) {
        H245DbgInit();
    }

    // validate debug log level
    if (dwLevel > g_dwH245DbgLevel) {
        return; // bail...
    }

    // retrieve local time
    GetLocalTime(&SystemTime);

    // add component header to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_HEADER
                       );

    // add timestamp to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_TIMESTAMP,
                       SystemTime.wHour,
                       SystemTime.wMinute,
                       SystemTime.wSecond,
                       SystemTime.wMilliseconds
                       );

    // add thread id to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_THREADID,
                       GetCurrentThreadId()
                       );

    // point at first argument
    va_start(Args, pszFormat);

    // determine number of bytes left in buffer
    nLengthRemaining = sizeof(szDebugMessage) - nLength;

    // add user specified debug message
    _vsnprintf(&szDebugMessage[nLength],
               nLengthRemaining,
               pszFormat,
               Args
               );

    // release pointer
    va_end(Args);

    // output message to specified sink
    OutputDebugString(szDebugMessage);
    OutputDebugString("\n");

} // H245TRACE()

/*****************************************************************************
 *									      
 * TYPE:	Global System
 *									      
 * PROCEDURE: 	H245Assert
 *
 * DESCRIPTION:	
 *	
 *		H245Assert that will only pop up a dialog box, does not
 *		stop system with fault.
 *
 *		FOR WINDOWS ONLY (Ring3 development) at this point
 *
 *		SEE MACRO - H245ASSERT defined in h245com.h
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/

void H245Assert (LPSTR file, int line, LPSTR expression)
{
#if !defined(SPOX) && defined(H324)
  int i;

  char Buffer[256];

  for (
       i=strlen(file);
       ((i) && (file[i] != '\\'));
       i--);
       wsprintf(Buffer,"file:%s line:%d expression:%s",&file[i],line,expression);
  MessageBox(GetTopWindow(NULL), Buffer, "H245 ASSERT", MB_OK);
#endif
  H245TRACE(0,1,"<<< ASSERT >>> file:%s line:%d expression:%s",file,line,expression);
}

void H245Panic (LPSTR file, int line)
{
#if !defined(SPOX) && defined(H324)
  int i;

  char Buffer[256];

  for (
       i=strlen(file);
       ((i) && (file[i] != '\\'));
       i--);
       wsprintf(Buffer,"file:%s line:%d",&file[i],line);
  MessageBox(GetTopWindow(NULL), Buffer, "H245 PANIC", MB_OK);
#endif
  H245TRACE(0,1,"<<< PANIC >>> file:%s line:%d",file,line);
}

/*****************************************************************************
 *									      
 * TYPE:	GLOBAL
 *									      
 * PROCEDURE: 	check_pdu
 *
 * DESCRIPTION:	
 *									      
 * RETURN:								      
 *									      
 *****************************************************************************/
int check_pdu (struct InstanceStruct *pInstance, MltmdSystmCntrlMssg *p_pdu)
{
  int error = H245_ERROR_OK;
  return error;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245asn.c ===
/******************************************************************************
 *
 *  File:  h245send.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245asn.c  $
 *  $Revision:   1.4  $
 *  $Modtime:   17 Jan 1997 14:31:20  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\h245asn.c_v  $
 *
 *    Rev 1.4   24 Jan 1997 19:41:36   SBELL1
 * upgraded to oss 4.2
 *
 *    Rev 1.3   07 Jun 1996 18:14:32   EHOWARDX
 *
 * Changed H245_malloc, H245_realloc, and H245_free to macros.
 * Added _H245_malloc, _H245_realloc, and _H245_free for use by OSS ASN.1.
 *
 *    Rev 1.2   28 May 1996 14:25:22   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   21 May 1996 13:39:28   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.0   09 May 1996 21:06:20   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.5.1.2   09 May 1996 19:34:44   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.5.1.1   25 Apr 1996 21:27:10   EHOWARDX
 * Changed to use h245Instance->p_ossWorld instead of bAsnInitialized.
 *
 *    Rev 1.5.1.0   23 Apr 1996 14:42:44   EHOWARDX
 * Added check for ASN.1 initialized.
 *
 *    Rev 1.5   13 Mar 1996 11:33:06   DABROWN1
 * Enable logging for ring0
 *
 *    Rev 1.4   07 Mar 1996 23:20:14   dabrown1
 *
 * Modifications required for ring0/ring3 compatiblity
 *
 *    Rev 1.3   06 Mar 1996 13:13:52   DABROWN1
 *
 * added #define _DLL for SPOX build
 *
 *    Rev 1.2   23 Feb 1996 13:54:42   DABROWN1
 *
 * added tracing functions
 *
 *    Rev 1.1   21 Feb 1996 16:52:08   DABROWN1
 *
 * Removed call to h245_asn1free, now uses generic h245_free
 *
 *    Rev 1.0   09 Feb 1996 17:35:20   cjutzi
 * Initial revision.
 *
 *****************************************************************************/

#define STRICT

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>
#include <memory.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef  _IA_SPOX_
# define _DLL
#endif //_IA_SPOX_

#include "h245asn1.h"
#include "h245sys.x"
#include "sendrcv.x"
#include "h245com.h"

/***********************/
/*    ASN1 INCLUDES    */
/***********************/

/***********************/
/*     S/R GLOBALS     */
/***********************/
#ifdef  _IA_SPOX_
# define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
# define HWND    void*
# undef _DLL
#endif //_IA_SPOX



int initializeASN1(ASN1_CODER_INFO *pWorld)
{
    int         nResult;

    nResult = H245_InitWorld(pWorld);

    return (MAKELONG(nResult, 0));
}

int terminateASN1(ASN1_CODER_INFO *pWorld)
{
    H245_TermWorld(pWorld);

    return 0;
}


// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

int H245_InitModule(void)
{
    H245_Module_Startup();
    return (H245_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int H245_TermModule(void)
{
    H245_Module_Cleanup();
    return ASN1_SUCCESS;
}

int H245_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H245_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H245_Module,         // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        H245ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H245_Module,         // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        H245ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        H245_TermWorld(pWorld);
    }

    return rc;
}

int H245_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H245_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                //  buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        H245ASSERT(ASN1_SUCCESS == rc);
        if (fBufferSupplied)
        {
            H245ASSERT(pBuf->value == pEncInfo->buf);
            H245ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
        H245ASSERT(FALSE);
    }
    return rc;
}

int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        H245ASSERT(ASN1_SUCCESS == rc);
        H245ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
        H245ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#include <windows.h>
#include "h245.h"

ASN1module_t H245_Module = NULL;

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Enc_H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced(ASN1encoding_t enc, H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_headerCRC(ASN1encoding_t enc, H223AnnexAReconfiguration_headerCRC *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_headerFEC(ASN1encoding_t enc, H223AnnexAReconfiguration_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_headerInterleaving(ASN1encoding_t enc, H223AnnexAReconfiguration_headerInterleaving *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_synchFlagLength(ASN1encoding_t enc, H223AnnexAReconfiguration_synchFlagLength *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val);
static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_AL3MParameters_arqType(ASN1encoding_t enc, AL3MParameters_arqType *val);
static int ASN1CALL ASN1Enc_AL3MParameters_crcLength(ASN1encoding_t enc, AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_AL1MParameters_numberOfRetransmissions(ASN1encoding_t enc, AL1MParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Enc_AL1MParameters_arqType(ASN1encoding_t enc, AL1MParameters_arqType *val);
static int ASN1CALL ASN1Enc_AL1MParameters_crcLength(ASN1encoding_t enc, AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val);
static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Enc_H223AnnexACapability_h223AnnexAMultiplexTableCapability(ASN1encoding_t enc, H223AnnexACapability_h223AnnexAMultiplexTableCapability *val);
static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val);
static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val);
static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val);
static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val);
static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val);
static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val);
static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_H223AnnexACapability(ASN1encoding_t enc, H223AnnexACapability *val);
static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val);
static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val);
static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val);
static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val);
static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val);
static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val);
static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val);
static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val);
static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val);
static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val);
static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val);
static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val);
static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val);
static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val);
static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val);
static int ASN1CALL ASN1Enc_AL1MParameters(ASN1encoding_t enc, AL1MParameters *val);
static int ASN1CALL ASN1Enc_AL3MParameters(ASN1encoding_t enc, AL3MParameters *val);
static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val);
static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val);
static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val);
static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val);
static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val);
static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration(ASN1encoding_t enc, H223AnnexAReconfiguration *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfigurationAck(ASN1encoding_t enc, H223AnnexAReconfigurationAck *val);
static int ASN1CALL ASN1Enc_H223AnnexAReconfigurationReject(ASN1encoding_t enc, H223AnnexAReconfigurationReject *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val);
static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val);
static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val);
static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val);
static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val);
static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val);
static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val);
static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val);
static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val);
static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val);
static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val);
static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val);
static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val);
static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val);
static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val);
static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val);
static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val);
static int ASN1CALL ASN1Enc_H223AnnexAModeParameters_adaptationLayertype(ASN1encoding_t enc, H223AnnexAModeParameters_adaptationLayertype *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_H223AnnexALogicalChannelParameters_adaptationLayertype(ASN1encoding_t enc, H223AnnexALogicalChannelParameters_adaptationLayertype *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val);
static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val);
static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_H223AnnexALogicalChannelParameters(ASN1encoding_t enc, H223AnnexALogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val);
static int ASN1CALL ASN1Enc_H223AnnexAModeParameters(ASN1encoding_t enc, H223AnnexAModeParameters *val);
static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val);
static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val);
static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val);
static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val);
static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val);
static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val);
static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Dec_H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced(ASN1decoding_t dec, H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_headerCRC(ASN1decoding_t dec, H223AnnexAReconfiguration_headerCRC *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_headerFEC(ASN1decoding_t dec, H223AnnexAReconfiguration_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_headerInterleaving(ASN1decoding_t dec, H223AnnexAReconfiguration_headerInterleaving *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_synchFlagLength(ASN1decoding_t dec, H223AnnexAReconfiguration_synchFlagLength *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val);
static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_AL3MParameters_arqType(ASN1decoding_t dec, AL3MParameters_arqType *val);
static int ASN1CALL ASN1Dec_AL3MParameters_crcLength(ASN1decoding_t dec, AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_AL1MParameters_numberOfRetransmissions(ASN1decoding_t dec, AL1MParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Dec_AL1MParameters_arqType(ASN1decoding_t dec, AL1MParameters_arqType *val);
static int ASN1CALL ASN1Dec_AL1MParameters_crcLength(ASN1decoding_t dec, AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val);
static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Dec_H223AnnexACapability_h223AnnexAMultiplexTableCapability(ASN1decoding_t dec, H223AnnexACapability_h223AnnexAMultiplexTableCapability *val);
static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val);
static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val);
static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val);
static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val);
static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val);
static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val);
static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_H223AnnexACapability(ASN1decoding_t dec, H223AnnexACapability *val);
static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val);
static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val);
static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val);
static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val);
static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val);
static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val);
static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val);
static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val);
static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val);
static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val);
static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val);
static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val);
static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val);
static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val);
static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val);
static int ASN1CALL ASN1Dec_AL1MParameters(ASN1decoding_t dec, AL1MParameters *val);
static int ASN1CALL ASN1Dec_AL3MParameters(ASN1decoding_t dec, AL3MParameters *val);
static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val);
static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val);
static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val);
static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val);
static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val);
static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration(ASN1decoding_t dec, H223AnnexAReconfiguration *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfigurationAck(ASN1decoding_t dec, H223AnnexAReconfigurationAck *val);
static int ASN1CALL ASN1Dec_H223AnnexAReconfigurationReject(ASN1decoding_t dec, H223AnnexAReconfigurationReject *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val);
static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val);
static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val);
static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val);
static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val);
static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val);
static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val);
static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val);
static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val);
static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val);
static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val);
static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val);
static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val);
static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val);
static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val);
static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val);
static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val);
static int ASN1CALL ASN1Dec_H223AnnexAModeParameters_adaptationLayertype(ASN1decoding_t dec, H223AnnexAModeParameters_adaptationLayertype *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_H223AnnexALogicalChannelParameters_adaptationLayertype(ASN1decoding_t dec, H223AnnexALogicalChannelParameters_adaptationLayertype *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val);
static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val);
static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_H223AnnexALogicalChannelParameters(ASN1decoding_t dec, H223AnnexALogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val);
static int ASN1CALL ASN1Dec_H223AnnexAModeParameters(ASN1decoding_t dec, H223AnnexAModeParameters *val);
static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val);
static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val);
static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val);
static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val);
static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val);
static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val);
static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val);
static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val);
static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val);
static void ASN1CALL ASN1Free_H222Capability(H222Capability *val);
static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val);
static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val);
static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val);
static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val);
static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val);
static void ASN1CALL ASN1Free_RequestMode(RequestMode *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val);
static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val);
static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val);
static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val);
static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val);
static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val);
static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val);
static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val);
static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val);
static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val);
static void ASN1CALL ASN1Free_VideoMode(VideoMode *val);
static void ASN1CALL ASN1Free_AudioMode(AudioMode *val);
static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val);
static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val);
static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val);
static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val);
static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val);
static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val);
static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val);
static void ASN1CALL ASN1Free_H223AnnexAModeParameters_adaptationLayertype(H223AnnexAModeParameters_adaptationLayertype *val);
static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val);
static void ASN1CALL ASN1Free_H223AnnexALogicalChannelParameters_adaptationLayertype(H223AnnexALogicalChannelParameters_adaptationLayertype *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val);
static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val);
static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val);
static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val);
static void ASN1CALL ASN1Free_DataType(DataType *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_H223AnnexALogicalChannelParameters(H223AnnexALogicalChannelParameters *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val);
static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val);
static void ASN1CALL ASN1Free_H223AnnexAModeParameters(H223AnnexAModeParameters *val);
static void ASN1CALL ASN1Free_DataMode(DataMode *val);
static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val);
static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val);
static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val);
static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_Capability(Capability *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_ModeElement(ModeElement *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val);
static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val);
static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val);
static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val);
static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val);
static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val);
static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val);
static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_MultimediaSystemControlMessage,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_MultimediaSystemControlMessage,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_MultimediaSystemControlMessage,
};
static const ULONG sizetab[1] = {
    SIZE_H245_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H245_Module_Startup(void)
{
    H245_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35343268);
}

void ASN1CALL H245_Module_Cleanup(void)
{
    ASN1_CloseModule(H245_Module);
    H245_Module = NULL;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lowerBitRate - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->higherBitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lowerBitRate))
	return 0;
    (val)->lowerBitRate += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->higherBitRate))
	return 0;
    (val)->higherBitRate += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.highestEntryNumberProcessed - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.highestEntryNumberProcessed))
	    return 0;
	(val)->u.highestEntryNumberProcessed += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.singleBitRate - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(enc, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.singleBitRate))
	    return 0;
	(val)->u.singleBitRate += 1;
	break;
    case 2:
	if (!ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(dec, &(val)->u.rangeOfBitRates))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->maximumNestingDepth - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumElementListSize - 2))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumSubElementListSize - 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->maximumNestingDepth))
	return 0;
    (val)->maximumNestingDepth += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumElementListSize))
	return 0;
    (val)->maximumElementListSize += 2;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumSubElementListSize))
	return 0;
    (val)->maximumSubElementListSize += 2;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced(ASN1encoding_t enc, H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->maximumNestingDepth - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumElementListSize - 2))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumSubElementListSize - 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced(ASN1decoding_t dec, H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->maximumNestingDepth))
	return 0;
    (val)->maximumNestingDepth += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumElementListSize))
	return 0;
    (val)->maximumElementListSize += 2;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumSubElementListSize))
	return 0;
    (val)->maximumSubElementListSize += 2;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->windowSize - 1))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(enc, &(val)->recovery))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->windowSize))
	return 0;
    (val)->windowSize += 1;
    if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(dec, &(val)->recovery))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, 1, 65535, 16);
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, sizeof(**val), 1, 65535, 16);
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->firstGOB))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	    return 0;
	(val)->firstMB += 1;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PEREncBitVal(enc, 5, (val)->firstGOB))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->numberOfGOBs - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PERDecU16Val(dec, 5, &(val)->firstGOB))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->numberOfGOBs))
	return 0;
    (val)->numberOfGOBs += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->temporalReference))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
	return 0;
    (val)->firstMB += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
	return 0;
    (val)->numberOfMBs += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->temporalReference))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(enc, &(val)->clockRecovery))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(enc, &(val)->errorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(dec, &(val)->clockRecovery))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(dec, &(val)->errorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NewATMVCIndication_aal_aal1(enc, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NewATMVCIndication_aal_aal5(enc, &(val)->u.aal5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NewATMVCIndication_aal_aal1(dec, &(val)->u.aal1))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NewATMVCIndication_aal_aal5(dec, &(val)->u.aal5))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ee, &(val)->u.videoNotDecodedMBs))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(dd, &(val)->u.videoNotDecodedMBs))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(enc, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ee, &(val)->u.videoFastUpdateMB))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(dec, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(dd, &(val)->u.videoFastUpdateMB))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.maximumBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.maximumBitRate))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	(val)->u.logicalChannelNumber += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(enc, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(enc, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiplexCapability))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(dec, &(val)->capabilityTableEntryNumbers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(dec, &(val)->capabilityDescriptorNumbers))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(&(val)->capabilityTableEntryNumbers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(&(val)->capabilityDescriptorNumbers);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_headerCRC(ASN1encoding_t enc, H223AnnexAReconfiguration_headerCRC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_headerCRC(ASN1decoding_t dec, H223AnnexAReconfiguration_headerCRC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_headerFEC(ASN1encoding_t enc, H223AnnexAReconfiguration_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_headerFEC(ASN1decoding_t dec, H223AnnexAReconfiguration_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_headerInterleaving(ASN1encoding_t enc, H223AnnexAReconfiguration_headerInterleaving *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_headerInterleaving(ASN1decoding_t dec, H223AnnexAReconfiguration_headerInterleaving *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration_synchFlagLength(ASN1encoding_t enc, H223AnnexAReconfiguration_synchFlagLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration_synchFlagLength(ASN1decoding_t dec, H223AnnexAReconfiguration_synchFlagLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
	    return 0;
	(val)->u.mediaLoop += 1;
	break;
    case 3:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
	    return 0;
	(val)->u.logicalChannelLoop += 1;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AL3MParameters_arqType(ASN1encoding_t enc, AL3MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AL3MParameters_arqType(ASN1decoding_t dec, AL3MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AL3MParameters_crcLength(ASN1encoding_t enc, AL3MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AL3MParameters_crcLength(ASN1decoding_t dec, AL3MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AL1MParameters_numberOfRetransmissions(ASN1encoding_t enc, AL1MParameters_numberOfRetransmissions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AL1MParameters_numberOfRetransmissions(ASN1decoding_t dec, AL1MParameters_numberOfRetransmissions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.finite))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AL1MParameters_arqType(ASN1encoding_t enc, AL1MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AL1MParameters_arqType(ASN1decoding_t dec, AL1MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AL1MParameters_crcLength(ASN1encoding_t enc, AL1MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AL1MParameters_crcLength(ASN1decoding_t dec, AL1MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.finite - 1))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.finite))
	    return 0;
	(val)->u.finite += 1;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MultiplexElement_type_subElementList(enc, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MultiplexElement_type_subElementList(dec, &(val)->u.subElementList))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_MultiplexElement_type_subElementList(&(val)->u.subElementList);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(enc, &(val)->routing))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(enc, &(val)->route))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(dec, &(val)->routing))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(dec, &(val)->route))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val)
{
    if (val) {
	ASN1Free_UnicastAddress_iPSourceRouteAddress_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM(enc, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM(dec, &(val)->u.eRM))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static ASN1stringtableentry_t Q2931Address_address_internationalNumber_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t Q2931Address_address_internationalNumber_StringTable = {
    2, Q2931Address_address_internationalNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.internationalNumber);
	if (!ASN1PEREncBitVal(enc, 4, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 4, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->qcif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->cif))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Seq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Prog))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoLow))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedProg))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighProg))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->qcif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->cif))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x100))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x200))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Seq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Prog))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoLow))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedProg))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighSeq))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighProg))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexACapability_h223AnnexAMultiplexTableCapability(ASN1encoding_t enc, H223AnnexACapability_h223AnnexAMultiplexTableCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced(enc, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexACapability_h223AnnexAMultiplexTableCapability(ASN1decoding_t dec, H223AnnexACapability_h223AnnexAMultiplexTableCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced(dec, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->decentralizedConferenceMC))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedConferenceMC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->decentralizedConferenceMC))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(enc, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(dec, &(val)->u.enhanced))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->srtsClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullErrorCorrection))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->longInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->shortInterleaver))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->srtsClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->adaptiveClockRecovery))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullErrorCorrection))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->longInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->shortInterleaver))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->errorCorrectionOnly))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233IVResponseTime))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233IVResponseTime))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(enc, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(dec, &(val)->u.tableEntryCapacityExceeded))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NonStandardIdentifier_h221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NonStandardIdentifier_h221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalType))
	return 0;
    l = ASN1uint32_uoctets((val)->statusDeterminationNumber);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->statusDeterminationNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalType))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->statusDeterminationNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationAck_decision(enc, &(val)->decision))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationAck_decision(dec, &(val)->decision))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MasterSlaveDeterminationReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MasterSlaveDeterminationReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeader))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeader))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(enc, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->capabilityDescriptorNumber))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(dec, &(val)->simultaneousCapabilities))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CapabilityDescriptor_simultaneousCapabilities(&(val)->simultaneousCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PEREncUnsignedShort(enc, ((val)->value)[i] - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1PERDecUnsignedShort(dec, &((val)->value)[i]))
	    return 0;
	((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_TerminalCapabilitySetReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_TerminalCapabilitySetReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->numberOfVCs - 1))
	return 0;
    if (!ASN1Enc_H222Capability_vcCapability(enc, &(val)->vcCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->numberOfVCs))
	return 0;
    (val)->numberOfVCs += 1;
    if (!ASN1Dec_H222Capability_vcCapability(dec, &(val)->vcCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability(H222Capability *val)
{
    if (val) {
	ASN1Free_H222Capability_vcCapability(&(val)->vcCapability);
    }
}

static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_VCCapability_aal1(enc, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VCCapability_aal5(enc, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->transportStream))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->programStream))
	return 0;
    if (!ASN1Enc_VCCapability_availableBitRates(enc, &(val)->availableBitRates))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_VCCapability_aal1(dec, &(val)->aal1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VCCapability_aal5(dec, &(val)->aal5))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->transportStream))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->programStream))
	return 0;
    if (!ASN1Dec_VCCapability_availableBitRates(dec, &(val)->availableBitRates))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->transportWithI_frames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumDelayJitter))
	return 0;
    if (!ASN1Enc_H223Capability_h223MultiplexTableCapability(enc, &(val)->h223MultiplexTableCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->transportWithI_frames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumDelayJitter))
	return 0;
    if (!ASN1Dec_H223Capability_h223MultiplexTableCapability(dec, &(val)->h223MultiplexTableCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rejCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->mREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc8bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc16bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc32bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uihCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numOfDLCS - 2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopBackTestCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401Capability - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->maxWindowSizeCapability - 1))
	return 0;
    if (!ASN1Enc_V75Capability(enc, &(val)->v75Capability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rejCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->mREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc8bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc16bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc32bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uihCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numOfDLCS))
	return 0;
    (val)->numOfDLCS += 2;
    if (!ASN1PERDecBoolean(dec, &(val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->loopBackTestCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401Capability))
	return 0;
    (val)->n401Capability += 1;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->maxWindowSizeCapability))
	return 0;
    (val)->maxWindowSizeCapability += 1;
    if (!ASN1Dec_V75Capability(dec, &(val)->v75Capability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h261aVideoPacketization))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h261aVideoPacketization))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multicastCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiUniCastConference))
	return 0;
    if (!ASN1Enc_MultipointCapability_mediaDistributionCapability(enc, &(val)->mediaDistributionCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multicastCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiUniCastConference))
	return 0;
    if (!ASN1Dec_MultipointCapability_mediaDistributionCapability(dec, &(val)->mediaDistributionCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val)
{
    if (val) {
	ASN1Free_MultipointCapability_mediaDistributionCapability(&(val)->mediaDistributionCapability);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedControl))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedAudio))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedVideo))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MediaDistributionCapability_centralizedData(enc, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_MediaDistributionCapability_distributedData(enc, &(val)->distributedData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedControl))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedAudio))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedVideo))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedVideo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MediaDistributionCapability_centralizedData(dec, &(val)->centralizedData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_MediaDistributionCapability_distributedData(dec, &(val)->distributedData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaDistributionCapability_centralizedData(&(val)->centralizedData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_MediaDistributionCapability_distributedData(&(val)->distributedData);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AnnexACapability(ASN1encoding_t enc, H223AnnexACapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->transferWithI_frames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2M))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3M))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL3MSDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumDelayJitter))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reconfigurationCapability))
	return 0;
    if (!ASN1Enc_H223AnnexACapability_h223AnnexAMultiplexTableCapability(enc, &(val)->h223AnnexAMultiplexTableCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexACapability(ASN1decoding_t dec, H223AnnexACapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->transferWithI_frames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2M))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3M))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL2MSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL3MSDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumDelayJitter))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reconfigurationCapability))
	return 0;
    if (!ASN1Dec_H223AnnexACapability_h223AnnexAMultiplexTableCapability(dec, &(val)->h223AnnexAMultiplexTableCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->cifMPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 2, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatHL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatLL))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SpatialatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatML))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatH_14))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatHL))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->hrd_B);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->hrd_B))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->bppMaxKb))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowSqcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowQcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif4MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif16MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->hrd_B))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->bppMaxKb))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowSqcifMPI))
		return 0;
	    (val)->slowSqcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowQcifMPI))
		return 0;
	    (val)->slowQcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCifMPI))
		return 0;
	    (val)->slowCifMPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif4MPI))
		return 0;
	    (val)->slowCif4MPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif16MPI))
		return 0;
	    (val)->slowCif16MPI += 1;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling16k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling22k05))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling24k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels2_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels3_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels3_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling16k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling22k05))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling24k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels2_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels3_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels3_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_T84Profile_t84Restricted(enc, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_T84Profile_t84Restricted(dec, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConferenceCapability_nonStandardData(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->chairControlCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConferenceCapability_nonStandardData(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->chairControlCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConferenceCapability_nonStandardData(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Q2931Address_address(enc, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Q2931Address_address(dec, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val)
{
    if (val) {
	ASN1Free_Q2931Address_address(&(val)->address);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeaderPresent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeaderPresent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->streamDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->streamDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->programDescriptors);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->streamDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannelReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannelReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_CloseLogicalChannel_source(enc, &(val)->source))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_CloseLogicalChannel_source(dec, &(val)->source))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_RequestChannelCloseReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_RequestChannelCloseReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(enc, &(val)->multiplexEntryDescriptors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(dec, &(val)->multiplexEntryDescriptors))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(&(val)->multiplexEntryDescriptors);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val)
{
    if (!ASN1Enc_MultiplexElement_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MultiplexElement_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val)
{
    if (!ASN1Dec_MultiplexElement_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MultiplexElement_repeatCount(dec, &(val)->repeatCount))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val)
{
    if (val) {
	ASN1Free_MultiplexElement_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_MultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_MultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntry_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntry_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntry_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryAck_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryAck_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryAck_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryRelease_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestMode_requestedModes(enc, &(val)->requestedModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestMode_requestedModes(dec, &(val)->requestedModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode(RequestMode *val)
{
    if (val) {
	ASN1Free_RequestMode_requestedModes(&(val)->requestedModes);
    }
}

static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeAck_response(enc, &(val)->response))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeAck_response(dec, &(val)->response))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AL1MParameters(ASN1encoding_t enc, AL1MParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_AL1MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->targetCodeRate))
	return 0;
    if (!ASN1Enc_AL1MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1Enc_AL1MParameters_numberOfRetransmissions(enc, &(val)->numberOfRetransmissions))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AL1MParameters(ASN1decoding_t dec, AL1MParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_AL1MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->targetCodeRate))
	return 0;
    if (!ASN1Dec_AL1MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1Dec_AL1MParameters_numberOfRetransmissions(dec, &(val)->numberOfRetransmissions))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AL3MParameters(ASN1encoding_t enc, AL3MParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_AL3MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->targetCodeRate))
	return 0;
    if (!ASN1Enc_AL3MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->numberOfRetransmissions))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AL3MParameters(ASN1decoding_t dec, AL3MParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_AL3MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->targetCodeRate))
	return 0;
    if (!ASN1Dec_AL3MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->numberOfRetransmissions))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H261VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H261VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_H262VideoMode_profileAndLevel(enc, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_H262VideoMode_profileAndLevel(dec, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1Enc_H263VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopRequest_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopRequest_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopAck_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopAck_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CommunicationModeCommand_communicationModeTable(enc, &(val)->communicationModeTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CommunicationModeCommand_communicationModeTable(dec, &(val)->communicationModeTable))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val)
{
    if (val) {
	ASN1Free_CommunicationModeCommand_communicationModeTable(&(val)->communicationModeTable);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CommunicationModeResponse_communicationModeTable(enc, &(val)->u.communicationModeTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CommunicationModeResponse_communicationModeTable(dec, &(val)->u.communicationModeTable))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CommunicationModeResponse_communicationModeTable(&(val)->u.communicationModeTable);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->mcuNumber))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->mcuNumber))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfiguration(ASN1encoding_t enc, H223AnnexAReconfiguration *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AnnexAReconfiguration_synchFlagLength(enc, &(val)->synchFlagLength))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->informationFieldSize))
	return 0;
    if (!ASN1Enc_H223AnnexAReconfiguration_headerInterleaving(enc, &(val)->headerInterleaving))
	return 0;
    if (!ASN1Enc_H223AnnexAReconfiguration_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1Enc_H223AnnexAReconfiguration_headerCRC(enc, &(val)->headerCRC))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->headerCounterForward))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfiguration(ASN1decoding_t dec, H223AnnexAReconfiguration *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AnnexAReconfiguration_synchFlagLength(dec, &(val)->synchFlagLength))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->informationFieldSize))
	return 0;
    if (!ASN1Dec_H223AnnexAReconfiguration_headerInterleaving(dec, &(val)->headerInterleaving))
	return 0;
    if (!ASN1Dec_H223AnnexAReconfiguration_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1Dec_H223AnnexAReconfiguration_headerCRC(dec, &(val)->headerCRC))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->headerCounterForward))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfigurationAck(ASN1encoding_t enc, H223AnnexAReconfigurationAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfigurationAck(ASN1decoding_t dec, H223AnnexAReconfigurationAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexAReconfigurationReject(ASN1encoding_t enc, H223AnnexAReconfigurationReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAReconfigurationReject(ASN1decoding_t dec, H223AnnexAReconfigurationReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest(enc, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest(dec, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_SendTerminalCapabilitySet_specificRequest(&(val)->u.specificRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_FlowControlCommand_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1Enc_FlowControlCommand_restriction(enc, &(val)->restriction))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_FlowControlCommand_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1Dec_FlowControlCommand_restriction(dec, &(val)->restriction))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.cancelBroadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.cancelBroadcastMyLogicalChannel))
	    return 0;
	(val)->u.cancelBroadcastMyLogicalChannel += 1;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousCommand_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_FunctionNotSupported_cause(enc, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->returnedFunction))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_FunctionNotSupported_cause(dec, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->returnedFunction))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->returnedFunction);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 4, (val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 4, &(val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousIndication_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousIndication_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_JitterIndication_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->additionalDecoderBuffer);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->additionalDecoderBuffer))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_JitterIndication_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->additionalDecoderBuffer))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->skew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->skew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumSkew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumSkew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->vendor);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal(enc, &(val)->aal))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_multiplex(enc, &(val)->multiplex))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal(dec, &(val)->aal))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_multiplex(dec, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (*val)->count - 2))
	return 0;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(*val)->count))
	return 0;
    (*val)->count += 2;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (*val)->count; i++) {
	    ASN1Free_MultiplexElement(&(*val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TerminalLabel(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_TerminalLabel(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_MultiplexElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Enc_MediaDistributionCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Dec_MediaDistributionCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val)
{
    if (val) {
	ASN1Free_MediaDistributionCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H222Capability_vcCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val)
{
    if (!ASN1Enc_VCCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H222Capability_vcCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val)
{
    if (!ASN1Dec_VCCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H222Capability_vcCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Enc_AlternativeCapabilitySet(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Dec_AlternativeCapabilitySet(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (val) {
	ASN1Free_AlternativeCapabilitySet(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CapabilityDescriptor(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CapabilityDescriptor(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_CapabilityDescriptor(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Enc_H2250Capability_mcCapability(enc, &(val)->mcCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Enc_MediaPacketizationCapability(enc, &(val)->mediaPacketizationCapability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Dec_H2250Capability_mcCapability(dec, &(val)->mcCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Dec_MediaPacketizationCapability(dec, &(val)->mediaPacketizationCapability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val)
{
    if (val) {
	ASN1Free_MultipointCapability(&(val)->receiveMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->transmitMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->receiveAndTransmitMultipointCapability);
    }
}

static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoCapability(enc, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoCapability(enc, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoCapability(enc, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoCapability(enc, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoCapability(dec, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoCapability(dec, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoCapability(dec, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoCapability(dec, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw64k - 1))
	    return 0;
	break;
    case 3:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw56k - 1))
	    return 0;
	break;
    case 4:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw64k - 1))
	    return 0;
	break;
    case 5:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw56k - 1))
	    return 0;
	break;
    case 6:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_64k - 1))
	    return 0;
	break;
    case 7:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_56k - 1))
	    return 0;
	break;
    case 8:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_48k - 1))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_AudioCapability_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g728 - 1))
	    return 0;
	break;
    case 11:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729 - 1))
	    return 0;
	break;
    case 12:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729AnnexA - 1))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioCapability(enc, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioCapability(enc, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwSilenceSuppression - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw64k))
	    return 0;
	(val)->u.g711Alaw64k += 1;
	break;
    case 3:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw56k))
	    return 0;
	(val)->u.g711Alaw56k += 1;
	break;
    case 4:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw64k))
	    return 0;
	(val)->u.g711Ulaw64k += 1;
	break;
    case 5:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw56k))
	    return 0;
	(val)->u.g711Ulaw56k += 1;
	break;
    case 6:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_64k))
	    return 0;
	(val)->u.g722_64k += 1;
	break;
    case 7:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_56k))
	    return 0;
	(val)->u.g722_56k += 1;
	break;
    case 8:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_48k))
	    return 0;
	(val)->u.g722_48k += 1;
	break;
    case 9:
	if (!ASN1Dec_AudioCapability_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g728))
	    return 0;
	(val)->u.g728 += 1;
	break;
    case 11:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729))
	    return 0;
	(val)->u.g729 += 1;
	break;
    case 12:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729AnnexA))
	    return 0;
	(val)->u.g729AnnexA += 1;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioCapability(dec, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioCapability(dec, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwSilenceSuppression))
	    return 0;
	(val)->u.g729AnnexAwSilenceSuppression += 1;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CRCLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->n401 - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopbackTestProcedure))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CRCLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->n401))
	return 0;
    (val)->n401 += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->loopbackTestProcedure))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_UnicastAddress_iPXAddress(enc, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_UnicastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress(enc, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_UnicastAddress_iPXAddress(dec, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_UnicastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress(dec, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_UnicastAddress_iPXAddress(&(val)->u.iPXAddress);
	    break;
	case 3:
	    ASN1Free_UnicastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 4:
	    break;
	case 5:
	    ASN1Free_UnicastAddress_iPSourceRouteAddress(&(val)->u.iPSourceRouteAddress);
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_MulticastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_MulticastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_MulticastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexEntryDescriptor_elementList(enc, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexEntryDescriptor_elementList(dec, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexEntryDescriptor_elementList(&(val)->elementList);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryReject_entryNumbers(&(val)->entryNumbers);
	ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoMode(enc, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoMode(enc, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoMode(enc, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoMode(enc, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoMode(dec, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoMode(dec, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoMode(dec, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoMode(dec, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoMode(VideoMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AudioMode_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioMode(enc, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioMode(enc, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AudioMode_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioMode(dec, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioMode(dec, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioMode(AudioMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceResponse_mCTerminalIDResponse(enc, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceResponse_terminalIDResponse(enc, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceResponse_conferenceIDResponse(enc, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceResponse_passwordResponse(enc, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceResponse_terminalListResponse(enc, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Enc_ConferenceResponse_makeMeChairResponse(enc, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceResponse_mCTerminalIDResponse(dec, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceResponse_terminalIDResponse(dec, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceResponse_conferenceIDResponse(dec, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceResponse_passwordResponse(dec, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceResponse_terminalListResponse(dec, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Dec_ConferenceResponse_makeMeChairResponse(dec, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceResponse_mCTerminalIDResponse(&(val)->u.mCTerminalIDResponse);
	    break;
	case 2:
	    ASN1Free_ConferenceResponse_terminalIDResponse(&(val)->u.terminalIDResponse);
	    break;
	case 3:
	    ASN1Free_ConferenceResponse_conferenceIDResponse(&(val)->u.conferenceIDResponse);
	    break;
	case 4:
	    ASN1Free_ConferenceResponse_passwordResponse(&(val)->u.passwordResponse);
	    break;
	case 5:
	    ASN1Free_ConferenceResponse_terminalListResponse(&(val)->u.terminalListResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EndSessionCommand_gstnOptions(enc, &(val)->u.gstnOptions))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EndSessionCommand_gstnOptions(dec, &(val)->u.gstnOptions))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.alphanumeric);
	if (!ASN1PEREncFragmentedCharString(enc, t, (val)->u.alphanumeric, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->u.alphanumeric, 8))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1ztcharstring_free((val)->u.alphanumeric);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->t84Protocol))
	return 0;
    if (!ASN1Enc_T84Profile(enc, &(val)->t84Profile))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->t84Protocol))
	return 0;
    if (!ASN1Dec_T84Profile(dec, &(val)->t84Profile))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->t84Protocol);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->associatedAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataMode_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataMode_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataProtocolCapability(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataMode_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223AnnexAModeParameters_adaptationLayertype(ASN1encoding_t enc, H223AnnexAModeParameters_adaptationLayertype *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AL1MParameters(enc, &(val)->u.al1M))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_AL3MParameters(enc, &(val)->u.al3M))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAModeParameters_adaptationLayertype(ASN1decoding_t dec, H223AnnexAModeParameters_adaptationLayertype *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AL1MParameters(dec, &(val)->u.al1M))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_AL3MParameters(dec, &(val)->u.al3M))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223AnnexAModeParameters_adaptationLayertype(H223AnnexAModeParameters_adaptationLayertype *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223ModeParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223ModeParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, 1, 15, 4);
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Enc_MultiplexEntryDescriptor(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, sizeof(**val), 1, 15, 4);
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Dec_MultiplexEntryDescriptor(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (val) {
	ASN1Free_MultiplexEntryDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223AnnexALogicalChannelParameters_adaptationLayertype(ASN1encoding_t enc, H223AnnexALogicalChannelParameters_adaptationLayertype *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AL1MParameters(enc, &(val)->u.al1M))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_AL3MParameters(enc, &(val)->u.al3M))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexALogicalChannelParameters_adaptationLayertype(ASN1decoding_t dec, H223AnnexALogicalChannelParameters_adaptationLayertype *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AL1MParameters(dec, &(val)->u.al1M))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_AL3MParameters(dec, &(val)->u.al3M))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223AnnexALogicalChannelParameters_adaptationLayertype(H223AnnexALogicalChannelParameters_adaptationLayertype *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConferenceCapability_nonStandardData_ElmFn);
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConferenceCapability_nonStandardData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConferenceCapability_nonStandardData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability_application_t84(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability_application_t84(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability_application_t84(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->nonStandardData);
    }
}

static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H222Capability(enc, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223Capability(enc, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_V76Capability(enc, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250Capability(ee, &(val)->u.h2250Capability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AnnexACapability(ee, &(val)->u.h223AnnexACapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H222Capability(dec, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223Capability(dec, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_V76Capability(dec, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250Capability(dd, &(val)->u.h2250Capability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AnnexACapability(dd, &(val)->u.h223AnnexACapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_H222Capability(&(val)->u.h222Capability);
	    break;
	case 5:
	    ASN1Free_H2250Capability(&(val)->u.h2250Capability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataApplicationCapability_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->maxBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataApplicationCapability_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val)
{
    if (val) {
	ASN1Free_DataApplicationCapability_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionData))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataType(DataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 4:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	case 6:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_H223LogicalChannelParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_V76HDLCParameters(enc, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_suspendResume(enc, &(val)->suspendResume))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uIH))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode(enc, &(val)->mode))
	return 0;
    if (!ASN1Enc_V75Parameters(enc, &(val)->v75Parameters))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_V76HDLCParameters(dec, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_suspendResume(dec, &(val)->suspendResume))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uIH))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_mode(dec, &(val)->mode))
	return 0;
    if (!ASN1Dec_V75Parameters(dec, &(val)->v75Parameters))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress(enc, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress(enc, &(val)->u.multicastAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress(dec, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress(dec, &(val)->u.multicastAddress))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress(&(val)->u.unicastAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress(&(val)->u.multicastAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223AnnexALogicalChannelParameters(ASN1encoding_t enc, H223AnnexALogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AnnexALogicalChannelParameters_adaptationLayertype(enc, &(val)->adaptationLayertype))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexALogicalChannelParameters(ASN1decoding_t dec, H223AnnexALogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AnnexALogicalChannelParameters_adaptationLayertype(dec, &(val)->adaptationLayertype))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223AnnexALogicalChannelParameters(H223AnnexALogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_H223AnnexALogicalChannelParameters_adaptationLayertype(&(val)->adaptationLayertype);
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	    return 0;
	(val)->sessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelAckParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_TransportAddress(&(val)->mediaControlChannel);
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223ModeParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223ModeParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val)
{
    if (val) {
	ASN1Free_H223ModeParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_H223AnnexAModeParameters(ASN1encoding_t enc, H223AnnexAModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AnnexAModeParameters_adaptationLayertype(enc, &(val)->adaptationLayertype))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexAModeParameters(ASN1decoding_t dec, H223AnnexAModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AnnexAModeParameters_adaptationLayertype(dec, &(val)->adaptationLayertype))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223AnnexAModeParameters(H223AnnexAModeParameters *val)
{
    if (val) {
	ASN1Free_H223AnnexAModeParameters_adaptationLayertype(&(val)->adaptationLayertype);
    }
}

static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataMode_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->bitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataMode_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode(DataMode *val)
{
    if (val) {
	ASN1Free_DataMode_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EncryptionCommand_encryptionAlgorithmID(enc, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EncryptionCommand_encryptionAlgorithmID(dec, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.encryptionSE);
	    break;
	case 3:
	    ASN1Free_EncryptionCommand_encryptionAlgorithmID(&(val)->u.encryptionAlgorithmID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->signalAddress))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->signalAddress))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val)
{
    if (val) {
	ASN1Free_TransportAddress(&(val)->signalAddress);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 2:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 3:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionMode))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	case 5:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H2250LogicalChannelAckParameters(enc, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H2250LogicalChannelAckParameters(dec, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H2250LogicalChannelAckParameters(&(val)->u.h2250LogicalChannelAckParameters);
	    break;
	}
    }
}

static ASN1stringtableentry_t NetworkAccessParameters_networkAddress_e164Address_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t NetworkAccessParameters_networkAddress_e164Address_StringTable = {
    4, NetworkAccessParameters_networkAddress_e164Address_StringTableEntries
};

static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Q2931Address(enc, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.e164Address);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TransportAddress(enc, &(val)->u.localAreaAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Q2931Address(dec, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TransportAddress(dec, &(val)->u.localAreaAddress))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Q2931Address(&(val)->u.q2931Address);
	    break;
	case 2:
	    break;
	case 3:
	    ASN1Free_TransportAddress(&(val)->u.localAreaAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_distributedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_distributedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_distributedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_centralizedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MaintenanceLoopOffCommand(enc, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SendTerminalCapabilitySet(enc, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_EncryptionCommand(enc, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_FlowControlCommand(enc, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EndSessionCommand(enc, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand(enc, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeCommand(ee, &(val)->u.communicationModeCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCommand(ee, &(val)->u.conferenceCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MaintenanceLoopOffCommand(dec, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SendTerminalCapabilitySet(dec, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_EncryptionCommand(dec, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_FlowControlCommand(dec, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EndSessionCommand(dec, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand(dec, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeCommand(dd, &(val)->u.communicationModeCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCommand(dd, &(val)->u.conferenceCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SendTerminalCapabilitySet(&(val)->u.sendTerminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_EncryptionCommand(&(val)->u.encryptionCommand);
	    break;
	case 6:
	    ASN1Free_EndSessionCommand(&(val)->u.endSessionCommand);
	    break;
	case 8:
	    ASN1Free_CommunicationModeCommand(&(val)->u.communicationModeCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexCapability(enc, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityTable(enc, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(enc, &(val)->capabilityDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexCapability(dec, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityTable(dec, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(dec, &(val)->capabilityDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexCapability(&(val)->multiplexCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TerminalCapabilitySet_capabilityTable(&(val)->capabilityTable);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TerminalCapabilitySet_capabilityDescriptors(&(val)->capabilityDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PEREncBoolean(enc, (val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_Capability_h233EncryptionReceiveCapability(enc, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCapability(ee, &(val)->u.conferenceCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecBoolean(dec, &(val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_Capability_h233EncryptionReceiveCapability(dec, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCapability(dd, &(val)->u.conferenceCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Capability(Capability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.receiveVideoCapability);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.transmitVideoCapability);
	    break;
	case 4:
	    ASN1Free_VideoCapability(&(val)->u.receiveAndTransmitVideoCapability);
	    break;
	case 5:
	    ASN1Free_AudioCapability(&(val)->u.receiveAudioCapability);
	    break;
	case 6:
	    ASN1Free_AudioCapability(&(val)->u.transmitAudioCapability);
	    break;
	case 7:
	    ASN1Free_AudioCapability(&(val)->u.receiveAndTransmitAudioCapability);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveDataApplicationCapability);
	    break;
	case 9:
	    ASN1Free_DataApplicationCapability(&(val)->u.transmitDataApplicationCapability);
	    break;
	case 10:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveAndTransmitDataApplicationCapability);
	    break;
	case 13:
	    ASN1Free_ConferenceCapability(&(val)->u.conferenceCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NetworkAccessParameters_distribution(enc, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Enc_NetworkAccessParameters_networkAddress(enc, &(val)->networkAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NetworkAccessParameters_distribution(dec, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Dec_NetworkAccessParameters_networkAddress(dec, &(val)->networkAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val)
{
    if (val) {
	ASN1Free_NetworkAccessParameters_networkAddress(&(val)->networkAddress);
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(enc, &(val)->mediaPacketization))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(dec, &(val)->mediaPacketization))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TransportAddress(&(val)->mediaControlChannel);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ModeElement_type(enc, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H223ModeParameters(enc, &(val)->h223ModeParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_V76ModeParameters(ee, &(val)->v76ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_H223AnnexAModeParameters(ee, &(val)->h223AnnexAModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ModeElement_type(dec, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H223ModeParameters(dec, &(val)->h223ModeParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_V76ModeParameters(dd, &(val)->v76ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_H223AnnexAModeParameters(dd, &(val)->h223AnnexAModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement(ModeElement *val)
{
    if (val) {
	ASN1Free_ModeElement_type(&(val)->type);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H223ModeParameters(&(val)->h223ModeParameters);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H223AnnexAModeParameters(&(val)->h223AnnexAModeParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CommunicationModeTableEntry_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->sessionDescription).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->sessionDescription).length, ((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Enc_CommunicationModeTableEntry_dataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CommunicationModeTableEntry_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    (val)->sessionID += 1;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->sessionDescription).length))
	return 0;
    ((val)->sessionDescription).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->sessionDescription).length, &((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Dec_CommunicationModeTableEntry_dataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CommunicationModeTableEntry_nonStandard(&(val)->nonStandard);
	}
	ASN1char16string_free(&(val)->sessionDescription);
	ASN1Free_CommunicationModeTableEntry_dataType(&(val)->dataType);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TransportAddress(&(val)->mediaControlChannel);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AnnexALogicalChannelParameters(ee, &(val)->u.h223AnnexALogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AnnexALogicalChannelParameters(dd, &(val)->u.h223AnnexALogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 4:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	case 5:
	    ASN1Free_H223AnnexALogicalChannelParameters(&(val)->u.h223AnnexALogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AnnexALogicalChannelParameters(ee, &(val)->u.h223AnnexALogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AnnexALogicalChannelParameters(dd, &(val)->u.h223AnnexALogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 3:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	case 4:
	    ASN1Free_H223AnnexALogicalChannelParameters(&(val)->u.h223AnnexALogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->reverseLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->reverseLogicalChannelNumber))
	return 0;
    (val)->reverseLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
}

static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->capabilityTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Capability(enc, &(val)->capability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->capabilityTableEntryNumber))
	return 0;
    (val)->capabilityTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_Capability(dec, &(val)->capability))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Capability(&(val)->capability);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(enc, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(dec, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(&(val)->forwardLogicalChannelParameters);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ee, &(val)->forwardMultiplexAckParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(dd, &(val)->forwardMultiplexAckParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(&(val)->forwardMultiplexAckParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ModeElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_ModeElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_ModeElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestMode_requestedModes_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val)
{
    if (!ASN1Enc_ModeDescription(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestMode_requestedModes_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val)
{
    if (!ASN1Dec_ModeDescription(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestMode_requestedModes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val)
{
    if (val) {
	ASN1Free_ModeDescription(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Enc_CapabilityTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Dec_CapabilityTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val)
{
    if (val) {
	ASN1Free_CapabilityTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDetermination(enc, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalCapabilitySet(enc, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_OpenLogicalChannel(enc, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_CloseLogicalChannel(enc, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelClose(enc, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySend(enc, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntry(enc, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestMode(enc, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RoundTripDelayRequest(enc, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MaintenanceLoopRequest(enc, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeRequest(ee, &(val)->u.communicationModeRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest(ee, &(val)->u.conferenceRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AnnexAReconfiguration(ee, &(val)->u.h223AnnexAReconfiguration))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDetermination(dec, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalCapabilitySet(dec, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_OpenLogicalChannel(dec, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_CloseLogicalChannel(dec, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelClose(dec, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySend(dec, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntry(dec, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestMode(dec, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RoundTripDelayRequest(dec, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MaintenanceLoopRequest(dec, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeRequest(dd, &(val)->u.communicationModeRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest(dd, &(val)->u.conferenceRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AnnexAReconfiguration(dd, &(val)->u.h223AnnexAReconfiguration))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_TerminalCapabilitySet(&(val)->u.terminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_OpenLogicalChannel(&(val)->u.openLogicalChannel);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySend(&(val)->u.multiplexEntrySend);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntry(&(val)->u.requestMultiplexEntry);
	    break;
	case 9:
	    ASN1Free_RequestMode(&(val)->u.requestMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDeterminationAck(enc, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationReject(enc, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetAck(enc, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalCapabilitySetReject(enc, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_OpenLogicalChannelAck(enc, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_OpenLogicalChannelReject(enc, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CloseLogicalChannelAck(enc, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestChannelCloseAck(enc, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RequestChannelCloseReject(enc, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MultiplexEntrySendAck(enc, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_MultiplexEntrySendReject(enc, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_RequestMultiplexEntryAck(enc, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_RequestMultiplexEntryReject(enc, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_RequestModeAck(enc, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_RequestModeReject(enc, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_RoundTripDelayResponse(enc, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_MaintenanceLoopAck(enc, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_MaintenanceLoopReject(enc, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeResponse(ee, &(val)->u.communicationModeResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 21:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse(ee, &(val)->u.conferenceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 22:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AnnexAReconfigurationAck(ee, &(val)->u.h223AnnexAReconfigurationAck))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 23:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AnnexAReconfigurationReject(ee, &(val)->u.h223AnnexAReconfigurationReject))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDeterminationAck(dec, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationReject(dec, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetAck(dec, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalCapabilitySetReject(dec, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_OpenLogicalChannelAck(dec, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_OpenLogicalChannelReject(dec, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CloseLogicalChannelAck(dec, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestChannelCloseAck(dec, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RequestChannelCloseReject(dec, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MultiplexEntrySendAck(dec, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_MultiplexEntrySendReject(dec, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_RequestMultiplexEntryAck(dec, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_RequestMultiplexEntryReject(dec, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_RequestModeAck(dec, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_RequestModeReject(dec, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_RoundTripDelayResponse(dec, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_MaintenanceLoopAck(dec, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_MaintenanceLoopReject(dec, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeResponse(dd, &(val)->u.communicationModeResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 21:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse(dd, &(val)->u.conferenceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 22:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AnnexAReconfigurationAck(dd, &(val)->u.h223AnnexAReconfigurationAck))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 23:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H223AnnexAReconfigurationReject(dd, &(val)->u.h223AnnexAReconfigurationReject))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 6:
	    ASN1Free_OpenLogicalChannelAck(&(val)->u.openLogicalChannelAck);
	    break;
	case 11:
	    ASN1Free_MultiplexEntrySendAck(&(val)->u.multiplexEntrySendAck);
	    break;
	case 12:
	    ASN1Free_MultiplexEntrySendReject(&(val)->u.multiplexEntrySendReject);
	    break;
	case 13:
	    ASN1Free_RequestMultiplexEntryAck(&(val)->u.requestMultiplexEntryAck);
	    break;
	case 14:
	    ASN1Free_RequestMultiplexEntryReject(&(val)->u.requestMultiplexEntryReject);
	    break;
	case 20:
	    ASN1Free_CommunicationModeResponse(&(val)->u.communicationModeResponse);
	    break;
	case 21:
	    ASN1Free_ConferenceResponse(&(val)->u.conferenceResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_FunctionNotUnderstood(enc, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationRelease(enc, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetRelease(enc, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_OpenLogicalChannelConfirm(enc, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelCloseRelease(enc, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySendRelease(enc, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntryRelease(enc, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestModeRelease(enc, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_MiscellaneousIndication(enc, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_JitterIndication(enc, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_H223SkewIndication(enc, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_NewATMVCIndication(enc, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_UserInputIndication(enc, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250MaximumSkewIndication(ee, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MCLocationIndication(ee, &(val)->u.mcLocationIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceIndication(ee, &(val)->u.conferenceIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VendorIdentification(ee, &(val)->u.vendorIdentification))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FunctionNotSupported(ee, &(val)->u.functionNotSupported))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_FunctionNotUnderstood(dec, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationRelease(dec, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetRelease(dec, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_OpenLogicalChannelConfirm(dec, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelCloseRelease(dec, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySendRelease(dec, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntryRelease(dec, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestModeRelease(dec, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_MiscellaneousIndication(dec, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_JitterIndication(dec, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_H223SkewIndication(dec, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_NewATMVCIndication(dec, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_UserInputIndication(dec, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_H2250MaximumSkewIndication(dd, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_MCLocationIndication(dd, &(val)->u.mcLocationIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceIndication(dd, &(val)->u.conferenceIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VendorIdentification(dd, &(val)->u.vendorIdentification))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_FunctionNotSupported(dd, &(val)->u.functionNotSupported))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_FunctionNotUnderstood(&(val)->u.functionNotUnderstood);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySendRelease(&(val)->u.multiplexEntrySendRelease);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntryRelease(&(val)->u.requestMultiplexEntryRelease);
	    break;
	case 14:
	    ASN1Free_UserInputIndication(&(val)->u.userInput);
	    break;
	case 16:
	    ASN1Free_MCLocationIndication(&(val)->u.mcLocationIndication);
	    break;
	case 18:
	    ASN1Free_VendorIdentification(&(val)->u.vendorIdentification);
	    break;
	case 19:
	    ASN1Free_FunctionNotSupported(&(val)->u.functionNotSupported);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_IndicationMessage(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_IndicationMessage(dec, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	case 4:
	    ASN1Free_IndicationMessage(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245main.c ===
//---------------------------------------------------------------------------
//  File:  H245Main.C
//
//  This file contains the DLL's entry and exit points.
//
// INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//---------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef _IA_SPOX_
# include <common.x>
# include <oil.x>
#else
# pragma warning( disable : 4100 4115 4201 4214 4514 )
# include <windows.h>
#endif //_IA_SPOX_

#define H245DLL_EXPORT
#include "h245com.h"
#include "provider.h"

#ifdef _IA_SPOX_

/*****************************************************************************
*
* Name:         DllMain
*
* Description:  This procedure is called by the SPOX module loader, when
*               someone loads, attaches, detaches, or unloads the DLL
*               module.
*
* Return:      If successful, TRUE is returned, otherwise FALSE is returned.
*
* Arguments:   hLibrary           - Library module handle for this module
*              dwReason           - Reason that the module entry point was
*                                   called. It can be load, unload, attach or
*				    detach
*
******************************************************************************/

Bool _stdcall DllMain( SML_Library  hLibrary,
                       LgUns       dwReason,
                       LgUns       dwDummy   )
{
  int ii;
  extern DWORD TraceLevel;

  switch(dwReason)
    {
    case SML_LOAD:	// DLL being loaded
      
      SYS_printf("Loading Teladdin H245 DLL... %s - %s\n", __DATE__, __TIME__);
      SYS_printf("Relocation address: %x\n",DllMain);
      SYS_printf("TraceLevel address: %x\n",&TraceLevel);
      break;
      
    case SML_UNLOAD:	// DLL being unloaded
      SYS_printf("\nH245: UNLOAD Teladdin H245 DLL at %x...\n",DllMain);
      
      for (ii=0;ii<MAXINST;ii++)
	{
	  if (InstanceTbl[ii])
	    {
	      H245TRACE(ii,10,"H245 DLLMain: Calling H245ShutDown(%d)\n",ii);
	      H245ShutDown(ii);
	    }
	}
      break;
    }
  
  return(TRUE);
}

#else 

#if defined(_DEBUG) && defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
LPInteropLogger H245Logger = NULL;
#endif  // (PCS_COMPLIANCE)
//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
//	Inputs:
//    			hInstDll	: DLL instance.
//    			fdwReason	: Reason the main function is called.
//    			lpReserved	: Reserved.
//
//	Return: 	TRUE		: OK
//			FALSE		: Error, DLL won't load
//---------------------------------------------------------------------------
BOOL WINAPI H245DllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
  extern CRITICAL_SECTION         TimerLock;
  extern CRITICAL_SECTION         InstanceCreateLock;
  extern CRITICAL_SECTION         InstanceLocks[MAXINST];
  extern struct InstanceStruct *  InstanceTable[MAXINST];
  register unsigned int           uIndex;

  switch (fdwReason)
  {
  case DLL_PROCESS_ATTACH:
    /* initialize memory resources */
    H245TRACE(0, 10, "***** Loading H.245 DLL");
#if defined(_DEBUG) && defined(PCS_COMPLIANCE)
    H245Logger = InteropLoad(H245LOG_PROTOCOL);
#endif  // (PCS_COMPLIANCE)

    __try {

        InitializeCriticalSectionAndSpinCount(&TimerLock,H323_SPIN_COUNT);
        InitializeCriticalSectionAndSpinCount(&InstanceCreateLock,H323_SPIN_COUNT);
        for (uIndex = 0; uIndex < MAXINST; ++uIndex)
        {
          InitializeCriticalSection(&InstanceLocks[uIndex]);
        }

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // failure
        return FALSE;
    }
   break;

  case DLL_PROCESS_DETACH:
    /* release memory resources */
    H245TRACE(0, 10, "***** Unloading H.245 DLL");
    H245TRACE(0, 10, "***** fProcessDetach = TRUE");

    for (uIndex = 0; uIndex < MAXINST; ++uIndex)
    {
      if (InstanceTable[uIndex])
      {
        register struct InstanceStruct *pInstance = InstanceLock(uIndex + 1);
        if (pInstance)
        {
          H245TRACE(uIndex+1,10,"DLLMain: Calling H245ShutDown");
          H245ShutDown(uIndex + 1);
		  InstanceUnlock_ProcessDetach(pInstance,TRUE);
        }
      }
      H245ASSERT(InstanceTable[uIndex] == NULL);
      DeleteCriticalSection(&InstanceLocks[uIndex]);
    }
    DeleteCriticalSection(&InstanceCreateLock);
    DeleteCriticalSection(&TimerLock);
#if defined(_DEBUG) && defined(PCS_COMPLIANCE)
    if (H245Logger)
    {
      H245TRACE(0, 4, "Unloading interop logger");
      InteropUnload(H245Logger);
      H245Logger = NULL;
    }
#endif  // (PCS_COMPLIANCE)
    break;
  }

  return TRUE;
}

#endif //_IA_SPOX_
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245send.c ===
/******************************************************************************
 *
 *  File:  h245send.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245send.c  $
 *  $Revision:   1.8  $
 *  $Modtime:   22 Jul 1996 17:24:18  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245send.c_v  $
 * 
 *    Rev 1.8   22 Jul 1996 17:33:28   EHOWARDX
 * Updated to latest Interop API.
 * 
 *    Rev 1.7   05 Jun 1996 17:14:30   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 * 
 *    Rev 1.6   04 Jun 1996 18:18:18   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 * 
 *    Rev 1.5   30 May 1996 23:39:12   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.4   28 May 1996 14:25:18   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.3   21 May 1996 13:40:48   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 *
 *    Rev 1.2   20 May 1996 14:35:14   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.1   17 May 1996 16:19:46   EHOWARDX
 * Changed sendPDU to return an error if link layer send fails.
 * (Probably should define a new error code for this...)
 *
 *    Rev 1.0   09 May 1996 21:06:26   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.11.1.4   09 May 1996 19:34:46   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 *
 *    Rev 1.11.1.3   25 Apr 1996 21:27:14   EHOWARDX
 * Changed to use pInstance->p_ossWorld instead of bAsnInitialized.
 *
 *    Rev 1.11.1.2   23 Apr 1996 14:44:34   EHOWARDX
 * Updated.
 *
 *    Rev 1.11.1.1   15 Apr 1996 15:12:04   EHOWARDX
 * Updated.
 *
 *    Rev 1.11.1.0   26 Mar 1996 19:14:46   EHOWARDX
 *
 * Commented out hTraceFile for H.323
 *
 *    Rev 1.11   21 Mar 1996 17:20:40   dabrown1
 * - put in test1/2 trace fdwrite
 * .
 *
 * .
 *
 *
 *
 *
 *    Rev 1.10   13 Mar 1996 11:31:14   DABROWN1
 *
 * Enable logging for ring0
 *
 *    Rev 1.9   11 Mar 1996 15:32:06   DABROWN1
 *
 * Defined/Undefined _DLL for _IA_SPOX_ environment
 *
 *    Rev 1.8   06 Mar 1996 13:11:44   DABROWN1
 *
 * enable flush buffers
 *
 *    Rev 1.7   02 Mar 1996 22:10:26   DABROWN1
 * updated to new H245_free
 *
 *    Rev 1.6   01 Mar 1996 17:25:14   DABROWN1
 *
 * moved oss 'world' context to h245instance
 * delete buffer returned in sendcomplete instead of what was held in context
 *
 *    Rev 1.5   28 Feb 1996 14:52:18   DABROWN1
 * Put oss errors in range of SR (10000)
 *
 *    Rev 1.4   23 Feb 1996 13:56:30   DABROWN1
 *
 * added H245TRACE / H245ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 16:52:52   DABROWN1
 *
 * correct pointer passed to SRP for transmits
 *
 *    Rev 1.2   21 Feb 1996 10:50:42   EHOWARDX
 * Got rid of unreferenced local variable.
 *
 *    Rev 1.1   21 Feb 1996 08:24:20   DABROWN1
 * allocate/deallocate send buffers per message.  Enable sendComplete functiot
 *
 *    Rev 1.0   09 Feb 1996 17:37:42   cjutzi
 * Initial revision.
 *
 *****************************************************************************/
#define STRICT

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>
#include <memory.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif



/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef   _IA_SPOX_
#define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"

#if defined(_DEBUG) && defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
extern  LPInteropLogger H245Logger;
#endif  // (PCS_COMPLIANCE)

#ifdef   _IA_SPOX_
#undef  _DLL
#endif //_IA_SPOX_



/**************************************************************************
**  Function    : sendPDU
**  Description : Convert struct to ASN.1 PDU and forward to datalink layer
***************************************************************************/
HRESULT sendPDU(struct InstanceStruct  *pInstance,
                MltmdSystmCntrlMssg    *lp245MsgStruct)
{
    HRESULT         lError;
    ASN1_BUF        Asn1Buf;
    PBYTE           pEncoded_pdu;
    int             nRet;

#if defined(LOGGING)
    ossPrintPDU(pInstance->pWorld, MltmdSystmCntrlMssg_PDU, lp245MsgStruct);
#endif

    // Set up the oss struct for passing a pre-allocated buffer
    switch (pInstance->Configuration) {
    case H245_CONF_H324:
        // Allocate a buffer to transmit
        pEncoded_pdu = H245_malloc(pInstance->SendReceive.dwPDUSize);
        if (pEncoded_pdu == NULL) {
            H245TRACE(pInstance->dwInst, 1, "H245Send: No memory");
            return H245_ERROR_NOMEM;
        }
        Asn1Buf.value  = &pEncoded_pdu[2];
        Asn1Buf.length = pInstance->SendReceive.dwPDUSize - 4;
        break;

    case H245_CONF_H323:
        // Allocate a buffer to transmit
        pEncoded_pdu = H245_malloc(pInstance->SendReceive.dwPDUSize);
        if (pEncoded_pdu == NULL) {
            H245TRACE(pInstance->dwInst, 1, "H245Send: No memory");
            return H245_ERROR_NOMEM;
        }
        Asn1Buf.value  = pEncoded_pdu;
        Asn1Buf.length = pInstance->SendReceive.dwPDUSize;
        break;

    default:
        H245TRACE(pInstance->dwInst,
                  1,
                  "SR: Unknown Configuration %d",
                  pInstance->Configuration);
        return H245_ERROR_SUBSYS;
    }

    nRet = H245_Encode(pInstance->pWorld,
                       (void *)lp245MsgStruct,
                       MltmdSystmCntrlMssg_PDU,
                       &Asn1Buf);

    if (ASN1_SUCCEEDED(nRet))
    {
        H245TRACE(pInstance->dwInst, 3, "H245: Msg Encode Successful");

#if defined(DBG) && defined(PCS_COMPLIANCE)
        if (H245Logger)
            InteropOutput(H245Logger,
                          (BYTE FAR*)(pEncoded_pdu), 
                          (int)Asn1Buf.length, 
                          H245LOG_SENT_PDU);
#endif  // (PCS_COMPLIANCE)

        lError = pInstance->SendReceive.hLinkSendReq(pInstance->SendReceive.hLinkLayerInstance,
                                                     pEncoded_pdu,
                                                     Asn1Buf.length);
    }
    else
    {
        H245_free(pEncoded_pdu);
        lError = H245_ERROR_ASN1;
    }

    return lError;
}


/**************************************************************************
**  Function    : h245SendComplete
**  Description : Send Completion Callback routine from link layer
***************************************************************************/

# pragma warning( disable : 4100 )

void h245SendComplete(   DWORD   h245Inst,
                         HRESULT dwMessage,
                         PBYTE   pbDataBuf,
                         DWORD   dwLength)
{
    struct InstanceStruct *pInstance;

    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
        H245TRACE(h245Inst, 1, "SR: h245SendComplete - invalid instance");
        return;
    }

    // Return the buffer
    if (pbDataBuf) {
        H245_free(pbDataBuf);
    }

    switch (dwMessage) {
    case LINK_SEND_COMPLETE:
        if (pInstance->SendReceive.dwFlushMap & SHUTDOWN_PENDING) {
            H245TRACE(h245Inst, 10, "SR: Shutdown Complete");
        }
        break;
    case LINK_SEND_ABORT:
        H245TRACE(h245Inst, 10, "SR: TX Abort Buffer");
        break;
    case LINK_FLUSH_COMPLETE:
        // If we are in the process of abort, then the next and
        // last mesage out will be the endSession
        H245TRACE(h245Inst, 10, "SR: TX Flush Complete");

        // Indicate Transmit buffer flush is complete
        pInstance->SendReceive.dwFlushMap ^= DATALINK_TRANSMIT;

        // If all requested queues have been flushed, call the
        //  appropriate callback routing
        switch (pInstance->SendReceive.dwFlushMap & SHUTDOWN_MASK) {
        case 0:
            // TBD: Who is interested in callback if not in connection
            //  with shutdown?
            break;
        case SHUTDOWN_PENDING:
            // Flush buffers completed, and shutdown in progress
            //  notify the API
            H245TRACE(h245Inst, 20, "SR: SHUTDOWN CALLBACK");
            break;
        default:
            // Still waiting for buffers to be flushed. No action now
            break;
        }  // switch (pInstance->SendReceive.dwFlushMap & SHUTDOWN_MASK) {
        break;
    default:
        H245TRACE(h245Inst, 10, "SR: SendComplete");
        break;
    }
    InstanceUnlock(pInstance);
}

# pragma warning( default : 4100 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\mlse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mlse.c                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MLSE.C  $
 * $Revision:   1.4  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/MLSE.C_v  $
 * 
 *    Rev 1.4   09 Dec 1996 13:34:46   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.3   04 Jun 1996 13:57:24   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   30 May 1996 23:39:14   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.1   28 May 1996 14:25:42   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:30   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   09 May 1996 19:48:26   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.0   15 Apr 1996 10:46:58   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mlse.h"



// Out-going/In-coming MLSE states
#define MLSE_NOT_LOOPED             0   // NOT LOOPED
#define MLSE_WAIT                   1   // AWAITING RESPONSE
#define MLSE_LOOPED                 1   // LOOPED


extern unsigned int uT102;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T102ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T102ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T102Expiry);
} // T102ExpiryF()



static void BuildMaintenanceLoopOffCommand(PDU_t *pPdu)
{
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = mntnncLpOffCmmnd_chosen;
} // BuildMaintenanceLoopOffCommand()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MLSE0_LOOP_requestF - LOOP.request from API in NOT LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE0_LOOP_requestF             (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_NOT_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE0_LOOP_request:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    // Send Maintenance Loop Request PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T102
    pObject->State = MLSE_WAIT;
    FsmStartTimer(pObject, T102ExpiryF, uT102);

    return lError;
} // MLSE0_LOOP_request



/*
 *  NAME
 *      MLSE1_MaintenanceLoopAckF - MaintenanceLoopAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopAckF       (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopAck:%d", pObject->Key);

    // Reset timer T102
    FsmStopTimer(pObject);

    // Send LOOP.confirm to client
    pObject->State = MLSE_LOOPED;
    H245FsmConfirm(pPdu, H245_CONF_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopAck



/*
 *  NAME
 *      MLSE1_MaintenanceLoopRejF - MaintenanceLoopReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopRej:%d", pObject->Key);

    // Reset timer T102
    FsmStopTimer(pObject);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmConfirm(pPdu, H245_CONF_MLSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopRej



/*
 *  NAME
 *      MLSE1_OUT_RELEASE_requestF - RELEASE.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_OUT_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pObject->State = MLSE_NOT_LOOPED;
    BuildMaintenanceLoopOffCommand(pPdu);
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_OUT_RELEASE_request



/*
 *  NAME
 *      MLSE1_T102ExpiryF - timer T102 Expiry in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT MLSE1_T102ExpiryF               (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MLSE1_T102Expiry:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MLSE1_T102ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildMaintenanceLoopOffCommand(pOut);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    // Send RELEASE.indication to client
    //   SOURCE := MLSE
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmConfirm(NULL, H245_CONF_MLSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // MLSE1_T102Expiry

# pragma warning( default : 4100 )



/*
 *  NAME
 *      MLSE2_MaintenanceLoopRejF - MaintenanceLoopReject in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopRejF       (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopRej:%d", pObject->Key);

    pObject->State = MLSE_NOT_LOOPED;

#if defined(SDL_COMPLIANT)
    // Send ERROR.indication(B) to client
    // TBD
#endif

    // Send RELEASE.indication to client
    //   SOURCE := MLSE
    H245FsmConfirm(pPdu, H245_CONF_MLSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopRej



/*
 *  NAME
 *      MLSE2_OUT_RELEASE_requestF - RELEASE.request from API in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_OUT_RELEASE_requestF      (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_OUT);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE2_OUT_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopOffCommand PDU to remote peer
    pObject->State = MLSE_NOT_LOOPED;
    BuildMaintenanceLoopOffCommand(pPdu);
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE2_OUT_RELEASE_request



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MLSE0_MaintenanceLoopRequestF - MaintenanceLoopRequest received in NOT LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE0_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_NOT_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE0_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    // Send LOOP.indication to client
    pObject->State = MLSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE0_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE1_MaintenanceLoopRequestF - MaintenanceLoopRequest received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

#if defined(SDL_COMPLIANT)
    // Send RELEASE.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send LOOP.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE1_MaintenanceLoopReleaseF - MaintenanceLoopOffCommand received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_MaintenanceLoopOffCommand:%d", pObject->Key);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE1_MaintenanceLoopOffCommand



/*
 *  NAME
 *      MLSE1_LOOP_responseF - LOOP.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_LOOP_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_LOOP_response:%d", pObject->Key);

    // Send MaintenanceLoopAck PDU to remote peer
    pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice = pObject->u.mlse.wLoopType;
    switch (pObject->u.mlse.wLoopType)
    {
    case systemLoop_chosen:
        break;
    case mediaLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop          = (WORD)pObject->Key;
        break;
    case logicalChannelLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.logicalChannelLoop = (WORD)pObject->Key;
        break;
    default:
        H245TRACE(pObject->dwInst, 1, "Invalid loop type %d", pObject->u.mlse.wLoopType);
    } // switch
    pObject->State = MLSE_LOOPED;
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_LOOP_response



/*
 *  NAME
 *      MLSE1_IN_RELEASE_requestF - RELEASE.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE1_IN_RELEASE_requestF       (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MLSE1_IN_RELEASE_request:%d", pObject->Key);

    // Send MaintenanceLoopReject PDU to remote peer
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice = pObject->u.mlse.wLoopType;
    switch (pObject->u.mlse.wLoopType)
    {
    case systemLoop_chosen:
        break;
    case mediaLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop          = (WORD)pObject->Key;
        break;
    case logicalChannelLoop_chosen:
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.logicalChannelLoop = (WORD)pObject->Key;
        break;
    default:
        H245TRACE(pObject->dwInst, 1, "Invalid loop type %d", pObject->u.mlse.wLoopType);
    } // switch
    pObject->State = MLSE_NOT_LOOPED;
    return sendPDU(pObject->pInstance, pPdu);
} // MLSE1_IN_RELEASE_request



/*
 *  NAME
 *      MLSE2_MaintenanceLoopRequestF - MaintenanceLoopRequest received in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopRequest:%d", pObject->Key);

    // Save type from PDU
    pObject->u.mlse.wLoopType =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;

    pObject->State = MLSE_WAIT;

#if defined(SDL_COMPLIANT)
    // Send RELEASE.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send LOOP.indication to client
    H245FsmIndication(pPdu, H245_IND_MLSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopRequest



/*
 *  NAME
 *      MLSE2_MaintenanceLoopReleaseF - MaintenanceLoopOffCommand received in LOOPED state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MLSE2_MaintenanceLoopOffCommandF(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MLSE_IN);
    H245ASSERT(pObject->State  == MLSE_LOOPED);
    H245TRACE(pObject->dwInst, 2, "MLSE2_MaintenanceLoopOffCommand:%d", pObject->Key);

    // Send RELEASE.indication to client
    pObject->State = MLSE_NOT_LOOPED;
    H245FsmIndication(pPdu, H245_IND_MLSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MLSE2_MaintenanceLoopOffCommand
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245_sr.c ===
/******************************************************************************
 *
 *  File:  h245_sr.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245_sr.c  $
 *  $Revision:   1.10  $
 *  $Modtime:   Mar 04 1997 17:30:56  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245_sr.c_v  $
 * 
 *    Rev 1.10   Mar 04 1997 17:51:22   tomitowx
 * process detach fix
 * 
 *    Rev 1.9   11 Dec 1996 13:55:20   SBELL1
 * Changed linkLayerInit parameters
 * 
 *    Rev 1.8   14 Oct 1996 14:05:52   EHOWARDX
 * 
 * Used cast to get rid of warning.
 * 
 *    Rev 1.7   14 Oct 1996 14:01:30   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.6   23 Jul 1996 08:57:08   EHOWARDX
 * 
 * Moved H245 interop logger init/deinit from H245_SR.C (per-instance)
 * to H245MAIN.C (per-DLL). With multiple instances and a global variable,
 * per-instance init/deinit is fundamentally wrong.
 * 
 *    Rev 1.5   22 Jul 1996 17:33:44   EHOWARDX
 * Updated to latest Interop API.
 * 
 *    Rev 1.4   05 Jun 1996 17:13:50   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 * 
 *    Rev 1.3   04 Jun 1996 18:17:32   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 * 
 *    Rev 1.2   29 May 1996 15:20:20   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:32   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:28   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17.1.6   09 May 1996 19:34:40   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 * 
 *    Rev 1.17.1.5   29 Apr 1996 19:42:42   EHOWARDX
 * Commented out linkLayerFlushAll() call and synchronized with Rev 1.30.
 * 
 *    Rev 1.26   29 Apr 1996 12:53:16   EHOWARDX
 * Commented out receive thread/receive queue code.
 * 
 *    Rev 1.17.1.4   25 Apr 1996 21:27:04   EHOWARDX
 * Changed to use h245Instance->p_ossWorld instead of bAsnInitialized.
 * 
 *    Rev 1.17.1.3   23 Apr 1996 14:44:22   EHOWARDX
 * Updated.
 *
 *    Rev 1.17.1.2   15 Apr 1996 15:11:54   EHOWARDX
 * Updated.
 *
 *    Rev 1.17.1.1   26 Mar 1996 19:13:50   EHOWARDX
 *
 * Commented out hTraceFile.
 *
 *    Rev 1.17.1.0   26 Mar 1996 13:11:22   EHOWARDX
 * Branced and added H245_CONF_H323 to sendRecvInit
 *
 *    Rev 1.17   19 Mar 1996 18:09:04   helgebax
 * removed old timer code
 *
 *    Rev 1.16   13 Mar 1996 11:30:44   DABROWN1
 *
 * Enable logging for ring 0
 *
 *    Rev 1.15   11 Mar 1996 15:39:18   DABROWN1
 *
 * Define/undefine _DLL for OSS ring0
 *
 *    Rev 1.14   07 Mar 1996 23:20:56   dabrown1
 *
 * modifications required for ring0/ring3 compatiblity
 *
 *    Rev 1.13   06 Mar 1996 13:12:24   DABROWN1
 *
 * flush link layer buffers at shutdown
 *
 *    Rev 1.12   02 Mar 1996 22:11:10   DABROWN1
 *
 * updated to new h245_free
 * changed h245_bzero to memset
 *
 *    Rev 1.11   01 Mar 1996 17:24:46   DABROWN1
 *
 * moved oss 'world' context to h245instance
 *
 *    Rev 1.10   28 Feb 1996 18:45:00   EHOWARDX
 *
 * Added H245TimerStart and H245TimerStop to linkLayerInit call.
 *
 *    Rev 1.9   28 Feb 1996 15:43:52   EHOWARDX
 *
 * Removed sample code.
 * Added code to free up all events on timer queue before deallocating.
 *
 *    Rev 1.8   27 Feb 1996 13:35:10   DABROWN1
 *
 * added h245instance in datalink initialization routine
 *
 *    Rev 1.7   26 Feb 1996 18:59:34   EHOWARDX
 *
 * Added H245TimerStart and H245TimerStop functions.
 * Also added sample timer function, which should be removed later.
 *
 *    Rev 1.6   23 Feb 1996 22:17:26   EHOWARDX
 *
 * Fixed check at start of sendRecvShutdown.
 * It's an error if dwInst is greater than or equal to MAXINST, not less than!
 *
 *    Rev 1.5   23 Feb 1996 21:59:28   EHOWARDX
 *
 * winspox changes.
 *
 *    Rev 1.4   23 Feb 1996 13:55:30   DABROWN1
 *
 * added h245TRACE H245ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 15:12:36   EHOWARDX
 *
 * Forgot to replace H245ReceiveComplete with H245ReceivePost.
 *
 *    Rev 1.2   20 Feb 1996 19:14:20   EHOWARDX
 * Added in mailbox changes.
 *
 *    Rev 1.1   21 Feb 1996 08:26:28   DABROWN1
 *
 * create and free multiple receive buffers.
 * Make size of buffer dependent on protocol in use
 *
 *    Rev 1.0   09 Feb 1996 17:34:24   cjutzi
 * Initial revision.
 *
 *****************************************************************************/

#define STRICT

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>
#include <memory.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef   _IA_SPOX_
 #define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"
#include "linkapi.h"

#ifdef   _IA_SPOX_
 #undef _DLL
#endif //_IA_SPOX_


/***********************/
/*    ASN1 INCLUDES    */
/***********************/



#if defined(USE_RECEIVE_QUEUE)
DWORD
ReceiveThread(VOID *lpThreadParameter)
{
    struct InstanceStruct *pInstance = (struct InstanceStruct *)lpThreadParameter;
	RXMSG				RxMsg;
    Uns                 uTimeout;
#ifdef   _IA_SPOX_
    RESULT              bPendResult;
#else 
    Bool                bPendResult;
#endif //_IA_SPOX_

	SETTASK("H245RCVTASK0");

	if (pInstance == NULL) {
		H245PANIC();
		return SR_INVALID_CONTEXT;
	}

	// Loop until thread is ready to terminate
    pInstance->SendReceive.bReceiveThread = TRUE;
	for ( ; ; )
	{
#ifdef _IA_SPOX_
		uTimeout = OIL_WAITFOREVER;
#else
        uTimeout = SYS_FOREVER;
#endif
		// Wait for an event (or a queued callback function) to wake us up.
		// This is an alertable wait state (fAlertable == TRUE)
        pInstance->SendReceive.bReceiveThread = FALSE;
        H245TRACE(pInstance->dwInst, 2, "ReceiveThread, uTimeout = %d", uTimeout);
		RESETTASK();
#ifdef   _IA_SPOX_
		bPendResult = RIL_ReadMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, uTimeout);
#else
		bPendResult = MBX_pend(pInstance->SendReceive.pMailbox, &RxMsg, uTimeout);
#endif //_IA_SPOX_
		SETTASK("H245RCVTASK");
        H245TRACE(pInstance->pInstance->dwInst, 2, "ReceiveThread, bPendResult = %d", bPendResult);
        pInstance->SendReceive.bReceiveThread = TRUE;

		switch (RxMsg.dwMessage) {
		case EXIT_RECEIVE_THREAD:
			// Thread exiting....signal app

			TRACE("H245: Receive Thread Exiting");

#ifdef _IA_SPOX_
			RIL_SignalSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
			SEM_post(pInstance->SendReceive.hReceiveSemphore);
#endif
			RESETTASK();
			return 0;
			break;

		default:
			// Ignore timer message, which should have dwLength == 0
			if (RxMsg.dwLength)
			{
				h245ReceiveComplete(RxMsg.h245Inst,
									RxMsg.dwMessage,
									RxMsg.pbDataBuf,
									RxMsg.dwLength);
			}
			else 
			{

TRACE1("H245SEND: SendTask %d", RxMsg.dwMessage);

				h245SendComplete(RxMsg.h245Inst,
									RxMsg.dwMessage,
									RxMsg.pbDataBuf,
									RxMsg.dwLength);
			}
			break;
		} // switch

	} // for
	return 0;
} // ReceiveThread()


static void
h245ReceivePost(DWORD	h245Inst,
				DWORD	dwMessage,
				PBYTE	pbDataBuf,
				DWORD	dwLength)
{
    register struct InstanceStruct *pInstance;
	RXMSG					        RxMsg;

	// Validate the instance handle
    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
		H245TRACE(h245Inst, 1, "h245ReceivePost h245Inst Invalid");
		H245PANIC();
		return;
	}

	RxMsg.h245Inst    = h245Inst;
	RxMsg.dwMessage   = dwMessage;
	RxMsg.pbDataBuf   = pbDataBuf;
	RxMsg.dwLength    = dwLength;
#ifdef   _IA_SPOX_
	if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
	if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
		H245TRACE(h245Inst, 1, "SR: MBX POST FAIL");
		H245PANIC();
	}
    InstanceUnlock(pInstance);
} // h245ReceivePost()
#endif  // (USE_RECEIVE_QUEUE)

HRESULT
initializeLinkDllEntry
(
	struct InstanceStruct * pInstance,
	LPCTSTR		            szDLLFile
)
{

#if defined(REMOVE_FROM_TSP)

	if (!(pInstance->SendReceive.hLinkModule = LoadLibrary(szDLLFile))) {
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerInit = (PFxnlinkLayerInit)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKINITIALIZE)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkShutdown = (PFxnlinkLayerShutdown)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKSHUTDOWN)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkGetInstance = (PFxnlinkLayerGetInstance)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKGETINSTANCE)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkReceiveReq = (PFxndatalinkReceiveRequest)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKRECEIVEREQUEST)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkSendReq = (PFxndatalinkSendRequest)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKSENDREQUEST)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerFlushChannel = (PFxnlinkLayerFlushChannel)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKFLUSHCHANNEL)))		{
		return H245_ERROR_FATAL;
	}

	if (!(pInstance->SendReceive.hLinkLayerFlushAll = (PFxnlinkLayerFlushAll)
			GetProcAddress(pInstance->SendReceive.hLinkModule,
						   LINKFLUSHALL)))		{
		return H245_ERROR_FATAL;
	}

	H245TRACE(pInstance->dwInst,
			  3,
			  "SR: %s Loaded", szDLLFile);

#else  // REMOVE_FROM_TSP

    pInstance->SendReceive.hLinkModule =            NULL;
	pInstance->SendReceive.hLinkLayerInit =         linkLayerInit; 
	pInstance->SendReceive.hLinkShutdown =          linkLayerShutdown; 
	pInstance->SendReceive.hLinkGetInstance =       linkLayerGetInstance; 
	pInstance->SendReceive.hLinkReceiveReq =        datalinkReceiveRequest; 
	pInstance->SendReceive.hLinkCancelReceiveReq =  datalinkCancelReceiveRequest; 
	pInstance->SendReceive.hLinkSendReq =           datalinkSendRequest;
    
	pInstance->SendReceive.hLinkLayerFlushChannel = linkLayerFlushChannel;
	pInstance->SendReceive.hLinkLayerFlushAll =     linkLayerFlushAll;

#endif // REMOVE_FROM_TSP

	return (0);
}


#if defined(DBG) && defined(H324)
void
srInitializeLogging
(
	struct InstanceStruct *pInstance,
	BOOL	bTracingEnabled
)
{
	FILE				*hTraceFile;
	char				initTraceFile[20] = "c:\\tmp\\h2450.000";
	BOOL				bSearch = TRUE;		// search for filename

	if (pInstance == NULL) {
		H245TRACE(h245Inst, 1, "SR:Enable Log Instance Error");
		H245PANIC();
		return;
	}

	// eventually will be from registry
	pInstance->SendReceive.bLoggingEnabled = bTracingEnabled;
	
	if (pInstance->SendReceive.bLoggingEnabled) {
		// Init the logger file for Ring0/SPOX implementations.  Loop until
		//	we get the next available revision
		memcpy(pInstance->SendReceive.fTraceFile,
			   initTraceFile,
			   20);
		pInstance->SendReceive.fTraceFile[11] = ((unsigned char)pInstance->dwInst & 0xF) + 0x30;

		do {
			hTraceFile = fopen(pInstance->SendReceive.fTraceFile, "r");
			if ((hTraceFile == NULL) || ((int)hTraceFile == -1)) {
				bSearch = FALSE;
			}
			else {
				// able to open the file. close it and try the next one
				fclose(hTraceFile);

				// get the next revision number
				if (pInstance->SendReceive.fTraceFile[15] == '9') {
					pInstance->SendReceive.fTraceFile[15] = '0';
					if (pInstance->SendReceive.fTraceFile[14] == '9') {
						pInstance->SendReceive.fTraceFile[14] = '0';
						pInstance->SendReceive.fTraceFile[13]++;
					}
					else {
						pInstance->SendReceive.fTraceFile[14]++;
					}
				}
				else {
					pInstance->SendReceive.fTraceFile[15]++;
				}
			}
		}while (bSearch);

		hTraceFile = fopen(pInstance->SendReceive.fTraceFile, "wb");
		if ((hTraceFile == NULL) || ((int)hTraceFile == -1)) {
			pInstance->SendReceive.bLoggingEnabled = FALSE;
			H245TRACE(h245Inst,
					  1,
					  "SR: Trace File CREATE ERROR");
		}
		else {
		// Close the file.  Will be opened immediately before writing
		//	and closed immediately thereafter
			pInstance->SendReceive.bLoggingEnabled = TRUE;
			fclose(hTraceFile);
		}
		
	}
}
#endif  // (DBG)

HRESULT
sendRcvShutdown
(
	struct InstanceStruct *pInstance
)
{
#if defined(USE_RECEIVE_QUEUE)
	RXMSG			RxMsg;
#endif  // (USE_RECEIVE_QUEUE)
	int				i;

	if (pInstance == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Shutdown Instance Error");
		return H245_ERROR_INVALID_INST;
	}

        if (pInstance->pWorld) {

		// Shutdown the ASN.1 libraries
                terminateASN1(pInstance->pWorld);

		// Free the ASN.1 global structure
                H245_free(        pInstance->pWorld);
        pInstance->pWorld = NULL;
	}



        // Shutdown link layer
#if defined(REMOVE_FROM_TSP)
        if (pInstance->SendReceive.hLinkModule) {
#endif
		// First get all buffers back that may still be lurking
//		if (pInstance->SendReceive.hLinkLayerFlushAll) {
//			pInstance->SendReceive.hLinkLayerFlushAll(pInstance->SendReceive.hLinkLayerInstance);
//		}
		if (pInstance->SendReceive.hLinkShutdown) {
			pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
		}
#if defined(REMOVE_FROM_TSP)
        FreeLibrary(pInstance->SendReceive.hLinkModule);

		pInstance->SendReceive.hLinkModule = NULL;
	}
#endif

	// return buffers from data link layer
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		if (pInstance->SendReceive.lpRxBuffer[i]) {
		    pInstance->SendReceive.hLinkCancelReceiveReq(
                pInstance->SendReceive.hLinkLayerInstance,
				(PBYTE)pInstance->SendReceive.lpRxBuffer[i]
                );
			H245_free(pInstance->SendReceive.lpRxBuffer[i]);
			pInstance->SendReceive.lpRxBuffer[i] = NULL;
		}
	}
#if defined(USE_RECEIVE_QUEUE)
	// Terminate receive thread
	if (pInstance->SendReceive.pTaskReceive && pInstance->SendReceive.pMailbox) {

TRACE("H245: Task/Mbox Present");
		// First post a message to have it exit
		RxMsg.h245Inst    = (DWORD)pInstance;
		RxMsg.dwMessage   = EXIT_RECEIVE_THREAD;
		RxMsg.pbDataBuf   = NULL;
		RxMsg.dwLength    = 0;
#ifdef   _IA_SPOX_
		if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
		if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
			H245TRACE(h245Inst, 1, "SR: Shutdown MBX POST FAIL");
			H245PANIC();
		}

		// Wait on semaphore for receive task to exit
#ifdef _IA_SPOX_
		RIL_WaitForSemaphore(pInstance->SendReceive.hReceiveSemphore, OIL_WAITFOREVER);
#else
		SEM_pend(pInstance->SendReceive.hReceiveSemphore, SYS_FOREVER);
#endif //_IA_SPOX_
		TRACE("H245: ReceiveTask Semaphore");
		
#ifdef _IA_SPOX_
		RIL_DeleteTask(pInstance->SendReceive.pTaskReceive);
#else
		TSK_delete(pInstance->SendReceive.pTaskReceive);
#endif //_IA_SPOX_
		pInstance->SendReceive.pTaskReceive = NULL;

#ifdef   _IA_SPOX_
		RIL_DeleteSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
		SEM_delete(pInstance->SendReceive.hReceiveSemphore);
#endif //_IA_SPOX_
		pInstance->SendReceive.hReceiveSemphore = NULL;

TRACE("H245: Semaphore Delete");
    }

    // Deallocate mailbox
    if (pInstance->SendReceive.pMailbox) {
#ifdef   _IA_SPOX_
	RIL_DeleteMailbox(pInstance->SendReceive.pMailbox);
#else
	MBX_delete(pInstance->SendReceive.pMailbox);
#endif //_IA_SPOX_
        pInstance->SendReceive.pMailbox = NULL;
    }
#endif  // (USE_RECEIVE_QUEUE)

    H245TRACE(pInstance->dwInst, 3, "SR: Shutdown Complete");
    return H245_ERROR_OK;
} // sendRcvShutdown()


HRESULT
sendRcvShutdown_ProcessDetach(	struct InstanceStruct *pInstance, BOOL fProcessDetach)
{
#if defined(USE_RECEIVE_QUEUE)
	RXMSG			RxMsg;
#endif  // (USE_RECEIVE_QUEUE)
	int				i;

	if (pInstance == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Shutdown Instance Error");
		return H245_ERROR_INVALID_INST;
	}

        if (pInstance->pWorld) {

		// Shutdown the ASN.1 libraries
                terminateASN1(pInstance->pWorld);

		// Free the ASN.1 global structure
                H245_free(        pInstance->pWorld);
        pInstance->pWorld = NULL;
	}



        // Shutdown link layer
#if defined(REMOVE_FROM_TSP)
        if (pInstance->SendReceive.hLinkModule) {
#endif
		// First get all buffers back that may still be lurking
//		if (pInstance->SendReceive.hLinkLayerFlushAll) {
//			pInstance->SendReceive.hLinkLayerFlushAll(pInstance->SendReceive.hLinkLayerInstance);
//		}
		//tomitowoju@intel.com
		if(!fProcessDetach)
		{
            H245TRACE(0, 10, "***** fProcessDetach = FALSE");

			if (pInstance->SendReceive.hLinkShutdown) {
				pInstance->SendReceive.hLinkShutdown(pInstance->SendReceive.hLinkLayerInstance);
			}
		}
		//tomitowoju@intel.com

#if defined(REMOVE_FROM_TSP)
        FreeLibrary(pInstance->SendReceive.hLinkModule);

		pInstance->SendReceive.hLinkModule = NULL;
	}
#endif

	// return buffers from data link layer
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		if (pInstance->SendReceive.lpRxBuffer[i]) {
		    pInstance->SendReceive.hLinkCancelReceiveReq(
                pInstance->SendReceive.hLinkLayerInstance,
				(PBYTE)pInstance->SendReceive.lpRxBuffer[i]
                );
			H245_free(pInstance->SendReceive.lpRxBuffer[i]);
			pInstance->SendReceive.lpRxBuffer[i] = NULL;
		}
	}
#if defined(USE_RECEIVE_QUEUE)
	// Terminate receive thread
	if (pInstance->SendReceive.pTaskReceive && pInstance->SendReceive.pMailbox) {

TRACE("H245: Task/Mbox Present");
		// First post a message to have it exit
		RxMsg.h245Inst    = (DWORD)pInstance;
		RxMsg.dwMessage   = EXIT_RECEIVE_THREAD;
		RxMsg.pbDataBuf   = NULL;
		RxMsg.dwLength    = 0;
#ifdef   _IA_SPOX_
		if (RIL_WriteMailbox(pInstance->SendReceive.pMailbox, (PMBoxMessage)&RxMsg, 0) == OIL_TIMEOUT) {
#else
		if (MBX_post(pInstance->SendReceive.pMailbox, &RxMsg, 0) == FALSE) {
#endif //_IA_SPOX_
			H245TRACE(h245Inst, 1, "SR: Shutdown MBX POST FAIL");
			H245PANIC();
		}

		// Wait on semaphore for receive task to exit
#ifdef _IA_SPOX_
		RIL_WaitForSemaphore(pInstance->SendReceive.hReceiveSemphore, OIL_WAITFOREVER);
#else
		SEM_pend(pInstance->SendReceive.hReceiveSemphore, SYS_FOREVER);
#endif //_IA_SPOX_
		TRACE("H245: ReceiveTask Semaphore");
		
#ifdef _IA_SPOX_
		RIL_DeleteTask(pInstance->SendReceive.pTaskReceive);
#else
		TSK_delete(pInstance->SendReceive.pTaskReceive);
#endif //_IA_SPOX_
		pInstance->SendReceive.pTaskReceive = NULL;

#ifdef   _IA_SPOX_
		RIL_DeleteSemaphore(pInstance->SendReceive.hReceiveSemphore);
#else
		SEM_delete(pInstance->SendReceive.hReceiveSemphore);
#endif //_IA_SPOX_
		pInstance->SendReceive.hReceiveSemphore = NULL;

TRACE("H245: Semaphore Delete");
    }

    // Deallocate mailbox
    if (pInstance->SendReceive.pMailbox) {
#ifdef   _IA_SPOX_
	RIL_DeleteMailbox(pInstance->SendReceive.pMailbox);
#else
	MBX_delete(pInstance->SendReceive.pMailbox);
#endif //_IA_SPOX_
        pInstance->SendReceive.pMailbox = NULL;
    }
#endif  // (USE_RECEIVE_QUEUE)

    H245TRACE(pInstance->dwInst, 3, "SR: Shutdown Complete");
    return H245_ERROR_OK;
} // sendRcvShutdown_ProcessDetach()




HRESULT
sendRcvInit
(
	struct InstanceStruct *pInstance
)
{

	int 				rc;
#if defined(USE_RECEIVE_THREAD)
#ifdef _IA_SPOX_
	TaskAttr			srTaskAttr;
#else
    struct TSK_Attrs    srTaskAttr;
#endif //_IA_SPOX_
#endif  // (USE_RECEIVE_THREAD)
	LPTSTR				szDLLFile;
	int					i;
   
    //MULTITHREAD
    DWORD dwTmpPhysID = INVALID_PHYS_ID; 

	// Overall oss ASN.1 initialization routine.  First allocate
	//	resources for its global structure, then initialize the
	//	subsystem.
        pInstance->pWorld = (ASN1_CODER_INFO *)H245_malloc(sizeof(ASN1_CODER_INFO));
        if (pInstance->pWorld == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - No Memory");
		return H245_ERROR_NOMEM;
	}

        if (initializeASN1(pInstance->pWorld) != 0) {
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - ASN.1 Encoder/Decoder initialization failed");

		// Free the ASN.1 global structure
                H245_free(pInstance->pWorld);
        pInstance->pWorld = NULL;
		return H245_ERROR_ASN1;
	}




	// Initialization proceeding well.  Wake up the
	//	data link layers, if necessary, based on the
	//	underlying protocol.
	switch (pInstance->Configuration) {
	case H245_CONF_H324:
		// Get the DLL
		szDLLFile = (LPTSTR)SRPDLLFILE;

		// Initialize default size of PDU for SRP
		pInstance->SendReceive.dwPDUSize = LL_PDU_SIZE + 4;
		pInstance->SendReceive.dwNumRXBuffers = NUM_SRP_LL_RCV_BUFFERS;
		break;

	case H245_CONF_H323:
		// Get the DLL
		szDLLFile = (LPTSTR)H245WSDLLFILE;

		// Initialize default size of PDU
		pInstance->SendReceive.dwPDUSize = LL_PDU_SIZE;
		pInstance->SendReceive.dwNumRXBuffers = MAX_LL_BUFFERS;
		break;

	default:
		H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - Invalid configuration %d", pInstance->Configuration);
		return H245_ERROR_SUBSYS;
	}


	//	Load and Initialize Datalink layer
	if ((rc = initializeLinkDllEntry(pInstance, szDLLFile)) != 0) {
		H245TRACE(pInstance->dwInst, 1, "SR: Link Open Lib Fail %d", rc);
		return rc;
	}

        //MULTITHREAD
        //use dwTmpPhysID so PhysID doesn't change.
        //PhysID is different var for H245 than H245ws.
        //Use hLinkLayerInstance for H245ws PhysID.
	rc = pInstance->SendReceive.hLinkLayerInit(&dwTmpPhysID,
					   pInstance->dwInst,
#if defined(USE_RECEIVE_QUEUE)
					   h245ReceivePost,
					   h245SendPost);
#else   // (USE_RECEIVE_QUEUE)
					   h245ReceiveComplete,
					   h245SendComplete);
#endif  // (USE_RECEIVE_QUEUE)

	if (FAILED(rc)) {
		H245TRACE(pInstance->dwInst, 1, "SR: Link Init Fail");
		return rc;
	}
	// Get the Link layer's instance handle
	pInstance->SendReceive.hLinkLayerInstance = pInstance->SendReceive.hLinkGetInstance(dwTmpPhysID);

#if defined(USE_RECEIVE_QUEUE)
	// Allocate semaphore for task deletion procedures
#ifdef  _IA_SPOX_
    RIL_CreateSemaphore(0, &(pInstance->SendReceive.hReceiveSemphore));
#else
	pInstance->SendReceive.hReceiveSemphore = SEM_create(0, NULL);
#endif //_IA_SPOX_
	if (pInstance->SendReceive.hReceiveSemphore == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Semaphore creation failed");
		return SR_CREATE_SEM_FAIL;
	}

	// Allocate mailbox
#ifdef   _IA_SPOX_
	RIL_CreateMailbox(pInstance->dwInst,
					  ID_H245,
					  16,
					  OIL_LOCAL,
					  &(pInstance->SendReceive.pMailbox));
#else 
	pInstance->SendReceive.pMailbox = MBX_create(sizeof(RXMSG), 16, NULL);
#endif   _IA_SPOX_
	if (pInstance->SendReceive.pMailbox == NULL) {
		H245TRACE(pInstance->dwInst, 1, "SR: Mailbox creation failed");
		return SR_CREATE_MBX_FAIL;
	}

#if defined(DBG) && defined(H324)
	// Turn logging on/off
	srInitializeLogging(pInstance, H245_TRACE_ENABLED);
#endif  // (DBG)

#ifdef _IA_SPOX_
	// Initialize the task and
	// Start the receive thread
    srTaskAttr.idwPriority = OIL_MINPRI;
    srTaskAttr.pStack    = NULL;
    srTaskAttr.dwStackSize = 8192;
	srTaskAttr.pEnviron = NULL;
    srTaskAttr.szName = "H245ReceiveThread";
    srTaskAttr.bExitFlag = TRUE;

	RIL_CreateTask((PFxn)ReceiveThread,
				   &srTaskAttr,
				   srContext,
				   &pInstance->SendReceive.pTaskReceive);
#else
	// Initialize the task and
	// Start the receive thread
    srTaskAttr.priority = TSK_MINPRI;
    srTaskAttr.stack    = NULL;
    srTaskAttr.stacksize = 8192;
    srTaskAttr.stackseg = 0;
//	srTaskAttr.environ = NULL;
    srTaskAttr.name = " ";
    srTaskAttr.exitflag = FALSE;
//    srTaskAttr.debug = TSK_DBG_NO;

	pInstance->SendReceive.pTaskReceive = TSK_create((Fxn)ReceiveThread,
                                          &srTaskAttr,
                                          srContext);
#endif //_IA_SPOX_
	if (pInstance->SendReceive.pTaskReceive == NULL)
	{
		H245TRACE(pInstance->dwInst, 1, "SR: Thread Create FAIL");		H245PANIC();
		return SR_THREAD_CREATE_ERROR;
	}





#endif  // (USE_RECEIVE_QUEUE)

	// post buffers to link layer for receive
	for (i = 0; i < pInstance->SendReceive.dwNumRXBuffers; ++i) {
		pInstance->SendReceive.lpRxBuffer[i] = H245_malloc(pInstance->SendReceive.dwPDUSize);
		if (pInstance->SendReceive.lpRxBuffer[i] == NULL) {
		    H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - No Memory");
			return H245_ERROR_NOMEM;
		}
		rc = pInstance->SendReceive.hLinkReceiveReq(pInstance->SendReceive.hLinkLayerInstance,
									   (PBYTE)pInstance->SendReceive.lpRxBuffer[i],
									   pInstance->SendReceive.dwPDUSize);
        if (rc != 0) {
		    H245TRACE(pInstance->dwInst, 1, "SR: SndRecvInit - Receive Buffer Post returned %d", rc);
		    return rc;
        }
	}

	H245TRACE(pInstance->dwInst,  3, "SR: INIT Complete");

	return H245_ERROR_OK;
} // sendRcvInit()


HRESULT
sendRcvFlushPDUs
(
	struct InstanceStruct *pInstance,
	DWORD	 dwDirection,
	BOOL	 bShutdown
)
{
    pInstance->SendReceive.dwFlushMap = dwDirection;
    if (bShutdown) {
     	pInstance->SendReceive.dwFlushMap |= SHUTDOWN_PENDING;
    }

    // Flush the requested queue(s)
    return(pInstance->SendReceive.hLinkLayerFlushChannel(pInstance->SendReceive.hLinkLayerInstance,
                                                         dwDirection));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245recv.c ===
/******************************************************************************
 *
 *  File:  h245recv.c
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245recv.c  $
 *  $Revision:   1.13.1.1  $
 *  $Modtime:   17 Mar 1997 20:32:00  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245recv.c_v  $
 * 
 *    Rev 1.13.1.1   17 Mar 1997 20:32:10   MANDREWS
 * Added pragma to disable warning for unreachable code.
 * 
 *    Rev 1.13.1.0   11 Mar 1997 16:30:12   MANDREWS
 * When generating a FunctionNotSupported PDU, don't include an
 * octet string containing the unrecognized PDU; this allows operation
 * with OSS 4.1.3-based endpoints which may not be able to properly
 * decode the octet string.
 * 
 *    Rev 1.13   06 Feb 1997 18:20:08   SBELL1
 * Saved length and pdu pointer before calling OSS Decode. That way we have
 * something valid for the H245FunctionNotSupported routine.
 * 
 *    Rev 1.12   27 Jan 1997 12:40:26   MANDREWS
 * 
 * Fixed warnings.
 * 
 *    Rev 1.11   01 Nov 1996 15:24:56   EHOWARDX
 * 
 * Added check for link not disconnected before re-posting receive buffer
 * to link layer to eliminate annoying error message from link layer.
 * 
 *    Rev 1.10   22 Jul 1996 17:33:42   EHOWARDX
 * Updated to latest Interop API.
 * 
 *    Rev 1.9   01 Jul 1996 16:14:32   EHOWARDX
 * locks
 * Added FunctionNotSupported if ossDecode fails.
 * 
 *    Rev 1.8   10 Jun 1996 16:53:46   EHOWARDX
 * Removed special handling of EndSession since shutdown moved to InstanceUnlo
 * 
 *    Rev 1.7   05 Jun 1996 17:14:28   EHOWARDX
 * Further work on converting to HRESULT; added PrintOssError to eliminate
 * pErrorString from instance structure.
 * 
 *    Rev 1.6   04 Jun 1996 18:18:16   EHOWARDX
 * Interop Logging changes inside #if defined(PCS_COMPLIANCE) conditionals.
 * 
 *    Rev 1.5   30 May 1996 23:39:10   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.4   28 May 1996 14:25:08   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.3   21 May 1996 13:40:46   EHOWARDX
 * Added LOGGING switch to log PDUs to the file H245.OUT.
 * Add /D "LOGGING" to project options to enable this feature.
 * 
 *    Rev 1.2   17 May 1996 16:44:22   EHOWARDX
 * Changed to use LINK_RECV_CLOSED to signal link layer close.
 * 
 *    Rev 1.1   17 May 1996 16:20:32   EHOWARDX
 * Added code to change API state if zero-length buffer received
 * signalling link layer closed.
 * 
 *    Rev 1.0   09 May 1996 21:06:24   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.8.1.5   09 May 1996 19:33:58   EHOWARDX
 * Redesigned locking logic.
 * Simplified link API.
 * 
 *    Rev 1.17   29 Apr 1996 16:05:12   EHOWARDX
 * Added special case handling of EndSessionCommand to ReceiveComplete().
 * 
 *    Rev 1.16   27 Apr 1996 21:13:14   EHOWARDX
 * Hope we finally got ossDecode() failure handling right...
 * 
 *    Rev 1.15   27 Apr 1996 13:08:54   EHOWARDX
 * Also need to terminate while loop if ossDecode fails!
 * 
 *    Rev 1.8.1.4   27 Apr 1996 11:25:36   EHOWARDX
 * Changed to not call FsmIncoming if ossDecode fails...
 * 
 * 
 *    Rev 1.8.1.3   25 Apr 1996 21:26:46   EHOWARDX
 * Changed to use pInstance->p_ossWorld instead of bAsnInitialized.
 * 
 *    Rev 1.8.1.2   23 Apr 1996 14:44:30   EHOWARDX
 * Updated.
 *
 *    Rev 1.8.1.1   15 Apr 1996 15:12:00   EHOWARDX
 * Updated.
 *
 *    Rev 1.8.1.0   26 Mar 1996 19:15:24   EHOWARDX
 *
 * Commented out hTraceFile for H.323
 *
 *    Rev 1.8   21 Mar 1996 17:21:36   dabrown1
 *
 * - put in test1/2 trace fdwrite
 *
 *    Rev 1.7   13 Mar 1996 11:31:56   DABROWN1
 *
 * Enable logging for ring0
 *
 *    Rev 1.6   06 Mar 1996 13:13:04   DABROWN1
 *
 * flush receive buffer functionality
 *
 *    Rev 1.5   01 Mar 1996 17:25:54   DABROWN1
 *
 * moved oss 'world' context to h245instance
 * changed oss delete from ossFreeBuf to ossFreePDU
 *
 *    Rev 1.4   23 Feb 1996 13:56:04   DABROWN1
 *
 * added H245TRACE / H245ASSERT calls
 *
 *    Rev 1.3   21 Feb 1996 12:09:56   EHOWARDX
 * Eliminated unused local variables.
 *
 *    Rev 1.2   21 Feb 1996 08:25:08   DABROWN1
 *
 * Provide multiple buffers receiving > 1 message (ie., link ACKs).
 *
 *    Rev 1.1   13 Feb 1996 14:46:06   DABROWN1
 *
 * changed asnexp.h (no longer there) to fsmexp.h
 *
 *    Rev 1.0   09 Feb 1996 17:36:20   cjutzi
 * Initial revision.
 *
 *****************************************************************************/
#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <limits.h>
#include <memory.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 4702)
# include <windows.h>
#endif



/***********************/
/*    H245 INCLUDES    */
/***********************/
#ifdef  _IA_SPOX_
# define _DLL
#endif //_IA_SPOX_

#include "h245com.h"
#include "sr_api.h"

#if defined(_DEBUG) && defined(PCS_COMPLIANCE)
#include "interop.h"
#include "h245plog.h"
extern  LPInteropLogger H245Logger;
#endif  // (PCS_COMPLIANCE)

#ifdef  _IA_SPOX_
# undef _DLL
#endif //_IA_SPOX_



/**************************************************************************
** Function    : h245ReceiveComplete
** Description : Receive Completion Callback routine from link layer
***************************************************************************/

HRESULT
H245FunctionNotSupported(struct InstanceStruct *pInstance, unsigned short wChoice, unsigned char *pBuf, unsigned uLength)
{
    MltmdSystmCntrlMssg Pdu = {0};

    Pdu.choice = indication_chosen;
    Pdu.u.indication.choice = functionNotSupported_chosen;
    Pdu.u.indication.u.functionNotSupported.cause.choice = wChoice;
    if (pBuf != NULL && uLength != 0)
    {
        Pdu.u.indication.u.functionNotSupported.bit_mask = returnedFunction_present;
        Pdu.u.indication.u.functionNotSupported.returnedFunction.length = (WORD)uLength;
        Pdu.u.indication.u.functionNotSupported.returnedFunction.value  = pBuf;
    }
    else
    {
        Pdu.u.indication.u.functionNotSupported.bit_mask = 0;
    }
    return sendPDU(pInstance, &Pdu);
} // H245FunctionNotSupported()

void h245ReceiveComplete(DWORD   h245Inst,
                         HRESULT dwMessage,
                         PBYTE   pbDataBuf,
                         DWORD   dwLength)
{
    struct InstanceStruct *pInstance;
    int                  pduNum = MltmdSystmCntrlMssg_PDU;
    ASN1_BUF             Asn1Buf;
    MltmdSystmCntrlMssg *pPdu;
    int                 nRet;

    // Validate the instance handle
    pInstance = InstanceLock(h245Inst);
    if (pInstance == NULL) {
        H245TRACE(h245Inst, 1, "h245ReceiveComplete: Instance not found");
        return;
    }

    // ONLY submit buffers to the decoder if it's for data received,
    // skip for flushes
    switch (dwMessage) {
    case LINK_RECV_CLOSED:
        H245TRACE(h245Inst, 3, "h245ReceiveComplete: Link Layer closed");
        pInstance->API.SystemState = APIST_Disconnected;
        InstanceUnlock(pInstance);
        return;

    case LINK_RECV_DATA:

        if (pInstance->pWorld == NULL) {
            H245TRACE(h245Inst, 1, "h245ReceiveComplete: ASN.1 Decoder not initialized");
            InstanceUnlock(pInstance);
            return;
        }

        switch (pInstance->Configuration) {
        case H245_CONF_H324:
            Asn1Buf.value  = &pbDataBuf[2];
            Asn1Buf.length = dwLength;
            break;

        default:
            Asn1Buf.value  = pbDataBuf;
            Asn1Buf.length = dwLength;
        } // switch

        // Loop around as long as the length field is positive.
        // ASN.1 decoder will update the length for each PDU it decodes until
        // a 0 length is achieved.
        while (Asn1Buf.length > 0)
        {
            int savePduLength = Asn1Buf.length;
            PBYTE savePdu = Asn1Buf.value;
            pPdu = NULL;

#if defined(DBG) && defined(PCS_COMPLIANCE)
            if (H245Logger)
                InteropOutput(H245Logger,
                              (BYTE FAR *)Asn1Buf.value,
                              (int)Asn1Buf.length,
                              H245LOG_RECEIVED_PDU);
#endif  // (PCS_COMPLIANCE)

            nRet = H245_Decode(pInstance->pWorld,
                            (void **)&pPdu,
                            pduNum,
                            &Asn1Buf);

            if (ASN1_SUCCEEDED(nRet))
            {
                // Decode succeeded

                H245TRACE(h245Inst, 3, "H.245 Msg decode successful");

                // Pass on data to finite state machine
                FsmIncoming(pInstance, pPdu);
            }
            else
            {
                // Decode failed
                H245FunctionNotSupported(pInstance, syntaxError_chosen, savePdu, savePduLength);
                Asn1Buf.length = 0;          // Terminate loop!
            }

            if (pPdu != NULL)
            {
                // Free the memory used by the ASN.1 library
                freePDU(pInstance->pWorld, pduNum, pPdu, H245_Module);
            }
        } // while (Asn1Buf.length > 0)

        if (pInstance->API.SystemState != APIST_Disconnected)
        {
            // Repost the buffer to the data link layer
            pInstance->SendReceive.hLinkReceiveReq(pInstance->SendReceive.hLinkLayerInstance,
                                                   pbDataBuf,
                                                   pInstance->SendReceive.dwPDUSize);
        }
        break; // case LINK_RECV_DATA

    case LINK_RECV_ABORT:
        // Receive buffer flush in process
        H245ASSERT(pbDataBuf != NULL);
        H245TRACE(h245Inst, 3, "SR: RX Flush Buffer");
        break;

    case LINK_FLUSH_COMPLETE:
        // Receive buffer flush done
        H245ASSERT(pbDataBuf == NULL);
        H245TRACE(h245Inst, 3, "SR: RX Flush Complete");
        pInstance->SendReceive.dwFlushMap &= ~DATALINK_RECEIVE;
        break;

    default:
        H245TRACE(h245Inst, 1, "SR: RX COMPLETE Error %d", dwMessage);
        break;
    } // switch
    InstanceUnlock(pInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\h245sys.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245sys.c  $
 *  $Revision:   1.8  $
 *  $Modtime:   Mar 04 1997 17:38:08  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/h245sys.c_v  $
 * 
 *    Rev 1.8   Mar 04 1997 17:51:56   tomitowx
 * process detach fix
 * 
 *    Rev 1.7   24 Jan 1997 19:40:48   SBELL1
 * upgraded to oss 4.2
 * 
 *    Rev 1.6   21 Jun 1996 18:53:22   unknown
 * Changed InstUnlock() to fix shutdown re-entrancy bug.
 * 
 *    Rev 1.5   10 Jun 1996 16:59:34   EHOWARDX
 * Moved init/shutdown of submodules to CreateInstance/InstanceUnlock.
 * 
 *    Rev 1.4   07 Jun 1996 17:38:22   EHOWARDX
 * 
 * Changed H245_malloc, H245_realloc, and H245_free to macros.
 * Added _H245_malloc, _H245_realloc, and _H245_free for use by OSS ASN.1.
 * 
 *    Rev 1.3   04 Jun 1996 13:57:02   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   28 May 1996 14:25:38   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.1   16 May 1996 13:51:26   EHOWARDX
 * Fixed minor timer/lock count interaction bugs.
 * 
 *    Rev 1.0   09 May 1996 21:06:28   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.25   09 May 1996 19:39:04   EHOWARDX
 * Changed includes.
 * 
 *    Rev 1.24   29 Apr 1996 12:56:58   EHOWARDX
 * Made timers more accurate & made them use fewer resources.
 * Note: This is windows-specific.
 * 
 *    Rev 1.18.1.2   15 Apr 1996 15:12:34   EHOWARDX
 * Kludge to not call H245DeInitTimer() when last timer is stopped.
 * This will have to be revisited later.
 * 
 *    Rev 1.18.1.1   02 Apr 1996 22:06:22   EHOWARDX
 * No change.
 * 
 *    Rev 1.18.1.0   27 Mar 1996 16:44:18   EHOWARDX
 * Changed timer code; decided it would work better if H245InitTimer()
 * actually got called.
 * 
 *    Rev 1.18   26 Mar 1996 09:46:08   cjutzi
 * 
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 * 
 *    Rev 1.17   25 Mar 1996 18:30:14   helgebax
 * - removed H245ASSERT .
 * .
 * 
 * 
 *    Rev 1.16   25 Mar 1996 18:10:48   cjutzi
 * 
 * - well .. I broke the build.. had to put back what I did.. 
 * 
 * 
 *    Rev 1.15   25 Mar 1996 17:50:02   cjutzi
 * 
 * - removed critical section.. back step
 * 
 *    Rev 1.14   25 Mar 1996 17:20:34   cjutzi
 * 
 * - added Remesh's EnterCritical section definitions.. to use
 *   oil layer. 
 * 
 *    Rev 1.13   18 Mar 1996 12:44:40   cjutzi
 * 
 * - put NULL as callback at shutdown
 * 
 *    Rev 1.12   18 Mar 1996 12:41:32   cjutzi
 * - added timer code for multiple timers queue.. 
 * 
 *    Rev 1.11   12 Mar 1996 15:48:46   cjutzi
 * 
 * - added InstanceTbl Lock
 * 
 *    Rev 1.10   07 Mar 1996 22:47:34   dabrown1
 * 
 * Modifications required for ring0/ring3 compatibilty
 * 
 *    Rev 1.9   02 Mar 1996 22:14:52   DABROWN1
 * 
 * removed h245_bzero and h245_bcopy (use memset and memcpy instead)
 * put guardbands in h245_malloc with check in h245_free for _DEBUG
 * changed # parameters passed to h245_free to 1 only (ptr)
 * redefined h245_realloc
 * 
 *    Rev 1.8   26 Feb 1996 17:10:56   cjutzi
 * 
 * - removed h245sys.h
 * 
 *    Rev 1.7   26 Feb 1996 12:42:26   cjutzi
 * 
 * - added bcopy 
 * 
 *    Rev 1.6   21 Feb 1996 16:23:38   DABROWN1
 * 
 * removed h245_ASN1free
 * modified malloc and free to save buffer size internally
 * 
 *    Rev 1.5   13 Feb 1996 14:54:12   DABROWN1
 * 
 * removed trace/debug files to new debug directory
 * 
 *    Rev 1.4   09 Feb 1996 15:45:08   cjutzi
 * - added h245trace
 * - added h245Assert
 *
 *****************************************************************************/
#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#if defined(_IA_SPOX_)
# include <oil.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif

#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

#if defined(_IA_SPOX_)
#include <h223api.h>

/************************************/
/* MALLOC ABSTRACTION
/************************************/
typedef struct MEMALLOC {
  DWORD     dwSize;
  void     *pBuffer;
} MEMALLOC, *PMEMALLOC;

#endif

/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245_malloc
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
void * 
DLL_ENTRY_FDEF
_H245_malloc ( size_t dwSize )
{
#if defined(_IA_SPOX_)

  PMEMALLOC p_mem;
  DWORD     dwBufferSize;
#ifdef DBG
  DWORD    *testptr;
#endif

  // embed the size of the memory in the block so we can pull it
  // out when we free it.
#ifdef DBG
  dwBufferSize = dwSize + sizeof(DWORD) + sizeof(DWORD);
#else
  dwBufferSize = dwSize + sizeof(DWORD);
#endif // DBG

  OIL_Alloc (dwBufferSize, &p_mem);

  if (p_mem) {

   /* Save the size so we know how big it is when we need to free it */
   p_mem->dwSize = dwBufferSize;

#ifdef DBG
   // Have guardbands for debugging purposes
   testptr = (DWORD *)((char *)p_mem + dwBufferSize - sizeof(DWORD));
   *testptr = 0x12345678;
#endif //DBG

   return &(p_mem->pBuffer);
  }
  else {
   return NULL;
  }

#else

# if defined(_MALLOC_DBG)
  return _malloc_dbg(dwSize, _NORMAL_BLOCK, __FILE__, __LINE__);
# else
  return malloc(dwSize);
# endif

#endif  // (_IA_SPOX_)

}


/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245_free
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/

void
DLL_ENTRY_FDEF
_H245_free( void *pBuf )
{
#if defined(_IA_SPOX_)

  PMEMALLOC p_mem;
#ifdef DBG
  DWORD    *testptr;
#endif // DBG

  /* Adjust pointer to account for size field */
  p_mem = (PMEMALLOC)((char *)pBuf - sizeof(DWORD));

#ifdef DBG
  testptr = (DWORD *)((char *)p_mem + p_mem->dwSize - sizeof(DWORD));
  H245ASSERT(*testptr == 0x12345678);
#endif // DBG

  OIL_Free (p_mem, p_mem->dwSize);

#else

# if defined(_MALLOC_DBG)
  _free_dbg(pBuf, _NORMAL_BLOCK);
# else
  free (pBuf);
# endif

#endif  // (_IA_SPOX_)
}


/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245_realloc
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/

void *
DLL_ENTRY_FDEF
_H245_realloc( void *pBuf, size_t dwSize )
{
#if defined(_IA_SPOX_)

  void     *pNewBuf;
  PMEMALLOC p_MemOld;

  // If user supplied ubffer is null, equivalent to malloc
  if (pBuf == NULL) {
    return H245_malloc(dwSize);
  }

  // If size is 0, same as free with a NULL return (we know
  // there is a buffer due to test (pBuf == NULL), above
  if (dwSize == 0) {
    H245_free( pBuf );
    return NULL;
  }

  // Obtain the buffer size requested
  pNewBuf = H245_malloc(dwSize);

  // If new malloc failed, return NULL
  if (pNewBuf) {

    // A buffer was submitted.  Check if newly requested
    // size is smaller or larger than the original
    p_MemOld = (PMEMALLOC)((char *)pBuf - sizeof(DWORD));

    // Copy over as much data from the old buffer as we can
    memcpy(pNewBuf,
           pBuf,
           H245_min(p_MemOld->dwSize, dwSize));

    // After data is copied, return the old buffer
    H245_free( pBuf );
  }

  return pNewBuf;

#else

# if defined(_MALLOC_DBG)
  return _realloc_dbg(pBuf, dwSize, _NORMAL_BLOCK, __FILE__, __LINE__);
# else
  return realloc (pBuf, dwSize);
# endif

#endif  // (_IA_SPOX_)
}



/**************************************************************************
 *
 * Instance Table/Instance Lock implementation
 *
 **************************************************************************/

CRITICAL_SECTION        InstanceCreateLock     = {0};
CRITICAL_SECTION        InstanceLocks[MAXINST] = {0};
struct InstanceStruct * InstanceTable[MAXINST] = {0};

struct InstanceStruct *InstanceCreate(DWORD dwPhysId, H245_CONFIG_T Configuration)
{
  register struct InstanceStruct *pInstance;
  register unsigned int           uIndex;
  unsigned int                    uFirst = (dwPhysId - 1) % MAXINST;
  HRESULT                         lError;

  // Allocate new instance
  pInstance = (struct InstanceStruct *)H245_malloc(sizeof(*pInstance));
  if (pInstance == NULL)
  {
    H245TRACE(dwPhysId,1,"InstanceCreate -> Instance malloc failed");
    return NULL;
  }

  // Make sure no one is trying to simultaneously add same physical Id
  // (I know this is a stretch...)
  EnterCriticalSection(&InstanceCreateLock);

  // Check if instance corresponding to dwPhysId already exists
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for unused instances
    if (InstanceTable[uIndex])
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] && InstanceTable[uIndex]->dwPhysId == dwPhysId)
      {
        LeaveCriticalSection(&InstanceLocks[uIndex]);
        LeaveCriticalSection(&InstanceCreateLock);
        H245_free(pInstance);
        H245TRACE(dwPhysId,1,"InstanceCreate -> Physical Id already in use");
        return NULL;
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  // Find empty slot for new instance
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for used instances
    if (InstanceTable[uIndex] == NULL)
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] == NULL)
      {
        // Initialize new instance
        // Once the new instance is added to the instance table,
        // we can relinquish the CreateInstanceLock
        InstanceTable[uIndex] = pInstance;
        LeaveCriticalSection(&InstanceCreateLock);
        memset(pInstance, 0, sizeof(*pInstance));
        pInstance->dwPhysId  = dwPhysId;
        pInstance->dwInst    = uIndex + 1;
        pInstance->LockCount = 1;

        /* API Subsystem Initialization */
        pInstance->Configuration = Configuration;
        lError = api_init(pInstance);
        if (lError != H245_ERROR_OK)
        {
          H245_free(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> api_init failed");
          return NULL;
        }

        /* Send Receive Subsystem Initialization */
        lError = sendRcvInit(pInstance);
        if (lError != H245_ERROR_OK)
        {
          api_deinit(pInstance);
          H245_free(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> sendRcvInit failed");
          return NULL;
        }

        /* State Machine Subsystem Initialization */
        lError = Fsm_init(pInstance);
        if (lError != H245_ERROR_OK)
        {
          sendRcvShutdown(pInstance);
          api_deinit(pInstance);
          H245_free(pInstance);
          H245TRACE(dwPhysId,1,"InstanceCreate -> Fsm_init failed");
          return NULL;
        }

        H245TRACE(pInstance->dwInst,9,"InstanceCreate: ++LockCount=%d", pInstance->LockCount);
        return pInstance;                 // Return locked instance
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  LeaveCriticalSection(&InstanceCreateLock);
  H245_free(pInstance);
  H245TRACE(dwPhysId,1,"InstanceCreate -> Too many instances");
  return NULL;
} // InstanceCreate()

struct InstanceStruct *InstanceFind(DWORD dwPhysId)
{
  register unsigned int           uIndex;
  unsigned int                    uFirst = (dwPhysId - 1) % MAXINST;

  // Check if instance corresponding to dwPhysId exists
  uIndex = uFirst;                      // Hash start index into table
  do
  {
    // Avoid entering critical section for unused instances
    if (InstanceTable[uIndex])
    {
      EnterCriticalSection(&InstanceLocks[uIndex]);
      if (InstanceTable[uIndex] && InstanceTable[uIndex]->dwPhysId == dwPhysId)
      {
        InstanceTable[uIndex]->LockCount++;
        H245TRACE(InstanceTable[uIndex]->dwInst,9,"InstanceFind: ++LockCount=%d", InstanceTable[uIndex]->LockCount);
        return InstanceTable[uIndex];     // Return locked instance
      }
      LeaveCriticalSection(&InstanceLocks[uIndex]);
    }
    uIndex = (uIndex + 1) % MAXINST;
  } while (uIndex != uFirst);

  H245TRACE(dwPhysId,1,"InstanceFind -> Instance not found");
  return NULL;                          // Instance not found
} // InstanceFind()

struct InstanceStruct *InstanceLock(register H245_INST_T dwInst)
{
  if (--dwInst >= MAXINST)
  {
    H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
    return NULL;
  }

  // Lock instance, then see if it exists
  EnterCriticalSection(&InstanceLocks[dwInst]);
  if (InstanceTable[dwInst])
  {
    InstanceTable[dwInst]->LockCount++;
    H245TRACE(dwInst+1,9,"InstanceLock: ++LockCount=%d", InstanceTable[dwInst]->LockCount);
    return InstanceTable[dwInst];      // Return locked instance
  }
  LeaveCriticalSection(&InstanceLocks[dwInst]);
  H245TRACE(dwInst+1,1,"InstanceLock -> Invalid instance");
  return NULL;
} // InstanceLock()

int InstanceUnlock(struct InstanceStruct *pInstance)
{
  register H245_INST_T dwInst = pInstance->dwInst - 1;
  if (dwInst >= MAXINST || InstanceTable[dwInst] != pInstance)
  {
    H245TRACE(pInstance->dwInst,1,"InstanceUnlock -> Invalid instance");
    return -1;
  }
  if (pInstance->fDelete && pInstance->LockCount == 1)
  {
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: deleting instance");
    pInstance->fDelete = FALSE; // InstanceUnlock will be re-entered from H245WS callback!
    Fsm_shutdown(pInstance);
    sendRcvShutdown(pInstance);
    api_deinit(pInstance);
    InstanceTable[dwInst] = NULL;
    LeaveCriticalSection(&InstanceLocks[dwInst]);
    while (pInstance->pTimerList)
    {
      register TimerList_T *pTimer = pInstance->pTimerList;
      pInstance->pTimerList = pTimer->pNext;
      H245TRACE(pInstance->dwInst,1,"InstanceUnlock: deleting timer");
      H245_free(pTimer);
    }
    H245_free(pInstance);
  }
  else
  {
    pInstance->LockCount--;
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: --LockCount=%d", pInstance->LockCount);
    LeaveCriticalSection(&InstanceLocks[dwInst]);
  }
  return 0;
} // InstanceUnlock()

int InstanceDelete(struct InstanceStruct *pInstance)
{
  H245TRACE(pInstance->dwInst,9,"InstanceDelete");
  pInstance->fDelete = TRUE;
  return InstanceUnlock(pInstance);
} // InstanceDelete()



int InstanceUnlock_ProcessDetach(struct InstanceStruct *pInstance, BOOL fProcessDetach)
{
  register H245_INST_T dwInst = pInstance->dwInst - 1;
  if (dwInst >= MAXINST || InstanceTable[dwInst] != pInstance)
  {
    H245TRACE(pInstance->dwInst,1,"InstanceUnlock -> Invalid instance");
    return -1;
  }
  if (pInstance->fDelete && pInstance->LockCount == 1)
  {
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: deleting instance");
    pInstance->fDelete = FALSE; // InstanceUnlock will be re-entered from H245WS callback!

    Fsm_shutdown(pInstance);
    //sendRcvShutdown(pInstance);
    sendRcvShutdown_ProcessDetach(pInstance,fProcessDetach);

    api_deinit(pInstance);
    InstanceTable[dwInst] = NULL;
    LeaveCriticalSection(&InstanceLocks[dwInst]);
    while (pInstance->pTimerList)
    {
      register TimerList_T *pTimer = pInstance->pTimerList;
      pInstance->pTimerList = pTimer->pNext;
      H245TRACE(pInstance->dwInst,1,"InstanceUnlock: deleting timer");
      H245_free(pTimer);
    }
    H245_free(pInstance);
  }
  else
  {
    pInstance->LockCount--;
    H245TRACE(pInstance->dwInst,9,"InstanceUnlock: --LockCount=%d", pInstance->LockCount);
    LeaveCriticalSection(&InstanceLocks[dwInst]);
  }
  return 0;
} // InstanceUnlock_ProcessDetach()




/*****************************************************************************
 *
 * TYPE:  TIMER STUFF
 *
 *****************************************************************************/

CRITICAL_SECTION        TimerLock = {0};
static int              TimerInited = 0;
#ifndef _IA_SPOX_
static UINT_PTR         H245TimerId;
#endif

/*****************************************************************************
 *
 * TYPE:  Global System
 *
 * PROCEDURE:   H245TimerTick - ticks every 1000ms
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
void H245TimerTick (void)
{
  DWORD                           dwTickCount = GetTickCount();
  unsigned int                    uIndex;
  register struct InstanceStruct *pInstance;
  register TimerList_T           *pTimer;

  H245ASSERT(TimerInited != 0);
  H245TRACE(0,9,"H245TimerTick <-");

  for (uIndex = 0; uIndex < MAXINST; ++uIndex)
  {
    // Avoid entering critical section for unused instances
    if (InstanceTable[uIndex])
    {
      pInstance = InstanceLock(uIndex + 1);
      if (pInstance)
      {
        while (pInstance->pTimerList && (pInstance->pTimerList->dwAlarm - dwTickCount) >= 0x80000000)
        {
          pTimer = pInstance->pTimerList;
          pInstance->pTimerList = pTimer->pNext;
          EnterCriticalSection(&TimerLock);
          if (--TimerInited == 0)
          {
#ifdef _IA_SPOX_
            H223_RegisterTimerCallBack((H223TIMERCB)NULL);
#else
            KillTimer (NULL, H245TimerId);
#endif
          }
          LeaveCriticalSection(&TimerLock);
          if (pTimer->pfnCallBack)
          {
            // TBD - what if pContext is no longer valid?
            (pTimer->pfnCallBack)(pInstance, PtrToUlong(pTimer), pTimer->pContext);
          }
          H245_free (pTimer);
        } // while
        InstanceUnlock(pInstance);
      } // if
    } // if
  } // for
  H245TRACE(0,9,"H245TimerTick ->");
} // TimerTick()

/*****************************************************************************
 *
 * TYPE:  Global System
 *
 * PROCEDURE:   H245TimerProc - FOR WINDOWS Ring 3 only
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
#ifndef _IA_SPOX_
#pragma warning ( disable : 4100 )
void CALLBACK  H245TimerProc(HWND  hwHwnd,
                             UINT  uiMessg,
                             UINT_PTR  idTimer,
                             DWORD dwTime)
{
  if (idTimer == H245TimerId)
    H245TimerTick ();
}
#pragma warning ( default : 4100 )
#endif

/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245StartTimer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
DWORD H245StartTimer (struct InstanceStruct *   pInstance,
                      void                  *   pContext,
                      H245TIMERCALLBACK         pfnCallBack,
                      DWORD                     dwTicks)
{
  TimerList_T   *pNew;
  TimerList_T   *pLook;
  TimerList_T   *pList;

  if (!pfnCallBack)
  {
    H245TRACE(pInstance->dwInst,1,"H245StartTimer: pfnCallBack == NULL");
    return 0;
  }

  pNew = (TimerList_T *)H245_malloc(sizeof(TimerList_T));
  if (pNew == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StartTimer: memory allocation failed");
    return 0;
  }

  pNew->pNext       = NULL;
  pNew->pContext    = pContext;
  pNew->pfnCallBack = pfnCallBack;
  pNew->dwAlarm     = GetTickCount() + dwTicks;

  EnterCriticalSection(&TimerLock);
  if (++TimerInited == 1)
  {
#ifdef _IA_SPOX_
    H223_RegisterTimerCallBack((H223TIMERCB)H245TimerTick);
#else
    H245TimerId = SetTimer ((HWND)NULL, (UINT_PTR)0, (UINT)1000, (TIMERPROC)H245TimerProc);
#endif
  }
  LeaveCriticalSection(&TimerLock);

  /* as you traverse the list.. subtract the delta off the new one */
  /* and link it in.. this list is a list of delta's off the time  */
  /* out that is linked in front of it.. so subtract as you go     */
  for (pList = NULL, pLook = pInstance->pTimerList;
       pLook && (pLook->dwAlarm - pNew->dwAlarm) >= 0x80000000;
       pList = pLook, pLook = pLook->pNext);

  /* link it in the list */
  pNew->pNext = pLook;
  if (pList)
  {
    // Insert new timer after pList and before pLook
    pList->pNext = pNew;
  }
  else
  {
    // Insert new timer at front of list
    pInstance->pTimerList = pNew;
  }
  return PtrToUlong(pNew);
}


/*****************************************************************************
 *
 * TYPE:        Global System
 *
 * PROCEDURE:   H245StopTimer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
DWORD H245StopTimer(struct InstanceStruct *pInstance, DWORD dwTimerId)
{
  TimerList_T   *pTimer = (TimerList_T *)dwTimerId;
  TimerList_T   *pLook;
  TimerList_T   *pList;

  H245ASSERT(TimerInited != 0);

  EnterCriticalSection(&TimerLock);
  if (--TimerInited == 0)
  {
#ifdef _IA_SPOX_
    H223_RegisterTimerCallBack((H223TIMERCB)NULL);
#else
    KillTimer (NULL, H245TimerId);
#endif
  }
  LeaveCriticalSection(&TimerLock);

  if (pInstance->pTimerList == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StopTimer: timer list NULL");
    return TRUE;
  }

  if (pTimer == pInstance->pTimerList)
  {
    pInstance->pTimerList = pTimer->pNext;
    H245_free (pTimer);
    return FALSE;
  }

  pList = pInstance->pTimerList;
  pLook = pList->pNext;
  while (pLook && pLook != pTimer)
  {
     pList = pLook;
     pLook = pLook->pNext;
  }

  /* if the timer exists.. */
  if (pLook == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"H245StopTimer: pTimer not in timer list");
    return TRUE;
  }

  pList->pNext = pTimer->pNext;
  H245_free (pTimer);
  return FALSE;
}

#ifdef _IA_SPOX_
PUBLIC RESULT InitializeCriticalSection(CRITICAL_SECTION * phLock)

{
  return OIL_CreateLock(phLock);
}

PUBLIC RESULT EnterCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_AcquireLock(*phLock);
}

PUBLIC RESULT LeaveCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_ReleaseLock(*phLock);
}

PUBLIC RESULT DeleteCriticalSection(CRITICAL_SECTION * phLock)
{
  return OIL_DeleteLock(*phLock);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\mstrslv.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mstrslv.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   mstrslv.c  $
 * $Revision:   1.12  $
 * $Modtime:   12 Dec 1996 14:37:12  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/mstrslv.c_v  $
 * 
 *    Rev 1.12   12 Dec 1996 15:52:50   EHOWARDX
 * Master Slave Determination kludge.
 * 
 *    Rev 1.11   11 Dec 1996 16:50:50   EHOWARDX
 * Went back to original Master/Slave determination algorithm.
 * 
 *    Rev 1.10   09 Dec 1996 13:34:48   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.9   26 Nov 1996 17:06:02   EHOWARDX
 * Reversed order of subtraction for DetermineMasterSlave.
 * 
 *    Rev 1.8   08 Aug 1996 16:03:40   EHOWARDX
 * 
 * Fixed master slave determinate bug (hopefully the last one!)
 * 
 *    Rev 1.7   19 Jul 1996 12:12:44   EHOWARDX
 * 
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 * 
 *    Rev 1.6   01 Jul 1996 23:35:48   EHOWARDX
 * MSDetAckIncoming bug - was sending indication instead of confirm.
 * 
 *    Rev 1.5   01 Jul 1996 23:14:20   EHOWARDX
 * Fixed bug in MSDetOutgoing -- state change was ifdefed out.
 * 
 *    Rev 1.4   07 Jun 1996 16:00:26   EHOWARDX
 * Fixed bug with pOut not getting freed in msDetOutgoing.
 * 
 *    Rev 1.3   07 Jun 1996 15:40:20   EHOWARDX
 * Fixed bug in msDetRejOutgoing; pOut was not freed if N100 count exceeded.
 * 
 *    Rev 1.2   04 Jun 1996 13:57:54   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.1   30 May 1996 23:39:16   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:06:32   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.11.1.4   09 May 1996 19:48:48   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.11.1.3   25 Apr 1996 17:00:22   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.11.1.2   15 Apr 1996 10:45:46   EHOWARDX
 * Update.
 *
 *    Rev 1.11.1.1   10 Apr 1996 21:15:46   EHOWARDX
 * Check-in for safety in middle of re-design.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mstrslv.h"
#include "pdu.x"



// Master Slave Determination states

#define MSIDLE                      0
#define MSOutgoingAwaiting          1
#define MSIncomingAwaiting          2

#define MAX_RAND                  0x00FFFFFF


extern unsigned int uN100;
extern unsigned int uT106;



/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T106ExpiryF - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T106ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T106Expiry);
} // T106ExpiryF()



#define GetTerminal(pObject)  (pObject)->pInstance->StateMachine.sv_TT
#define GetStatus(pObject)    (pObject)->pInstance->StateMachine.sv_STATUS
#define SetStatus(pObject, Status) (pObject)->pInstance->StateMachine.sv_STATUS = (Status)
#define GetRandomNumber(pObject) (pObject)->u.msdse.sv_SDNUM
#define SetRandomNumber(pObject, uRandom) (pObject)->u.msdse.sv_SDNUM = (uRandom)
#define GetCount(pObject) (pObject)->u.msdse.sv_NCOUNT
#define SetCount(pObject, uCount) (pObject)->u.msdse.sv_NCOUNT = (uCount)



/*
 *  NAME
 *      DetermineStatus - determines whether the terminal is a master or a slave or neither
 *
 *
 *  PARAMETERS
 *   INPUT   pdu        pointer to a PDU structure
 *
 *  RETURN VALUE
 *   terminal status
 */

static MS_Status_t DetermineStatus(Object_t *pObject, PDU_t *pPdu)
{
    unsigned int uTemp;
    unsigned char sv_TT = GetTerminal(pObject);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.terminalType < sv_TT)
        return pObject->pInstance->StateMachine.sv_STATUS = MASTER;
    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.terminalType > sv_TT)
        return pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
    uTemp = (pPdu->u.MltmdSystmCntrlMssg_rqst.u.masterSlaveDetermination.statusDeterminationNumber - GetRandomNumber(pObject)) & 0xFFFFFF;
    if (uTemp > 0x800000)
        return pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
    if (uTemp < 0x800000 && uTemp != 0)
        return pObject->pInstance->StateMachine.sv_STATUS = MASTER;
    return pObject->pInstance->StateMachine.sv_STATUS = INDETERMINATE;
}



/***********************************************************************
 *
 * FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      detRequestIdle - request Master/Slave Determination from API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT detRequestIdle(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIDLE);

    SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
    SetCount(pObject, 1);               // Initialize retry counter
    SetStatus(pObject, INDETERMINATE);
    H245TRACE(  pObject->dwInst, 2,
                "detRequestIdle: TerminalType=%d StatusDeterminationNumber=%d",
                GetTerminal(pObject), GetRandomNumber(pObject));

    /* Send a Master/Slave determination PDU */
    H245TRACE(pObject->dwInst, 2, "Master/Slave Determination to Send/Rec module");
    pdu_req_mstslv (pPdu, GetTerminal(pObject), GetRandomNumber(pObject));
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T106 */
    pObject->State = MSOutgoingAwaiting;
    FsmStartTimer(pObject, T106ExpiryF, uT106);

    return lError;
} // detRequestIdle()

/*
 *  NAME
 *      msDetIdle - received Master/Slave Determination PDU in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetIdle(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIDLE);

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        DetermineStatus(pObject, pPdu);
        return H245_ERROR_NOMEM;
    }

    SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
    switch (DetermineStatus(pObject, pPdu))
    {
    case MASTER:
        /* Build MasterSlave Determination Ack */
        H245TRACE(pObject->dwInst, 2, "msDetIdle: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case SLAVE:
        /* Build MasterSlave Determination Ack */
        H245TRACE(pObject->dwInst, 2, "msDetIdle: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        /* Send a masterSlaveDet Reject */
        pdu_rsp_mstslv_rej(pOut);
        lError = sendPDU(pObject->pInstance, pOut);
        H245_free(pOut);
        return lError;
    } // switch

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    pObject->State = MSIncomingAwaiting;

#if defined(SDL_COMPLIANT)
    /* Send DETERMINE indication to client - unnecessary */
    H245FsmIndication(pPdu, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    /* set timer T106 */
    FsmStartTimer(pObject, T106ExpiryF, uT106);
    return lError;
}



/*
 *  NAME
 *      msDetAckOutgoing - received Master/Slave Determination Ack pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */
HRESULT msDetAckOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSOutgoingAwaiting);

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer */
    FsmStopTimer(pObject);

    /* Decision is opposite of MasterSlaveDeterminationAck.decision */
    switch(pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice)
    {
    case master_chosen:
        pObject->pInstance->StateMachine.sv_STATUS = MASTER;
        H245TRACE(pObject->dwInst, 2, "msDetAckOutgoing: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case slave_chosen:
        pObject->pInstance->StateMachine.sv_STATUS = SLAVE;
        H245TRACE(pObject->dwInst, 2, "msDetAckOutgoing: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        H245TRACE(pObject->dwInst, 1, "msDetAckOutgoing: Invalid Master Slave Determination Ack received");
        return H245_ERROR_PARAM;
    }

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send DETERMINE confirm to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      msDetOutgoing- received Master/Slave Determination pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSOutgoingAwaiting);

	if (pObject->pInstance->bMasterSlaveKludge == 0)
	{
		// Ignore this message
		return NOERROR;
	}

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer T106 */
    FsmStopTimer(pObject);

    switch (DetermineStatus(pObject, pPdu))
    {
    case MASTER:
        H245TRACE(pObject->dwInst, 2, "msDetOutgoing: sending Ack: SLAVE");
        pdu_rsp_mstslv_ack(pOut, slave_chosen);
        break;

    case SLAVE:
        H245TRACE(pObject->dwInst, 2, "msDetOutgoing: sending Ack: MASTER");
        pdu_rsp_mstslv_ack(pOut, master_chosen);
        break;

    default:
        if (GetCount(pObject) >= uN100)
        {
            H245_free(pOut);

            /* Send ERROR.indication(F) to client */
            H245TRACE(pObject->dwInst, 2, "msDetOutgoing: Counter expired; Session Failed");
            H245FsmConfirm(NULL,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

            /* Send REJECT.indication to client - unnecessary */

            pObject->State = MSIDLE;
            lError = 0;
        }
        else
        {
            /* generate a new random number */
            H245TRACE(pObject->dwInst, 2, "Resending MasterSlaveDetermination");
            SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
            SetCount(pObject, GetCount(pObject) + 1);

            /* Send MasterSlave Determination PDU to remote */
            pdu_req_mstslv (pOut, GetTerminal(pObject), GetRandomNumber(pObject));
            lError = sendPDU(pObject->pInstance, pOut);
            H245_free(pOut);

            /* set timer T106 */
            pObject->State = MSOutgoingAwaiting;
            FsmStartTimer(pObject, T106ExpiryF, uT106);
        }
        return lError;
    } // switch

    /* Send MasterSlave Determination Ack to remote */
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    pObject->State = MSIncomingAwaiting;

#if defined(SDL_COMPLIANT)
    /* Send DETERMINE indication to client */
    H245FsmIndication(pPdu, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    /* set timer T106 */
    FsmStartTimer(pObject, T106ExpiryF, uT106);

    return lError;
}



/*
 *  NAME
 *      msDetRejOutgoing- received Master/Slave Determination Reject pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */


HRESULT msDetRejOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSOutgoingAwaiting);

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* reset timer T106 */
    FsmStopTimer(pObject);

    if (GetCount(pObject) >= uN100)
    {
        H245_free(pOut);

        H245TRACE(pObject->dwInst, 2, "msDetRejOutgoing: Counter expired; Session Failed");
        pObject->State = MSIDLE;

        /* Send ERROR.indication(f) to client */
        H245FsmConfirm(pPdu,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
        /* Send REJECT.indication to client - not necessary */
        H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

        lError = 0;
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "msDetRejOutgoint: Re-sending a MasterSlaveDetermination");

        /* generate a new random number */
        SetRandomNumber(pObject, GetTickCount() & MAX_RAND);
        SetCount(pObject, GetCount(pObject) + 1);

        /* Send MasterSlave Determination PDU to remote */
        pdu_req_mstslv (pOut, GetTerminal(pObject), GetRandomNumber(pObject));
        lError = sendPDU(pObject->pInstance,pOut);
        H245_free(pOut);

        /* set timer T106 */
        FsmStartTimer(pObject, T106ExpiryF, uT106);
    }

    return lError;
}



/*
 *  NAME
 *      msDetReleaseOutgoing- received Master/Slave Determination release pdu in outgoing state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetReleaseOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSOutgoingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetReleaseOutgoing: Master/Slave Determination Release received; session failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(B) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      t106ExpiryOutgoing- timer expired for an outgoing M/S determination pdu
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t106ExpiryOutgoing(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSOutgoingAwaiting);
    H245ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2, "t106ExpiryOutgoing: Timer expired before receiving Ack; session failed");

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* Send MasterSlave Determination Release to remote */
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = mstrSlvDtrmntnRls_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send ERROR.indication(A) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(NULL,H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return lError;
}

# pragma warning( default : 4100 )



/*
*  NAME
*      msDetAckIncoming- received Master/Slave Determination Ack pdu in incoming state
*
*
*  PARAMETERS
*   INPUT   pObject        pointer to a State Entity
*
*  RETURN VALUE
*       error return codes defined in h245com.h
*/

HRESULT msDetAckIncoming(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIncomingAwaiting);

    /* reset timer T106 */
    FsmStopTimer(pObject);

    switch (GetStatus(pObject))
    {
    case  master_chosen:
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
        {
            H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Terminal is a MASTER");

            /* Send DETERMINE.confirm to client */
            pObject->State = MSIDLE;
            H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
            return 0;
        }
        break;

    case slave_chosen:
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == slave_chosen)
        {
            H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Terminal is a SLAVE");

            /* Send DETERMINE.confirm to client */
            pObject->State = MSIDLE;
            H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, FSM_OK);
            return 0;
        }
        break;

    default:
        H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: Invalid MasterSlave Determination Ack received");
        return H245_ERROR_PARAM;
    } // switch

    H245TRACE(pObject->dwInst, 2, "msDetAckIncoming: bad decision in MasterSlave Determination Ack; Session failed");

    /* Send ERROR.indication(E) to client */
    pObject->State = MSIDLE;
    H245FsmConfirm(pPdu, H245_CONF_INIT_MSTSLV, pObject->pInstance, pObject->dwTransId, SESSION_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

return 0;
}



/*
 *  NAME
 *      msDetIncoming- received Master/Slave Determination pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetIncoming(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetIncoming: received MasterSlave Determination in INCOMING state; Session failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(C) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      msDetRejIncoming- received Master/Slave Determination Reject pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetRejIncoming(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetRejIncoming: received MasterSlave Reject: Session Failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(D) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      msDetReleaseIncoming- received Master/Slave Determination Release pdu in incoming state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT msDetReleaseIncoming(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIncomingAwaiting);
    H245TRACE(pObject->dwInst, 2, "msDetReleaseIncoming: received MasterSlave Release; Session Failed");

    /* reset timer T106 */
    FsmStopTimer(pObject);

    /* Send ERROR.indication(B) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(pPdu,H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, MS_FAILED);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}



/*
 *  NAME
 *      t106ExpiryIncoming - timer expired while waiting for second Ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t106ExpiryIncoming(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MSDSE);
    H245ASSERT(pObject->State  == MSIncomingAwaiting);
    H245ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2, "t106ExpiryIncoming: timer expired waiting for Ack; Session failed");

    /* Send ERROR.indication(A) to client */
    pObject->State = MSIDLE;
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_MSTSLV, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}

# pragma warning( default : 4100 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\api_dwn.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  AUTHOR: cjutzi (Curt Jutzi) Intel Corporation
 *
 *  $Workfile:   api_dwn.c  $
 *  $Revision:   1.45.1.0  $
 *  $Modtime:   30 Apr 1997 13:41:36  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_dwn.c_v  $
 * 
 *    Rev 1.45.1.0   30 Apr 1997 13:48:14   MANDREWS
 * Fixed bug in H245RequestMode(); when constructing a linked list of
 * mode descriptions, the "next" pointer in the last list element was
 * not being set (should be NULL). Also, the pdu structure was being
 * initialized to all zeros using an incorrect (too small) byte length.
 * 
 *    Rev 1.45   05 Mar 1997 09:56:04   MANDREWS
 * Fixed compiler warning in release mode.
 * 
 *    Rev 1.44   04 Mar 1997 17:33:26   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 * 
 *    Rev 1.43   26 Feb 1997 11:12:06   MANDREWS
 * Fixed problem in assigning dynamic term cap IDs; the dynamic IDs were
 * overlapping with static IDs.
 * 
 *    Rev 1.42   Feb 24 1997 18:30:18   tomitowx
 * multiple modedescriptor support
 * 
 *    Rev 1.41   07 Feb 1997 15:33:58   EHOWARDX
 * Changed H245DelCapDescriptor to match changes to set_cap_descriptor.
 * 
 *    Rev 1.40   27 Jan 1997 12:40:16   MANDREWS
 * 
 * Fixed warnings.
 * 
 *    Rev 1.39   09 Jan 1997 19:17:04   EHOWARDX
 * 
 * Initialize lError to H245_ERROR_OK to prevent "may be uninitialized"
 * warning.
 * 
 *    Rev 1.38   19 Dec 1996 17:18:50   EHOWARDX
 * Changed to use h245asn1.h definitions instead of _setof3 and _setof8.
 * 
 *    Rev 1.37   12 Dec 1996 15:57:22   EHOWARDX
 * Master Slave Determination kludge.
 * 
 *    Rev 1.36   11 Dec 1996 13:55:44   SBELL1
 * Changed H245Init parameters.
 * 
 *    Rev 1.35   17 Oct 1996 18:17:36   EHOWARDX
 * Changed general string to always be Unicode.
 * 
 *    Rev 1.34   14 Oct 1996 14:01:26   EHOWARDX
 * Unicode changes.
 * 
 *    Rev 1.33   11 Oct 1996 15:19:56   EHOWARDX
 * Fixed H245CopyCap() bug.
 * 
 *    Rev 1.32   28 Aug 1996 11:37:10   EHOWARDX
 * const changes.
 * 
 *    Rev 1.31   19 Aug 1996 16:28:36   EHOWARDX
 * H245CommunicationModeResponse/H245CommunicationModeCommand bug fixes.
 * 
 *    Rev 1.30   15 Aug 1996 15:19:46   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 * 
 *    Rev 1.29   08 Aug 1996 16:02:58   EHOWARDX
 * 
 * Eliminated api_vers.h.
 * Changed H245Init Debug trace to eliminate API_VERSION.
 * 
 *    Rev 1.28   19 Jul 1996 12:48:22   EHOWARDX
 * 
 * Multipoint clean-up.
 * 
 *    Rev 1.27   01 Jul 1996 22:13:42   EHOWARDX
 * 
 * Added Conference and CommunicationMode structures and functions.
 * 
 *    Rev 1.26   18 Jun 1996 14:53:16   EHOWARDX
 * Eliminated Channel parameter to MaintenanceLoopRelease.
 * Made Multiplex Capability mandatory -- H245SendTermCaps now returns
 * H245_ERROR_NO_MUX_CAPS if no Multiplex Capability has been defined.
 * 
 *    Rev 1.25   14 Jun 1996 18:57:38   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.24   10 Jun 1996 16:59:02   EHOWARDX
 * Moved init/shutdown of submodules to CreateInstance/InstanceUnlock.
 * 
 *    Rev 1.23   06 Jun 1996 18:50:10   EHOWARDX
 * Equivalent of H.324 bugs #808 and 875 fixed.
 * 
 *    Rev 1.22   05 Jun 1996 17:16:48   EHOWARDX
 * MaintenanceLoop bug fix.
 * 
 *    Rev 1.21   04 Jun 1996 13:56:42   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.20   30 May 1996 23:38:52   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.19   29 May 1996 16:08:04   unknown
 * Fixed bug in copying nonstandard identifiers.
 * 
 *    Rev 1.18   29 May 1996 15:19:48   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.17   28 May 1996 14:25:12   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.16   21 May 1996 15:46:54   EHOWARDX
 * Fixed bugs in NonStandard messages using object identifier.
 *
 *    Rev 1.15   20 May 1996 22:17:54   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.14   20 May 1996 14:35:12   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.13   17 May 1996 14:53:38   EHOWARDX
 * Added calls to StartSystemClose() and EndSystemClose().
 *
 *    Rev 1.12   16 May 1996 19:40:30   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.11   16 May 1996 16:36:10   EHOWARDX
 * Fixed typo in H245SetCapDescriptor.
 *
 *    Rev 1.10   16 May 1996 16:14:06   EHOWARDX
 * Fixed backwards-compatibility problem in H245SetLocalCap
 * (CapId of zero should result in dynamically-allocated cap id being used)
 *
 *    Rev 1.9   16 May 1996 16:03:44   EHOWARDX
 * Fixed typo in H245SetCapDescriptor.
 *
 *    Rev 1.8   16 May 1996 15:58:32   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.7   15 May 1996 21:49:46   unknown
 * Added call to InstanceLock() to increment lock count before call
 * to InstanceDelete() in H245EndConnectionPhase2().
 *
 *    Rev 1.6   15 May 1996 19:54:02   unknown
 * Fixed H245SetCapDescriptor.
 *
 *    Rev 1.5   14 May 1996 16:56:22   EHOWARDX
 * Last minute change from H245_IND_CAPDESC_T to H245_TOTCAPDESC_T.
 * H245EnumCaps() callback now uses H245_TOTCAPDESC_T instead
 * of separate H245_CAPDESCID_T and H245_CAPDESC_T for consistency.
 *
 *    Rev 1.4   14 May 1996 15:55:44   EHOWARDX
 * Added mux cap handling to H245DelLocalCap.
 *
 *    Rev 1.3   14 May 1996 14:06:06   EHOWARDX
 * Fixed abort from H245EnumCaps - if Cap Callback returns non-zero,
 * Cap Desc Callback is never called.
 *
 *    Rev 1.2   13 May 1996 23:16:42   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.1   11 May 1996 20:32:52   EHOWARDX
 * Checking in for the night...
 *
 *    Rev 1.0   09 May 1996 21:06:06   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.25.1.10   09 May 1996 19:31:02   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.25.1.9   01 May 1996 19:31:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address types to H245_xxx.
 *
 *    Rev 1.25.1.8   27 Apr 1996 21:09:20   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.25.1.7   25 Apr 1996 20:06:26   EHOWARDX
 * Moved setting of EndSessionPdu in EndSessionPhase1 to before call to api_fs
 *
 *    Rev 1.25.1.6   25 Apr 1996 17:57:00   EHOWARDX
 * Added dwTxPort argument to H245OpenChannel().
 *
 *    Rev 1.25.1.5   25 Apr 1996 16:51:00   EHOWARDX
 * Function changes as per H.245 API Changes spec.
 *
 *    Rev 1.25.1.4   24 Apr 1996 20:54:32   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.25.1.3   19 Apr 1996 12:54:40   EHOWARDX
 * Updated to 1.30
 *
 *    Rev 1.25.1.2   15 Apr 1996 15:10:48   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.25.1.1   03 Apr 1996 17:12:50   EHOWARDX
 * Integrated latest H.323 changes.
 *
 *    Rev 1.25.1.0   03 Apr 1996 15:53:42   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.20   27 Mar 1996 15:25:34   cjutzi
 * - fixed a bug from this morning checkin dynamically allocating
 *   pdu's.. free_mux_tbl was getting called after pdu was free'd..
 *   this was a problem since the mux table pointer was in the pdu
 *
 *    Rev 1.19   27 Mar 1996 08:37:08   cjutzi
 *
 * - removed PDU from stack.. made them dynamically allocated
 *
 *    Rev 1.18   20 Mar 1996 14:47:32   cjutzi
 * - added ERROR H245_ERROR_NO_CAPDESC to SendTermCaps.
 *
 *    Rev 1.17   18 Mar 1996 15:23:16   cjutzi
 *
 *
 *
 *    Rev 1.16   13 Mar 1996 09:15:44   cjutzi
 *
 * - changed LLPCRITICAL_SECTION to CRITICAL_SECTION *
 *
 *    Rev 1.15   12 Mar 1996 15:51:48   cjutzi
 *
 * - implemented locking
 * - fixed callback bug w/ clenaup on term caps..
 * - implemented End Session
 * - fixed shutdown
 *
 *    Rev 1.14   08 Mar 1996 14:02:48   cjutzi
 *
 * - removed H245SetSimultaneous stuff..
 * - added H245SetCapDescriptor Stuff..
 * - completeed MuxTable Entry Stuff.
 * - required H223 -or- some portion of MuxCapbilities to be
 *   there before you issue SendCaps..
 * - NOTE: need to inforce the Simultaneous capabilities in
 *   the same mannor..
 *
 *    Rev 1.13   05 Mar 1996 17:35:38   cjutzi
 *
 * - implemented SendMultiplexTable..
 * - removed bcopy/bzero and changed free call
 * - added master slave indication
 *
 *    Rev 1.12   01 Mar 1996 13:48:24   cjutzi
 *
 * - added hani's new fsm id's
 * - added some support for release on close request.
 *
 *    Rev 1.11   29 Feb 1996 17:27:10   cjutzi
 *
 * - bi-directional channel working..
 *
 *    Rev 1.10   29 Feb 1996 08:35:52   cjutzi
 *
 * - added p_ossWorld to initialization
 *
 *    Rev 1.9   27 Feb 1996 13:30:18   cjutzi
 *
 * - fixed master slave problem with conf_ind and tracker type
 * - removed RSP_LCSE in close channel resp
 *
 *    Rev 1.8   26 Feb 1996 17:23:18   cjutzi
 *
 * - MiscCommand API added
 * - Fixed Assert for H245Init.. was not NULL'n out the pointers for the
 *   context blocks..
 *
 *    Rev 1.7   26 Feb 1996 11:05:16   cjutzi
 *
 * - added simultaneous caps.. and fixed bugs..
 *   lot's of changes..
 *
 *    Rev 1.6   16 Feb 1996 13:01:08   cjutzi
 *
 * - got open / close / request close working in both directions.
 *
 *    Rev 1.5   15 Feb 1996 14:42:54   cjutzi
 *
 * - fixed trace level bind w/ Instance.. no other change but had to
 *   add when h245deb.c when in..
 *
 *
 *    Rev 1.4   15 Feb 1996 10:50:54   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - changed callback or IND_OPEN
 * - changed constants IND_OPEN/IND_OPEN_NEEDRSP etc..
 * - cleaned up the open.. (not complete yet.. )
 *
 *    Rev 1.3   09 Feb 1996 16:58:36   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/**** NOTE:                                                             *****/
/****           Headers are documented, however they may or may not     *****/
/****   coorispond to reality.  See the H245Spec.doc from Intel for the *****/
/****   current :-> H245 specification                                  *****/
/****                                                                   *****/
/**** DISCLAMER:                                                        *****/
/****                                                                   *****/
/****   Since this code wasn't developed in Word 7.0, I am fully        *****/
/****   responsable for all spelling mistakes in the comments. Please   *****/
/****   disregard the spelling mistakes.. or fix them, if you are       *****/
/****   currently modifying the code.                                   *****/
/****                                                                   *****/
/****                           - Thankyou                              *****/
/****                                                                   *****/
/****                                   Curt Jutzi                      *****/
/****                                   Oregon, USA                     *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>     /* stuff.. like typedef's .. */
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#define H245DLL_EXPORT
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

#include "api_util.x"
#include "pdu.x"
#include "fsmexpor.h"
#include "api_debu.x"
#include "sr_api.h"
#include "h245deb.x"



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245Init
 *
 * DESCRIPTION
 *
 *       H245_INST_T  H245Init (
 *                              H245_CONF_T               Configuration,
 *                              DWORD                     dwH245PhysId,
 *                              DWORD                     dwLinkLayerPhysId,
 *                              DWORD                     dwPreserved,
 *                              H245_CONF_IND_CALLBACK_T  Callback
 *                              )
 *      Description:
 *
 *              Called to create an H.245 instance and its related sublayers
 *              (e.g., SRP). This function must be called before any other
 *              API calls may be called  The current H.245 implementation can
 *              only have, at most, one client. Therefore H245Init can only be
 *              called once per physical ID.
 *      Input
 *
 *              Configuration   Indicates the type of configuration the client
 *                              wishes to establish, e.g.  H.324, H.323, H.310,
 *                              or DSVD.
 *              dwH245PhysId    Parameter identifying the H245 entry
 *              pdwLinkLayerPhysId
 *                              Output parameter identifying the linkLayer 
 *                              entry.
 *              dwPreserved     Parameter that may be used by H.245 client to
 *                              provide context, passed back to client in all
 *                              confirms and indications.
 *              Callback        Callback routine supplied by the client which
 *                              will be used by the H.245 subsystem to convey
 *                              confirm and indication messages back to the
 *                              client.
 *      Call Type:
 *
 *              Synchronous
 *
 *      Return Values:
 *
 *              Return value of 0 indicates Failure
 *              Return value of non 0 is a valid H245_INST_T
 *
 *      Errors:
 *              N/A
 *
 *      See Also:
 *              H245EndSession
 *              H245Shutdown
 *
 *
 *****************************************************************************/

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwH245PhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         unsigned long            dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;

  H245TRACE(dwH245PhysId,4,"H245Init(%d, 0x%x, 0x%x, 0x%x, %d) <-",
            Configuration, dwH245PhysId, dwPreserved, CallBack, byTerminalType);

  switch (Configuration)
  {
  case H245_CONF_H324:
  case H245_CONF_H323:
    break;

  default:
    H245TRACE(dwH245PhysId,1,"H245Init -> Invalid Configuration %d", Configuration);
    return H245_INVALID_ID;
  } // switch

  if (CallBack == NULL)
  {
    H245TRACE(dwH245PhysId,1,"H245Init -> Null CallBack");
    return H245_INVALID_ID;
  }

  /* see if this physical identifier has been initialized already */
  // Send down H245PhysId that was input.
  pInstance = InstanceCreate(dwH245PhysId, Configuration);
  if (pInstance == NULL)
  {
    return H245_INVALID_ID;
  }

  // Get the linkLayer PhysId.
  *pdwLinkLayerPhysId = pInstance->SendReceive.hLinkLayerInstance;

  // Initialize instance API structure
  pInstance->API.dwPreserved     = dwPreserved;
  pInstance->API.ConfIndCallBack = CallBack;

  // Initialize instance FSM structure
  pInstance->StateMachine.sv_TT     = byTerminalType;
  pInstance->StateMachine.sv_STATUS = INDETERMINATE;

  H245TRACE(pInstance->dwInst,4,"H245Init -> %d", pInstance->dwInst);
  lError = pInstance->dwInst;
  InstanceUnlock(pInstance);
  return lError;
} // H245Init()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245GetInstanceId
 *
 * DESCRIPTION:
 *
 *      H245_INST_T H245GetInstanceId   (DWORD  dwPhysId)
 *
 *      Description:
 *              Called to get dwInst from H.245 for a given PhysId
 *
 *      Input
 *              dwPhysId        Identifier for physical device used by
 *                              instance
 *
 *      Output
 *              dwInst          Instance handle for the given physical Id
 *                              passed.  If there was an error the return
 *                              value will be 0
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              dwInst if success
 *              0 if failure
 *
 *      Errors:
 *              N/A
 *
 *      See Also:
 *              H245Init
 *
 *****************************************************************************/

H245DLL H245_INST_T
H245GetInstanceId       (unsigned long          dwPhysicalId)
{
  register struct InstanceStruct *pInstance;
  H245_INST_T                     dwInst;

  H245TRACE (0,4,"H245GetInstanceId <-");

  pInstance = InstanceFind(dwPhysicalId);
  if (pInstance)
  {
    dwInst = pInstance->dwInst;
    InstanceUnlock(pInstance);
    H245TRACE (dwInst,4,"H245GetInstanceId(%d) -> %d", dwPhysicalId, dwInst);
    return dwInst;
  }

  H245TRACE (0,1,"H245GetInstanceId <- failed");
  return H245_INVALID_ID;
} // H245GetInstanceId()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245EndSession
 *
 * DESCRIPTION
 *
 *              Yes.. this should be explained.. Since Send Receive needs
 *              to flush some buffers and send out an End Session.. what we've
 *              hopefully done is a 2 phase shut down...
 *
 *              call StartSessionClose which initiates the flush..
 *              when flush is complete EndSessionPhase1 is called..
 *              The end session pdu is then placed in the send queue..
 *              When the End Session Pdu is sent.. the EndSession Phase
 *              2 is called, and the result is sent up to the client..
 *
 *              Hope that helps..
 *
 *
 *      HRESULT H245EndSession ( H245_INST_T           dwInst,
 *                                 H245_ENDSESSION_T     Mode,
 *                                 H245_NONSTANDARD_T   *pNonStd (*optional*)
 *                               )
 *
 *      Description:
 *              Called to shutdown the peer to peer session between this H.245
 *              session and the remote peers H.245 layer.
 *
 *              It will terminate by issuing an EndSession command to the
 *              remote side and call end session for all the H.245 subsystems.
 *              All resources are returned; therefore no further action is
 *              permitted, except H245ShutDown until another H245Init API call
 *              is made.
 *
 *      input
 *              dwInst          Instance handle returned by H245Init
 *              Mode            Mode which the client wishes to terminat
 *                              the session
 *              pNonStd         If the mode is non standard this is the non
 *                              standard parameter passes to the remote client.
 *                              This parameter is optional, and should be set
 *                              to NULL if not used
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_NOT_CONNECTED
 *      See Also:
 *              H245Shutdown
 *              H245Init
 *
 *****************************************************************************/

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        )
{
  register struct InstanceStruct *pInstance;
  register MltmdSystmCntrlMssg   *pPdu;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245EndSession <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* system should be in either connecting or connected */

  switch (pInstance->API.SystemState)
  {
  case APIST_Connecting:
  case APIST_Connected:
    break;

  default:
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOT_CONNECTED;
  }

  // Allocate the PDU buffer
  pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_NOMEM));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  // Build the PDU
  lError = pdu_cmd_end_session (pPdu, Mode, pNonStd);

  if (lError == H245_ERROR_OK)
  {
    // Send the PDU
    lError = FsmOutgoing(pInstance, pPdu, 0);
  }

  // Free the PDU buffer
  H245_free(pPdu);

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(lError));
  }
  else
  {
    H245TRACE (dwInst,4,"H245EndSession -> OK");
    pInstance->API.SystemState = APIST_Disconnected;
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245EndSession()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245ShutDown
 *
 * DESCRIPTION
 *
 *      HRESULT  H245Shutdown ( H245_INST_T      dwInst);
 *
 *      Description:
 *
 *              Called to terminate the specified instance of H.245. If there
 *              is currently an active session (see H245Init) then the H.245
 *              subsystem will issue an EndSession to the other side and wait
 *              for H.245 sublayer termination notifications before it queues
 *              Callback confirm.
 *
 *              This call will force the client to issue another H245Init
 *              before it can use any of the H.245 API functions.
 *
 *      Input
 *              dwInst                  Instance handle returned by H245Init
 *
 *      Call Type:
 *              asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245Init
 *
 *****************************************************************************/

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst)
{
  register struct InstanceStruct *pInstance;
  register HRESULT                lError;

  H245TRACE (dwInst,4,"H245ShutDown <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ShutDown -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  switch (pInstance->API.SystemState)
  {
  case APIST_Connecting:
  case APIST_Connected:
    lError = H245EndSession(dwInst,H245_ENDSESSION_DISCONNECT,NULL);
    break;

  default:
    lError = H245_ERROR_OK;
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ShutDown -> %s", map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ShutDown -> OK");
  InstanceDelete  (pInstance);
  return H245_ERROR_OK;
} // H245ShutDown()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245InitMasterSlave
 *
 * DESCRIPTION
 *
 *      HRESULT  H245InitMasterSlave ( H245_INST_T       dwInst,
 *                                    DWORD             dwTransId )
 *
 *      Description:
 *              Called to initiate the H.245 master slave negotiation.
 *              Upon completion of the negotiation the local client will
 *              receive an H245_CONF_INIT_MSTSLV message indicating the
 *              result of the negotiation.
 *      Input
 *              dwInst          Instance handle returned by
 *                              H245GetInstanceId
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous response to
 *                              this call.
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_INIT_MSTSLV
 *
 *      Errors:
 *              H245_ERROR_OK           Master Slave Determination started
 *              H245_ERROR_INPROCESS    Master Slave Determination currently
 *                                      in process
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INPROCESS    In process
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245Init
 *
 *      callbacks
 *              H245_IND_MSTSLV
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        )
{
  struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu = NULL;

  /* check for valid instance handle */

  H245TRACE (dwInst,4,"H245InitMasterSlave <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* if the transaction is in process.. tell client */
  if (pInstance->API.MasterSlave == APIMS_InProcess)
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_INPROCESS));
      InstanceUnlock(pInstance);
      return H245_ERROR_INPROCESS;
    }

  /* if the transaction is already complete */
  if (pInstance->API.MasterSlave != APIMS_Undef)
  {
    if (pInstance->API.ConfIndCallBack)
    {
      H245_CONF_IND_T    confirm_ind_event;
      confirm_ind_event.Kind = H245_CONF;
      confirm_ind_event.u.Confirm.Confirm       = H245_CONF_INIT_MSTSLV;
      confirm_ind_event.u.Confirm.dwPreserved   = pInstance->API.dwPreserved;
      confirm_ind_event.u.Confirm.dwTransId     = dwTransId;
      confirm_ind_event.u.Confirm.Error         = H245_ERROR_OK;
      confirm_ind_event.u.Confirm.u.ConfMstSlv  =
        (pInstance->API.MasterSlave == APIMS_Master) ? H245_MASTER : H245_SLAVE;
      (*pInstance->API.ConfIndCallBack)(&confirm_ind_event, NULL);
    }
    H245TRACE (dwInst,4,"H245InitMasterSlave -> OK");
    InstanceUnlock(pInstance);
    return H245_ERROR_OK;
  }

  /* get somthing to keep track of what the heck you're doing.. */
  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_MSTSLV_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_UNDEF,
                                        API_CH_TYPE_UNDEF,
                                        0,
                                        H245_INVALID_CHANNEL,
                                        H245_INVALID_CHANNEL,
                                        0)))
    {
      H245TRACE(dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  /* set master slave in process */
  pInstance->API.SystemState = APIST_Connecting;
  pInstance->API.MasterSlave = APIMS_InProcess;

  memset(pPdu, 0, sizeof(*pPdu));
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu->u.MltmdSystmCntrlMssg_rqst.choice = masterSlaveDetermination_chosen;

  lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
  H245_free(pPdu);
  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245InitMasterSlave -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245InitMasterSlave()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SetLocalCap
 *
 * DESCRIPTION
 *
 *       HRESULT H245SetLocalCap (
 *                              H245_INST_T      dwInst,
 *                              H245_TOTCAP_T   *pTotCap,
 *                              H245_CAPID_T    *pCapId
 *                              )
 *
 *      Description:
 *              This function allows the client to define a specific
 *              capability to the H.245 subsystem. When this function is
 *              called a new capability entry is made in the local capability
 *              table.  The returned value in *pCapId can be used by the client
 *              to refer to that registered capability.  NULL in the *pCapId
 *              is valid.
 *
 *              This call is used for both client (Audio / Video / Data / Mux)
 *              capabilities.  It is not used for setting capability descriptors.
 *
 *      Note:
 *               This function does not communicate this update to the
 *                remote peer until the client calls H245SendTermCaps.
 *               pTotCap->CapId is of no significance in this call.
 *
 *              pTotCap->CapId is of no significance in this call and should
 *              be set to 0
 *
 *              if DataType of H245_DATA_MUX  is used  (i.e. in setting the
 *              mux table capabilities) No capid is returned, and it can not
 *              be used in H245SetCapDescritptor  api call.
 *
 *      Input
 *              dwInst  Instance handle returned by GetInstanceId
 *                      pTotCap Capability set defining the capability
 *
 *              Note:   pTotCap->CapId is of no significance in this call.
 *
 *      output
 *              pCapId  Capability id which client can use to reference
 *                      this capability in the H.245 subsystem.  This can
 *                      be NULL, in this case nothing is returned.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              If pCap is not null, the local cap table id is returned
 *              to the client in this parameter.
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        There was an invalid parameter passed
 *              H245_ERROR_MAXTBL       Entry not made because local cap table
 *                                      is full
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245DelLocalCap
 *              H245EnumCaps
 *              H245SetCapDescriptor
 *
 *
 * ASSUMPTION:
 *                      pTotCap->CapId  will be set to H245_INVALID_CAPID
 *                      pTotCap->Dir    will be set
 *
 *****************************************************************************/

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245SetLocalCap <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* check for valid parameters */
  if (pTotCap == NULL ||
      pCapId  == NULL ||
	  ((*pCapId > H245_MAX_CAPID) && (*pCapId != H245_INVALID_CAPID)) ||
      pTotCap->Dir < H245_CAPDIR_LCLRX   ||
      pTotCap->Dir > H245_CAPDIR_LCLRXTX ||
      pTotCap->ClientType < H245_CLIENT_NONSTD ||
      pTotCap->ClientType > H245_CLIENT_MUX_H2250)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  // Don't trust the user filled-in data type!
  pTotCap->DataType = DataTypeMap[pTotCap->ClientType];

  /* if it's a MUX type handle here */
  if (pTotCap->DataType == H245_DATA_MUX)
  {
    // Add multiplex capability
    if (pTermCapSet->bit_mask & multiplexCapability_present)
    {
      del_mux_cap(pTermCapSet);
    }

    *pCapId = pTotCap->CapId = 0;
    lError = set_mux_cap(pInstance, pTermCapSet, pTotCap);

#if defined(DBG)
    if (lError == H245_ERROR_OK)
    {
      // Validate mux capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad mux capability - delete it
        del_mux_cap(pTermCapSet);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DBG)
  }
  else if (*pCapId == 0 || *pCapId == H245_INVALID_CAPID)
  {
    // Assign the next never-used cap id
    if (pInstance->API.LocalCapIdNum == H245_INVALID_CAPID)
    {
      // All possible capability identifiers have been assigned
      H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_MAXTBL));
      InstanceUnlock(pInstance);
      return H245_ERROR_MAXTBL;
    }
    *pCapId = pInstance->API.LocalCapIdNum;

    /* insert in the new capability in the local capability set table */
    pTotCap->CapId = *pCapId;
    lError = set_capability(pInstance, pTermCapSet, pTotCap);

#if defined(DBG)
    if (lError == H245_ERROR_OK)
    {
      // Validate capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad capability - delete it
        H245DelLocalCap(dwInst, *pCapId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DBG)

    if (lError == H245_ERROR_OK)
      pInstance->API.LocalCapIdNum++;
  }
  else
  {
    /* insert in the new capability in the local capability set table */
    pTotCap->CapId = *pCapId;
    lError = set_capability(pInstance, pTermCapSet, pTotCap);

#if defined(DBG)
    if (lError == H245_ERROR_OK)
    {
      // Validate capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad capability - delete it
        H245DelLocalCap(dwInst, *pCapId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DBG)
  }

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(lError));
    pTotCap->CapId = *pCapId = H245_INVALID_CAPID;
  }
  else
  {
    H245TRACE (dwInst,4,"H245SetLocalCap -> OK");
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245SetLocalCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245DelLocalCap
 *
 * DESCRIPTION  Delete Local Cap simply disables the cap.. it
 *              will not be updated until the client issues
 *              H245SendTermCaps
 *
 *
 *       HRESULT H245DelLocalCap(
 *                              H245_INST_T     dwInst,
 *                              H245_CAPID_T    CapId
 *                              )
 *
 *      Description:
 *              This function allows the client to delete a specific
 *              capability id in the H.245 subsystem.
 *
 *              Note: This function does not communicate this update
 *              to the remote peer until the client calls H245SendTermCaps.
 *
 *      Input
 *              dwInst  Instance handle returned by H245GetInstanceId
 *              CapId   Cap Id the client wishes to remove from the
 *              capability table.
 *
 *              If an error occurs no action is taken and the CapId the
 *              client wished to delete is not changed.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK           Capability deleted
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245SendTermCaps
 *              H245EnumCaps
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  CapabilityTableLink             pCapLink;
  HRESULT                         lError = H245_ERROR_OK;

  H245TRACE (dwInst,4,"H245DelLocalCap <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245DelLocalCap -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  if (CapId == 0)
  {
    // Delete multiplex capability
    del_mux_cap(pTermCapSet);
  }
  else
  {
    /* (TBC) if I delete my capability id.. what about simultaneous caps ?? */
    /* should I go through the list and deactivate them ??                */
    pCapLink = find_capid_by_entrynumber (pTermCapSet, CapId);
    if (pCapLink)
    {
      // Delete terminal capability
      disable_cap_link (pCapLink);
    }
    else
    {
      lError = H245_ERROR_PARAM;
    }
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245DelLocalCap -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245DelLocalCap -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245DelLocalCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SetCapDescriptor
 *
 * DESCRIPTION
 *
 *      HRESULT H245SetCapDescriptor (
 *                                  H245_INST_T       dwInst,
 *                                  H245_CAPDESC_T   *pCapDesc,
 *                                  H245_CAPDESCID_T *pCapDescId (* Optional *)
 *                                  )
 *      Description:
 *              This procedure is called to set local capability descriptors.
 *              It will return a capability descriptor id in the parameter
 *              *pCapDescId if it is non null.
 *
 *              Note:
 *                These capabilities are communicated via the H245SendTermCaps
 *                API call.  Any updates to the CapDescriptor table (either
 *                additions or deletions ) will not be communicated to the
 *                remote side until the H245SendTermCaps call is made.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              CapDesc         This is the capability Descriptor you wish
 *                              to set
 *      Output
 *              pCapDescId      optional: Capability id that will be returned.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_CAPID Capid used in CapDesc was not
 *                                       registred
 *              H245_ERROR_MAXTB         Out of table space to store Descriptor
 *              H245_ERROR_PARAM         Descriptor is too long or not valid
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_INST
 *
 *      See Also:
 *              H245DelCapDescriptor
 *              H245SendTermCaps
 *
 * ASSUMES:
 *              SimCapId is the array entry point in the apabilityDescriptors
 *              array.. this has a limitation, in that you can never wrap the
 *              array at 256.. this will be cleaned up when array is turned into
 *              linked list.
 *
 *****************************************************************************/

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245SetCapDescriptor <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SetCapDescriptor -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* must have capdescriptor &&   */
  /* length must be less than 256 */
  if (pCapDesc == NULL ||
      pCapDesc->Length >= 256 ||
      pCapDescId == NULL)
  {
    H245TRACE (dwInst,1,"H245SetCapDescriptor -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  if (*pCapDescId >= 256)
  {
    // Assign the next never-used cap id
    if (pInstance->API.LocalCapDescIdNum >= 256)
    {
      // All possible capability identifiers have been assigned
      H245TRACE (dwInst,1,"H245CapDescriptor -> %s",map_api_error(H245_ERROR_MAXTBL));
      InstanceUnlock(pInstance);
      return H245_ERROR_MAXTBL;
    }
    *pCapDescId = pInstance->API.LocalCapDescIdNum;

    /* insert in the new capability descriptor in the local capability descriptor table */
    lError = set_cap_descriptor(pInstance, pCapDesc, pCapDescId,
                                  &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
#if defined(DBG)
    if (lError == H245_ERROR_OK)
    {
      // Validate Capability Descriptor
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Capability Descriptor Invalid - delete it
        H245DelCapDescriptor(dwInst, *pCapDescId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DBG)
    if (lError == H245_ERROR_OK)
      pInstance->API.LocalCapDescIdNum++;
  }
  else
  {
    /* insert in the new capability in the local capability set table */
    lError = set_cap_descriptor(pInstance, pCapDesc, pCapDescId,
                                  &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
#if defined(DBG)
    if (lError == H245_ERROR_OK)
    {
      // Validate Capability Descriptor
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Capability Descriptor Invalid - delete it
        H245DelCapDescriptor(dwInst, *pCapDescId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DBG)
  }

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245CapDescriptor -> %s",map_api_error(lError));
    *pCapDescId = H245_INVALID_CAPDESCID;
  }
  else
  {
    H245TRACE (dwInst,4,"H245CapDescriptor -> OK");
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245SetCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245DelCapDescriptor
 *
 * DESCRIPTION
 *
 *       HRESULT H245DelCapDescriptor (
 *                                   H245_INST_T          dwInst,
 *                                   H245_CAPDESCID_T     CapDescId
 *                                   )
 *      Description:
 *              This procedure is called to delete local capability descriptors.
 *
 *              Note:
 *                      These capabilities are communicated via the
 *                      H245SendTermCaps API call.  Any updates to the
 *                      CapDescriptor table (either additions or deletions )
 *                      will not be communicated to the remote side until the
 *                      H245SendTermCaps call is made.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              CapDescId       This is the capability Descriptor you wish
 *                              to delete
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_INST
 *
 *      See Also:
 *              H245SetCapDescriptor
 *              H245SendTermCaps
 *
 * ASSUMES:
 *
 *              SimCapId is the array entry point in the apabilityDescriptors
 *              array.. this has a limitation, in that you can never wrap the
 *              array at 256.. this will be cleaned up when array is turned into
 *              linked list.
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        )
{
  register struct InstanceStruct *pInstance;
  CapabilityDescriptor           *p_cap_desc;
  struct TerminalCapabilitySet   *pTermCapSet;
  unsigned int                    uId;
  H245TRACE (dwInst,4,"H245DelCapDescriptor <-");

  if (CapDescId >= 256)
  {
    H245TRACE(dwInst,1,"API:H24DelCapDescriptor -> Invalid cap desc id %d",CapDescId);
    return H245_ERROR_INVALID_CAPDESCID;
  }

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"API:H24DelCapDescriptor -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* get pointer to Capability Descriptor */
  p_cap_desc = NULL;
  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == CapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL ||
      p_cap_desc->smltnsCpblts == NULL ||
      (p_cap_desc->bit_mask & smltnsCpblts_present) == 0)
  {
    H245TRACE(dwInst,1,"API:H24DelCapDescriptor -> Invalid cap desc id %d",CapDescId);
    InstanceUnlock(pInstance);
    return H245_ERROR_INVALID_CAPDESCID;
  }

  /* free up the list */
  dealloc_simultaneous_cap (p_cap_desc);

  /* (TBC) what if you've removed the last simultaneous cap ? */

  /* in this case.. the count does not go down.. it simply    */
  /* removes the cap descriptor bit from the table..          */

  H245TRACE (dwInst,4,"H245DelCapDescriptor -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245DelCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SendTermCaps
 *
 * DESCRIPTION
 *
 *      HRESULT
 *      H245SendTermCaps (
 *                      H245_INST_T             dwInst,
 *                      DWORD                   dwTransId
 *                      )
 *
 *      Description:
 *
 *              Called to send terminal capabilities to the remote H.245 peer.
 *              When remote capabilities are receive the client will be
 *              notified by the H245_IND_CAP indication. When remote side has
 *              acknowledged the local terminal capabilities and has responded
 *              with their terminal capabilities the client will receive an
 *              H245_CONF_ TERMCAP.  Between H245Init and H245SendTermCap the
 *              client may call H245SetLocalCap to register capabilities.
 *              These capabilities will not be registered to the remote side
 *              until H245SendTermCap has been called.
 *
 *              Note: As required by the H245 specification, Mutliplex
 *                    capabilities, and Capability descriptors must be
 *                    loaded before the first capability PDU is sent.
 *
 *                    Once H245SendTermCap is called, any subsequent calls to
 *                    H245SetLocalTermCap will result in that capability being
 *                    communicated to the remote H.245 peer.
 *
 *      Input
 *              dwInst                  Instance handle returned by
 *                                      H245GetInstanceId
 *              dwTransId               User supplied object used to identify
 *                                      this request in the asynchronous
 *                                      response to this call.
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_TERMCAP
 *
 *      Errors:
 *              H245_ERROR_OK           Function succeeded
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *              H245_ERROR_NO_MUX_CAPS  no Mux capabilities have been set yet
 *              H245_ERROR_NO_CAPDESC   no Capability Descriptors have been set
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245Init
 *
 *      callbacks
 *
 *              H245_IND_CAP
 *              H245_IND_CAPDESC
 *              H245_IND_CAP_DEL
 *              H245_IND_CAPDESC_DEL
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        )
{
  struct InstanceStruct  *pInstance;
  Tracker_T              *pTracker;
  HRESULT                 lError;
  unsigned char			  TermCapData = TRUE;
  struct TerminalCapabilitySet_capabilityTable  TermCap = {0};

  H245TRACE(dwInst,4,"H245SendTermCaps <-");

  /* check for valid instance handle */

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* must have mux parameters set */
  if ((pInstance->API.PDU_LocalTermCap.TERMCAPSET.bit_mask & multiplexCapability_present) == 0)
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NO_MUX_CAPS));
      InstanceUnlock(pInstance);
      return H245_ERROR_NO_MUX_CAPS;
    }

  /* must have capability descriptors set */
  if (!(pInstance->API.PDU_LocalTermCap.TERMCAPSET.bit_mask & capabilityDescriptors_present))
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NO_CAPDESC));
      InstanceUnlock(pInstance);
      return H245_ERROR_NO_CAPDESC;
    }

  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_TERMCAP_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_UNDEF,
                                        API_CH_TYPE_UNDEF,
                                        0,
                                        H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                        0)))
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  pdu_req_termcap_set (&pInstance->API.PDU_LocalTermCap, 0);
  TermCap.next = pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable;
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable = &TermCap;
  TermCap.value.bit_mask = capability_present;
  TermCap.value.capabilityTableEntryNumber = pInstance->API.LocalCapIdNum;
  TermCap.value.capability.choice = Capability_nonStandard_chosen;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice = h221NonStandard_chosen;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35CountryCode	 = 0xB5;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35Extension	 = 0x42;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = 0x8080;
  TermCap.value.capability.u.Capability_nonStandard.data.value  = &TermCapData;
  TermCap.value.capability.u.Capability_nonStandard.data.length = sizeof(TermCapData);
  lError = FsmOutgoing(pInstance, &pInstance->API.PDU_LocalTermCap, PtrToUlong(pTracker));
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable = TermCap.next;

  if (lError != H245_ERROR_OK)
    H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(lError));
  else
    H245TRACE(dwInst,4,"H245SendTermCaps -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendTermCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245EnumCaps
 *
 * DESCRIPTION
 *
 *      HRESULT  H245EnumCaps (
 *                           DWORD                       dwInst,
 *                           DWORD                       dwTransId,
 *                           H245_CAPDIR_T               Direction,
 *                           H245_DATA_T                 DataType,
 *                           H245_CLIENT_T               ClientType,
 *                           H245_CAP_CALLBACK_T         CallBack
 *                           )
 *
 *
 *      Callback:
 *              CallBack (
 *                             DWORD                      dwTransId,
 *                             H245_TOTCAP_T             *pTotCap,
 *                       )
 *
 *      Description:
 *
 *              This function calls the H.245 client back for every
 *              capability as defined in the API call that complies with the
 *              request.  If the DataType parameter is set to 0 all of the
 *              caps types are returned (either local or remote based on the
 *              Direction parameter) no mater what is in the ClientType
 *              parameter. If the ClientType parameter is 0, it will return
 *              all of the capabilities of the given DataType.
 *
 *              The user supplied call back is called within the context of
 *              the call, therefor the call will be considered synchronous.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              Direction       Local/Remote Receive, Transmit, or Receive and
 *                              Transmit
 *              DataType        Type of data (Audio, Video, Data, etc.)
 *              ClientType      Client type (H.262, G.711. etc. ).
 *              dwTransId       User supplied object used to identify this
 *                              request in the callback.
 *
 *      CallBack Output
 *              dwTransId       Identical to dwTransId passed in H245EnumCaps
 *                              pTotCap Pointer one of the capabilities.
 *
 *              Note: TotCap parameter must be copied in the callback.  This
 *                    data structure is reused for each callback.
 *
 *      Call Type:
 *              Synchronous Callback - i.e. called back in the context of
 *                              the API call
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        One or more parameters were invalid
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle.
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245ReplLocalCap
 *
 *      callback
 *
 *              H245_IND_CAP
 *              H245_IND_CAPDESC
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         unsigned long            dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  CapabilityTableLink             pCapLink;
  int                             lcl_rmt;
  H245_TOTCAP_T                   totcap;
  int                             nResult = 0;

  H245TRACE (dwInst,4,"H245EnumCaps <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* check for callback routine */
  if (pfCapCallback == NULL && pfCapDescCallback == NULL)
    {
      H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* ok... check the direction.. either remote or local caps.. */
  switch (Direction)
  {
  case H245_CAPDIR_RMTRX:
  case H245_CAPDIR_RMTTX:
  case H245_CAPDIR_RMTRXTX:
    pTermCapSet = &pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
    lcl_rmt = H245_REMOTE;
    break;

  case H245_CAPDIR_LCLRX:
  case H245_CAPDIR_LCLTX:
  case H245_CAPDIR_LCLRXTX:
    pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
    lcl_rmt = H245_LOCAL;
    break;

  /* must be either local or remote */
  // case H245_CAPDIR_DONTCARE:
  default:
    H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  if (pfCapCallback)
  {
    if (pTermCapSet->bit_mask & multiplexCapability_present &&
        build_totcap_from_mux(&totcap, &pTermCapSet->multiplexCapability, Direction) == H245_ERROR_OK)
    {
      (*pfCapCallback)(dwTransId, &totcap);
    }

    if (ClientType == H245_CLIENT_DONTCARE)
    {
      if (DataType == H245_DATA_DONTCARE)
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // if
      else
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK &&
              totcap.DataType == DataType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // else
    } // if
    else
    {
      if (DataType == H245_DATA_DONTCARE)
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK &&
              totcap.ClientType == ClientType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          } /* if cap match */
        } // for
      } // if
      else
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap,pCapLink,lcl_rmt) == H245_ERROR_OK &&
              totcap.ClientType == ClientType &&
              totcap.DataType   == DataType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // else
    } // else
  } // if (pfCapCallback)

  if (pfCapDescCallback)
  {
    // Convert CapabilityDescriptor format to H245_CAPDESC_T format
    unsigned int                uCapDesc;
    register SmltnsCpbltsLink   pSimCap;
    register unsigned int       uAltCap;
    H245_TOTCAPDESC_T           TotCapDesc;

    for (uCapDesc = 0;
         uCapDesc < pTermCapSet->capabilityDescriptors.count && nResult == 0;
         ++uCapDesc)
    {
      if (pTermCapSet->capabilityDescriptors.value[uCapDesc].bit_mask & smltnsCpblts_present)
      {
        H245ASSERT(pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber <= 256);
        TotCapDesc.CapDesc.Length = 0;
        pSimCap = pTermCapSet->capabilityDescriptors.value[uCapDesc].smltnsCpblts;
        H245ASSERT(pSimCap != NULL);
        while (pSimCap)
        {
          if (TotCapDesc.CapDesc.Length >= H245_MAX_SIMCAPS)
          {
            H245TRACE (dwInst,1,"H245EnumCaps -> Number of simutaneous capabilities exceeds H245_MAX_SIMCAPS");
            InstanceUnlock(pInstance);
            return H245_ERROR_MAXTBL;
          }
          if (pSimCap->value.count > H245_MAX_ALTCAPS)
          {
            H245TRACE (dwInst,1,"H245EnumCaps -> Number of alternative capabilities exceeds H245_MAX_ALTCAPS");
            InstanceUnlock(pInstance);
            return H245_ERROR_MAXTBL;
          }
          TotCapDesc.CapDesc.SimCapArray[TotCapDesc.CapDesc.Length].Length = (WORD) pSimCap->value.count;
          for (uAltCap = 0; uAltCap < pSimCap->value.count; ++uAltCap)
          {
            TotCapDesc.CapDesc.SimCapArray[TotCapDesc.CapDesc.Length].AltCaps[uAltCap] = pSimCap->value.value[uAltCap];
          }
          TotCapDesc.CapDesc.Length++;
          pSimCap = pSimCap->next;
        } // while
        TotCapDesc.CapDescId = pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber;
        nResult = pfCapDescCallback(dwTransId, &TotCapDesc);
      } // if
    } // for
  } // if (pfCapDescCallback)

  H245TRACE (dwInst,4,"H245EnumCaps -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245EnumCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245GetCaps
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

# pragma warning( disable : 4100 )

static H245_TOTCAP_T * *      ppTotCapGlobal;
static unsigned long          dwTotCapLen;
static unsigned long          dwTotCapMax;
static H245_TOTCAPDESC_T * *  ppCapDescGlobal;
static unsigned long          dwCapDescLen;
static unsigned long          dwCapDescMax;
static HRESULT                dwGetCapsError;

static int
GetCapsCapCallback(unsigned long dwTransId, H245_TOTCAP_T *pTotCap)
{
  H245_TOTCAP_T *pNewCap;

  if (dwGetCapsError == H245_ERROR_OK)
  {
    if (dwTotCapLen >= dwTotCapMax)
    {
      dwGetCapsError = H245_ERROR_MAXTBL;
    }
    else
    {
      dwGetCapsError = H245CopyCap(&pNewCap, pTotCap);
      if (dwGetCapsError == H245_ERROR_OK)
      {
        *ppTotCapGlobal++ = pNewCap;
        ++dwTotCapLen;
      }
    }
  }

  return 0;
} // GetCapsCapCallback()

static int
GetCapsCapDescCallback(unsigned long dwTransId, H245_TOTCAPDESC_T *pCapDesc)
{
  H245_TOTCAPDESC_T *pNewCapDesc;

  if (dwGetCapsError == H245_ERROR_OK)
  {
    if (dwCapDescLen >= dwCapDescMax)
    {
      dwGetCapsError = H245_ERROR_MAXTBL;
    }
    else
    {
      dwGetCapsError = H245CopyCapDescriptor(&pNewCapDesc,pCapDesc);
      {
        *ppCapDescGlobal++ = pNewCapDesc;
        ++dwCapDescLen;
      }
    }
  }

  return 0;
} // GetCapsCapDescCallback()

# pragma warning( default : 4100 )

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T * *      ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T * *  ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        )
{
  register struct InstanceStruct *pInstance;
  H245_CAP_CALLBACK_T           CapCallback;
  H245_CAPDESC_CALLBACK_T       CapDescCallback;

  H245TRACE (dwInst,4,"H245GetCaps <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245GetCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  dwTotCapLen     = 0;
  if (ppTotCap == NULL || pdwTotCapLen == NULL || *pdwTotCapLen == 0)
  {
    CapCallback = NULL;
  }
  else
  {
    CapCallback     = GetCapsCapCallback;
    ppTotCapGlobal  = ppTotCap;
    dwTotCapMax     = *pdwTotCapLen;
  }

  dwCapDescLen    = 0;
  if (ppCapDesc == NULL || pdwCapDescLen == NULL || *pdwCapDescLen == 0)
  {
    CapDescCallback = NULL;
  }
  else
  {
    CapDescCallback = GetCapsCapDescCallback;
    ppCapDescGlobal = ppCapDesc;
    dwCapDescMax    = *pdwCapDescLen;
  }

  /* check parameters */
  if (CapCallback == NULL && CapDescCallback == NULL)
  {
    H245TRACE (dwInst,1,"H245GetCaps -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  dwGetCapsError = H245_ERROR_OK;
  H245EnumCaps(dwInst,
               0,
               Direction,
               DataType,
               ClientType,
               CapCallback,
               CapDescCallback);

  if (pdwTotCapLen)
    *pdwTotCapLen = dwTotCapLen;
  if (pdwCapDescLen)
    *pdwCapDescLen = dwCapDescLen;
  if (dwGetCapsError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245GetCaps -> %s", map_api_error(dwGetCapsError));
  else
    H245TRACE (dwInst,4,"H245GetCaps -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245GetCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyCap
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T			**ppDestTotCap,
						 const H245_TOTCAP_T	*pTotCap)
{
  POBJECTID               pObjectTo;
  POBJECTID               pObjectFrom;
  HRESULT				  Status;

  if (ppDestTotCap == NULL)
	  return H245_ERROR_PARAM;
  
  *ppDestTotCap = NULL;
  
  if (pTotCap == NULL)
	  return H245_ERROR_PARAM;

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_NONSTD:
  case H245_CLIENT_VID_NONSTD:
  case H245_CLIENT_AUD_NONSTD:
  case H245_CLIENT_MUX_NONSTD:
    if (pTotCap->Cap.H245_NonStd.nonStandardIdentifier.choice == object_chosen)
    {
      *ppDestTotCap = H245_malloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245_NonStd.data.length +
        ObjectIdLength(&pTotCap->Cap.H245_NonStd.nonStandardIdentifier) * sizeof(OBJECTID));
    }
    else
    {
      *ppDestTotCap = H245_malloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245_NonStd.data.length);
    }
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    if (pTotCap->Cap.H245_NonStd.data.length != 0)
    {
      (*ppDestTotCap)->Cap.H245_NonStd.data.value = (unsigned char *)(*ppDestTotCap + 1);
      memcpy((*ppDestTotCap)->Cap.H245_NonStd.data.value,
             pTotCap->Cap.H245_NonStd.data.value,
             pTotCap->Cap.H245_NonStd.data.length);
    }
    else
    {
      (*ppDestTotCap)->Cap.H245_NonStd.data.value = NULL;
    }
    if (pTotCap->Cap.H245_NonStd.nonStandardIdentifier.choice == object_chosen &&
        pTotCap->Cap.H245_NonStd.nonStandardIdentifier.u.object != NULL)
    {
      pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
        pTotCap->Cap.H245_NonStd.data.length);
      (*ppDestTotCap)->Cap.H245_NonStd.nonStandardIdentifier.u.object = pObjectTo;
      pObjectFrom = pTotCap->Cap.H245_NonStd.nonStandardIdentifier.u.object;
      do
      {
        pObjectTo->value = pObjectFrom->value;
        pObjectTo->next  = pObjectTo + 1;
        ++pObjectTo;
      } while ((pObjectFrom = pObjectFrom->next) != NULL);
      --pObjectTo;
      pObjectTo->next = NULL;
    }
    break;

  case H245_CLIENT_DAT_NONSTD:
    if (pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen)
    {
      *ppDestTotCap = H245_malloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length +
        ObjectIdLength(&pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier) * sizeof(OBJECTID));
    }
    else
    {
      *ppDestTotCap = H245_malloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
    }
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    if (pTotCap->Cap.H245_NonStd.data.length != 0)
    {
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value =
        (unsigned char *)(*ppDestTotCap + 1);
      memcpy((*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value,
             pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value,
             pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
    }
    else
    {
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value = NULL;
    }
    if (pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen &&
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object != NULL)
    {
      pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object = pObjectTo;
      pObjectFrom = pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object;
      do
      {
        pObjectTo->value = pObjectFrom->value;
        pObjectTo->next  = pObjectTo + 1;
        ++pObjectTo;
      } while ((pObjectFrom = pObjectFrom->next) != NULL);
      --pObjectTo;
      pObjectTo->next = NULL;
    }
    break;

  case H245_CLIENT_DAT_T120:
  case H245_CLIENT_DAT_DSMCC:
  case H245_CLIENT_DAT_USERDATA:
  case H245_CLIENT_DAT_T434:
  case H245_CLIENT_DAT_H224:
  case H245_CLIENT_DAT_H222:
    if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.choice == object_chosen)
      {
        *ppDestTotCap = H245_malloc(sizeof(*pTotCap) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length +
          ObjectIdLength(&pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier) * sizeof(OBJECTID));
      }
      else
      {
        *ppDestTotCap = H245_malloc(sizeof(*pTotCap) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
      }
	  if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

      **ppDestTotCap = *pTotCap;
      if (pTotCap->Cap.H245_NonStd.data.length != 0)
      {
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value =
          (unsigned char *)(*ppDestTotCap + 1);
        memcpy((*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value,
               pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value,
               pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
      }
      else
      {
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value = NULL;
      }
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.choice == object_chosen &&
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object != NULL)
      {
        pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object = pObjectTo;
        pObjectFrom = pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object;
        do
        {
          pObjectTo->value = pObjectFrom->value;
          pObjectTo->next  = pObjectTo + 1;
          ++pObjectTo;
        } while ((pObjectFrom = pObjectFrom->next) != NULL);
        --pObjectTo;
        pObjectTo->next = NULL;
      }
    }
    else
    {
      *ppDestTotCap = H245_malloc(sizeof(*pTotCap));
	  if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;
      **ppDestTotCap = *pTotCap;
    }
    break;

  case H245_CLIENT_CONFERENCE:
  {
    NonStandardDataLink pList;
    NonStandardDataLink pFrom;
    NonStandardDataLink pTo;

	// Initialize Status here to prevent compiler warning "returning a possibly
	// uninitialized value"
	Status = H245_ERROR_NOMEM;

    *ppDestTotCap = H245_malloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;

    pList = NULL;
    (*ppDestTotCap)->Cap.H245Conference.nonStandardData = NULL;
    pFrom = pTotCap->Cap.H245Conference.nonStandardData;
    while (pFrom)
    {
      pTo = H245_malloc(sizeof(*pTo));
	  if (pTo == NULL)
		  Status = H245_ERROR_NOMEM;

      if (pTo != NULL)
      {
        Status = CopyNonStandardParameter(&pTo->value, &pFrom->value);
		if (Status != H245_ERROR_OK)
        {
          H245_free(pTo);
          pTo = NULL;
        }
      }
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          FreeNonStandardParameter(&pTo->value);
          H245_free(pTo);
        }
        H245_free(*ppDestTotCap);
		*ppDestTotCap = NULL;
        return Status;
      }
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = (*ppDestTotCap)->Cap.H245Conference.nonStandardData;
      (*ppDestTotCap)->Cap.H245Conference.nonStandardData = pTo;
    } // while
    break;
  }

  case H245_CLIENT_MUX_H222:
  {
    VCCapabilityLink pList = NULL;
    VCCapabilityLink pFrom;
    VCCapabilityLink pTo;

    *ppDestTotCap = H245_malloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability = NULL;
    pFrom = pTotCap->Cap.H245Mux_H222.vcCapability;
    while (pFrom)
    {
      pTo = H245_malloc(sizeof(*pTo));
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          H245_free(pTo);
        }
        H245_free(*ppDestTotCap);
        *ppDestTotCap = NULL;
        return H245_ERROR_NOMEM;
      }
      pTo->value = pFrom->value;
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability;
      (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability = pList;
    } // while
    break;
  }

  case H245_CLIENT_MUX_H2250:
    *ppDestTotCap = H245_malloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    Status = CopyH2250Cap(&(*ppDestTotCap)->Cap.H245Mux_H2250, &pTotCap->Cap.H245Mux_H2250);
    if (Status != H245_ERROR_OK)
	{
      H245_free(*ppDestTotCap);
	  *ppDestTotCap = NULL;
	  return Status;
    }
    break;

  default:
    *ppDestTotCap = H245_malloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;
    **ppDestTotCap = *pTotCap;
  } // switch

  return H245_ERROR_OK;
} // H245CopyCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeCap
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T *        pTotCap)
{
  if (pTotCap == NULL)
  {
    return H245_ERROR_PARAM;
  }

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_CONFERENCE:
    {
      NonStandardDataLink pList;
      NonStandardDataLink pTo;

      pList = pTotCap->Cap.H245Conference.nonStandardData;
      while (pList)
      {
        pTo = pList;
        pList = pList->next;
        FreeNonStandardParameter(&pTo->value);
        H245_free(pTo);
      }
    }
    break;

  case H245_CLIENT_MUX_H222:
    {
      VCCapabilityLink pList;
      VCCapabilityLink pTo;

      pList = pTotCap->Cap.H245Mux_H222.vcCapability;
      while (pList)
      {
        pTo = pList;
        pList = pList->next;
        H245_free(pTo);
      }
    }
    break;

  case H245_CLIENT_MUX_H2250:
    FreeH2250Cap(&pTotCap->Cap.H245Mux_H2250);
    break;

  } // switch
  H245_free(pTotCap);
  return 0;
} // H245FreeCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyCapDescriptor
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T			**ppDestCapDesc,
						 const H245_TOTCAPDESC_T	*pCapDesc)
{
  if (ppDestCapDesc == NULL)
	  return H245_ERROR_PARAM;
  
  *ppDestCapDesc = NULL;
  
  if (pCapDesc == NULL)
	  return H245_ERROR_PARAM;

  *ppDestCapDesc = H245_malloc(sizeof(**ppDestCapDesc));
  if (*ppDestCapDesc == NULL)
	  return H245_ERROR_NOMEM;

  **ppDestCapDesc = *pCapDesc;
  return H245_ERROR_OK;
} // H245CopyCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeCapDescriptor
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T *    pCapDesc)
{
  if (pCapDesc == NULL)
  {
    return H245_ERROR_PARAM;
  }

  H245_free(pCapDesc);
  return 0;
} // H245FreeCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyMux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *           pMux)
{
  register unsigned int   uLength;
  register H245_MUX_T    *pNew;
  H2250LCPs_nnStndrdLink  pList;
  H2250LCPs_nnStndrdLink  pFrom;
  H2250LCPs_nnStndrdLink  pTo;

  switch (pMux->Kind)
  {
  case H245_H222:
    uLength = sizeof(*pMux) +
      pMux->u.H222.programDescriptors.length +
      pMux->u.H222.streamDescriptors.length;
    pNew = H245_malloc(uLength);
    if (pNew != NULL)
    {
      *pNew = *pMux;
      if (pMux->u.H222.programDescriptors.length != 0)
      {
        pNew->u.H222.programDescriptors.value = (unsigned char *)(pNew + 1);
        memcpy(pNew->u.H222.programDescriptors.value,
               pMux->u.H222.programDescriptors.value,
               pMux->u.H222.programDescriptors.length);
      }
      else
      {
        pNew->u.H222.programDescriptors.value = NULL;
      }

      if (pMux->u.H222.streamDescriptors.length != 0)
      {
        pNew->u.H222.streamDescriptors.value = ((unsigned char *)pNew) +
          (uLength - pMux->u.H222.streamDescriptors.length);
        memcpy(pNew->u.H222.streamDescriptors.value,
               pMux->u.H222.streamDescriptors.value,
               pMux->u.H222.streamDescriptors.length);
      }
      else
      {
        pNew->u.H222.streamDescriptors.value = NULL;
      }
    }
    break;

  case H245_H223:
    pNew = H245_malloc(sizeof(*pMux) + pMux->u.H223.H223_NONSTD.data.length);
    if (pNew != NULL)
    {
      *pNew = *pMux;
      if (pMux->u.H223.H223_NONSTD.data.length != 0)
      {
        pNew->u.H223.H223_NONSTD.data.value = (unsigned char *)(pNew + 1);
        memcpy(pNew->u.H223.H223_NONSTD.data.value,
               pMux->u.H223.H223_NONSTD.data.value,
               pMux->u.H223.H223_NONSTD.data.length);
      }
      else
      {
        pNew->u.H223.H223_NONSTD.data.value = NULL;
      }
    }
    break;

  case H245_H2250:
  case H245_H2250ACK:
    // Caveat: assumes nonstandard list, mediaChannel and mediaControlChannel
    //         in same place in both structures
    if (pMux->u.H2250.mediaChannelPresent &&
        (pMux->u.H2250.mediaChannel.type == H245_IPSSR_UNICAST ||
         pMux->u.H2250.mediaChannel.type == H245_IPLSR_UNICAST) &&
        pMux->u.H2250.mediaChannel.u.ipSourceRoute.route != NULL &&
        pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount != 0)
    {
      if (pMux->u.H2250.mediaControlChannelPresent &&
          (pMux->u.H2250.mediaControlChannel.type == H245_IPSSR_UNICAST ||
           pMux->u.H2250.mediaControlChannel.type == H245_IPLSR_UNICAST) &&
          pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route != NULL &&
          pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount != 0)
      {
        unsigned int          uLength2;
        uLength  = pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount << 2;
        uLength2 = pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount << 2;
        pNew = H245_malloc(sizeof(*pMux) + uLength + uLength2);
        if (pNew != NULL)
        {
          *pNew = *pMux;
          pNew->u.H2250.mediaChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
          pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route =
            pNew->u.H2250.mediaChannel.u.ipSourceRoute.route + uLength;
          memcpy(pNew->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 uLength);
          memcpy(pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
                 uLength2);
        }
      }
      else
      {
        uLength = pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount << 2;
        pNew = H245_malloc(sizeof(*pMux) + uLength);
        if (pNew != NULL)
        {
          *pNew = *pMux;
          pNew->u.H2250.mediaChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
          memcpy(pNew->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 uLength);
        }
      }
    }
    else if (pMux->u.H2250.mediaControlChannelPresent &&
             (pMux->u.H2250.mediaControlChannel.type == H245_IPSSR_UNICAST ||
              pMux->u.H2250.mediaControlChannel.type == H245_IPLSR_UNICAST) &&
             pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route != NULL &&
             pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount != 0)
    {
      uLength = pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount << 2;
      pNew = H245_malloc(sizeof(*pMux) + uLength);
      if (pNew != NULL)
      {
        *pNew = *pMux;
        pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
        memcpy(pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
               pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
               uLength);
      }
    }
    else
    {
      pNew = H245_malloc(sizeof(*pMux));
      if (pNew != NULL)
      {
        *pNew = *pMux;
      }
    }
    pList = NULL;
    pNew->u.H2250.nonStandardList = NULL;
    pFrom = pMux->u.H2250.nonStandardList;
    while (pFrom)
    {
      pTo = H245_malloc(sizeof(*pTo));
      if (pTo != NULL)
      {
        if (CopyNonStandardParameter(&pTo->value, &pFrom->value) != H245_ERROR_OK)
        {
          H245_free(pTo);
          pTo = NULL;
        }
      }
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          FreeNonStandardParameter(&pTo->value);
          H245_free(pTo);
        }
        H245_free(pNew);
        return NULL;
      }
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = pNew->u.H2250.nonStandardList;
      pNew->u.H2250.nonStandardList = pTo;
    } // while
    break;

//  case H245_VGMUX:
 default:
    pNew = H245_malloc(sizeof(*pMux));
    if (pNew != NULL)
    {
      *pNew = *pMux;
    }
  } // switch

  return pNew;
} // H245CopyMux()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeMux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux)
{
  H2250LCPs_nnStndrdLink      pLink;

  if (pMux == NULL)
  {
    return H245_ERROR_PARAM;
  }

  switch (pMux->Kind)
  {
  case H245_H2250:
  case H245_H2250ACK:
    // Caveat: assumes nonstandard list is in same place in both structures
    while (pMux->u.H2250.nonStandardList)
    {
      pLink = pMux->u.H2250.nonStandardList;
      pMux->u.H2250.nonStandardList = pLink->next;
      FreeNonStandardParameter(&pLink->value);
      H245_free(pLink);
    }
    break;
  } // switch

  H245_free(pMux);
  return 0;
} // H245FreeMux()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245OpenChannel
 *
 * DESCRIPTION
 *
 *      HRESULT H245OpenChannel (
 *                              H245_INST_T      dwInst,
 *                              DWORD            dwTransId,
 *                              DWORD            dwTxChannel,
 *                              H245_TOTCAP_T   *pTxMode,
 *                              H245_MUX_T      *pTxMux,
 *                              H245_TOTCAP_T   *pRxMode, (* bi-dir only *)
 *                              H245_MUX_T      *pRxMux   (* bi-dir only *)
 *                              )
 *
 *      Description:
 *              This function is called to open either a uni-directional,
 *              or a bi-directional channel.  The  mode to the remote peer
 *              will be designated by the *pTxMode.. To open a bi-directional
 *              channel the client selects a non-null receive mode ( *pRxMode).
 *              This mode  indicates to  the remote peer its transmit mode.
 *              For  uni-directional channels the *pRxMode must be NULL.
 *
 *              The dwTxChannel parameter indicates which forward logical
 *              channel the H.245 will open.  If this is a bi-directional
 *              channel open, the confirm will indicate the logical channel
 *              specified in the open request by the remote terminal
 *
 *              The pMux parameter will contain a pointer to H.223, H.222,
 *              VGMUX, or other logical channel parameters depending on the
 *              system configuration. (see H245_H223_LOGICAL_PARAM).  This
 *              may be NULL for some clients.
 *
 *      Note:
 *               pTxMode->CapId is of no significance in this call.
 *                      It is not used
 *               pRxMode->CapId is of no significance in this call.
 *                      It is not used
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call.
 *              dwTxChannel     Logical Channel number for forward (Transmit)
 *                              Channel
 *              pTxMode         The capability (mode) used for transmission
 *                              to the remote peer.
 *                              Note: pTxMode->CapId is ignored
 *              pTxMux          The formward logical channel parameters
 *                              for H.223, H.222, VGMUX, etc.
 *              pRxMode         Optional: Transmit mode specified for the
 *                              remote terminal. This is used only for
 *                              Bi-directional Channel opens and must be set
 *                              to NULL if opening a Uni-directional channel.
 *                              Note: pRxMode->CapId is ignored
 *              pRxMux          Optional : The reverse logical channel
 *                              parameters for H.223, H.222, VGMUX, etc. or
 *                              NULL.
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callback:
 *              H245_CONF_OPEN
 *              H245_CONF_NEEDRSP_OPEN  Bi-Directional Channels only
 *                                      waiting for confirm.
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM                One or more parameters were
 *                                              invalid
 *              H245_ERROR_BANDWIDTH_OVERFLOW   Open would exceed bandwidth
 *                                              limitations
 *              H245_ERROR_NOMEM
 *              H245_ERROR_NORESOURCE           Out of resources, too many
 *                                              open channels or outside scope
 *                                              of simultaneous capabilities.
 *              H245_ERROR_INVALID_INST         dwInst is not a valid instance
 *                                              handle
 *              H245_ERROR_INVALID_STATE        Not in the proper state to
 *                                              issue open
 *              H245_ERROR_CHANNEL_INUSE        Channel is currently open
 *
 *      See Also:
 *              H245CloseChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *
 *      callback
 *
 *              H245_CONF_OPEN
 *              H245_CONF_NEEDRSP_OPEN
 *              H245_IND_OPEN_CONF
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;
  Tracker_T                      *pTracker;
  MltmdSystmCntrlMssg            *pPdu;

  H245TRACE (dwInst,4,"H245OpenChannel <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }
  /* must have performed Master Slave Negotiation at this point */
  if (pInstance->Configuration == H245_CONF_H324 &&
      pInstance->API.MasterSlave != APIMS_Master &&
      pInstance->API.MasterSlave != APIMS_Slave)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  pTracker = find_tracker_by_txchannel (pInstance, wTxChannel, API_CH_ALLOC_LCL);

  /* channel is currently in use */
  if (pTracker)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_CHANNEL_INUSE));
      InstanceUnlock(pInstance);
      return H245_ERROR_CHANNEL_INUSE;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));

  /* lock in the transmit side..                        */
  /* wait until OpenChannelConfResp to setup RxChannel  */

  lError = pdu_req_open_channel(pPdu,
                                  wTxChannel,
                                  dwTxPort,        /* forward port */
                                  pTxMode,
                                  pTxMux,
                                  pRxMode,
                                  pRxMux,
                                  pSeparateStack);
  if (lError != H245_ERROR_OK)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(lError));
      H245_free(pPdu);
      InstanceUnlock(pInstance);
      return lError;
    }

  /* if allocation error */

  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_OPEN_CHANNEL_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_LCL,
                                        (pRxMode?API_CH_TYPE_BI:API_CH_TYPE_UNI),
                                        pTxMode->DataType,
                                        wTxChannel, H245_INVALID_CHANNEL,
                                        0)))
  {
    H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOMEM));
    H245_free(pPdu);
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }

  lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
  H245_free(pPdu);
  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245OpenChannel -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannel()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245OpenChannelAccept
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T *           pTracker;
  MltmdSystmCntrlMssg * pPdu;
  HRESULT               lError;

  H245TRACE (dwInst,4,"H245OpenChannelAccept <- wRxChannel=%d wTxChannel=%d",
             wRxChannel, wTxChannel);

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);

  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* if not open.. invalid op */
  if (pTracker->TrackerType != API_OPEN_CHANNEL_T)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /*       if was uni open w/ TxChannel set.. error     */
  /* -or -                                              */
  /*       if was bi open w/ !TxChannel set.. error     */

  /* AND it wasn't a reject                             */

  if (pTracker->u.Channel.ChannelType == API_CH_TYPE_BI && wTxChannel == 0)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* for debug */
  H245ASSERT (pTracker->u.Channel.RxChannel == wRxChannel);
  H245ASSERT (pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);

  /* check state.. must be returning.. */
  if (pTracker->State != API_ST_WAIT_LCLACK)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  /* setup tracker object for new transaction */
  pTracker->TransId = dwTransId;

  pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));


  switch (pTracker->u.Channel.ChannelType)
    {
    case API_CH_TYPE_UNI:
      pTracker->State = API_ST_IDLE;
      pTracker->u.Channel.TxChannel = 0;
      lError = pdu_rsp_open_logical_channel_ack(pPdu,
                                                wRxChannel,
                                                pRxMux,
                                                0,
                                                NULL,
                                                dwTxPort,
                                                pSeparateStack);
      if (lError != H245_ERROR_OK)
      {
        // If parameter error, we don't want to deallocate tracker
        H245_free (pPdu);
        InstanceUnlock(pInstance);
        return lError;
      }
      lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
      break;

    case API_CH_TYPE_BI:
      pTracker->State = API_ST_WAIT_CONF;       /* waiting for confirmation */
      pTracker->u.Channel.TxChannel = wTxChannel;
      lError = pdu_rsp_open_logical_channel_ack(pPdu,
                                                wRxChannel,
                                                pRxMux,
                                                wTxChannel,
                                                pTxMux,
                                                dwTxPort,
                                                pSeparateStack);
      if (lError != H245_ERROR_OK)
      {
        // If parameter error, we don't want to deallocate tracker
        H245_free (pPdu);
        InstanceUnlock(pInstance);
        return lError;
      }
      lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
      break;

    default:
      H245TRACE (dwInst,1,"H245OpenChannelAccept: Invalid Tracker Channel Type %d",
                 pTracker->u.Channel.ChannelType);
      lError = H245_ERROR_FATAL;
    } // switch

  H245_free (pPdu);

  switch (lError)
  {
  case H245_ERROR_OK:
    H245TRACE (dwInst,4,"H245OpenChannelAccept -> OK");
    break;

  default:
    // Deallocate tracker object for all errors except parameter error
    unlink_dealloc_tracker (pInstance, pTracker);

    // Fall-through to next case is intentional

  case H245_ERROR_PARAM:
      // If parameter error, we don't want to deallocate tracker
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(lError));
  } // switch

  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannelAccept()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245OpenChannelReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T *           pTracker;
  MltmdSystmCntrlMssg * pPdu;
  HRESULT               lError;

  H245TRACE (dwInst,4,"H245OpenChannelReject <- wRxChannel=%d", wRxChannel);

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);

  /* not locking tracker.. since no indication will come in until I issue the request */
  /* if not open.. invalid op */
  if (pTracker == NULL || pTracker->TrackerType != API_OPEN_CHANNEL_T)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* for debug */
  H245ASSERT (pTracker->u.Channel.RxChannel == wRxChannel);
  H245ASSERT (pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);

  /* check state.. must be returning.. */
  if (pTracker->State != API_ST_WAIT_LCLACK)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));

  pdu_rsp_open_logical_channel_rej(pPdu, wRxChannel, wCause);

  switch (pTracker->u.Channel.ChannelType)
    {
    case API_CH_TYPE_UNI:
      lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
      break;

    case API_CH_TYPE_BI:
      lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
      break;

    default:
      H245TRACE (dwInst,1,"H245OpenChannelReject: Invalid Tracker Channel Type %d",
                 pTracker->u.Channel.ChannelType);
      lError = H245_ERROR_FATAL;
    } // switch

  H245_free (pPdu);
  unlink_dealloc_tracker (pInstance, pTracker);

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245OpenChannelReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannelReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannel
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannel (
 *                              H245_INST_T     dwInst,
 *                              DWORD           dwTransId,
 *                              DWORD           wTxChannel,
 *                              )
 *      Description:
 *              Called to close a channel upon which the client previously
 *              issued an OpenChannel request.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call.
 *              wChannel        Logical Channel Number to close
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_CLOSE
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        wChannel is not a locally opened
 *                                      channel
 *              H245_ERROR_INVALID_INST dwInst is not a valid intance handle
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP   Can not perform this operation on
 *                                      this channel.(See H245CloseChannelReq)
 *      See Also:
 *              H245OpenChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *              H245CloseChannelReq
 *
 *      callback
 *              H245_CONF_CLOSE
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannel <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_txchannel (pInstance, wTxChannel, API_CH_ALLOC_LCL);
  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_INVALID_CHANNEL));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_CHANNEL;
    }

  /* setup new tracker state */
  pTracker->State = API_ST_WAIT_RMTACK;
  pTracker->TrackerType = API_CLOSE_CHANNEL_T;
  pTracker->TransId = dwTransId;

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  pdu_req_close_logical_channel(pPdu, wTxChannel, 0/* user */);

  error = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
  H245_free (pPdu);

  /* error.. so deallocate tracker structure */
  if (error != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(error));
  }
  else
    H245TRACE (dwInst,4,"H245CloseChannel -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245CloseChannel()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannelReq
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannelReq (
 *                                 H245_INST_T          dwInst,
 *                                 DWORD                dwTransId,
 *                                 DWORD                wChannel,
 *                                 )
 *      Description:
 *              Called to request the remote peer to close a logical channel
 *              it previously opened
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call
 *              wChannel        Logical Channel Number to close
 *
 *              Note: This is only asking permission.  Even if the Close
 *              Request is accepted the channel still has to be closed from
 *              the remote side.  (i.e. this does not close the channel it
 *              only asked the remote side it issue a close)
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_CLOSE
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM                wChannel is not a channel
 *                                              opened by remote peer
 *              H245_ERROR_INVALID_INST         dwInst is not a valid instance
 *                                              handle
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP           Can not perform this operation
 *                                              on this channel
 *                                              (see H245CloseChannel)
 *      See Also:
 *              H245OpenChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *              H245CloseChannel
 *
 *      callback
 *
 *              H245_CONF_CLOSE
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannelReq <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);
  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /*  verify state of tracker */
  pTracker->State = API_ST_WAIT_RMTACK;
  pTracker->TrackerType = API_CLOSE_CHANNEL_T;
  pTracker->TransId = dwTransId;

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  pdu_req_request_close_channel(pPdu, wRxChannel);

  error = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
  H245_free (pPdu);
  if (error != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(error));
  }
  else
    H245TRACE (dwInst,4,"H245CloseChannelReq -> OK");
  InstanceUnlock(pInstance);
  return error;
} // H245CloseChannelReq()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannelReqResp
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannelReqResp (
 *                                      H245_INST_T     dwInst,
 *                                      H245_ACC_REJ_T  AccRej,
 *                                      DWORD           wChannel
 *                                      )
 *
 *      Description:
 *              This routine is called to accept or reject a
 *              RequestChannelClose (H245_IND_REQ_CLOSE indication) from the
 *              remote peer. The channel must have been locally opened.  The
 *              parameter AccRej is H245_ACC to accept or H245_REJ to reject
 *              the close.  The local client should follow this response with
 *              a H245CloseChannel call.
 *
 *              If there was a Release CloseChannelRequest event that
 *              occurred during this transaction there error code returned
 *              will be H245_ERROR_CANCELED.  This indicates to the H.245
 *              client that no action should be taken.
 *
 *      Input
 *              dwInst          Instance handle returned by H245GetInstanceId
 *              AccRej          this parameter contains either H245_ACC or
 *                              H245_REJ.  This indicates to H.245 which
 *                              action to take.
 *              wChannel        Logical Channel Number to close
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP   Can not perform this operation on this
 *                                      channel (see H245CloseChannel)
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *              H245_ERROR_CANCELED     if release was received during the
 *                                      processing of this request..
 *      See Also:
 *              H245CloseChannel
 *
 *      callback
 *
 *              H245_IND_REQ_CLOSE
 *              H245_IND_CLOSE
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannelReqResp <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_txchannel (pInstance, wChannel,  API_CH_ALLOC_LCL);

  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* if the request was canceled.. tell useer */
  if (pTracker->State == API_ST_WAIT_LCLACK_CANCEL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_CANCELED));
      InstanceUnlock(pInstance);
      return H245_ERROR_CANCELED;
    }

  /* verify state of tracker */
  if ((pTracker->State != API_ST_WAIT_LCLACK) ||
      (pTracker->TrackerType != API_CLOSE_CHANNEL_T))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* set the state to idle.. expect this side to close the channel next */
  pTracker->State = API_ST_IDLE;

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  if (AccRej == H245_ACC)
  {
    pTracker = NULL;
    pdu_rsp_request_channel_close_ack(pPdu, wChannel);
  }
  else
  {
    pdu_rsp_request_channel_close_rej(pPdu, wChannel, AccRej);
  }

  error = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));
  H245_free (pPdu);
  if (error != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(error));
  else
    H245TRACE (dwInst,4,"H245CloseChannelReqResp ->");
  InstanceUnlock(pInstance);
  return error;
} // H245CloseChannelReqResp()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SendLocalMuxTable
 *
 * DESCRIPTION
 *
 *      HRESULT H245SendLocalMuxTable (
 *                                    H245_INST_T        dwInst,
 *                                    DWORD              dwTransId,
 *                                    H245_MUX_TABLE_T  *pMuxTbl
 *                                    )
 *      Description:
 *              This routine is called to send a mux table to the remote
 *              side. The remote side can either reject or accept each mux
 *              table entry in a message. The confirm is sent back to the
 *              calling H.245 client based on the acceptance or non
 *              acceptance of each Mux table entry with H245_CONF_MUXTBL_SND.
 *
 *              This is a fairly dangerous call, since the mux table
 *              structure is a linked lise of mux table entries.  Invalid
 *              data structures could cause an access error. Example code is
 *              supplied in the appendix.
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify
 *                              this request in the asynchronous
 *                              confirm to this call.
 *      pMuxTbl Mux table entry structure
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_MUXTBLSND
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_MUXTBLENTRY
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *
 *      See Also:
 *              APPENDIX Examples
 *
 *      callback
 *
 *              H245_CONF_MUXTBL_SND
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                 lError;
  Tracker_T              *pTracker;
  MltmdSystmCntrlMssg    *pPdu;

  H245TRACE (dwInst,4,"H245SendLocalMuxTable <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable  -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* make sure parameters ar ok.. */
  if (!pMuxTable)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable  -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* allocate tracker for event */
  pTracker = alloc_link_tracker (pInstance,
                                  API_SEND_MUX_T,
                                  dwTransId,
                                  API_ST_WAIT_RMTACK,
                                  API_CH_ALLOC_UNDEF,
                                  API_CH_TYPE_UNDEF,
                                  0,
                                  H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                  0);
  if (pTracker == NULL)
  {
    H245TRACE(dwInst,1,"H245SendLocalMuxTable -> %s",map_api_error(H245_ERROR_NOMEM));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }

  // Allocate PDU buffer
  pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg));
  if (pPdu == NULL)
  {
    H245TRACE (dwInst,1,"H245SendLocalMuxTable -> %s",H245_ERROR_NOMEM);
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  lError = pdu_req_send_mux_table(pInstance,
                                  pPdu,
                                  pMuxTable,
                                  0,
                                  &pTracker->u.MuxEntryCount);
  if (lError == H245_ERROR_OK)
  {
    lError = FsmOutgoing(pInstance, pPdu, PtrToUlong(pTracker));

    /* free the list just built */
    free_mux_desc_list(pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors);
  }

  /* free the pdu */
  H245_free (pPdu);

  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245SendLocalMuxTable -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245SendLocalMuxTable -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendLocalMuxTable()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245MuxTableIndResp
 *
 * DESCRIPTION
 *
 *      HRESULT H245MuxTableIndResp (
 *                                  H45_INST_T          dwInst,
 *                                  H245_ACC_REJ_MUX_T  AccRejMux,
 *                                  DWORD               Count
 *                                  )
 *      Description:
 *              This procedure is called to either accept or reject mux
 *              table entries sent up in the H245_IND_MUX_TBL indication.
 *
 *      Input
 *              dwInst                  Instance handle returned by H245Init
 *              AccRejMux               Accept Reject Mux structure
 *              Count                   number of entries in the structure
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_MUXTBLENTRY
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_INVALID_OP
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *      See Also:
 *              H245SendLocalMuxTable
 *
 *      callback
 *
 *              H245_IND_MUX_TBL
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  DWORD                   ii;
  Tracker_T              *pTracker;
  MltmdSystmCntrlMssg    *pPdu;

  H245TRACE (dwInst,4,"H245MuxTableIndResp <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp  -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* look for tracker.. */
  pTracker = NULL;
  pTracker = find_tracker_by_type (pInstance, API_RECV_MUX_T, pTracker);

  /* if tracker not found.. issue invalid op */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  H245ASSERT (pTracker->State == API_ST_WAIT_LCLACK);

  /* can't ack or reject more than you got */
  if ((dwCount > pTracker->u.MuxEntryCount) ||
      (dwCount > 15))
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* verify the mux table entry id's */
  for (ii=0;ii<dwCount;ii++)
    {
      if ((AccRejMux[ii].MuxEntryId > 15) ||
          (AccRejMux[ii].MuxEntryId <= 0))
        {
          H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_PARAM));
          InstanceUnlock(pInstance);
          return H245_ERROR_PARAM;
        }
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* if there are any rejects in the list.. send reject */
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));
  if (pdu_rsp_mux_table_rej (pPdu,0,AccRejMux,dwCount) == H245_ERROR_OK)
    FsmOutgoing(pInstance, pPdu, 0);

  /* if there are any accepts in the list.. send accept */
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));
  if (pdu_rsp_mux_table_ack (pPdu,0,AccRejMux,dwCount) == H245_ERROR_OK)
    FsmOutgoing(pInstance, pPdu, 0);

  /* if we've acked all the entries */
  if (!(pTracker->u.MuxEntryCount -= dwCount))
    unlink_dealloc_tracker (pInstance, pTracker);

  H245_free (pPdu);
  H245TRACE (dwInst,4,"H245MuxTableIndResp -> %s",H245_ERROR_OK);
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;

} // H245MuxTableIndResp()



#if 0

/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245MiscCommand
 *
 * DESCRIPTION
 *
 *      HRESULT H245MiscCommand (
 *                              H245_INST_T      dwInst,
 *                              DWORD            wChannel,
 *                              H245_MISC_T     *pMisc
 *                              )
 *      Description:
 *              Send a Misc. command to the remote side (see H245_MISC_T
 *              data Structure)
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              wChannel        Logical Channel Number
 *              pMisc           pointer to a misc. command structure
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_NOMEM
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *
 *      callback
 *
 *              H245_IND_MISC
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT H245MiscCommand (
                         H245_INST_T            dwInst,
                         WORD                   wChannel,
                         H245_MISC_T            *pMisc
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245MiscCommand <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }
  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if the channel can not be found */
  if (!find_tracker_by_txchannel(pInstance, wChannel, API_CH_ALLOC_LCL) &&
      !find_tracker_by_rxchannel(pInstance, wChannel, API_CH_ALLOC_RMT))
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_INVALID_CHANNEL));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_CHANNEL;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* budld pdu for misc command */
  pdu_cmd_misc (pPdu, pMisc, wChannel);

  lError = FsmOutgoing(pInstance, pPdu, 0);
  H245_free (pPdu);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MiscCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MiscCommand()

#endif



// #pragma warning( disable : 4100 )

/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntry
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntry <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }
  for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
  {
     if (pwMultiplexTableEntryNumbers[dwIndex] < 1 ||
         pwMultiplexTableEntryNumbers[dwIndex] > 15)
     {
       H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_PARAM));
       return H245_ERROR_PARAM;
     }
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = requestMultiplexEntry_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.value[dwIndex] =
        pwMultiplexTableEntryNumbers[dwIndex];
    }

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntry -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntry()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntryAck
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntryAck <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestMultiplexEntryAck_chosen;
    pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.value[dwIndex] =
        pwMultiplexTableEntryNumbers[dwIndex];
    }

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntryAck -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntryAck()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntryReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntryReject <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = rqstMltplxEntryRjct_chosen;
    pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].multiplexTableEntryNumber =
        pwMultiplexTableEntryNumbers[dwIndex];
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].cause.choice = RMERDs_cs_unspcfdCs_chosen;
    }

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntryReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntryReject()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMode
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
						 ModeDescription 		ModeDescriptions[],
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  RequestedModesLink              pLink;
  DWORD                           dwIndex;
  ULONG							  ulPDUsize;

  H245TRACE (dwInst,4,"H245RequestMode <-");

  if (ModeDescriptions == NULL || dwCount == 0 || dwCount > 256)
  {
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  ulPDUsize = (sizeof(*pPdu) + (sizeof(*pLink)*(dwCount)));

  pPdu = (PDU_T *)H245_malloc(ulPDUsize);
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
	USHORT usModeDescIndex;
	
    memset(pPdu, 0, ulPDUsize);

    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = requestMode_chosen;
    pLink = (RequestedModesLink)(pPdu + 1);
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes = pLink;

    for (usModeDescIndex = 0; usModeDescIndex < dwCount; usModeDescIndex++)
	{
		pLink->value.count = (WORD)ModeDescriptions[usModeDescIndex].count;
		for (dwIndex = 0; dwIndex < ModeDescriptions[usModeDescIndex].count; dwIndex++)
		{
		  pLink->value.value[dwIndex] = ModeDescriptions[usModeDescIndex].value[dwIndex];
		}
		pLink->next = pLink + 1;
		pLink++;
	}
	(pLink - 1)->next = NULL;
    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMode -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMode()





/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestModeAck
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RequestModeAck <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestModeAck -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestModeAck_chosen;
    pPdu->u.MSCMg_rspns.u.requestModeAck.response.choice = wResponse;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestModeAck -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestModeAck -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestModeAck()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestModeReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RequestModeReject <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestModeReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestModeReject_chosen;
    pPdu->u.MSCMg_rspns.u.requestModeReject.cause.choice = wCause;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestModeReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestModeReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestModeReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RoundTripDelayRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RoundTripDelayRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RoundTripDelayRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = roundTripDelayRequest_chosen;

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RoundTripDelayRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RoundTripDelayRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RoundTripDelayRequest()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoop
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoop <-");

  if (dwLoopType < systemLoop_chosen ||
      dwLoopType > logicalChannelLoop_chosen ||
      (dwLoopType != systemLoop_chosen && wChannel == 0))
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = maintenanceLoopRequest_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice = (WORD)dwLoopType;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop = wChannel;

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoop -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoop()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopRelease
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst)
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopRelease <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopRelease -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = mntnncLpOffCmmnd_chosen;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopRelease -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopRelease -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopRelease()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopAccept
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopAccept <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopAccept -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = maintenanceLoopAck_chosen;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop = wChannel;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopAccept -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopAccept -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopAccept()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopReject <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = maintenanceLoopReject_chosen;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop = wChannel;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.cause.choice = wCause;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245NonStandardObject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  POBJECTID                       pObject;

  H245TRACE (dwInst,4,"H245NonStandardObject <-");

  if (pData == NULL || dwDataLength == 0 || pwObjectId == NULL || dwObjectIdLength == 0)
  {
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu) + dwObjectIdLength * sizeof(*pObject));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    switch (MessageType)
    {
    case H245_MESSAGE_REQUEST:
      pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
      pPdu->u.MltmdSystmCntrlMssg_rqst.choice = RqstMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_RESPONSE:
      pPdu->choice = MSCMg_rspns_chosen;
      pPdu->u.MSCMg_rspns.choice = RspnsMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_COMMAND:
      pPdu->choice = MSCMg_cmmnd_chosen;
      pPdu->u.MSCMg_cmmnd.choice = CmmndMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_INDICATION:
      pPdu->choice = indication_chosen;
      pPdu->u.indication.choice = IndctnMssg_nonStandard_chosen;
      break;

    default:
      H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    } // switch

    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length = (WORD)dwDataLength;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value  = (unsigned char *)pData;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice = object_chosen;

    // Copy the object identifier
    pObject = (POBJECTID) (pPdu + 1);
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.object = pObject;
    do
    {
      pObject->next = pObject + 1;
      pObject->value = *pwObjectId++;
      ++pObject;
    } while (--dwObjectIdLength);

    // Null terminate the linked list
    --pObject;
    pObject->next = NULL;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245NonStandardObject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245NonStandardObject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245NonStandardH221
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245NonStandard221 <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    switch (MessageType)
    {
    case H245_MESSAGE_REQUEST:
      pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
      pPdu->u.MltmdSystmCntrlMssg_rqst.choice = RqstMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_RESPONSE:
      pPdu->choice = MSCMg_rspns_chosen;
      pPdu->u.MSCMg_rspns.choice = RspnsMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_COMMAND:
      pPdu->choice = MSCMg_cmmnd_chosen;
      pPdu->u.MSCMg_cmmnd.choice = CmmndMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_INDICATION:
      pPdu->choice = indication_chosen;
      pPdu->u.indication.choice = IndctnMssg_nonStandard_chosen;
      break;

    default:
      H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    } // switch

    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length = (WORD)dwDataLength;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value  = (unsigned char *)pData;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice = h221NonStandard_chosen;

    // Fill in the H.221 identifier
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode   = byCountryCode;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension     = byExtension;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = wManufacturerCode;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245NonStandardH221 -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245NonStandardH221



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst)
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245CommunicationModeRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = communicationModeRequest_chosen;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeRequest



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeResponse
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError = H245_ERROR_OK;
  CommunicationModeTableLink      pLink;
  unsigned int                    uIndex;

  H245TRACE (dwInst,4,"H245CommunicationModeResponse <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeResponse -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu) + byTableCount * sizeof(*pLink));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = cmmnctnMdRspns_chosen;
    pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.choice = communicationModeTable_chosen;
    pLink = (CommunicationModeTableLink)(pPdu + 1);
    pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable = pLink;
    for (uIndex = 0; uIndex < byTableCount; ++uIndex)
    {
      pLink[uIndex].next = &pLink[uIndex + 1];
      lError = SetupCommModeEntry(&pLink[uIndex].value, &pTable[uIndex]);
      if (lError != H245_ERROR_OK)
         break;
    }
    pLink[byTableCount - 1].next = NULL;
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeResponse -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeResponse -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeResponse()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeCommand
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError = H245_ERROR_OK;
  CommunicationModeCommandLink    pLink;
  unsigned int                    uIndex;

  H245TRACE (dwInst,4,"H245CommunicationModeCommand <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu) + byTableCount * sizeof(*pLink));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = communicationModeCommand_chosen;
    pLink = (CommunicationModeCommandLink)(pPdu + 1);
    pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable = pLink;
    for (uIndex = 0; uIndex < byTableCount; ++uIndex)
    {
      pLink[uIndex].next = &pLink[uIndex + 1];
      lError = SetupCommModeEntry(&pLink[uIndex].value, &pTable[uIndex]);
      if (lError != H245_ERROR_OK)
         break;
    }
    pLink[byTableCount - 1].next = NULL;
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeCommand()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = conferenceRequest_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.choice = (WORD)RequestType;
    switch (RequestType)
    {
    case dropTerminal_chosen:
    case requestTerminalID_chosen:
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.mcuNumber      = byMcuNumber;
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case terminalListRequest_chosen:
    case makeMeChair_chosen:
    case cancelMakeMeChair_chosen:
    case enterH243Password_chosen:
    case enterH243TerminalID_chosen:
    case enterH243ConferenceID_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceRequest()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceResponse
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  unsigned                        uIndex;

  H245TRACE (dwInst,4,"H245ConferenceResponse <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = conferenceResponse_chosen;
    pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = (WORD)ResponseType;
    switch (ResponseType)
    {
    case mCTerminalIDResponse_chosen:
    case terminalIDResponse_chosen:
    case conferenceIDResponse_chosen:
    case passwordResponse_chosen:
      if (pOctetString == NULL ||
          byOctetStringLength == 0 ||
          byOctetStringLength > 128)
      {
          H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_PARAM));
          return H245_ERROR_PARAM;
      }
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.mcuNumber      = byMcuNumber;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.terminalNumber = byTerminalNumber;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.length            = byOctetStringLength;
      memcpy(pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.value,
             pOctetString,
             byOctetStringLength);

      // Fall-through to next case is intentional

    case videoCommandReject_chosen:
    case terminalDropReject_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case terminalListResponse_chosen:
      if (pTerminalList == NULL ||
          wTerminalListCount == 0 ||
          wTerminalListCount > 256)
      {
          H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_PARAM));
          return H245_ERROR_PARAM;
      }
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.count = wTerminalListCount;
      for (uIndex = 0; uIndex < wTerminalListCount; ++uIndex)
      {
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.value[uIndex] =
          pTerminalList[uIndex];
      }
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case H245_RSP_DENIED_CHAIR_TOKEN:
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = makeMeChairResponse_chosen;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice = deniedChairToken_chosen;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case H245_RSP_GRANTED_CHAIR_TOKEN:
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = makeMeChairResponse_chosen;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice = grantedChairToken_chosen;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceResponse -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceResponse()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceCommand
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceCommand <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = conferenceCommand_chosen;
    pPdu->u.MSCMg_cmmnd.u.conferenceCommand.choice = (WORD)CommandType;
    switch (CommandType)
    {
    case brdcstMyLgclChnnl_chosen:
    case cnclBrdcstMyLgclChnnl_chosen:
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.brdcstMyLgclChnnl = Channel;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case makeTerminalBroadcaster_chosen:
    case sendThisSource_chosen:
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.makeTerminalBroadcaster.mcuNumber      = byMcuNumber;
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.makeTerminalBroadcaster.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case cnclMkTrmnlBrdcstr_chosen:
    case cancelSendThisSource_chosen:
    case dropConference_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceCommand()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = conferenceIndication_chosen;
    pPdu->u.indication.u.conferenceIndication.choice = (WORD)IndicationType;
    switch (IndicationType)
    {
    case sbeNumber_chosen:
      pPdu->u.indication.u.conferenceIndication.u.sbeNumber = bySbeNumber;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case terminalNumberAssign_chosen:
    case terminalJoinedConference_chosen:
    case terminalLeftConference_chosen:
    case terminalYouAreSeeing_chosen:
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.mcuNumber      = byMcuNumber;
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case seenByAtLeastOneOther_chosen:
    case cnclSnByAtLstOnOthr_chosen:
    case seenByAll_chosen:
    case cancelSeenByAll_chosen:
    case requestForFloor_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245UserInput
 *
 * DESCRIPTION
 *
 *      HRESULT H245UserInput (
 *                           H245_INST_T                         dwInst,
 *                           char                               *pGenString,
 *                           H245_NONSTANDARD_PARAMETER_T       *pNonStd
 *                           )
 *      Description:
 *
 *              Send a User Input indiation to the remote side.  One of the
 *              two parameters must be set (pGenString, pNonStd).  The client
 *              can either send a string or a NonStandard parameter set to the
 *              remote client.  Only one of the two parameters can contain a
 *              value.  The other is required to be NULL.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              pGenString      choice: String to be sent to remote
 *                              side in accordance with T.51 specification.
 *              pNonStd         choice: NonStandard Parameter
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *              H245_ERROR_PARAM
 *
 *      callback
 *              H245_IND_USERINPUT
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                        pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu;
#if 1
  int                   nLength;
  char *                pszGeneral = NULL;
#endif

  H245TRACE (dwInst,4,"H245UserInput <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  pPdu = (MltmdSystmCntrlMssg *)H245_malloc(sizeof(MltmdSystmCntrlMssg));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* build PDU */
#if 1
  if (pGenString)
  {
    nLength = WideCharToMultiByte(CP_ACP,     // code page
                                  0,          // dwFlags
                                  pGenString, // Unicode string
                                  -1,         // Unicode string length (bytes)
                                  NULL,       // ASCII string
                                  0,          // max ASCII string length
                                  NULL,       // default character
                                  NULL);     // default character used
    pszGeneral = H245_malloc(nLength);
    if (pszGeneral == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
    nLength = WideCharToMultiByte(CP_ACP,       // code page
                                  0,            // dwFlags
                                  pGenString,   // Unicode string
                                  -1,           // Unicode string length (bytes)
                                  pszGeneral,   // ASCII string
                                  nLength,      // max ASCII string length
                                  NULL,         // default character
                                  NULL);        // default character used
    lError = pdu_ind_usrinpt (pPdu, NULL, pszGeneral);
  }
  else
  {
    lError = pdu_ind_usrinpt (pPdu, pNonStd, NULL);
  }
#else
    lError = pdu_ind_usrinpt (pPdu, pNonStd, pGenString);
#endif
  if (lError == H245_ERROR_OK)
    lError = FsmOutgoing(pInstance, pPdu, 0);
#if 1
  if (pszGeneral)
    H245_free(pszGeneral);
#endif
  H245_free (pPdu);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245UserInput -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245UserInput()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FlowControl
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245FlowControl <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245FlowControl -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = flowControlCommand_chosen;
    pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice = (WORD)Scope;
    if (dwRestriction == H245_NO_RESTRICTION)
    {
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice = noRestriction_chosen;
    }
    else
    {
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice = maximumBitRate_chosen;
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.u.maximumBitRate = dwRestriction;
    }
    switch (Scope)
    {
    case FCCd_scp_lgclChnnlNmbr_chosen:
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FCCd_scp_lgclChnnlNmbr = Channel;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case FlwCntrlCmmnd_scp_rsrcID_chosen:
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FlwCntrlCmmnd_scp_rsrcID = wResourceID;

      // Fall-through to next case

    case FCCd_scp_whlMltplx_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245FlowControl -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245FlowControl -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245FlowControl()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245H223SkewIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245H223SkewIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245H223SkewIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = h223SkewIndication_chosen;
    pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber1 = wLogicalChannelNumber1;
    pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber2 = wLogicalChannelNumber2;
    pPdu->u.indication.u.h223SkewIndication.skew                  = wSkew;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245H223SkewIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245H223SkewIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245H223SkewIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245H2250MaximumSkewIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245H2250MaximumSkewIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245H2250MaximumSkewIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = h2250MxmmSkwIndctn_chosen;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber1 = wLogicalChannelNumber1;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber2 = wLogicalChannelNumber2;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.maximumSkew           = wMaximumSkew;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245H2250MaximumSkewIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245H2250MaximumSkewIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245H2250MaximumSkewIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MCLocationIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MCLocationIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MCLocationIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = mcLocationIndication_chosen;
    lError = SetupTransportAddress(&pPdu->u.indication.u.mcLocationIndication.signalAddress,
                                   pSignalAddress);
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MCLocationIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MCLocationIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MCLocationIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245VendorIdentification
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,
                         unsigned char          byProductNumberLength,
                         const unsigned char   *pVersionNumber,
                         unsigned char          byVersionNumberLength
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245VendorIdentification <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245VendorIdentification -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)H245_malloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = vendorIdentification_chosen;
    pPdu->u.indication.u.vendorIdentification.bit_mask = 0;
    pPdu->u.indication.u.vendorIdentification.vendor = *pIdentifier;
    if (pProductNumber != NULL && byProductNumberLength != 0)
    {
      pPdu->u.indication.u.vendorIdentification.bit_mask |= productNumber_present;
      pPdu->u.indication.u.vendorIdentification.productNumber.length = byProductNumberLength;
      memcpy(pPdu->u.indication.u.vendorIdentification.productNumber.value,
             pProductNumber,
             byProductNumberLength);
    }
    if (pVersionNumber != NULL && byVersionNumberLength != 0)
    {
      pPdu->u.indication.u.vendorIdentification.bit_mask |= versionNumber_present;
      pPdu->u.indication.u.vendorIdentification.versionNumber.length = byVersionNumberLength;
      memcpy(pPdu->u.indication.u.vendorIdentification.versionNumber.value,
             pVersionNumber,
             byVersionNumberLength);
    }
    lError = FsmOutgoing(pInstance, pPdu, 0);
    H245_free(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245VendorIdentification -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245VendorIdentification -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245VendorIdentification()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245SendPDU
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245SendPDU <-");

  // Check for valid instance handle
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SendPDU -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  lError = FsmOutgoing(pInstance, pPdu, 0);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245SendPDU -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245SendPDU -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendPDU()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SystemControl
 *
 * DESCRIPTION
 *
 *      HRESULT H245SystemControl
 *                              (       H245_INST_T     dwInst,
 *                                      DWORD           Request ,
 *                                      VOID            *pData
 *                              )
 *
 *      Description:
 *                      This function should not be used by clients who
 *                      normally interface to the H.245 subsystem.  It is
 *                      defined here to help during development and debug
 *                      of the H.245 subsystem.
 *
 *                      This is a roll your own.. and can do what
 *                      ever the user needs.. It's a hook to allow
 *                      IOCTL (unix) calls that can either be
 *                      passed to lower stack elements (AT&T Streams IOCTL
 *                      would be an example - :) or simply to get or put
 *                      information to the H245 SubSytem.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              Request         Requested system control
 *              pData           In the case of sending information
 *                              down to H.245 this is an input
 *                              parameter, and its data format
 *                              is determined by the Request.
 *      output
 *              pData           In the case of retrieving information
 *                              from  H.245 this can be an output
 *                              parameter, and its data format is
 *                              determined by the Request.  It may not
 *                              have valid data if the request is a
 *                              synchronous request. (See Request Options).
 *      Call Type:
 *
 *              Synchronous
 *
 *      Request Options:
 *
 *        H245_SYSCON_GET_STATS    Retrieves Statistics
 *                                 from H.245 subsystem
 *                                 parameter pData = &H245_SYSCON_STAT_T
 *        H245_ SYSCON_RESET_STATS Resets the statistics
 *                                 pData = NULL
 *        H245_SYS_TRACE           Set Trace Level
 *                                 pData = &DWORD (Trace Level)
 *
 *      Return Values:
 *              See Request Options
 *
 *      Errors:
 *              H245_ERROR_OK
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        )
{
  HRESULT                         lError;
  DWORD                           dwTemp;

  H245TRACE(dwInst,4,"H245SystemControl <-");

  if (dwRequest == H245_SYSCON_DUMP_TRACKER)
  {
    register struct InstanceStruct *pInstance = InstanceLock(dwInst);
    if (pInstance == NULL)
    {
      lError = H245_ERROR_INVALID_INST;
    }
    else
    {
      dump_tracker(pInstance);
      InstanceUnlock(pInstance);
      lError = H245_ERROR_OK;
    }
  }
  else if (pData == NULL)
  {
    lError = H245_ERROR_PARAM;
  }
  else
  {
    lError = H245_ERROR_OK;
    switch (dwRequest)
      {
      case H245_SYSCON_GET_FSM_N100:
        *((DWORD *)pData) = (DWORD) uN100;
        H245TRACE(dwInst,20,"H245SystemControl: Get N100 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T101:
        *((DWORD *)pData) = (DWORD) uT101;
        H245TRACE(dwInst,20,"H245SystemControl: Get T101 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T102:
        *((DWORD *)pData) = (DWORD) uT102;
        H245TRACE(dwInst,20,"H245SystemControl: Get T102 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T103:
        *((DWORD *)pData) = (DWORD) uT103;
        H245TRACE(dwInst,20,"H245SystemControl: Get T103 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T104:
        *((DWORD *)pData) = (DWORD) uT104;
        H245TRACE(dwInst,20,"H245SystemControl: Get T104 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T105:
        *((DWORD *)pData) = (DWORD) uT105;
        H245TRACE(dwInst,20,"H245SystemControl: Get T105 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T106:
        *((DWORD *)pData) = (DWORD) uT106;
        H245TRACE(dwInst,20,"H245SystemControl: Get T106 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T107:
        *((DWORD *)pData) = (DWORD) uT107;
        H245TRACE(dwInst,20,"H245SystemControl: Get T107 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T108:
        *((DWORD *)pData) = (DWORD) uT108;
        H245TRACE(dwInst,20,"H245SystemControl: Get T108 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T109:
        *((DWORD *)pData) = (DWORD) uT109;
        H245TRACE(dwInst,20,"H245SystemControl: Get T109 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_SET_FSM_N100:
        dwTemp = (DWORD) uN100;
        uN100  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set N100 = %d",uN100);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T101:
        dwTemp = (DWORD) uT101;
        uT101  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T101 = %d",uT101);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T102:
        dwTemp = (DWORD) uT102;
        uT102  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T102 = %d",uT102);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T103:
        dwTemp = (DWORD) uT103;
        uT103  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T103 = %d",uT103);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T104:
        dwTemp = (DWORD) uT104;
        uT104  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T104 = %d",uT104);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T105:
        dwTemp = (DWORD) uT105;
        uT105  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T105 = %d",uT105);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T106:
        dwTemp = (DWORD) uT106;
        uT106  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T106 = %d",uT106);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T107:
        dwTemp = (DWORD) uT107;
        uT107  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T107 = %d",uT107);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T108:
        dwTemp = (DWORD) uT108;
        uT108  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T108 = %d",uT108);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T109:
        dwTemp = (DWORD) uT109;
        uT109  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T109 = %d",uT109);
        *((DWORD *)pData) = dwTemp;
        break;

#if defined(DBG)
      case H245_SYSCON_TRACE_LVL:
        dwTemp = g_dwH245DbgLevel;
        g_dwH245DbgLevel = *(DWORD *)pData;
        H245TRACE(dwInst,20,"H245SystemControl: Set TraceLevel = %d",g_dwH245DbgLevel);
        *((DWORD *)pData) = dwTemp;
        break;
#endif

      default:
        lError = H245_ERROR_NOTIMP;
    } // switch
  } // else

  if (lError != H245_ERROR_OK)
    H245TRACE(dwInst,1,"H245SystemControl -> %s",map_api_error(lError));
  else
    H245TRACE(dwInst,4,"H245SystemControl -> OK");
  return lError;
} // H245SystemControl()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\mrse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: mrse.c                                                    *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   mrse.c  $
 * $Revision:   1.5  $
 * $Modtime:   13 Feb 1997 19:25:48  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/mrse.c_v  $
 * 
 *    Rev 1.5   13 Feb 1997 19:31:20   MANDREWS
 * Fixed bug in generation of request mode ack and request mode reject;
 * the sequence number was not being copied into the pdu.
 * 
 *    Rev 1.4   09 Dec 1996 13:34:46   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.3   04 Jun 1996 14:01:06   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   30 May 1996 23:39:16   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.1   28 May 1996 14:25:44   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:32   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   09 May 1996 19:48:08   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.0   15 Apr 1996 10:44:52   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "mrse.h"



// Out-going/In-coming MRSE states
#define MRSE_IDLE                   0   // IDLE
#define MRSE_WAIT                   1   // AWAITING_RESPONSE



extern unsigned int uT109;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T109ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T109ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T109Expiry);
} // T109ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MRSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE0_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MRSE_OUT);
    H245ASSERT(pObject->State  == MRSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MRSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byMrseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber =
        pObject->pInstance->StateMachine.byMrseOutSequence;

    // Send Request Mode PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T109
    pObject->State = MRSE_WAIT;
    FsmStartTimer(pObject, T109ExpiryF, uT109);

    return lError;
} // MRSE0_TRANSFER_request



/*
 *  NAME
 *      MRSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == MRSE_OUT);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T109
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byMrseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber =
        pObject->pInstance->StateMachine.byMrseOutSequence;

    // Send Request Mode PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T109
    FsmStartTimer(pObject, T109ExpiryF, uT109);

    return lError;
} // MRSE1_TRANSFER_request



/*
 *  NAME
 *      MRSE1_RequestModeAckF - RequestModeAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeAckF     (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_OUT);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestModeAck:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.requestModeAck.sequenceNumber ==
        pObject->pInstance->StateMachine.byMrseOutSequence)
    {
        // Reset timer T109
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = MRSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MRSE1_RequestModeAck



/*
 *  NAME
 *      MRSE1_RequestModeRejF - RequestModeReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeRejF  (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_OUT);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE0_RequestModeRej:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.requestModeReject.sequenceNumber ==
        pObject->pInstance->StateMachine.byMrseOutSequence)
    {
        // Reset timer T109
        FsmStopTimer(pObject);

        // Send REJECT.indication to H.245 user
        // CAUSE = RequestModeReject.cause
        pObject->State = MRSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MRSE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MRSE1_RequestModeRej



/*
 *  NAME
 *      MRSE1_T109ExpiryF - timer T109 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT MRSE1_T109ExpiryF                (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    H245ASSERT(pObject->Entity == MRSE_OUT);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MRSE1_T109Expiry:%d", pObject->Key);

    // Send RequestModeRelease PDU to remote peer
    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MRSE1_T109ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = requestModeRelease_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = MRSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_MRSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // MRSE1_T109Expiry

# pragma warning( default : 4100 )



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MRSE0_RequestModeF - RequestMode received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE0_RequestModeF        (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_IN);
    H245ASSERT(pObject->State  == MRSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MRSE0_RequestMode:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber;

    // Send TRANSFER.indication to H.245 user
    pObject->State = MRSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE0_RequestMode



/*
 *  NAME
 *      MRSE1_RequestModeF - RequestMode received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeF        (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_IN);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestMode:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.sequenceNumber;

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MRSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send TRANSFER.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MRSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE1_RequestMode



/*
 *  NAME
 *      MRSE1_RequestModeReleaseF - RequestModeRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_RequestModeReleaseF (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_IN);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_RequestModeRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    // SOURCE:=PROTOCOL
    pObject->State = MRSE_IDLE;
    H245FsmIndication(pPdu, H245_IND_MRSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MRSE1_RequestModeRelease



/*
 *  NAME
 *      MRSE1_TRANSFER_responseF - TRANSFER.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_TRANSFER_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_IN);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_TRANSFER_response:%d", pObject->Key);

    // Send RequestModeAck PDU to remote peer
    pObject->State = MRSE_IDLE;
	pPdu->u.MSCMg_rspns.u.requestModeAck.sequenceNumber = pObject->byInSequence;
    return sendPDU(pObject->pInstance, pPdu);
} // MRSE1_TRANSFER_response



/*
 *  NAME
 *      MRSE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MRSE1_REJECT_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == MRSE_IN);
    H245ASSERT(pObject->State  == MRSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MRSE1_REJECT_request:%d", pObject->Key);

    // Send RequestModeReject PDU to remote
    pObject->State = MRSE_IDLE;
	pPdu->u.MSCMg_rspns.u.requestModeReject.sequenceNumber = pObject->byInSequence;
    return sendPDU(pObject->pInstance, pPdu);
} // MRSE1_REJECT_request
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\muxentry.c ===
/***********************************************************************
 *                                                                     *
 * Filename: muxentry.c                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   MUXENTRY.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/MUXENTRY.C_v  $
 * 
 *    Rev 1.5   09 Dec 1996 13:34:50   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.4   19 Jul 1996 12:12:46   EHOWARDX
 * 
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 * 
 *    Rev 1.3   14 Jun 1996 18:58:30   EHOWARDX
 * Geneva Update.
 * 
 *    Rev 1.2   04 Jun 1996 13:57:06   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.1   30 May 1996 23:39:18   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:06:34   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.14.1.3   09 May 1996 19:48:36   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.14.1.2   15 Apr 1996 10:46:00   EHOWARDX
 * Update.
 *
 *    Rev 1.14.1.1   10 Apr 1996 21:15:00   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.14.1.0   05 Apr 1996 20:52:56   EHOWARDX
 * Branched.
 *
 *    Rev 1.14   02 Apr 1996 12:01:58   helgebax
 * documented code
 *
 *    Rev 1.13   28 Mar 1996 11:20:52   helgebax
 * removed mux release, fixed return values
 *
 *    Rev 1.12   19 Mar 1996 18:09:46   helgebax
 *
 * removed include file: h245time.h
 *
 *    Rev 1.11   19 Mar 1996 17:31:36   helgebax
 *
 * added new timers
 *
 *    Rev 1.10   13 Mar 1996 11:49:14   helgebax
 * s can also access already deleted objects
 *
 *    Rev 1.9   13 Mar 1996 08:58:46   helgebax
 * No change.
 *
 *    Rev 1.8   11 Mar 1996 14:31:32   helgebax
 * removed prototype def for release function (moved to pdu.x)
 *
 *    Rev 1.7   07 Mar 1996 13:23:12   helgebax
 * changed pObject->pdu_struct to NULL in timerExpiry function because the
 * pdu pointer has been deleted
 *
 *    Rev 1.6   01 Mar 1996 13:22:46   unknown
 *
 * Changed to used pdu_id to save muxentry number so when timeout occurs
 * we can send the correct muxentry number in the MultiplexEntrySendRelease.
 *
 *    Rev 1.5   01 Mar 1996 11:47:56   unknown
 * Since nSequence was removed from header, I have commented out
 * all references to it in the code. Also, state ASSERTs have been
 * changed to reflect the fact that state changes occur BEFORE
 * calling the state function, rather than AFTER.
 *
 *    Rev 1.4   29 Feb 1996 20:57:20   helgebax
 * No change.
 *
 *    Rev 1.3   29 Feb 1996 18:19:46   EHOWARDX
 * Made changes requested by Hani.
 *
 *    Rev 1.2   28 Feb 1996 15:47:04   EHOWARDX
 *
 * First pass MTSE implementation complete.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "muxentry.h"



// Out-going/In-coming MTSE states
#define MTSE_IDLE                   0   // IDLE
#define MTSE_WAIT                   1   // AWAITING_RESPONSE



extern unsigned int uT104;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T104ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T104Expiry);
} // T104ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MTSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE0_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT                       lError;
    unsigned int                  uIndex;
    MultiplexEntryDescriptorLink  pLink;

    H245ASSERT(pObject->Entity  == MTSE_OUT);
    H245ASSERT(pObject->State == MTSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MTSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byMtseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber =
        pObject->pInstance->StateMachine.byMtseOutSequence;

    // Save information for release
    uIndex = 0;
    pLink = pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors;
    while (pLink)
    {
      pObject->u.mtse.multiplexTableEntryNumber.value[uIndex++] =
        pLink->value.multiplexTableEntryNumber;
      pLink = pLink->next;
    }
    pObject->u.mtse.multiplexTableEntryNumber.count = (unsigned short)uIndex;

    // Send MultiplexEntrySend PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T104
    pObject->State = MTSE_WAIT;
    FsmStartTimer(pObject, T104ExpiryF, uT104);

    return lError;
} // MTSE0_TRANSFER_request



/*
 *  NAME
 *      MTSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_TRANSFER_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT                       lError;
    unsigned int                  uIndex;
    MultiplexEntryDescriptorLink  pLink;

    H245ASSERT(pObject->Entity  == MTSE_OUT);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T104
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byMtseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber =
        pObject->pInstance->StateMachine.byMtseOutSequence;

    // Save information for release
    uIndex = 0;
    pLink = pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors;
    while (pLink)
    {
      pObject->u.mtse.multiplexTableEntryNumber.value[uIndex++] =
        pLink->value.multiplexTableEntryNumber;
      pLink = pLink->next;
    }
    pObject->u.mtse.multiplexTableEntryNumber.count = (unsigned short)uIndex;

    // Send MultiplexEntrySend PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T104
    FsmStartTimer(pObject, T104ExpiryF, uT104);

    return lError;
} // MTSE1_TRANSFER_request



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendAckF - MultiplexEntrySendAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendAckF     (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_OUT);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySendAck:%d", pObject->Key);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber ==
        pObject->pInstance->StateMachine.byMtseOutSequence)
    {
        // Reset timer T104
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = MTSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // MTSE1_MultiplexEntrySendAck



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendRejF - MultiplexEntrySendReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendRejF  (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_OUT);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE0_MultiplexEntrySendRej:%d", pObject->Key);

    if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber ==
        pObject->pInstance->StateMachine.byMtseOutSequence)
    {
        // Reset timer T104
        FsmStopTimer(pObject);

        // Send REJECT.indication to H.245 user
        // CAUSE = MultiplexEntrySendReject.cause
        pObject->State = MTSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, REJECT);
    }

    return 0;
} // MTSE1_MultiplexEntrySendRej



/*
 *  NAME
 *      MTSE1_T104ExpiryF - timer T104 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT MTSE1_T104ExpiryF                (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    H245ASSERT(pObject->Entity  == MTSE_OUT);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "MTSE1_T104Expiry:%d", pObject->Key);

    // Send MultiplexEntrySendRelease PDU to remote peer
    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "MTSE1_T104ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = mltplxEntrySndRls_chosen;
    pOut->u.indication.u.mltplxEntrySndRls = pObject->u.mtse;
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    // Send REJECT.indication to H.245 user
    // SOURCE = PROTOCOL
    pObject->State = MTSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_MUXTBL_SND, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
} // MTSE1_T104Expiry

# pragma warning( default : 4100 )



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      MTSE0_MultiplexEntrySendF - MultiplexEntrySend received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE0_MultiplexEntrySendF        (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_IN);
    H245ASSERT(pObject->State == MTSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "MTSE0_MultiplexEntrySend:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber;

    // Send TRANSFER.indication to H.245 user
    pObject->State = MTSE_WAIT;
    H245FsmIndication(pPdu, H245_IND_MUX_TBL, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE0_MultiplexEntrySend



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendF - MultiplexEntrySend received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendF        (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_IN);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySend:%d", pObject->Key);

    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.sequenceNumber;

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MTSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send TRANSFER.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_MUX_TBL, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE1_MultiplexEntrySend



/*
 *  NAME
 *      MTSE1_MultiplexEntrySendReleaseF - MultiplexEntrySendRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_MultiplexEntrySendReleaseF (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_IN);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_MultiplexEntrySendRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    // SOURCE:=PROTOCOL
    pObject->State = MTSE_IDLE;
    H245FsmIndication(pPdu, H245_IND_MTSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // MTSE1_MultiplexEntrySendRelease



/*
 *  NAME
 *      MTSE1_TRANSFER_responseF - TRANSFER.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_TRANSFER_responseF         (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_IN);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_TRANSFER_response:%d", pObject->Key);

    // Send MultiplexEntrySendAck PDU to remote peer
    pObject->State = MTSE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // MTSE1_TRANSFER_response



/*
 *  NAME
 *      MTSE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT MTSE1_REJECT_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity  == MTSE_IN);
    H245ASSERT(pObject->State == MTSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "MTSE1_REJECT_request:%d", pObject->Key);

    // Send MultiplexEntrySendReject PDU to remote
    pObject->State = MTSE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // MTSE1_REJECT_request
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\openb.c ===
/***********************************************************************
 *                                                                     *
 * Filename: openb.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   openb.c  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 18:05:30  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\openb.c_v $
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openb.h"
#include "pdu.x"



// Open Bi-directional Logical Channel Out-going states
#define OpenOutBReleased                 0
#define OpenOutBAwaitingEstablishment    1
#define OpenOutBEstablished              2
#define OpenOutBAwaitingRelease          3

// Open Bi-directional Logical Channel In-coming states
#define OpenInBReleased                  0
#define OpenInBAwaitingEstablishment     1
#define OpenInBAwaitingConfirmation      2
#define OpenInBEstablished               3



extern unsigned int uT103;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103OutExpiryF - Callback function called by the timer.
 *      T103InExpiryF  - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   obj        pointer to a FSM object
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T103OutExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103OutExpiry);
} // T103OutExpiryF()

int T103InExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103InExpiry);
} // T103InExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      establishReqBReleased - API request to open bidirectional channel in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishReqBReleased(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBReleased);
    H245TRACE(pObject->dwInst, 2,
              "Sending open Bidirectional channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingEstablishment;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openChannelAckBAwaitingE - received open bidirectional channel Ack in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelAckBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm to client */
    pObject->State = OpenOutBEstablished;
    H245FsmConfirm(pPdu,H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, FSM_OK);

    /* Send Open Logical Channel Confirm to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 1,
                  "openChannelAckBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_ind_open_logical_channel_conf(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);
    return lError;
}



/*
 *  NAME
 *      openChannelRejBAwaitingE - received open bidirectional channel reject in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with REJECT to API; Channel=%d",
              pObject->Key);

    /* reset  timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.indication to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      releaseReqBOutAwaitingE - API request to close bidirectional channel in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBOutAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Close (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingRelease;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      t103ExpiryBAwaitingE - handle timeout for  outstanding  open bidirectional pdu
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t103ExpiryBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingEstablishment);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_NEEDRSP_OPEN  with a timer expiry to API->Channel=%d", pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(NULL, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

    /* Send Close Logical Channel (source:=lcse) to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 1,
                  "t103ExpiryBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_req_close_logical_channel(pOut, (WORD)pObject->Key, 1);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}

# pragma warning( default : 4100 )



/*
 *  NAME
 *      releaseReqBEstablished - API request to close channel in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Bidirectional Channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingRelease;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openChannelRejBEstablished - received open reject in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_NEEDRSP_OPEN with error B then with REJECT to API->Channel=%d", pObject->Key);

    pObject->State = OpenOutBReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(B) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_B_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=B-LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeChannelAckBEstablished - received close ack in established state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelAckBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_NEEDRSP_OPEN with error C then with REJECT to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenOutBReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(C) to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_C_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication to client */
    H245FsmConfirm(pPdu, H245_CONF_NEEDRSP_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeChannelAckAwaitingR - received close ack in Awaiting Release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.confirm to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(pPdu, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openChannelRejBAwaitingR - received open reject in awaiting release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelRejBAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    return closeChannelAckAwaitingR(pObject, pPdu);
}



/*
 *  NAME
 *      t103ExpiryBAwaitingR - handle timer expiry in awaiting release
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t103ExpiryBAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with timer expiry to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutBReleased;
    H245FsmConfirm(NULL, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.confirm to client */
#endif

    return 0;
}

# pragma warning( default : 4100 )



/*
 *  NAME
 *      establishReqAwaitingR - API open request in awaiting release state
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishReqAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_OUT);
    H245ASSERT(pObject->State == OpenOutBAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "Send a (re) Open Bidirectional Channel to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutBAwaitingEstablishment;
    FsmStartTimer(pObject, T103OutExpiryF, uT103);

    return lError;
}



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      openChannelBReleased - open channel received in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBReleased(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBReleased);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* Send ESTABLISH.indication to client */
    pObject->State = OpenInBAwaitingEstablishment;
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);
    return 0;
}



/*
 *  NAME
 *      closeChannelBReleased - close channel received in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT closeChannelBReleased (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBReleased);
    H245ASSERT(pObject->Key == pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber);
    H245TRACE(pObject->dwInst, 2,
              "Close Channel (Bidirectional) received while in Released state; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Ack (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBReleased: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    return lError;
}

# pragma warning( default : 4100 )



/*
 *  NAME
 *      establishResBAwaitingE - response to an open request    with an ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT establishResBAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenAck (Bidirectional) to ASN module; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Ack to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenInBAwaitingConfirmation;
    FsmStartTimer(pObject, T103InExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      releaseReqBInAwaitingE - response to an open request with a reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT releaseReqBInAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Send OpenReject (Bidirectional) to SR module; Channel=%d", pObject->Key);

    /* Send Open Logical Channel Reject to remote peer */
    pObject->State = OpenInBReleased;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      closeChannelBAwaitingE - received close channel in Awaiting establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBAwaitingE - overriding open request
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openChannelConfirmBAwaitingE - received open confirm while awaiting establishment
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelConfirmBAwaitingE (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN_CONF with error F to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(F) to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_OPEN_CONF, pObject->pInstance, 0, ERROR_E_INAPPROPRIATE);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "openChannelConfirmBAwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=B-LCSE) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}



/*
 *  NAME
 *      t103ExpiryBAwaitingC - timer expired waiting for open confirm
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t103ExpiryBAwaitingC(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "Timer T103 expired while waiting for OpenConfirm for OpenAck");

    /* Send ERROR.indication(G) to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(NULL, H245_IND_OPEN_CONF, pObject->pInstance, pObject->dwTransId, ERROR_F_TIMEOUT);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t103ExpiryBAwaitingC: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    return lError;
}

# pragma warning( default : 4100 )



/*
 *  NAME
 *      openChannelConfirmBAwaitingC - received open confirm while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelConfirmBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN_CONF with no errors; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm to client */
    pObject->State = OpenInBEstablished;
    H245FsmIndication(pPdu, H245_IND_OPEN_CONF, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeChannelBAwaitingC - received close channel while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2,
              "Send Close Ack (Bidirectional) to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBAwaitingC: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBAwaitingC - received open channel while awaiting confirmation
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBAwaitingC (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBAwaitingConfirmation);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    pObject->State = OpenInBAwaitingEstablishment;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeChannelBEstablished - received close channel while in established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT closeChannelBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error up to API; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel Ack to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeChannelBEstablished: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pdu_rsp_close_logical_channel_ack(pOut, (WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInBReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openChannelBEstablished - received open channel while in established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a State Entity
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT openChannelBEstablished(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == BLCSE_IN);
    H245ASSERT(pObject->State == OpenInBEstablished);
    H245TRACE(pObject->dwInst, 2, "Overriding H245_IND_OPEN to API; Channel=%d", pObject->Key);

    pObject->State = OpenInBAwaitingEstablishment;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication to client */
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client*/
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\openu.c ===
/***********************************************************************
 *                                                                     *
 * Filename: openu.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   OPENU.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/OPENU.C_v  $
 * 
 *    Rev 1.5   09 Dec 1996 13:36:50   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.4   19 Jul 1996 12:12:02   EHOWARDX
 * 
 * Changed to use API events defined in H245API.H instead of FSM events
 * which are no longer defined in FSMEXPOR.H.
 * 
 *    Rev 1.3   04 Jun 1996 13:56:52   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   30 May 1996 23:39:20   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.1   28 May 1996 14:25:24   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:36   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.13.1.2   09 May 1996 19:48:32   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.13.1.1   15 Apr 1996 10:45:26   EHOWARDX
 * Update.
 *
 *    Rev 1.13.1.0   10 Apr 1996 21:14:06   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openu.h"
#include "pdu.x"



// Open Uni-directional Logical Channel Out-going states
#define OpenOutUReleased                 0
#define OpenOutUAwaitingEstablishment    1
#define OpenOutUEstablished              2
#define OpenOutUAwaitingRelease          3



// Open Uni-directional Logical Channel In-coming states
#define OpenInUReleased                  0
#define OpenInUAwaitingEstablishment     1
#define OpenInUEstablished               2



extern unsigned int uT103;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T103ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T103ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T103Expiry);
} // T103ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      establishReleased - request for open unidirectional channel from API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT establishReleased(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUReleased);
    H245TRACE(pObject->dwInst, 2, "Sending open logical channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingEstablishment;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openAckAwaitingE - received open unidirectional channel Ack in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openAckAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUAwaitingEstablishment);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send ESTABLISH.confirm (SOURCE:=USER) to client */
    pObject->State = OpenOutUEstablished;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openRejAwaitingE - received open unidirectional channel reject in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_OPEN with REJECT to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      releaseAwaitingE - close unidirectional channel in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseAwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2, "Close message to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingRelease;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      t103AwaitingE - handle timer T103 expiry
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT t103AwaitingE(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_OPEN with a timer expiry to API; Channel=%d",
              pObject->Key);

    pOut =  H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t103AwaitingE: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel (source:=lcse) to remote peer */
    pdu_req_close_logical_channel(pOut, (WORD)pObject->Key, 1);
    lError = sendPDU(pObject->pInstance,pOut);
    H245_free(pOut);

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

    return lError;
}



/*
 *  NAME
 *      releaseEstablished - send close channel while in the Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseEstablished(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2, "Send a Close Logical Channel to ASN; Channel=%d",
              pObject->Key);

    /* Send Close Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingRelease;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/*
 *  NAME
 *      openRejEstablished - received open unidirectional channel reject in Establish state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejEstablished(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_OPEN with error B then with REJECT to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenOutUReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(B) to client - not necessary */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_B_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeAckEstablished - received close unidirectional channel Ack in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAckEstablished(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUEstablished);
    H245TRACE(pObject->dwInst, 2, "H245_CONF_OPEN with error C then with REJECT to API->channel:%d", pObject->Key);

    pObject->State = OpenOutUReleased;

#if defined(SDL_COMPLIANT)
    /* Send ERROR.indication(C) to client - not necessary */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, ERROR_C_INAPPROPRIATE);
#endif

    /* Send RELEASE.indication (SOURCE:=LCSE) to client */
    H245FsmConfirm(pPdu, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);

    return 0;
}



/*
 *  NAME
 *      closeAckAwaitingR - received CloseAck/OpenReject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUAwaitingRelease);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send RELEASE.confirm to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(pPdu, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      openRejAwaitingR - received open unidirectional channel Reject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openRejAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    return closeAckAwaitingR(pObject, pPdu);
}



/*
 *  NAME
 *      t103AwaitingR - handle timer expiry for close channel
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t103AwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State  == OpenOutUAwaitingRelease);
    H245ASSERT(pPdu            == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_CLOSE with timer expiry to API; Channel=%d",
              pObject->Key);

    /* Send ERROR.indication(D) to client */
    pObject->State = OpenOutUReleased;
    H245FsmConfirm(NULL, H245_CONF_CLOSE, pObject->pInstance, pObject->dwTransId, ERROR_D_TIMEOUT);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.confirm to client - not necessary */
    H245FsmConfirm(NULL, H245_CONF_OPEN, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    return 0;
}

# pragma warning( default : 4100 )



/*
 *  NAME
 *      establishAwaitingR - open unidirectional channel request from API in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT establishAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_OUT);
    H245ASSERT(pObject->State == OpenOutUAwaitingRelease);
    H245TRACE(pObject->dwInst, 2, "send a (re) Open Channel to ASN; Channel=%d",
              pObject->Key);

    /* reset timer T103 */
    FsmStopTimer(pObject);

    /* Send Open Logical Channel to remote peer */
    lError = sendPDU(pObject->pInstance,pPdu);

    /* set timer T103 */
    pObject->State = OpenOutUAwaitingEstablishment;
    FsmStartTimer(pObject, T103ExpiryF, uT103);

    return lError;
}



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

HRESULT openReleased(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUReleased);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_OPEN with no error to API; Channel=%d",
              pObject->Key);

    /* Send ESTABLISH.indication to client */
    pObject->State = OpenInUAwaitingEstablishment;
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeReleased - received close unidirectional channel in Idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT closeReleased(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUReleased);
    H245ASSERT(pObject->Key == pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber);
    H245TRACE(pObject->dwInst, 2, "Close Channel received while in Released state; Channel=%d",
              pObject->Key);
    H245TRACE(pObject->dwInst, 2, "Send Close Ack; Channel=%d",
              pObject->Key);

    pOut =  H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeReleased: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    return lError;
}

# pragma warning( default : 4100 )



/*
 *  NAME
 *      responseAwaiting - response to an open in Awaiting Establishment state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT responseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenAck to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Ack to remote peer */
    pObject->State = OpenInUEstablished;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      releaseAwaiting - response to open with open reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT releaseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "Send OpenReject to ASN; Channel=%d",
              pObject->Key);

    /* Send Open Logical Channel Reject to remote peer */
    pObject->State = OpenInUReleased;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      closeAwaiting - received close unidirectional channel in Awaiting  state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeAwaiting: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send RELEASE.indication to client */
    pObject->State = OpenInUReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openAwaiting - received an overriding open unidirectional channel while Awaiting establishment
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUAwaitingEstablishment);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE, then H245_IND_OPEN to API; Channel=%d",
              pObject->Key);

    pObject->State = OpenInUReleased;

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client */
    H245FsmIndication( NULL, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication(pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeEstablished - received close unidirectional channel in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeEstablished(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    pOut = (PDU_t *) H245_malloc(sizeof(PDU_t ));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "closeEstablished: memory allocation failed");
        return H245_ERROR_NOMEM;
    }

    /* Send Close Logical Channel Ack to remote peer */
    pdu_rsp_close_logical_channel_ack(pOut,(WORD)pObject->Key);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send RELEASE.indication to clietn */
    pObject->State = OpenInUReleased;
    H245FsmIndication(pPdu, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);

    return lError;
}



/*
 *  NAME
 *      openEstablished - received overriding open unidirectional channel in Established state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT openEstablished(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == LCSE_IN);
    H245ASSERT(pObject->State == OpenInUEstablished);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_CLOSE followed by H245_IND_OPEN to API; Channel=%d",
              pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send RELEASE.indication (SOURCE:=USER) to client - not necessary */
    H245FsmIndication( NULL, H245_IND_CLOSE, pObject->pInstance, 0, FSM_OK);
#endif

    /* Send ESTABLISH.indication to client */
    H245FsmIndication( pPdu, H245_IND_OPEN, pObject->pInstance, 0, FSM_OK);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\pdu.c ===
/***************************************************************************
 *
 *   INTEL Corporation Proprietary Information                             
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.                             
 *                                                                         
 *   This listing is supplied under the terms of a license agreement       
 *   with INTEL Corporation and may not be used, copied, nor disclosed     
 *   except in accordance with the terms of that agreement.                
 *
 ***************************************************************************
 *                                                                         
 *  $Workfile:   pdu.c  $                                               
 *  $Revision:   1.13  $                                                 
 *  $Modtime:   27 Jan 1997 12:33:26  $                                 
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/pdu.c_v  $  
 * 
 *    Rev 1.13   27 Jan 1997 12:40:28   MANDREWS
 * 
 * Fixed warnings.
 * 
 *    Rev 1.12   28 Aug 1996 11:37:26   EHOWARDX
 * const changes.
 * 
 *    Rev 1.11   19 Aug 1996 15:38:36   EHOWARDX
 * Initialized lResult to H245_ERROR_OK in SetupCommModeEntry().
 * 
 *    Rev 1.10   15 Aug 1996 15:20:34   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 * 
 *    Rev 1.9   08 Aug 1996 16:01:56   EHOWARDX
 * 
 * Change pdu_rsp_mstslv_ack to take either master_chosen or slave_chosen
 * as second parameter.
 * 
 *    Rev 1.8   19 Jul 1996 12:14:30   EHOWARDX
 * Eliminated pdu_cmd_misc.
 * 
 *    Rev 1.7   09 Jul 1996 17:10:26   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 * 
 *    Rev 1.6   14 Jun 1996 18:58:32   EHOWARDX
 * Geneva Update.
 * 
 *    Rev 1.5   10 Jun 1996 16:52:24   EHOWARDX
 * Eliminated #include "h245init.x"
 * 
 *    Rev 1.4   30 May 1996 23:39:22   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.3   29 May 1996 15:20:22   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.2   28 May 1996 14:25:20   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.1   13 May 1996 23:16:40   EHOWARDX
 * Fixed remote terminal capability handling.
 * 
 *    Rev 1.0   09 May 1996 21:06:38   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.27   09 May 1996 19:32:46   EHOWARDX
 * Added support for new H.245 fields (e.g. SeparateStack).
 * 
 *    Rev 1.26   01 May 1996 19:28:24   EHOWARDX
 * Changed H2250_xxx defines from H2250 address type to H245_xxx defines.
 * 
 *    Rev 1.25   27 Apr 1996 21:10:42   EHOWARDX
 * Cleaned up multiplex ack parameter handling.
 * 
 *    Rev 1.23.1.5   25 Apr 1996 17:54:34   EHOWARDX
 * Changed wTxPort to dwTxPort in pdu_req_open_logical_channel().
 * 
 *    Rev 1.23.1.4   24 Apr 1996 20:51:24   EHOWARDX
 * Added new OpenLogicalChannelAck support.
 * 
 *    Rev 1.23.1.3   16 Apr 1996 20:10:58   EHOWARDX
 * Added support for H2250LogicalParameters to OpenLogicalChannel.
 * 
 *    Rev 1.23.1.2   15 Apr 1996 15:14:20   EHOWARDX
 * Updated Open Logical Channel to match current ASN.1 syntax structure.
 * 
 *    Rev 1.23.1.1   02 Apr 1996 22:35:04   EHOWARDX
 * Needed to initialize setupType.choice in H245OpenChannel.
 * (This field is probably soon to be obsolete, but right now
 * the PDU encode rejects it if it is not initialized.
 * 
 *    Rev 1.23.1.0   28 Mar 1996 20:17:18   EHOWARDX
 * 
 * Changes for new ASN syntax additions.
 * 
 *    Rev 1.22   13 Mar 1996 10:12:00   cjutzi
 * 
 * - was not puting sequence number in mux_acc or mux_rej
 * 
 *    Rev 1.21   12 Mar 1996 15:50:22   cjutzi
 * 
 * added EndSession
 * 
 *    Rev 1.20   11 Mar 1996 14:04:32   cjutzi
 * - added ind_multiplex_entry_send_release.. back in.. and to the header.. 
 * 
 *    Rev 1.19   08 Mar 1996 14:01:04   cjutzi
 * 
 * - added Multiplex Entry stuff
 * 
 *    Rev 1.18   06 Mar 1996 08:43:32   cjutzi
 * - fixed constraints on sub element lists, and nesting depth for 
 *   mux table pdu build.. 
 * 
 *    Rev 1.17   05 Mar 1996 19:40:04   EHOWARDX
 * Put pdu_ind_multiplex_entry_send_release() and
 * pdu_ind_request_multiplex_entry_release() functions back in after
 * Curt was so kind as to delete them for us.
 * 
 *    Rev 1.16   05 Mar 1996 17:33:12   cjutzi
 * 
 * - fixed, and imlemented down muxt table entries, 
 * - removed bzero/bcopy and fixed free api call
 * 
 *    Rev 1.15   02 Mar 1996 22:14:18   DABROWN1
 * 
 * updated to new h245_free (only one param)
 * 
 *    Rev 1.14   28 Feb 1996 19:06:34   unknown
 * Oops! Gotta watch those global replaces... (Changed H245H245ASSERT
 * back to H245ASSERT)
 * 
 *    Rev 1.13   28 Feb 1996 18:29:34   EHOWARDX
 * Changed ASSERT() to H245ASSERT().
 * 
 *    Rev 1.12   28 Feb 1996 16:08:36   EHOWARDX
 * 
 * Changed pTable to WORD pointer.
 * 
 *    Rev 1.11   28 Feb 1996 14:01:42   EHOWARDX
 * 
 * Added MultiplexEntry functions:
 *   pdu_req_multiplex_entry_send
 *   pdu_rsp_multiplex_entry_send_ack
 *   pdu_rsp_multiplex_entry_send_reject
 *   pdu_ind_multiplex_entry_send_release
 *   pdu_ind_request_multiplex_entry_release
 * 
 *    Rev 1.10   26 Feb 1996 17:25:14   cjutzi
 * 
 * - implemented MISCCMD command for PDU's 
 * 
 *    Rev 1.9   26 Feb 1996 09:24:30   cjutzi
 * - removed req_termcqap_set (bit_mask) setup.. moved to main line
 *   code.. rather than the pdu build.. 
 * 
 *    Rev 1.8   22 Feb 1996 12:43:16   unknown
 * Fixed bitmask Open Ack problem
 * 
 *    Rev 1.7   21 Feb 1996 14:17:36   unknown
 * No change.
 * 
 *    Rev 1.6   15 Feb 1996 10:55:16   cjutzi
 * 
 * - fixed open pdu problem bit-mask
 * - changed interface for MUX_T
 * 
 *    Rev 1.5   13 Feb 1996 14:39:48   DABROWN1
 * Removed SPOX dependent include files from mainline
 * 
 *    Rev 1.4   13 Feb 1996 13:27:04   cjutzi
 * - fixed a problem w/ open channel
 * 
 *    Rev 1.3   09 Feb 1996 15:49:48   cjutzi
 * 
 * - added dollar log to header.
 * - changed bitmask on open.. hadn't set forward open parameters to present..
 *
 ***************************************************************************/
#define STRICT 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

/***********************/
/*   SYSTEM INCLUDES   */
/***********************/

/***********************/
/* HTF SYSTEM INCLUDES */
/***********************/

#ifdef OIL
# include <oil.x>
# include <common.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245asn1.h"                   /* must be included before H245api.h */
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "api_util.x"	                /* for free_mux_desc_list */
#include "pdu.x"



HRESULT
SetupUnicastAddress (UnicastAddress                  *pOut,
                     const H245_TRANSPORT_ADDRESS_T  *pIn)
{
  switch (pIn->type)
  {
  case H245_IP_UNICAST:
    pOut->choice = UnicastAddress_iPAddress_chosen;
    pOut->u.UnicastAddress_iPAddress.network.length = 4;
    memcpy(pOut->u.UnicastAddress_iPAddress.network.value, pIn->u.ip.network, 4);
    pOut->u.UnicastAddress_iPAddress.tsapIdentifier = pIn->u.ip.tsapIdentifier;
    break;

  case H245_IP6_UNICAST:
    pOut->choice = UncstAddrss_iP6Address_chosen;
    pOut->u.UncstAddrss_iP6Address.network.length = 16;
    memcpy(pOut->u.UncstAddrss_iP6Address.network.value, pIn->u.ip6.network, 16);
    pOut->u.UncstAddrss_iP6Address.tsapIdentifier = pIn->u.ip6.tsapIdentifier;
    break;

  case H245_IPSSR_UNICAST:
    pOut->choice = iPSourceRouteAddress_chosen;
    pOut->u.iPSourceRouteAddress.routing.choice = strict_chosen;
    pOut->u.iPSourceRouteAddress.network.length = 4;
    memcpy(pOut->u.iPSourceRouteAddress.network.value, pIn->u.ipSourceRoute.network, 4);
    pOut->u.iPSourceRouteAddress.tsapIdentifier = pIn->u.ipSourceRoute.tsapIdentifier;
    // TBD - handle route
    return H245_ERROR_NOTIMP;
    break;

  case H245_IPLSR_UNICAST:
    pOut->choice = iPSourceRouteAddress_chosen;
    pOut->u.iPSourceRouteAddress.routing.choice = loose_chosen;
    pOut->u.iPSourceRouteAddress.network.length = 4;
    memcpy(pOut->u.iPSourceRouteAddress.network.value, pIn->u.ipSourceRoute.network, 4);
    pOut->u.iPSourceRouteAddress.tsapIdentifier = pIn->u.ipSourceRoute.tsapIdentifier;
    // TBD - handle route
    return H245_ERROR_NOTIMP;
    break;

  case H245_IPX_UNICAST:
    pOut->choice = iPXAddress_chosen;
    pOut->u.iPXAddress.node.length = 6;
    memcpy(pOut->u.iPXAddress.node.value, pIn->u.ipx.node, 6);
    pOut->u.iPXAddress.netnum.length = 4;
    memcpy(pOut->u.iPXAddress.netnum.value, pIn->u.ipx.netnum, 4);
    pOut->u.iPXAddress.tsapIdentifier.length = 2;
    memcpy(pOut->u.iPXAddress.tsapIdentifier.value, pIn->u.ipx.tsapIdentifier, 2);
    break;

  case H245_NETBIOS_UNICAST:
    pOut->choice = netBios_chosen;
    pOut->u.netBios.length = 16;
    memcpy(pOut->u.netBios.value, pIn->u.netBios, 16);
    break;

  default:
	  H245TRACE(0,1,"API:SetupUnicastAddress: invalid address type %d", pIn->type);
    return H245_ERROR_PARAM;
  } // switch

  return H245_ERROR_OK;
} // SetupUnicastAddress()


 
HRESULT
SetupMulticastAddress (MulticastAddress                *pOut,
                       const H245_TRANSPORT_ADDRESS_T  *pIn)
{
  switch (pIn->type)
  {
  case H245_IP_MULTICAST:
    pOut->choice = MltcstAddrss_iPAddress_chosen;
    pOut->u.MltcstAddrss_iPAddress.network.length = 4;
    memcpy(pOut->u.MltcstAddrss_iPAddress.network.value, pIn->u.ip.network, 4);
    pOut->u.MltcstAddrss_iPAddress.tsapIdentifier = pIn->u.ip.tsapIdentifier;
    break;

  case H245_IP6_MULTICAST:
    pOut->choice = MltcstAddrss_iP6Address_chosen;
    pOut->u.MltcstAddrss_iP6Address.network.length = 16;
    memcpy(pOut->u.MltcstAddrss_iP6Address.network.value, pIn->u.ip6.network, 16);
    pOut->u.MltcstAddrss_iP6Address.tsapIdentifier = pIn->u.ip6.tsapIdentifier;
    break;

  default:
    H245TRACE(0,1,"API:SetupMulticastAddress: invalid address type %d", pIn->type);
    return H245_ERROR_PARAM;
  } // switch

  return H245_ERROR_OK;
} // SetupMulticastAddress()


 
HRESULT
SetupTransportAddress ( TransportAddress               *pOut,
                        const H245_TRANSPORT_ADDRESS_T *pIn)
{
  if (pIn->type & 1)
  {
    pOut->choice = unicastAddress_chosen;
    return SetupUnicastAddress(&pOut->u.unicastAddress, pIn);
  }
  else
  {
    pOut->choice = multicastAddress_chosen;
    return SetupMulticastAddress(&pOut->u.multicastAddress, pIn);
  }
} // SetupTransportAddress()


 
HRESULT
SetupCommModeEntry    ( CommunicationModeTableEntry        *pOut,
                        const H245_COMM_MODE_ENTRY_T       *pIn)
{
  HRESULT   lResult = H245_ERROR_OK;

  memset(pOut, 0, sizeof(*pOut));
  if (pIn->pNonStandard != NULL)
  {
    pOut->CMTEy_nnStndrd = pIn->pNonStandard;
    pOut->bit_mask |= CMTEy_nnStndrd_present;
  }

  pOut->sessionID = pIn->sessionID;

  if (pIn->associatedSessionIDPresent)
  {
    pOut->CMTEy_assctdSssnID = pIn->associatedSessionID;
    pOut->bit_mask |= CMTEy_assctdSssnID_present;
  }

  if (pIn->terminalLabelPresent)
  {
    pOut->terminalLabel = pIn->terminalLabel;
    pOut->bit_mask |= terminalLabel_present;
  }

  pOut->sessionDescription.value  = pIn->pSessionDescription;
  pOut->sessionDescription.length = pIn->wSessionDescriptionLength;

  switch (pIn->dataType.ClientType)
  {
  case H245_CLIENT_VID_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_NONSTD");
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_videoData.u.VdCpblty_nonStandard,
                                       &pIn->dataType.Cap.H245Vid_NONSTD);
    pOut->dataType.u.dataType_videoData.choice = VdCpblty_nonStandard_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H261:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H261");
    pOut->dataType.u.dataType_videoData.u.h261VideoCapability = pIn->dataType.Cap.H245Vid_H261;
    pOut->dataType.u.dataType_videoData.choice = h261VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H262:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H262");
    pOut->dataType.u.dataType_videoData.u.h262VideoCapability = pIn->dataType.Cap.H245Vid_H262;
    pOut->dataType.u.dataType_videoData.choice = h262VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_H263:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_H263");
    pOut->dataType.u.dataType_videoData.u.h263VideoCapability = pIn->dataType.Cap.H245Vid_H263;
    pOut->dataType.u.dataType_videoData.choice = h263VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;
  case H245_CLIENT_VID_IS11172:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_VID_IS11172");
    pOut->dataType.u.dataType_videoData.u.is11172VideoCapability = pIn->dataType.Cap.H245Vid_IS11172;
    pOut->dataType.u.dataType_videoData.choice = is11172VideoCapability_chosen;
    pOut->dataType.choice = dataType_videoData_chosen;
    break;

  case H245_CLIENT_AUD_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_NONSTD");
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_audioData.u.AdCpblty_nonStandard,
                                      &pIn->dataType.Cap.H245Aud_NONSTD);
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_nonStandard_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;



    break;
  case H245_CLIENT_AUD_G711_ALAW64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ALAW64");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Alaw64k = pIn->dataType.Cap.H245Aud_G711_ALAW64;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Alaw64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ALAW56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ALAW56");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Alaw56k = pIn->dataType.Cap.H245Aud_G711_ALAW56;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Alaw56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ULAW64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ULAW64");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Ulaw64k = pIn->dataType.Cap.H245Aud_G711_ULAW64;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Ulaw64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G711_ULAW56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G711_ULAW56");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g711Ulaw56k = pIn->dataType.Cap.H245Aud_G711_ULAW56;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g711Ulaw56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_64:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_64");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_64k = pIn->dataType.Cap.H245Aud_G722_64;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_64k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_56:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_56");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_56k = pIn->dataType.Cap.H245Aud_G722_56;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_56k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G722_48:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G722_48");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g722_48k = pIn->dataType.Cap.H245Aud_G722_48;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g722_48k_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G723:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G723");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g7231 = pIn->dataType.Cap.H245Aud_G723;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g7231_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G728:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G728");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g728 = pIn->dataType.Cap.H245Aud_G728;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g728_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_G729:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_G729");
    pOut->dataType.u.dataType_audioData.u.AudioCapability_g729 = pIn->dataType.Cap.H245Aud_G729;
    pOut->dataType.u.dataType_audioData.choice = AudioCapability_g729_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_GDSVD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_GDSVD");
    pOut->dataType.u.dataType_audioData.u.AdCpblty_g729AnnexA = pIn->dataType.Cap.H245Aud_GDSVD;
    pOut->dataType.u.dataType_audioData.choice = AdCpblty_g729AnnexA_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_IS11172:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_IS11172");
    pOut->dataType.u.dataType_audioData.u.is11172AudioCapability = pIn->dataType.Cap.H245Aud_IS11172;
    pOut->dataType.u.dataType_audioData.choice = is11172AudioCapability_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;
  case H245_CLIENT_AUD_IS13818:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_AUD_IS13818");
    pOut->dataType.u.dataType_audioData.u.is13818AudioCapability = pIn->dataType.Cap.H245Aud_IS13818;
    pOut->dataType.u.dataType_audioData.choice = is13818AudioCapability_chosen;
    pOut->dataType.choice = dataType_audioData_chosen;
    break;

  case H245_CLIENT_DAT_NONSTD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_NONSTD");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_NONSTD;
    lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_nnStndrd,
                                            &pIn->dataType.Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd);
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_nnStndrd_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T120:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T120");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T120;
    if (pIn->dataType.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t120_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_DSMCC:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_DSMCC");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_DSMCC;
    if (pIn->dataType.Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_dsm_cc_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_USERDATA:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_USERDATA");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_USERDATA;
    if (pIn->dataType.Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd,
                                            &pIn->dataType.Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_usrDt_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T84:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T84");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T84;
    if (pIn->dataType.Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd,
                                                  &pIn->dataType.Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t84_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_T434:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_T434");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_T434;
    if (pIn->dataType.Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_T434.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_t434_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_H224:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_H224");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_H224;
    if (pIn->dataType.Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_H224.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_h224_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_NLPID:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_NLPID");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_NLPID;
    if (pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd,
                                                &pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
    }
    if (lResult == H245_ERROR_OK && pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length != 0)
    {
      pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value =
        H245_malloc(pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
      if (pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value)
      {
        memcpy(pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value,
                pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.value,
                pIn->dataType.Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
      }
      else
        lResult = H245_ERROR_NOMEM;
    }
    else
      pOut->dataType.u.dataType_data.application.u.DACy_applctn_nlpd.nlpidData.value = NULL;

    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_nlpd_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_DSVD:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_DSVD");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_DSMCC;
    pOut->dataType.u.dataType_data.application.choice = DACy_applctn_dsvdCntrl_chosen;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  case H245_CLIENT_DAT_H222:
    H245TRACE(0,20,"SetupCommModeEntry: H245_CLIENT_DAT_H222");
    pOut->dataType.u.dataType_data = pIn->dataType.Cap.H245Dat_H222;
    if (pIn->dataType.Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      lResult = CopyNonStandardParameter(&pOut->dataType.u.dataType_data.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd,
                                         &pIn->dataType.Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
    }
    pOut->dataType.u.dataType_data.application.choice = DACy_an_h222DtPrttnng_chosen ;
    pOut->dataType.choice = dataType_data_chosen;
    break;
  default:
    H245TRACE(0,20,"SetupCommModeEntry: default");
    lResult = H245_ERROR_NOSUP;
  } /* switch */
  if (lResult)
    return lResult;

  if (pIn->mediaChannelPresent)
  {
    lResult = SetupTransportAddress(&pOut->CMTEy_mdChnnl, &pIn->mediaChannel);
    if (lResult)
      return lResult;
    pOut->bit_mask |= CMTEy_mdChnnl_present;
  }

  if (pIn->mediaGuaranteedPresent)
  {
    pOut->CMTEy_mdGrntdDlvry = pIn->mediaGuaranteed;
    pOut->bit_mask |= CMTEy_mdGrntdDlvry_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    lResult = SetupTransportAddress(&pOut->CMTEy_mdCntrlChnnl, &pIn->mediaControlChannel);
    if (lResult)
      return lResult;
    pOut->bit_mask |= CMTEy_mdCntrlChnnl_present;
  }

  if (pIn->mediaControlGuaranteedPresent)
  {
    pOut->CMTEy_mdCntrlGrntdDlvry = pIn->mediaControlGuaranteed;
    pOut->bit_mask |= CMTEy_mdCntrlGrntdDlvry_present;
  }

  return H245_ERROR_OK;
} // SetupCommModeEntry()



/*****************************************************************************
 *                                                                            
 * TYPE:        Local
 *                                                                            
 * PROCEDURE:   setup_H223_mux
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
static HRESULT
setup_H222_mux (H222LogicalChannelParameters         *pOut, 
                const H245_H222_LOGICAL_PARAM_T      *pIn)
{
  /* See load_H222_param() for inverse function */
  pOut->bit_mask     = 0;
  pOut->resourceID   = pIn->resourceID;
  pOut->subChannelID = pIn->subChannelID;
  if (pIn->pcr_pidPresent)
  {
    pOut->bit_mask |= pcr_pid_present;
    pOut->pcr_pid = pIn->pcr_pid;
  }
  if (pIn->programDescriptors.length && pIn->programDescriptors.value)
  {
    pOut->bit_mask |= programDescriptors_present;
    pOut->programDescriptors.length = (WORD)pIn->programDescriptors.length;
    pOut->programDescriptors.value  = pIn->programDescriptors.value;
  }
  if (pIn->streamDescriptors.length && pIn->streamDescriptors.value)
  {
    pOut->bit_mask |= streamDescriptors_present;
    pOut->streamDescriptors.length = (WORD)pIn->streamDescriptors.length;
    pOut->streamDescriptors.value  = pIn->streamDescriptors.value;
  }
  return H245_ERROR_OK;
} // setup_H222_mux

static HRESULT
setup_H223_mux (H223LogicalChannelParameters         *pOut, 
		            const H245_H223_LOGICAL_PARAM_T      *pIn)
{
  /* See load_H223_param() for inverse function */
  switch (pIn->AlType)
  {
  case H245_H223_AL_NONSTD:
    pOut->adaptationLayerType.u.H223LCPs_aLTp_nnStndrd = pIn->H223_NONSTD;
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_nnStndrd_chosen;  
    break;
    
  case H245_H223_AL_AL1FRAMED:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al1Frmd_chosen; 
    break;
    
  case H245_H223_AL_AL1NOTFRAMED:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al1NtFrmd_chosen; 
    break;
    
  case H245_H223_AL_AL2NOSEQ:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_a2WSNs_1_chosen;
    break;

  case H245_H223_AL_AL2SEQ:   
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_a2WSNs_2_chosen;
    break;

  case H245_H223_AL_AL3:
    pOut->adaptationLayerType.choice = H223LCPs_aLTp_al3_chosen;
    pOut->adaptationLayerType.u.H223LCPs_aLTp_al3.controlFieldOctets = pIn->CtlFldOctet;
    pOut->adaptationLayerType.u.H223LCPs_aLTp_al3.sendBufferSize = pIn->SndBufSize;
    break;

  default:
	 H245TRACE(0,1,"API:setup_H223_mux: invalid AlType %d", pIn->AlType);
    return H245_ERROR_PARAM;
  } /* switch */

  /* segmentation flag */
  pOut->segmentableFlag = pIn->SegmentFlag;
  
  return H245_ERROR_OK;
} // setup_H223_mux

static HRESULT
setup_VGMUX_mux(V76LogicalChannelParameters        *pOut, 
                const H245_VGMUX_LOGICAL_PARAM_T   *pIn)
{
  /* See load_VGMUX_param() for inverse function */
  pOut->hdlcParameters.crcLength.choice       = (unsigned short)pIn->crcLength;
  pOut->hdlcParameters.n401                   = pIn->n401;
  pOut->hdlcParameters.loopbackTestProcedure  = pIn->loopbackTestProcedure;
  pOut->suspendResume.choice                  = (unsigned short)pIn->suspendResume;
  pOut->uIH                                   = pIn->uIH;
  pOut->mode.choice                           = (unsigned short)pIn->mode;
  switch (pIn->mode)
  {
  case H245_V76_ERM:
    pOut->mode.u.eRM.windowSize               = pIn->windowSize;
    pOut->mode.u.eRM.recovery.choice          = (unsigned short)pIn->recovery;
    break;

  } // switch
  pOut->v75Parameters.audioHeaderPresent = pIn->audioHeaderPresent;
  return H245_ERROR_OK;
} // setup_VGMUX_mux

static HRESULT
setup_H2250_mux(H2250LogicalChannelParameters  *pOut,
                const H245_H2250_LOGICAL_PARAM_T     *pIn)
{
  /* See load_H2250_param() for inverse function */
  HRESULT                lError = H245_ERROR_OK;

  pOut->bit_mask = 0;

  if (pIn->nonStandardList)
  {
    pOut->H2250LCPs_nnStndrd = pIn->nonStandardList;
    pOut->bit_mask |= H2250LCPs_nnStndrd_present;
  }

  pOut->sessionID = pIn->sessionID;

  if (pIn->associatedSessionIDPresent)
  {
    pOut->H2250LCPs_assctdSssnID = pIn->associatedSessionID;
    pOut->bit_mask |= H2250LCPs_assctdSssnID_present;
  }

  if (pIn->mediaChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCPs_mdChnnl,
                                     &pIn->mediaChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCPs_mdChnnl_present;
      }
    }
  }

  if (pIn->mediaGuaranteedPresent)
  {
    pOut->H2250LCPs_mdGrntdDlvry = pIn->mediaGuaranteed;
    pOut->bit_mask |= H2250LCPs_mdGrntdDlvry_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCPs_mdCntrlChnnl,
                                     &pIn->mediaControlChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCPs_mdCntrlChnnl_present;
      }
    }
  }

  if (pIn->mediaControlGuaranteedPresent)
  {
    pOut->H2250LCPs_mCGDy = pIn->mediaControlGuaranteed;
    pOut->bit_mask |= H2250LCPs_mCGDy_present;
  }

  if (pIn->silenceSuppressionPresent)
  {
    pOut->silenceSuppression = pIn->silenceSuppression;
    pOut->bit_mask |= silenceSuppression_present;
  }

  if (pIn->destinationPresent)
  {
    pOut->destination = pIn->destination;
    pOut->bit_mask |= destination_present;
  }

  if (pIn->mediaControlChannelPresent)
  {
    pOut->bit_mask |= H2250LCPs_mdCntrlChnnl_present;
    lError = SetupTransportAddress(&pOut->H2250LCPs_mdCntrlChnnl,
                                     &pIn->mediaControlChannel);
  }

  if (pIn->dynamicRTPPayloadTypePresent)
  {
    pOut->H2250LCPs_dRTPPTp = pIn->dynamicRTPPayloadType;
    pOut->bit_mask |= H2250LCPs_dRTPPTp_present;
  }

  if (pIn->h261aVideoPacketization)
  {
    pOut->mediaPacketization.choice = h261aVideoPacketization_chosen;
    pOut->bit_mask |= mediaPacketization_present;
  }

  return lError;
} // setup_H2250_mux

static HRESULT
setup_H2250ACK_mux(H2250LgclChnnlAckPrmtrs             *pOut,
                   const H245_H2250ACK_LOGICAL_PARAM_T *pIn)
{
  /* See load_H2250ACK_param() for inverse function */
  HRESULT                lError = H245_ERROR_OK;

  pOut->bit_mask = 0;

  if (pIn->nonStandardList)
  {
    pOut->H2250LCAPs_nnStndrd = pIn->nonStandardList;
    pOut->bit_mask |= H2250LCAPs_nnStndrd_present;
  }

  if (pIn->sessionIDPresent)
  {
    pOut->sessionID = pIn->sessionID;
    pOut->bit_mask |= sessionID_present;
  }

  if (pIn->mediaChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCAPs_mdChnnl,
                                     &pIn->mediaChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCAPs_mdChnnl_present;
      }
    }
  }

  if (pIn->mediaControlChannelPresent)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = SetupTransportAddress(&pOut->H2250LCAPs_mdCntrlChnnl,
                                       &pIn->mediaControlChannel);
      if (lError == H245_ERROR_OK)
      {
        pOut->bit_mask |= H2250LCAPs_mdCntrlChnnl_present;
      }
    }
  }

  if (pIn->dynamicRTPPayloadTypePresent)
  {
    pOut->H2250LCAPs_dRTPPTp = pIn->dynamicRTPPayloadType;
    pOut->bit_mask |= H2250LCAPs_dRTPPTp_present;
  }

  return lError;
} // setup_H2250ACK_mux



/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION: 
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_req_open_channel (  PDU_T *         pPdu,
                        WORD            wTxChannel,
                        DWORD           dwTxPort,
                        const H245_TOTCAP_T * pTxMode,
                        const H245_MUX_T    * pTxMux,
                        const H245_TOTCAP_T * pRxMode,
                        const H245_MUX_T    * pRxMux,
                        const H245_ACCESS_T * pSeparateStack)
{
  RequestMessage               *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  struct OpenLogicalChannel    *pPdu_olc = &p_req->u.openLogicalChannel;
  HRESULT                       lError;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = openLogicalChannel_chosen;

  H245ASSERT(pTxMode);
  H245ASSERT(pTxMux);

  /* Initialize bit masks to 0 */
  /* --> bit_mask no reverse parameters, no reverse mux table parameters */
  pPdu_olc->bit_mask = 0;
  /* no port number present */
  pPdu_olc->forwardLogicalChannelParameters.bit_mask = 0;
  /* no reverse mulitiplex parameters present    */
  pPdu_olc->OLCl_rLCPs.bit_mask = 0;

  /************************************************************/
  /* SETUP THE CHANNEL INFORMATION (NOT MUX STUFF : SEE BELOW */
  /************************************************************/

  /*************************/
  /* FORWARD CHANNEL STUFF */
  /*************************/

  /* --> forwardLogicalChannelNumber */
  pPdu_olc->forwardLogicalChannelNumber = wTxChannel;

  /* --> forwardLogicalChannelParameters                */
  /*    -->forwardLogicalChannelParameters.bit_mask     */
  /*    -->forwardLogicalChannelParameters.fLCPs_prtNmbr*/

  /*    -->forwardLogicalChannelParameters.dataType     */


  /* if port present .. make it so.. (beam me up scotty) */
  if (dwTxPort != H245_INVALID_PORT_NUMBER)
  {
    pPdu_olc->forwardLogicalChannelParameters.bit_mask |= fLCPs_prtNmbr_present;
    pPdu_olc->forwardLogicalChannelParameters.fLCPs_prtNmbr = (WORD)dwTxPort;
  }

  /* select the data type */
  switch (pTxMode->DataType)
    {
    case H245_DATA_NONSTD:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_nonStandard_chosen;
      break;
    case H245_DATA_NULL:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = nullData_chosen;
      break;
    case H245_DATA_VIDEO:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_videoData_chosen;
      break;
    case H245_DATA_AUDIO:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_audioData_chosen;
      break;
    case H245_DATA_DATA:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = DataType_data_chosen;
      break;
    case H245_DATA_ENCRYPT_D:
      pPdu_olc->forwardLogicalChannelParameters.dataType.choice = encryptionData_chosen;
      return H245_ERROR_NOTIMP;     // TBD
      break;
    default:
	   H245TRACE(0,1,"API:pdu_req_open_channel: invalid TX DataType %d", pTxMode->DataType);
      return H245_ERROR_PARAM;
    } /* switch */

  /* in the DataType.. load the capability */
  lError = load_cap((struct Capability *)&pPdu_olc->forwardLogicalChannelParameters.dataType, pTxMode);
  if (lError != H245_ERROR_OK)
    {
      return lError;
    }
  
  /********************************/
  /* FORWARD MUX H223 PARAM STUFF */
  /********************************/
  
  /* set forward parameters choices */
  /*    -->forwardLogicalChannelParameters.multiplexParameters.choice                   */
  /*    -->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs     */
  switch (pTxMux->Kind)
  {
  case H245_H222:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h222LCPs_chosen;
    lError = setup_H222_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs,
                             &pTxMux->u.H222);
    break;

  case H245_H223:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice =
      fLCPs_mPs_h223LCPs_chosen;
    lError = setup_H223_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h223LCPs,
                             &pTxMux->u.H223);
    break;

  case H245_VGMUX:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice = 
      fLCPs_mPs_v76LCPs_chosen;
    lError = setup_VGMUX_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_v76LCPs,
                              &pTxMux->u.VGMUX);
    break;

  case H245_H2250:
    pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.choice = 
      fLCPs_mPs_h2250LCPs_chosen;
    lError = setup_H2250_mux(&pPdu_olc->forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h2250LCPs,
                              &pTxMux->u.H2250);
    // TBD - Add Network Access Parameters support
    break;

  default:
    H245TRACE(0,1,"API:pdu_req_open_channel: invalid TX Mux Kind %d", pTxMux->Kind);
    lError = H245_ERROR_PARAM;
  } /* switch */
  if (lError != H245_ERROR_OK)
    return lError; 

  /*************************/
  /* REVERSE CHANNEL STUFF */
  /*************************/

  if (pRxMode)
    {
      /* --> bit_mask reverse parameters exist !!!! party..down garth..  */
      pPdu_olc->bit_mask |= OLCl_rLCPs_present;
      /*        -->OLCl_rLCPs.dataType  */

      /* select the data type */
      switch (pRxMode->DataType)
        {
        case H245_DATA_NONSTD:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_nonStandard_chosen;
          break;
        case H245_DATA_NULL:
          pPdu_olc->OLCl_rLCPs.dataType.choice = nullData_chosen;
          break;
        case H245_DATA_VIDEO:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_videoData_chosen;
          break;
        case H245_DATA_AUDIO:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_audioData_chosen;
          break;
        case H245_DATA_DATA:
          pPdu_olc->OLCl_rLCPs.dataType.choice = DataType_data_chosen;
          break;
        case H245_DATA_ENCRYPT_D:
          pPdu_olc->OLCl_rLCPs.dataType.choice = encryptionData_chosen;
          return H245_ERROR_NOTIMP;     // TBD
          break;
        default:
	       H245TRACE(0,1,"API:pdu_req_open_channel: invalid RX DataType %d", pRxMode->DataType);
          return H245_ERROR_PARAM;
        } /* switch */
        
      /* in the DataType.. load the capability */
      lError = load_cap((struct Capability *)&pPdu_olc->OLCl_rLCPs.dataType, pRxMode);
      if (lError != H245_ERROR_OK)
        {
          return lError;
        }

      /********************************/
      /* REVERSE MUX H223 PARAM STUFF */
      /********************************/
      
      if (pRxMux)
        {
              /* set reverse parameters choices         */
              /*        -->OLCl_rLCPs.dataType          */
              /*        -->OLCl_rLCPs.bit_mask  */
              /* set them to be present.. and it was so */
              
          switch (pRxMux->Kind)
            {
            case H245_H223:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_h223LCPs_chosen;
              lError = setup_H223_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h223LCPs,
                                        &pRxMux->u.H223);
              break;
              
            case H245_VGMUX:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_v76LCPs_chosen;
              lError = setup_VGMUX_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_v76LCPs,
                                         &pRxMux->u.VGMUX);
              break;
              
            case H245_H2250:
              pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice = rLCPs_mPs_h2250LCPs_chosen;
              lError = setup_H2250_mux (&pPdu_olc->OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h2250LCPs,
                                         &pRxMux->u.H2250);
              break;
              
            default:
              H245TRACE(0,1,"API:pdu_req_open_channel: invalid RX Mux Kind %d", pRxMux->Kind);
              lError = H245_ERROR_PARAM;
            } /* switch */
            if (lError != H245_ERROR_OK)
              return lError; 

            pPdu_olc->OLCl_rLCPs.bit_mask |= OLCl_rLCPs_mltplxPrmtrs_present; /* reverse multiplex parameters present */

        } /* if pRxMux */
    } /* if pRxMode */

  if (pSeparateStack)
  {
    pPdu_olc->bit_mask |= OpnLgclChnnl_sprtStck_present;
    pPdu_olc->OpnLgclChnnl_sprtStck = *pSeparateStack;
  }

  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_open_logical_channel_ack (  PDU_T *               pPdu,
				                            WORD                  wRxChannel,
                                    const H245_MUX_T *    pRxMux,
				                            WORD                  wTxChannel,
				                            const H245_MUX_T *    pTxMux, // for H.222/H.225.0 only
                                    DWORD                 dwTxPort,
                                    const H245_ACCESS_T * pSeparateStack)
{
  OpenLogicalChannelAck  *pAck = &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck;
  HRESULT                 lError;

  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = openLogicalChannelAck_chosen;

  pAck->bit_mask = 0;                   // Initialize bit mask

  pAck->forwardLogicalChannelNumber = wRxChannel;

  if (wTxChannel != 0)
  {
    pAck->bit_mask |= OLCAk_rLCPs_present;

    pAck->OLCAk_rLCPs.bit_mask = 0;     // Initialize bit mask
    pAck->OLCAk_rLCPs.reverseLogicalChannelNumber = wTxChannel;
    if (dwTxPort != H245_INVALID_PORT_NUMBER)
    {
      pAck->OLCAk_rLCPs.bit_mask |= rLCPs_prtNmbr_present;
      pAck->OLCAk_rLCPs.rLCPs_prtNmbr = (WORD)dwTxPort;
    }

    if (pTxMux)
    {
      pAck->OLCAk_rLCPs.bit_mask |= OLCAk_rLCPs_mPs_present;
      lError = H245_ERROR_PARAM;
      switch (pTxMux->Kind)
      {
      case H245_H222:
        pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice = rLCPs_mPs_h222LCPs_chosen;
        lError = setup_H222_mux(&pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.rLCPs_mPs_h222LCPs,
                                  &pTxMux->u.H222);
        break;

      case H245_H2250:
        pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice = mPs_h2250LgclChnnlPrmtrs_chosen;
        lError = setup_H2250_mux(&pAck->OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.mPs_h2250LgclChnnlPrmtrs,
                                      &pTxMux->u.H2250);
        break;

      } // switch
      if (lError != H245_ERROR_OK)
        return lError;
    } // if
  } // if

  if (pSeparateStack)
  {
    pAck->bit_mask |= OLCAk_sprtStck_present;
    pAck->OLCAk_sprtStck = *pSeparateStack;
  }

  if (pRxMux)
  {
    pAck->bit_mask |= frwrdMltplxAckPrmtrs_present;
    lError = H245_ERROR_PARAM;
    switch (pRxMux->Kind)
    {
    case H245_H2250ACK:
      pAck->frwrdMltplxAckPrmtrs.choice = h2250LgclChnnlAckPrmtrs_chosen;
      lError = setup_H2250ACK_mux(&pAck->frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs,
                                    &pRxMux->u.H2250ACK);
      break;

    } // switch
    if (lError != H245_ERROR_PARAM)
      return lError;
  }

  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_open_logical_channel_rej (  PDU_T *         pPdu,
				                            WORD            wRxChannel,
				                            WORD            wCause)
{
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = openLogicalChannelReject_chosen;
  pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber = wRxChannel;
  pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice = wCause;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_ind_open_logical_channel_conf ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  IndicationMessage     *p_ind = &pPdu->u.indication;
  OpenLogicalChannelConfirm *pPdu_olcc = &(p_ind->u.opnLgclChnnlCnfrm);
  p_ind->choice = opnLgclChnnlCnfrm_chosen;

  pPdu->choice = indication_chosen;
  pPdu_olcc->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_req_request_close_channel(PDU_T *pPdu,
			                        WORD                 wChannel)
{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  RequestChannelClose   *pPdu_rcc = &(p_req->u.requestChannelClose);

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = requestChannelClose_chosen;
  pPdu_rcc->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_req_close_logical_channel (PDU_T *pPdu,
			                         WORD                wChannel,
			                         DWORD               user_lcse) /* 0=user */
							                                                /* 1=lcse */

{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  CloseLogicalChannel   *pPdu_cc = &(p_req->u.closeLogicalChannel);
  p_req->choice = closeLogicalChannel_chosen;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_cc->forwardLogicalChannelNumber = wChannel;
  if (user_lcse)
    pPdu_cc->source.choice = lcse_chosen;
  else
    pPdu_cc->source.choice = user_chosen;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_close_logical_channel_ack ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  ResponseMessage       *p_rsp = &pPdu->u.MSCMg_rspns;
  CloseLogicalChannelAck        *pPdu_clca = &(p_rsp->u.closeLogicalChannelAck);

  p_rsp->choice = closeLogicalChannelAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_clca->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_request_channel_close_ack ( PDU_T *pPdu,
				                            WORD                 wChannel)
{
  ResponseMessage       *p_rsp = &pPdu->u.MSCMg_rspns;
  RequestChannelCloseAck *pPdu_rcca = &(p_rsp->u.requestChannelCloseAck);
  p_rsp->choice = requestChannelCloseAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_rcca->forwardLogicalChannelNumber = wChannel;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_request_channel_close_rej ( PDU_T *pPdu,
				                            WORD                 wChannel,
				                            H245_ACC_REJ_T       acc_rej)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  RequestChannelCloseReject     *pPdu_rccr = &(p_rsp->u.rqstChnnlClsRjct);

  p_rsp->choice = rqstChnnlClsRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_rccr->forwardLogicalChannelNumber = wChannel;
  pPdu_rccr->cause.choice = (WORD)acc_rej;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_req_mstslv (        PDU_T *                 pPdu,
		                    BYTE                    byTerminalType,
		                    unsigned int            number)
{
  RequestMessage        *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  MasterSlaveDetermination      *pPdu_msd = &(p_req->u.masterSlaveDetermination);
  p_req->choice = masterSlaveDetermination_chosen;

  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_msd->terminalType = (WORD)byTerminalType;
  pPdu_msd->statusDeterminationNumber = number;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_mstslv_rej (PDU_T *pPdu)
{
  ResponseMessage                       *p_rsp = &pPdu->u.MSCMg_rspns;
  MasterSlaveDeterminationReject        *pPdu_msdr = &(p_rsp->u.mstrSlvDtrmntnRjct);

  p_rsp->choice = mstrSlvDtrmntnRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_msdr->cause.choice = identicalNumbers_chosen;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_mstslv_ack (    PDU_T *                 pPdu,
                        unsigned short          mst_slv)
{
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu->u.MSCMg_rspns.choice = mstrSlvDtrmntnAck_chosen;
  pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice = mst_slv;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_req_termcap_set (PDU_T *pPdu,
		               WORD                 wSequenceNumber)
{
  RequestMessage *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  TerminalCapabilitySet *pPdu_tcs = &(p_req->u.terminalCapabilitySet);
  p_req->choice = terminalCapabilitySet_chosen;
				       
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu_tcs->sequenceNumber = wSequenceNumber;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_termcap_set_ack(PDU_T *pPdu,
			                  WORD                 wSequenceNumber)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  TerminalCapabilitySetAck      *pPdu_tcsa = &(p_rsp->u.terminalCapabilitySetAck);

  p_rsp->choice = terminalCapabilitySetAck_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_tcsa->sequenceNumber = wSequenceNumber;
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_termcap_set_rej(PDU_T *pPdu,
			               WORD                 wSequenceNumber, 
			               H245_ACC_REJ_T       reason, 
			               WORD                 highest_processed)
{
  ResponseMessage               *p_rsp = &pPdu->u.MSCMg_rspns;
  TerminalCapabilitySetReject   *pPdu_tcsr = &(p_rsp->u.trmnlCpbltyStRjct);

  p_rsp->choice = trmnlCpbltyStRjct_chosen;
  pPdu->choice = MSCMg_rspns_chosen;
  pPdu_tcsr->sequenceNumber = wSequenceNumber;

  switch (reason)
    {
    case H245_REJ_UNDEF_TBL_ENTRY:
      pPdu_tcsr->cause.choice =  undefinedTableEntryUsed_chosen;
      break;
    case H245_REJ_DIS_CAP_EXCEED:
      pPdu_tcsr->cause.choice = dscrptrCpctyExcdd_chosen;
      break;
    case H245_REJ_TBLENTRY_CAP_EXCEED:
      pPdu_tcsr->cause.choice = tblEntryCpctyExcdd_chosen;

      if (!highest_processed)
	pPdu_tcsr->cause.u.tblEntryCpctyExcdd.choice = noneProcessed_chosen;
      else
	{
	  pPdu_tcsr->cause.u.tblEntryCpctyExcdd.choice = hghstEntryNmbrPrcssd_chosen;
	  pPdu_tcsr->cause.u.tblEntryCpctyExcdd.u.hghstEntryNmbrPrcssd = highest_processed;
	}
      break;
    case H245_REJ:
    default:
      pPdu_tcsr->cause.choice = TCSRt_cs_unspcfd_chosen;
      break;
    }
  return H245_ERROR_OK;
}



/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_ind_misc (PDU_T       *pPdu)
{
  IndicationMessage     *p_ind = &pPdu->u.indication;
  MiscellaneousIndication       *p_pdu_misc = &(p_ind->u.miscellaneousIndication);
  p_ind->choice = miscellaneousIndication_chosen;
  
  pPdu->choice = indication_chosen;
  /* (TBC) */
  return H245_ERROR_NOTIMP;
}




/*****************************************************************************
 *                                                                            
 * TYPE:        LOCAL
 *                                                                            
 * PROCEDURE:   build_mux_entry_element - recursivly build mux element list
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
build_mux_entry_element(struct InstanceStruct    *pInstance,
       			         H245_MUX_ENTRY_ELEMENT_T *p_mux_el,
			               MultiplexElement         *p_ASN_mux_el,
			               DWORD			              element_depth)
{
  HRESULT       lError;
  DWORD		max_element_depth = 0;
  DWORD		max_element_width = 0;

  /* check for h223 MAX depth of recursion */
  if (pInstance->Configuration == H245_CONF_H324)
    {
      /* if h223 in basic mode */
      if (pInstance->API.PDU_LocalTermCap.
	    u.MltmdSystmCntrlMssg_rqst.
	      u.terminalCapabilitySet.multiplexCapability.
	        u.h223Capability.
		  h223MultiplexTableCapability.choice == h223MltplxTblCpblty_bsc_chosen)
	{
	  max_element_depth = 1;
	  max_element_width = 2;
	}
      else 
      if (pInstance->API.PDU_LocalTermCap.
	    u.MltmdSystmCntrlMssg_rqst.
	      u.terminalCapabilitySet.multiplexCapability.
	        u.h223Capability.
		  h223MultiplexTableCapability.choice == h223MTCy_enhncd_chosen)
	{
	  max_element_depth = 
	    pInstance->API.PDU_LocalTermCap.
	      u.MltmdSystmCntrlMssg_rqst.
		u.terminalCapabilitySet.multiplexCapability.
		  u.h223Capability.
		    h223MultiplexTableCapability.u.h223MTCy_enhncd.maximumNestingDepth;
	  max_element_width = 
	    pInstance->API.PDU_LocalTermCap.
	      u.MltmdSystmCntrlMssg_rqst.
		u.terminalCapabilitySet.multiplexCapability.
		  u.h223Capability.
		    h223MultiplexTableCapability.u.h223MTCy_enhncd.maximumElementListSize;
	}
    }
  /* nested too deap */
  if (max_element_depth)
    if (element_depth > max_element_depth)
      {
	H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Maximum Depth %d",element_depth );
	return (H245_ERROR_MUXELEMENT_DEPTH);
      }

  H245ASSERT (p_mux_el);
  
  /* if logical channel number (termination of tree branch) */
  if (p_mux_el->Kind == H245_MUX_LOGICAL_CHANNEL)
    {
      p_ASN_mux_el->type.choice = typ_logicalChannelNumber_chosen;

      /* invalid channel number .. 0 is command channel */
      // 3/7/96 - cjutzi removed.. looks like they use it in the examples 
      //
      //if (p_mux_el->u.wChannel == 0)
      //	{
      //	  H245TRACE(Inst,1,"API:build_mux_entry_element: << ERROR >> Channel 0 not allowed if format");
      //	  return H245_ERROR_INVALID_DATA_FORMAT;
      //	}

      p_ASN_mux_el->type.u.typ_logicalChannelNumber = (WORD)p_mux_el->u.Channel;
    }
  /* else it is a sub element list again.. */
  else
    {
      MultiplexElementLink 	        p_ASN_mux_link;
      H245_MUX_ENTRY_ELEMENT_T 	       *p_mux_el_look;
      
      /* allocate a new sub element list structure */
      
      p_ASN_mux_link = (MultiplexElementLink)H245_malloc(sizeof(*p_ASN_mux_link));
      if (p_ASN_mux_link == NULL)
	{
	  return H245_ERROR_NOMEM;
	}

      /* zero out */
      memset (p_ASN_mux_link, 0, sizeof (*p_ASN_mux_link));

      /* for every entry  entry present.. */
      for (p_ASN_mux_link->count = 0, p_mux_el_look = p_mux_el->u.pMuxTblEntryElem;
	   p_mux_el_look;
	   p_mux_el_look = p_mux_el_look->pNext, p_ASN_mux_link->count++)
	{
	  /* check.. for api mistakes.. ie.. pointer is really a channel # */
	  
          if (PtrToUlong(p_mux_el_look) < (DWORD)128)
	    {
	      H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << WARNING >> Possible H245_MUX_LOGICAL_CHANNEL labeled as pointer.. <<CRASH>>");
	    }

	  if ((lError = build_mux_entry_element (pInstance, 
						p_mux_el_look,
						&(p_ASN_mux_link->value[p_ASN_mux_link->count]),
						element_depth+1)) != H245_ERROR_OK)
	    {
	      H245_free (p_ASN_mux_link);
	      return lError;
	    }

	} /* for */

      /* must have at least 2 subelements in the list.. if not */
      /* there is an error in the construct.. yousa yousa!!!   */
      if (p_ASN_mux_link->count < 2)
	{
	  H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Element List < 2");  
	  H245_free (p_ASN_mux_link);
	  return H245_ERROR_INVALID_DATA_FORMAT;
	}

      /* width too wide for MuxLayer*/
      if (max_element_width)
	if (p_ASN_mux_link->count > max_element_width)
	  {
	    H245TRACE(pInstance->dwInst,1,"API:build_mux_entry_element: << ERROR >> Maximum Width %d",(p_ASN_mux_link->count));  
	    H245_free (p_ASN_mux_link);
	    return H245_ERROR_MUXELEMENT_WIDTH;
	  }

      /* assign to the ASN1 struct for this element */
      p_ASN_mux_el->type.u.subElementList = p_ASN_mux_link;
      p_ASN_mux_el->type.choice = subElementList_chosen;
    }

  /* ok.. deal w/ ASN1 repeat count */
  if (!p_mux_el->RepeatCount)
    p_ASN_mux_el->repeatCount.choice = untilClosingFlag_chosen;
  else
    {
      p_ASN_mux_el->repeatCount.choice = repeatCount_finite_chosen;
      p_ASN_mux_el->repeatCount.u.repeatCount_finite = (WORD)p_mux_el->RepeatCount;
    }

  return H245_ERROR_OK;
}



/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_req_send_mux_table (  struct InstanceStruct * pInstance,
			  PDU_T                 * pPdu,
			  H245_MUX_TABLE_T      * p_mux_table,
			  WORD                    wSequenceNumber,
			  DWORD	                * p_mux_count)
{
  RequestMessage         	       *p_req = &pPdu->u.MltmdSystmCntrlMssg_rqst;
  MultiplexEntrySend     	       *pPdu_mes = &(p_req->u.multiplexEntrySend);
  MultiplexEntryDescriptorLink	        p_ASN_med_link = NULL;
  MultiplexEntryDescriptorLink	        p_ASN_med_link_lst = NULL;
  //H245_MUX_ENTRY_DESC_T		*p_mux_desc;

  /* setup pdu choices */
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  p_req->choice = multiplexEntrySend_chosen;

  pPdu_mes->sequenceNumber = wSequenceNumber;
  pPdu_mes->multiplexEntryDescriptors = NULL;

  /* must have mux table structure */
  if (!p_mux_table)
    return H245_ERROR_PARAM;
  
  /* for each descriptor in the table.. */
  /* make sure there are only max of 15 */
  /* and that the numbers range 1-15	*/

  for (*p_mux_count = 0;
       p_mux_table && (*p_mux_count < 16);
       p_mux_table = p_mux_table->pNext,*p_mux_count = (*p_mux_count)+1)
    {
      /* allocate a new multiplex Entry Descriptor */
      p_ASN_med_link = (MultiplexEntryDescriptorLink)H245_malloc(sizeof(*p_ASN_med_link));
      if (p_ASN_med_link == NULL)
	{
	  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
	  return H245_ERROR_NOMEM;
	}
      
      /* zero out the structure */
      memset (p_ASN_med_link, 0, sizeof(*p_ASN_med_link));

      /* first multiplex entry descriptor ie. time through */
      /* assign to "->multiplexEntryDescriptors" 	   */
      if (!pPdu_mes->multiplexEntryDescriptors)
	pPdu_mes->multiplexEntryDescriptors = p_ASN_med_link;

      /* every other time.. link it in.. */
      else
	{
	  H245ASSERT (p_ASN_med_link_lst);
	  p_ASN_med_link_lst->next = p_ASN_med_link;
	}
      /* setup for next time thorugh */
      p_ASN_med_link_lst = p_ASN_med_link;

      /* set the entry number */
      if ((p_mux_table->MuxEntryId > 15) ||
	  (p_mux_table->MuxEntryId < 1))
	{
	  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
	  /* H245_free (p_ASN_med_link); -- will be freed in call abouve since it is already linked in */
	  return H245_ERROR_PARAM;
	}
      p_ASN_med_link->value.multiplexTableEntryNumber = (WORD)p_mux_table->MuxEntryId;

      /* if entry is present */
      if (p_mux_table->pMuxTblEntryElem)
	{
	  H245_MUX_ENTRY_ELEMENT_T *p_mux_el;
	  DWORD			    error;

	  /* setup so ASN knows entry is present */
	  p_ASN_med_link->value.bit_mask = elementList_present;

	  /* for every entry  entry present.. */
	  for (p_ASN_med_link->value.elementList.count = 0, p_mux_el = p_mux_table->pMuxTblEntryElem;
	       p_mux_el;
	       p_mux_el = p_mux_el->pNext, p_ASN_med_link->value.elementList.count++)
	    {
	      if ((error = 
		   build_mux_entry_element (pInstance, p_mux_el,
		    &(p_ASN_med_link->value.elementList.value[p_ASN_med_link->value.elementList.count]),0)) != H245_ERROR_OK)
		{
		  free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
		  return error;
		}
	    } /* for */

	} /* if */
      /* else.. not present */
      else      
	p_ASN_med_link->value.bit_mask = 0;

    } /* for */
  
  /* you've got too many mux entries.. no more than 16 .. remember.. */
  if (*p_mux_count >= 16)
    {
      free_mux_desc_list(pPdu_mes->multiplexEntryDescriptors);
      return H245_ERROR_INVALID_MUXTBLENTRY;
    }
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   pdu_rsp_mux_table_ack - 
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 *		- Assume all mux id's are valid.
 *                                                                            
 * RETURN:                                                                    
 *		- H245_ERROR_OK if there are acks to send
 *		- H245_CANCELED if you shouldn't send the pdu.. (nothing to do)
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_mux_table_ack ( PDU_T *pPdu,
		                  WORD		            wSequenceNumber,
		                  H245_ACC_REJ_MUX_T   acc_rej_mux,
		                  DWORD		            count)
{
  DWORD			 ii;
  WORD	 num_ack = 0;
  ResponseMessage	*p_rsp 	  = &(pPdu->u.MSCMg_rspns);
  MultiplexEntrySendAck *p_mux_ack = &(p_rsp->u.multiplexEntrySendAck);

  pPdu->choice = MSCMg_rspns_chosen;
  p_rsp->choice = multiplexEntrySendAck_chosen;
  p_mux_ack->sequenceNumber = wSequenceNumber;
  
  for (ii = 0; ii < count; ii++)
    {
      if (acc_rej_mux[ii].AccRej == H245_ACC)
	{
	  p_mux_ack->multiplexTableEntryNumber.value[num_ack] = 
	     (WORD)acc_rej_mux[ii].MuxEntryId;
	  num_ack++;
	}
    }

  p_mux_ack->multiplexTableEntryNumber.count = num_ack;

  if (num_ack)
    return H245_ERROR_OK;
  else
    return H245_ERROR_CANCELED;
} 

/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   pdu_rsp_mux_table_rej - 
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 *		- Assume all mux id's are valid.
 *                                                                            
 * RETURN:                                                                    
 *		- H245_ERROR_OK if there are rej to send
 *		- H245_CANCELED if you shouldn't send the pdu.. (nothing to do)
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_rsp_mux_table_rej ( PDU_T *pPdu,
		                  WORD		            wSequenceNumber,
		                  H245_ACC_REJ_MUX_T   acc_rej_mux,
		                  DWORD		            count)
{
  DWORD			    ii;
  WORD	    num_rej = 0;
  ResponseMessage	   *p_rsp 	  = &(pPdu->u.MSCMg_rspns);
  MultiplexEntrySendReject *p_mux_rej = &(p_rsp->u.multiplexEntrySendReject);

  pPdu->choice = MSCMg_rspns_chosen;
  p_rsp->choice = multiplexEntrySendReject_chosen;

  p_mux_rej->sequenceNumber = wSequenceNumber;
  
  for (ii = 0; ii < count; ii++)
    {
      if (acc_rej_mux[ii].AccRej != H245_ACC)
	{
	  p_mux_rej->rejectionDescriptions.value[num_rej].multiplexTableEntryNumber = 
	    (WORD)acc_rej_mux[ii].MuxEntryId;

	  switch (acc_rej_mux[ii].AccRej)
	    {
	    case H245_REJ_MUX_COMPLICATED:
	      p_mux_rej->rejectionDescriptions.value[num_rej].cause.choice = 
		descriptorTooComplex_chosen;
	      break;

	    case H245_REJ:
	    default:
	      p_mux_rej->rejectionDescriptions.value[num_rej].cause.choice = 
		MERDs_cs_unspcfdCs_chosen;
	      break;
	    }
	      
	  num_rej++;
	}
    }

  p_mux_rej->rejectionDescriptions.count = num_rej;

  if (num_rej)
    return H245_ERROR_OK;
  else
    return H245_ERROR_CANCELED;
} 



/*****************************************************************************
 *                                                                            
 * TYPE:        
 *                                                                            
 * PROCEDURE:   pdu_cmd_end_session
 *
 * DESCRIPTION
 *
 * ASSUMES:
 *
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_cmd_end_session(PDU_T *         pPdu,
		                H245_ENDSESSION_T       		mode,
		                const H245_NONSTANDARD_PARAMETER_T *p_nonstd)
{
  CommandMessage     *p_cmd = &pPdu->u.MSCMg_cmmnd;
  EndSessionCommand  *p_pdu_endsess = &(p_cmd->u.endSessionCommand);
  p_cmd->choice = endSessionCommand_chosen;
  pPdu->choice = MSCMg_cmmnd_chosen;

  switch (mode)
    {
    case H245_ENDSESSION_DISCONNECT:
      p_pdu_endsess->choice = disconnect_chosen;
      break;
    case H245_ENDSESSION_NONSTD:
      p_pdu_endsess->choice = EndSssnCmmnd_nonStandard_chosen;
      H245ASSERT(p_nonstd);
      p_pdu_endsess->u.EndSssnCmmnd_nonStandard = *p_nonstd;
      break;
    case H245_ENDSESSION_TELEPHONY:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = telephonyMode_chosen;
      break;
    case H245_ENDSESSION_V8BIS:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v8bis_chosen;
      break;
    case H245_ENDSESSION_V34DSVD:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice =  v34DSVD_chosen;
      break;
    case H245_ENDSESSION_V34DUPFAX:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v34DuplexFAX_chosen;
      break;
    case H245_ENDSESSION_V34H324:
      p_pdu_endsess->choice = gstnOptions_chosen;
      p_pdu_endsess->u.gstnOptions.choice = v34H324_chosen;
      break;
    default:
      return H245_ERROR_NOSUP;
    }
  return H245_ERROR_OK;
}

/*****************************************************************************
 *                                                                            
 * TYPE:
 *                                                                            
 * PROCEDURE:   
 *
 * DESCRIPTION
 *                                                                            
 * RETURN:                                                                    
 *                                                                            
 *****************************************************************************/
HRESULT
pdu_ind_usrinpt ( PDU_T *pPdu,
                  const H245_NONSTANDARD_PARAMETER_T *pNonStd,
                  const char *string)
{
  IndicationMessage    *p_ind     = &pPdu->u.indication;
  UserInputIndication  *p_pdu_usr = &p_ind->u.userInput;
  pPdu->choice = indication_chosen;
  p_ind->choice = userInput_chosen;

  /* Must be either one or the other */
  if (pNonStd && string)
    return H245_ERROR_PARAM;

  if (pNonStd)
  {
    p_pdu_usr->choice = UsrInptIndctn_nnStndrd_chosen;
    p_pdu_usr->u.UsrInptIndctn_nnStndrd = *pNonStd;
  }
  else if (string)
  {
    p_pdu_usr->choice = alphanumeric_chosen;
    p_pdu_usr->u.alphanumeric = (char *)string;
  }
  else
    return H245_ERROR_PARAM;

  return H245_ERROR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\rmese.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rmese.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RMESE.C  $
 * $Revision:   1.3  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/RMESE.C_v  $
 * 
 *    Rev 1.3   09 Dec 1996 13:37:00   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.2   04 Jun 1996 13:57:38   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.1   30 May 1996 23:39:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:06:40   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   09 May 1996 19:48:50   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.0   15 Apr 1996 10:45:20   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rmese.h"



// Out-going/In-coming RMESE states
#define RMESE_IDLE                  0   // IDLE
#define RMESE_WAIT                  1   // AWAITING_RESPONSE



extern unsigned int uT107;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T107ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T107ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T107Expiry);
} // T107ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RMESE0_SEND_requestF - SEND.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE0_SEND_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == RMESE_OUT);
    H245ASSERT(pObject->State  == RMESE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RMESE0_SEND_request:%d", pObject->Key);

    // Save information for release
    pObject->u.rmese = pPdu->u.indication.u.rqstMltplxEntryRls;

    // Send RequestMultiplexEntry PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T107
    pObject->State = RMESE_WAIT;
    FsmStartTimer(pObject, T107ExpiryF, uT107);

    return lError;
} // RMESE0_SEND_request



/*
 *  NAME
 *      RMESE1_SEND_requestF - SEND.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_SEND_requestF            (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == RMESE_OUT);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_SEND_request:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Save information for release
    pObject->u.rmese = pPdu->u.indication.u.rqstMltplxEntryRls;

    // Send RequestMultiplexEntry PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T107
    FsmStartTimer(pObject, T107ExpiryF, uT107);

    return lError;
} // RMESE1_SEND_request



/*
 *  NAME
 *      RMESE1_RequestMuxEntryAckF - RequestMultiplexEntryAck in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryAckF      (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_OUT);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntryAck:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Send SEND.confirm to H.245 user
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(pPdu, H245_CONF_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryAck



/*
 *  NAME
 *      RMESE1_RequestMuxEntryRejF - RequestMultiplexEntryReject in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryRejF      (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_OUT);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE0_RequestMuxEntryRej:%d", pObject->Key);

    // Reset timer T107
    FsmStopTimer(pObject);

    // Send REJECT.indication to H.245 user
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(pPdu, H245_CONF_RMESE_REJECT, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryRej



/*
 *  NAME
 *      RMESE1_T107ExpiryF - timer T107 Expiry
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT RMESE1_T107ExpiryF              (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;
    PDU_t *             pOut;
    unsigned short      wNumber = (unsigned short) pObject->Key;

    H245ASSERT(pObject->Entity == RMESE_OUT);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "RMESE1_T107Expiry:%d", pObject->Key);

    // Send RequestMultiplexEntryRelease PDU to remote peer
    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RMESE1_T107ExpiryF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = rqstMltplxEntryRls_chosen;
    pOut->u.indication.u.rqstMltplxEntryRls = pObject->u.rmese;
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = RMESE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_RMESE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return lError;
} // RMESE1_T107Expiry

# pragma warning( default : 4100 )



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RMESE0_RequestMuxEntryF - RequestMultiplexEntry received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE0_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_IN);
    H245ASSERT(pObject->State  == RMESE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RMESE0_RequestMuxEntry:%d", pObject->Key);

    // Send SEND.indication to H.245 user
    pObject->State = RMESE_WAIT;
    H245FsmIndication(pPdu, H245_IND_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE0_RequestMuxEntry



/*
 *  NAME
 *      RMESE1_RequestMuxEntryF - RequestMultiplexEntry received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryF         (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_IN);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntry:%d", pObject->Key);

#if defined(SDL_COMPLIANT)
    // Send REJECT.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_RMESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);
#endif

    // Send SEND.indication to H.245 user
    H245FsmIndication(pPdu, H245_IND_RMESE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntry



/*
 *  NAME
 *      RMESE1_RequestMuxEntryReleaseF - RequestMultiplexEntryRelease received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_RequestMuxEntryReleaseF  (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_IN);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_RequestMuxEntryRelease:%d", pObject->Key);

    // Send REJECT.indication to H.245 user
    //   SOURCE := PROTOCOL
    pObject->State = RMESE_IDLE;
    H245FsmIndication(pPdu, H245_IND_RMESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RMESE1_RequestMuxEntryRelease



/*
 *  NAME
 *      RMESE1_SEND_responseF - SEND.response from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_SEND_responseF           (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_IN);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_SEND_response:%d", pObject->Key);

    // Send RequestMultiplexEntryAck PDU to remote peer
    pObject->State = RMESE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // RMESE1_SEND_response



/*
 *  NAME
 *      RMESE1_REJECT_requestF - REJECT.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RMESE1_REJECT_requestF          (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RMESE_IN);
    H245ASSERT(pObject->State  == RMESE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RMESE1_REJECT_request:%d", pObject->Key);

    // Send RequestMultiplexEntryReject PDU to remote
    pObject->State = RMESE_IDLE;
    return sendPDU(pObject->pInstance, pPdu);
} // RMESE1_REJECT_request
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\pduparse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: pduparse.c                                                *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   PDUPARSE.C  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/PDUPARSE.C_v  $
 * 
 *    Rev 1.6   09 Dec 1996 13:36:56   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.5   29 Jul 1996 16:58:08   EHOWARDX
 * 
 * Missed some Geneva update PDU types.
 * 
 *    Rev 1.4   05 Jun 1996 17:15:02   EHOWARDX
 * MaintenanceLoop fix.
 * 
 *    Rev 1.3   04 Jun 1996 13:58:06   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   29 May 1996 15:20:24   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:26   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:40   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.8.1.4   09 May 1996 19:48:40   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.8.1.3   25 Apr 1996 17:00:16   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.8.1.2   15 Apr 1996 10:48:00   EHOWARDX
 * Update.
 *
 *    Rev 1.8.1.1   10 Apr 1996 21:15:54   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.8.1.0   05 Apr 1996 20:53:06   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"

/*
 *  NAME
 *      PduParseIncoming - parse an inbound PDU and determine Entity, Event, etc.
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM Instance structure
 *      INPUT   pPdu        Pointer to an incoming PDU structure
 *      OUTPUT  pEntity     Pointer to variable to return PDU state entity in
 *      OUTPUT  pEvent      Pointer to variable to return PDU event in
 *      OUTPUT  pKey        Pointer to variable to return lookup key in
 *      OUTPUT  pbCreate    Pointer to variable to return create flag in
 *
 *  RETURN VALUE
 *      SUCCESS or FAIL
 */


HRESULT
PduParseIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu,
                 Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate)
{
    H245ASSERT(pInstance != NULL);
    H245ASSERT(pPdu      != NULL);
    H245ASSERT(pEntity   != NULL);
    H245ASSERT(pEvent    != NULL);
    H245ASSERT(pKey      != NULL);
    H245ASSERT(pbCreate  != NULL);

    // Set default value for key
    *pKey = 0;

    switch (pPdu->choice)
    {

    ////////////////////////////////////////////////////////////////////
    //
    // REQUEST
    //
    ////////////////////////////////////////////////////////////////////
    case MltmdSystmCntrlMssg_rqst_chosen:
        *pbCreate = TRUE;
        switch (pPdu->u.MltmdSystmCntrlMssg_rqst.choice)
        {
        case RqstMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardRequestPDU;
            break;

        case masterSlaveDetermination_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetPDU;
            break;

        case terminalCapabilitySet_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = TermCapSetPDU;
            break;

        case openLogicalChannel_chosen:
            if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = OpenBChPDU;
            }
            else
            {
                *pEntity    = LCSE_IN;
                *pEvent     = OpenUChPDU;
            }
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;
            break;

        case closeLogicalChannel_chosen:
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = CloseBChPDU;
            }
            else
            {
               *pEntity     = LCSE_IN;
               *pEvent      = CloseUChPDU;
            }
            break;

        case requestChannelClose_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = ReqChClosePDU;
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySend_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MultiplexEntrySendPDU;
            break;

        case requestMultiplexEntry_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RequestMultiplexEntryPDU;
            break;

        case requestMode_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = RequestModePDU;
            break;

        case roundTripDelayRequest_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayRequestPDU;
            break;

        case maintenanceLoopRequest_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MaintenanceLoopRequestPDU;
            switch (pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case communicationModeRequest_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeRequestPDU;
            break;

        case conferenceRequest_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceRequestPDU;
            break;

        case h223AnnxARcnfgrtn_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Request %d",
                      pPdu->u.MltmdSystmCntrlMssg_rqst.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // RESPONSE
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_rspns_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_rspns.choice)
        {
        case RspnsMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardResponsePDU;
            break;

        case mstrSlvDtrmntnAck_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetAckPDU;
            break;

        case mstrSlvDtrmntnRjct_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetRejectPDU;
            break;

        case terminalCapabilitySetAck_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TermCapSetAckPDU;
            break;

        case trmnlCpbltyStRjct_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TermCapSetRejectPDU;
            break;

        case openLogicalChannelAck_chosen:
            if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = OpenBChAckPDU;
            }
            else
            {
                *pEntity    = LCSE_OUT;
                *pEvent     = OpenUChAckPDU;
            }
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.forwardLogicalChannelNumber;
            break;

        case openLogicalChannelReject_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = OpenBChRejectPDU;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = OpenUChRejectPDU;
            }
            break;

        case closeLogicalChannelAck_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.closeLogicalChannelAck.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = CloseBChAckPDU;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = CloseUChAckPDU;
            }
            break;

        case requestChannelCloseAck_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqChCloseAckPDU;
            *pKey = pPdu->u.MSCMg_rspns.u.requestChannelCloseAck.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRjct_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqChCloseRejectPDU;
            *pKey = pPdu->u.MSCMg_rspns.u.rqstChnnlClsRjct.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySendAck_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MultiplexEntrySendAckPDU;
            break;

        case multiplexEntrySendReject_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MultiplexEntrySendRejectPDU;
            break;

        case requestMultiplexEntryAck_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RequestMultiplexEntryAckPDU;
            break;

        case rqstMltplxEntryRjct_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RequestMultiplexEntryRejectPDU;
            break;

        case requestModeAck_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = RequestModeAckPDU;
            break;

        case requestModeReject_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = RequestModeRejectPDU;
            break;

        case roundTripDelayResponse_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayResponsePDU;
            break;

        case maintenanceLoopAck_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MaintenanceLoopAckPDU;
            switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case maintenanceLoopReject_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MaintenanceLoopRejectPDU;
            switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case cmmnctnMdRspns_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeResponsePDU;
            break;

        case conferenceResponse_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceResponsePDU;
            break;

        case h223AnnxARcnfgrtnAck_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigAckPDU;
            break;

        case h223AnnxARcnfgrtnRjct_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223ReconfigRejectPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Response %d",
                      pPdu->u.MSCMg_rspns.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // COMMAND
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_cmmnd_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_cmmnd.choice)
        {
        case CmmndMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardCommandPDU;
            break;

        case mntnncLpOffCmmnd_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MaintenanceLoopOffCommandPDU;
            break;

        case sndTrmnlCpbltySt_chosen:
            *pEntity    = STATELESS;
            *pEvent     = SendTerminalCapabilitySetPDU;
            *pbCreate   = TRUE;
            break;

        case encryptionCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = EncryptionCommandPDU;
            break;

        case flowControlCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FlowControlCommandPDU;
            break;

        case endSessionCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = EndSessionCommandPDU;
            break;

        case miscellaneousCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MiscellaneousCommandPDU;
            break;

        case communicationModeCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = CommunicationModeCommandPDU;
            break;

        case conferenceCommand_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceCommandPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Command %d",
                      pPdu->u.MSCMg_cmmnd.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // INDICATION
    //
    ////////////////////////////////////////////////////////////////////
    case indication_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.indication.choice)
        {
        case IndctnMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NonStandardIndicationPDU;
            break;

        case functionNotUnderstood_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FunctionNotUnderstoodPDU;
            break;

        case mstrSlvDtrmntnRls_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetReleasePDU;
            break;

        case trmnlCpbltyStRls_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = TermCapSetReleasePDU;
            break;

        case opnLgclChnnlCnfrm_chosen:
            *pEntity    = BLCSE_IN;
            *pEvent     = OpenBChConfirmPDU;
            *pKey = pPdu->u.indication.u.opnLgclChnnlCnfrm.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRls_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = ReqChCloseReleasePDU;
            *pKey = pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber;
            break;

        case mltplxEntrySndRls_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MultiplexEntrySendReleasePDU;
            break;

        case rqstMltplxEntryRls_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RequestMultiplexEntryReleasePDU;
            break;

        case requestModeRelease_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = RequestModeReleasePDU;
            break;

        case miscellaneousIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MiscellaneousIndicationPDU;
            break;

        case jitterIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = JitterIndicationPDU;
            break;

        case h223SkewIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H223SkewIndicationPDU;
            break;

        case newATMVCIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = NewATMVCIndicationPDU;
            break;

        case userInput_chosen:
            *pEntity    = STATELESS;
            *pEvent     = UserInputIndicationPDU;
            break;

        case h2250MxmmSkwIndctn_chosen:
            *pEntity    = STATELESS;
            *pEvent     = H2250MaximumSkewIndicationPDU;
            break;

        case mcLocationIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = MCLocationIndicationPDU;
            break;

        case conferenceIndication_chosen:
            *pEntity    = STATELESS;
            *pEvent     = ConferenceIndicationPDU;
            break;

        case vendorIdentification_chosen:
            *pEntity    = STATELESS;
            *pEvent     = VendorIdentificationPDU;
            break;

        case functionNotSupported_chosen:
            *pEntity    = STATELESS;
            *pEvent     = FunctionNotSupportedPDU;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Indication %d",
                      pPdu->u.indication.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    default:
        H245TRACE(pInstance->dwInst, 1, "PduParseIncoming: Invalid Message Type %d",
                  pPdu->choice);
        return H245_ERROR_PARAM;
    } // switch

    return H245_ERROR_OK;
} // PduParseIncoming()



/*
 *  NAME
 *      PduParseOutgoing - parse an outbound PDU and determine Entity, Event, etc.
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM Instance structure
 *      INPUT   pPdu        Pointer to an incoming PDU structure
 *      OUTPUT  pEntity     Pointer to variable to return PDU state entity in
 *      OUTPUT  pEvent      Pointer to variable to return PDU event in
 *      OUTPUT  pKey        Pointer to variable to return lookup key in
 *      OUTPUT  pbCreate    Pointer to variable to return create flag in
 *
 *  RETURN VALUE
 *      SUCCESS or FAIL
 */

HRESULT
PduParseOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu,
                 Entity_t *pEntity, Event_t *pEvent, Key_t *pKey, int *pbCreate)
{
    H245ASSERT(pInstance != NULL);
    H245ASSERT(pPdu      != NULL);
    H245ASSERT(pEntity   != NULL);
    H245ASSERT(pEvent    != NULL);
    H245ASSERT(pKey      != NULL);
    H245ASSERT(pbCreate  != NULL);

    // Set default value for key
    *pKey = 0;

    switch (pPdu->choice)
    {

    ////////////////////////////////////////////////////////////////////
    //
    // REQUEST
    //
    ////////////////////////////////////////////////////////////////////
    case MltmdSystmCntrlMssg_rqst_chosen:
        *pbCreate = TRUE;
        switch (pPdu->u.MltmdSystmCntrlMssg_rqst.choice)
        {
        case RqstMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case masterSlaveDetermination_chosen:
            *pEntity    = MSDSE;
            *pEvent     = MSDetReq;
            break;

        case terminalCapabilitySet_chosen:
            *pEntity    = CESE_OUT;
            *pEvent     = TransferCapRequest;
            break;

        case openLogicalChannel_chosen:
            if (pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = ReqBEstablish;
            }
            else
            {
                *pEntity    = LCSE_OUT;
                *pEvent     = ReqUEstablish;
            }
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;
            break;

        case closeLogicalChannel_chosen:
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_OUT, *pKey) != NULL)
            {
                *pEntity    = BLCSE_OUT;
                *pEvent     = ReqClsBLCSE;
            }
            else
            {
               *pEntity     = LCSE_OUT;
               *pEvent      = ReqURelease;
            }
            break;

        case requestChannelClose_chosen:
            *pEntity    = CLCSE_OUT;
            *pEvent     = ReqClose;
            *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySend_chosen:
            *pEntity    = MTSE_OUT;
            *pEvent     = MTSE_TRANSFER_request;
            break;

        case requestMultiplexEntry_chosen:
            *pEntity    = RMESE_OUT;
            *pEvent     = RMESE_SEND_request;
            break;

        case requestMode_chosen:
            *pEntity    = MRSE_OUT;
            *pEvent     = MRSE_TRANSFER_request;
            break;

        case roundTripDelayRequest_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RTDSE_TRANSFER_request;
            break;

        case maintenanceLoopRequest_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MLSE_LOOP_request;
            switch (pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice)
            {
            case systemLoop_chosen:
                break;
            case mediaLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
                break;
            case logicalChannelLoop_chosen:
                *pKey = pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.logicalChannelLoop;
                break;
            default:
                return H245_ERROR_PARAM;
            } // switch
            break;

        case communicationModeRequest_chosen:
        case conferenceRequest_chosen:
        case h223AnnxARcnfgrtn_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Request %d",
                      pPdu->u.MltmdSystmCntrlMssg_rqst.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // RESPONSE
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_rspns_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_rspns.choice)
        {
        case RspnsMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

#if 0
        // Master Slave Determination Ack is generated by State Machine only
        case mstrSlvDtrmntnAck_chosen:
            *pEntity    = MSDSE;
            break;

        // Master Slave Determination Reject is generated by State Machine only
        case mstrSlvDtrmntnRjct_chosen:
            *pEntity    = MSDSE;
            break;
#endif

        case terminalCapabilitySetAck_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = CESE_TRANSFER_response;
            break;

        case trmnlCpbltyStRjct_chosen:
            *pEntity    = CESE_IN;
            *pEvent     = CESE_REJECT_request;
            break;

        case openLogicalChannelAck_chosen:
            if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = ResponseBEstablish;
            }
            else
            {
                *pEntity    = LCSE_IN;
                *pEvent     = ResponseUEstablish;
            }
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.forwardLogicalChannelNumber;
            break;

        case openLogicalChannelReject_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
                *pEvent     = OpenRejectBLCSE;
            }
            else
            {
               *pEntity     = LCSE_IN;
               *pEvent      = EstablishUReject;
            }
            break;

#if 0
        // Close Logical Channel Ack is generated by State Machine only
        case closeLogicalChannelAck_chosen:
            *pKey = pPdu->u.MSCMg_rspns.u.closeLogicalChannelAck.forwardLogicalChannelNumber;
            if (ObjectFind(pInstance, BLCSE_IN, *pKey) != NULL)
            {
                *pEntity    = BLCSE_IN;
            }
            else
            {
               *pEntity     = LCSE_IN;
            }
            break;
#endif

        case requestChannelCloseAck_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = CLCSE_CLOSE_response;
            *pKey = pPdu->u.MSCMg_rspns.u.requestChannelCloseAck.forwardLogicalChannelNumber;
            break;

        case rqstChnnlClsRjct_chosen:
            *pEntity    = CLCSE_IN;
            *pEvent     = CLCSE_REJECT_request;
            *pKey = pPdu->u.MSCMg_rspns.u.rqstChnnlClsRjct.forwardLogicalChannelNumber;
            break;

        case multiplexEntrySendAck_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MTSE_TRANSFER_response;
            break;

        case multiplexEntrySendReject_chosen:
            *pEntity    = MTSE_IN;
            *pEvent     = MTSE_REJECT_request;
            break;

        case requestMultiplexEntryAck_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RMESE_SEND_response;
            break;

        case rqstMltplxEntryRjct_chosen:
            *pEntity    = RMESE_IN;
            *pEvent     = RMESE_REJECT_request;
            break;

        case requestModeAck_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = MRSE_TRANSFER_response;
            break;

        case requestModeReject_chosen:
            *pEntity    = MRSE_IN;
            *pEvent     = MRSE_REJECT_request;
            break;

#if 0
        // Round Trip Delay Response sent by State Machine only
        case roundTripDelayResponse_chosen:
            *pEntity    = RTDSE;
            *pEvent     = RoundTripDelayResponse;
            break;
#endif

        case maintenanceLoopAck_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MLSE_LOOP_response;
            // Caveat: Channel number must be zero if system loop!
            *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
            break;

        case maintenanceLoopReject_chosen:
            *pEntity    = MLSE_IN;
            *pEvent     = MLSE_IN_RELEASE_request;
            // Caveat: Channel number must be zero if system loop!
            *pKey = pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
            break;

        case cmmnctnMdRspns_chosen:
        case conferenceResponse_chosen:
        case h223AnnxARcnfgrtnAck_chosen:
        case h223AnnxARcnfgrtnRjct_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Response %d",
                      pPdu->u.MSCMg_rspns.choice);
            return H245_ERROR_PARAM;
        }
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // COMMAND
    //
    ////////////////////////////////////////////////////////////////////
    case MSCMg_cmmnd_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.MSCMg_cmmnd.choice)
        {
        case CmmndMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case mntnncLpOffCmmnd_chosen:
            *pEntity    = MLSE_OUT;
            *pEvent     = MLSE_OUT_RELEASE_request;
            break;

        case sndTrmnlCpbltySt_chosen:
        case encryptionCommand_chosen:
        case flowControlCommand_chosen:
        case endSessionCommand_chosen:
        case miscellaneousCommand_chosen:
        case communicationModeCommand_chosen:
        case conferenceCommand_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Command %d",
                      pPdu->u.MSCMg_cmmnd.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    ////////////////////////////////////////////////////////////////////
    //
    // INDICATION
    //
    ////////////////////////////////////////////////////////////////////
    case indication_chosen:
        *pbCreate = FALSE;
        switch (pPdu->u.indication.choice)
        {
        case IndctnMssg_nonStandard_chosen:
            *pEntity    = STATELESS;
            break;

        case functionNotUnderstood_chosen:
            *pEntity    = STATELESS;
            break;

#if 0
        // Master Slave Determination Release is sent by State Machine Only
        case mstrSlvDtrmntnRls_chosen:
            *pEntity    = MSDSE;
            break;

       // Terminal Capability Set Release is sent by State Machine Only
        case trmnlCpbltyStRls_chosen:
            *pEntity    = CESE_OUT
            break;
#endif

        case opnLgclChnnlCnfrm_chosen:
            *pEntity    = BLCSE_OUT;
            *pEvent     = RspConfirmBLCSE;
            *pKey = pPdu->u.indication.u.opnLgclChnnlCnfrm.forwardLogicalChannelNumber;
            break;

#if 0
        // Request Channel Close Release is sent by State Machine Only
        case rqstChnnlClsRls_chosen:
            *pEntity    = CLCSE_OUT;
            *pKey = pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber;
            break;

        // Multiplex Entry Send Release is sent by State Machine Only
        case mltplxEntrySndRls_chosen:
            *pEntity    = MTSE_OUT;
            break;

        // Request Multiplex Entry Release is sent by State Machine Only
        case rqstMltplxEntryRls_chosen:
            *pEntity    = RMESE_OUT;
            break;

        // Request Mode Release is sent by State Machine Only
        case requestModeRelease_chosen:
            *pEntity    = MRSE_OUT;
            break;
#endif

        case miscellaneousIndication_chosen:
        case jitterIndication_chosen:
        case h223SkewIndication_chosen:
        case newATMVCIndication_chosen:
        case userInput_chosen:
        case h2250MxmmSkwIndctn_chosen:
        case mcLocationIndication_chosen:
        case conferenceIndication_chosen:
        case vendorIdentification_chosen:
        case functionNotSupported_chosen:
            *pEntity    = STATELESS;
            break;

        default:
            H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Indication %d",
                      pPdu->u.indication.choice);
            return H245_ERROR_PARAM;
        } // switch
        break;

    default:
        H245TRACE(pInstance->dwInst, 1, "PduParseOutgoing: Invalid Message Type %d",
                  pPdu->choice);
        return H245_ERROR_PARAM;
    } // switch

    return H245_ERROR_OK;
} // PduParseOutgoing()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\rqstcls.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rqstcls.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   RQSTCLS.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/RQSTCLS.C_v  $
 * 
 *    Rev 1.5   09 Dec 1996 13:37:02   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.4   19 Jul 1996 12:15:40   EHOWARDX
 * 
 * Changed to use event definitions from H245API.H.
 * 
 *    Rev 1.3   04 Jun 1996 13:57:30   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.2   30 May 1996 23:39:26   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.1   29 May 1996 15:20:26   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.0   09 May 1996 21:06:42   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.6.1.2   09 May 1996 19:48:46   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.6.1.1   15 Apr 1996 10:46:22   EHOWARDX
 * Update.
 *
 *    Rev 1.6.1.0   10 Apr 1996 21:12:42   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rqstcls.h"



// request close channels from receive side outgoing states
#define ReqCloseOutIDLE             0
#define ReqCloseOutAwaitingResponse 1

// request close channels on open side incoming states
#define ReqCloseInIDLE              0
#define ReqCloseInAwaitingResponse  1



extern unsigned int uT108;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T108ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T108ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T108Expiry);
} // T108ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      closeRequestIdle - request to close a remote channel by API in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeRequestIdle (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == CLCSE_OUT);
    H245ASSERT(pObject->State == ReqCloseOutIDLE);
    H245TRACE(pObject->dwInst, 2,
              "Send RequestChannelClose to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close to remote peer */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T108 */
    pObject->State = ReqCloseOutAwaitingResponse;
    FsmStartTimer(pObject, T108ExpiryF, uT108);

    return lError;
}



/*
 *  NAME
 *      requestCloseAckAwaitingR - received request close Ack in awaiting release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseAckAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_OUT);
    H245ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE to API; Channel=%d",
              pObject->Key);

    /* reset timer T108 */
    FsmStopTimer(pObject);

    /* Send CLOSE.confirm to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(pPdu, H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      requestCloseRejAwaitingR - received request close reject in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseRejAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_OUT);
    H245ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE to API with REJECT; Channel=%d",
              pObject->Key);

    /* reset timer T108 */
    FsmStopTimer(pObject);

    /* Send REJECT.indication to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(pPdu,H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId,REJECT);

    return 0;
}



/*
 *  NAME
 *      t108ExpiryAwaitingR - handle timer expiry of an outstanding request close
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t108ExpiryAwaitingR (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == CLCSE_OUT);
    H245ASSERT(pObject->State == ReqCloseOutAwaitingResponse);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2,
              "H245_CONF_REQ_CLOSE with Timer T108 Expiry to API; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Release to remote peer */
    pOut = (PDU_t *) H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "t108ExpiryAwaitingR: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = rqstChnnlClsRls_chosen;
    pOut->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber = (WORD)pObject->Key;
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send REJECT.indication (SOURCE:=PROTOCOL to client */
    pObject->State = ReqCloseOutIDLE;
    H245FsmConfirm(NULL, H245_CONF_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
}

# pragma warning( default : 4100 )



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      requestCloseIdle - received requestClose in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseIdle (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_IN);
    H245ASSERT(pObject->State == ReqCloseInIDLE);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_REQ_CLOSE with no error to API; Channel=%d",
              pObject->Key);

    /* Send CLOSE.indication to client */
    pObject->State = ReqCloseInAwaitingResponse;
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      closeResponseAwaitingR - respond to a requestclose with an Ack (or Reject)
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT closeResponseAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_IN);
    H245ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "Request Close Response Ack to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Ack to remote peer */
    pObject->State = ReqCloseInIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



HRESULT rejectRequestAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_IN);
    H245ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Request Close Response Reject to ASN; Channel=%d",
              pObject->Key);

    /* Send Request Channel Close Reject to remote peer */
    pObject->State = ReqCloseInIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      requestCloseReleaseAwaitingR - received a release while awaiting the api to respond
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseReleaseAwaitingR(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_IN);
    H245ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "H245_IND_REQ_CLOSE with Reject to API; Channel=%d",
              pObject->Key);

    /* Send REJECT.indication to client */
    pObject->State = ReqCloseInIDLE;
    H245FsmIndication(pPdu, H245_IND_CLCSE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      requestCloseAwaitingR - overriding requestClose pdu in Awaiting Release state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject    pointer to a State Entity
 *
 *  RETURN VALUE
 *      error return codes defined in h245com.h
 */

HRESULT requestCloseAwaitingR (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CLCSE_IN);
    H245ASSERT(pObject->State == ReqCloseInAwaitingResponse);
    H245TRACE(pObject->dwInst, 2,
              "Overriding H245_IND_REQ_CLOSE with OK to API; Channel=%d",
              pObject->Key);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    /* Send CLOSE.indication to client */
    H245FsmIndication(pPdu, H245_IND_REQ_CLOSE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\termcap.c ===
/***********************************************************************
 *                                                                     *
 * Filename: termcap.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   TERMCAP.C  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:36:34  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\termcap.c_v $
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "termcap.h"
#include "pdu.x"



// Terminal Capability Exchange Out-going/In-coming states
#define CapIDLE                         0
#define CapAwaitingResponse             1



extern unsigned int uT101;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T101ExpiryF - Callback function called by the timer.
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T101ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T101Expiry);
} // T101ExpiryF()



/***********************************************************************
 *
 * OUT-GOING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      requestCapIdle - received TRANSFER.request in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT requestCapIdle(Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == CESE_OUT);
    H245ASSERT(pObject->State == CapIDLE);

    /* Increment sequence number */
    pObject->pInstance->StateMachine.byCeseOutSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber =
        pObject->pInstance->StateMachine.byCeseOutSequence;
    H245TRACE(  pObject->dwInst, 2, "TerminalCapabilitySet to ASN; Sequence=%d",
                pObject->pInstance->StateMachine.byCeseOutSequence);

    /* Send Terminal Capability Set to remote */
    lError = sendPDU(pObject->pInstance, pPdu);

    /* set timer T101 */
    pObject->State = CapAwaitingResponse;
    FsmStartTimer(pObject, T101ExpiryF, uT101);

    return lError;
}



/*
 *  NAME
 *      termCapAckAwaiting - received termCap Ack in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapAckAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_OUT);
    H245ASSERT(pObject->State == CapAwaitingResponse);

    /* reset timer T101 */
    FsmStopTimer(pObject);

    if (pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber ==
        pObject->pInstance->StateMachine.byCeseOutSequence)
    {
        H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with no error to API; Sequence=%d",
                  pObject->pInstance->StateMachine.byCeseOutSequence);
        pObject->State = CapIDLE;
        H245FsmConfirm(pPdu, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "termCapAckAwaiting: Sequence %d != %d",
                  pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber,
                  pObject->pInstance->StateMachine.byCeseOutSequence);
    }

    return 0;
}



/*
 *  NAME
 *      termCapRejAwaiting - received termCap Ack  in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapRejAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_OUT);
    H245ASSERT(pObject->State == CapAwaitingResponse);

    /* reset timer T101 */
    FsmStopTimer(pObject);

    if (pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber ==
        pObject->pInstance->StateMachine.byCeseOutSequence)
    {
        H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with Reject to API; Sequence=%d",
                  pObject->pInstance->StateMachine.byCeseOutSequence);
        pObject->State = CapIDLE;
        H245FsmConfirm(pPdu, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, REJECT);
    }
    else
    {
        H245TRACE(pObject->dwInst, 2, "termCapRejAwaiting: Sequence %d != %d",
                  pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber,
                  pObject->pInstance->StateMachine.byCeseOutSequence);
    }

    return 0;
}



/*
 *  NAME
 *      t101ExpiryAwaiting - handle timer expiry for an outstanding termcap
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT t101ExpiryAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == CESE_OUT);
    H245ASSERT(pObject->State == CapAwaitingResponse);
    H245ASSERT(pPdu           == NULL);

    pOut = (PDU_t *) H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    /* Send Terminal Capability Set Release to remote */
    pOut->choice = indication_chosen;
    pOut->u.indication.choice = trmnlCpbltyStRls_chosen;
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    /* Send REJECT.indication (SOURCE=PROTOCOL) to client */
    H245TRACE(pObject->dwInst, 2, "H245_CONF_SEND_TERMCAP with Timer Expiry to API; Sequence=%d",
              pObject->pInstance->StateMachine.byCeseOutSequence);
    pObject->State = CapIDLE;
    H245FsmConfirm(NULL, H245_CONF_SEND_TERMCAP, pObject->pInstance, pObject->dwTransId, TIMER_EXPIRY);

    return lError;
}

# pragma warning( default : 4100 )



/***********************************************************************
 *
 * IN-COMING FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      termCapSetIdle - received termcap set in idle state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapSetIdle(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_IN);
    H245ASSERT(pObject->State == CapIDLE);

    /* Save sequence number from PDU */
    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;
    H245TRACE(pObject->dwInst, 2, "H245_IND_CAP with no error to API; Sequence=%d",
              pObject->byInSequence);

    /* Send TRANSFER.indication to client */
    pObject->State = CapAwaitingResponse;
    H245FsmIndication(pPdu, H245_IND_CAP, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      responseCapAwaiting - respond to a termcap with ack
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT responseCapAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_IN);
    H245ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Send Term Cap Ack to ASN; Sequence=%d",
              pObject->byInSequence);

    pPdu->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber =
        pObject->byInSequence;

    /* Send Terminal Capability Set Ack to remote */
    pObject->State = CapIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      rejectCapAwaiting - respond to a termcap with reject
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT rejectCapAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_IN);
    H245ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "Send Term Cap Reject to ASN; Sequence=%d",
              pObject->byInSequence);

    pPdu->u.MSCMg_rspns.u.trmnlCpbltyStRjct.sequenceNumber =
        pObject->byInSequence;

    /* Send Terminal Capability Set Reject to remote */
    pObject->State = CapIDLE;
    return sendPDU(pObject->pInstance, pPdu);
}



/*
 *  NAME
 *      termCapReleaseAwaiting - received termcap release in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapReleaseAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_IN);
    H245ASSERT(pObject->State == CapAwaitingResponse);
    H245TRACE(pObject->dwInst, 2, "H245_IND_CAP with Reject to API; Sequence=%d",
              pObject->byInSequence);

    /* Send REJECT.indication (SOURCE = PROTOCOL) to client */
    pObject->State = CapIDLE;
    H245FsmIndication(pPdu, H245_IND_CESE_RELEASE, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
}



/*
 *  NAME
 *      termCapSetAwaiting - received overriding termcap set in Awaiting state
 *
 *
 *  PARAMETERS
 *   INPUT   pObject        pointer to a FSM object
 *
 *  RETURN VALUE
 *       error return codes defined in h245com.h
 */

HRESULT termCapSetAwaiting(Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == CESE_IN);
    H245ASSERT(pObject->State == CapAwaitingResponse);

    /* Save sequence number from PDU */
    pObject->byInSequence = (unsigned char)
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;
    H245TRACE(  pObject->dwInst, 2, "termCapSetAwaiting: Sequence=%d",
                pObject->byInSequence);

#if defined(SDL_COMPLIANT)
    /* Send REJECT.indication to client - not necessary */
    H245FsmIndication(NULL, H245_IND_CAP, pObject->pInstance, pObject->dwTransId, REJECT);
#endif

    /* Send TRANSFER.indication to client */
    H245FsmIndication(pPdu, H245_IND_CAP, pObject->pInstance, 0, FSM_OK);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\h245ws.cpp ===
/***************************************************************************
 *
 * File: h245ws.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 *
 * $Workfile:   h245ws.cpp  $
 * $Revision:   2.11  $
 * $Modtime:   31 Jan 1997 19:22:28  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\h245ws.cpv  $
 * 
 *    Rev 2.11   31 Jan 1997 20:24:34   SBELL1
 * Relinquished CallControl Stack lock before DefWindowProc
 * 
 *    Rev 2.10   31 Jan 1997 14:54:12   EHOWARDX
 * Added CCLOCK support.
 *
 *    Rev 2.9   20 Jan 1997 20:42:34   SBELL1
 * Fixed GPF when shutting down.
 * 
 *    Rev 2.8   07 Jan 1997 11:51:48   EHOWARDX
 * 
 * Fixed "assignment within conditional expression" warning
 * in GetLinkLayerInstance().
 * 
 *    Rev 2.7   03 Jan 1997 13:15:18   EHOWARDX
 * Attempt at workaround for #1718 linkLayerListen() returns WSAENOBUFS.
 * 
 *    Rev 2.6   23 Dec 1996 15:30:16   EHOWARDX
 * 
 * Set window to zero after call to destroy window -- Uninitialize seems
 * to be called more than once.
 * 
 *    Rev 2.5   20 Dec 1996 17:49:10   SBELL1
 * changed to blocking mode before closesocket in SocketClose. 
 * This makes the linger work.
 * 
 *    Rev 2.4   19 Dec 1996 19:03:18   SBELL1
 * Moved Initialize to linkLayerInit
 * Set linger option on accept socket
 * reversed "new" change 
 * 
 *    Rev 2.3   Dec 13 1996 17:12:36   plantz
 * fixed string for UNICODE.
// 
//    Rev 1.3   13 Dec 1996 14:32:10   SBELL1
// fixed string for UNICODE.
// 
//    Rev 1.1   12 Dec 1996 17:59:02   SBELL1
// Fixed bug in lingering on Q.931 Listen socket.
// 
//    Rev 1.0   11 Dec 1996 13:41:14   SBELL1
// Initial revision.
 * 
 *    Rev 1.46   18 Oct 1996 16:46:12   EHOWARDX
 * 
 * Changed GetIpAddress to take wide char cAddr field.
 * 
 *    Rev 1.45   Oct 01 1996 14:29:56   EHOWARDX
 * Moved Initialize() and Unitialize() calls to DllMain().
 * 
 *    Rev 1.44   26 Sep 1996 18:52:10   EHOWARDX
 * 
 * Moved some initialization around to prevent possible assertion failure
 * in SocketClose().
 * 
 *    Rev 1.43   15 Aug 1996 13:59:00   rodellx
 * 
 * Added additional address validation for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 * 
 *    Rev 1.42   Aug 07 1996 14:38:00   mandrews
 * Set bMulticast field of CC_ADDR structures correctly.
 * 
 *    Rev 1.41   24 Jul 1996 11:53:02   EHOWARDX
 * Changed ADDR to CC_ADDR, IP_XXX to CC_IP_XXX.
 * Fixed bug in SocketCloseEvent - needed to revalidate pHws after callback.
 * 
 *    Rev 1.40   08 Jul 1996 19:27:18   unknown
 * Second experiment to try to fix Q.931 shutdown problem.
 * 
 *    Rev 1.39   02 Jul 1996 16:23:02   EHOWARDX
 * Backed out experimental change.
 * 
 *    Rev 1.37   28 Jun 1996 18:06:50   unknown
 * Added breaks to GetPort.
 * 
 *    Rev 1.36   27 Jun 1996 14:06:06   EHOWARDX
 * Byte-swapped port number for debug trace in linkLayerListen & linkLayerConn
 * 
 *    Rev 1.35   21 Jun 1996 18:52:14   unknown
 * Fixed yet another shutdown bug - linkLayerShutdown re-entrancy check.
 * 
 *    Rev 1.34   18 Jun 1996 16:56:20   EHOWARDX
 * Added check to see if callback deallocated our instance to SocketConnect().
 * 
 *    Rev 1.33   17 Jun 1996 13:23:48   EHOWARDX
 * Workaround for PostQuitMessage() bug.
 * 
 *    Rev 1.32   12 Jun 1996 11:43:26   EHOWARDX
 * Changed linkLayerConnect errors from HWS_CRITICAL to HWS_WARNING.
 * 
 *    Rev 1.31   May 28 1996 18:14:00   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.30   May 28 1996 10:38:08   plantz
 * Change sprintf to wsprintf.
 * 
 *    Rev 1.29   17 May 1996 16:49:24   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.28   16 May 1996 13:09:18   EHOWARDX
 * Made reporting of IP Addres and port consistent between linkLayerListen
 * and LinkLayerConnect.
 * 
 *    Rev 1.27   14 May 1996 11:31:50   EHOWARDX
 * Fixed bug with doing another connect on instance that failed previous
 * connect. Instance now returns LINK_INVALID_STATE, and must be closed
 * and reopened.
 * 
 *    Rev 1.26   09 May 1996 18:33:22   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.25   Apr 29 1996 19:06:48   plantz
 * Reenable code to try to send all messages when shutting down.
 * 
 *    Rev 1.24   Apr 29 1996 14:02:58   plantz
 * Add NotifyRead and NotifyWrite functions.
 * Delete unused function FindH245Instance.
 * .
 * 
 *    Rev 1.23   Apr 25 1996 21:16:26   plantz
 * Add connect callback parameter to linkLayerAccept.
 * Pass message type to connect callback.
 * 
 *    Rev 1.22   Apr 24 1996 20:49:30   plantz
 * Listen on address passed to linkLayerListen; use INADDR_ANY if it is 0.
 * Return the result of getsockname after listening.
 * Add a callback parameter to linkLayerConnect. Call it when FD_CONNECT event
 * occurs and after calling accept, passing error code and local and peer
 * addresses.
 * 
 *    Rev 1.21   Apr 24 1996 16:55:20   plantz
 * Merge 1.15.1.0 with 1.20 (winsock 1 changes)
 * 
 *    Rev 1.20   19 Apr 1996 18:28:50   EHOWARDX
 * Changed Send and receive flush to call send and receive callback with
 * LINK_FLUSH_COMPLETE message to more accurately emulate behavior
 * of H245SRP.DLL.
 * 
 *    Rev 1.19   19 Apr 1996 10:34:26   EHOWARDX
 * Updated to latest LINKAPI.H - WINAPI keywork eliminated.
 * 
 *    Rev 1.18   12 Apr 1996 19:17:02   unknown
 * Removed annoying trace message.
 * 
 *    Rev 1.17   11 Apr 1996 14:53:22   EHOWARDX
 * Changed to include INCOMMON.H instead of CALLCONT.H.
 * 
 *    Rev 1.16   04 Apr 1996 12:35:04   EHOWARDX
 * Valiantly trying to track never-ending changes to Link Layer API
 * (Thanks Dan! Changing linkLayerGetInstId to linkLayerGetInstance() --
 * what a stroke of genius!)
 * 
 *    Rev 1.15.1.0   Apr 24 1996 16:23:02   plantz
 * Change to use winsock 1.
 * 
 *    Rev 1.15   03 Apr 1996 16:35:46   EHOWARDX
 * CLOSED state no longer implies that we have a thread;
 * replaced assert with if statement.
 * 
 *    Rev 1.14   03 Apr 1996 14:52:24   EHOWARDX
 * Fixed yet another shutdown problem.
 * 
 *    Rev 1.13   02 Apr 1996 18:28:50   EHOWARDX
 * Added ProcessQueuedRecvs() to SocketAccept().
 * 
 *    Rev 1.12   01 Apr 1996 16:25:46   EHOWARDX
 * Experiment with calling ProcessRecvQueue on FD_WRITE event.
 * 
 *    Rev 1.11   01 Apr 1996 14:20:40   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.10   29 Mar 1996 11:12:56   EHOWARDX
 * Added line to SocketClose to set state to HWS_CLOSED.
 * 
 *    Rev 1.9   27 Mar 1996 13:00:30   EHOWARDX
 * Added dwThreadId to H245WS instance structure.
 * Reversed shutdown loop to check state first BEFORE checking send queue.
 * 
 *    Rev 1.8   22 Mar 1996 10:54:20   unknown
 * 
 * Minor change in trace text.
 * 
 *    Rev 1.7   20 Mar 1996 14:11:20   unknown
 * Added Sleep(0) to bind retry loop.
 * 
 *    Rev 1.6   19 Mar 1996 20:21:56   EHOWARDX
 * Redesigned shutdown.
 * 
 *    Rev 1.4   18 Mar 1996 19:08:28   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.3   14 Mar 1996 17:01:46   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.2   09 Mar 1996 21:12:26   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.1   08 Mar 1996 20:24:24   unknown
 * This is the real version of the main h245ws.dll code.
 * Version 1.0 was a stub version created by Mike Andrews.
 *
 ***************************************************************************/

#ifndef STRICT
#define STRICT
#endif	// not defined STRICT
#define LINKDLL_EXPORT
#pragma warning ( disable : 4115 4201 4214 4514 )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "queue.h"
#include "linkapi.h"
#include "incommon.h"
#include "h245ws.h"
#include "tstable.h"
#include "provider.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// REVIEW: Should we use the newer definition from winsock2.h ?
#undef FD_ALL_EVENTS
#define FD_ALL_EVENTS (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE)
#define WINSOCK_EVENT_MSG (WM_USER+1)

HRESULT SocketOpen(PHWSINST pHws, BOOL bSetLinger = TRUE);


/*
 * Static variables
 */
static HWND        window   = 0;
TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table
static CRITICAL_SECTION SocketToHWSInstanceMapLock;
static SOCKET_TO_INSTANCE *pSocketToHWSInstanceMap = NULL;

// If we are not using the Unicode enabled tracing, then undefine the __TEXT macro.
// Do not place anything that should be a Unicode constant string between this #undef
// and the corresponding redefinition of the macro

#if defined(DBG)
#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x

static const char * StateMap[] =

#else

static const LPTSTR StateMap[] =

#endif
{
   __TEXT("HWS_START"),         // 0  Initial state
   __TEXT("HWS_LISTENING"),     // 1  Waiting for FD_ACCEPT
   __TEXT("HWS_CONNECTING"),    // 2  Waiting for FD_CONNECT
   __TEXT("HWS_CONNECTED"),     // 3  Data transfer state
   __TEXT("HWS_CLOSING"),       // 4  Waiting for FD_CLOSE
   __TEXT("HWS_CLOSED"),        // 5  Waiting for linkLayerShutdown()
   __TEXT("HWS_SHUTDOWN"),      // 6  linkLayerShutdown() called from callback
};


typedef struct _ERROR_MAP
{
   int         nErrorCode;

#ifdef UNICODE_TRACE
   LPCTSTR pszErrorText;
#else
   const char *pszErrorText;
#endif
} ERROR_MAP;


static const ERROR_MAP ErrorMap[] =
{
   0,                     __TEXT("OK"),
   WSAEINTR,              __TEXT("WSAEINTR - Interrupted function call"),
   WSAEBADF,              __TEXT("WSAEBADF"),
   WSAEACCES,             __TEXT("WSAEACCES - Permission denied"),
   WSAEFAULT,             __TEXT("WSAEFAULT - Bad address"),
   WSAEINVAL,             __TEXT("WSAEINVAL - Invalid argument"),
   WSAEMFILE,             __TEXT("WSAEMFILE - Too many open files"),
   WSAEWOULDBLOCK,        __TEXT("WSAEWOULDBLOCK - Resource temporarily unavailable"),
   WSAEINPROGRESS,        __TEXT("WSAEINPROGRESS - Operation now in progress"),
   WSAEALREADY,           __TEXT("WSAEALREADY - Operation already in progress"),
   WSAENOTSOCK,           __TEXT("WSAENOTSOCK - Socket operation on non-socket"),
   WSAEDESTADDRREQ,       __TEXT("WSAEDESTADDRREQ - Destination address required"),
   WSAEMSGSIZE,           __TEXT("WSAEMSGSIZE - Message too long"),
   WSAEPROTOTYPE,         __TEXT("WSAEPROTOTYPE - Protocol wrong type for socket"),
   WSAENOPROTOOPT,        __TEXT("WSAENOPROTOOPT - Bad protocol option"),
   WSAEPROTONOSUPPORT,    __TEXT("WSAEPROTONOSUPPORT - Protocol not supported"),
   WSAESOCKTNOSUPPORT,    __TEXT("WSAESOCKTNOSUPPORT - Socket type not supported"),
   WSAEOPNOTSUPP,         __TEXT("WSAEOPNOTSUPP - Operation not supported"),
   WSAEPFNOSUPPORT,       __TEXT("WSAEPFNOSUPPORT - Protocol family not supported"),
   WSAEAFNOSUPPORT,       __TEXT("WSAEAFNOSUPPORT - Address family not supported by protocol family"),
   WSAEADDRINUSE,         __TEXT("WSAEADDRINUSE - Address already in use"),
   WSAEADDRNOTAVAIL,      __TEXT("WSAEADDRNOTAVAIL - Cannot assign requested address"),
   WSAENETDOWN,           __TEXT("WSAENETDOWN - Network is down"),
   WSAENETUNREACH,        __TEXT("WSAENETUNREACH - Network is unreachable"),
   WSAENETRESET,          __TEXT("WSAENETRESET - Network dropped connection on reset"),
   WSAECONNABORTED,       __TEXT("WSAECONNABORTED - Software caused connection abort"),
   WSAECONNRESET,         __TEXT("WSAECONNRESET - Connection reset by peer"),
   WSAENOBUFS,            __TEXT("WSAENOBUFS - No buffer space available"),
   WSAEISCONN,            __TEXT("WSAEISCONN - Socket is already connected"),
   WSAENOTCONN,           __TEXT("WSAENOTCONN - Socket is not connected"),
   WSAESHUTDOWN,          __TEXT("WSAESHUTDOWN - Cannot send after socket shutdown"),
   WSAETOOMANYREFS,       __TEXT("WSAETOOMANYREFS"),
   WSAETIMEDOUT,          __TEXT("WSAETIMEDOUT - Connection timed out"),
   WSAECONNREFUSED,       __TEXT("WSAECONNREFUSED - Connection refused"),
   WSAELOOP,              __TEXT("WSAELOOP"),
   WSAENAMETOOLONG,       __TEXT("WSAENAMETOOLONG"),
   WSAEHOSTDOWN,          __TEXT("WSAEHOSTDOWN - Host is down"),
   WSAEHOSTUNREACH,       __TEXT("WSAEHOSTUNREACH - No route to host"),
   WSAENOTEMPTY,          __TEXT("WSAENOTEMPTY"),
   WSAEPROCLIM,           __TEXT("WSAEPROCLIM - Too many processes"),
   WSAEUSERS,             __TEXT("WSAEUSERS"),
   WSAEDQUOT,             __TEXT("WSAEDQUOT"),
   WSAESTALE,             __TEXT("WSAESTALE"),
   WSAEREMOTE,            __TEXT("WSAEREMOTE"),
   WSASYSNOTREADY,        __TEXT("WSASYSNOTREADY - Network subsystem is unavailable"),
   WSAVERNOTSUPPORTED,    __TEXT("WSAVERNOTSUPPORTED - WINSOCK.DLL version out of range"),
   WSANOTINITIALISED,     __TEXT("WSANOTINITIALISED - Successful WSAStartup() not yet performed"),
   WSAEDISCON,            __TEXT("WSAEDISCON - Graceful shutdown in progress"),
   WSAHOST_NOT_FOUND,     __TEXT("WSAHOST_NOT_FOUND - Host not found"),
   WSATRY_AGAIN,          __TEXT("WSATRY_AGAIN - Non-authoritative host not found"),
   WSANO_RECOVERY,        __TEXT("WSANO_RECOVERY - This is a non-recoverable error"),
   WSANO_DATA,            __TEXT("WSANO_DATA - Valid name, no data record of requested type"),
//   WSA_INVALID_HANDLE,    __TEXT("WSA_INVALID_HANDLE - Specified event object handle is invalid"),
//   WSA_INVALID_PARAMETER, __TEXT("WSA_INVALID_PARAMETER - One or more parameters are invalid"),
//   WSA_IO_PENDING,        __TEXT("WSA_IO_PENDING - Overlapped operations will complete later"),
//   WSA_IO_INCOMPLETE,     __TEXT("WSA_IO_INCOMPLETE - Overlapped I/O event object not in signaled state"),
//   WSA_NOT_ENOUGH_MEMORY, __TEXT("WSA_NOT_ENOUGH_MEMORY - Insufficient memory available"),
//   WSA_OPERATION_ABORTED, __TEXT("WSA_OPERATION_ABORTED - Overlapped operation aborted"),
};



//
// Function Definitions
//

#include <string.h>

#ifdef UNICODE_TRACE
static const LPTSTR
#else
static const char *
#endif
SocketStateText(UINT uState)
{
#ifdef UNICODE_TRACE
   static TCHAR      szSocketStateText[80];
#else
   static char       szSocketStateText[80];
#endif

   if (uState <= HWS_SHUTDOWN)
      return StateMap[uState];
   wsprintf(szSocketStateText, __TEXT("Unknown state %d"), uState);
   return szSocketStateText;
} // SocketStateText()



#ifdef UNICODE_TRACE
static LPCTSTR
#else
static const char *
#endif
SocketErrorText1(int nErrorCode)
{
   register int      nIndex = sizeof(ErrorMap) / sizeof(ErrorMap[0]);
#ifdef UNICODE_TRACE
   static TCHAR      szSocketErrorText[80];
#else
   static char       szSocketErrorText[80];
#endif


   while (nIndex > 0)
   {
      if (ErrorMap[--nIndex].nErrorCode == nErrorCode)
      {
         return ErrorMap[nIndex].pszErrorText;
      }
   }
   wsprintf(szSocketErrorText, __TEXT("Unknown error 0x%x"), nErrorCode);
   return szSocketErrorText;
} // SocketErrorText1()

#ifdef UNICODE_TRACE
LPCTSTR
#else
const char *
#endif
SocketErrorText(void)
{
   return SocketErrorText1(WSAGetLastError());
} // SocketErrorText()

#endif  // (DBG)


/***************************************************************************
 *
 * Local routines
 *
 ***************************************************************************/

static DWORD
HashSocket(SOCKET socket)
{
        return (DWORD)((socket >> 2) % SOCK_TO_PHYSID_TABLE_SIZE);
}



DWORD
SocketToPhysicalId(SOCKET socket)
{
	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	if(pSocketToHWSInstanceMap == NULL)
		return(INVALID_PHYS_ID);

	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	while(pEntry != NULL) 
	{
		if(pEntry->socket == socket)
		{
			LeaveCriticalSection(&SocketToHWSInstanceMapLock);
			return(pEntry->dwPhysicalId);
		} else
		{
			pEntry = pEntry->next;
		}
	}

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(INVALID_PHYS_ID);

} // SocketToPhysicalId()

BOOL
CreateSocketToPhysicalIdMapping(SOCKET socket, DWORD dwPhysicalId)
{
	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	
	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	PSOCKET_TO_INSTANCE pNewEntry;
	if (pEntry->socket == INVALID_SOCKET) 
	{
		pNewEntry = pEntry; 
	} else
	{
		pNewEntry = new SOCKET_TO_INSTANCE;
		if (pNewEntry == NULL) 
		{
			LeaveCriticalSection(&SocketToHWSInstanceMapLock);
			return(FALSE);
		}
		pNewEntry->next = pEntry->next;
		pEntry->next = pNewEntry;
	}

	pNewEntry->socket = socket;
	pNewEntry->dwPhysicalId = dwPhysicalId;

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(TRUE);
}

BOOL
RemoveSocketToPhysicalIdMapping(SOCKET socket)
{

	if (socket == INVALID_SOCKET)
		return(FALSE);

	// hash the socket to get an index into the SocketToHWSInstanceMap table
	DWORD idx = HashSocket(socket);
	BOOL bFound = FALSE;

	EnterCriticalSection(&SocketToHWSInstanceMapLock);
	
	// idx indicates the entry point in the array, now traverse the linked list
	PSOCKET_TO_INSTANCE pEntry = &pSocketToHWSInstanceMap[idx]; 
	if (pEntry->socket == socket) 
	{
		pEntry->socket = INVALID_SOCKET;
		bFound = TRUE;
	} else
	{
		PSOCKET_TO_INSTANCE pNextEntry;
		pNextEntry = pEntry->next;
		while (bFound == FALSE && pNextEntry != NULL)
		{
			if(pNextEntry->socket == socket)
			{
				pEntry->next = pNextEntry->next;
				delete pNextEntry;
				bFound = TRUE;
			} else
			{
				pEntry     = pNextEntry;
				pNextEntry = pNextEntry->next;
			}
		}
	}

	LeaveCriticalSection(&SocketToHWSInstanceMapLock);
	return(bFound);
}

static unsigned short GetPort (CC_ADDR *pAddr)
{
   unsigned short int port = 0;
   switch (pAddr->nAddrType)
   {
   case CC_IP_DOMAIN_NAME:
      port = pAddr->Addr.IP_DomainName.wPort;
      break;

   case CC_IP_DOT:
      port = pAddr->Addr.IP_Dot.wPort;
      break;

   case CC_IP_BINARY:
      port = pAddr->Addr.IP_Binary.wPort;
      break;

   } // switch

   return htons(port);
} // GetPort()


static unsigned long GetIPAddress (CC_ADDR *pAddr)
{
   struct hostent *     pHostEnt;
   char                 szAddr[256];

   switch (pAddr->nAddrType)
   {
   case CC_IP_DOMAIN_NAME:
      WideCharToMultiByte(CP_ACP,           // code page
                          0,                // dwFlags
                          pAddr->Addr.IP_DomainName.cAddr,
                          -1,               // Unicode string length (bytes)
                          szAddr,           // ASCII string
                          sizeof(szAddr),   // max ASCII string length
                          NULL,             // default character
                          NULL);            // default character used
      pHostEnt = gethostbyname(szAddr);
      if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
         return 0;
      return *((unsigned long *)pHostEnt->h_addr_list[0]);

   case CC_IP_DOT:
      WideCharToMultiByte(CP_ACP,           // code page
                          0,                // dwFlags
                          pAddr->Addr.IP_Dot.cAddr,
                          -1,               // Unicode string length (bytes)
                          szAddr,           // ASCII string
                          sizeof(szAddr),   // max ASCII string length
                          NULL,             // default character
                          NULL);            // default character used
      return inet_addr(szAddr);

   case CC_IP_BINARY:
       return pAddr->Addr.IP_Binary.dwAddr == 0 ? INADDR_ANY : htonl(pAddr->Addr.IP_Binary.dwAddr);
   } // switch
   return 0;
} // GetIPAddress()


static HRESULT GetLocalAddr(PHWSINST pHws, CC_ADDR *pAddr)
{
    SOCKADDR_IN sockaddr;
    int len = sizeof(sockaddr);

    if (getsockname(pHws->hws_Socket,
                    (struct sockaddr *)&sockaddr,
                    &len) == SOCKET_ERROR)
    {
        return MAKE_WINSOCK_ERROR(WSAGetLastError());
    }

    pAddr->nAddrType = CC_IP_BINARY;
	pAddr->bMulticast = FALSE;
    pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
    pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

    return NOERROR;
}

static HRESULT GetPeerAddr(PHWSINST pHws, CC_ADDR *pAddr)
{
    SOCKADDR_IN sockaddr;
    int len = sizeof(sockaddr);

    if (getpeername(pHws->hws_Socket,
                    (struct sockaddr *)&sockaddr,
                    &len) == SOCKET_ERROR)
    {
        return MAKE_WINSOCK_ERROR(WSAGetLastError());
    }

    pAddr->nAddrType = CC_IP_BINARY;
	pAddr->bMulticast = FALSE;
    pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
    pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

    return NOERROR;
}


void
SocketFlushRecv(PHWSINST pHws)
{
   register PREQUEST    pReq;

   if (pHws->hws_pRecvQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
      {
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_ABORT,
                                    pReq->req_client_data,
                                    0);
         HWSFREE(pReq);
      }
   }
   pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                              LINK_FLUSH_COMPLETE,
                              NULL,
                              0);
} // SocketFlushRecv()



void
SocketFlushSend(PHWSINST pHws)
{
   register PREQUEST    pReq;

   if (pHws->hws_pSendQueue)
   {
      while ((pReq = (PREQUEST)  QRemove(pHws->hws_pSendQueue)) != NULL)
      {
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_ABORT,
                                    pReq->req_client_data,
                                    0);
         HWSFREE(pReq);
      }
   }
   pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                              LINK_FLUSH_COMPLETE,
                              NULL,
                              0);
} // SocketFlushSend()



void
SocketCloseEvent(PHWSINST pHws)
{
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketCloseEvent"));
   if (pHws->hws_uState == HWS_CONNECTED)
   {
      register DWORD dwPhysicalId = pHws->hws_dwPhysicalId;
      pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,LINK_RECV_CLOSED,0,0);

      // Check to see if callback deallocated our instance or state changed

      if(gpInstanceTable->Validate(dwPhysicalId) == FALSE)
        return;

      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
				__TEXT("SocketCloseEvent: calling shutdown"));
      if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("HandleNetworkEvent: shutdown() returned %s"),
                  SocketErrorText());
      }
   }
   pHws->hws_uState = HWS_CLOSED;
} // SocketCloseEvent()



/*
 * DESCRIPTION
 *    Deallocate all allocated objects except for task handle
 */

void
SocketClose(PHWSINST pHws)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketClose"));

   pHws->hws_uState = HWS_CLOSED;

   RemoveSocketToPhysicalIdMapping(pHws->hws_Socket);

   // Close the socket
   if (pHws->hws_Socket != INVALID_SOCKET)
   {
      // To make the linger work, turn off WSAAsyncSelect to turn off 
      // non-blocking via ioctlsocket, to close the socket.
      unsigned long blocking = 0;
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                __TEXT("SocketClose: calling closesocket"));
         
      WSAAsyncSelect(pHws->hws_Socket,
                     window, WINSOCK_EVENT_MSG,
                     0);
      ioctlsocket(pHws->hws_Socket, FIONBIO,&blocking);
      if (closesocket(pHws->hws_Socket) == SOCKET_ERROR)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("SocketClose: closesocket() returned %s"),
                   SocketErrorText());
      }
      pHws->hws_Socket = INVALID_SOCKET;
   }

} // SocketClose()



HRESULT
SocketOpen(PHWSINST pHws, BOOL bSetLinger)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketOpen"));

   // Create a socket
   pHws->hws_Socket = socket(AF_INET, SOCK_STREAM, 0);
   if (pHws->hws_Socket == INVALID_SOCKET)
   {
      // WSASocket() failed
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("SocketOpen: socket() returned %s"),
                SocketErrorText1(err));
      SocketClose(pHws);
      return MAKE_WINSOCK_ERROR(err);
   }

   /*
   ** Request notification messages for all events on this socket.
   ** Note that this call automatically puts the socket into non-blocking
   ** mode, as if we had called WSAIoctl with the FIONBIO flag.
   **/
   if (WSAAsyncSelect(pHws->hws_Socket,
                      window, WINSOCK_EVENT_MSG,
                      FD_ALL_EVENTS) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketOpen: WSAASyncSelect() returned %s"),
                  SocketErrorText1(err));
      SocketClose(pHws);
      return MAKE_WINSOCK_ERROR(err);
   }

   if(bSetLinger == TRUE)
   {
		// Set a linger structure for the socket so that closesocket will block for a period of time (until all
		// data is sent or the timeout value) before actually killing the connection.
		// This change is being made in order to get rid of the PeekMessage() loops in linklayerShutdown().
		struct linger sockLinger;
		sockLinger.l_onoff = 1;				// yes we want to linger (wait for FIN ACK after sending data and FIN)
		sockLinger.l_linger = 1;			// linger for up to 1 second

	 
		if(setsockopt (pHws->hws_Socket,
								SOL_SOCKET,
								SO_LINGER,
								(const char*) &sockLinger,
								sizeof(sockLinger)) == SOCKET_ERROR)
		{
            int err = WSAGetLastError();
            HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketOpen: setsockopt returned %s"),
                  SocketErrorText1(err));
            SocketClose(pHws);
            return MAKE_WINSOCK_ERROR(err);
		}

	 }

   // add an entry in the socket to instance map
	if(CreateSocketToPhysicalIdMapping(pHws->hws_Socket, pHws->hws_dwPhysicalId) != TRUE)
	{
		HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
			__TEXT("SocketOpen: CreateSocketToPhysicalIdMapping() failed"));
		SocketClose(pHws);
		return(LINK_MEM_FAILURE);
	}

   return NOERROR;
} // SocketOpen()



HRESULT
SocketBind(PHWSINST pHws, CC_ADDR *pAddr)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pAddr != NULL);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketBind"));

   // Get a local address to bind the socket to
   pHws->hws_SockAddr.sin_family           = AF_INET;
   pHws->hws_SockAddr.sin_port             = GetPort(pAddr);
   pHws->hws_SockAddr.sin_addr.S_un.S_addr = GetIPAddress(pAddr);
   if ((pAddr->nAddrType == CC_IP_DOMAIN_NAME) &&
           (pHws->hws_SockAddr.sin_addr.S_un.S_addr == 0))
   {
       return LINK_UNKNOWN_ADDR;
   }

   // Bind the socket
   while (bind(pHws->hws_Socket,                            // s
               (const struct sockaddr *)&pHws->hws_SockAddr, // name
               sizeof(pHws->hws_SockAddr)) == SOCKET_ERROR)      // namelen
   {
      // bind() failed
      int err = WSAGetLastError();
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("SocketBind: bind() returned %s"),
                SocketErrorText1(err));
      if (err != WSAENOBUFS)
      {
         return MAKE_WINSOCK_ERROR(err);
      }
      Sleep(0);
   }

   return NOERROR;
} // SocketBind()

void
SocketConnect(PHWSINST pHws, int error)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("SocketConnect"));

   if (error == 0)
   {
       pHws->hws_uState = HWS_CONNECTED;

       if (pHws->hws_h245ConnectCallback)
       {
           CC_ADDR   LocalAddr;
           CC_ADDR   PeerAddr;
           PCC_ADDR  pLocalAddr = &LocalAddr;
           PCC_ADDR  pPeerAddr  = &PeerAddr;
           DWORD     dwPhysicalId = pHws->hws_dwPhysicalId;

           if (GetLocalAddr(pHws, pLocalAddr) != NOERROR)
               pLocalAddr = NULL;
           if (GetPeerAddr(pHws, pPeerAddr) != NOERROR)
               pPeerAddr = NULL;

           pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                 LINK_CONNECT_COMPLETE, pLocalAddr, pPeerAddr);

           // Check to see if callback deallocated our instance - this can be done
		   // by attempting a lock - which will now fail if the entry has been marked
		   // for deletion.  Thus, if the lock succeeds, then just unlock it (since we 
		   // already have a lock on it).

		   if(gpInstanceTable->Validate(dwPhysicalId) == FALSE)
			   return;
       }

       NotifyWrite(pHws);
       NotifyRead(pHws);
   }
   else
   {
      if (pHws->hws_h245ConnectCallback)
      {
         pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                       MAKE_WINSOCK_ERROR(error), NULL, NULL);
      }
   }
} // SocketConnect()

HRESULT
SocketAccept(PHWSINST pHwsListen, PHWSINST pHwsAccept)
{
   SOCKET listen_socket = pHwsListen->hws_Socket;
   struct linger sockLinger;
   sockLinger.l_onoff = 1;	// yes we want to linger (wait for FIN ACK after sending data and FIN)
   sockLinger.l_linger = 1;	// linger for up to 1 second

   // Accept the connection.
   pHwsAccept->hws_uSockAddrLen = sizeof(pHwsAccept->hws_SockAddr);
   pHwsAccept->hws_Socket = accept(pHwsListen->hws_Socket,
                       (struct sockaddr *)&pHwsAccept->hws_SockAddr,
                       (int *)&pHwsAccept->hws_uSockAddrLen);

   if (pHwsAccept->hws_Socket == INVALID_SOCKET)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHwsAccept->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerAccept: accept() returned %s"),
                SocketErrorText1(err));
      SocketConnect(pHwsAccept, err);
      return MAKE_WINSOCK_ERROR(err);
   }

   if (pHwsListen == pHwsAccept)
   {
      HWSTRACE0(pHwsListen->hws_dwPhysicalId, HWS_TRACE,
                __TEXT("SocketClose: calling closesocket"));
      closesocket(listen_socket);
      RemoveSocketToPhysicalIdMapping(listen_socket);
   }

   
   // Set a linger structure for the socket so that closesocket will block for a period of time (until all
   // data is sent or the timeout value) before actually killing the connection.
   // This change is being made in order to get rid of the PeekMessage() loops in linklayerShutdown().
   if(setsockopt (pHwsAccept->hws_Socket,
                  SOL_SOCKET,
	     		  SO_LINGER,
                  (const char*) &sockLinger,
                  sizeof(sockLinger)) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(pHwsAccept->hws_dwPhysicalId, HWS_WARNING,
                  __TEXT("SocketAccept: setsockopt returned %s"),
                  SocketErrorText1(err));
      SocketClose(pHwsAccept);
      return MAKE_WINSOCK_ERROR(err);
   }
   

   // add the new socket to the socket to phys id map
   CreateSocketToPhysicalIdMapping(pHwsAccept->hws_Socket, pHwsAccept->hws_dwPhysicalId);

   SocketConnect(pHwsAccept, 0);
   return NOERROR;
} // SocketAccept()



/*++

Description:

   Handles network events that may occur on a connected socket.
   The events handled by this function are FD_ACCEPT, FD_CLOSE, FD_READ, and
   FD_WRITE.

Arguments:

   pHws - pointer to data for the connection on which the event happened.
   event - event that occurred
   error - error code accompanying the event

Return Value:

   SUCCESS - The network event was successfully handled.

   LINK_FATAL_ERROR - Some kind of error occurred while handling the
   event, and the connection should be closed.

   LINK_RECV_CLOSED - The connection has been gracefully closed.

--*/

void
HandleNetworkEvent(PHWSINST pHws, int event, int error)
{
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("HandleNetworkEvent"));

   if (error == WSAENETDOWN)
   {
       HWSTRACE0(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                 __TEXT("HandleSocketEvent: Connection error"));
       pHws->hws_uState = HWS_CLOSED;
       return;
   }

   switch (event)
   {
   case FD_READ:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_READ %s"),
                SocketErrorText1(error));
      if (error == 0 && pHws->hws_uState <= HWS_CLOSING)
      {
         ProcessQueuedRecvs(pHws);
      }
      break;

   case FD_WRITE:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_WRITE %s"),
                SocketErrorText1(error));
      if (error == 0 && pHws->hws_uState <= HWS_CONNECTED)
      {
         ProcessQueuedSends(pHws);
      }
      break;

   case FD_OOB:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_OOB %s"),
                SocketErrorText1(error));
      break;


   case FD_ACCEPT:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_ACCEPT %s"),
                SocketErrorText1(error));
      if (pHws->hws_h245ConnectCallback != NULL)
      {
         if (error == 0)
         {
             pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                           LINK_CONNECT_REQUEST, NULL, NULL);
         }
         else
         {
             pHws->hws_h245ConnectCallback(pHws->hws_dwH245Instance,
                                           MAKE_WINSOCK_ERROR(error), NULL, NULL);
         }
      }
      else if (error == 0)
      {
         // If the client did not specify a callback, accept the call using the same physical
         // Id as the listen. This will result in the listen socket being closed.
         SocketAccept(pHws, pHws);
      }
      break;

   case FD_CONNECT:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_CONNECT %s"),
                SocketErrorText1(error));
      SocketConnect(pHws, error);
      break;

   case FD_CLOSE:
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                __TEXT("HandleNetworkEvent: FD_CLOSE %s"),
                SocketErrorText1(error));
      SocketCloseEvent(pHws);
      break;
   }
} // HandleNetworkEvent()


LRESULT CALLBACK WndProc(
        HWND hWnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
   PHWSINST pHws;
   DWORD dwPhysicalId;

#if defined(USE_PROVIDER_LOCK)
    H323LockProvider();
#endif

   switch (message)
   {
   case WINSOCK_EVENT_MSG:
      if (((dwPhysicalId=SocketToPhysicalId((SOCKET)wParam)) == INVALID_PHYS_ID) ||
          ((pHws=gpInstanceTable->Lock(dwPhysicalId)) == NULL))

      {
         HWSTRACE1(0, HWS_WARNING,
                   __TEXT("WndProc: Winsock event on unknown socket 0x%x"),
                   wParam);
         break;
      }

      HandleNetworkEvent(pHws, WSAGETSELECTEVENT(lParam), WSAGETSELECTERROR(lParam));
      gpInstanceTable->Unlock(dwPhysicalId);

      break;

   default:
      {
#if defined(USE_PROVIDER_LOCK)
         H323UnlockProvider();
#endif
         return DefWindowProc(hWnd, message, wParam, lParam);
      }
   }

#if defined(USE_PROVIDER_LOCK)
    H323UnlockProvider();
#endif

   return (0);
}

void NotifyRead(PHWSINST pHws)
{
   PostMessage(window, WINSOCK_EVENT_MSG, (WPARAM)pHws->hws_Socket, (LPARAM)MAKELONG(FD_READ, 0));
}

void NotifyWrite(PHWSINST pHws)
{
   PostMessage(window, WINSOCK_EVENT_MSG, (WPARAM)pHws->hws_Socket, (LPARAM)MAKELONG(FD_WRITE, 0));
}

/*++

Description:

   Calls WSAStartup, makes sure we have a good version of WinSock

Arguments:

   None.

Return Value:
   0                 WinSock DLL successfully started up.
   LINK_FATAL_ERROR  Error starting up WinSock DLL.

--*/


static const TCHAR CLASS_NAME[] = __TEXT("H245WSWndClass");

int     WinsockInitError = -1;
HRESULT InitializeStatus = LINK_INVALID_STATE;

void Initialize()
{
   WORD wVersion = MAKEWORD(1, 1);
   WSADATA  WsaData;      // receives data from WSAStartup
   WNDCLASS wndclass = { 0, WndProc, 0, 0, 0, 0, 0, 0, NULL, CLASS_NAME };
   DWORD    dwIndex;

   // Caveat: We can't use WSAGetLastError() for WSAStartup failure!
   if ((WinsockInitError = WSAStartup(wVersion, &WsaData)) != 0)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: WSAStartup() failed"));
      InitializeStatus = MAKE_WINSOCK_ERROR(WinsockInitError);
      return;
   }

   if (LOBYTE(WsaData.wVersion) != 1 ||
       HIBYTE(WsaData.wVersion) != 1)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: Winsock version mismatch"));
      InitializeStatus = MAKE_WINSOCK_ERROR(WSAVERNOTSUPPORTED);
      return;
   }

   // Create window to receive Winsock messages
   if (RegisterClass(&wndclass) == 0
       || (window = CreateWindow(CLASS_NAME, __TEXT(""), WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, 0, NULL)) == 0)
   {
      HWSTRACE0(0, HWS_WARNING, __TEXT("linkLayerInit: error creating window"));
      InitializeStatus = HRESULT_FROM_WIN32(GetLastError());
      return;
   }

   gpInstanceTable = new TSTable <HWSINST> (30);	// note: table will resize automatically
   if(gpInstanceTable == NULL || gpInstanceTable->IsInitialized() == FALSE)
   {
	  InitializeStatus = LINK_MEM_FAILURE;
      return;
   }
      
   pSocketToHWSInstanceMap = new SOCKET_TO_INSTANCE[SOCK_TO_PHYSID_TABLE_SIZE];
   if(pSocketToHWSInstanceMap == NULL)
   {
	  InitializeStatus = LINK_MEM_FAILURE;
      return;
   }

    __try {

        // initialize lock (and allocate event immediately)
        InitializeCriticalSectionAndSpinCount(&SocketToHWSInstanceMapLock,H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // report memory failure
        InitializeStatus = LINK_MEM_FAILURE;
        return;
    }

   memset(pSocketToHWSInstanceMap, 0, sizeof(SOCKET_TO_INSTANCE) * SOCK_TO_PHYSID_TABLE_SIZE);
	
   // Init the sockets to a bad value

   for (dwIndex = 0; dwIndex < SOCK_TO_PHYSID_TABLE_SIZE; dwIndex++)
   {
      pSocketToHWSInstanceMap[dwIndex].socket = INVALID_SOCKET;
   }

   InitializeStatus = NOERROR;
}

void Uninitialize()
{
   if (WinsockInitError == 0)
   {
      if (window)
      {
         DestroyWindow(window);
         window = 0;
         UnregisterClass(CLASS_NAME, 0);

         if (gpInstanceTable)
         {
            delete gpInstanceTable;

            if (InitializeStatus == NOERROR)
            {
               EnterCriticalSection(&SocketToHWSInstanceMapLock);
               delete pSocketToHWSInstanceMap;
               LeaveCriticalSection(&SocketToHWSInstanceMapLock);
               DeleteCriticalSection(&SocketToHWSInstanceMapLock);
            }
         }
      }
      WSACleanup();
   }

 }


/***************************************************************************
 *
 * External entry points
 *
 ***************************************************************************/
//MULTITHREAD => dwH245Instance is now an OUTPUT param not an INPUT param.
LINKDLL HRESULT linkLayerInit (DWORD          *dwPhysicalId,
                              DWORD          dwH245Instance,
                              H245SRCALLBACK cbReceiveComplete,
                              H245SRCALLBACK cbTransmitComplete)
{
   register PHWSINST    pHws;
   *dwPhysicalId = INVALID_PHYS_ID; // Just in case...

   // Put Initialize back in here so we know everything we need is up and
   // running.
   if (InitializeStatus == LINK_INVALID_STATE)
      Initialize();
  
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   pHws = (PHWSINST)HWSMALLOC(sizeof(*pHws));
   if (pHws == NULL)
   {
      // couldn't allocate our context. Return
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate context"));
      return LINK_MEM_FAILURE;
   }
   memset(pHws, 0, sizeof(*pHws));
   pHws->hws_Socket           = INVALID_SOCKET;
#if defined(DBG)
   pHws->hws_dwMagic = HWSINST_MAGIC;
#endif  // (DBG)

   // Create and initialize the Receive queue
   pHws->hws_pRecvQueue = QCreate();
   if (pHws->hws_pRecvQueue == NULL)
   {
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate Receive queue"));
      SocketClose(pHws);
      HWSFREE(pHws);
      return LINK_MEM_FAILURE;
   }

   // Create and initialize the Send queue
   pHws->hws_pSendQueue = QCreate();
   if (pHws->hws_pSendQueue == NULL)
   {
      HWSTRACE0(INVALID_PHYS_ID, HWS_WARNING, __TEXT("linkLayerInit: could not allocate Send queue"));
      SocketClose(pHws);
      HWSFREE(pHws);
      return LINK_MEM_FAILURE;
   }

   // Save intance identifiers and callback pointers
   pHws->hws_uState           = HWS_START;
   pHws->hws_dwH245Instance   = dwH245Instance;
   pHws->hws_h245RecvCallback = cbReceiveComplete;
   pHws->hws_h245SendCallback = cbTransmitComplete;

   // Open Channel 0 for the Forward and Reverse Directions
   // TBD

   // Add instance to instance list

   gpInstanceTable->CreateAndLock(pHws, &pHws->hws_dwPhysicalId);
   *dwPhysicalId = pHws->hws_dwPhysicalId;

   gpInstanceTable->Unlock(pHws->hws_dwPhysicalId);

   HWSTRACE2(*dwPhysicalId, HWS_TRACE,
             __TEXT("linkLayerInit(%d, %d) succeeded"), dwPhysicalId, dwH245Instance);

   return NOERROR;
} // linkLayerInit()



LINKDLL HRESULT linkLayerShutdown(DWORD dwPhysicalId)
{
   register PHWSINST    pHws;
   UINT                 uRetryCount;
   register PREQUEST    pReq;

   if (InitializeStatus != NOERROR)
      return InitializeStatus;
	
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerShutdown: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   // mark this instance as deleted so we don't process anymore messages for it - 
   // note: the FALSE indicates to the TSTable class to NOT do the deletion of memory
   // once the last unlock has completed (which is at the end of this function)
   gpInstanceTable->Delete(dwPhysicalId, FALSE);

   RemoveSocketToPhysicalIdMapping(pHws->hws_Socket);

   switch (pHws->hws_uState)
   {
   case HWS_START:
   case HWS_LISTENING:
   case HWS_CONNECTING:
      break;

   case HWS_CONNECTED:
      // Try to send all messages waiting on send queue
      HWSASSERT(pHws->hws_pSendQueue != NULL);
      ProcessQueuedSends(pHws);
      uRetryCount = 0;
      while (  pHws->hws_uState == HWS_CONNECTED &&
               IsQEmpty(pHws->hws_pSendQueue) == FALSE &&
               ++uRetryCount <= 5)
      {
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_NOTIFY,
                   __TEXT("linkLayerShutdown: Waiting for send %d"), uRetryCount);
         ProcessQueuedSends(pHws);
         Sleep(100);
      }

      if (pHws->hws_uState == HWS_CONNECTED)
      {
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                   __TEXT("linkLayerShutdown: calling shutdown"));
         if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
         {
            HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                     __TEXT("linkLayerShutdown: shutdown() returned %s"),
                     SocketErrorText());
         }
         pHws->hws_uState = HWS_CLOSING;
      }

   case HWS_CLOSING:
      break;

   case HWS_CLOSED:
      break;

   default:
      HWSASSERT(FALSE);
   } // switch

   // Deallocate instance objects

   SocketClose(pHws);


   // Deallocate Receive queue
   if (pHws->hws_pRecvQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
      {
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_ABORT,
                                    pReq->req_client_data,
                                    0);
         HWSFREE(pReq);
      }
      QFree(pHws->hws_pRecvQueue);
      pHws->hws_pRecvQueue = NULL;
   }

   // Deallocate Send queue
   if (pHws->hws_pSendQueue)
   {
      while ((pReq = (PREQUEST) QRemove(pHws->hws_pSendQueue)) != NULL)
      {
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_ABORT,
                                    pReq->req_client_data,
                                    0);
         HWSFREE(pReq);
      }
      QFree(pHws->hws_pSendQueue);
      pHws->hws_pSendQueue = NULL;
   }

   gpInstanceTable->Unlock(dwPhysicalId);

   HWSFREE(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerShutdown: succeeded"));
   return NOERROR;
} // linkLayerShutdown



/***************************************************************************
 *
 *  NAME
 *      linkLayerGetInstance - return instance id corresponding to physical id
 *
 *  SYNOPSIS
 *      LINKDLL DWORD linkLayerGetInstance(DWORD dwPhysicalId);
 *
 * DESCRIPTION
 *      Returns the Instance identifier corresponding to dwPhysId.
 *
 *  PARAMETERS
 *      dwPhysicalId    Physical identifier to search for
 *
 *  RETURN VALUE
 //MULTITHREAD
 *      INVALID_PHYS_ID    (-1)No instance corresponding to dwPhysicalId found
 *      n>0             Instance Id corresponding to dwPhysicalId
 *
 ***************************************************************************/

LINKDLL DWORD linkLayerGetInstance(DWORD dwPhysicalId)
{
   if (InitializeStatus == NOERROR &&
       dwPhysicalId != INVALID_PHYS_ID &&
       gpInstanceTable->Lock(dwPhysicalId) != NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerGetInstance: succeeded"));
      gpInstanceTable->Unlock(dwPhysicalId); 
      return dwPhysicalId;
   }

   HWSTRACE0(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerGetInstance: failed"));
   return INVALID_PHYS_ID;                           // return failure
} // linkLayerGetInstance()



/***************************************************************************
 *
 * NAME
 *    linkLayerFlushChannel - flush transmit and/or receive channels
 *
 * DESCRIPTION
 *    This is a dummy function required only for compatibility with the SRP API.
 *
 * RETURN VALUE
 *    0           Function succeeded.
 *    n!=0        Link error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/

LINKDLL HRESULT linkLayerFlushChannel(DWORD dwPhysicalId, DWORD dwDirectionMask)
{
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   PHWSINST pHws;
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerFlushChannel: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   switch (dwDirectionMask & (DATALINK_RECEIVE | DATALINK_TRANSMIT))
   {
   case DATALINK_TRANSMIT | DATALINK_RECEIVE:
      // Flush both receive and transmit
      // Caveat: H.245 expects us to flush receive first!
      SocketFlushRecv(pHws);

      // Fall through to next case

   case DATALINK_TRANSMIT:
      // Flush transmit
      // SockFlushSend() just removes the entries from the queue - it doesn't send them.
      // So instead, call ProcessQueuedSends() to actually empty the send queue.
      //      SocketFlushSend(pHws);	
			ProcessQueuedSends(pHws);
      break;

   case DATALINK_RECEIVE:
      // Flush receive
      SocketFlushRecv(pHws);
      break;

   } // switch

 	gpInstanceTable->Unlock(dwPhysicalId);

   HWSTRACE2(dwPhysicalId, HWS_TRACE,
             __TEXT("linkLayerFlushChannel(%d, 0x%X) succeeded"),
             dwPhysicalId, dwDirectionMask);
   return NOERROR;
} // linkLayerFlushChannel()



/***************************************************************************
 *
 * NAME
 *    linkLayerFlushAll - flush transmit and receive channels
 *
 * DESCRIPTION
 *    This is a dummy function required only for compatibility with the SRP API.
 *
 * RETURN VALUE
 *    0           Function succeeded.
 *    n!=0        Link error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/

LINKDLL HRESULT linkLayerFlushAll(DWORD dwPhysicalId)
{

   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   PHWSINST pHws;
   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("linkLayerFlushAll: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   // Flush both receive and transmit
   // Caveat: H.245 expects us to flush receive first!
   SocketFlushRecv(pHws);
   SocketFlushSend(pHws);

   gpInstanceTable->Unlock(dwPhysicalId);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerFlushAll succeeded"));
   return NOERROR;
} // linkLayerFlushAll()



/*++

Description:

   Initiates a call to a remote node.
   1) Create a socket.
   2) Set the socket up for windows message notification of FD_CONNECT events.
   3) Attempt a connection

Arguments:
   pHws  - Pointer to context data from connection.

Return Value:
   SUCCESS  - A connection attempt was successfully initiated.
   LINK_FATAL_ERROR  - Error occurred while attempting to initiate a connection.

--*/

LINKDLL HRESULT linkLayerConnect(DWORD dwPhysicalId, CC_ADDR *pAddr, H245CONNECTCALLBACK callback)
{
   register PHWSINST    pHws;
   CC_ADDR              Addr;
   HRESULT              hr;

   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   HWSTRACE5(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerConnect: connecting to %d.%d.%d.%d/%d"),
             GetIPAddress(pAddr) & 0xFF,
             (GetIPAddress(pAddr) >>  8) & 0xFF,
             (GetIPAddress(pAddr) >> 16) & 0xFF,
             GetIPAddress(pAddr) >> 24,
             ntohs(GetPort(pAddr)));

   if ((dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(dwPhysicalId))))
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerConnect: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState != HWS_START)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR, __TEXT("linkLayerConnect: State = %s"),
                SocketStateText(pHws->hws_uState));
   	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   pHws->hws_h245ConnectCallback = callback;

   // Create a socket, bind to a local address and initiate a connection.
   if ((hr = SocketOpen(pHws)) != NOERROR)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerConnect: SocketOpen() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(dwPhysicalId);
      return hr;
   }

   Addr.nAddrType = CC_IP_BINARY;
   Addr.bMulticast = FALSE;
   Addr.Addr.IP_Binary.wPort = 0;
   Addr.Addr.IP_Binary.dwAddr = 0;
   if ((hr = SocketBind(pHws, &Addr)) != NOERROR)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
	      __TEXT("linkLayerConnect: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(dwPhysicalId);
      return hr;
   }

   // Reminder: WinSock requires that we pass a struct sockaddr *
   // to connect; however, the service provider is free to
   // interpret the pointer as an arbitrary chunk of data of size
   // uSockAddrLen.
   pHws->hws_SockAddr.sin_port             = GetPort(pAddr);
   pHws->hws_SockAddr.sin_addr.S_un.S_addr = GetIPAddress(pAddr);
   if (connect(pHws->hws_Socket,                                   // s
            (const struct sockaddr *)&pHws->hws_SockAddr,   // name
            sizeof(pHws->hws_SockAddr)) == SOCKET_ERROR)   // namelen
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         break;

      default:
         HWSTRACE1(dwPhysicalId, HWS_WARNING,
                   __TEXT("linkLayerConnect: WSAConnect() returned %s"),
                   SocketErrorText1(err));
         SocketClose(pHws);
         pHws->hws_uState = HWS_START;
         gpInstanceTable->Unlock(dwPhysicalId);
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   } // if
   else
   {
      HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("connect() succeeded"));
      SocketConnect(pHws, 0);
      gpInstanceTable->Unlock(dwPhysicalId);
      return NOERROR;
   } // else

   pHws->hws_uState = HWS_CONNECTING;
   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("linkLayerConnect: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // linkLayerConnect()



/***************************************************************************
 *
 * NAME
 *    linkLayerListen - start listen on connection
 *
 * DESCRIPTION
 *    This function creates a socket,
 *    binds to a local address, and listens on the created socket.
 *    The address being listened to is returned in the structure
 *    pointed to by pAddr.
 *
 * PARAMETERS
 *    dwPhysicalId      Link layer identifier returned by linkLayerGetInstance().
 *    pAddr             Pointer to address structure (defined in CALLCONT.H.)
 *
 * RETURN VALUE
 *    0                 Function succeeded.
 *    n!=0              Error code (see LINKAPI.H for definitions.)
 *
 ***************************************************************************/
//MULTITHREAD => dwPhysicalID was INPUT now it's OUTPUT
LINKDLL HRESULT linkLayerListen (DWORD *dwPhysicalId, DWORD dwH245Instance, CC_ADDR *pAddr, H245CONNECTCALLBACK callback)
{
   HRESULT hr;
   register PHWSINST    pHws;

   if (InitializeStatus == LINK_INVALID_STATE)
      Initialize();
   if (InitializeStatus != NOERROR)
      return InitializeStatus;

   if ((*dwPhysicalId == INVALID_PHYS_ID) ||
      (!(pHws = gpInstanceTable->Lock(*dwPhysicalId))))
   {
      if ((hr = linkLayerInit(dwPhysicalId, dwH245Instance, NULL, NULL)) != NOERROR)
         return hr;

      pHws = gpInstanceTable->Lock(*dwPhysicalId);
      HWSASSERT(pHws != NULL);
   }
   else
   {
      HWSASSERT(pHws->hws_dwH245Instance == dwH245Instance);
   }

   if (pHws->hws_uState != HWS_START)
   {
      HWSTRACE1(*dwPhysicalId, HWS_ERROR, __TEXT("linkLayerListen: State = %s"),
                SocketStateText(pHws->hws_uState));
      gpInstanceTable->Unlock(*dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   pHws->hws_h245ConnectCallback = callback;

   if ((hr = SocketOpen(pHws, FALSE)) != NOERROR)
   {
      HWSTRACE0(*dwPhysicalId, HWS_WARNING, __TEXT("linkLayerListen: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   if ((hr = SocketBind(pHws, pAddr)) != NOERROR)
   {
      HWSTRACE0(*dwPhysicalId, HWS_WARNING, __TEXT("linkLayerListen: SocketBind() failed"));
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   // Listen for incoming connection requests on the socket.
   int nBacklog = SOMAXCONN;
   while (listen(pHws->hws_Socket, nBacklog) == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      HWSTRACE1(*dwPhysicalId,
                HWS_WARNING,
                __TEXT("linkLayerListen: listen() returned %s"),
                SocketErrorText1(err));
      if (nBacklog == SOMAXCONN)
         nBacklog = 10;
      if (err != WSAENOBUFS || --nBacklog == 0)
      {
         SocketClose(pHws);
         pHws->hws_uState = HWS_START;
         gpInstanceTable->Unlock(*dwPhysicalId);
         return MAKE_WINSOCK_ERROR(err);
      }     
      Sleep(0);
   }

   if ((hr = GetLocalAddr(pHws, pAddr)) != NOERROR)
   {
      // getsockname() failed
      HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                __TEXT("linkLayerListen: getsockname() returned %s"),
                SocketErrorText());
      SocketClose(pHws);
      pHws->hws_uState = HWS_START;
      gpInstanceTable->Unlock(*dwPhysicalId);
      return hr;
   }

   HWSTRACE5(*dwPhysicalId, HWS_TRACE, __TEXT("linkLayerListen: listening on %d.%d.%d.%d/%d"),
             GetIPAddress(pAddr) & 0xFF,
             (GetIPAddress(pAddr) >>  8) & 0xFF,
             (GetIPAddress(pAddr) >> 16) & 0xFF,
             GetIPAddress(pAddr) >> 24,
             ntohs(GetPort(pAddr)));

   pHws->hws_uState = HWS_LISTENING;
   HWSTRACE0(*dwPhysicalId, HWS_TRACE, __TEXT("linkLayerListen: succeeded"));
   gpInstanceTable->Unlock(*dwPhysicalId);
   return NOERROR;
} // linkLayerListen()


LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback)
{
    PHWSINST pHwsListen;
    PHWSINST pHwsAccept;

    HRESULT rc;
    if (InitializeStatus != NOERROR)
       return InitializeStatus;

	HWSTRACE0(dwPhysicalIdAccept, HWS_TRACE, __TEXT("linkLayerAccept"));
    if ((dwPhysicalIdListen == INVALID_PHYS_ID) ||
       (!(pHwsListen = gpInstanceTable->Lock(dwPhysicalIdListen))))
    {
       HWSTRACE0(dwPhysicalIdListen, HWS_ERROR, __TEXT("linkLayerAccept: dwPhysicalIdListen not found"));
       return LINK_INVALID_INSTANCE;
    }

    pHwsAccept = gpInstanceTable->Lock(dwPhysicalIdAccept);
    if (pHwsAccept == NULL)
    {
       HWSTRACE0(dwPhysicalIdAccept, HWS_ERROR, __TEXT("linkLayerAccept: dwPhysicalIdAccept not found"));
		 gpInstanceTable->Unlock(dwPhysicalIdListen);
       return LINK_INVALID_INSTANCE;
    }

    HWSASSERT(pHwsListen->hws_uState == HWS_LISTENING);
    HWSASSERT(pHwsAccept == pHwsListen || pHwsAccept->hws_uState == HWS_START);

    pHwsAccept->hws_h245ConnectCallback = callback;

    rc = SocketAccept(pHwsListen, pHwsAccept);
	gpInstanceTable->Unlock(dwPhysicalIdListen);
    gpInstanceTable->Unlock(dwPhysicalIdAccept);
    return rc;
}

// Here is the corresponding redefinition of the __TEXT macro

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) L##x
#endif


#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\h245ws.h ===
/***************************************************************************
 *
 * File: h245ws.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245ws.h  $
 * $Revision:   1.19  $
 * $Modtime:   31 Jan 1997 15:56:32  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\h245ws.h_v  $
 * 
 *    Rev 1.19   31 Jan 1997 16:23:34   SBELL1
 * Got rid of unused next pointer and put in definition of SocketTOPhysicalID
 * 
 *    Rev 1.18   13 Dec 1996 12:13:06   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.17   11 Dec 1996 13:45:36   SBELL1
 * Changed table/locks to use tstable.h stuff.
 * 
 *    Rev 1.16   21 Jun 1996 18:51:44   unknown
 * Fixed yet another shutdown bug - linkLayerShutdown re-entrancy check.
 * 
 *    Rev 1.15   May 28 1996 10:36:50   plantz
 * Change HWSMALLOC and HWSFREE to use GlobalAlloc and GlobalFree (in release
 * build only). Remove HWSREALLOC; it was not used.
 * .
 * 
 *    Rev 1.14   17 May 1996 16:49:36   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.13   16 May 1996 13:09:50   EHOWARDX
 * Made reporting of IP Addres and port consistent between linkLayerListen
 * and LinkLayerConnect.
 * 
 *    Rev 1.12   09 May 1996 18:33:06   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.11   Apr 29 1996 14:02:28   plantz
 * Delete unused or private functions.
 * 
 *    Rev 1.10   Apr 29 1996 12:15:38   plantz
 * Remove unused members of HWSINST structure.
 * 
 *    Rev 1.9   Apr 24 1996 20:46:58   plantz
 * Changed ListenCallback to ConnectCallback in HWSINST structure.
 * 
 *    Rev 1.8   Apr 24 1996 16:24:14   plantz
 * Change to use winsock 1 and not use overlapped I/O.
 * 
 *    Rev 1.7   01 Apr 1996 14:20:38   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.6   27 Mar 1996 13:01:28   EHOWARDX
 * Added dwThreadId to H245WS instance structure.
 * 
 *    Rev 1.5   19 Mar 1996 20:21:46   EHOWARDX
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:07:10   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:01:50   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:58   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:17:56   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef H245WS_H
#define H245WS_H

#ifndef STRICT 
#define STRICT 
#endif

#include <malloc.h>
#include <incommon.h>

#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus

/*
 * Constants
 */

#define SUCCESS         0
#define TPKT_VERSION    3
#define TPKT_HEADER_SIZE 4

// Indexes of permanent events in Events[]
#define EVENT_SOCKET    0
#define EVENT_RECV      1
#define EVENT_SEND      2
#define EVENT_FIRST     3



// Values for byLevel
#define HWS_CRITICAL    0x01
#define HWS_ERROR       0x02
#define HWS_WARNING     0x04
#define HWS_NOTIFY      0x08
#define HWS_TRACE       0x10
#define HWS_TEMP        0x20
#define HWSMALLOC(x)    malloc(x)
#define HWSFREE(x)      free(x)
#if defined(DBG)
 void HwsTrace (DWORD dwInst, BYTE byLevel, LPSTR pszFormat, ...);
 #define HWSASSERT(exp) ASSERT(exp)
 #define HWSTRACE0(dwH245Instance,byLevel,a) HwsTrace(dwH245Instance,byLevel,a)
 #define HWSTRACE1(dwH245Instance,byLevel,a,b) HwsTrace(dwH245Instance,byLevel,a,b)
 #define HWSTRACE2(dwH245Instance,byLevel,a,b,c) HwsTrace(dwH245Instance,byLevel,a,b,c)
 #define HWSTRACE3(dwH245Instance,byLevel,a,b,c,d) HwsTrace(dwH245Instance,byLevel,a,b,c,d)
 #define HWSTRACE4(dwH245Instance,byLevel,a,b,c,d,e) HwsTrace(dwH245Instance,byLevel,a,b,c,d,e)
 #define HWSTRACE5(dwH245Instance,byLevel,a,b,c,d,e,f) HwsTrace(dwH245Instance,byLevel,a,b,c,d,e,f)
#else   // (DBG)
 #define HWSASSERT(exp)
 #define HWSTRACE0(dwH245Instance,byLevel,a)
 #define HWSTRACE1(dwH245Instance,byLevel,a,b)
 #define HWSTRACE2(dwH245Instance,byLevel,a,b,c)
 #define HWSTRACE3(dwH245Instance,byLevel,a,b,c,d)
 #define HWSTRACE4(dwH245Instance,byLevel,a,b,c,d,e)
 #define HWSTRACE5(dwH245Instance,byLevel,a,b,c,d,e,f)
#endif  // (DBG)


// This structure is used for overlapped sends and receives
typedef struct _IO_REQUEST
{
   struct _HWSINST * req_pHws;         // Pointer back to socket data
   BYTE              req_TpktHeader[TPKT_HEADER_SIZE];
   int               req_header_bytes_done;
   BYTE            * req_client_data;
   int               req_client_length;
   int               req_client_bytes_done;
   DWORD             req_dwMagic;      // Request type (send or receive)
#define RECV_REQUEST_MAGIC 0x91827364
#define SEND_REQUEST_MAGIC 0x19283746
} REQUEST, *PREQUEST;



typedef struct _HWSINST
{
   UINT              hws_uState;
#define HWS_START          0  
#define HWS_LISTENING      1  /* Waiting for FD_ACCEPT                     */
#define HWS_CONNECTING     2  /* Waiting for FD_CONNECT                    */
#define HWS_CONNECTED      3  /* Data transfer state                       */
#define HWS_CLOSING        4  /* Waiting for FD_CLOSE                      */
#define HWS_CLOSED         5  /* Waiting for linkLayerShutdown()           */
#define HWS_SHUTDOWN       6  /* linkLayerShutdown() called from callback  */

   DWORD             hws_dwPhysicalId;
   DWORD             hws_dwH245Instance;
   H245CONNECTCALLBACK hws_h245ConnectCallback;
   H245SRCALLBACK    hws_h245RecvCallback;
   H245SRCALLBACK    hws_h245SendCallback;
   SOCKET            hws_Socket;
   SOCKADDR_IN       hws_SockAddr;
   UINT              hws_uSockAddrLen;

   // points to a queue used to hold send buffers
   PQUEUE            hws_pSendQueue;

   // points to a queue used to hold receive buffers
   PQUEUE            hws_pRecvQueue;

   // The maximum message size we can send on this socket.
   // This value is either an integer or the manifest constant NO_MAX_MSG_SIZE.
   UINT              hws_uMaxMsgSize;
   BOOL              hws_bCloseFlag;

#if defined(DBG)
   DWORD             hws_dwMagic;      // Request type (send or receive)
#define HWSINST_MAGIC   0x12345678
#endif  // (DBG)

} HWSINST, *PHWSINST;


typedef struct _SOCKET_TO_INSTANCE
{
	SOCKET socket;
	DWORD dwPhysicalId;
	struct _SOCKET_TO_INSTANCE *next;
} SOCKET_TO_INSTANCE, *PSOCKET_TO_INSTANCE;

#define SOCK_TO_PHYSID_TABLE_SIZE		251

////////////////////////////////////////////////////////////////////////////
//
// Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE_TRACE
LPCTSTR
#else
const char *
#endif
SocketErrorText(void);

//PHWSINST FindPhysicalId(DWORD dwPhysicalId);
void NotifyRead        (PHWSINST pHws);
void NotifyWrite       (PHWSINST pHws);
void ProcessQueuedRecvs(PHWSINST pHws);
void ProcessQueuedSends(PHWSINST pHws);
void SocketCloseEvent  (PHWSINST pHws);
DWORD SocketToPhysicalId (SOCKET socket);
BOOL CreateSocketToPhysicalIdMapping(SOCKET socket, DWORD dwPhysicalId);
BOOL RemoveSocketToPhysicalIdMapping(SOCKET socket);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)


#endif  // H245WS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\src\rtdse.c ===
/***********************************************************************
 *                                                                     *
 * Filename: rtdse.c                                                   *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   rtdse.c  $
 * $Revision:   1.4  $
 * $Modtime:   Feb 28 1997 13:13:32  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/rtdse.c_v  $
 * 
 *    Rev 1.4   Feb 28 1997 13:14:24   tomitowx
 * fixed Roundtripdelay timer problem.
 * that occurs when ping peer link is invalid/unvailable
 * due to an abnormal application/machine shutdown.
 * 
 *    Rev 1.3   09 Dec 1996 13:37:04   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.2   04 Jun 1996 13:57:26   EHOWARDX
 * Fixed Release build warnings.
 * 
 *    Rev 1.1   30 May 1996 23:39:28   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.0   09 May 1996 21:06:42   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.1   09 May 1996 19:48:24   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.0   15 Apr 1996 10:46:40   EHOWARDX
 * Initial revision.
 *                                                                     *
 ***********************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "rtdse.h"



// Out-going/In-coming RTDSE states
#define RTDSE_IDLE                  0   // IDLE
#define RTDSE_WAIT                  1   // AWAITING_RESPONSE



extern unsigned int uT105;

/***********************************************************************
 *
 * LOCAL FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      T105ExpiryF - Callback function called by the timer
 *
 *
 *  PARAMETERS
 *   INPUT   dwInst     current instance of H.245
 *   INPUT   id         timer id
 *   INPUT   pObject    pointer to a State Entity
 *
 *
 *  RETURN VALUE
 *       OK
 */

int T105ExpiryF(struct InstanceStruct *pInstance, DWORD dwTimerId, void *pObject)
{
    return FsmTimerEvent(pInstance, dwTimerId, pObject, T105Expiry);
} // T105ExpiryF()



static void BuildRoundTripDelayResponse(PDU_t *pOut, BYTE bySequenceNumber)
{
    pOut->choice = MSCMg_rspns_chosen;
    pOut->u.MSCMg_rspns.choice = roundTripDelayResponse_chosen;
    pOut->u.MSCMg_rspns.u.roundTripDelayResponse.sequenceNumber = bySequenceNumber;
} // BuildRoundTripDelayResponse()



/***********************************************************************
 *
 * FINITE STATE MACHINE FUNCTIONS
 *
 ***********************************************************************/

/*
 *  NAME
 *      RTDSE0_TRANSFER_requestF - TRANSFER.request from API in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE0_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == RTDSE);
    H245ASSERT(pObject->State  == RTDSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RTDSE0_TRANSFER_request:%d", pObject->Key);

    pObject->pInstance->StateMachine.byRtdseSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber =
        pObject->pInstance->StateMachine.byRtdseSequence;

    // Send RoundTripDelayRequest PDU to remote peer
    lError = sendPDU(pObject->pInstance, pPdu);

	
//tomitowoju@intel.com
	if(lError == H245_ERROR_OK)
	{
		// Set timer T105
		pObject->State = RTDSE_WAIT;
		FsmStartTimer(pObject, T105ExpiryF, uT105);

	}
//tomitowoju@intel.com
		// Set timer T105
//		pObject->State = RTDSE_WAIT;
//		FsmStartTimer(pObject, T105ExpiryF, uT105);
//tomitowoju@intel.com

    return lError;
} // RTDSE0_TRANSFER_request



/*
 *  NAME
 *      RTDSE0_RoundTripDelayRequestF - RoundTripDelayRequest received in IDLE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE0_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == RTDSE);
    H245ASSERT(pObject->State  == RTDSE_IDLE);
    H245TRACE(pObject->dwInst, 2, "RTDSE0_RoundTripDelayRequest:%d", pObject->Key);

    // Send RoundTripDelayResponse to remote peer
    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RTDSE0_RoundTripDelayRequestF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildRoundTripDelayResponse(pOut, (BYTE)pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    return lError;
} // RTDSE0_RoundTripDelayRequest



/*
 *  NAME
 *      RTDSE1_TRANSFER_requestF - TRANSFER.request from API in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_TRANSFER_requestF        (Object_t *pObject, PDU_t *pPdu)
{
    HRESULT             lError;

    H245ASSERT(pObject->Entity == RTDSE);
    H245ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_TRANSFER_request:%d", pObject->Key);

    // Reset timer T105
    FsmStopTimer(pObject);

    pObject->pInstance->StateMachine.byRtdseSequence++;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber =
        pObject->pInstance->StateMachine.byRtdseSequence;

    // Send RoundTripDelayRequest PDU to remote
    lError = sendPDU(pObject->pInstance, pPdu);

    // Set timer T105
    FsmStartTimer(pObject, T105ExpiryF, uT105);

    return lError;
} // RTDSE1_TRANSFER_request



/*
 *  NAME
 *      RTDSE1_RoundTripDelayRequestF - RoundTripDelayRequest received in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_RoundTripDelayRequestF   (Object_t *pObject, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    H245ASSERT(pObject->Entity == RTDSE);
    H245ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_RoundTripDelayRequest:%d", pObject->Key);

    // Send RoundTripDelayResponse to remote peer
    pOut = H245_malloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        H245TRACE(pObject->dwInst, 2,
                  "RTDSE1_RoundTripDelayRequestF: memory allocation failed");
        return H245_ERROR_NOMEM;
    }
    BuildRoundTripDelayResponse(pOut, (BYTE)pPdu->u.MltmdSystmCntrlMssg_rqst.u.roundTripDelayRequest.sequenceNumber);
    lError = sendPDU(pObject->pInstance, pOut);
    H245_free(pOut);

    return lError;
} // RTDSE1_RoundTripDelayRequest



/*
 *  NAME
 *      RTDSE1_RoundTripDelayResponseF - RoundTripDelayResponse in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

HRESULT RTDSE1_RoundTripDelayResponseF  (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RTDSE);
    H245ASSERT(pObject->State  == RTDSE_WAIT);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_RoundTripDelayResponse:%d", pObject->Key);

    if (pPdu->u.MSCMg_rspns.u.roundTripDelayResponse.sequenceNumber ==
        pObject->pInstance->StateMachine.byRtdseSequence)
    {
        // Reset timer T105
        FsmStopTimer(pObject);

        // Send TRANSFER.confirm to H.245 user
        pObject->State = RTDSE_IDLE;
        H245FsmConfirm(pPdu, H245_CONF_RTDSE, pObject->pInstance, pObject->dwTransId, FSM_OK);
    }

    return 0;
} // RTDSE1_RoundTripDelayResponse



/*
 *  NAME
 *      RTDSE1_T105ExpiryF - timer T105 Expiry in AWAITING RESPONSE state
 *
 *
 *  PARAMETERS
 *      INPUT   pObject pointer to State Entity
 *      INPUT   pPdu    pointer to PDU
 *
 *  RETURN VALUE
 *      Error return codes defined in h245com.h
 */

# pragma warning( disable : 4100 )

HRESULT RTDSE1_T105ExpiryF              (Object_t *pObject, PDU_t *pPdu)
{
    H245ASSERT(pObject->Entity == RTDSE);
    H245ASSERT(pObject->State  == RTDSE_WAIT);
    H245ASSERT(pPdu == NULL);
    H245TRACE(pObject->dwInst, 2, "RTDSE1_T105Expiry:%d", pObject->Key);

    // Send EXPIRY.notification to client
    pObject->State = RTDSE_IDLE;
    H245FsmConfirm(NULL, H245_CONF_RTDSE_EXPIRED, pObject->pInstance, pObject->dwTransId, FSM_OK);

    return 0;
} // RTDSE1_T105Expiry

# pragma warning( default : 4100 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\hwsdebug.c ===
/***************************************************************************
 *
 * File: hwsdebug.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   hwsdebug.c  $
 * $Revision:   1.13  $
 * $Modtime:   13 Dec 1996 11:44:24  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\hwsdebug.c_v  $
 * 
 *    Rev 1.13   13 Dec 1996 12:12:50   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.12   11 Dec 1996 13:41:56   SBELL1
 * Put in UNICODE tracing stuff.
 * 
 *    Rev 1.11   01 Oct 1996 14:49:22   EHOWARDX
 * Revision 1.9 copied to tip.
 * 
 *    Rev 1.9   May 28 1996 10:40:14   plantz
 * Change vsprintf to wvsprintf.
 * 
 *    Rev 1.8   29 Apr 1996 17:13:16   unknown
 * Fine-tuning instance-specific name.
 * 
 *    Rev 1.7   29 Apr 1996 13:04:56   EHOWARDX
 * 
 * Added timestamp and instance-specific short name.
 * 
 *    Rev 1.6   Apr 24 1996 16:20:56   plantz
 * Removed include winsock2.h and incommon.h
 * 
 *    Rev 1.4.1.0   Apr 24 1996 16:19:54   plantz
 * Removed include winsock2.h and callcont.h
 * 
 *    Rev 1.4   01 Apr 1996 14:20:34   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.3   22 Mar 1996 16:04:18   EHOWARDX
 * Added #if defined(_DEBUG) around whole file.
 * 
 *    Rev 1.2   22 Mar 1996 15:25:28   EHOWARDX
 * Changed to use ISR_HookDbgStr instead of OutputDebugString.
 * 
 *    Rev 1.1   14 Mar 1996 17:01:00   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.0   08 Mar 1996 20:22:14   unknown
 * Initial revision.
 *
 ***************************************************************************/

#if defined(DBG) && !defined(ISRDBG)

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

DWORD g_dwLinkDbgLevel = 0;
BOOL  g_fLinkDbgInitialized = FALSE;

void LinkDbgInit() {

#define H323_REGKEY_ROOT \
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\H323TSP")

#define H323_REGVAL_DEBUGLEVEL \
    TEXT("DebugLevel")

#define H323_REGVAL_LINKDEBUGLEVEL \
    TEXT("LinkDebugLevel")

    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    LPSTR pszValue;
    LPSTR pszKey = H323_REGKEY_ROOT;

    // only call this once
    g_fLinkDbgInitialized = TRUE;

    // open registry subkey
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus != ERROR_SUCCESS) {
        return; // bail...
    }
    
    // initialize values
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // retrieve link debug level
    pszValue = H323_REGVAL_LINKDEBUGLEVEL;

    // query for registry value
    lStatus = RegQueryValueEx(
                hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // initialize values
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // retrieve tsp debug level
        pszValue = H323_REGVAL_DEBUGLEVEL;

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );
    }

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // update debug level
        g_dwLinkDbgLevel = dwValue;
    }

    // close key
    RegCloseKey(hKey);
}

/*****************************************************************************
 *
 * TYPE:       Global System
 *
 * PROCEDURE:  HwsTrace
 *
 * DESCRIPTION:
 *    Trace function for HWS
 *
 * INPUT:
 *    dwInst         Instance identifier for trace message
 *    dwLevel        Trace level as defined below
 *    pszFormat      sprintf string format with 1-N parameters
 *
 * Trace Level (byLevel) Definitions:
 *    HWS_CRITICAL   Progammer errors that should never happen
 *    HWS_ERROR	   Errors that need to be fixed
 *    HWS_WARNING	   The user could have problems if not corrected
 *    HWS_NOTIFY	   Status, events, settings...
 *    HWS_TRACE	   Trace info that will not overrun the system
 *    HWS_TEMP		   Trace info that may be reproduced in heavy loops
 *
 * RETURN VALUE:
 *    None
 *
 *****************************************************************************/

void HwsTrace (DWORD dwInst,
               BYTE byLevel, 
#ifdef UNICODE_TRACE
				LPTSTR pszFormat,
#else
				LPSTR pszFormat,
#endif               
                ...)
{
#define DEBUG_FORMAT_HEADER     "LINK "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "

#define MAX_DEBUG_STRLEN        512

    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAX_DEBUG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // make sure initialized
    if (g_fLinkDbgInitialized == FALSE) {
        LinkDbgInit();
    }

    // validate debug log level
    if ((DWORD)(BYTE)byLevel > g_dwLinkDbgLevel) {
        return; // bail...
    }

    // retrieve local time
    GetLocalTime(&SystemTime);

    // add component header to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_HEADER
                       );

    // add timestamp to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_TIMESTAMP,
                       SystemTime.wHour,
                       SystemTime.wMinute,
                       SystemTime.wSecond,
                       SystemTime.wMilliseconds
                       );

    // add thread id to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_THREADID,
                       GetCurrentThreadId()
                       );

    // point at first argument
    va_start(Args, pszFormat);

    // determine number of bytes left in buffer
    nLengthRemaining = sizeof(szDebugMessage) - nLength;

    // add user specified debug message
    _vsnprintf(&szDebugMessage[nLength],
               nLengthRemaining,
               pszFormat,
               Args
               );

    // release pointer
    va_end(Args);

    // output message to specified sink
    OutputDebugString(szDebugMessage);
    OutputDebugString("\n");

} // HwsTrace()

#endif // DBG

#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\h245wsrx.cpp ===
/***************************************************************************
 *
 * File: h245wsrx.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245wsrx.cpp  $
 * $Revision:   2.4  $
 * $Modtime:   30 Jan 1997 17:15:58  $
 * $Log:   S:/STURGEON/SRC/H245WS/VCS/h245wsrx.cpv  $
 * 
 *    Rev 2.4   30 Jan 1997 17:17:16   EHOWARDX
 * Fixed bug in trace message - need to do trace before
 * calling shutdown() sent shutdown clears error retrieved
 * by WSAGetLastError().
 * 
 *    Rev 2.3   14 Jan 1997 15:48:04   EHOWARDX
 * Changed TryRecv() and TrySend() to check for WSAECONNRESET and
 * WSAECONNABORT return from recv() and send() and act accordingly.
 * 
 *    Rev 2.2   19 Dec 1996 18:54:54   SBELL1
 * took out tag comments
 * 
 *    Rev 2.1   Dec 13 1996 17:31:00   plantz
 * moved #ifdef _cplusplus to after include files
// 
//    Rev 1.1   13 Dec 1996 12:11:34   SBELL1
// moved #ifdef _cplusplus to after include files
// 
//    Rev 1.0   11 Dec 1996 13:41:52   SBELL1
// Initial revision.
 * 
 *    Rev 1.19   08 Jul 1996 19:27:44   unknown
 * Second experiment to try to fix Q.931 shutdown problem.
 * 
 *    Rev 1.18   01 Jul 1996 16:45:12   EHOWARDX
 * 
 * Moved Call to SocketCloseEvent from TryRecv() to ProcessQueuedRecvs().
 * TryRecv() now returns LINK_RECV_CLOSED to trigger ProcessQueuedRecvs()
 * to call SocketCloseEvent().
 * 
 *    Rev 1.17   May 28 1996 18:14:36   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.16   17 May 1996 16:49:32   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.15   09 May 1996 18:33:16   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.14   29 Apr 1996 16:53:16   EHOWARDX
 * 
 * Added trace statement.
 * 
 *    Rev 1.13   Apr 29 1996 14:04:20   plantz
 * Call NotifyRead instead of ProcessQueuedRecvs.
 * 
 *    Rev 1.12   Apr 29 1996 12:14:06   plantz
 * Change tpkt header to include header size in packet length.
 * Assert that message length does not exceed INT_MAX.
 * .
 * 
 *    Rev 1.11   27 Apr 1996 14:07:32   EHOWARDX
 * Parenthesized return from TryRecv().
 * 
 *    Rev 1.10   Apr 25 1996 21:15:12   plantz
 * Check state of connection before attemting to call recv.
 * 
 *    Rev 1.9   Apr 24 1996 16:39:34   plantz
 * Merge 1.5.1.0 with 1.8 (changes for winsock 1)
 * 
 *    Rev 1.5.1.0   Apr 24 1996 16:23:00   plantz
 * Change to not use overlapped I/O (for winsock 1).
 * 
 *    Rev 1.5   01 Apr 1996 14:20:12   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.4   19 Mar 1996 20:18:16   EHOWARDX
 * 
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:08:32   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:01:58   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:02   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:20:18   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif	// not defined STRICT

#define LINKDLL_EXPORT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <limits.h>
//#include <winsock.h>
#include <windows.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "tstable.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


// If we are not using the Unicode version of the ISR display utility, then redefine
// the __TEXT macro to do nothing.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

extern TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table

#define GetTpktLength(pReq) (((pReq)->req_TpktHeader[2] << 8) + (pReq)->req_TpktHeader[3])

HRESULT Q931Hangup(
    DWORD hQ931Call,
    BYTE bReason);

/*++

Description:
   Start a receive

Arguments:
   pHws              - Pointer to context for "connection"
   pReq              - Pointer to I/O request structure

Return Value:
   SUCCESS                       - Successfully started receive.
   LINK_RECV_ERROR_WOULD_BLOCK   - 
   Winsock error

--*/

static HRESULT
TryRecv(IN PHWSINST pHws, IN char *data, IN int length, IN OUT int *total_bytes_done)
{
   int requested_length = length - *total_bytes_done;
   int recv_result = recv(pHws->hws_Socket, data+*total_bytes_done, requested_length, 0);

   if (recv_result == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         return LINK_RECV_WOULD_BLOCK;

      case WSAECONNABORTED:
      case WSAECONNRESET:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TryRecv: recv() returned %s"),
                   SocketErrorText());
         if (pHws->hws_uState == HWS_CONNECTED)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                      __TEXT("TryRecv: calling shutdown"));
            if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
            {
               HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                        __TEXT("TryRecv: shutdown() returned %s"),
                        SocketErrorText());
            }
            else
            {
                Q931Hangup( pHws->hws_dwH245Instance, CC_REJECT_UNDEFINED_REASON );
            }

            pHws->hws_uState = HWS_CLOSING;
         }
         return MAKE_WINSOCK_ERROR(err);

      default:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TryRecv: recv() returned %s"),
                   SocketErrorText());
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   }

   HWSTRACE1(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("TryRecv: recv returned %d"), recv_result);
   if (recv_result == 0)
   {
      return LINK_RECV_CLOSED;
   }

   *total_bytes_done += recv_result;
   return (recv_result == requested_length) ? NOERROR : LINK_RECV_WOULD_BLOCK;
}


static HRESULT
RecvStart(IN PHWSINST pHws, IN PREQUEST pReq)
{
   HRESULT nResult = NOERROR;

   // Sanity checks
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pReq != NULL);
   HWSASSERT(pReq->req_dwMagic == RECV_REQUEST_MAGIC);
   HWSASSERT(pReq->req_pHws == pHws);

   // Get the header first; if that succeeds get the client data
   if (pReq->req_header_bytes_done < TPKT_HEADER_SIZE)
   {
       nResult = TryRecv(pHws,
                         (char *)pReq->req_TpktHeader,
                         TPKT_HEADER_SIZE,
                         &pReq->req_header_bytes_done);
   }

   if (nResult == NOERROR)
   {
       long int tpkt_length = GetTpktLength(pReq) - TPKT_HEADER_SIZE;
       if (pReq->req_TpktHeader[0] != TPKT_VERSION || tpkt_length <= 0)
       {
          // Invalid header version
          HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                    __TEXT("RecvComplete: bad header version; available data discarded"));
          // Should this be reported to the client??

          // Read and discard all available data
          // The client's buffer is used as a temporary buffer.
          while (recv(pHws->hws_Socket, (char *)pReq->req_client_data, pReq->req_client_length, 0) != SOCKET_ERROR)
              ;

          // Mark the header for this request as unread; it
          // will be read again when additional data is received.
          pReq->req_header_bytes_done = 0;
          nResult = LINK_RECV_ERROR;
       }
       else if (tpkt_length > pReq->req_client_length)
       {
          // Packet too large
          int request_length;
          int result;

          HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                    __TEXT("RecvComplete: packet too large; packet discarded"));
          // Should this be reported to the client??

          // Read and discard the packet
          // The client's buffer is used as a temporary buffer.
          do {
              request_length = pReq->req_client_length;
              if (request_length > tpkt_length)
                  request_length = tpkt_length;
              result = recv(pHws->hws_Socket, (char *)pReq->req_client_data, request_length, 0);
          } while (result != SOCKET_ERROR && (tpkt_length -= result) > 0);

          if (result == SOCKET_ERROR && WSAGetLastError() == WSAEWOULDBLOCK)
          {
              //TODO: packet too large handling
              // Adjust the header so that the rest of this packet will be read, but
              // flag it so that it is known to be an error and will not be returned
              // to the client.
          }
          else
          {
              // Mark the header for this request as unread; it
              // will be read again for the next packet received.
              pReq->req_header_bytes_done = 0;
          }

          nResult = LINK_RECV_ERROR;
       }
       else
       {
           // Normal case
           // The current implementation of TryRecv requires that the requested
           // size fit in a signed int (because that is what Winsock supports
           // in a single recv). This is guaranteed at this point regardless
           // of the originator of the packets, because we don't allow a buffer
           // to be posted that is larger than that (see ASSERT below). If the
           // packet were larger than the buffer, it would have been caught above.
           // If TryRecv is changed to remove the restriction on buffer size and
           // accept a parameter of type long int, this assert may be removed.
           HWSASSERT(tpkt_length <= INT_MAX);
           nResult = TryRecv(pHws,
                             (char *)pReq->req_client_data,
                             (int)tpkt_length,
                             &pReq->req_client_bytes_done);
       }
   }

   return nResult;
} // RecvStart()


void
ProcessQueuedRecvs(IN PHWSINST pHws)
{
   register PREQUEST    pReq;
   register DWORD       dwPhysicalId = pHws->hws_dwPhysicalId;

   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pHws->hws_uState <= HWS_CLOSING);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("ProcessQueuedRecvs"));

   while ((pReq = (PREQUEST) QRemove(pHws->hws_pRecvQueue)) != NULL)
   {
      switch (RecvStart(pHws, pReq))
      {
      case NOERROR:
         // Call Recv callback
         pHws->hws_h245RecvCallback(pHws->hws_dwH245Instance,
                                    LINK_RECV_DATA,
                                    pReq->req_client_data,
                                    pReq->req_client_bytes_done);

         // Free the I/O request structure
         HWSFREE(pReq);

         // Check to see if callback deallocated our instance or state changed

         // Check to see if callback deallocated our instance - this can be done
  	      // by attempting a lock - which will now fail if the entry has been marked
	      // for deletion.  Thus, if the lock succeeds, then just unlock it (since we 
	      // already have a lock on it in a higher level function).

		   if(gpInstanceTable->Lock(dwPhysicalId) == NULL)
			   return;
		   gpInstanceTable->Unlock(dwPhysicalId);
		   if(pHws->hws_uState > HWS_CONNECTED)
		      return;

         break;

      default:
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("ProcessQueuedRecvs: RecvStart() failed"));

         // Fall-through to next case is intentional

      case LINK_RECV_WOULD_BLOCK:
         // The receive would have blocked; we need to requeue the I/O request
         // and wait for a FD_READ network event.
         // If any part of the data was received, the bytes_done field has been updated.
         if (QInsertAtHead(pHws->hws_pRecvQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedRecvs: QInsertAtHead() failed"));
         }
         return;

      case LINK_RECV_CLOSED:
         if (QInsertAtHead(pHws->hws_pRecvQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedRecvs: QInsertAtHead() failed"));
         }
         SocketCloseEvent(pHws);
         return;

      } // switch
   } // while
} // ProcessQueuedRecvs()






/**************************************************************************
** Function    : datalinkReceiveRequest
** Description : Fills header/tail of buffer and posts buffer to H.223
***************************************************************************/
LINKDLL HRESULT datalinkReceiveRequest( DWORD    dwPhysicalId,
                                        PBYTE    pbyDataBuf,
                                        DWORD    dwLength)
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkReceiveRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);

   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkReceiveRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkReceiveRequest: state = %d"), pHws->hws_uState);
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   // Allocate request structure
   pReq = (PREQUEST) HWSMALLOC(sizeof(*pReq));
   if (pReq == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("datalinkReceiveRequest: could not allocate request buffer"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_MEM_FAILURE;
   }

   // The current implementation requires that the size of each message
   // fit in a signed int (because that is what Winsock supports in a
   // single recv). If it is necessary to receive larger messages,
   // TryRecv and RecvStart must be changed to limit the size in each
   // recv call, and loop until all the data is received.
   // This assert could then be removed.
   HWSASSERT(dwLength <= INT_MAX);

   pReq->req_pHws             = pHws;
   pReq->req_header_bytes_done= 0;
   pReq->req_client_data      = pbyDataBuf;
   pReq->req_client_length    = (int)dwLength;
   pReq->req_client_bytes_done= 0;
   pReq->req_dwMagic          = RECV_REQUEST_MAGIC;

   if (QInsert(pHws->hws_pRecvQueue, pReq) == FALSE)
   {
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                __TEXT("datalinkReceiveRequest: QInsert() failed"));
	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_RECV_NOBUFF;
   }

   if (pHws->hws_uState == HWS_CONNECTED)
       NotifyRead(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkReceiveRequest: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // datalinkReceiveRequest()


/**************************************************************************
** Function    : datalinkCancelReceiveRequest
** Description : remove buffer from the request queue.
***************************************************************************/
LINKDLL HRESULT datalinkCancelReceiveRequest( 
    IN  DWORD    dwPhysicalId,
    IN  PBYTE    pbyDataBuf
    )
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkCancelReceiveRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);

   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkCancelReceiveRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkCancelReceiveRequest: state = %d"), pHws->hws_uState);
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   if (pHws->hws_pRecvQueue == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkCancelReceiveRequest: RecvQueue is NULL"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_INSTANCE;
   }
   
   // Remove the request that contains the receive buffer.
   QLock(pHws->hws_pRecvQueue);
   pReq = (PREQUEST) QFirstItem(pHws->hws_pRecvQueue);
   while (pReq != NULL)
   {
       if (pReq->req_client_data == pbyDataBuf)
       {
           QRemoveCurrentItem(pHws->hws_pRecvQueue);
           // Free the I/O request structure
           HWSFREE(pReq);
           break;
       }
       pReq = (PREQUEST) QNextItem(pHws->hws_pRecvQueue);
   }

   QUnlock(pHws->hws_pRecvQueue);

   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
}
#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\h245wstx.cpp ===
/***************************************************************************
 *
 * File: h245wstx.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   h245wstx.cpp  $
 * $Revision:   2.4  $
 * $Modtime:   30 Jan 1997 17:15:58  $
 * $Log:   S:/STURGEON/SRC/H245WS/VCS/h245wstx.cpv  $
 * 
 *    Rev 2.4   30 Jan 1997 17:18:02   EHOWARDX
 * Fixed bug in trace message - need to do trace before
 * calling shutdown() sent shutdown clears error retrieved
 * by WSAGetLastError().
 * 
 *    Rev 2.3   14 Jan 1997 15:49:00   EHOWARDX
 * Changed TryRecv() and TrySend() to check for WSAECONNRESET and
 * WSAECONNABORT return from recv() and send() and act accordingly.
 * 
 *    Rev 2.2   19 Dec 1996 18:55:12   SBELL1
 * took out tag comments
 * 
 *    Rev 2.1   Dec 13 1996 17:33:24   plantz
 * moved #ifdef _cplusplus to after include files
// 
//    Rev 1.1   13 Dec 1996 12:12:02   SBELL1
// moved #ifdef _cplusplus to after include files
// 
//    Rev 1.0   11 Dec 1996 13:41:54   SBELL1
// Initial revision.
 * 
 *    Rev 1.16   May 28 1996 18:14:40   plantz
 * Change error codes to use HRESULT. Propogate Winsock errors where appropriate
 * 
 *    Rev 1.15   17 May 1996 16:49:34   EHOWARDX
 * Shutdown fix.
 * 
 *    Rev 1.14   09 May 1996 18:33:20   EHOWARDX
 * 
 * Changes to build with new LINKAPI.H.
 * 
 *    Rev 1.13   29 Apr 1996 16:53:28   EHOWARDX
 * 
 * Added trace statement.
 * 
 *    Rev 1.12   Apr 29 1996 14:04:38   plantz
 * Call NotifyWrite instead of ProcessQueuedSends.
 * 
 *    Rev 1.11   Apr 29 1996 12:15:04   plantz
 * Change tpkt header to include header size in packet length.
 * Assert that message length does not exceed INT_MAX.
 * .
 * 
 *    Rev 1.10   27 Apr 1996 14:46:24   EHOWARDX
 * Parenthesized TrySend() return.
 * 
 *    Rev 1.9   Apr 24 1996 16:41:30   plantz
 * Merge 1.5.1.0 with 1.8 (changes for winsock 1).
 * 
 *    Rev 1.5.1.0   Apr 24 1996 16:22:22   plantz
 * Change to not use overlapped I/O (for winsock 1).
 * 
 *    Rev 1.5   01 Apr 1996 14:20:44   unknown
 * Shutdown redesign.
 * 
 *    Rev 1.4   19 Mar 1996 20:18:20   EHOWARDX
 * 
 * Redesigned shutdown.
 * 
 *    Rev 1.3   18 Mar 1996 19:08:32   EHOWARDX
 * Fixed shutdown; eliminated TPKT/WSCB dependencies.
 * Define TPKT to put TPKT/WSCB dependencies back in.
 * 
 *    Rev 1.2   14 Mar 1996 17:02:02   EHOWARDX
 * 
 * NT4.0 testing; got rid of HwsAssert(); got rid of TPKT/WSCB.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:30   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:20:06   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif	// not defined STRICT

#define LINKDLL_EXPORT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <limits.h>
//#include <winsock.h>
#include <windows.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "tstable.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


// If we are using not using the Unicode version of the IRS display utility, then
// redefine the __TEXT macro to do nothing.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

extern TSTable<HWSINST>* gpInstanceTable;	// global ptr to the instance table

static void SetupTPKTHeader(BYTE *tpkt_header, DWORD length);

/*++

Description:
   Attempt to send

Arguments:
   pHws              - Pointer to context for "connection"
   pReq              - Pointer to I/O request structure

Return Value:
   SUCCESS                       - Successfully started send.
   LINK_SEND_ERROR_WOULD_BLOCK   - 
   LINK_SEND_ERROR_CLOSED        - The socket was gracefully closed.
   LINK_SEND_ERROR_ERROR         - Error receiving data.

--*/

static HRESULT
TrySend(IN PHWSINST pHws, IN const char *data, IN int length, IN OUT int *total_bytes_sent)
{
   int requested_length = length - *total_bytes_sent;
   int send_result = send(pHws->hws_Socket, data+*total_bytes_sent, requested_length, 0);

   if (send_result == SOCKET_ERROR)
   {
      int err = WSAGetLastError();
      switch (err)
      {
      case WSAEWOULDBLOCK:
         return LINK_SEND_WOULD_BLOCK;

      case WSAECONNABORTED:
      case WSAECONNRESET:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TrySend: send() returned %s"),
                   SocketErrorText());
         if (pHws->hws_uState == HWS_CONNECTED)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE,
                      __TEXT("TrySend: calling shutdown"));
            if (shutdown(pHws->hws_Socket, 1) == SOCKET_ERROR)
            {
               HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                        __TEXT("TrySend: shutdown() returned %s"),
                        SocketErrorText());
            }
            pHws->hws_uState = HWS_CLOSING;
         }
         return MAKE_WINSOCK_ERROR(err);

      default:
         HWSTRACE1(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("TrySend: send() returned %s"),
                   SocketErrorText());
         return MAKE_WINSOCK_ERROR(err);
      } // switch
   }

   HWSTRACE1(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("TrySend: send returned %d"), send_result);
   *total_bytes_sent += send_result;
   return (send_result == requested_length) ? NOERROR : LINK_SEND_WOULD_BLOCK;
}


static HRESULT
SendStart(IN PHWSINST pHws, IN PREQUEST pReq)
{
   HRESULT nResult = NOERROR;

   // Sanity checks
   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pReq != NULL);
   HWSASSERT(pReq->req_dwMagic == SEND_REQUEST_MAGIC);
   HWSASSERT(pReq->req_pHws == pHws);

   // Send the header first; if that succeeds send the client data
   if (pReq->req_header_bytes_done < TPKT_HEADER_SIZE)
   {
       nResult = TrySend(pHws,
                         (const char *)pReq->req_TpktHeader,
                         TPKT_HEADER_SIZE,
                         &pReq->req_header_bytes_done);
   }

   if (nResult == NOERROR)
   {
       nResult = TrySend(pHws,
                         (const char *)pReq->req_client_data,
                         pReq->req_client_length,
                         &pReq->req_client_bytes_done);
   }

   return nResult;
} // SendStart()


void
ProcessQueuedSends(IN PHWSINST pHws)
{
   register PREQUEST    pReq;
   register DWORD       dwPhysicalId = pHws->hws_dwPhysicalId;

   HWSASSERT(pHws != NULL);
   HWSASSERT(pHws->hws_dwMagic == HWSINST_MAGIC);
   HWSASSERT(pHws->hws_uState <= HWS_CONNECTED);
   HWSTRACE0(pHws->hws_dwPhysicalId, HWS_TRACE, __TEXT("ProcessQueuedSends"));

   while ((pReq = (PREQUEST)QRemove(pHws->hws_pSendQueue)) != NULL)
   {
      switch (SendStart(pHws, pReq))
      {
      case NOERROR:
         // Call Send callback
         pHws->hws_h245SendCallback(pHws->hws_dwH245Instance,
                                    LINK_SEND_COMPLETE,
                                    pReq->req_client_data,
                                    pReq->req_client_bytes_done);

         // Free the I/O request structure
         HWSFREE(pReq);

         // Check to see if callback deallocated our instance or state changed
		   if(gpInstanceTable->Lock(dwPhysicalId) == NULL)
			   return;
		   gpInstanceTable->Unlock(dwPhysicalId);
		   if(pHws->hws_uState > HWS_CONNECTED)
		      return;

         break;

      default:
         HWSTRACE0(pHws->hws_dwPhysicalId, HWS_WARNING,
                   __TEXT("ProcessQueuedSends: SendStart() failed"));

         // Fall-through to next case is intentional

      case LINK_SEND_WOULD_BLOCK:
         // The send would have blocked; we need to requeue the I/O request
         // and wait for a FD_WRITE network event.
         // If any part of the data was sent, the bytes_done field has been updated.
         if (QInsertAtHead(pHws->hws_pSendQueue, pReq) == FALSE)
         {
            HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                      __TEXT("ProcessQueuedSends: QInsertAtHead() failed"));
         }
         return;

      } // switch
   } // while
} // ProcessQueuedSends()



/**************************************************************************
** Function    : datalinkSendRequest
** Description : Fills header/tail of buffer and posts buffer to H.223
***************************************************************************/
LINKDLL HRESULT datalinkSendRequest( DWORD    dwPhysicalId,
                                   PBYTE    pbyDataBuf,
                                   DWORD    dwLength)
{
   register PHWSINST    pHws;
   register PREQUEST    pReq;

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkSendRequest"));

   pHws = gpInstanceTable->Lock(dwPhysicalId);
   if (pHws == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkSendRequest: dwPhysicalId not found"));
      return LINK_INVALID_INSTANCE;
   }

   if (pHws->hws_uState > HWS_CONNECTED)
   {
      HWSTRACE1(dwPhysicalId, HWS_ERROR,
                __TEXT("datalinkSendRequest: state = %d"), pHws->hws_uState);
	  gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_INVALID_STATE;
   }

   // Allocate request structure
   pReq = (PREQUEST) HWSMALLOC(sizeof(*pReq));
   if (pReq == NULL)
   {
      HWSTRACE0(dwPhysicalId, HWS_WARNING,
                __TEXT("datalinkSendRequest: could not allocate request buffer"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_MEM_FAILURE;
   }

   // The current implementation requires that the size of each message
   // fit in a signed int (because that is what Winsock supports in a
   // single send). If it is necessary to send larger messages,
   // TrySend must be changed to limit the size in each send call, and
   // loop until all the data is sent. This assert could then be removed.
   HWSASSERT(dwLength <= INT_MAX);

   pReq->req_pHws             = pHws;
   pReq->req_client_data      = pbyDataBuf;
   pReq->req_client_length    = (int)dwLength;
   pReq->req_client_bytes_done= 0;
   pReq->req_dwMagic          = SEND_REQUEST_MAGIC;

   // Format TPKT header
   SetupTPKTHeader(pReq->req_TpktHeader, dwLength);
   pReq->req_header_bytes_done = 0;

   if (QInsert(pHws->hws_pSendQueue, pReq) == FALSE)
   {
      HWSTRACE0(pHws->hws_dwPhysicalId, HWS_CRITICAL,
                __TEXT("datalinkSendRequest: QInsert() failed"));
	   gpInstanceTable->Unlock(dwPhysicalId);
      return LINK_SEND_NOBUFF;
   }

   if (pHws->hws_uState == HWS_CONNECTED)
       NotifyWrite(pHws);

   HWSTRACE0(dwPhysicalId, HWS_TRACE, __TEXT("datalinkSendRequest: succeeded"));
   gpInstanceTable->Unlock(dwPhysicalId);
   return NOERROR;
} // datalinkSendRequest

static void SetupTPKTHeader(BYTE *tpkt_header, DWORD length)
{
    length += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    HWSASSERT(length < (1L << 16));

    tpkt_header[0] = TPKT_VERSION;
    tpkt_header[1] = 0;
    tpkt_header[2] = (BYTE)(length >> 8);
    tpkt_header[3] = (BYTE)length;
}


#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\hwsmain.c ===
/***************************************************************************
 *
 * File: hwsmain.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   hwsmain.c  $
 * $Revision:   1.8  $
 * $Modtime:   03 Feb 1997 19:20:32  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\hwsmain.c_v  $
 * 
 *    Rev 1.8   03 Feb 1997 19:21:18   SBELL1
 * removed DATE and TIME from loading of DLL for H.323 proxy compatability.
 * 
 *    Rev 1.7   19 Dec 1996 18:56:46   SBELL1
 * Moved Initialize to linkLayerInit
 * 
 *    Rev 1.6   13 Dec 1996 12:13:02   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.5   11 Dec 1996 13:44:44   SBELL1
 * Put in UNICODE tracing stuff.
 * 
 *    Rev 1.4   Oct 01 1996 14:30:26   EHOWARDX
 * Moved Initialize() and Unitialize() calls to DllMain().
 * 
 *    Rev 1.3   Oct 01 1996 14:05:04   EHOWARDX
 * Deleted trace of default case (DLL_THREAD_ATTACH/DLL_THREAD_DETACH).
 * 
 *    Rev 1.2   03 Jun 1996 10:46:18   EHOWARDX
 * Added trace of DLL loading/unloading.
 * 
 *    Rev 1.1   Apr 24 1996 16:15:58   plantz
 * Removed include winsock2.h
 * .
 * 
 *    Rev 1.0   08 Mar 1996 20:21:22   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif	// not defined STRICT

#pragma warning ( disable : 4115 4201 4214 4514 )
#undef _WIN32_WINNT	// override bogus platform definition in our common build environment

#include <windows.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

void Initialize();
void Uninitialize();

//---------------------------------------------------------------------------
// Function: dllmain
//
// Description: DLL entry/exit points.
//
// Inputs:
//    hInstDll    : DLL instance.
//    fdwReason   : Reason the main function is called.
//    lpReserved  : Reserved.
//
// Return Value:
//    TRUE        : OK
//    FALSE       : Error, DLL won't load
//---------------------------------------------------------------------------

#pragma warning ( disable : 4100 )

// If we are not using the Unicode version of the ISR display utility, then undef the
// __TEXT macro.

#ifndef UNICODE_TRACE
#undef  __TEXT
#define __TEXT(x) x
#endif

BOOL WINAPI H245WSDllMain (HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpvReserved)
{
  switch (fdwReason)
  {
  case DLL_PROCESS_ATTACH:
    HWSTRACE0(0, HWS_NOTIFY, __TEXT("***** Loading H245WS DLL"));
    break;

  case DLL_PROCESS_DETACH:
    HWSTRACE0(0, HWS_NOTIFY, __TEXT("***** Unloading H245WS DLL"));
    Uninitialize();
    break;

  }
  return TRUE;
}

#pragma warning ( default : 4100 )

#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\apimsm.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/apimsm.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.11  $
 *	$Date:   Apr 15 1996 08:52:10  $
 *	$Author:   RKUHN  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		Media Service Manager "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with MSM. Any EXE or DLL which interacts with
 *		MSM will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef APIMSM_H
#define APIMSM_H

#include <apierror.h>

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllImport
#define DllImport	__declspec( dllimport )
#endif  // DllImport


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport



// Product Identifier
//
#define MAX_PRODUCTID_LENGTH	50
typedef char PRODUCTID[MAX_PRODUCTID_LENGTH], *LPPRODUCTID;


// Service identifier
//
#define MAX_SERVICEID_LENGTH	50
typedef char SERVICEID[MAX_SERVICEID_LENGTH], *LPSERVICEID;


// Registry defines
//
#define MSM_REG_SERVICEID		"MediaServiceManager"
#define MSM_REG_RMSPATH			"RMSPath"
#define MSM_REG_SERVICES		"Services"


// Defines for handle returned by MSM
//
typedef DWORD	HSESSION,	*LPHSESSION;
typedef DWORD	HSERVICE,	*LPHSERVICE;
typedef DWORD	HPORT,		*LPHPORT;
typedef DWORD	HLINK,		*LPHLINK;
typedef DWORD	HSYNC,		*LPHSYNC;


// Defines for cookies passed in by application
//
typedef DWORD	ERRORCOOKIE,	*LPERRORCOOKIE;
typedef DWORD	SERVICECOOKIE,	*LPSERVICECOOKIE;
typedef DWORD	PORTCOOKIE,		*LPPORTCOOKIE;



// Typedef for application callbacks made by MSM
//
typedef void		(CALLBACK *MSM_ERRORCALLBACK)	(ERRORCOOKIE, HRESULT);
typedef HRESULT		(CALLBACK *MSM_SERVICECALLBACK)	(HSERVICE, SERVICECOOKIE, WPARAM, LPARAM, LPARAM);
typedef HRESULT		(CALLBACK *MSM_PORTCALLBACK)	(HSERVICE, HPORT, PORTCOOKIE, WPARAM, LPARAM, LPARAM);


// Typedefs for MSM application entry points to ensure stricter checking
// when functions are called via pointers
//
typedef HRESULT		(*MSM_OPENSESSION)		(LPPRODUCTID, MSM_ERRORCALLBACK, DWORD, LPHSESSION);
typedef HRESULT		(*MSM_CLOSESESSION)		(HSESSION);
typedef HRESULT		(*MSM_OPENSERVICE)		(HSESSION, LPSERVICEID, MSM_SERVICECALLBACK, SERVICECOOKIE, LPARAM, LPARAM, LPHSERVICE);
typedef HRESULT		(*MSM_CLOSESERVICE)		(HSERVICE);
typedef HRESULT		(*MSM_SENDSERVICECMD)	(HSERVICE, HPORT, WORD, LPARAM, LPARAM);
typedef HRESULT		(*MSM_OPENPORT)			(HSERVICE, MSM_PORTCALLBACK, PORTCOOKIE, LPARAM, LPARAM, LPHPORT);
typedef HRESULT		(*MSM_CLOSEPORT)		(HPORT);
typedef HRESULT		(*MSM_LINKPORTS)		(HPORT, HPORT, LPHLINK);
typedef HRESULT		(*MSM_UNLINKPORTS)		(HLINK);
typedef HRESULT		(*MSM_SYNCPORTS)		(HPORT, HPORT, LPHSYNC);
typedef HRESULT		(*MSM_UNSYNCPORTS)		(HSYNC);


typedef struct _MSMAPI
{
	MSM_OPENSESSION		MSM_OpenSession;
	MSM_CLOSESESSION	MSM_CloseSession;
	MSM_OPENSERVICE		MSM_OpenService;
	MSM_CLOSESERVICE	MSM_CloseService;
	MSM_SENDSERVICECMD	MSM_SendServiceCmd;
	MSM_OPENPORT		MSM_OpenPort;
	MSM_CLOSEPORT		MSM_ClosePort;
	MSM_LINKPORTS		MSM_LinkPorts;
	MSM_UNLINKPORTS		MSM_UnlinkPorts;
	MSM_SYNCPORTS		MSM_SyncPorts;
	MSM_UNSYNCPORTS		MSM_UnsyncPorts;
}
MSMAPI, *LPMSMAPI;

// ERROR CALLBACK
//

extern void CALLBACK MSM_ErrorCallback
(
	ERRORCOOKIE			dAppErrorCookie,// Application error cookie
	HRESULT				hResult			// Error information.
);


// SESSION CONTROL
//
extern DllExport HRESULT MSM_OpenSession
(
	LPPRODUCTID			pszAppId,		// String identifies app's registry section.
	MSM_ERRORCALLBACK	pErrorCallback,	// Pointer to callback function for errors
	ERRORCOOKIE			dAppErrorCookie,// Application error cookie returned on aync errors
	LPHSESSION			phSession		// Pointer to location to store the session handle
);


extern DllExport HRESULT MSM_CloseSession
(
	HSESSION		hSession		// Handle of session to be closed.
);


// SERVICE CONTROL
//

extern HRESULT CALLBACK MSM_ServiceCallback
(
	HSERVICE		hService,		// Handle of service to be closed.
	SERVICECOOKIE	dServiceCookie, // Application service cookie
	WPARAM			wParam,			// Pass through word param
	LPARAM			lParamIn,		// Pass through long param in
	LPARAM			lParamOut		// Pass through long param out
);


extern DllExport HRESULT MSM_OpenService
(
	HSESSION			hSession,		// MSM session-instance handle.
	LPSERVICEID			pszServiceId,	// Unique service-type identifier.
	MSM_SERVICECALLBACK	pServiceCallback,// Application callback for service
	SERVICECOOKIE		dAppServiceCookie,// Application service cookie
	LPARAM				lParamIn,		// Pass through long param in
	LPARAM				lParamOut,		// Pass through long param out
	LPHSERVICE			phService		// Pointer to location to store the service handle
);

extern DllExport HRESULT MSM_CloseService
(
	HSERVICE		hService		// Handle of service to be closed.
);

extern DllExport HRESULT MSM_SendServiceCmd
(
	HSERVICE		hService,		// Service-instance handle.
	HPORT			hPort,			// Port-instance handle.
	WORD			wCommand,		// Service-specific command.
	LPARAM			lParamIn,		// Pass through long param in
	LPARAM			lParamOut		// Pass through long param out
);

// PORT CONTROL
//

extern HRESULT CALLBACK MSM_PortCallback
(
	HSERVICE		hService,		// Handle of service.
	HPORT			hPort,			// Handle of port.
	PORTCOOKIE		dAppPortCookie, // Application port cookie
	WPARAM			wParam,			// Pass through word param
	LPARAM			lParamIn,		// Pass through long param in
	LPARAM			lParamOut		// Pass through long param out
);

extern DllExport HRESULT MSM_OpenPort
(
	HSERVICE			hService,		// Service-instance handle.
	MSM_PORTCALLBACK	pPortCallback,	// Application callback for port
	PORTCOOKIE			dAppPortCookie, // Application port cookie
	LPARAM				lParamIn,		// Pass through long param in
	LPARAM				lParamOut,		// Pass through long param out
	LPHPORT				phPort			// Pointer to location to store the port handle
);

extern DllExport HRESULT MSM_ClosePort
(
	HPORT			hPort			// Handle of port to be closed.
);


// LINK CONTROL
//
extern DllExport HRESULT MSM_LinkPorts
(
	HPORT			hSrcPort,		// Source port of linked stream.
	HPORT			hSnkPort,		// Sink port of linked stream.
	LPHLINK			phLink			// Pointer to location to store the link handle
);

extern DllExport HRESULT MSM_UnlinkPorts
(
	HLINK			hLink			// Handle of link to be disabled.
);


// SYNC CONTROL
//
extern DllExport HRESULT MSM_SyncPorts
(
	HPORT			hTargetPort,	// Target port to sync with
	HPORT			hSyncPort,		// Syncbc port to be sync'ed
	LPHSYNC			phSync			// Pointer to location to store the sync handle
);

extern DllExport HRESULT MSM_UnsyncPorts
(
	HSYNC			hSync			// Handle of sync to be disabled.
);


#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // APIMSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\queue.h ===
/***********************************************************************
 *  INTEL Corporation Prorietary Information                           *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation.                          *
 ***********************************************************************/
/*-*-------------------------------------------------------------------------

   File Name:
      queue.h

   Summary:
      Queue management header file.

   Prerequisites:
      windows.h

   Hide:
   $Header:   S:\sturgeon\src\h245ws\vcs\queue.h_v   1.5   13 Dec 1996 12:13:58   SBELL1  $

-------------------------------------------------------------------------*-*/

#ifndef QUEUE_H
#define QUEUE_H

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

#define NORMAL          0
#define ABNORMAL        1

#define MAX_QUEUE_SIZE  10
#define Q_NULL          -1

typedef struct _QUEUE
{

    LPVOID              apObjects[MAX_QUEUE_SIZE];
    int                 nHead;
    int                 nTail;
    int                 nCursor;
    CRITICAL_SECTION    CriticalSection;

} QUEUE, *PQUEUE;


PQUEUE  QCreate         (void);
void    QFree           (PQUEUE pQueue);
BOOL    QInsert         (PQUEUE pQueue, LPVOID pObject);
BOOL    QInsertAtHead   (PQUEUE pQueue, LPVOID pObject);
LPVOID  QRemove         (PQUEUE pQueue);
BOOL    IsQEmpty        (PQUEUE pQueue);

// Iterationg methods.
void    QLock           (PQUEUE pQueue);
void    QUnlock         (PQUEUE pQueue);
LPVOID  QFirstItem      (PQUEUE pQueue);
LPVOID  QNextItem       (PQUEUE pQueue);
LPVOID  QRemoveCurrentItem(PQUEUE pQueue);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  /* QUEUE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\resource.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation.                          *
 ***********************************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by h245ws.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245ws\queue.c ===
/***************************************************************************
 *
 * File: queue.c
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   queue.c  $
 * $Revision:   1.8  $
 * $Modtime:   13 Dec 1996 11:48:16  $
 * $Log:   S:\sturgeon\src\h245ws\vcs\queue.c_v  $
 * 
 *    Rev 1.8   13 Dec 1996 12:13:12   SBELL1
 * moved ifdef _cplusplus to after includes
 * 
 *    Rev 1.7   May 28 1996 10:39:00   plantz
 * Change QFree to not free objects on the queue; instead it insists that
 * the queue be empty.
 * 
 *    Rev 1.6   21 May 1996 16:21:36   EHOWARDX
 * Added DeleteCriticalSection to QFree().
 * 
 *    Rev 1.5   Apr 24 1996 16:18:58   plantz
 * Removed include winsock2.h and incommon.h
 * 
 *    Rev 1.3.1.0   Apr 24 1996 16:16:42   plantz
 * Removed include winsock2.h and callcont.h
 * 
 *    Rev 1.3   01 Apr 1996 14:53:28   EHOWARDX
 * Changed pQUEUE to PQUEUE.
 * 
 *    Rev 1.1   09 Mar 1996 21:12:34   EHOWARDX
 * Fixes as result of testing.
 * 
 *    Rev 1.0   08 Mar 1996 20:22:38   unknown
 * Initial revision.
 *
 ***************************************************************************/

#ifndef STRICT
#define STRICT
#endif	// not defined STRICT

#pragma warning ( disable : 4115 4201 4214 4514 )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include "queue.h"
#include "linkapi.h"
#include "h245ws.h"
#include "provider.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)



/*-*-------------------------------------------------------------------------

   Function Name:
      QCreate

   Syntax:
      PQUEUE QCreate(void);

   Parameters:
      None.

   Summary:
      Allocates and initializes a new queue.

   Returns:
      NULL        - Allocation of memory for new queue failed.
      Otherwise   - Address of new queue created.

-------------------------------------------------------------------------*-*/

PQUEUE QCreate(void)
{
   register PQUEUE     pQueue;         /* pointer to the new queue         */

   /* Allocate a new queue */
   pQueue = (PQUEUE)HWSMALLOC(sizeof(QUEUE));
   if (pQueue != NULL)
   {
      /* Initialize the new queue */
      pQueue->nHead = pQueue->nTail = Q_NULL;

      __try {

          // initialize lock (and allocate event immediately)
          InitializeCriticalSectionAndSpinCount(&pQueue->CriticalSection,H323_SPIN_COUNT);

      } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH
                  ) {

          // free queue
          HWSFREE(pQueue);

          // re-initialize
          pQueue = NULL;
      }
   }

   return pQueue;
} /* QCreate */


void QLock(PQUEUE pQueue)
{
   EnterCriticalSection(&pQueue->CriticalSection);
}

void QUnlock(PQUEUE pQueue)
{
   LeaveCriticalSection(&pQueue->CriticalSection);
}


LPVOID QFirstItem(PQUEUE pQueue)
{
    HWSASSERT(pQueue != NULL);

    if (pQueue->nHead == Q_NULL)
    {
      /* If the queue is empty, we will return NULL */
      return NULL;
    }

    pQueue->nCursor = pQueue->nHead;

    return pQueue->apObjects[pQueue->nHead];

}

LPVOID QNextItem(PQUEUE pQueue)
{
    pQueue->nCursor = (pQueue->nCursor + 1) % MAX_QUEUE_SIZE;
    
    if (pQueue->nCursor == ((pQueue->nTail + 1) % MAX_QUEUE_SIZE))
    {
        return NULL;
    }

    return pQueue->apObjects[pQueue->nCursor];
} /* QNextItem */

LPVOID QRemoveCurrentItem(PQUEUE pQueue)
{
    register LPVOID     pElem;         /* pointer to the new queue         */
    
    HWSASSERT(pQueue->nHead != Q_NULL);

    pElem = pQueue->apObjects[pQueue->nCursor];

    // copy the head element to the current slot and remove the first element.
    pQueue->apObjects[pQueue->nCursor] = pQueue->apObjects[pQueue->nHead];
    pQueue->apObjects[pQueue->nHead] = NULL;

    /* Check to see if we've just emptied the queue; if so, set */
    /* the nHead and nTail indices to Q_NULL.  If not, set the nHead */
    /* index to the right value. */
    if (pQueue->nHead == pQueue->nTail)
    {
        pQueue->nHead = pQueue->nTail = Q_NULL;
    }
    else
    {
        pQueue->nHead = (pQueue->nHead + 1) % MAX_QUEUE_SIZE;
    }

    return pElem;

} /* QRemoveCurrentItem */

/*-*-------------------------------------------------------------------------

   Function Name:
      QFree

   Syntax:
      void QFree(PQUEUE pQueue);

   Parameters:
      pQueue      -pointer to the queue to free

   Summary:
      Deallocates a queue that was allocated by QCreate.

-------------------------------------------------------------------------*-*/

void QFree(PQUEUE pQueue)
{
   /* The queue must be empty before it is freed. */
   HWSASSERT(pQueue->nHead == Q_NULL);

   /* Free the queue. */
   DeleteCriticalSection(&pQueue->CriticalSection);
   HWSFREE(pQueue);
} /* QFree */

/*
 *  NAME
 *      QRemove - remove object from head of queue
 *
 *  ARGUMENTS
 *      pQueue      Pointer to queue
 *
 *  RETURN VALUE
 *      Pointer to object dequeued or NULL of queue empty
 */

/*-*-------------------------------------------------------------------------

   Function Name:
      QRemove

   Syntax:
      LPVOID QRemove(PQUEUE pQueue);

   Parameters:
      pQueue      - Pointer to queue.

   Summary:
      Removes and returns object from head of queue.

   Returns:
      NULL        - Queue was empty.
      Otherwise   - Address of object dequeued.

-------------------------------------------------------------------------*-*/

LPVOID QRemove(PQUEUE pQueue)
{
   register LPVOID     pObject;           /* pointer to the object to remove  */

   EnterCriticalSection(&pQueue->CriticalSection);

   if (pQueue->nHead == Q_NULL)
   {
      /* If the queue is empty, we will return NULL */
      pObject = NULL;
   }
   else
   {
      /* Get the pointer, NULL it in the apObjects array. */
      pObject = pQueue->apObjects[pQueue->nHead];
      pQueue->apObjects[pQueue->nHead] = NULL;

      /* Check to see if we've just emptied the queue; if so, set */
      /* the nHead and nTail indices to Q_NULL.  If not, set the nHead */
      /* index to the right value. */
      if (pQueue->nHead == pQueue->nTail)
      {
         pQueue->nHead = pQueue->nTail = Q_NULL;
      }
      else
      {
         pQueue->nHead = (pQueue->nHead + 1) % MAX_QUEUE_SIZE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return pObject;
} /* QRemove */



/*-*-------------------------------------------------------------------------

   Function Name:
      QInsert

   Syntax:
      BOOL QInsert(PQUEUE pQueue, LPVOID pObject);

   Parameters:
      pQueue      - Pointer to queue to insert object into.
      pObject     - Pointer to object to insert into queue.

   Summary:
      Inserts an object at tail of queue.

   Returns:
      TRUE        - Object successfully added to queue.
      FALSE       - Queue full; object could not be added.

-------------------------------------------------------------------------*-*/

BOOL QInsert(PQUEUE pQueue, LPVOID pObject)
{
   register int        iTemp;

   EnterCriticalSection(&pQueue->CriticalSection);

   /* If the queue is full, set the return value to FALSE and do */
   /* nothing; if not, update the indices appropriately and set the */
   /* return value to TRUE.  */
   if (pQueue->nHead == Q_NULL)
   {
      /* Queue is empty */
      pQueue->apObjects[0] = pObject;
      pQueue->nHead = pQueue->nTail = 0;
      iTemp = TRUE;
   }
   else
   {
      iTemp = (pQueue->nTail + 1) % MAX_QUEUE_SIZE;
      if (iTemp == pQueue->nHead)
      {
         /* Queue is full */
         iTemp = FALSE;
      }
      else
      {
         pQueue->apObjects[iTemp] = pObject;
         pQueue->nTail = iTemp;
         iTemp = TRUE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return (BOOL) iTemp;
}



/*-*-------------------------------------------------------------------------

   Function Name:
      QInsertAtHead

   Syntax:
      BOOL QInsertAtHead(PQUEUE pQueue, LPVOID pObject);

   Parameters:
      pQueue      - Pointer to queue to insert object into.
      pObject     - Pointer to object to insert into queue.

   Summary:
      Inserts an object at head of queue.

   Returns:
      TRUE        - Object successfully added to queue.
      FALSE       - Queue full; object could not be added.

-------------------------------------------------------------------------*-*/

BOOL QInsertAtHead(PQUEUE pQueue, LPVOID pObject)
{
   register int        iTemp;

   EnterCriticalSection(&pQueue->CriticalSection);

   if (pQueue->nHead == Q_NULL)
   {
      /* Queue is empty */
      pQueue->apObjects[0] = pObject;
      pQueue->nHead = pQueue->nTail = 0;
      iTemp = TRUE;
   }
   else
   {
      iTemp = (pQueue->nHead + (MAX_QUEUE_SIZE - 1)) % MAX_QUEUE_SIZE;
      if (iTemp == pQueue->nTail)
      {
         /* Queue is full */
         iTemp = FALSE;
      }
      else
      {
         pQueue->apObjects[iTemp] = pObject;
         pQueue->nHead = iTemp;
         iTemp = TRUE;
      }
   }

   LeaveCriticalSection(&pQueue->CriticalSection);
   return (BOOL) iTemp;
} /* QInsertAtHead */



/*-*-------------------------------------------------------------------------

   Function Name:
      IsQEmpty

   Syntax:
      BOOL IsQEmpty(PQUEUE pQueue);

   Parameters:
      pQueue      - Pointer to queue to check.

   Summary:
      Checks if a queue is empty.

   Returns:
      TRUE        - Queue is empty.
      FALSE       - Queue contains at least one object.

-------------------------------------------------------------------------*-*/

BOOL IsQEmpty(PQUEUE pQueue)
{
   return (pQueue->nHead == Q_NULL ? TRUE : FALSE);
} /* IsQEmpty */



#if defined(__cplusplus)
}
#endif  // (__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\cpls.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __CPLS_H
#define __CPLS_H

#include <limits.h>

#ifdef WIN32
	#include <windows.h>
	#include <windowsx.h> 
	#include "port32.h"
#endif

#ifdef _WINDOWS
	#ifndef _MSWINDOWS_
		#define _MSWINDOWS_
	#endif
#endif

typedef int HLOG;                          

#ifndef FALSE
	#define FALSE   0
#endif

#ifndef TRUE
	#define TRUE    1
#endif
#ifdef WIN32
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT __declspec(dllexport)
		#define CPLS_EXPORT __declspec(dllexport)
	#else
		#define CPLS_FAREXPORT __declspec(dllimport)
		#define CPLS_EXPORT __declspec(dllimport)
	#endif
	#ifndef EXPORT
		#define EXPORT
	#endif	// EXPORT
#elif _MSWINDOWS_
	#ifndef CALLBACK
		#define CALLBACK _far _pascal
	#endif
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT _far _export _pascal
		#define CPLS_EXPORT _export
	#else
		#define CPLS_FAREXPORT _far _pascal
		#define CPLS_EXPORT
	#endif
	#ifndef EXPORT
		#define EXPORT _export
	#endif	// EXPORT
	#ifndef FAR
		#define FAR _far
	#endif
#else    
	#ifndef CALLBACK
		#define CALLBACK      
	#endif
	#define CPLS_FAREXPORT
	#ifndef EXPORT
		#define EXPORT  
	#endif
	#ifndef FAR
		#define FAR
	#endif
#endif  // _MSWINDOWS_  


typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef const char FAR* CPLProtocol;
typedef int CPLProtocolID;

#define CONFIG_FILENAME "CPLS.INI"    // internal use only

// Pre-defined event and event category constants.
//
#define String_Event USHRT_MAX
#define Binary_Event USHRT_MAX-1

#define String_Category USHRT_MAX
#define Binary_Category USHRT_MAX-1

#ifdef __cplusplus      
	class CProtocolLog;
	class CProtocolEvent;
	typedef CProtocolEvent FAR* (CALLBACK *CPLEventGenesisProc)( 
															BYTE FAR* pObject,              // in
															CProtocolLog FAR* pSourceLog,   // in
															BOOL bCopyObject );             // in
extern "C"{

// This first one is only for C++ clients...
void CPLS_FAREXPORT CPLRegisterEventGenesisProc( CPLProtocolID ProtocolID, CPLEventGenesisProc pfnGenesisProc );

#endif  // __cplusplus

// Possible file mode values for CPLOpen().
//
#define CPLS_CREATE 0		// Will overwrite an existing file.
#define CPLS_APPEND 1		// Will append to an existing file, or create a new one.

/////////////////////////////////////////////////////////////////////////////
// 					PROTOCOL LOGGING FUNCTIONS
//
// Here is the sequence of functions to call for use of a protocol logger:
//		1) CPLInitialize() or CPLINTInitialize()
//		2) CPLOpen()
//		3) CPLOutput*() or CPLINTOutput*() -- repeat as necessary
//		4) CPLClose()
//		5) CPLUninitialize()
//
// CPLInitialize() - Creates a protocol logger.
// CPLINTInitialize() - The version of CPLInitialize() which must be called
//		by clients which will be calling the CPLINTOuptut*() functions within
//		interrupt context.  CPLINTInitialize may not be called within
//		interrupt context.
// CPLUninitialize() - Releases a protocol logger.  This must be called for
//		every initialized logger before shutdown in order to free associated
//		memory.
// CPLOpen() - Associates a protocol logger with a file (output stream).
// CPLClose() - Releases a logger's usage of a stream.  This function does
//		not block.  A "close" event is placed on the event queue of the
//		stream.  Release of the stream occurs when this "close" event is
//		serviced.
// CPLOutputDebug() - 
// CPLINTOutputDebug() - The version of CPLOutputDebug() safely callable
//		within interrupt context.
// CPLOutputAscii() - 
// CPLINTOutputAscii() - The version of CPLOutputAscii() safely callable
//		within interrupt context.
// CPLOutput() - 
// CPLINTOutput() - The version of CPLOutput() safely callable
//		within interrupt context.
// CPLFlush() - Flushes all events to the stream of the specified logger.
//		Blocks until the flush is complete.
// CPLINTFlush() -  The version of CPLFlush() safely callable within
//		interrupt context.  This version does not block.  A "flush" message
//		is sent to CPLS.  The flush occurs when this flush message is
//		serviced.
// CPLFlushAndClose() -
// CPLEnable() - Enables or disables protocol logging at runtime.
// CPLEnableAsync() - Sets synchronous or asynchronous logging output mode.
//		CURRENTLY NOT SUPPORTED.
// CPLLogAscii() - 
// CPLINTLogAscii() - The version of CPLLogAscii() safely callable
//		within interrupt context.
//
// Only these functions may be called from within interrupt context:
//		CPLINTOutputDebug()
//		CPLINTOutputAscii()
//		CPLINTOutput()
//		CPLINTFlush()
//		CPLEnable()
//		CPLINTLogAscii()
/////////////////////////////////////////////////////////////////////////////
CPLProtocolID CPLS_FAREXPORT CPLInitialize( CPLProtocol Protocol );
CPLProtocolID CPLS_FAREXPORT CPLINTInitialize( CPLProtocol Protocol );

int  CPLS_FAREXPORT CPLUninitialize( HLOG hlog );

HLOG CPLS_FAREXPORT CPLOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
HLOG CPLS_FAREXPORT CPLINTOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
int  CPLS_FAREXPORT CPLClose( HLOG hLog );

int  CPLS_FAREXPORT CPLOutputDebug( HLOG hLog, 
							const char FAR* szString );
int  CPLS_FAREXPORT CPLINTOutputDebug( HLOG hLog, 
							const char FAR* szString );

int  CPLS_FAREXPORT CPLOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );

int  CPLS_FAREXPORT CPLOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );

int  CPLS_FAREXPORT CPLFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLINTFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLFlushAndClose( HLOG hLog );

void CPLS_FAREXPORT CPLEnable( BOOL bEnable );
//void CPLS_FAREXPORT CPLEnableAsync( BOOL bEnable );

#ifdef __cplusplus
};      // extern "C"
#endif  // __cplusplus

#define CPLLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )

#define CPLINTLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLINTOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )
		
#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\autoreg.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/autoreg.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.2  $
 *	$Date:   May 15 1996 11:00:52  $
 *	$Author:   gdanneel  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef AUTOREG_H
#define AUTOREG_H


#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllImport
#define DllImport	__declspec( dllimport )
#endif  // DllImport


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

#include <winerror.h>
#include "apierror.h"

//#define FACILITY_AUTOREG	82

//This is the base of the server errors, 
//All HTTP return codes are added to this
//base error to create the actual return
//value.
#define ERROR_SERVER_ERROR_BASE 0x8200

#define AR_OK				((HRESULT)MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_AUTOREG, ERROR_SUCCESS))
#define AR_WINSOCK_STARTUP	((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_DLL_INIT_FAILED))
#define AR_WINSOCK_VERSION	((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_OLD_WIN_VERSION))
#define AR_ADDRLEN			((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_BAD_LENGTH))
#define AR_STRING_INVALID	((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_INTERNAL_ERROR))
#define AR_SOCKERROR		((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_WRITE_FAULT))
#define AR_INVALID_RESPONSE	((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_INVALID_DATA))
#define AR_SERVER_ERROR		((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_SERVER_ERROR_BASE))
#define AR_PEER_UNREACHABLE	((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_AUTOREG, ERROR_HOST_UNREACHABLE))


//------------------------------------------------------------------------------
// RegisterAddress
// DLL entry point
// Register the current IP address with the given registration server.
// Returns error code indicating success or failure.
//
// Parameters :
//			RegServer	IP address or domain name of registration server
//			App			Application to register
//			IPAddress	IP address to register, if null, take the local
//						IP address gathered from the network
//			Port		The application port to register, i.e. the 
//						port that the application is listening on
//			Name		The name of the user/machine to register
//
// Returns :
//        Status
//------------------------------------------------------------------------------
HRESULT DllExport RegisterAddress(	const char *RegServer, 
									const char *App,
									const char *IPAddress,
									const char *Port,
									const char *Name);

//------------------------------------------------------------------------------
// UnRegisterAddress
// DLL entry point
// Remove a registration with the given name server.
// Returns error code indicating success or failure.
//
// Parameters :
//			RegServer	IP address or domain name of registration server
//			Name		The name of the user/machine that was registered
//
// Returns :
//        Status
//------------------------------------------------------------------------------
HRESULT DllExport UnRegisterAddress(const char *RegServer, 
									const char *Name);


#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus


#endif // AUTOREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\apimsp.h ===
/****************************************************************************
 *
 *	$Archive:   S:\sturgeon\src\include\vcs\apimsp.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.21  $
 *	$Date:   15 Apr 1996 10:33:10  $
 *	$Author:   LCARROLL  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef APIMSP_H
#define APIMSP_H

#include <apierror.h>

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllImport
#define DllImport	__declspec( dllimport )
#endif  // DllImport


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


// Define for MSP return indicating no error
#define MSPE_OK		0


// Type identifies MSPs.
//
// Guideline for MSPTYPE strings
//      CompanyProductServiceSubtypeVersionDirection\0
//        10  +  10  +  10  +  10  +   6  +   3    + 1   = 50 chars
//
// e.g.  #define "IntelIPhoneAudioG7231.0Src"
//
#define MAX_MSPTYPE_LENGTH              50
typedef char MSPTYPE[MAX_MSPTYPE_LENGTH], *LPMSPTYPE;


// Control structures are passed to the MSP by MSM.  These handles identify 
// internal MSM control structures and should not be manipulated by the MSP.
// The MSP should return these handles in the appropriate MSM callbacks.
typedef DWORD	HMSPCTRL;
typedef DWORD	HPORTCTRL;
typedef DWORD	HBUFFERCTRL;


// Tokens are passed to MSM from MSPs.  MSM passes these tokens back to the
// MSP to identify particular instances or objects in later calls.
typedef DWORD MSPTOKEN,		*LPMSPTOKEN;
typedef DWORD PORTTOKEN,	*LPPORTTOKEN;
typedef DWORD BUFFERTOKEN,	*LPBUFFERTOKEN;


// Definitions for media synchronization
//
typedef DWORD	MSYNCSTAMP,	*LPMSYNCSTAMP;	// Sync stamp for an MSP.
typedef int 	MSYNCDELTA, *LPMSYNCDELTA;	// Difference between two sync stamps.
typedef DWORD	MSYNCSTATE, *LPMSYNCSTATE;	// State of sync (wait, play, drop, etc.).

#define MSYNC_WAIT			0	// Frame should be played later (early).
#define MSYNC_PLAY			1	// Frame should be played now.
#define MSYNC_HURRY			2	// MSP should hurry to catch up.
#define MSYNC_DROP			3	// Frame should be dropped (late).
#define MSYNC_ERROR 		4	// There is an error in the sync process.



// Registry defines
//
#define MSP_REG_DLLNAME				"DllName"
#define MSP_REG_ERRORPATH			"ErrorPath"
#define MSP_REG_DIRECTION			"Direction"
#define MSP_REG_LONGNAME			"LongName"
#define MSP_REG_SHORTNAME			"ShortName"
#define MSP_REG_PRODUCTCOUNT		"ProductCount"

#define MSP_REG_ENABLESYNC			"EnableSync"		// Whether to use sync manager.
#define MSP_REG_DEF_ENABLESYNC		1
#define MSP_REG_EARLYLIMIT			"SyncEarlyLimit"	// Later than this is an error.
#define MSP_REG_DEF_EARLYLIMIT		-1500
#define MSP_REG_EARLYPLAYLIMIT		"SyncEarlyPlayLimit"// Earlier than this must wait.
#define MSP_REG_DEF_EARLYPLAYLIMIT	-226
#define MSP_REG_LATEPLAYLIMIT		"SyncLatePlayLimit"	// Later than this must catch up.
#define MSP_REG_DEF_LATEPLAYLIMIT	-200
#define MSP_REG_LATELIMIT			"SyncLateLimit"		// Later than this must hurry.
#define MSP_REG_DEF_LATELIMIT		-100


#define MSP_REG_KEY_DEFAULT			0x00000000
#define MSP_REG_KEY_USER			0x00000001
#define MSP_REG_KEY_PRODUCT			0x00000002
#define MSP_REG_KEY_RMS				0x00000003
#define MSP_REG_KEY_OTHER			0x00000004
#define MSP_REG_KEY_TRYALL			0x00000005



// Typedefs for MSM entry points accessed by MSPs
//
typedef HRESULT (*SENDAPPCOMMAND)		(HMSPCTRL, HPORTCTRL, WPARAM, LPARAM, LPARAM);
typedef HRESULT (*MSP2MSMSEND)			(HPORTCTRL, BUFFERTOKEN, LPWSABUF, UINT);
typedef HRESULT (*MSM2MSPSENDCOMPLETE)	(HPORTCTRL, HBUFFERCTRL);
typedef HRESULT (*MSP2MSMFLUSHBUFFERS)	(HPORTCTRL);
typedef HRESULT (*ERRORNOTIFY)			(HMSPCTRL, HPORTCTRL, HRESULT);
typedef HRESULT (*GETREGDWORDVALUE)		(HMSPCTRL, LPSTR, LPSTR, LPDWORD, DWORD, DWORD);
typedef HRESULT (*SETREGDWORDVALUE)		(HMSPCTRL, LPSTR, LPSTR, DWORD, DWORD);
typedef HRESULT (*GETREGSTRINGVALUE)	(HMSPCTRL, LPSTR, LPSTR, LPSTR, LPSTR, DWORD, DWORD);
typedef HRESULT (*SETREGSTRINGVALUE)	(HMSPCTRL, LPSTR, LPSTR, LPSTR, LPSTR, DWORD);
typedef HRESULT (*NEWSYNCSTAMP)			(LPMSYNCSTAMP);
typedef HRESULT (*SETSYNCCLOCK)			(HPORTCTRL, MSYNCSTAMP, DWORD);
typedef HRESULT (*STARTSYNCCLOCK)		(HPORTCTRL);
typedef HRESULT (*STOPSYNCCLOCK)		(HPORTCTRL);
typedef HRESULT (*TESTSYNCSTATE)		(HPORTCTRL, MSYNCSTAMP, LPMSYNCSTATE, LPMSYNCDELTA, DWORD);



// struct used to export MSM entry points accessed by MSPs
//
typedef struct _MSMSPI
{
	SENDAPPCOMMAND		SendAppCommand;
	MSP2MSMSEND 		MSP2MSMSend;
	MSM2MSPSENDCOMPLETE	MSM2MSPSendComplete;
	MSP2MSMFLUSHBUFFERS MSP2MSMFlushBuffers;
	ERRORNOTIFY			ErrorNotify;
	GETREGDWORDVALUE	GetRegDwordValue;
	SETREGDWORDVALUE	SetRegDwordValue;
	GETREGSTRINGVALUE	GetRegStringValue;
	SETREGSTRINGVALUE	SetRegStringValue;
	NEWSYNCSTAMP		NewSyncStamp;
	SETSYNCCLOCK		SetSyncClock;
	STARTSYNCCLOCK		StartSyncClock;
	STOPSYNCCLOCK		StopSyncClock;
	TESTSYNCSTATE		TestSyncState;
}
MSMSPI, *LPMSMSPI;



// Typedefs for MSP entry points accessed by MSM
//
typedef HRESULT (*OPENSERVICE)		(LPMSPTYPE, HMSPCTRL, const LPMSMSPI, LPARAM, LPARAM, LPMSPTOKEN);
typedef HRESULT (*CLOSESERVICE)		(MSPTOKEN);
typedef HRESULT (*OPENPORT)			(MSPTOKEN, HPORTCTRL, LPARAM, LPARAM, LPPORTTOKEN);
typedef HRESULT (*CLOSEPORT)		(MSPTOKEN, PORTTOKEN);
typedef HRESULT (*SERVICECMDPROC)	(MSPTOKEN, PORTTOKEN, WPARAM, LPARAM, LPARAM);
typedef HRESULT (*MSM2MSPSEND)		(MSPTOKEN, PORTTOKEN, HBUFFERCTRL, LPWSABUF, UINT);
typedef HRESULT (*MSP2MSMSENDCOMPLETE)	(MSPTOKEN, PORTTOKEN, BUFFERTOKEN, LPWSABUF);
typedef HRESULT (*MSM2MSPFLUSHBUFFERS)	(MSPTOKEN, PORTTOKEN);


// MSP API
//
typedef struct _MSPAPI
{
	OPENSERVICE				OpenService;
	CLOSESERVICE			CloseService;
	OPENPORT				OpenPort;
	CLOSEPORT				ClosePort;
	SERVICECMDPROC			ServiceCmdProc;
	MSM2MSPSEND				MSM2MSPSend;
	MSP2MSMSENDCOMPLETE		MSP2MSMSendComplete;
	MSM2MSPFLUSHBUFFERS		MSM2MSPFlushBuffers;
}
MSPAPI, *LPMSPAPI;



// Prototypes for MSP entry points accessed by MSM
//
extern DllExport HRESULT MSP_OpenService
(
LPMSPTYPE		pMSPType,	// Pointer to unique MSP identifier
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
const LPMSMSPI	pMSMSPI,	// Pointer to MSM entry points called be an MSP
LPARAM			lParamIn,	// Long parameter in
LPARAM			lParamOut,	// Long parameter out
LPMSPTOKEN		pMSPToken	// Pointer to token returned by the MSP
);

extern DllExport HRESULT MSP_CloseService
(
MSPTOKEN		MSPToken	// MSP token for instance data
);

extern DllExport HRESULT MSP_OpenPort
(
MSPTOKEN		MSPToken,	// MSP token for instance data
HPORTCTRL		hPortCtrl,	// MSM's instance handle for port
LPARAM			lParamIn,	// Long parameter in
LPARAM			lParamOut,	// Long parameter out
LPPORTTOKEN		pPortToken	// Pointer to port token returned by the MSP
);

extern DllExport HRESULT MSP_ClosePort
(
MSPTOKEN		MSPToken,	// MSP's token for instance data
PORTTOKEN		PortToken	// MSP's token for port instance data
);

extern DllExport HRESULT MSP_ServiceCmdProc
(
MSPTOKEN		MSPToken,	// MSP's token for instance data
PORTTOKEN		PortToken,	// MSP's token for port instance data
WPARAM			wParam,		// Word parameter in
LPARAM			lParamIn,	// Long parameter in
LPARAM			lParamOut	// Long parameter out
);

extern DllExport HRESULT MSP_MSM2MSPSend
(
MSPTOKEN		MSPToken,	// MSP's token for instance data
PORTTOKEN		PortToken,	// MSP's token for port instance data
HBUFFERCTRL		hBufferCtrl,// MSM's handle to buffer instance data
LPWSABUF		pWSABuf,	// Pointer to WSA buffer array
UINT			uWSABufCount// Count of WSA buffers in buffer array
);

extern DllExport HRESULT MSP_MSP2MSMSendComplete
(
MSPTOKEN		MSPToken,	// MSP's token for instance data
PORTTOKEN		PortToken,	// MSP's token for port instance data
BUFFERTOKEN		BufferToken,// MSP's token for buffer instance data
LPWSABUF		pWSABuf		// Pointer to WSA buffer array
);

extern DllExport HRESULT MSP_MSM2MSPFlushBuffers
(
MSPTOKEN		MSPToken,	// MSP's token for instance data
PORTTOKEN		PortToken	// MSP's token for port instance data
);




// Prototypes for MSM entry points accessed by MSPs
//
extern DllExport HRESULT MSM_SendAppCommand
(
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
HPORTCTRL		hPortCtrl,	// MSM's instance handle for port
WPARAM			wParam,		// Word parameter in
LPARAM			lParamIn,	// Long parameter in
LPARAM			lParamOut	// Long parameter out
);


extern DllExport HRESULT MSM_MSP2MSMSend
(
HPORTCTRL		hPortCtrl,	// MSM's instance handle for port
BUFFERTOKEN		BufferToken,// MSP's token for buffer instance data
LPWSABUF		pWSABuf,	// Pointer to WSA buffer array
UINT			uWSABufCount// Count of WSA buffers in buffer array
);

extern DllExport HRESULT MSM_MSM2MSPSendComplete
(
HPORTCTRL		hPortCtrl,	// MSM's instance handle for port
HBUFFERCTRL		hBufferCtrl	// MSM's handle to buffer instance data
);

extern DllExport HRESULT MSM_ErrorNotify
(
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
HPORTCTRL		hPortCtrl,	// MSM's instance handle for port
HRESULT			hResult		// Error to report
);

extern DllExport HRESULT MSM_MSP2MSMFlushBuffers
(
HPORTCTRL		hPortCtrl	// MSM's instance handle for port
);

extern DllExport HRESULT MSM_GetRegDwordValue
(
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
LPSTR			pstrKey,	// Pointer to optional string for subkeys
LPSTR			pstrValue,	// pointer to string of value to get
LPDWORD			pdValueData,// Pointer to location to place value
DWORD			dDefault,	// Default if no settings exists
DWORD			dFlags		// Flags to indicate where to look for value (Default (0) = TRYALL)
);

extern DllExport HRESULT MSM_SetRegDwordValue
(
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
LPSTR			pstrKey,	// Pointer to optional string for subkeys
LPSTR			pstrValue,	// Pointer to string of value to set
DWORD			dValueData,	// Data to set
DWORD			dFlags		// Flags to indicate where to set value (Default (0) = RMS)
);

extern DllExport HRESULT MSM_GetRegStringValue
(
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
LPSTR			pstrKey,	// Pointer to optional string for subkeys
LPSTR			pstrValue,	// Pointer to string of value to get
LPSTR			pstrValueData,// Pointer to string to receive value data
LPSTR			pstrDefault,// Pointer to default string if no settings exists
LPDWORD			pdSize,		// Pointer to the size of the return buffer
DWORD			dFlags		// Flags to indicate where to look for value (Default (0) = TRYALL)
);

extern DllExport HRESULT MSM_SetRegStringValue
(
HMSPCTRL		hMSPCtrl,	// MSM's instance handle for MSP
LPSTR			pstrKey,	// Pointer to optional string for subkeys
LPSTR			pstrValue,	// Pointer to string of value to set
LPSTR			pstrValueData,// Pointer to string data to set
DWORD			dFlags		// Flags to indicate where to set value (Default (0) = RMS)
);

extern DllExport HRESULT MSM_NewSyncStamp
(
LPMSYNCSTAMP	pStamp
);

extern DllExport HRESULT MSM_SetSyncClock
(
HPORTCTRL		hPortCtrl,	// MSM's instance handle for port
MSYNCSTAMP		tDataStamp,	// New time stamp
DWORD			dLatency	// Latency in milliseconds until timstamp is valid
);

extern DllExport HRESULT MSM_StartSyncClock
(
HPORTCTRL		hPortCtrl			// MSM's instance handle for port
);

extern DllExport HRESULT MSM_StopSyncClock
(
HPORTCTRL		hPortCtrl			// MSM's instance handle for port
);

extern DllExport HRESULT MSM_TestSyncState
(
HPORTCTRL		hPortCtrl,			// MSM's instance handle for port
MSYNCSTAMP		tDataStamp,
LPMSYNCSTATE	pState,
LPMSYNCDELTA	pDelta,
DWORD			dLatency			// Latency to playback client's packet
);


#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus


#endif // APIMSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\arscli.h ===
////////////////////////////////////////////////////////////////////////////////
//
// INTEL Corporation Proprietary Information
// Copyright (c) 1995 Intel Corporation
//
// This  software  is supplied under the terms of a license agreement with INTEL
// Corporation  and  may not be used, copied, nor disclosed except in accordance
// with the terms of that agreement.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// $Workfile:   arscli.h  $
// $Revision:   1.6  $
// $Modtime:   19 Sep 1996 19:20:44  $
//
// DESCRIPTION:
//
//		This header file defines the Address Resolution Service's client
//		side interface.  This interface is meant to be used by applications
//		who have a need to map to dynamically assigned address information
//		for a given user (i.e. if the user is connected to the internet via
//		a ISP who uses DHCP to hand out IP addresses.
//
//		The following exported functions are declared in this file:
//
//			ARCreateRegistration()
//			ARDestroyRegistration()
//			ARCreateCallTargetInfo()
//			ARQueryCallTargetInfo()
//			ARDestroyCallTargetInfo()
//			ARGetConfigVal()
//			ARSetConfigVal()
//			ARReleaseStringResult()
//			ARGetHostByAddr()
//
////////////////////////////////////////////////////////////////////////////////

/****************************************************************************
 *
 *	ARS Client Interface 0.005
 *
 ***************************************************************************/

#ifndef ARSCLIENT_H
#define ARSCLIENT_H


#ifndef DllImport
#define DllImport	__declspec( dllimport )
#endif  // DllImport

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

//
// Error Handling Information
//

#include <winerror.h>
#include "apierror.h"

typedef enum AR_TAGS 
{
	AR_TAG_BADTAG = 0,
	AR_TAG_IPADDR,
	AR_TAG_PORTNUM,
	AR_TAG_APPGUID,
	AR_TAG_USERNAME,
	AR_TAG_NAPPS,
	AR_TAG_QUERYURL,
	AR_TAG_USERID,
	AR_NUM_TAGS
} ARTag;

typedef enum AR_CONFIGTAGS
{
	AR_CONFIG_BADTAG = 0,
	AR_CONFIG_PROXY,
	AR_CONFIG_PROXYPORT,
	AR_CONFIG_SERVERURL,
	AR_NUM_CONFIGTAGS
} ARConfigTag;

//This is the base of the server errors, 
//All HTTP return codes are added to this
//base error to create the actual return
//value.
#define ERROR_SERVER_ERROR_BASE (ERROR_LOCAL_BASE_ID + 0x200)

#define AR_OLE_FAIL(x) ((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, \
											  FACILITY_ARSCLIENT, (x)))

#define AR_OLE_SUCCESS(x) ((HRESULT)MAKE_HRESULT(SEVERITY_SUCCESS, \
										   FACILITY_ARSCLIENT, (x)))

#define AR_OK					AR_OLE_SUCCESS(ERROR_SUCCESS)
#define AR_WINSOCK_STARTUP		AR_OLE_FAIL(ERROR_DLL_INIT_FAILED)
#define AR_WINSOCK_VERSION		AR_OLE_FAIL(ERROR_OLD_WIN_VERSION)
#define AR_ADDRLEN				AR_OLE_FAIL(ERROR_BAD_LENGTH)
#define AR_STRING_INVALID		AR_OLE_FAIL(ERROR_INTERNAL_ERROR)
#define AR_SOCKERROR			AR_OLE_FAIL(ERROR_WRITE_FAULT)
#define AR_INVALID_RESPONSE		AR_OLE_FAIL(ERROR_INVALID_DATA)
#define AR_SERVER_ERROR			AR_OLE_FAIL(ERROR_SERVER_ERROR_BASE)
#define AR_PEER_UNREACHABLE		AR_OLE_FAIL(ERROR_HOST_UNREACHABLE)
#define AR_OUTOFMEMORY			AR_OLE_FAIL(ERROR_OUTOFMEMORY)
#define AR_INVALID_PARAMETER	AR_OLE_FAIL(ERROR_INVALID_PARAMETER)
#define AR_NOT_IMPLEMENTED		AR_OLE_FAIL(ERROR_INVALID_FUNCTION)
#define AR_BAD_TARGET			AR_OLE_FAIL(ERROR_OPEN_FAILED)
#define	AR_BADCONTEXT			AR_OLE_FAIL(ERROR_INVALID_ADDRESS)

//
// Local data types
//

typedef void* ARRegContext;
typedef void* ARCallTargetInfoContext;
typedef char* ARString;

//
//	Function prototypes
//

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

/*----------------------------------------------------------------------------
 * ARCreateRegistration
 * DLL entry point
 * 
 * Takes server information and registers with that server, creating
 * a context which must be used to unregister.
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      regContext  Pointer to a registration
 *                    context to be filled (ARRegContext)
 *      appGUID     GUID of application to register
 *      appName     Displayable name of application to register
 *		appMIME		MIME type for the application
 *      port        The application port to register
 *      ipAddress   IP address to register
 *                    if NULL, will be gathered from registry
 *      userGUID    GUID of user to register
 *                    if NULL, will be gathered from registry
 *      userName    Displayable name of user to register
 *                    if NULL, will be gathered from registry
 *      flags       ULS-compatible flags
 *      ttl         Time to live (time between keep-alives)
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *		AR_OUTOFMEMORY			Could not allocate memory for context 
 *		AR_WINSOCK_STARTUP		Error initializing WinSock 
 *		AR_WINSOCK_VERSION		Invalid WinSock version
 *		AR_STRING_INVALID		Could not parse URL to find address and port 
 *		AR_PEER_UNREACHABLE		Could not open TCP socket to server 
 *		AR_SOCKERROR			Could not send request over socket 
 *		AR_INVALID_RESPONSE		Server's response was not of the proper form 
 *		AR_SERVER_ERROR			Server returned an error code
 *		AR_ADDRLEN				The IP address exceeds the maximum length
 *-------------------------------------------------------------------------*/
HRESULT DllExport 
ARCreateRegistration( const char    *appID, 		// IN
                      const char    *appName, 		// IN
  					  const char    *appMIME,		// IN
                      const LONG     port, 			// IN
                      const char    *ipAddress, 	// IN
                      const char    *userID, 		// IN
                      const char    *userName, 		// IN
                      const LONG     flags, 		// IN
                      const LONG     ttl, 			// IN
					  ARRegContext  *regContext);	// OUT

/*---------------------------------------------------------------------------
 * ARDestroyRegistration
 * DLL entry point
 *
 * Removes the registration associated with the given context and
 * destroys the context.
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      regContext  Pointer to the ARRegContext to destroy
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	regContext == NULL
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *		AR_OUTOFMEMORY			Could not allocate memory for context 
 *		AR_WINSOCK_STARTUP		Error initializing WinSock 
 *		AR_WINSOCK_VERSION		Invalid WinSock version
 *		AR_STRING_INVALID		Could not parse URL to find address and port 
 *		AR_PEER_UNREACHABLE		Could not open TCP socket to server 
 *		AR_SOCKERROR			Could not send request over socket 
 *		AR_INVALID_RESPONSE		Server's response was not of the proper form 
 *		AR_SERVER_ERROR			Server returned an error code
 *		AR_ADDRLEN				The IP address exceeds the maximum length
 *-------------------------------------------------------------------------*/
HRESULT DllExport ARDestroyRegistration(ARRegContext regContext); 	// IN

/*-------------------------------------------------------------------------
 * ARCreateCallTargetInfo
 * DLL entry point
 *
 * Given a string, creates a context object which can be used to
 * query fields within a call target delivered by that string
 * NOTE: The intention is that a command line be passed, which
 * can then be interpreted freely by the DLL in an application-
 * independent manner to indicate the call target.
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      rawTarget   String to be used to derive call target information
 *      ctiContext  Pointer to a call target information context
 *                  to be filled
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	(ctiContext || rawTarget) == NULL
 *		AR_BAD_TARGET			We could not create the call target info with
 *								the raw target passed in.
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *-------------------------------------------------------------------------*/
HRESULT DllExport 
ARCreateCallTargetInfo(const char*	rawTarget, 					// IN
                       ARCallTargetInfoContext*	ctiContext);	// OUT

/*---------------------------------------------------------------------------
 * ARQueryCallTargetInfo
 * DLL entry point
 *
 * Given a call target information context, will return the value of a
 * given tag.  Tag names are case insensitive.
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      ctiContext  A call target information context to query
 *      tagField    A tag to get the value for.
 *
 *		  Valid tags:
 *
 *				AR_TAG_BADTAG = 0	(Place keep for illegal tag value)
 *				AR_TAG_IPADDR
 *				AR_TAG_PORTNUM
 *				AR_TAG_APPGUID
 *				AR_TAG_USERNAME
 *				AR_TAG_NAPPS
 *				AR_TAG_QUERYURL
 *
 *      value       Pointer to location to store value.
 *                    Stored as a null-terminated string.
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	(ctiContext || value) == NULL
 *								tagField == AR_TAG_BADTAG
 *		AR_INVALID_RESPONSE		The call target information is invalid
 *								for the specified tag.
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *-------------------------------------------------------------------------*/
HRESULT DllExport 
ARQueryCallTargetInfo(ARCallTargetInfoContext	ctiContext, // IN
 					  ARTag						tagField, 	// IN
                      ARString*            		value); 	// OUT

/*---------------------------------------------------------------------------
 * ARDestroyCallTargetInfo
 * DLL entry point
 *
 * Destroys a call target information context
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      ctiContext  The call target information context to destroy
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	ctiContext == NULL
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *-------------------------------------------------------------------------*/
HRESULT DllExport 
ARDestroyCallTargetInfo(ARCallTargetInfoContext ctiContext); 	// IN


/*---------------------------------------------------------------------------
 * ARGetConfigVal
 * DLL entry point
 *
 * Obtain specified ARS configuration value
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      tagField    A tag to get the value for.
 *
 *		  Valid tags:
 *
 *				AR_CONFIG_BADTAG = 0	(Place keep for illegal tag value)
 *				AR_CONFIG_PROXY
 *				AR_CONFIG_PROXYPORT
 *				AR_CONFIG_SERVERURL
 *
 *      value       Pointer to location to store pointer to value.
 *                    Stored as a null-terminated string;
 *						allocated by DLL
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	tagField == AR_TAG_BADTAG
 *		AR_BAD_TARGET			Could not open registry for reading
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *-------------------------------------------------------------------------*/
HRESULT DllExport 
ARGetConfigVal(	ARConfigTag					tagField,	// IN
				ARString*              		value);		// OUT

/*---------------------------------------------------------------------------
 * ARSetConfigVal
 * DLL entry point
 *
 * Set specified ARS configuration value
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      tagField    A tag to get the value for.
 *					Valid tags are those valid for ARGetConfigVal
 *      value       Pointer to location to store pointer to value.
 *                    Stored as a null-terminated string;
 *						allocated by DLL
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	tagField == AR_TAG_BADTAG
 *		AR_BAD_TARGET			Could not open registry for writing
 *		AR_NOT_IMPLEMENTED		This call has not been implemented.
 *-------------------------------------------------------------------------*/
HRESULT DllExport 
ARSetConfigVal(	ARConfigTag					tagField,	// IN
				const char					*value);	// IN


/*---------------------------------------------------------------------------
 * ARReleaseStringResult
 * DLL entry point
 *
 * Destroys a string allocated by ARGetConfigVal or ARQueryCallTargetInfo
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      value  The string to destroy
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	value == NULL
 *-------------------------------------------------------------------------*/
HRESULT DllExport ARReleaseStringResult(ARString value);	// IN

/*---------------------------------------------------------------------------
 * ARGetHostByAddr
 * DLL entry point
 *
 * Converts IP addr in dot notation to a host name.
 *
 * Returns error code indicating success or failure.
 *
 * Parameters:
 *
 *      lpszAddr	ptr to string containing IP addr in dot notation
 *		pphostName	address of ptr to store the host name
 *
 * Returns:
 *      AR_OK					Success
 *		AR_INVALID_PARAMETER	value == NULL
 *-------------------------------------------------------------------------*/

HRESULT DllExport ARGetHostByAddr(const char* lpszAddr,		// IN
								  char** pphostName);		// OUT

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

/****************************************************************************
 *
 * $Log:   S:\sturgeon\src\include\vcs\arscli.h_v  $
 * 
 *    Rev 1.6   23 Sep 1996 08:45:14   ENBUSHX
 * No change.
 * 
 *    Rev 1.5   19 Sep 1996 19:29:52   ENBUSHX
 * Fubction to translate from IP DOT to domain name.
 * 
 *    Rev 1.4   19 Sep 1996 18:58:34   ENBUSHX
 * Added a define for user id field in iii file.
 * 
 *    Rev 1.3   11 Jul 1996 18:42:12   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.2   10 Jul 1996 18:40:52   rodellx
 * 
 * Moved definition of arscli facility to apierror.h.
 * 
 *    Rev 1.1   08 Jul 1996 14:50:48   GEHOFFMA
 * Don't think any changes were made... just to be sure
 *
 ***************************************************************************/

#endif // ARSCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\audinfo.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/audinfo.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Author:   EDAVISON  $
 *
 *	Deliverable:
 *
 *	Abstract: Header file for the Audio MSP to share information with the App.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef AUDINFO_H
#define AUDINFO_H

#include	"apierror.h"
#include	"h245api.h"

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


//Unique IDs for this version of MSP.
// IMPORTANT : Currently the last 3 characters are case-sensitive for 
//			   string parsing purposes. It can be either Src or Snk.
#define		AUDIO_SRC_MSP		"IntelAudioRtp1.0Src"
#define		AUDIO_SNK_MSP		"IntelAudioRtp1.0Snk"

// Externalized Registry key defaults and ranges.
//
#define		AUDSNK_VOL_MIN		0			// Min audio volume setting.
#define		AUDSNK_VOL_MAX		15			// Max audio volume setting.
#define		AUDSNK_DEF_VOL		3			// Default audio volume setting.
#define		AUDSNK_VOL_FACTOR	0x10001000L // WAVE-specific volume factor.

// Service Command codes
#define		AUDCMD_MUTE				0x00000001	// Mute this audio snk instance.
#define		AUDCMD_PLAY				0x00000002	// Unmute this audio snk instance.
#define		AUDCMD_SETVOLUME	 	0x00000003	// Set audio volume.
#define		AUDCMD_GET_CONFIG		0x00000004	// Get current configuration.
#define		AUDCMD_GET_FOCUS_INFO	0x00000005  // for focus notify stuff
#define		AUDCMD_PUSH_TO_TALK		0x00000006	// Toggle Push to Talk functionality
#define		AUDCMD_SETTHRESHOLD		0x00000007	// Set threshold for voice activation

#define		AUD_FULL_DUPLEX_MODE	1
#define		AUD_HALF_DUPLEX_MODE	2

#define		RECORDING_STATE_PLAY	1
#define		RECORDING_STATE_MUTED	2

#define		HALF_DUPLEX_NA			0
#define		HALF_DUPLEX_TALK		1
#define		HALF_DUPLEX_LISTEN		2

// Voice Activation states
// The valid states only apply to Half Duplex operation
#define		VOICEACT_DISABLED		0	// In Full Duplex mode
#define		VOICEACT_IDLE_TALK		1
#define		VOICEACT_TALK			2
#define		VOICEACT_LISTEN			4

// State Transition notifications
#define		IDLE_TO_TALK			1
#define		IDLE_TO_LISTEN			2
#define		LISTEN_TO_IDLE			3
#define		TALK_TO_IDLE			4
#define		LISTEN_TO_TALK			5
#define		LISTEN_SILENCE			6
#define		LISTEN_DATA				7
#define		TALK_SILENCE			8
#define		TALK_DATA				9

// Energy notifications
#define		RECORD_ENERGY			10
#define		PLAYBACK_ENERGY			11

#define		MILLISEC_IN_ONE_SECOND	1000
#define		SILENCE_DELTA_SECONDS	1
#define		SILENCE_PACKETS_TO_SEND	2

#define     G723_THRESHOLD          0

// Registry Keys
#define		kMaxPortsPerMspInst		"MaxPortsPerMspInst"
#define		kCodecType				"CodecType"
#define		kNumWaveHeaders			"NumWaveHeaders"
#define		kNumSrcWaveBufs			"NumSrcWaveBufs"
#define		kFramesPerPkt			"FramesPerPkt"
#define		kDefaultVolume			"DefaultVolume"
#define		kMinVolume				"MinVolume"
#define		kMaxVolume				"MaxVolume"
#define     kPlaybackPacketSize     "PlaybackPacketSize"
#define     kInitPlaybackBufferPool "InitPlaybackBufferPool"
#define     kLatencyFrameCount      "LatencyFrameCount"
#define     kMaxFramesPerPlayback   "MaxFramesPerPlayback"
#define     kCapturePacketSize      "CapturePacketSize"
#define		kG723Use63DataRate		"G723Use63DataRate"
#define		kG723UsePostfilter		"G723UsePostfilter"
#define		kG723UseSilenceDetect	"G723UseSilenceDetect"
#define		kSilenceDeltaSeconds	"SilenceDeltaSeconds"
#define		kSilencePacketsToSend	"SilencePacketsToSend"
#define		kLHDataRate				"LHDataRate"
#define		kG723Threshold			"G723Threshold"

//------------------------------------------------------------------------------
// Audio MSP Error codes
// Other common error codes are defined in <winerror.h> and "apierror.h"
//------------------------------------------------------------------------------

#define		FIRST_EAUD_ID			ERROR_LOCAL_BASE_ID

#define		EAUD_MSP_TYPE			FIRST_EAUD_ID + 0
#define		EAUD_WAVE_INSTANCE		FIRST_EAUD_ID + 1
#define		EAUD_MSP_CTRL_HND		FIRST_EAUD_ID + 2

#define		EAUD_FREE_MEM			FIRST_EAUD_ID + 3

#define		EAUD_MSP_CALL_ORDER		FIRST_EAUD_ID + 4
#define		EAUD_VOL_NOT_SUPPORTED	FIRST_EAUD_ID + 5
#define		EAUD_GET_VOL			FIRST_EAUD_ID + 6
#define		EAUD_SET_VOL			FIRST_EAUD_ID + 7

#define		EAUD_WAV_OPEN			FIRST_EAUD_ID + 8
#define		EAUD_WAV_CLOSE			FIRST_EAUD_ID + 9
#define		EAUD_WAV_START			FIRST_EAUD_ID + 12
#define		EAUD_WAV_STOP			FIRST_EAUD_ID + 13
#define		EAUD_WAV_RESET			FIRST_EAUD_ID + 14
#define		EAUD_WAV_OPEN_NODRIVER	FIRST_EAUD_ID + 15
#define		EAUD_WAV_OPEN_INUSE		FIRST_EAUD_ID + 16
#define		EAUD_WAV_CLOSE_INUSE    FIRST_EAUD_ID + 17
#define		EAUD_NO_DEVICES			FIRST_EAUD_ID + 18
	
#define		EAUD_BUFSSTUCKINWINDRV	FIRST_EAUD_ID + 19
#define		EAUD_BUFSSTUCKINMSM		FIRST_EAUD_ID + 20
#define		EAUD_WAVEINADDBUFFER	FIRST_EAUD_ID + 21

#define		EAUD_COM_INIT			FIRST_EAUD_ID + 22	
#define		EAUD_PPM_INIT			FIRST_EAUD_ID + 23
#define		EAUD_PPM_COOKIE			FIRST_EAUD_ID + 24
#define		EAUD_AUDIO_SRC_INIT		FIRST_EAUD_ID + 25
#define		EAUD_AUDIO_SNK_INIT		FIRST_EAUD_ID + 26

#define		EAUD_INTERNAL			FIRST_EAUD_ID + 27

// Audio MSP Open Service structure
// To be passed in lParamIn by MSM in the MSP_OpenService call
typedef struct _AUDMSPOPENSERVICE
{
	BOOL	bForceHalfDuplex;		// should we override full duplex operation?
}
AUDMSPOPENSERVICE, *LPAUDMSPOPENSERVICE;

// Audio MSP Open Port structure
// To be passed in lParamIn by MSM in the MSP_OpenPort call
typedef struct _AUDMSPOPENPORT
{
	H245_TOTCAP_T	*pH245TotCapT;
	BYTE			RTPPayloadType;
}
AUDMSPOPENPORT, *LPAUDMSPOPENPORT;

// Audio MSP Service Command structure
// The command will be specified in wParam in MSP_ServiceCmdProc
// Structure that will be passed in lParamIn
typedef struct _AUDMSPSERVICECMD
{
	UINT		DuplexMode;		// Full or Half Duplex
	UINT		Volume;			// Volume setting
	UINT		PlayMode;		// Play or Mute
	UINT		Direction;		// Talk or Listen
	UINT		CodecType;		// G.723 etc.
	UINT		Threshold;		// Voice Activation threshold
}
AUDMSPSERVICECMD, *LPAUDMSPSERVICECMD;

typedef struct _AUDMSPFOCUSINFO
{
	UINT		PortCount;
	VOID *		pPortCtrl;
}
AUDMSPFOCUSINFO, *LPAUDMSPFOCUSINFO;

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus


#endif // AUDINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\coder.hpp ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\coder.hpv  $
 *
 *	$Revision:   1.4  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *	$Log:   S:\sturgeon\src\include\vcs\coder.hpv  $
// 
//    Rev 1.4   16 Jan 1997 15:25:06   BPOLING
// changed copyrights to 1997
// 
//    Rev 1.3   18 Dec 1996 21:49:58   BPOLING
// builds with msdev and for windows only
// 
//    Rev 1.2   09 Dec 1996 14:13:54   EHOWARDX
// Updated copyright notice.
 * 
 *    Rev 1.1   15 Nov 1996 16:16:14   BPOLING
 * vcs header added.
 *                                                                     *
 ***********************************************************************
 *																	   *
 *	coder.hpp														   *
 *																	   * 
 *	PURPOSE:	Encode/Decode ANS.1 Gatekeeper PDU using the OSS ANS.1 *
 *				compiler functions.									   *
 *																	   *
 *	FUNCTIONS:														   *
 *																	   *
 *	COMMENTS: 														   *
 *																	   *
 ***********************************************************************/

/************************************************************************
 * 						Include Files		           				   	*
 ***********************************************************************/

/************************************************************************
 * 						Manifest Constants								*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/

/************************************************************************
 * 						Class Definitions								*
 ***********************************************************************/

#ifndef _CODER_HPP
#define _CODER_HPP

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			8     // H225.0
#define RECOMM_NUMBER   2250
#define VERSION         0
#define ADDITIONAL      1


typedef struct _percallInfo
{
    unsigned char   bit_mask;
    NonStandardParameter prCllInf_nnStndrdDt;  /* optional */
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
    ossBoolean      originator;  /* optional */
    struct _seqofP17 {
        struct _seqofP17 *next;
        RTPSession      value;
    } *audio;  /* optional */
    struct _seqofP18 {
        struct _seqofP18 *next;
        RTPSession      value;
    } *video;  /* optional */
    struct _seqofP19 {
        struct _seqofP19 *next;
        TransportChannelInfo value;
    } *data;  /* optional */
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType        callType;
    BandWidth       bandWidth;
    CallModel       callModel;
} PERCALLINFO, *PPERCALLINFO;

typedef struct _seqpercallInfo{
    struct _seqpercallInfo *next;
	struct _percallInfo		value;
} SEQPERCALLINFO, *PSEQPERCALLINFO;

typedef struct _seqtransadds{
    struct _seqtransadds  	*next;
    TransportAddress 		value;
} SEQTRANSADDS, *PSEQTRANSADDS;

typedef struct _seqaliasadds {
    struct _seqaliasadds  	*next;
    AliasAddress    		value;
} SEQALIASADDS, *PSEQALIASADDS;

class Coder{

private:
	OssGlobal 			m_World;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

#ifdef _CONSOLE
	// Print a H323 structure
	int Print(RasMessage *pData);
	// Print an encoded H323 structure
	void Print(OssBuf *pOssBuf);
#else
	int InitCoder();
#endif
	// Creates an OssBuf
	int Encode(RasMessage *pInputData, OssBuf *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(OssBuf *pInputOssBuf, RasMessage **pOutputData);
	// Used to free buffer created by decode
	int Free(RasMessage *pData);
	// Used to free buffer created by encode
	void Free(OssBuf ossBuf);
	int Copy(RasMessage **pDestination,RasMessage *pSource);
	// Compare rasStruct
	// return of 1 means structures are not the same
	// return of 0 means structures are the same
	int Compare(RasMessage *pOriginal, RasMessage *pCopied);
	// Returns the sequence number out of any RasMessage
	// Returns zero on error
	RequestSeqNum GetSequenceNumber(RasMessage *prasStruct);
	RequestSeqNum SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum);
	// Returns a pointer EndpointIdentifier for any RasMessage
	// NULL for RasMessage that have no EndpointIdentifier
	EndpointIdentifier *GetEndpointID(RasMessage *prasStruct);
	// Returns a pointer to a valid H323 protocolIdentifier linked list 
	// when a valid Rasmessage is passed in and sets the protocol Identifier
	// item in RasMessages that have an protocol Identifier
	// If in an RasMessage that doesn't have a protocol identifer is passed in,
	// NULL is returned.
	ProtocolIdentifier SetProtocolIdentifier(RasMessage &rasStruct);
	// Returns TRUE if protocols match, FALSE - otherwise
	BOOL VerifyProtocolIdentifier(RasMessage &rasStruct);
	// finds the requested protocol rasAddress and copies it
	DWORD CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice);
	// finds the requested protocol callSignalAddress and copies it
	DWORD CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\drclsid.h ===
#ifndef DRCLSID_H
#define DRCLSID_H

// CLSID_DR: {A29F3681-D402-11cf-B839-00AA0053A236}
DEFINE_GUID(CLSID_DR, 0xa29f3681, 0xd402, 0x11cf, { 0xb8, 0x39, 0x0, 0xaa, 0x0, 0x53, 0xa2, 0x36 );

#endif //DRCLSID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\cpucalc.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/cpucalc.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.0  $
 *	$Date:   Nov 20 1996 14:05:46  $
 *	$Author:   MLEWIS1  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/
#ifndef _CPUCALC_H
#define _CPUCALC_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

//////////////////////////////////////////////////////
// CPU Performance Calulation typedef Section
//////////////////////////////////////////////////////

typedef DWORD HCALCINFO;

//////////////////////////////////////////////////////
// CPU Performance Calulation Prototypes Section
//////////////////////////////////////////////////////

// initialize CPU calulation object
HCALCINFO InitCPUCalc(void);

// cleanup CPU calculation object
void CleanupCPUCalc(HCALCINFO hCalc);

// get current CPU utilization value
BOOL GetCPUUsage(HCALCINFO hCalc, DWORD *pCpuUsage);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // _CPUCALC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\drerr.h ===
// drerr.h
// error code definition for data router and winsock callback.

#ifndef DRERR_H
#define DRERR_H

#include "apierror.h"


// error code for data router
#define DR_E_FAIL             (ERROR_BASE_ID + 1)
#define DR_E_OUTOFMEMORY      (ERROR_BASE_ID + 2)
							 
// error code for winsock callback
#define WSCB_E_SONOTFOUND     (ERROR_BASE_ID + 1)		   // SocketObject not found in SO List
#define WSCB_E_NOTINTABLE     (ERROR_BASE_ID + 2)          // Socket not found in socket table
#define WSCB_E_MPOOLUSEDUP    (ERROR_BASE_ID + 3)          // Memory pool used up

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\core.h ===
/****************************************************************************
 *  $Header:   S:/sturgeon/src/common/vcs/core.h_v   1.0   01 Mar 1996 17:44:42   WYANG  $
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1994 Intel Corporation. All rights reserved.
 *
 *  $Revision:   1.0  $
 *  $Date:   01 Mar 1996 17:44:42  $
 *  $Author:   WYANG  $
 *
 *  Log at end of file.
 *
 *  Module Name:    psbacore.h
 *  Abstract:       Core ProShare Video COM support
 *  Environment:    MSVC 1.5, OLE 2
 *  Notes:
 *		CClassFactory	- common class factory
 *		CUnknown		- default implementation of IUnknown
 *		CPsObject		- default implementation of IPsObject
 *		CPsApp			- CWinApp derivation
 *
 ***************************************************************************/

#ifndef CORE_H
#define CORE_H

//#include "internat.h"
//#include "psuiaux.h"
#include <winsock2.h>
#include <assert.h>


//***************************************************************************
// CClassFactory
//      CClassFactory is a common OLE 2 class factory that supports creation
//      of single or multiple instance OLE objects via a registration
//      mechanism. To use, an OLE class must implement a static CREATEPROC
//      method, and add a REGISTER_CLASS entry. All REGISTER_CLASS entries
//      must be collected together and wrapped with the BEGIN_CLASS_REGISTRY and
//      END_CLASS_REGISTRY macros.

// UNLOADSERVERPROC in .exe is called by class factory to unload .exe server (not used for .dll)
typedef void (STDMETHODCALLTYPE* UNLOADSERVERPROC)( void );

// DESTROYEDPROC in class factory is called by each object when it is destroyed
typedef void (STDMETHODCALLTYPE* DESTROYEDPROC)( REFCLSID rclsid );

// CREATEPROC in object (static method) is called by class factory to create a new object
typedef HRESULT (STDMETHODCALLTYPE* CREATEPROC)(
    const LPUNKNOWN     pUnkOuter,              // controlling outer if aggregating
    const DESTROYEDPROC pfnObjDestroyed,        // function to call when object is destroyed
    LPUNKNOWN FAR*      ppUnkInner              // inner unknown
    );

class CClassFactory : public IClassFactory
{
private:
    // static members
    struct Registry
    {
        const CLSID*    pClsid;
        CREATEPROC      pfnCreate;
        REGCLS          regCls;
        CClassFactory*  pFactory;
        ULONG           cObjects;
	    LPUNKNOWN   	pUnkSingle;
        DWORD           dwRegister;
    };
    static Registry         NEAR s_registry[];
    static UINT             NEAR s_nRegistry;
    static ULONG            NEAR s_cLockServer;
    static ULONG            NEAR s_cObjects;
    static UNLOADSERVERPROC NEAR s_pfnUnloadServer;

private:
    ULONG       m_cRef;
    Registry*   m_pReg;

public:
    CClassFactory( Registry* pReg );
    ~CClassFactory();

    // IUnknown interface
    virtual STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj ); 
    virtual STDMETHODIMP_( ULONG ) AddRef( void );
    virtual STDMETHODIMP_( ULONG ) Release( void );

    // IClassFactory interface
    virtual STDMETHODIMP CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObject );
    virtual STDMETHODIMP LockServer( BOOL fLock );

    // callback to track object destruction
    static STDMETHODIMP_( void ) ObjectDestroyed( REFCLSID rclsid );

    // Exe server helpers
    static void SetUnloadServerProc( UNLOADSERVERPROC pfnUnloadServer );
    static STDMETHODIMP RegisterAllClasses( DWORD dwClsContext );
    static STDMETHODIMP RevokeAllClasses( void );

    // Dll server helpers
    static STDMETHODIMP GetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvObj );
    static STDMETHODIMP CanUnloadNow( void );
    
    // local helpers                         
    static STDMETHODIMP LocalCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID FAR* ppvObj );

protected:
    static int CompareClsids( const void* clsid1, const void* clsid2 );
    static void SortRegistry( void );
    static Registry* FindClass( const CLSID* pClsid );

private:
	static CClassFactory*		newCClassFactory( Registry* pReg );
};

/////////////////////////////////////////////////////////////////////////////
// Class registry definition macros
//
#define BEGIN_CLASS_REGISTRY() \
    CClassFactory::Registry NEAR CClassFactory::s_registry[] = {
#define REGISTER_CLASS( clsid, class_name, regCls ) \
        { &clsid, class_name::_CreateObject, regCls, NULL, 0, NULL, 0 },
#define END_CLASS_REGISTRY() \
        { &CLSID_NULL, NULL, REGCLS_SINGLEUSE, NULL, 0, NULL, 0 } \
    };

/////////////////////////////////////////////////////////////////////////////
// Macros to define and implement a standard CREATEPROC
//
#define DECLARE_CREATEPROC() \
    static STDMETHODIMP _CreateObject( const LPUNKNOWN, const DESTROYEDPROC, LPUNKNOWN FAR* );

#define IMPLEMENT_CREATEPROC( class_name )                                                                      \
STDMETHODIMP                                                                                                    \
class_name::_CreateObject(                                                                                      \
    const LPUNKNOWN     pUnkOuter,              /* pointer to controlling outer if we're being aggregated */    \
    const DESTROYEDPROC pfnObjectDestroyed,     /* pointer to function to call when object is destroyed */      \
    LPUNKNOWN FAR*      ppUnkInner              /* return pointer to object here */                             \
    )                                                                                                           \
{                                                                                                               \
    SetObjectDestroyed( pfnObjectDestroyed );                                                                   \
                                                                                                                \
    /* check the other parameters; if these tests are made in a release build, */                               \
    /* return E_INVALIDARG on failure. */                                                                       \
    assert( pUnkOuter == NULL || ! ::IsBadReadPtr( pUnkOuter, sizeof(LPUNKNOWN)) );                             \
    assert( ! ::IsBadWritePtr( ppUnkInner, sizeof(LPUNKNOWN) ) );                                               \
    *ppUnkInner = NULL;                                                                                         \
                                                                                                                \
	class_name* pNewObject = NULL;                                                                              \
	                                                                                                            \
    /* create the new object */                                                                                 \
                                                                                                                \
                                                                                                                \
    	pNewObject = new class_name( pUnkOuter, ppUnkInner );                                                   \
                                                                                                                \
                                                                                                                \
                                                                                                                \
                                                                                                                \
    /* check the returned pointer */                                                                            \
    if( ! pNewObject )                                                                                          \
        return ResultFromScode( E_OUTOFMEMORY );                                                                \
                                                                                                                \
    /* make sure ppUnkInner is returned. If we're not */                                                        \
    /* aggregated it's ok to use pVideoView */                                                                  \
    if( ! *ppUnkInner )                                                                                         \
    {                                                                                                           \
        if( ! pUnkOuter )                                                                                       \
            return ResultFromScode( E_UNEXPECTED );                                                             \
        else                                                                                                    \
        {                                                                                                       \
            delete pNewObject;                                                                                  \
            return ResultFromScode( CLASS_E_NOAGGREGATION );                                                    \
        }                                                                                                       \
    }                                                                                                           \
                                                                                                                \
    return NOERROR;                                                                                             \
}                                                                                                               \
/* end of IMPLEMENT_CREATEPROC */

#if 0
    /* perform any remaining initialization */                                                                  \
    HRESULT hr = pNewObject->Init();                                                                            \
    if( FAILED( hr ) )                                                                                          \
    {                                                                                                           \
    	pNewObject->OnLastRelease();																			\
        delete pNewObject;                                                                                      \
        *ppUnkInner = NULL;                                                                                     \
        return hr;                                                                                              \
    }                                                                                                           
#endif

//***************************************************************************
// CUnknown - A generic IUnknown component object supporting aggregation
//      and CClassFactory
//
class CUnknown : public IUnknown
{
private:
    // controlling unknown; this will be the outer unknown if we're
    // aggregated, or our inner unknown if not
    LPUNKNOWN   m_pUnkControl;

    // nested inner IUnknown implementation. This is neccesary for a class
    // implemented using multiple inheritance to be aggregated.
    class CInnerUnknown : public IUnknown
    {
    private:
        // object reference count
        ULONG       m_cRef;
        CUnknown*   m_pThis;

    public:
        CInnerUnknown( CUnknown* pThis );
        ~CInnerUnknown();
//#ifdef _DEBUG
//        virtual void AssertValid( void ) const;
//        virtual void Dump( CDumpContext& dc ) const;
//#endif //_DEBUG

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
        STDMETHODIMP_( ULONG ) AddRef( void );
        STDMETHODIMP_( ULONG ) Release( void );
    } m_unkInner;
    friend CInnerUnknown;

    // pointer to object destruction function in common class factory
    // this can be a static (shared) member as all objects will call
    // the same function
    static DESTROYEDPROC s_pfnObjectDestroyed;

protected:
    CUnknown( LPUNKNOWN pUnkOuter, LPUNKNOWN FAR* ppUnkInner );
    static void SetObjectDestroyed( DESTROYEDPROC pfnObjectDestroyed );

public:
    virtual ~CUnknown();
//#ifdef _DEBUG
//    virtual void AssertValid( void ) const;
//    virtual void Dump( CDumpContext& dc ) const;
//#endif // _DEBUG

    // method called just prior to an object being destroyed
    virtual STDMETHODIMP_( void ) OnLastRelease( void );

    // method to get interface pointers supported by derived objects
    // called by CInnerUnknown::QueryInterface; should return S_FALSE
    // if interface is AddRef'd, S_OK if caller needs to AddRef the interface.
    virtual STDMETHODIMP GetInterface( REFIID riid, LPVOID FAR* ppvObj ) = 0;

    virtual STDMETHODIMP_( const CLSID& ) GetCLSID( void ) const = 0;

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
    virtual STDMETHODIMP_( ULONG ) AddRef( void );
    virtual STDMETHODIMP_( ULONG ) Release( void );

	// Standard allocator support
//	static LPVOID StdAlloc( ULONG cb );
//	static void StdFree( LPVOID pv );
//	static LPVOID StdRealloc( LPVOID pv, ULONG cb );
//	static ULONG StdGetSize( LPVOID pv );
//	static int StdDidAlloc( LPVOID pv );
//	static void StdHeapMinimize( void );
};

/////////////////////////////////////////////////////////////////////////////
// CUnknown inline methods
//
inline void CUnknown::SetObjectDestroyed( DESTROYEDPROC pfnObjectDestroyed )
{
    // make sure objectDestroyed function hasn't changed. If it could ever change then
    // the pointer should be stored in an instance specific member. The current
    // CClassFactory implementation guarantees that it will be the same function for
    // each object of a class, although not necessarily for each class.
    assert( ! ::IsBadCodePtr( (FARPROC) pfnObjectDestroyed ) || NULL == pfnObjectDestroyed );
    assert( NULL == s_pfnObjectDestroyed || s_pfnObjectDestroyed == pfnObjectDestroyed );

    // store the objectDestroyed function ptr
    s_pfnObjectDestroyed = pfnObjectDestroyed;
}

#endif  // PSBACORE_H

/*****************************************************************************
 * $Log:   S:/sturgeon/src/common/vcs/core.h_v  $
 * 
 *    Rev 1.0   01 Mar 1996 17:44:42   WYANG
 * Initial revision.
 * 
 *    Rev 1.0   Dec 08 1995 16:40:26   rnegrin
 * Initial revision.
 * 
 *    Rev 1.24   20 Sep 1995 16:04:48   PCRUTCHE
 * OLEFHK32
 * 
 *    Rev 1.23   13 Jun 1995 19:42:48   DEDEN
 * Dynamic object allocation helper functions\macros
 * 
 *    Rev 1.22   09 Jun 1995 14:45:12   KAWATTS
 * Moved CDebug::LoadLibrary to CPsAppHelper
 * 
 *    Rev 1.21   17 May 1995 21:50:36   DEDEN
 * Derive CPsApp from CDBoxHelper
 * 
 *    Rev 1.20   05 May 1995 14:45:20   DEDEN
 * Override CWinApp::DoMessageBox() with CPsApp::DoMessageBox() to alter AfxMessageBox behavior
 * 
 *    Rev 1.19   25 Apr 1995 12:35:00   DEDEN
 * Fix IMPLEMENT_CREATEPROC with TRY\CATCH for possible memory exception
 * 
 *    Rev 1.18   11 Apr 1995 16:18:24   DEDEN
 * Added GetSettingsPtr method
 * 
 *    Rev 1.17   20 Mar 1995 17:02:10   KAWATTS
 * Command line support
 * 
 *    Rev 1.16   14 Mar 1995 19:26:58   PCRUTCHE
 * _CreateObject now calls OnLastRelease if Init fails
 * 
 *    Rev 1.15   07 Mar 1995 16:38:42   AKHARE
 * ARM complaint sizeof
 * 
 *    Rev 1.14   03 Mar 1995 18:01:58   KAWATTS
 * Added include of internat.h
 * 
 *    Rev 1.13   01 Mar 1995 14:40:10   DEDEN
 * Removed static CUnknown:: variables associated with maintaining a static
 * task allocator pointer for the CUnknown:: static memory functions.
 * Moved implementation of functions to psunk.cpp.  Now use CoGetMalloc
 * every time.
 * 
 *    Rev 1.12   17 Feb 1995 10:59:56   DEDEN
 * Move GetStandardAllocator\ReleaseStandardAllocator to public section
 * 
 *    Rev 1.11   17 Feb 1995 10:51:22   KAWATTS
 * Added CUnknown::{Get,Release}StandardAllocator
 * 
 *    Rev 1.10   15 Feb 1995 16:08:52   KAWATTS
 * Changed CPsApp to use CPsAppHelper
 * 
 *    Rev 1.9   13 Feb 1995 15:27:36   KAWATTS
 * Added CPsAppHelper
 * 
 *    Rev 1.8   07 Feb 1995 14:01:16   KAWATTS
 * Added Load/UnloadResourceDll
 * 
 *    Rev 1.7   06 Feb 1995 11:10:46   KAWATTS
 * Added CPsApp::UseResourceDll
 * 
 *    Rev 1.6   31 Jan 1995 17:52:02   KAWATTS
 * Added error logging support
 * 
 *    Rev 1.5   20 Jan 1995 11:38:44   PCRUTCHE
 * Added lpMalloc parameter to InitInstance
 * 
 *    Rev 1.4   06 Jan 1995 09:56:02   PCRUTCHE
 * Changed registry data structure
 * 
 *    Rev 1.3   14 Dec 1994 19:08:58   DEDEN
 * Added CPsObject::PrefsChanged method
 * 
 *    Rev 1.2   01 Dec 1994 15:04:24   PCRUTCHE
 * Added QueryClose to PsObject
 * 
 *    Rev 1.1   29 Nov 1994 15:12:16   KAWATTS
 * Added standard allocator support to CUnknown
 * 
 *    Rev 1.0   07 Nov 1994 14:24:28   KAWATTS
 * Initial revision.
 * 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\fileio.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/fileio.h_v  $
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.5  $
 *	$Date:   Apr 02 1996 15:48:40  $
 *	$Author:   RKUHN  $
 *
 *	Deliverable: vcrmsp32.dll
 *
 *	Abstract: The FileIO public include file to be included by
 *	the App
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef FILEIO_H
#define FILEIO_H

#define	FILEIO_SRC_MSP	"IntelIPhoneFileIO1.0Src"
// The FILEIO_SNK_MSP is not to be used currently
#define	FILEIO_SNK_MSP	"IntelIPhoneFileIO1.0Snk"

#define	VIDEO_STREAM	0
#define	AUDIO_STREAM	1

// this is the command that needs to be sent to the FileIO MSP
// throught MSM_SendServiceCmd function when the MSP is to start
// sourcing the file specified in OpenService
#define START_SOURCING 1

// this is the command that needs to be sent to the FileIO MSP
// throught MSM_SendServiceCmd function when the MSP is to pause
// sourcing the file specified in OpenService. This command
// will just pause reading. The file or stream is not closed. 
// For actual shutdown ClosePort() needs to be called by MSM
// Also this command is to be sent for each port(video and audio)
// separately. To resume, START_SOURCING command will have to be sent
#define PAUSE_SOURCING 2

// This command will cause the read thread for the port 
// to be terminated.The stream correpoonding to the port
// will be closed. The port will still not be shutdown.ClosePort()
// will have to be called explicitly for port shutdown
#define STOP_SOURCING  3


// this is the wParam sent to the ServiceCallback function from
// the FileIO MSP when it is done sourcing the file
#define FILE_DONE	1

// this needs to be passed to the FileIO MSP on a MSM_OpenService 
// call as the first LPARAM parameter, and it should contain the 
// the file name to source terminated by '/0'
typedef char *LPOPENSERVICEIN; 

// The app will call MSP_OpenPort() thru MSM passing pointer to this
// structure as lParam1.This structure can be expanded to include
// the type algorithm/codec which the App would like this MSP to
// use for the stream
typedef struct _OPENPORTINPUT
{
	WORD	MediaType;	// VIDEO_STREAM = 0,AUDIO_STREAM = 1
        WORD    DontSendEOFCmd; // When this is set, the FileIO
	// MSP will go back to the start of the stream when end of stream is reached
	// This is useful for testing, when we have only a small file
	// and we want to play for a long time
} OPENPORTINPUT, *LPOPENPORTINPUT;

// this structure is used in the SendAppCmd call as the lParamIn.
// it specifies two handles which the application must wait on before
// calling CloseService on the fileio MSP.
typedef struct
{
	HANDLE waitHandle1;
	HANDLE waitHandle2;
} SEND_APP_CMD_STRUCT, *LP_SEND_APP_CMD_STRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\gkicom.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 *
 *	$Revision:   1.3  $
 *	$Date:   10 Jan 1997 17:41:10  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 17:41:10   CHULME
 * Changed CallReturnInfo structure to contain CRV and conferenceID
 * 
 *    Rev 1.2   10 Jan 1997 16:06:54   CHULME
 * Removed stdafx.h check for non MFC GKI implementation
 * 
 *    Rev 1.1   27 Dec 1996 14:37:22   EHOWARDX
 * Split out error codes into GKIERROR.H.
 * 
 *    Rev 1.0   11 Dec 1996 14:49:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   22 Nov 1996 15:25:44   CHULME
 * Added VCS log to the header
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKICOM_H
#define GKICOM_H

#include "apierror.h"
#include "gkierror.h"
#include "gkpdu.h"

typedef struct SeqTransportAddr {
	struct SeqTransportAddr	*next;
	TransportAddress		value;
} SeqTransportAddr;

typedef struct SeqAliasAddr {
	struct SeqAliasAddr		*next;
	AliasAddress			value;
} SeqAliasAddr;

typedef struct CallReturnInfo {
	HANDLE					hCall;
	CallModel				callModel;
	TransportAddress		destCallSignalAddress;
	BandWidth				bandWidth;
	CallReferenceValue		callReferenceValue;
	ConferenceIdentifier	conferenceID;
	WORD					wError;
} CallReturnInfo;

// Version Information for GKI Interface
#define GKI_VERSION				21	// TBD - reset to 1 after testing

// wMsg literals - these are added to the wBaseMessage supplied by the user
#define GKI_REG_CONFIRM			1
#define GKI_REG_DISCOVERY		2
#define GKI_REG_REJECT			3
#define GKI_REG_BYPASS			4

#define GKI_UNREG_CONFIRM		5
#define GKI_UNREG_REJECT		6

#define GKI_ADM_CONFIRM			7
#define GKI_ADM_REJECT			8

#define GKI_BW_CONFIRM			9
#define GKI_BW_REJECT			0xa

#define GKI_DISENG_CONFIRM		0xb
#define GKI_DISENG_REJECT		0xc

#define GKI_LOCATION_CONFIRM	0xd
#define GKI_LOCATION_REJECT		0xe

#define GKI_ERROR				0xf
#define MAX_ASYNC_MSGS			0xf

#define HR_SEVERITY_MASK				0x80000000
#define HR_R_MASK						0x40000000
#define HR_C_MASK						0x20000000
#define HR_N_MASK						0x10000000
#define HR_R2_MASK						0x08000000
#define HR_FACILITY_MASK				0x07ff0000
#define HR_CODE_MASK					0x0000ffff

#endif // GKICOM_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\gkierror.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 *
 *	$Revision:   1.4  $
 *	$Date:   23 Apr 1997 09:59:02  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 * 
 *    Rev 1.4   23 Apr 1997 09:59:02   CHULME
 * Added return code
 * 
 *    Rev 1.3   Apr 15 1997 10:06:26   tomitowx
 * No change.
 * 
 *    Rev 1.2   08 Feb 1997 12:20:14   CHULME
 * Added error code for semaphore creation error
 * 
 *    Rev 1.1   16 Jan 1997 15:25:08   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.0   27 Dec 1996 14:37:02   EHOWARDX
 * Initial revision.
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKIERROR_H
#define GKIERROR_H

// Status codes
#define GKI_EXIT_THREAD_CODE			ERROR_LOCAL_BASE_ID + 1	// not actually error code
#define GKI_REDISCOVER_CODE				ERROR_LOCAL_BASE_ID + 2	// not actually error code
#define GKI_DELETE_CALL_CODE			ERROR_LOCAL_BASE_ID + 3	// not actually error code
#define GKI_GCF_RCV_CODE				ERROR_LOCAL_BASE_ID + 4	// not actually error code
#define GKI_EXIT_THREAD_SNTBYP_CODE		ERROR_LOCAL_BASE_ID + 5	// not actually error code

#define GKI_ALREADY_REG_CODE			ERROR_LOCAL_BASE_ID + 0x10
#define GKI_VERSION_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x11
#define GKI_ENCODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x12
#define GKI_NOT_REG_CODE				ERROR_LOCAL_BASE_ID + 0x13
#define GKI_BUSY_CODE					ERROR_LOCAL_BASE_ID + 0x14
#define GKI_NO_TA_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x15
#define GKI_NO_RESPONSE_CODE			ERROR_LOCAL_BASE_ID + 0x16
#define GKI_DECODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x17
#define GKI_SEMAPHORE_ERROR_CODE		ERROR_LOCAL_BASE_ID + 0x18

#define GKI_OK							NOERROR

#define GKI_EXIT_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_EXIT_THREAD_CODE)
#define GKI_REDISCOVER					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_REDISCOVER_CODE)
#define GKI_DELETE_CALL					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_DELETE_CALL_CODE)
#define GKI_GCF_RCV						MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_GCF_RCV_CODE)
#define GKI_EXIT_THREAD_SNTBYP			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_EXIT_THREAD_SNTBYP_CODE)

#define GKI_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_OUTOFMEMORY)
#define GKI_NO_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_TOO_MANY_TCBS)
#define GKI_HANDLE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_INVALID_HANDLE)

#define GKI_ALREADY_REG					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ALREADY_REG_CODE)
#define GKI_VERSION_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_VERSION_ERROR_CODE)
#define GKI_ENCODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ENCODER_ERROR_CODE)
#define GKI_NOT_REG						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_REG_CODE)
#define GKI_BUSY						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_BUSY_CODE)
#define GKI_NO_TA_ERROR					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_TA_ERROR_CODE)
#define GKI_NO_RESPONSE					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_RESPONSE_CODE)
#define GKI_DECODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_DECODER_ERROR_CODE)
#define GKI_SEMAPHORE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_SEMAPHORE_ERROR_CODE)

#define GKI_WINSOCK2_ERROR(w)			(MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK2,w))

#endif // GKIERROR_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\gkiexp.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 *
 *	$Revision:   1.7  $
 *	$Date:   11 Feb 1997 15:37:30  $
 *
 *	$Author:   CHULME  $															*
 *
 *	$Log:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 * 
 *    Rev 1.7   11 Feb 1997 15:37:30   CHULME
 * Added GKI_CleanupRequest function
 * 
 *    Rev 1.6   16 Jan 1997 15:25:00   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.5   17 Dec 1996 18:23:36   CHULME
 * Change interface to use Remote rather than destination for AdmissionRequest
 * 
 *    Rev 1.4   09 Dec 1996 14:13:40   EHOWARDX
 * Updated copyright notice.
 *                                                                     * 
 ***********************************************************************/

// gkiexp.h : header file
//

#ifndef GKIEXP_H
#define GKIEXP_H

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#if defined(REMOVE_FROM_TSP)

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif

#else  // REMOVE_FROM_TSP

#define DLL_EXPORT
#define DLL_IMPORT

#endif // REMOVE_FROM_TSP

// ------------------------ Variable Imports --------------------------
extern DLL_IMPORT DWORD dwGKIDLLFlags;
extern DLL_IMPORT BOOL  fGKIEcho;
extern DLL_IMPORT BOOL  fGKIDontSend;
#if 0 //NSMWrap
extern DLL_IMPORT BOOL  fNSMWrapper;
#endif

// ------------------------ Function Imports --------------------------
HRESULT DLL_IMPORT GKI_RegistrationRequest(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_UnregistrationRequest(void);

HRESULT DLL_IMPORT GKI_LocationRequest(SeqAliasAddr         *pLocationInfo);

HRESULT DLL_IMPORT GKI_AdmissionRequest(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pRemoteInfo,
                                    TransportAddress     *pRemoteCallSignalAddress,
                                    SeqAliasAddr         *pDestExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_BandwidthRequest(HANDLE              hModCall, 
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

HRESULT DLL_IMPORT GKI_DisengageRequest(HANDLE hCall);

HRESULT DLL_IMPORT GKI_CleanupRequest(void);

#ifdef _DEBUG
WORD DLL_IMPORT Dump_GKI_RegistrationRequest(long        lVersion, 
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);

WORD DLL_IMPORT Dump_GKI_AdmissionRequest(unsigned short usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //GKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\freelist.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 11/95 Intel Corporation. 
//
//
//  Module Name: freelist.h
//  Abstract:    header file. a data structure for maintaining a pool of memory.
//	Environment: MSVC 2.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//NOTE: This structure is useful if you will be making several calls to new and delete
//      during the course of a program.  To use this structure, you create a new freelist.
//      You must give it a size and quantitity.  To get a chunk of uninitialized memory you use 
//      Get(). This is useful for structures and types that don't need any initialization.  
//
//      If you are planning to use this memory as a class then use the overloaded new operator
//      This will gurantee that the constructor is called. (see bottom of file) the overloaded
//      new operator takes two paramters. A size and a pointer to a free list. The size of the 
//      object must be bigger than sizeof(QueItem).  
//      
//      To put memory back in the free list you call Free().
/////////////////////////////////////////////////////////////////////////////////

#ifndef FREELIST_H
#define FREELIST_H

#include "que.h"
#include <assert.h>
#include <wtypes.h>



class FreeList {

private:
Queue  m_List;
char * m_pMemory;
size_t m_Size;

//only need this if I Get is private. But you might want to call get 
//if you want a free list of things that are not classes and therefore 
//don't need there constructors called.
//friend  void * operator new(size_t size, FreeList *l);

public:

//inline default constructor do I want this?
FreeList(){m_Size = 0; m_pMemory = NULL;};

//2nd constructor. Size must be at least the size of a QueItem
FreeList(int NumElements, size_t Size); 

//inline destructor
~FreeList(){delete m_pMemory;};

//inline. Gets a chunk of memeory from list, but does NOT do any initialization.
//Need to type cast return value to correct type
void * Get(){return (void *) m_List.Dequeue();};

//inline. Frees piece of memory.
HRESULT  Free(void * Element){return (m_List.Enqueue((QueueItem *)Element));};

//inline. returns true if list is empty; false otherwise
BOOL   Is_Empty(){return m_List.Is_Empty();};

//returns the size of the fragments that it creates and stores.
size_t    Size(){return m_Size;};

}; //end class FreeList

//inline. Overload the new operator. 
//Gets a chunk of memory from free list and calls the constructor on that chunk of memory.
//The constructor is that of the object new is called on. The returned
//pointer is of the correct type. (just like the real new operator)

//example:
//class FooClass;
// pFoo = new(pSomeFreeList) FooClass;
inline void * operator new(size_t size, FreeList *l)
{
assert(l->Size() == size);
return l->Get();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\gkerror.h ===
/***********************************************************************
 *																		*
 *	INTEL CORPORATION PROPRIETARY INFORMATION							*
 *																		*
 *	This software is supplied under the terms of a license			   	*
 *	agreement or non-disclosure agreement with Intel Corporation		*
 *	and may not be copied or disclosed except in accordance	   			*
 *	with the terms of that agreement.									*
 *																		*
 *	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
 *																		*
 *	$Archive:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 *
 *	$Revision:   1.18  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 * 
 *    Rev 1.18   16 Jan 1997 15:25:06   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.17   19 Dec 1996 18:46:44   BPOLING
 * added error code for no call signal address left in a user.
 * 
 *    Rev 1.16   18 Dec 1996 21:48:16   AKLEMENT
 * Fixed an error code for GWInfo.cpp
 * 
 *    Rev 1.14   18 Dec 1996 17:02:58   AKLEMENT
 * Added more GKInfo error codes.
 * 
 *    Rev 1.13   17 Dec 1996 19:20:02   AKLEMENT
 * Added GWInfo error codes.
 * 
 *    Rev 1.12   11 Dec 1996 13:32:44   AKLEMENT
 * Fixed the Prop Info header.
 * 
 *    Rev 1.11   10 Dec 1996 15:55:02   AKLEMENT
 * Added Resource Reading error define.
 * 
 *    Rev 1.10   10 Dec 1996 01:23:58   BPOLING
 * added a new error code for sending RRJ Undefined Reason.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:34   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   04 Dec 1996 10:43:18   BPOLING
 * added a new message id to post to h/i.
 * 
 *    Rev 1.7   04 Dec 1996 10:14:46   BPOLING
 * added error code for invalid ip address
 * 
 *    Rev 1.6   21 Nov 1996 13:06:18   BPOLING
 * added error code for HI PostMessage decoding.
 * 
 *    Rev 1.5   15 Nov 1996 14:38:18   BPOLING
 * vcs log fix.
 *                                                                     * 
 ***********************************************************************/

#ifndef GK_ERROR_H
#define GK_ERROR_H

#define GK_NOERROR					0

// WIN32 system error 000

#define GK_MEMORY_ERROR				1
#define GK_REGCREATEKEY_FAILED 		2
#define GK_GUID_ERROR				3
#define GK_EXCEPTION				4
#define GK_RESOURCE_ERROR			5

// Service related 100

#define GK_INVALID_ARG 				101
#define GK_NOARGS					102
#define GK_STARTSERVICE_FAILED		103
#define GK_EXIT						104

// User Class Errors 200

#define GK_USER_NOTINITIALIZED		201
#define GK_NOUSERFOUND				202
#define GK_EMPTYSEQUENCE			203
#define GK_TRANSPORTNOTFOUND		204
#define GK_ALIASNOTFOUND			205
#define GK_NO_CALLSIG				206

// Engine related Errors 300

#define GK_XRSRESPONSE				301
#define GK_NORESPONSE				303
#define GK_INVALIDMESSAGE			304
#define GK_SENDRRJ_NEEDGRQ			305
#define GK_XRSMESSAGERECEIVED		306
#define GK_NSMMESSAGERECEIVED		307
#define GK_BADENDPOINTID			308
#define GK_SENDGRJ_TERMEX			309
#define GK_SENDRRJ_UNDEFINED		310

// Ras Map related errors 400

#define GK_NORASFOUND		  	401
#define GK_RASFOUND				402
#define GK_DUPLICATERAS			403
#define GK_RAS_NOTINITIALIZED	404
#define GK_RAS_NOT_UNIQUE		405

// Sockets related errors 500

#define GK_NOPORT					501
#define GK_NOHOSTNAME				502
#define GK_UNSUPPORTEDPROTOCOL		503
#define GK_PROTOCOLNOTFOUND			504
#define GK_INVALIDPDUTYPE			505
#define GK_SOCKETSERROR				506
#define GK_RESPONSE					507
#define GK_INVALID_IPADDRESS		508

// Bound Map related errors 600

#define GK_NOBOUNDFOUND				601
#define GK_BOUNDFOUND				602
#define GK_DUPLICATEBOUND			603
#define GK_BOUND_NOTINITIALIZED		604
#define GK_BOUNDLOCKED				607
#define GK_BOUNDNOTLOCKED			608

// CONF Map related errors 700

#define GK_NOCONFFOUND				701
#define GK_CONFFOUND				702
#define GK_DUPLICATECONF			703
#define GK_CONF_NOTINITIALIZED		704
#define GK_NOT_IN_CONF				706
#define GK_INVALID_REQUEST			707
#define GK_CONFDELETE				708
#define GK_CONFCREATEFAILED			709


// PDU Error return codes 800

#define GK_ARJ_REQUEST_DENIED		800
#define GK_ARJ_UNDEFINED_REASON		801

// Alias CMap Errors 900

#define GK_ALIAS_NOTINITIALIZED		900
#define GK_ALIAS_NOT_UNIQUE			901
#define GK_ALIASFOUND				902
#define GK_NOALIASFOUND				903

// Guid Map related errors 1000

#define GK_NOGUIDFOUND				1001
#define GK_GUIDFOUND				1002
#define GK_DUPLICATEGUID			1003
#define GK_GUIDINUSE				1004
#define GK_GUID_NOTINITIALIZED		1005

// Call Sig CMap Errors 1100

#define GK_CALLSIG_NOTINITIALIZED		1100
#define GK_CALLSIG_NOT_UNIQUE			1101
#define GK_CALLSIGFOUND					1102
#define GK_NOCALLSIGFOUND				1103

// Call Errors 1200

#define GK_NOCALLFOUND					1200
#define GK_DIDNOTPURGE					1201
#define GK_CALL_NOTINITIALIZED			1202
#define GK_CALL_CREATE					1203
#define GK_CALL_DELETE					1204
#define GK_CALL_CHANGE					1205
#define GK_CALL_TIMER					1206

// Bandwidth Manager Errors 1300

#define GK_INVALID_BANDWIDTH			1300
#define GK_EXTERNAL_EXCEEDS_INTERNAL	1301
#define GK_NO_AVAILABLE_BANDWIDTH		1302
#define GK_USEDBW_WENT_NEGATIVE			1303
#define GK_LESS_AVAILABLE_BANDWIDTH		1304

// Logger Errors 1400

#define GK_LOGGING_IS_OFF				1400
#define GK_FILE_NOT_OPEN				1401
#define GK_COULD_NOT_OPEN_FILE			1402
#define GK_FILE_ALREADY_OPEN			1403
#define GK_NAME_USED_FOR_LOG			1404
#define GK_COULD_NOT_MAKE_DIR			1405

// GWInfo Errors 1500
#define GK_WRONG_PDU					1500
#define GK_NOT_GATEWAY					1501
#define GK_PROTOCOL_NOT_PRESENT			1502
#define GK_GW_NOT_FOUND					1503
#define GK_GW_NOT_REQUIRED				1504
#define GK_PREFIX_RESERVED				1505
#define GK_NO_DEST_INFO_SPECIFIED		1506

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\htmlfltr.h ===
#ifndef DllImport
#define DllImport  __declspec( dllimport)
#endif

#ifndef DllExport
#define DllExport  __declspec( dllexport)
#endif

#ifdef __cplusplus
extern "C" {
#endif

int DllExport HTMLfilter(char *ifn, char *ofn);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\lh.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: lh.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
#ifndef LH_H
#define LH_H

#ifdef __cplusplus

typedef struct : public PPMSESSPARAM_T
{
	DWORD msec;
} LHSESSPARAM_T;

#else /* __cplusplus */

typedef struct {
    PPMSESSPARAM_T ppmSessParam;
	DWORD msec;
} LHSESSPARAM_T;

#endif /* __cplusplus */

#endif // LH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\isubmit.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 11/95 Intel Corporation. 
//
//
//  Module Name: isubmit.h
//  Abstract:    Header file for Generic Submit Interfaces
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef ISUBMIT_H
#define ISUBMIT_H

#include <winsock2.h>

#ifdef __cplusplus
#define DEFAULT_PARAM_ZERO	=0
#else
#define DEFAULT_PARAM_ZERO
#endif

//Interfaces
#undef INTERFACE
#define INTERFACE ISubmitCallback

DECLARE_INTERFACE_(ISubmitCallback,IUnknown) 
{ 
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj)PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)PURE;
  STDMETHOD_(ULONG,Release)(THIS)PURE;

  STDMETHOD_(void,SubmitComplete)(THIS_ void *pUserToken, HRESULT Error)PURE;	
  STDMETHOD_(void,ReportError)(THIS_ HRESULT Error, int DEFAULT_PARAM_ZERO)PURE;
};

#undef INTERFACE
#define INTERFACE ISubmit
DECLARE_INTERFACE_(ISubmit,IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj)PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)PURE;
  STDMETHOD_(ULONG,Release)(THIS)PURE;

  STDMETHOD(InitSubmit)(THIS_ ISubmitCallback *pSubmitCallback)PURE;
  STDMETHOD(Submit)(THIS_ WSABUF *pWSABuffer, DWORD BufferCount, 
						void *pUserToken, HRESULT Error)PURE;
  STDMETHOD_(void,ReportError)(THIS_ HRESULT Error)PURE;
  STDMETHOD(Flush)(THIS)PURE;
};

#undef INTERFACE
#define INTERFACE ISubmitUser
DECLARE_INTERFACE_(ISubmitUser,IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj)PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)PURE;
  STDMETHOD_(ULONG,Release)(THIS)PURE;

  STDMETHOD(SetOutput)(THIS_ IUnknown *pSubmit)PURE;
};
		 

/////////////////////////////////////////////////////////////////////////////
// Interface ids
// 
// {A92D97A1-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( IID_ISubmitCallback,	0xa92d97a1, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A92D97A2-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( IID_ISubmit,			0xa92d97a2, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {0C1EA742-C917-11cf-A9C3-00AA00A4BE0C}
DEFINE_GUID( IID_ISubmitUser,       0xc1ea742, 0xc917, 0x11cf, 0xa9, 0xc3, 0x0, 0xaa, 0x0, 0xa4, 0xbe, 0xc);

#endif /* ISUBMIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\interop.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif

#else   // ! (defined(_DEBUG) || defined(PCS_COMPLIANCE))
#define InteropLoad()
#define InteropUnload()
#define InteropOutput()

#endif  // (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\ippm.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: ippm.h
//  Abstract:    Header file for PPM Interface
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef IPPM_H
#define IPPM_H

#include "isubmit.h"

#ifdef __cplusplus
#define DEFAULT_PARAM_ZERO	=0
#else
#define DEFAULT_PARAM_ZERO
#endif

typedef struct
{
	int payload_type;
} PPMSESSPARAM_T;

#define HRESULT_BUFFER_DROP				0x60000001
#define HRESULT_BUFFER_SILENCE			0x60000002
#define HRESULT_BUFFER_NORMAL			0x60000003
#define HRESULT_BUFFER_START_STREAM		0x60000004

#undef INTERFACE
#define INTERFACE IPPMSend
DECLARE_INTERFACE_(IPPMSend,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(InitPPMSend)(THIS_ int MaxPacketSize) PURE;
 STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam)PURE;
 STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc)PURE;
};

#undef INTERFACE
#define INTERFACE IPPMReceive
DECLARE_INTERFACE_(IPPMReceive,IUnknown)
{
 // *** IUnknown methods ***
 STDMETHOD(QueryInterface) ( THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
 STDMETHOD_(ULONG,Release) (THIS) PURE;
 
 STDMETHOD(InitPPMReceive)(THIS_ int MaxBufferSize DEFAULT_PARAM_ZERO) PURE;
 STDMETHOD(SetSession)(THIS_ PPMSESSPARAM_T *pSessparam)PURE;
 STDMETHOD(SetAlloc)(THIS_ IMalloc *pIMalloc)PURE;
};

////////////////////////////////////////////////////////////////////////////
// Interface ids
// 
// {1df95370-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( IID_IPPMSend,	0x1df95370,	0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

// {1df95371-f1fe-11cf-ba07-00aa003419d3}
DEFINE_GUID( IID_IPPMReceive,0x1df95371,0xf1fe, 0x11cf, 0xba, 0x07, 0x00, 0xaa, 0x00, 0x34, 0x19, 0xd3);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\isdmcapi.h ===
#ifndef __ISDMCAPI_H__
#define __ISDMCAPI_H__

#include "isdmapi.h"

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

typedef struct SESSIONTIMESTRUCT
{
	HSTATSESSION	hSession;
	DWORD			dwActivityTime;
	DWORD			dwActivityPrevTime;
	DWORD			dwActivityValue;
	DWORD			dwActivityPrevValue;
	DWORD			dwLatencyValue;
	DWORD			dwLossValue;
} SESSTIME, *LPSESSTIME;

typedef struct ISDMCODECSTRUCT
{
	WORD	wSendQuality;
	WORD	wRecvQuality;
} ISDM_CODEC_INFO,*LPISDM_CODEC_INFO;

typedef struct ISDMCALCITEMSTRUCT
{
	DWORD	dwValue;
	DWORD	dwMin;
	DWORD	dwMax;
	DWORD	dwThreshold;
} ISDM_CALC_ITEM,*LPISDM_CALC_ITEM;

typedef struct ISDMCALCINFOSTRUCT
{
	ISDM_CODEC_INFO CodecInfo;
	ISDM_CALC_ITEM Loss;
	ISDM_CALC_ITEM Latency;	
	ISDM_CALC_ITEM Activity;	
} ISDM_CALC_INFO, *LPISDM_CALC_INFO;

extern DllExport BOOL GetCPUUsage(DWORD *pCpuUsage);
extern DllExport BOOL GetRRCMStatItems(LPISDM_CALC_INFO pCalcInfo, LPSESSTIME *pSess);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\gkpdu.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************/
/* Abstract syntax: gkpdu */
/* Created: Wed Jan 15 13:27:58 1997 */
/* ASN.1 compiler version: 4.2 */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -c++ -per ASN1DF~1.zp8 gkpdu.asn
 */

#ifndef OSS_gkpdu
#define OSS_gkpdu

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "asn1hdr.h"
#include "asn1code.h"

#define          RasMessage_PDU 1

typedef struct ObjectID_ {
    struct ObjectID_ *next;
    unsigned short  value;
} *ObjectID;

typedef struct H221NonStandard {
    unsigned short  t35CountryCode;
    unsigned short  t35Extension;
    unsigned short  manufacturerCode;
} H221NonStandard;

typedef struct NonStandardIdentifier {
    unsigned short  choice;
#       define      object_chosen 1
#       define      h221NonStandard_chosen 2
    union _union {
        struct ObjectID_ *object;
        H221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    struct {
        unsigned int    length;
        unsigned char   *value;
    } data;
} NonStandardParameter;

typedef struct _choice1 {
    unsigned short  choice;
#       define      strict_chosen 1
#       define      loose_chosen 2
    union _union {
        Nulltype        strict;
        Nulltype        loose;
    } u;
} _choice1;

typedef struct TransportAddress {
    unsigned short  choice;
#       define      ipAddress_chosen 1
#       define      ipSourceRoute_chosen 2
#       define      ipxAddress_chosen 3
#       define      ip6Address_chosen 4
#       define      netBios_chosen 5
#       define      nsap_chosen 6
#       define      nonStandardAddress_chosen 7
    union _union {
        struct _seq1 {
            struct {
                unsigned short  length;
                unsigned char   value[4];
            } ip;
            unsigned short  port;
        } ipAddress;
        struct _seq2 {
            struct {
                unsigned short  length;
                unsigned char   value[4];
            } ip;
            unsigned short  port;
            struct _seqof1 {
                struct _seqof1  *next;
                struct {
                    unsigned short  length;
                    unsigned char   value[4];
                } value;
            } *route;
            _choice1        routing;
        } ipSourceRoute;
        struct _seq3 {
            struct {
                unsigned short  length;
                unsigned char   value[6];
            } node;
            struct {
                unsigned short  length;
                unsigned char   value[4];
            } netnum;
            struct {
                unsigned short  length;
                unsigned char   value[2];
            } port;
        } ipxAddress;
        struct _seq4 {
            struct {
                unsigned short  length;
                unsigned char   value[16];
            } ip;
            unsigned short  port;
        } ip6Address;
        struct _octet1 {
            unsigned short  length;
            unsigned char   value[16];
        } netBios;
        struct _octet2 {
            unsigned short  length;
            unsigned char   value[20];
        } nsap;
        NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct VendorIdentifier {
    unsigned char   bit_mask;
#       define      productId_present 0x80
#       define      versionId_present 0x40
    H221NonStandard vendor;
    struct {
        unsigned short  length;
        unsigned char   value[256];
    } productId;  /* optional */
    struct {
        unsigned short  length;
        unsigned char   value[256];
    } versionId;  /* optional */
} VendorIdentifier;

typedef struct GatekeeperInfo {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} GatekeeperInfo;

typedef struct H310Caps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} H310Caps;

typedef struct H320Caps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} H320Caps;

typedef struct H321Caps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} H321Caps;

typedef struct H322Caps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} H322Caps;

typedef struct H323Caps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} H323Caps;

typedef struct H324Caps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} H324Caps;

typedef struct VoiceCaps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} VoiceCaps;

typedef struct T120OnlyCaps {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} T120OnlyCaps;

typedef struct SupportedProtocols {
    unsigned short  choice;
#       define      nonStandardData_chosen 1
#       define      h310_chosen 2
#       define      h320_chosen 3
#       define      h321_chosen 4
#       define      h322_chosen 5
#       define      h323_chosen 6
#       define      h324_chosen 7
#       define      voice_chosen 8
#       define      t120_only_chosen 9
    union _union {
        NonStandardParameter nonStandardData;
        H310Caps        h310;
        H320Caps        h320;
        H321Caps        h321;
        H322Caps        h322;
        H323Caps        h323;
        H324Caps        h324;
        VoiceCaps       voice;
        T120OnlyCaps    t120_only;
    } u;
} SupportedProtocols;

typedef struct GatewayInfo {
    unsigned char   bit_mask;
#       define      protocol_present 0x80
#       define      GtwyInf_nonStandardData_present 0x40
    struct _seqof2 {
        struct _seqof2  *next;
        SupportedProtocols value;
    } *protocol;  /* optional */
    NonStandardParameter GtwyInf_nonStandardData;  /* optional */
} GatewayInfo;

typedef struct McuInfo {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} McuInfo;

typedef struct TerminalInfo {
    unsigned char   bit_mask;
#       define      GtkprInf_nnStndrdDt_present 0x80
    NonStandardParameter GtkprInf_nnStndrdDt;  /* optional */
} TerminalInfo;

typedef struct EndpointType {
    unsigned char   bit_mask;
#       define      EndpntTyp_nnStndrdDt_present 0x80
#       define      vendor_present 0x40
#       define      gatekeeper_present 0x20
#       define      gateway_present 0x10
#       define      mcu_present 0x08
#       define      terminal_present 0x04
    NonStandardParameter EndpntTyp_nnStndrdDt;  /* optional */
    VendorIdentifier vendor;  /* optional */
    GatekeeperInfo  gatekeeper;  /* optional */
    GatewayInfo     gateway;  /* optional */
    McuInfo         mcu;  /* optional */
    TerminalInfo    terminal;  /* optional */
    ossBoolean      mc;
    ossBoolean      undefinedNode;
} EndpointType;

typedef struct AliasAddress {
    unsigned short  choice;
#       define      e164_chosen 1
#       define      h323_ID_chosen 2
    union _union {
        char            e164[129];
        struct _char1 {
            unsigned short  length;
            unsigned short  *value;
        } h323_ID;
    } u;
} AliasAddress;

typedef struct Q954Details {
    ossBoolean      conferenceCalling;
    ossBoolean      threePartyService;
} Q954Details;

typedef struct QseriesOptions {
    ossBoolean      q932Full;
    ossBoolean      q951Full;
    ossBoolean      q952Full;
    ossBoolean      q953Full;
    ossBoolean      q955Full;
    ossBoolean      q956Full;
    ossBoolean      q957Full;
    Q954Details     q954Info;
} QseriesOptions;

typedef struct ConferenceIdentifier {
    unsigned short  length;
    unsigned char   value[16];
} ConferenceIdentifier;

typedef unsigned short  RequestSeqNum;

typedef struct GatekeeperIdentifier {
    unsigned short  length;
    unsigned short  *value;
} GatekeeperIdentifier;

typedef unsigned int    BandWidth;

typedef unsigned short  CallReferenceValue;

typedef struct EndpointIdentifier {
    unsigned short  length;
    unsigned short  *value;
} EndpointIdentifier;

typedef struct ObjectID_ *ProtocolIdentifier;

typedef struct GatekeeperRequest {
    unsigned char   bit_mask;
#       define      GtkprRqst_nnStndrdDt_present 0x80
#       define      GtkprRqst_gtkprIdntfr_present 0x40
#       define      GtkprRqst_callServices_present 0x20
#       define      GtkprRqst_endpointAlias_present 0x10
    RequestSeqNum   requestSeqNum;
    struct ObjectID_ *protocolIdentifier;
    NonStandardParameter GtkprRqst_nnStndrdDt;  /* optional */
    TransportAddress rasAddress;
    EndpointType    endpointType;
    GatekeeperIdentifier GtkprRqst_gtkprIdntfr;  /* optional */
    QseriesOptions  GtkprRqst_callServices;  /* optional */
    struct _seqof3 {
        struct _seqof3  *next;
        AliasAddress    value;
    } *GtkprRqst_endpointAlias;  /* optional */
} GatekeeperRequest;

typedef struct GatekeeperConfirm {
    unsigned char   bit_mask;
#       define      GtkprCnfrm_nnStndrdDt_present 0x80
#       define      GtkprCnfrm_gtkprIdntfr_present 0x40
    RequestSeqNum   requestSeqNum;
    struct ObjectID_ *protocolIdentifier;
    NonStandardParameter GtkprCnfrm_nnStndrdDt;  /* optional */
    GatekeeperIdentifier GtkprCnfrm_gtkprIdntfr;  /* optional */
    TransportAddress rasAddress;
} GatekeeperConfirm;

typedef struct GatekeeperRejectReason {
    unsigned short  choice;
#       define      GtkprRjctRsn_rsrcUnvlbl_chosen 1
#       define      terminalExcluded_chosen 2
#       define      GtkprRjctRsn_invldRvsn_chosen 3
#       define      GtkprRjctRsn_undfndRsn_chosen 4
    union _union {
        Nulltype        GtkprRjctRsn_rsrcUnvlbl;
        Nulltype        terminalExcluded;
        Nulltype        GtkprRjctRsn_invldRvsn;
        Nulltype        GtkprRjctRsn_undfndRsn;
    } u;
} GatekeeperRejectReason;

typedef struct GatekeeperReject {
    unsigned char   bit_mask;
#       define      GtkprRjct_nnStndrdDt_present 0x80
#       define      GtkprRjct_gtkprIdntfr_present 0x40
    RequestSeqNum   requestSeqNum;
    struct ObjectID_ *protocolIdentifier;
    NonStandardParameter GtkprRjct_nnStndrdDt;  /* optional */
    GatekeeperIdentifier GtkprRjct_gtkprIdntfr;  /* optional */
    GatekeeperRejectReason rejectReason;
} GatekeeperReject;

typedef struct RegistrationRequest {
    unsigned char   bit_mask;
#       define      RgstrtnRqst_nnStndrdDt_present 0x80
#       define      RgstrtnRqst_trmnlAls_present 0x40
#       define      RgstrtnRqst_gtkprIdntfr_present 0x20
    RequestSeqNum   requestSeqNum;
    struct ObjectID_ *protocolIdentifier;
    NonStandardParameter RgstrtnRqst_nnStndrdDt;  /* optional */
    ossBoolean      discoveryComplete;
    struct _seqof4 {
        struct _seqof4  *next;
        TransportAddress value;
    } *callSignalAddress;
    struct _seqof5 {
        struct _seqof5  *next;
        TransportAddress value;
    } *rasAddress;
    EndpointType    terminalType;
    struct _seqof6 {
        struct _seqof6  *next;
        AliasAddress    value;
    } *RgstrtnRqst_trmnlAls;  /* optional */
    GatekeeperIdentifier RgstrtnRqst_gtkprIdntfr;  /* optional */
    VendorIdentifier endpointVendor;
} RegistrationRequest;

typedef struct RegistrationConfirm {
    unsigned char   bit_mask;
#       define      RgstrtnCnfrm_nnStndrdDt_present 0x80
#       define      RgstrtnCnfrm_trmnlAls_present 0x40
#       define      RCm_gtkprIdntfr_present 0x20
    RequestSeqNum   requestSeqNum;
    struct ObjectID_ *protocolIdentifier;
    NonStandardParameter RgstrtnCnfrm_nnStndrdDt;  /* optional */
    struct _seqof7 {
        struct _seqof7  *next;
        TransportAddress value;
    } *callSignalAddress;
    struct _seqof8 {
        struct _seqof8  *next;
        AliasAddress    value;
    } *RgstrtnCnfrm_trmnlAls;  /* optional */
    GatekeeperIdentifier RCm_gtkprIdntfr;  /* optional */
    EndpointIdentifier endpointIdentifier;
} RegistrationConfirm;

typedef struct RegistrationRejectReason {
    unsigned short  choice;
#       define      discoveryRequired_chosen 1
#       define      RgstrtnRjctRsn_invldRvsn_chosen 2
#       define      invalidCallSignalAddress_chosen 3
#       define      invalidRASAddress_chosen 4
#       define      duplicateAlias_chosen 5
#       define      invalidTerminalType_chosen 6
#       define      RgstrtnRjctRsn_undfndRsn_chosen 7
#       define      transportNotSupported_chosen 8
    union _union {
        Nulltype        discoveryRequired;
        Nulltype        RgstrtnRjctRsn_invldRvsn;
        Nulltype        invalidCallSignalAddress;
        Nulltype        invalidRASAddress;
        struct _seqof9 {
            struct _seqof9  *next;
            AliasAddress    value;
        } *duplicateAlias;
        Nulltype        invalidTerminalType;
        Nulltype        RgstrtnRjctRsn_undfndRsn;
        Nulltype        transportNotSupported;
    } u;
} RegistrationRejectReason;

typedef struct RegistrationReject {
    unsigned char   bit_mask;
#       define      RgstrtnRjct_nnStndrdDt_present 0x80
#       define      RgstrtnRjct_gtkprIdntfr_present 0x40
    RequestSeqNum   requestSeqNum;
    struct ObjectID_ *protocolIdentifier;
    NonStandardParameter RgstrtnRjct_nnStndrdDt;  /* optional */
    RegistrationRejectReason rejectReason;
    GatekeeperIdentifier RgstrtnRjct_gtkprIdntfr;  /* optional */
} RegistrationReject;

typedef struct UnregistrationRequest {
    unsigned char   bit_mask;
#       define      UnrgstrtnRqst_endpntAls_present 0x80
#       define      URt_nnStndrdDt_1_present 0x40
#       define      URt_endpntIdntfr_present 0x20
    RequestSeqNum   requestSeqNum;
    struct _seqof10 {
        struct _seqof10 *next;
        TransportAddress value;
    } *callSignalAddress;
    struct _seqof11 {
        struct _seqof11 *next;
        AliasAddress    value;
    } *UnrgstrtnRqst_endpntAls;  /* optional */
    NonStandardParameter URt_nnStndrdDt_1;  /* optional */
    EndpointIdentifier URt_endpntIdntfr;  /* optional */
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    unsigned char   bit_mask;
#       define      UCm_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    NonStandardParameter UCm_nnStndrdDt;  /* optional */
} UnregistrationConfirm;

typedef struct UnregRejectReason {
    unsigned short  choice;
#       define      notCurrentlyRegistered_chosen 1
#       define      callInProgress_chosen 2
#       define      UnrgRjctRsn_undfndRsn_chosen 3
    union _union {
        Nulltype        notCurrentlyRegistered;
        Nulltype        callInProgress;
        Nulltype        UnrgRjctRsn_undfndRsn;
    } u;
} UnregRejectReason;

typedef struct UnregistrationReject {
    unsigned char   bit_mask;
#       define      URt_nnStndrdDt_2_present 0x80
    RequestSeqNum   requestSeqNum;
    UnregRejectReason rejectReason;
    NonStandardParameter URt_nnStndrdDt_2;  /* optional */
} UnregistrationReject;

typedef struct CallType {
    unsigned short  choice;
#       define      pointToPoint_chosen 1
#       define      oneToN_chosen 2
#       define      nToOne_chosen 3
#       define      nToN_chosen 4
    union _union {
        Nulltype        pointToPoint;
        Nulltype        oneToN;
        Nulltype        nToOne;
        Nulltype        nToN;
    } u;
} CallType;

typedef struct CallModel {
    unsigned short  choice;
#       define      direct_chosen 1
#       define      gatekeeperRouted_chosen 2
    union _union {
        Nulltype        direct;
        Nulltype        gatekeeperRouted;
    } u;
} CallModel;

typedef struct AdmissionRequest {
    unsigned char   bit_mask;
#       define      callModel_present 0x80
#       define      destinationInfo_present 0x40
#       define      destCallSignalAddress_present 0x20
#       define      destExtraCallInfo_present 0x10
#       define      srcCallSignalAddress_present 0x08
#       define      AdmssnRqst_nnStndrdDt_present 0x04
#       define      AdmssnRqst_callServices_present 0x02
    RequestSeqNum   requestSeqNum;
    CallType        callType;
    CallModel       callModel;  /* optional */
    EndpointIdentifier endpointIdentifier;
    struct _seqof12 {
        struct _seqof12 *next;
        AliasAddress    value;
    } *destinationInfo;  /* optional */
    TransportAddress destCallSignalAddress;  /* optional */
    struct _seqof13 {
        struct _seqof13 *next;
        AliasAddress    value;
    } *destExtraCallInfo;  /* optional */
    struct _seqof14 {
        struct _seqof14 *next;
        AliasAddress    value;
    } *srcInfo;
    TransportAddress srcCallSignalAddress;  /* optional */
    BandWidth       bandWidth;
    CallReferenceValue callReferenceValue;
    NonStandardParameter AdmssnRqst_nnStndrdDt;  /* optional */
    QseriesOptions  AdmssnRqst_callServices;  /* optional */
    ConferenceIdentifier conferenceID;
    ossBoolean      activeMC;
    ossBoolean      answerCall;
} AdmissionRequest;

typedef struct AdmissionConfirm {
    unsigned char   bit_mask;
#       define      irrFrequency_present 0x80
#       define      AdmssnCnfrm_nnStndrdDt_present 0x40
    RequestSeqNum   requestSeqNum;
    BandWidth       bandWidth;
    CallModel       callModel;
    TransportAddress destCallSignalAddress;
    unsigned short  irrFrequency;  /* optional */
    NonStandardParameter AdmssnCnfrm_nnStndrdDt;  /* optional */
} AdmissionConfirm;

typedef struct AdmissionRejectReason {
    unsigned short  choice;
#       define      calledPartyNotRegistered_chosen 1
#       define      ARRn_invldPrmssn_chosen 2
#       define      AdmssnRjctRsn_rqstDnd_chosen 3
#       define      AdmssnRjctRsn_undfndRsn_chosen 4
#       define      callerNotRegistered_chosen 5
#       define      routeCallToGatekeeper_chosen 6
#       define      invldEndpntIdntfr_chosen 7
#       define      AdmssnRjctRsn_rsrcUnvlbl_chosen 8
    union _union {
        Nulltype        calledPartyNotRegistered;
        Nulltype        ARRn_invldPrmssn;
        Nulltype        AdmssnRjctRsn_rqstDnd;
        Nulltype        AdmssnRjctRsn_undfndRsn;
        Nulltype        callerNotRegistered;
        Nulltype        routeCallToGatekeeper;
        Nulltype        invldEndpntIdntfr;
        Nulltype        AdmssnRjctRsn_rsrcUnvlbl;
    } u;
} AdmissionRejectReason;

typedef struct AdmissionReject {
    unsigned char   bit_mask;
#       define      AdmssnRjct_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    AdmissionRejectReason rejectReason;
    NonStandardParameter AdmssnRjct_nnStndrdDt;  /* optional */
} AdmissionReject;

typedef struct BandwidthRequest {
    unsigned char   bit_mask;
#       define      callType_present 0x80
#       define      BndwdthRqst_nnStndrdDt_present 0x40
    RequestSeqNum   requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    CallType        callType;  /* optional */
    BandWidth       bandWidth;
    NonStandardParameter BndwdthRqst_nnStndrdDt;  /* optional */
} BandwidthRequest;

typedef struct BandwidthConfirm {
    unsigned char   bit_mask;
#       define      BndwdthCnfrm_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    BandWidth       bandWidth;
    NonStandardParameter BndwdthCnfrm_nnStndrdDt;  /* optional */
} BandwidthConfirm;

typedef struct BandRejectReason {
    unsigned short  choice;
#       define      notBound_chosen 1
#       define      invalidConferenceID_chosen 2
#       define      BndRjctRsn_invldPrmssn_chosen 3
#       define      insufficientResources_chosen 4
#       define      BndRjctRsn_invldRvsn_chosen 5
#       define      BndRjctRsn_undfndRsn_chosen 6
    union _union {
        Nulltype        notBound;
        Nulltype        invalidConferenceID;
        Nulltype        BndRjctRsn_invldPrmssn;
        Nulltype        insufficientResources;
        Nulltype        BndRjctRsn_invldRvsn;
        Nulltype        BndRjctRsn_undfndRsn;
    } u;
} BandRejectReason;

typedef struct BandwidthReject {
    unsigned char   bit_mask;
#       define      BndwdthRjct_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth       allowedBandWidth;
    NonStandardParameter BndwdthRjct_nnStndrdDt;  /* optional */
} BandwidthReject;

typedef struct DisengageReason {
    unsigned short  choice;
#       define      forcedDrop_chosen 1
#       define      normalDrop_chosen 2
#       define      DsnggRsn_undefinedReason_chosen 3
    union _union {
        Nulltype        forcedDrop;
        Nulltype        normalDrop;
        Nulltype        DsnggRsn_undefinedReason;
    } u;
} DisengageReason;

typedef struct DisengageRequest {
    unsigned char   bit_mask;
#       define      DsnggRqst_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
    NonStandardParameter DsnggRqst_nnStndrdDt;  /* optional */
} DisengageRequest;

typedef struct DisengageConfirm {
    unsigned char   bit_mask;
#       define      UCm_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    NonStandardParameter UCm_nnStndrdDt;  /* optional */
} DisengageConfirm;

typedef struct DisengageRejectReason {
    unsigned short  choice;
#       define      DsnggRjctRsn_ntRgstrd_chosen 1
#       define      requestToDropOther_chosen 2
    union _union {
        Nulltype        DsnggRjctRsn_ntRgstrd;
        Nulltype        requestToDropOther;
    } u;
} DisengageRejectReason;

typedef struct DisengageReject {
    unsigned char   bit_mask;
#       define      DsnggRjct_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    DisengageRejectReason rejectReason;
    NonStandardParameter DsnggRjct_nnStndrdDt;  /* optional */
} DisengageReject;

typedef struct LocationRequest {
    unsigned char   bit_mask;
#       define      LctnRqst_endpntIdntfr_present 0x80
#       define      LctnRqst_nnStndrdDt_present 0x40
    RequestSeqNum   requestSeqNum;
    EndpointIdentifier LctnRqst_endpntIdntfr;  /* optional */
    struct _seqof15 {
        struct _seqof15 *next;
        AliasAddress    value;
    } *destinationInfo;
    NonStandardParameter LctnRqst_nnStndrdDt;  /* optional */
    TransportAddress replyAddress;
} LocationRequest;

typedef struct LocationConfirm {
    unsigned char   bit_mask;
#       define      LctnCnfrm_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
    NonStandardParameter LctnCnfrm_nnStndrdDt;  /* optional */
} LocationConfirm;

typedef struct LocationRejectReason {
    unsigned short  choice;
#       define      LctnRjctRsn_ntRgstrd_chosen 1
#       define      LctnRjctRsn_invldPrmssn_chosen 2
#       define      LctnRjctRsn_rqstDnd_chosen 3
#       define      LctnRjctRsn_undfndRsn_chosen 4
    union _union {
        Nulltype        LctnRjctRsn_ntRgstrd;
        Nulltype        LctnRjctRsn_invldPrmssn;
        Nulltype        LctnRjctRsn_rqstDnd;
        Nulltype        LctnRjctRsn_undfndRsn;
    } u;
} LocationRejectReason;

typedef struct LocationReject {
    unsigned char   bit_mask;
#       define      LctnRjct_nnStndrdDt_present 0x80
    RequestSeqNum   requestSeqNum;
    LocationRejectReason rejectReason;
    NonStandardParameter LctnRjct_nnStndrdDt;  /* optional */
} LocationReject;

typedef struct InfoRequest {
    unsigned char   bit_mask;
#       define      InfRqst_nonStandardData_present 0x80
#       define      replyAddress_present 0x40
    RequestSeqNum   requestSeqNum;
    CallReferenceValue callReferenceValue;
    NonStandardParameter InfRqst_nonStandardData;  /* optional */
    TransportAddress replyAddress;  /* optional */
} InfoRequest;

typedef struct TransportChannelInfo {
    unsigned char   bit_mask;
#       define      sendAddress_present 0x80
#       define      recvAddress_present 0x40
    TransportAddress sendAddress;  /* optional */
    TransportAddress recvAddress;  /* optional */
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    char            *cname;
    unsigned int    ssrc;
    unsigned short  sessionId;
    struct _seqof16 {
        struct _seqof16 *next;
        unsigned short  value;
    } *associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse {
    unsigned char   bit_mask;
#       define      InfRqstRspns_nnStndrdDt_present 0x80
#       define      InfRqstRspns_endpntAls_present 0x40
#       define      perCallInfo_present 0x20
    NonStandardParameter InfRqstRspns_nnStndrdDt;  /* optional */
    RequestSeqNum   requestSeqNum;
    EndpointType    endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    struct _seqof20 {
        struct _seqof20 *next;
        TransportAddress value;
    } *callSignalAddress;
    struct _seqof21 {
        struct _seqof21 *next;
        AliasAddress    value;
    } *InfRqstRspns_endpntAls;  /* optional */
    struct _seqof22 {
        struct _seqof22 *next;
        struct {
            unsigned char   bit_mask;
#               define      prCllInf_nnStndrdDt_present 0x80
#               define      originator_present 0x40
#               define      audio_present 0x20
#               define      video_present 0x10
#               define      data_present 0x08
            NonStandardParameter prCllInf_nnStndrdDt;  /* optional */
            CallReferenceValue callReferenceValue;
            ConferenceIdentifier conferenceID;
            ossBoolean      originator;  /* optional */
            struct _seqof17 {
                struct _seqof17 *next;
                RTPSession      value;
            } *audio;  /* optional */
            struct _seqof18 {
                struct _seqof18 *next;
                RTPSession      value;
            } *video;  /* optional */
            struct _seqof19 {
                struct _seqof19 *next;
                TransportChannelInfo value;
            } *data;  /* optional */
            TransportChannelInfo h245;
            TransportChannelInfo callSignaling;
            CallType        callType;
            BandWidth       bandWidth;
            CallModel       callModel;
        } value;
    } *perCallInfo;  /* optional */
} InfoRequestResponse;

typedef struct NonStandardMessage {
    RequestSeqNum   requestSeqNum;
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct UnknownMessageResponse {
    RequestSeqNum   requestSeqNum;
} UnknownMessageResponse;

typedef struct RasMessage {
    unsigned short  choice;
#       define      gatekeeperRequest_chosen 1
#       define      gatekeeperConfirm_chosen 2
#       define      gatekeeperReject_chosen 3
#       define      registrationRequest_chosen 4
#       define      registrationConfirm_chosen 5
#       define      registrationReject_chosen 6
#       define      unregistrationRequest_chosen 7
#       define      unregistrationConfirm_chosen 8
#       define      unregistrationReject_chosen 9
#       define      admissionRequest_chosen 10
#       define      admissionConfirm_chosen 11
#       define      admissionReject_chosen 12
#       define      bandwidthRequest_chosen 13
#       define      bandwidthConfirm_chosen 14
#       define      bandwidthReject_chosen 15
#       define      disengageRequest_chosen 16
#       define      disengageConfirm_chosen 17
#       define      disengageReject_chosen 18
#       define      locationRequest_chosen 19
#       define      locationConfirm_chosen 20
#       define      locationReject_chosen 21
#       define      infoRequest_chosen 22
#       define      infoRequestResponse_chosen 23
#       define      nonStandardMessage_chosen 24
#       define      unknownMessageResponse_chosen 25
    union _union {
        GatekeeperRequest gatekeeperRequest;
        GatekeeperConfirm gatekeeperConfirm;
        GatekeeperReject gatekeeperReject;
        RegistrationRequest registrationRequest;
        RegistrationConfirm registrationConfirm;
        RegistrationReject registrationReject;
        UnregistrationRequest unregistrationRequest;
        UnregistrationConfirm unregistrationConfirm;
        UnregistrationReject unregistrationReject;
        AdmissionRequest admissionRequest;
        AdmissionConfirm admissionConfirm;
        AdmissionReject admissionReject;
        BandwidthRequest bandwidthRequest;
        BandwidthConfirm bandwidthConfirm;
        BandwidthReject bandwidthReject;
        DisengageRequest disengageRequest;
        DisengageConfirm disengageConfirm;
        DisengageReject disengageReject;
        LocationRequest locationRequest;
        LocationConfirm locationConfirm;
        LocationReject  locationReject;
        InfoRequest     infoRequest;
        InfoRequestResponse infoRequestResponse;
        NonStandardMessage nonStandardMessage;
        UnknownMessageResponse unknownMessageResponse;
    } u;
} RasMessage;


extern void *gkpdu;    /* encoder-decoder control table */
#ifdef __cplusplus
}	/* extern "C" */
#endif /* __cplusplus */
#endif /* OSS_gkpdu */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\port32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  
//   This source is supplied under the terms of a licence agreement or
//   non-disclosure statement with Intel Corporation and may not be copied
//   nor disclosed except in accordance with the terms of that agreement.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PORT32.H
// Stuff to make porting from Win3.1 to Win32 a little less hellish.
//////////////////////////////////////////////////////////////////////////////
#ifndef PORT32_H
#define PORT32_H


//////////////////////////////////////////////////////////////////////////////
// some convenient, explicit types
//////////////////////////////////////////////////////////////////////////////
typedef short INTEGER_16;
typedef int INTEGER_32;
typedef unsigned short UINTEGER_16;
typedef unsigned int UINTEGER_32;
typedef short BOOLEAN_16;

typedef short INT16;
typedef int INT32;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
typedef short BOOL16;
	
//////////////////////////////////////////////////////////////////////////////
// macros to make old keywords go away
//////////////////////////////////////////////////////////////////////////////
#define __pascal
#define _pascal
#define _far
#define __far
#define _export
#define __export
#define _huge
#define huge
#define __huge
#define  __segment
#define _HFAR_
#define _loadds
#define __loadds

//////////////////////////////////////////////////////////////////////////////
// other macros that may or may not be handy
//////////////////////////////////////////////////////////////////////////////
#define WRITE OF_WRITE

#define OFFSETOF(lp)        (int) (lp)
#define SELECTOROF

#define GLOBALHANDLE(lp)      GlobalHandle(lp)
#define GLOBALHANDLEFUNC(lp)  GlobalHandle(lp)
#define LOCALHANDLE(lp)       LocalHandle(lp)
#define LOCALHANDLEFUNC(lp)   LocalHandle(lp)


#define _AfxGetPtrFromFarPtr(p)   ((void*)(p))
#define GETWINDOWHINSTANCE(hWnd)  GetWindowLong(hWnd ,GWL_HINSTANCE)
#define GETWINDOWHPARENT(hWnd)    GetWindowLong(hWnd, GWL_HWNDPARENT)
#define GETWINDOWID(hWnd)         GetWindowLong(hWnd, GWL_ID)

#define SETCLASSCURSOR(hWnd,NewVal)  SetClassLong(hWnd ,GCL_HCURSOR,NewVal)

//////////////////////////////////////////////////////////////////////////////
// Name of shared mutex for serializing access to 16-bit data stack
//////////////////////////////////////////////////////////////////////////////
#define STR_DATASTACKMUX "_mux_DataStack"

#endif // PORT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.4  $
      $Date:   01 Oct 1996 11:14:54  $
    $Author:   EHOWARDX  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

#if defined(ISRDBG32_C)
#define ISR_DLL      DllExport
#else
#define ISR_DLL      DllImport
#endif

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (128*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (256*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define ISR_DBG 				0
#define ISR_ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
ISR_DLL void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

ISR_DLL void WINAPI DLL_EXPORT
ISR_ClearItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void);

ISR_DLL ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

ISR_DLL ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

ISR_DLL int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if defined(DBG) && defined(ISRDBG)

#define ISRDEBUGINFO    1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\isrg_org.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.4  $
      $Date:   01 Oct 1996 11:14:54  $
    $Author:   EHOWARDX  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

#if defined(ISRDBG32_C)
#define ISR_DLL      DllExport
#else
#define ISR_DLL      DllImport
#endif

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (128*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (256*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define DBG 				0
#define ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
ISR_DLL void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
ISR_DLL void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

ISR_DLL void WINAPI DLL_EXPORT
ISR_ClearItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void);

ISR_DLL ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

ISR_DLL ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

ISR_DLL int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
ISR_DLL void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\list.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/list.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.1  $
 *	$Date:   22 Jul 1996 09:45:08  $
 *	$Author:   RKUHN  $
 *
 *	Deliverable: msm.dll
 *
 *	Abstract: Media Service Manager "windows app code" header file.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef LIST_H
#define LIST_H

#ifdef __cplusplus
extern "C" {                    // Assume C Declarations for C++.
#endif // __cplusplus


#define LISTTIMEOUT		2000

typedef struct _LISTNODE
{
	struct _LISTNODE	*pPrev;
	struct _LISTNODE	*pNext;
	LPVOID				pObject;
}
LISTNODE, *LPLISTNODE;


typedef struct _LIST
{
	LPLISTNODE			pHead;
	LPLISTNODE			pTail;
	UINT				uCount;
	CRITICAL_SECTION	csList;
}
LIST, *LPLIST;


BOOL		LIST_Create (LPLIST);
BOOL		LIST_Destroy (LPLIST);

LPLISTNODE	LIST_AddHead (LPLIST, LPVOID);
LPLISTNODE	LIST_AddTail (LPLIST, LPVOID);
LPLISTNODE	LIST_AddNode (LPLIST, LPLISTNODE, LPVOID);

LPVOID		LIST_RemoveHead (LPLIST);
LPVOID		LIST_RemoveTail (LPLIST);
LPVOID		LIST_RemoveAt (LPLIST, LPLISTNODE);
void		LIST_RemoveAll (LPLIST);

LPLISTNODE	LIST_GetHeadNode (LPLIST);
LPLISTNODE	LIST_GetTailNode (LPLIST);
LPVOID		LIST_GetNext (LPLIST, LPLISTNODE*);
LPVOID		LIST_GetPrev (LPLIST, LPLISTNODE*);
LPVOID		LIST_GetAt (LPLIST, LPLISTNODE);

UINT		LIST_GetCount (LPLIST);

LPLISTNODE	LIST_Find (LPLIST, LPLISTNODE, LPVOID);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\linkapi.h ===
/***************************************************************************
 *
 * File: linkapi.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   linkapi.h  $
 * $Revision:   1.17  $
 * $Modtime:   11 Dec 1996 13:57:14  $
 * $Log:   S:\sturgeon\src\include\vcs\linkapi.h_v  $
 * 
 *    Rev 1.17   11 Dec 1996 14:10:48   SBELL1
 * changed parameters to linkLayerInit/Listen
 * 
 *    Rev 1.16.1.0   11 Dec 1996 13:57:14   SBELL1
 * CHanged parameters to linkLayerInit and Listen.
 * 
 *    Rev 1.16   14 Oct 1996 14:00:20   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.15   15 Aug 1996 14:00:08   rodellx
 * 
 * Added additional address validation error case for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 * 
 *    Rev 1.14   11 Jul 1996 18:42:10   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.13   10 Jul 1996 21:36:26   rodellx
 * 
 * Changed error code base to required value defined by apierror.h.
 * 
 *    Rev 1.12   May 28 1996 18:09:08   plantz
 * Change all error and message codes to use HRESULT. Deleted unused codes.
 * 
 *    Rev 1.11   09 May 1996 18:28:36   EHOWARDX
 * Eliminated unnessary formal parameters.
 * 
 *    Rev 1.4   25 Apr 1996 21:43:50   helgebax
 * Copied Philip's changes from sturgeon\src\include.
 * 
 *    Rev 1.10   Apr 25 1996 21:07:16   plantz
 * Add messages for connect callback.
 * Add connect callback parameter to link layer accept.
 * 
 *    Rev 1.9   Apr 25 1996 15:36:50   plantz
 * Remove #include incommon.h and dependencies on types defined in incommon
 * (use pointers to incomplete structure types instead).
 * 
 *    Rev 1.8   Apr 24 1996 20:54:08   plantz
 * Change name of H245LISTENCALLBACK to H245CONNECTCALLBACK and add additional
 * parameters. Add it as an parameter to linkLayerConnect as well as
 * linkLayerListen.
 * 
 *    Rev 1.7   Apr 24 1996 17:00:04   plantz
 * Merge 1.3.1.0 with 1.6 (changes to support Q931).
 * 
 *    Rev 1.6   19 Apr 1996 10:35:36   EHOWARDX
 * Encorporate Dan's latest SRPAPI.H changes.
 * 
 *    Rev 1.3.1.0   Apr 23 1996 13:45:26   plantz
 * Changes to support Q.931.
 * 
 *****************************************************************************/

#ifndef LINKAPI_H
#define LINKAPI_H

#include "apierror.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

#if defined(REMOVE_FROM_TSP)

// declare exported functions
#if defined(LINKDLL_EXPORT)
#define LINKDLL __declspec (dllexport)
#else   // (LINKDLL_EXPORT)
#define LINKDLL __declspec (dllimport)
#endif  // (LINKDLL_EXPORT)
#define SRPDLL LINKDLL

#else

#define LINKDLL
#define SRPDLL

#endif


////////////////////////////////////////////////////////////////////////////
//
// Link Layer defaults
//
////////////////////////////////////////////////////////////////////////////

#define INVALID_PHYS_ID			(DWORD) 0xffffffff


////////////////////////////////////////////////////////////////////////////
//
// Link Layer Error defines
//
////////////////////////////////////////////////////////////////////////////

#define LINK_ERROR_BASE        ERROR_LOCAL_BASE_ID
#define LINK_SEND_ERROR_BASE   LINK_ERROR_BASE + 0x100
#define LINK_SEND_COMP_BASE    LINK_ERROR_BASE + 0x200
#define LINK_RCV_ERROR_BASE    LINK_ERROR_BASE + 0x300
#define LINK_RCV_COMP_BASE     LINK_ERROR_BASE + 0x400
#define LINK_UTIL_ERROR_BASE   LINK_ERROR_BASE + 0x500
#define LINK_UTIL_COMP_BASE    LINK_ERROR_BASE + 0x600
#define LINK_FATAL_ERROR       LINK_ERROR_BASE + 0x700
#define LINK_CONN_ERROR_BASE   LINK_ERROR_BASE + 0x800
#define LINK_CONN_COMP_BASE    LINK_ERROR_BASE + 0x900

////////////////////////////////////////////////////////////////////////////
//
// CallBack Prototype for Channel CallBack
//
////////////////////////////////////////////////////////////////////////////

typedef void (*H245SRCALLBACK)
(
    DWORD       dwH245Instance,
    HRESULT     dwMessage,
    PBYTE       pbyDataBuf,
    DWORD       dwLength
);

// Link Send Callback error codes
#define LINK_SEND_COMPLETE     MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 0)
#define LINK_SEND_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 5) // Tx aborted the SDU (not implemented)
#define LINK_SEND_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+20)
#define LINK_SEND_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+22)
#define LINK_SEND_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+23)

// Link Receive Callback error codes
#define LINK_RECV_DATA         MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 6) // DATA.INDICATION from H.223 (Should not be zero)
#define LINK_RECV_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 7) // Tx aborted the SDU (not implemented)
#define LINK_RECV_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+10) // from AL2 - _CRC error
#define LINK_RECV_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+20)
#define LINK_RECV_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+22)

typedef void (*H245CONNECTCALLBACK)
(
   DWORD       dwH245Instance,
   HRESULT     dwMessage,
   struct _ADDR *LocalAddr,
   struct _ADDR *PeerAddr
);

#define LINK_CONNECT_REQUEST   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+1)
#define LINK_CONNECT_COMPLETE  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+2)

////////////////////////////////////////////////////////////////////////////
//
// Link Layer Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

/**************************************************************************
**	Function 	: linkLayerInit
**	Description : This function will initialize the datalink subsystem. 
**				  This in turn will make appropriate calls to initialize 
**				  the software and hardware subsystems below this layer. 
**				  linkLayernit() has to be called before any other service or
**				  System control functions are used.
****************************************************************************/
LINKDLL HRESULT
linkLayerInit
(
    DWORD*           pdwPhysicalId,
    DWORD           dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

typedef
HRESULT 
(*PFxnlinkLayerInit)
(
    DWORD*           pdwPhysicalId,
    DWORD           dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

///////////////////////////////////////////////////////////////
///
///	SRP Initialization defines
///
///////////////////////////////////////////////////////////////

#define LINK_INVALID_INSTANCE    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+1)
#define LINK_DUPLICATE_INSTANCE  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+2)
#define LINK_MEM_FAILURE         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, ERROR_OUTOFMEMORY)
#define LINK_INVALID_STATE       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+6)



/**************************************************************************
**	Function 	: linkLayerShutdown
**	Description : This releases all the memory the link layer used for a particular 
**				  instance. For using any of the linklayer services in that 
**				  instance again, a linkLayerInit has to be called. 
**				  This function will shutdown the linklayer session pointed 
**				  by the dwPhysicalID.
***************************************************************************/
LINKDLL HRESULT
linkLayerShutdown
(DWORD dwPhysicalId);



typedef
 HRESULT 
(*PFxnlinkLayerShutdown)
(DWORD dwPhysicalId);



///////////////////////////////////////////////////////////////
///
///	SRP Termination defines
///
///////////////////////////////////////////////////////////////

/**************************************************************************
**	Function 	: linkLayerGetInstance
**	Description : Returns the link layer instance corresponding to a physical ID
***************************************************************************/
LINKDLL DWORD
linkLayerGetInstance
(DWORD dwPhysicalId);



typedef
DWORD  
(*PFxnlinkLayerGetInstance)
(DWORD dwPhysicalId);



/**************************************************************************
**	Function 	: datalinkReceiveRequest
**	Description : Posts one receive message buffer to the link layer subsystem. 
**				  This buffer will be filled in by the incoming message for
** 				  the specified channel. H223_DATA_INDICATION will be sendto 
**				  the client on receiving a complete PDU. Error messages may also be 
**				  reported.
***************************************************************************/
LINKDLL HRESULT
datalinkReceiveRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT  
(*PFxndatalinkReceiveRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Receive Request return codes

#define LINK_RECV_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_ERROR_BASE+ 2) // No room for buffering


/**************************************************************************
**	Function 	: datalinkCancelReceiveRequest
**	Description : Posts one receive message buffer to the link layer subsystem. 
**				  This buffer will be filled in by the incoming message for
** 				  the specified channel. H223_DATA_INDICATION will be sendto 
**				  the client on receiving a complete PDU. Error messages may also be 
**				  reported.
***************************************************************************/
LINKDLL HRESULT
datalinkCancelReceiveRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf
);

typedef
HRESULT  
(*PFxndatalinkCancelReceiveRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf
);


/**************************************************************************
**	Function 	: datalinkSendRequest
**	Description : Hands over the message to be sent to the link layer subsystem.
***************************************************************************/
LINKDLL HRESULT
datalinkSendRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT  
(*PFxndatalinkSendRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Send Request return codes

#define LINK_SEND_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_ERROR_BASE+2)


/**************************************************************************
**	Function 	: linkLayerFlushChannel
**	Description : All the posted transmit and/or receive buffers are released.
**					The bitmasks DATALINK_RECEIVE and DATALINK_RECEIVE can
**					be OR'd together to perform both functions in the same call
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushChannel
(DWORD dwPhysicalId, DWORD dwDirectionMask);




typedef
HRESULT 
(*PFxnlinkLayerFlushChannel)
(DWORD dwPhysicalId, DWORD dwDirectionMask);




// Bits for dwDirectionMask
#define DATALINK_RECEIVE      0x01  // Flush buffer in receive direction
#define DATALINK_TRANSMIT     0x02  // Flush buffer in Transmit direction
#define DATALINK_TX_ACTIVES   0x04  // Flush buffers actively being transmitted
#define SHUTDOWN_PENDING      0x08  // Shutdown is in progress
#define FLUSH_SYNCH           0x10  // 0: Asynch call, 1: Synchronous call
#define DATALINK_TRANSMIT_ALL (DATALINK_TRANSMIT | DATALINK_TX_ACTIVES)
#define SHUTDOWN_MASK         (DATALINK_RECEIVE | DATALINK_TRANSMIT | SHUTDOWN_PENDING)


// linkLayerFlushChannel Callback

#define LINK_FLUSH_COMPLETE   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_UTIL_COMP_BASE+1)


/**************************************************************************
**	Function 	: linkLayerFlushAll
**	Description : All the posted transmit and/or receive buffers are released.
**					Same as LinkLayerFlushChannel except:
**					1) Synchronous Call
**					2) Transmit Buffers in progress are flushed
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushAll
(DWORD	dwPhysicalId);



typedef
HRESULT 
(*PFxnlinkLayerFlushAll)
(DWORD	dwPhysicalId);



// linkLayerFlushChannel RETURN CODES same as for linkLayerFlushChannel

#define LINK_UNKNOWN_ADDR      MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, LINK_UTIL_ERROR_BASE + 1)

LINKDLL HRESULT
linkLayerConnect(DWORD dwPhysicalId, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerListen(DWORD* dwPhysicalId, DWORD dwH245Instance, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback);


#define LL_PDU_SIZE             2048

/**************************************************************************
**
**  Dynamic DLL Function Calls
**
**************************************************************************/
#ifdef UNICODE
#define SRPDLLFILE          L"h245srp.dll"
#define H245WSDLLFILE       L"h245ws.dll"
#else
#define SRPDLLFILE          "h245srp.dll"
#define H245WSDLLFILE       "h245ws.dll"
#endif

#if defined(REMOVE_FROM_TSP)

#define LINKINITIALIZE      __TEXT("linkLayerInit")
#define LINKSHUTDOWN        __TEXT("linkLayerShutdown")
#define LINKGETINSTANCE     __TEXT("linkLayerGetInstance")
#define LINKRECEIVEREQUEST  __TEXT("datalinkReceiveRequest")
#define LINKSENDREQUEST     __TEXT("datalinkSendRequest")
#define LINKFLUSHCHANNEL    __TEXT("linkLayerFlushChannel")
#define LINKFLUSHALL        __TEXT("linkLayerFlushAll")

#endif  // REMOVE_FROM_TSP

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // LINKAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\ppmif.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/ppmif.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   30 Jul 1996 15:18:58  $
 *	$Author:   SLI  $
 *
 *	Deliverable: audmsp32.dll
 *
 *	Abstract: 32-bit Audio Source/Sink Media Service Provider code.
 *
 *	Notes: 
 *
 ***************************************************************************/

#ifndef PPMIF_H
#define PPMIF_H

#include "ippm.h"			// PPM interface include file
							// Includes isubmit.h

#define		ulong					ULONG
#define     MAX_PPM_PACKET_SIZE     1000
#define		G723_CODEC				723
#define		G711_ALAW_CODEC			711
#define		G711_MULAW_CODEC		712
#define		H263_CODEC				263
#define		H261_CODEC				261
#define     IVI41_CODEC				41
#define		LH_CODEC				111
#define		GENERIC_CODEC			999

extern BOOL	bCOMInitialized;

// MSP COM Interfaces to provide to PPM
// The Send and Receive interfaces use ISubmit/ISubmitCallback. The new interface
// also implies that the SRC (ISubmit) side allocates and manages buffers.

class MSPISubmit : public ISubmit 
{
public:
     LPVOID m_pToken;
	 LPVOID	m_pParent;
     ISubmitCallback* m_pPPMISubmitCallback;

	 // IUnknown Interface functions
	 STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
     STDMETHODIMP_ ( ULONG )AddRef(void){ return 0; }
     STDMETHODIMP_ ( ULONG )Release(void){ return 0; }

	 // ISubmit functions
     STDMETHOD(InitSubmit)(ISubmitCallback* pSubmitCallback);
     STDMETHOD(Submit)(WSABUF* pWSABuffer, DWORD BufferCount, void *pUserToken, HRESULT Error);
	 STDMETHOD_(void,ReportError)(HRESULT Error);
	 STDMETHOD(Flush)(void);

	 // Constructor and Destructor
     MSPISubmit(LPVOID pToken, LPVOID pParent); // { m_pPPMISubmitCallback = NULL; }
     ~MSPISubmit();
};

class MSPISubmitCB : public ISubmitCallback 
{
public:
     LPVOID m_pToken;

	 // IUnknown Interface functions
	 STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
     STDMETHODIMP_ ( ULONG )AddRef(void){ return 0; }
     STDMETHODIMP_ ( ULONG )Release(void){ return 0; }
     
	 // ISubmitCallback functions 
     STDMETHOD_(void,SubmitComplete)(void *pUserToken, HRESULT Error);
	 STDMETHOD_(void,ReportError)(HRESULT Error, int Value);

	 MSPISubmitCB(LPVOID	pToken);
	 ~MSPISubmitCB() {};
};

class MSPPPMInterface
{
public:
	// Our interfaces to PPM
	MSPISubmit			*pMSPISubmit;
	MSPISubmitCB		*pMSPISubmitCB;

public:
	// PPM's interfaces we call
	ISubmit				*pPPMISubmit;
	ISubmitUser			*pPPMISubmitUser;
	ISubmitCallback		*pPPMISubmitCB;

	// PPM's interface to initialize either send or receive
	IPPMSend            *pPPMInitISend;
	IPPMReceive         *pPPMInitIReceive;

	// Constructor and destructor
	MSPPPMInterface ();
	~MSPPPMInterface ();

	BOOL InitMSPPPMInterface (LPVOID pToken, BOOL IsSrcMsp, UINT CodecType);
	BOOL InitMSPPPMInterface (LPVOID pToken, BOOL IsSrcMsp, GUID guidPPMClass);

	HRESULT	Submit(WSABUF	*pWSABuffer,
				   DWORD	BufferCount,
				   void	*pCookie);

	HRESULT	Submit(WSABUF	*pWSABuffer,
				   DWORD	BufferCount,
				   void		*pCookie,
				   HRESULT	hresult);

	void	SubmitComplete(void	*pCookie,
						   HRESULT	Error);

	void	SetSession (PPMSESSPARAM_T *pSessparam);

	void Flush();
private:
	BOOL	m_bIsSrcMsp;

};

extern void
ProcessSubmitCompleteFromPPM
(
	LPVOID		pToken,
	LPVOID		pCookie, 
	DWORD		dwError
);

extern HRESULT
ProcessSubmitFromPPM
(
	LPVOID		pToken,
	LPWSABUF	pWSABuf, 
	DWORD		dwBufferCount,
	LPVOID		pCookie
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\mspbuffs.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/mspbuffs.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.7  $
 *	$Date:   Apr 25 1996 10:46:04  $
 *	$Author:   MLEWIS1  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/
#ifndef MSPBUFFS_H
#define MSPBUFFS_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

//////////////////////////////////////////////////////
// Buffer Manager typedef Section
//////////////////////////////////////////////////////

typedef DWORD STATUS, *LPSTATUS;
typedef LPBYTE BUFPTR; 
typedef DWORD HBUFQUEUE;

//////////////////////////////////////////////////////
// Buffer Manager Error Code Section
//////////////////////////////////////////////////////

#define MBE_OK	   0
#define MBE_EMPTY  1000
#define MBE_NOMEM  1001
#define MBE_PARAM  1002
#define MBE_STATE  1003
#define MBE_EMPTYQ MBE_EMPTY

//////////////////////////////////////////////////////
// Buffer Manager Prototypes Section
//////////////////////////////////////////////////////

// create a buffer of the specified size
BUFPTR MB_CreateBuffer(UINT size, LPSTATUS lpStatus);

// delete the buffer.  must not be on a queue
STATUS MB_DeleteBuffer(BUFPTR pBuf);

// get the size a buffer
UINT MB_BufSize(BUFPTR pBuf);

// associate user data with a buffer
STATUS MB_Associate(BUFPTR pBuf, LPVOID pAssc);

// retrieve the user data associated with a buffer
LPVOID MB_GetAssociation(BUFPTR pBuf, LPSTATUS lpStatus);

//////////////////////////////////////////////////////
// Queue Manager Prototypes Section
//////////////////////////////////////////////////////

// create a FIFO queue (empty)
HBUFQUEUE MB_CreateQueue(LPSTATUS lpStatus);

// delete the FIFO queue.  must be empty
STATUS MB_DeleteQueue(HBUFQUEUE hQue);

// add a buffer to the tail of the queue
STATUS MB_Enqueue(HBUFQUEUE hQue, BUFPTR pBuf);

// get the next buffer from the head of the queue (NULL if empty)
BUFPTR MB_Dequeue(HBUFQUEUE hQue, LPSTATUS lpStatus);

// remove a specified buffer from anywhere in the queue
STATUS MB_Remove(HBUFQUEUE hQue, BUFPTR pBuf);

// refer to buffer on the head of the queue	(not dequeued, NULL if empty)
BUFPTR MB_Front(HBUFQUEUE hQue, LPSTATUS lpStatus);

// refer to buffer at the tail of the queue	(not dequeued, NULL if empty)
BUFPTR MB_Back(HBUFQUEUE hQue, LPSTATUS lpStatus);

// refer to next buffer in the queue (NULL if last)
BUFPTR MB_Next(BUFPTR pBuf, LPSTATUS lpStatus);

// refer to previous buffer in the queue (NULL if first)
BUFPTR MB_Prev(BUFPTR pBuf, LPSTATUS lpStatus);

// count of buffers in a queue
UINT MB_QCount(HBUFQUEUE hQue, LPSTATUS lpStatus);

// get a buffer with specified associated data (dequeued, NULL if not found)
BUFPTR MB_RemoveByAssociation(HBUFQUEUE hQue, LPVOID pAssc, LPSTATUS lpStatus);

// get the queue a buffer is on (NULL if not on queue)
HBUFQUEUE MB_OnQueue(BUFPTR pBuf, LPSTATUS lpStatus);

// add a buffer to the head of the queue
STATUS MB_GetAndResetWatermarks(HBUFQUEUE hQue, UINT *lpHiWater, UINT *lpLoWater);

// Get and reset watermarks on the queue
STATUS MB_Requeue(HBUFQUEUE hQue, BUFPTR pBuf);

// get a buffer with specified associated data ( leave queued, NULL if not found)
BUFPTR MB_FindByAssociation(HBUFQUEUE hQue, LPVOID pAssc, LPSTATUS lpStatus);

// Restrict queue access to the calling thread
STATUS MB_QLock(HBUFQUEUE hQue);

// Restore queue access to all threads
STATUS MB_QUnlock(HBUFQUEUE hQue);

//////////////////////////////////////////////////////
// Pool Manager Prototypes Section
//////////////////////////////////////////////////////

// create a pool(queue) with the specified number and size of buffers
HBUFQUEUE MB_CreatePool(UINT bufSize, UINT count, LPSTATUS lpStatus);

// delete a pool(queue) and all buffers queued on it
STATUS MB_DeletePool(HBUFQUEUE hPool);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // MSPBUFFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\ll.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992-1993 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

	$Source: q:/prism/include/rcs/apiutils.h $
  $Revision:   1.0  $
	  $Date:   06 Mar 1996 09:01:48  $
	$Author:   LCARROLL  $
	$Locker:  $

	Description
	-----------
	Utility API header file.

****************************************************************************/

#ifndef APIUTILS_H
#define APIUTILS_H

#ifdef __cplusplus
extern "C" {					// Assume C declarations for C++.
#endif // __cplusplus


// ll.c ---------------------------------------------------------------
//
// The following are used by the DLL loader utilities.
//
typedef LPBYTE FAR *ptaPtrs;
typedef HINSTANCE	thDLL;

extern thDLL LL_LoadDLL
(
	LPSTR	pzDLLName,		// Path\name of DLL to be loaded.
	ptaPtrs papzFunctNames, // List of ptrs to DLL function names to resolve.
	ptaPtrs papFunct		// Will be list of ptrs to functions in DLL.
);
extern UINT LL_UnloadDLL
(
	thDLL hDLL				// Handle of DLL to unload.
);



#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus


#endif // APIUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\q931.h ===
/****************************************************************************
 *
 *	$Archive:   S:/sturgeon/src/include/vcs/q931.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.49.2.0  $
 *	$Date:   20 Jun 1997 14:10:50  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef Q931_H
#define Q931_H


#include "incommon.h"
#include "q931pdu.h"
#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

//====================================================================================
// Q931-specific codes
//====================================================================================

// Status codes
#define CS_OK                               NOERROR
#define CS_BAD_PARAM                        MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x1)
#define CS_DUPLICATE_LISTEN                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x2)
#define CS_INTERNAL_ERROR                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x3)
#define CS_BAD_SIZE                         MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x4)
#define CS_NO_MEMORY                        MAKE_Q931_ERROR(ERROR_OUTOFMEMORY)
#define CS_NOT_IMPLEMENTED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x6)
#define CS_NOT_INITIALIZED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x7)
#define CS_DUPLICATE_INITIALIZE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x8)
#define CS_SUBSYSTEM_FAILURE                MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x9)
#define CS_OUT_OF_SEQUENCE                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xA)
#define CS_PEER_UNREACHABLE                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xB)
#define CS_SETUP_TIMER_EXPIRED              MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xC)
#define CS_RINGING_TIMER_EXPIRED            MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xD)
#define CS_INCOMPATIBLE_VERSION             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xE)

// parsing error cases
#define CS_OPTION_NOT_IMPLEMENTED           MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xF)
#define CS_ENDOFINPUT                       MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x10)
#define CS_INVALID_FIELD                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x11)
#define CS_NO_FIELD_DATA                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x12)
#define CS_INVALID_PROTOCOL                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x13)
#define CS_INVALID_MESSAGE_TYPE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x14)
#define CS_MANDATORY_IE_MISSING             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x15)
#define CS_BAD_IE_CONTENT                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x16)
#define CS_MESSAGE_TOO_SHORT                MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x17)

// Event codes
#define Q931_CALL_INCOMING                  1
#define Q931_CALL_REMOTE_HANGUP             2
#define Q931_CALL_REJECTED                  3
#define Q931_CALL_ACCEPTED                  4
#define Q931_CALL_RINGING                   5
#define Q931_CALL_FAILED                    6
#define Q931_CALL_CONNECTION_CLOSED         7

// Goal codes
#define CSG_NONE                            0
#define CSG_JOIN                            1
#define CSG_CREATE                          2
#define CSG_INVITE                          3

#define CC_MAX_PARTY_NUMBER_LEN             254

//====================================================================================
// Q931-specific types
//====================================================================================

typedef HRESULT CS_STATUS;
typedef DWORD HQ931LISTEN, *PHQ931LISTEN;
typedef DWORD HQ931CALL, *PHQ931CALL;


//====================================================================================
// Callback definitions.
//====================================================================================

typedef DWORD (*Q931_CALLBACK) (BYTE bEvent, HQ931CALL hQ931Call,
    HQ931LISTEN hListenToken, DWORD dwUserToken, void *pEventData);

typedef BOOL (*Q931_RECEIVE_PDU_CALLBACK) (Q931MESSAGE *pMessage,
    HQ931CALL hQ931Call, DWORD dwListenToken, DWORD dwUserToken);

//====================================================================================
// definitions of structures passed to callbacks as parameters.
//====================================================================================

// CSS_CALL_INCOMING callback parameter type
typedef struct 
{
    WORD wCallReference;
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;
    LPWSTR pszCalledPartyNumber;
    PCC_ADDR pSourceAddr;
    PCC_ADDR pCallerAddr;
    PCC_ADDR pCalleeDestAddr;
    PCC_ADDR pLocalAddr;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pSourceEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_INCOMING, *PCSS_CALL_INCOMING;

// CSS_CALL_REMOTE_HANGUP callback parameter type
typedef struct
{
    BYTE bReason;
} CSS_CALL_REMOTE_HANGUP, *PCSS_CALL_REMOTE_HANGUP;


// CSS_CALL_REJECTED callback parameter type
typedef struct 
{
    BYTE bRejectReason;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pAlternateAddr;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_REJECTED, *PCSS_CALL_REJECTED;

// CSS_CALL_ACCEPTED callback parameter type
typedef struct 
{
    WORD wCallReference;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pCalleeAddr;
    PCC_ADDR pLocalAddr;
    PCC_ADDR pH245Addr;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pDestinationEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_ACCEPTED, *PCSS_CALL_ACCEPTED;

// Q931_CALL_RINGING callback event will have pEventData set to NULL

// CSS_CALL_FAILED callback paremeter type
typedef struct
{
    HRESULT error;
} CSS_CALL_FAILED, *PCSS_CALL_FAILED;

//====================================================================================
// function declarations.
//====================================================================================

CS_STATUS Q931Init();

CS_STATUS Q931DeInit();

CS_STATUS Q931Listen(
    PHQ931LISTEN phQ931Listen,
    PCC_ADDR pListenAddr,
    DWORD dwListenToken,
    Q931_CALLBACK ListenCallback);

CS_STATUS Q931CancelListen(
    HQ931LISTEN hQ931Listen);

CS_STATUS Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD dwUserToken,
    Q931_CALLBACK ConnectCallback,
	DWORD dwBandwidth,
    WORD wCRV);

CS_STATUS Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason);

CS_STATUS Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV);

CS_STATUS Q931AcceptCall(
    HQ931CALL hQ931Call,
    LPWSTR pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_ADDR pH245Addr,
	DWORD dwBandwidth,
    DWORD dwUserToken);

CS_STATUS Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931ReOpenConnection(
    HQ931CALL hQ931Call);

CS_STATUS Q931GetVersion(
    WORD wLength,          // character count, not byte count.
    LPWSTR pszVersion);

CS_STATUS Q931SetAlertingTimeout(
    DWORD dwDuration);

void Q931SetReceivePDUHook(
    Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback);

CS_STATUS Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931SendPDU(
    HQ931CALL hQ931Call,
    BYTE* CodedPtrPDU,
    DWORD CodedLengthPDU);

CS_STATUS Q931FlushSendQueue(
    HQ931CALL hQ931Call);

// utility routines
CS_STATUS Q931ValidateAddr(PCC_ADDR pAddr);
CS_STATUS Q931ValidatePartyNumber(LPWSTR pszPartyNumber);

CS_STATUS Q931ValidateAliasItem(PCC_ALIASITEM pSource);
CS_STATUS Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource);
CS_STATUS Q931FreeAliasItem(PCC_ALIASITEM pSource);

CS_STATUS Q931ValidateAliasNames(PCC_ALIASNAMES pSource);
CS_STATUS Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
CS_STATUS Q931FreeAliasNames(PCC_ALIASNAMES pSource);

CS_STATUS Q931ValidateDisplay(LPWSTR pszDisplay);
CS_STATUS Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource);
CS_STATUS Q931FreeDisplay(LPWSTR pszDisplay);

CS_STATUS Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo);
CS_STATUS Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource);
CS_STATUS Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo);

CS_STATUS Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);
CS_STATUS Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource);
CS_STATUS Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);

#ifdef __cplusplus
}
#endif

#endif Q931_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\q931pdu.h ===
/****************************************************************************
 *
 *  $Archive:   S:/sturgeon/src/include/vcs/q931pdu.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1996 Intel Corporation.
 *
 *  $Revision:   1.11.2.0  $
 *  $Date:   20 Jun 1997 14:11:14  $
 *  $Author:   MANDREWS  $
 *
 *  Abstract: Parser routines for Q931 PDUs
 *
 ***************************************************************************/
#ifndef Q931PAR_H
#define Q931PAR_H

#include <winerror.h>
#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

struct S_BUFFERDESCR
{
    DWORD Length;
    BYTE *BufferPtr;
};

typedef struct S_BUFFERDESCR BUFFERDESCR;
typedef struct S_BUFFERDESCR *PBUFFERDESCR;

// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E
   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN Present;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN Present;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN Present;
    BYTE Length;
    BYTE Contents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The sending complete element is a single type 2
typedef struct S_SINGLESTRUCT2 SENDCOMPLIE;
typedef struct S_SINGLESTRUCT2 *PSENDCOMPLIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The repeat indicator element is a single type 1
typedef struct S_SINGLESTRUCT1 REPEATIE;
typedef struct S_SINGLESTRUCT1 *PREPEATIE;

// The segmented element is a variable 
typedef struct S_VARSTRUCT SEGMENTEDIE;
typedef struct S_VARSTRUCT *PSEGMENTEDIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The end to end transit delay element is a variable 
typedef struct S_VARSTRUCT ENDTOENDDELAYIE;
typedef struct S_VARSTRUCT *PENDTOENDDELAYIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The reverse charge indication element is a variable 
typedef struct S_VARSTRUCT REVERSECHARGEIE;
typedef struct S_VARSTRUCT *PREVERSECHARGEIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The transit network selection element is a variable 
typedef struct S_VARSTRUCT TRANSITNETIE;
typedef struct S_VARSTRUCT *PTRANSITNETIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209 ((PDTYPE)0x05)

struct S_VARSTRUCT_UU
{
    BOOLEAN Present;
    BYTE ProtocolDiscriminator;
    WORD UserInformationLength;
    BYTE UserInformation[0x1000];   // 4k bytes should be good for now...
};

// The user to user element is a variable 
typedef struct S_VARSTRUCT_UU USERUSERIE;
typedef struct S_VARSTRUCT_UU *PUSERUSERIE;

struct S_PARTY_NUMBER
{
    BOOLEAN Present;
    BYTE NumberType;
    BYTE NumberingPlan;
    BYTE PartyNumberLength;
    BYTE PartyNumbers[MAXVARFIELDLEN];
};

// The called party number element is a variable 
typedef struct S_PARTY_NUMBER CALLEDNUMBERIE;
typedef struct S_PARTY_NUMBER *PCALLEDNUMBERIE;

// Q932 defined message types
#define HOLDMESSAGETYPE				0x24
#define HOLDACKMESSAGETYPE			0x28
#define HOLDREJECTMESSAGETYPE		0x30
#define RETRIEVEMESSAGETYPE			0x31
#define RETRIEVEACKMESSAGETYPE		0x33
#define RETRIEVEREJECTMESSAGETYPE	0x37
#define FACILITYMESSAGETYPE			0x62
#define REGISTERMESSAGETYPE			0x64

#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE CallReference;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    SENDCOMPLIE SendingComplete;
    CONGESTIONIE CongestionLevel;
    REPEATIE RepeatIndicator;
    SEGMENTEDIE SegmentedMessage;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    ENDTOENDDELAYIE EndToEndTransitDelay;
    TRANSITDELAYIE TransitDelay;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CLOSEDUGIE ClosedUserGroup;
    REVERSECHARGEIE ReverseChargeIndication;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    TRANSITNETIE TransitNetworkSelection;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;
};

typedef struct S_MESSAGE Q931MESSAGE;
typedef struct S_MESSAGE *PQ931MESSAGE;

//-------------------------------------------------------------------
// Single routine for parsing Q931 messages
//-------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message);

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//==========================================================
// CAUSE FIELD DEFINITIONS
//==========================================================
#define CAUSE_EXT_BIT                0x80
#define CAUSE_CODING_CCITT           0x00
#define CAUSE_LOCATION_USER          0x00
#define CAUSE_RECOMMENDATION_Q931    0x00

#define CAUSE_VALUE_NORMAL_CLEAR     0x10
#define CAUSE_VALUE_USER_BUSY        0x11
#define CAUSE_VALUE_NO_ANSWER        0x13   // Callee does not answer
#define CAUSE_VALUE_REJECTED         0x15
#define CAUSE_VALUE_ENQUIRY_RESPONSE 0x1E
#define CAUSE_VALUE_NOT_IMPLEMENTED  0x4F
#define CAUSE_VALUE_INVALID_CRV      0x51
#define CAUSE_VALUE_INVALID_MSG      0x5F
#define CAUSE_VALUE_IE_MISSING       0x60
#define CAUSE_VALUE_IE_CONTENTS      0x64
#define CAUSE_VALUE_TIMER_EXPIRED    0x66

typedef struct _ERROR_MAP
{
    int nErrorCode;
#ifdef UNICODE_TRACE
    LPWSTR pszErrorText;
#else
    LPSTR pszErrorText;
#endif
} ERROR_MAP;

typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *ptr;
} BINARY_STRING;

typedef struct _Q931_SETUP_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    BOOL SourceAddrPresent;
    BOOL CallerAddrPresent;
    BOOL CalleeAddrPresent;
    BOOL CalleeDestAddrPresent;
    CC_ADDR SourceAddr;                // originating addr
    CC_ADDR CallerAddr;                // gk addr
    CC_ADDR CalleeAddr;                // local addr
    CC_ADDR CalleeDestAddr;            // target destination addr
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_SETUP_ASN;

typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BYTE bReason;
} Q931_RELEASE_COMPLETE_ASN;

typedef struct _Q931_CONNECT_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BOOL h245AddrPresent;
    CC_ADDR h245Addr;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_CONNECT_ASN;

typedef struct _Q931_ALERTING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
} Q931_ALERTING_ASN;

typedef struct _Q931_CALL_PROCEEDING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
} Q931_CALL_PROCEEDING_ASN;

typedef struct _Q931_FACILITY_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR AlternativeAddr;
    PCC_ALIASNAMES pAlternativeAliasList;
    CC_CONFERENCEID ConferenceID;
    BOOL ConferenceIDPresent;
    BYTE bReason;
} Q931_FACILITY_ASN;

//-------------------------------------------------------------------
// Initialization Routines
//-------------------------------------------------------------------
HRESULT Q931InitPER();
HRESULT Q931DeInitPER();

//-------------------------------------------------------------------
// Parsing Routines
//-------------------------------------------------------------------

HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData);

HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData);

HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData);

HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData);

HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData);

HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData);

//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------

// routines for the Setup Message:
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
	DWORD dwBandwidth,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Release Complete Message:
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Connect Message:
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
	DWORD dwBandwidth,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Alerting Message:
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Proceeding Message:
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf);

#ifdef __cplusplus
}
#endif

#endif Q931PAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\ppmclsid.h ===
/****************************************************************************
 *  $Header:   S:/STURGEON/SRC/INCLUDE/VCS/ppmclsid.h_v   1.2   May 15 1996 21:57:38   lscline  $ 
 *
 *  INTEL Corporation Proprietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1995, 1996 Intel Corporation. All rights reserved.
 *
 *  $Revision:   1.2  $
 *  $Date:   May 15 1996 21:57:38  $
 *  $Author:   lscline  $
 *
 *  Log at end of file.
 *
 *  Module Name:   PPMGUID.h
 *  Abstract:       PPM Class Ids
 *  Environment:    MSVC 4.0, OLE 2
 *  Notes:
 *      This file should be included in exactly one source file per module
 *      after '#include <initguid.h>' and '#define INITGUID' to define the
 *      GUIDs, and in other source files without '#include <initguid.h>'
 *      to declare them. This file is included in psavcomp.h so it does not
 *      need to be explicitly included for the declarations.
 *
 ***************************************************************************/
#ifndef PPMCLSID_H
#define PPMCLSID_H


/////////////////////////////////////////////////////////////////////////////
// Class ids
//

// {A92D97A3-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_GenPPMSend,			0xa92d97a3, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {C20E2441-662A-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_GenPPMReceive,		0xc20e2441, 0x662a, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A92D97A4-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_H261PPMSend,			0xa92d97a4, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {C20E2442-662A-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_H261PPMReceive,		0xc20e2442, 0x662a, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {C20E2445-662A-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_H263PPMSend,			0xc20e2445, 0x662a, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {C20E2446-662A-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_H263PPMReceive,		0xc20e2446, 0x662a, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A92D97A5-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_G711PPMSend,			0xa92d97a5, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {C20E2443-662A-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_G711PPMReceive,		0xc20e2443, 0x662a, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A92D97A6-66CD-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_G723PPMSend,			0xa92d97a6, 0x66cd, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {C20E2444-662A-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_G723PPMReceive,		0xc20e2444, 0x662a, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A0A99E01-8714-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_IV41PPMSend,			0xa0a99e01, 0x8714, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {A0A99E02-8714-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_IV41PPMReceive,		0xa0a99e02, 0x8714, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {09BCCE41-AD93-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_G711APPMSend,		0x9bcce41, 0xad93, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {09BCCE42-AD93-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_G711APPMReceive,		0x9bcce42, 0xad93, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {09BCCE43-AD93-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_LHPPMSend,			0x9bcce43, 0xad93, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

// {09BCCE44-AD93-11cf-B9BA-00AA00A89C1D}
DEFINE_GUID( CLSID_LHPPMReceive,		0x9bcce44, 0xad93, 0x11cf, 0xb9, 0xba, 0x0, 0xaa, 0x0, 0xa8, 0x9c, 0x1d);

#endif //PPMGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\rsx.h ===
/*
//   RSX.H
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//
//      Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
//  PVCS:
//      $Workfile:   rsx.h  $
//      $Revision:   1.1  $
//      $Modtime:   Jul 26 1996 14:40:46  $
//
//  PURPOSE:
//		RSX 2.0 Header
//
//  CONTENTS:
//		COM Interface declarations
//		Data Structures
//		Error Codes
//    
*/


#ifndef __RSX20_INCLUDED__
#define __RSX20_INCLUDED__
#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown        void
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include "mmsystem.h"

#ifdef _WIN32

/* {E78F7620-96CB-11cf-A00B-444553540000} */
DEFINE_GUID(CLSID_RSX20, 
	0xe78f7620, 0x96cb, 0x11cf, 0xa0, 0xb, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* {E78F7629-96CB-11cf-A00B-444553540000} */
DEFINE_GUID(IID_IRSX20, 
	0xe78f7629, 0x96cb, 0x11cf, 0xa0, 0xb, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* {E78F762D-96CB-11cf-A00B-444553540000} */
DEFINE_GUID(IID_IRSXCachedEmitter, 
	0xe78f762d, 0x96cb, 0x11cf, 0xa0, 0xb, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* {E78F7630-96CB-11cf-A00B-444553540000} */
DEFINE_GUID(IID_IRSXStreamingEmitter, 
	0xe78f7630, 0x96cb, 0x11cf, 0xa0, 0xb, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* {E78F7634-96CB-11cf-A00B-444553540000} */
DEFINE_GUID(IID_IRSXDirectListener, 
	0xe78f7634, 0x96cb, 0x11cf, 0xa0, 0xb, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/* {E78F7638-96CB-11cf-A00B-444553540000} */
DEFINE_GUID(IID_IRSXStreamingListener, 
	0xe78f7638, 0x96cb, 0x11cf, 0xa0, 0xb, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


#endif

typedef struct IRSX								FAR *LPRSX;
typedef struct IRSXCachedEmitter				FAR *LPRSXCACHEDEMITTER;
typedef struct IRSXDirectListener				FAR *LPRSXDIRECTLISTENER;
typedef struct IRSXStreamingEmitter				FAR *LPRSXSTREAMINGEMITTER;
typedef struct IRSXStreamingListener			FAR *LPRSXSTREAMINGLISTENER;

typedef struct _RSXBUFFERHDR	                FAR *LPRSXBUFFERHDR;
typedef struct _RSXCACHEDEMITTERDESC			FAR *LPRSXCACHEDEMITTERDESC;
typedef struct _RSXDIRECTLISTENERDESC			FAR *LPRSXDIRECTLISTENERDESC;
typedef struct _RSXEMITTERMODEL					FAR *LPRSXEMITTERMODEL;
typedef struct _RSXENVIRONMENT					FAR *LPRSXENVIRONMENT;
typedef struct _RSXQUERYMEDIAINFO				FAR *LPRSXQUERYMEDIAINFO;
typedef struct _RSXREVERBMODEL					FAR *LPRSXREVERBMODEL;
typedef struct _RSXSTREAMINGEMITTERDESC			FAR *LPRSXSTREAMINGEMITTERDESC;
typedef struct _RSXSTREAMINGLISTENERDESC		FAR *LPRSXSTREAMINGLISTENERDESC;
typedef struct _RSXVECTOR3D                     FAR *LPRSXVECTOR3D;


#define RSX_MAX_NAME_LEN     (MAX_PATH)


/*
// Enumerated Types
*/

enum RSX_CPU_Budget { RSX_MIN_BUDGET, RSX_LOW_BUDGET, RSX_MODERATE_BUDGET };


#ifdef _WIN32
#undef INTERFACE
#define INTERFACE IRSX
DECLARE_INTERFACE_( IRSX, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    
	/*** IRSX methods ***/
    STDMETHOD(CreateCachedEmitter)(THIS_  LPRSXCACHEDEMITTERDESC lpCachedEmitterAttr, LPRSXCACHEDEMITTER FAR *lpCachedEmitterInterface, IUnknown FAR *reserved) PURE;    
	STDMETHOD(CreateDirectListener)(THIS_  LPRSXDIRECTLISTENERDESC lpDirectListenerAttr, LPRSXDIRECTLISTENER FAR *lpDirectListenerInterface, IUnknown FAR *reserved) PURE;

	STDMETHOD(CreateStreamingEmitter)(THIS_  LPRSXSTREAMINGEMITTERDESC lpStreamingEmitterAttr, LPRSXSTREAMINGEMITTER FAR *lpStreamingEmitterInterface, IUnknown FAR *reserved) PURE;    
	STDMETHOD(CreateStreamingListener)(THIS_  LPRSXSTREAMINGLISTENERDESC lpStreamingListenerAttr, LPRSXSTREAMINGLISTENER FAR *lpStreamingListenerInterface, IUnknown FAR *reserved) PURE;
	
	STDMETHOD(GetEnvironment)(THIS_ LPRSXENVIRONMENT lpEnvAttr) PURE;
    STDMETHOD(GetReverb)(THIS_ LPRSXREVERBMODEL lpReverbModel) PURE;
    STDMETHOD(SetEnvironment)(THIS_ LPRSXENVIRONMENT lpEnvAttr) PURE;
    STDMETHOD(SetReverb)(THIS_ LPRSXREVERBMODEL lpReverbModel) PURE;
    	
};
#endif


/*
// Flags for IRSXCachedEmitter::ControlMedia
//
*/
#define RSX_PLAY			 0x00000010
#define RSX_PAUSE            0x00000020
#define RSX_RESUME           0x00000040
#define RSX_STOP			 0x00000050



#ifdef _WIN32
#undef INTERFACE
#define INTERFACE IRSXCachedEmitter
DECLARE_INTERFACE_( IRSXCachedEmitter, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


  /*** IRSXEmitter methods ***/
        STDMETHOD(GetCPUBudget)(THIS_ enum RSX_CPU_Budget* lpCPUBudget) PURE;
	STDMETHOD(GetModel)(THIS_ LPRSXEMITTERMODEL lpEmitterModel) PURE;
	STDMETHOD(GetMuteState)(THIS_ LPDWORD lpdwMuteState) PURE;
	STDMETHOD(GetOrientation)(THIS_ LPRSXVECTOR3D lpOrientation) PURE;
    STDMETHOD(GetPitch)(THIS_ PFLOAT lpfPitch) PURE;
    STDMETHOD(GetUserData)(THIS_ LPDWORD lpdwUser) PURE;
	STDMETHOD(GetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;
	
	STDMETHOD(QueryMediaState)(THIS_ LPRSXQUERYMEDIAINFO lpQueryMediaInfo) PURE;
    
	STDMETHOD(SetCPUBudget)(THIS_ enum RSX_CPU_Budget CPUBudget) PURE;
	STDMETHOD(SetModel)(THIS_ LPRSXEMITTERMODEL lpEmitterModel) PURE;
	STDMETHOD(SetMuteState)(THIS_ DWORD dwMuteState) PURE;
	STDMETHOD(SetOrientation)(THIS_ LPRSXVECTOR3D lpOrientation) PURE;
    STDMETHOD(SetPitch)(THIS_ FLOAT fPitch) PURE;
	STDMETHOD(SetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;

    

    /*** IRSXCachedEmitter methods ***/
	STDMETHOD(ControlMedia)(THIS_ DWORD dwControl, DWORD nLoops, FLOAT fInitialStartTime) PURE;
	STDMETHOD(GetCacheTime)(THIS_ PFLOAT lpfCacheTime) PURE;
	STDMETHOD(GetMarkPosition)(THIS_ PFLOAT lpfBeginTime, PFLOAT lpfEndTime) PURE;
	STDMETHOD(SetCacheTime)(THIS_ FLOAT fCacheTime) PURE;
	STDMETHOD(SetMarkPosition)(THIS_ FLOAT fBeginTime, FLOAT fEndTime) PURE;
		

};
#endif



#ifdef _WIN32
#undef INTERFACE
#define INTERFACE IRSXStreamingEmitter
DECLARE_INTERFACE_( IRSXStreamingEmitter, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	/*** IRSXEmitter methods ***/
	STDMETHOD(GetCPUBudget)(THIS_ enum RSX_CPU_Budget* lpCPUBudget) PURE;
	STDMETHOD(GetModel)(THIS_ LPRSXEMITTERMODEL lpEmitterModel) PURE;
	STDMETHOD(GetMuteState)(THIS_ LPDWORD lpdwMuteState) PURE;
	STDMETHOD(GetOrientation)(THIS_ LPRSXVECTOR3D lpOrientation) PURE;
    STDMETHOD(GetPitch)(THIS_ PFLOAT lpfPitch) PURE;
    STDMETHOD(GetUserData)(THIS_ LPDWORD lpdwUser) PURE;
	STDMETHOD(GetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;
	
	STDMETHOD(QueryMediaState)(THIS_ LPRSXQUERYMEDIAINFO lpQueryMediaInfo) PURE;
    
	STDMETHOD(SetCPUBudget)(THIS_ enum RSX_CPU_Budget CPUBudget) PURE;
	STDMETHOD(SetModel)(THIS_ LPRSXEMITTERMODEL lpEmitterModel) PURE;
	STDMETHOD(SetMuteState)(THIS_ DWORD dwMuteState) PURE;
	STDMETHOD(SetOrientation)(THIS_ LPRSXVECTOR3D lpOrientation) PURE;
    STDMETHOD(SetPitch)(THIS_ FLOAT fPitch) PURE;
	STDMETHOD(SetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;
    
    /*** IRSXCachedEmitter methods ***/
	STDMETHOD(Flush)(THIS) PURE;
	STDMETHOD(SubmitBuffer)(THIS_ LPRSXBUFFERHDR lpBufferHdr) PURE;

};
#endif



#ifdef _WIN32
#undef INTERFACE
#define INTERFACE IRSXDirectListener
DECLARE_INTERFACE_( IRSXDirectListener, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    
	/*** IRSXListener methods ***/
    STDMETHOD(GetOrientation)(THIS_ LPRSXVECTOR3D lpDirection, LPRSXVECTOR3D lpUp) PURE;
    STDMETHOD(GetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;
    STDMETHOD(GetUserData)(THIS_ LPDWORD lpdwUser) PURE;

	STDMETHOD(SetOrientation)(THIS_ LPRSXVECTOR3D lpDirection, LPRSXVECTOR3D lpUp) PURE;
    STDMETHOD(SetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;    

    
	/*** IRSXDirectListener methods ***/
	STDMETHOD(Connect)(THIS) PURE;
	STDMETHOD(Disconnect)(THIS) PURE;
    
};
#endif


#ifdef _WIN32
#undef INTERFACE
#define INTERFACE IRSXStreamingListener
DECLARE_INTERFACE_( IRSXStreamingListener, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    
	/*** IRSXListener methods ***/
    STDMETHOD(GetOrientation)(THIS_ LPRSXVECTOR3D lpDirection, LPRSXVECTOR3D lpUp) PURE;
    STDMETHOD(GetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;
    STDMETHOD(GetUserData)(THIS_ LPDWORD lpdwUser) PURE;

	STDMETHOD(SetOrientation)(THIS_ LPRSXVECTOR3D lpDirection, LPRSXVECTOR3D lpUp) PURE;
    STDMETHOD(SetPosition)(THIS_ LPRSXVECTOR3D lpPosition) PURE;    


    /*** IRSXStreamingListener methods ***/
	STDMETHOD(RequestBuffer)(THIS_ LPSTR lpBufferA, LPSTR lpBufferB, DWORD dwSizeB) PURE;
    
};
#endif




/*
// RSXBUFFERHDR
*/
typedef struct _RSXBUFFERHDR {
	DWORD			cbSize;			/* structure size */
	DWORD			dwUser;			/* user data */
    DWORD			dwSize;			/* size of data pointed to by lpData */
	LPSTR			lpData;			/* pointer to data */
	HANDLE			hEventSignal;	/* event handle to be signaled when buffer complete */
    DWORD           dwReserved1;    /* reserved for RSX */
    DWORD           dwReserved2;    /* reserved for RSX */
    DWORD           dwReserved3;    /* reserved for RSX */
    DWORD           dwReserved4;    /* reserved for RSX */
	DWORD           dwReserved5;    /* reserved for RSX */
} RSXBUFFERHDR;


/*
// Flags for RSXCACHEDEMITTERDESC and RSXSTREAMINGEMITTERDESC
*/
#define RSXEMITTERDESC_NODOPPLER	0x00000001
#define RSXEMITTERDESC_NOATTENUATE	0x00000002
#define RSXEMITTERDESC_NOSPATIALIZE	0x00000004
#define RSXEMITTERDESC_NOREVERB     0x00000008

/*
// Flags for RSXCACHEDEMITTERDESC
*/
#define RSXEMITTERDESC_GROUPID		0x00000010
#define RSXEMITTERDESC_PREPROCESS	0x00000020
#define RSXEMITTERDESC_INMEMORY		0x00000040

/*
// RSXCACHEDEMITTERDESC
*/

typedef struct _RSXCACHEDEMITTERDESC {
	DWORD			cbSize;			/* structure size */
	DWORD			dwFlags;		/* creation flags */
	DWORD			dwGroupID;		/* synchronization group ID, use zero for no group */
        char                    szFilename[RSX_MAX_NAME_LEN]; /* path  */
	HANDLE			hEventSignal;	/* Signaled when play completes */
	DWORD			dwUser;			/* User specific */
} RSXCACHEDEMITTERDESC;



/*
// RSXDIRECTLISTENERDESC
*/
typedef struct _RSXDIRECTLISTENERDESC {
	DWORD			cbSize;			/* structure size */
	LPWAVEFORMATEX	lpwf;			/* Requested output format */
	HWND			hMainWnd;		/* Main Window Handle is DirectSound will be used */
	DWORD			dwUser;			/* User specific */
} RSXDIRECTLISTENERDESC;



/*
// RSXEMITTERMODEL
*/
typedef struct _RSXEMITTERMODEL {
	DWORD			cbSize;			/* structure size */
	float			fMinBack;		/* min back -- ambient */
	float			fMinFront;		/* min front -- ambient */
	float			fMaxBack;		/* max back -- attenuation */
	float			fMaxFront;		/* max front -- attenuation */
	float			fIntensity;		/* static intensity */
} RSXEMITTERMODEL;



/*
// Flags for RSXENVIRONMENT
*/
#define RSXENVIRONMENT_COORDINATESYSTEM	0x00000001
#define RSXENVIRONMENT_SPEEDOFSOUND		0x00000002
#define RSXENVIRONMENT_CPUBUDGET		0x00000004

/*
// RSXENVIRONMENT
*/
typedef struct _RSXENVIRONMENT
{
	DWORD			cbSize;			/* structure size */
	DWORD			dwFlags;		/* creation flags */
	BOOL            bUseRightHand;	/* coordinate system */
	FLOAT			fSpeedOfSound;  /* Speed of Sound for Doppler */
	enum RSX_CPU_Budget	CPUBudget;		/* CPU limit for localization */
  
} RSXENVIRONMENT;



/*
// RSXQUERYMEDIAINFO
*/
typedef struct _RSXQUERYMEDIAINFO {

	DWORD			cbSize;			/* structure size */
	DWORD			dwControl;		/* play state */
	FLOAT			fSecondsPlayed;	/* playback position in seconds */
	FLOAT			fTotalSeconds;	/* total play time */
	DWORD			dwNumLoops;		/* loop count */
	FLOAT			fAudibleLevel;	/* audible level */
	
} RSXQUERYMEDIAINFO;



/*
// RSXREVERBMODEL
*/
typedef struct _RSXREVERBMODEL
{
	DWORD			cbSize;			/* structure size */
	BOOL            bUseReverb;		/* is reverb applied */
	FLOAT			fDecayTime;		/* Decay in seconds */
	FLOAT			fIntensity;		/* Gain to model sound absorption */
} RSXREVERBMODEL;



/* 
// RSXSTREAMINGEMITTERDESC
*/

typedef struct _RSXSTREAMINGEMITTERDESC {
	DWORD			cbSize;			/* structure size */
	DWORD			dwFlags;		/* creation flags */
	DWORD			dwType;			/* unused -- must be zero */
	LPWAVEFORMATEX	lpwf;			/* buffer format */
	DWORD			dwUser;			/* User specific */
} RSXSTREAMINGEMITTERDESC;


/*
// RSXSTREAMINGLISTENERDESC
*/
typedef struct _RSXSTREAMINGLISTENERDESC {
	DWORD			cbSize;			/* structure size */
	LPWAVEFORMATEX	lpwf;			/* Requested output format */
	DWORD			dwRequestedBufferSize; /* Application requested buffer size */
	DWORD			dwActualBufferSize; /* RSX specified buffer size */
	DWORD			dwUser;			/* User specific */
} RSXSTREAMINGLISTENERDESC;



/*
// RSXVECTOR3D
*/
typedef struct _RSXVECTOR3D {
    float          x;
    float          y;
    float          z;    
} RSXVECTOR3D;



/*
// Error Codes
//
*/



/* no sound driver installed */
#define RSXERR_NODRIVER			MAKE_HRESULT( 1, FACILITY_ITF, 10 )

/* wave driver doesn't support format */
#define RSXERR_BADFORMAT			MAKE_HRESULT( 1, FACILITY_ITF, 20 )

/* a zero length vector was specified for the orientation */
#define RSXERR_ZEROVECTOR		MAKE_HRESULT( 1, FACILITY_ITF, 30 )

/* 
// an error occurred opening the wave file specified
// when creating the emitter
*/
#define RSXERR_FILENOTFOUND			MAKE_HRESULT( 1, FACILITY_ITF, 40 )
#define RSXERR_FILESHARINGVIOLATION	MAKE_HRESULT( 1, FACILITY_ITF, 41 )


/* the wave file is corrupted(not valid) */
#define RSXERR_CORRUPTFILE		MAKE_HRESULT( 1, FACILITY_ITF, 50 )

/* the listeners orienation vectors are parallel */
#define RSXERR_PARALLELVECTORS	MAKE_HRESULT( 1, FACILITY_ITF, 60 )

/* sound resources are allocated or busy */
#define RSXERR_ALLOCATED			MAKE_HRESULT( 1, FACILITY_ITF, 70 )

/* An invalid operation was performed while RSX is playing
// a cached emitter
*/
#define RSXERR_PLAYING          MAKE_HRESULT( 1, FACILITY_ITF, 80 )



#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\rasplog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1994:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR	Steve Nesland, Sam Sakthivel
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by MBFT and
//		the MBFT PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the MBFT protocol as the one to be logged.  In the 
// MBFT code, it is used only in the CPLInitialize() call.  
// For example:  MBFTProtocolLogger = CPLInitialize( MBFT_PROTOCOL );
//
#define RASLOG_PROTOCOL "RAS_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// MBFT to the logging via user data.  Bit zero of the user data represents
// the ASN encoding type.  Bit 1 represents pdu type (Connect or Domain).
// Bit 2 represents whether the PDU was sent or received.
//

#define RASLOG_SENT_PDU                1UL
#define RASLOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\reg.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/reg.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.11  $
 *	$Date:   Nov 13 1996 14:11:28  $
 *	$Author:   rdowning  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef __REG_HEADER__
#define __REG_HEADER__

#include <winreg.h>
#include "h245api.h"
#include "q931.h"
#include "callcont.h"
#include <winerror.h>
#include "apierror.h"

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

extern __declspec(dllexport) long CreateRegStringValue(char *pKey,char *pSubKey,char *pValue,char *pValueData,int iRootKey);
extern __declspec(dllexport) long CreateRegNumValue(char *pKey,char *pSubKey,char *pValue,DWORD dwValueData,int iRootKey);
extern __declspec(dllexport) long GetRegNumValue(char *pKey,char *pSubKey,char *pValue,DWORD *pRetBuf,int iRootKey);
extern __declspec(dllexport) long GetRegStringValue(char *pKey,char *pSubKey,char *pValue,BYTE *pRetBuf,DWORD *pRetBufSize,int iRootKey);
extern __declspec(dllexport) long GetNumSubkeys(char *pKey,char *pSubKey,DWORD *pRetBuf,int iRootKey);
extern __declspec(dllexport) long GetSubkeyString(char *pKey,char *pSubKey,DWORD iIndex,char *pRetBuf,DWORD *pRetBufSize,int iRootKey);

// Capability read/write to the registry.
// Read a single capability structure out of the given key and
// subkey.  The format of the capability is defined as follows:
//
//
// Key/SubKey
// CapabilityType = REG_SZ  (G723 | LNH | H263)
//      The CapabilityType value is common to any capability
//      It defines the format of the capability structure and 
//      the further values to read.
//
//
// G723 audio capability fields All DWORDs
//
// MaxALSDUAudioFrames
// SilenceSupression
//
// H263 video capability fields  All DWORDs
//
// SqcifMPI
// QcifMPI
// CifMPI
// Cif4MPI
// Cif16MPI
// Hrdb
// Maxkb
// MaxBitRate
// UnrestrictedVector
// ArithmeticCoding
// AdvancedPrediction
// Frames
// TemporalSpatialTradeoff
//
// L&H audio capability fields  All DWORDs  
// Stored into a nonStandardCapability structure
//
// FormatTag
// DataRate
// FrameSize
// FramesPerPkt
// UseSilenceDet
// UsePostFilter
//
//
extern __declspec(dllexport) HRESULT GetRegCapability(char *pKey, char *pSubKey, CC_TERMCAP *CapEntry, int iRootKey);
extern __declspec(dllexport) HRESULT CreateRegCapability(char *pKey, char *pSubKey, CC_TERMCAP *CapEntry, int iRootKey);

// Check for compatibility between two capabilities
extern __declspec(dllexport) BOOLEAN IsCapInteroperable(CC_TERMCAP *CapEntry1, CC_TERMCAP *CapEntry2);
extern __declspec(dllexport) HRESULT IsVideoCapInteroperable(CC_TERMCAP *CapEntry1, CC_TERMCAP *CapEntry2, CC_TERMCAP *CapEntry0);

// Read an entire capability list from the registry.
// GetRegCapTable - Allocate and read a capability table from 
// the registry.
// A Capability table is stored in the registry as follows
//    Key/SubKey/CapTable
//		NumEntries REG_DWORD
//		Entry0 REG_SZ 
//		Entry1 REG_SZ
//		...
//  Each entry is numbered and will be returned in the corresponding
// position in the array.  This allows the capability table to 
// define an order of the entries.
// Each entry is a string which corresponds to the name of a key
// in the 
//  HKEY_LOCAL_MACHINE\SOFTWARE\Intel\RMS\CodecCapabilities 
// area.  From this new key, the system can get all of the 
// fields of the indicated capability.
//
// The return values are:
// RetCapEntryTable,	Value is an allocated pointer to the array of
//						capability structures.  The caller is responsible
//						to free this memory when they are finished with it.
// RetCapEntryTableSize	Size of the allocated array in number of cap entries
//
extern __declspec(dllexport) HRESULT GetRegCapTable(char *pProdKey, char* pCapKey, char *pSubKey, CC_TERMCAP **RetCapEntryTable, int *RetCapEntryTableSize, int iRootKey);


// Return codes for the registry capability functions


#define CR_OK				((HRESULT)MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_CAPREG, ERROR_SUCCESS))
#define CR_KEYINVALID		((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CAPREG, ERROR_BADKEY))
#define CR_OUTOFMEM			((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CAPREG, ERROR_OUTOFMEMORY))
#define CR_UNKNOWNCAP		((HRESULT)MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CAPREG, ERROR_NOT_SUPPORTED))


#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#define GetRegStringSize(pKey,pSubKey,pValue,pSize,iRootKey) GetRegStringValue(pKey,pSubKey,pValue,NULL,pSize,iRootKey)

#define CURRENT_USER	0
#define LOCAL_MACHINE	1
#define CLASSES_ROOT	2
#define USERS			3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\que.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 11/95 Intel Corporation. 
//
//
//  Module Name: que.h
//  Abstract:    header file. Generic queing structure.
//	Environment: MSVC 2.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////
//NOTE: To use this que structure, you must include this file. You create a Que object.
//      Using the que object you can call deque and enque. You can enqueue any object of a
//      class derived from QueItem.  In that derived class you add any fields you will need.
//      (eg. a buffer pointer field, and a length field). There is no limit on the size of 
//      the que.      
/////////////////////////////////////////////////////////////////////////////////

#ifndef QUE_H
#define QUE_H

//Don't really need winsock2.h but it has guards against including
//Winsock.h and it includes windows.h which is what I want.
//#include <windows.h>
#include <winsock2.h>
#include <wtypes.h>

class QueueItem {
friend class Queue; 

private:
  QueueItem* m_pNext;
  QueueItem* m_pPrev;
  
public:
   QueueItem::QueueItem(){m_pNext = NULL; m_pPrev= NULL;}
  
}; //end QueItem class

///////////////////////////////////////
class Queue {

private:
  
  QueueItem* m_pHead;
  QueueItem* m_pTail;
  int m_NumItems;
  CRITICAL_SECTION m_CritSect;

public:

// constructor
Queue(); 

//inline destructor
~Queue(){DeleteCriticalSection(&m_CritSect);}

// NOTE:
// Enqueue and Dequeue(void) are protected against simultaneous access by multiple threads.
// Obviously, this protection does not extend to threads using GetHead, GetTail, GetPrev, GetNext,
// and Dequeue(QueueItem *). Any threads using these functions and any other threads operating
// on the same queue must use an additional critical section.

//Add item to end of queue. Returns E_FAIL for a corrupt que or NOERROR for success
HRESULT Enqueue(QueueItem* item);

//Remove and return first item in queue. Returns NULL if queue is empty.
QueueItem* Dequeue();

//Remove a specific item from queue
void Dequeue(QueueItem *);

//Return first item in queue without removing it. Returns NULL if queue is empty.
QueueItem *GetHead() { return m_pHead; };

//Return last item in queue without removing it. Returns NULL if queue is empty.
QueueItem *GetTail() { return m_pTail; };

//Return the item following the item specified. Returns NULL if specified item is the last in the queue.
QueueItem *GetNext(QueueItem *item) { return item->m_pNext; };

//Return the item preceding the item specified. Returns NULL if specified item is the first in the queue.
QueueItem *GetPrev(QueueItem *item) { return item->m_pPrev; };

//inline. Checks to see if que is empty
BOOL Is_Empty() {return (BOOL)(!(m_pHead) && !(m_pTail));};

//inline returns number of items in list.
int NumItems() {return m_NumItems;};

}; //end Queue class

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\rtpclass.h ===
/////////////////////////////////////////////////////////////////////////////
//  INTEL Corporation Proprietary Information
//  This listing is supplied under the terms of a license agreement with Intel 
//  Corporation and many not be copied nor disclosed except in accordance
//  with the terms of that agreement.
//  Copyright (c) 1995, 1996 Intel Corporation. 
//
//
//  Module Name: rtpclass.h
//	Environment: MSVC 4.0, OLE 2
/////////////////////////////////////////////////////////////////////////////////

#ifndef RTPCLASS_H
#define RTPCLASS_H

#include "rtp.h"

class RTP_Header {
public:
        enum { fixed_header_size = 12 };

private:
#ifdef DEBUG
        union {
            unsigned char bytes[fixed_header_size];
            RTP_HDR_T     header;       /* This is here for convenience in debugging only */
        };
#else
        unsigned char bytes[fixed_header_size];
#endif

public:
        int v() { return (bytes[0] >> 6) & 3; }
        void set_v(int v) { bytes[0] = (bytes[0] & 0x3f) | ((v & 3) << 6); }
        
        int p() { return (bytes[0] >> 5) & 1; }
        void set_p(int v) { bytes[0] = (bytes[0] & 0xdf) | ((v & 1) << 5); }
        
        int x() { return (bytes[0] >> 4) & 1; }
        void set_x(int v) { bytes[0] = (bytes[0] & 0xef) | ((v & 1) << 4); }
        
        int cc() { return bytes[0] & 0x0f; }
        void set_cc(int v) { bytes[0] = (bytes[0] & 0xf0) | (v & 0x0f); }
        
        int m() { return (bytes[1] >> 7) & 1; }
        void set_m(int v) { bytes[1] = (bytes[1] & 0x7f) | ((v & 1) << 7); }
        
        int pt() { return (bytes[1] & 0x7f); }
        void set_pt(int v) { bytes[1] = (bytes[1] & 0x80) | (v & 0x7f); }
        
        unsigned short seq() { return bytes[2] << 8 | bytes[3]; };
        void set_seq(unsigned short v) { bytes[2] = (unsigned char)(v >> 8);
                                         bytes[3] = (unsigned char)(v);
                                       }
        
        unsigned long ts() { return (unsigned long)bytes[4] << 24
                                    | (unsigned long)bytes[5] << 16
                                    | (unsigned long)bytes[6] << 8
                                    | (unsigned long)bytes[7];
                           }
        void set_ts(unsigned long v) { bytes[4] = (unsigned char)(v >> 24);
                                       bytes[5] = (unsigned char)(v >> 16);
                                       bytes[6] = (unsigned char)(v >> 8);
                                       bytes[7] = (unsigned char)(v);
                                     }
        
        unsigned long ssrc() {  return (unsigned long)bytes[8] << 24
                                       | (unsigned long)bytes[9] << 16
                                       | (unsigned long)bytes[10] << 8
                                       | (unsigned long)bytes[11];
   	                     }
        void set_ssrc(unsigned long v) { bytes[8] = (unsigned char)(v >> 24);
                                         bytes[9] = (unsigned char)(v >> 16);
                                         bytes[10] = (unsigned char)(v >> 8);
                                         bytes[11] = (unsigned char)(v);
                                       }


        //refer to section 5.3.1 of the RTP spec to understand the RTP Extension header.
        int header_size() 
        {
            int NumCSRCBytes = cc() * 4;
            int NumExtensionBytes = 0;

            if ( x() == 1 )
            {   
                //tmp points to the first word of the extended header.
                //bytes 2 and 3 of this word contain the length of the extended header
                //in 32-bit words (not counting the first word)
                unsigned char *tmp = bytes + fixed_header_size + NumCSRCBytes;
                unsigned short x_len = ((unsigned short)tmp[2] << 8) | (unsigned short)tmp[3];
      
                //number of words plus the length field itself.
                NumExtensionBytes = (x_len + 1) * 4;
            }

            //the fixed header  plus  the csrc list  plus the extended header
            return ( fixed_header_size + NumCSRCBytes + NumExtensionBytes ); 
        }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\rtpmsp.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/rtpmsp.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.15  $
 *	$Date:   11 Jul 1996 18:42:08  $
 *	$Author:   rodellx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef RTPMSP_H
#define RTPMSP_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// define SOURCE and SINK MSP IDs
#define RTPMSP_SRC "IntelRMSNetIORTPSrc"
#define RTPMSP_SNK "IntelRMSNetIORTPSnk"

// RTPMSP defined error codes
#define	RPE_BASE		(ERROR_LOCAL_BASE_ID)
#define RPE_AFSUPPORT	(MAKE_RTPMSP_ERROR(RPE_BASE+1))
#define RPE_STATE		(MAKE_RTPMSP_ERROR(RPE_BASE+2))
#define RPE_NOPROVIDER	(MAKE_RTPMSP_ERROR(RPE_BASE+3))

#define	RPE_BADVERSION	(MAKE_RTPMSP_ERROR(ERROR_INVALID_VERSION))
#define RPE_NOMEM		(MAKE_RTPMSP_ERROR(ERROR_NOT_ENOUGH_MEMORY))
#define RPE_PARAM		(MAKE_RTPMSP_ERROR(ERROR_INVALID_PARAMETER))
#define RPE_NOTIMPL		(MAKE_RTPMSP_ERROR(ERROR_NOT_SUPPORTED))
#define RPE_INTERNAL	(MAKE_RTPMSP_ERROR(ERROR_GEN_FAILURE))
#define RPE_DUPLICATE	(MAKE_RTPMSP_ERROR(ERROR_ALREADY_EXISTS))
#define RPE_NOBUFFERS   (MAKE_RTPMSP_ERROR(ERROR_BUFFER_LIMIT))

// version RTPMSP initialization data structures
#define RTPMSPINITVER	2

// pass a pointer to this structure as the lParam1 parameter
// to MSM_OpenService with fields filled in.  
typedef struct _RTPMSPININIT
{
	UINT	version;			// value of RTPMSPINITVER
	UINT	len;				// length of the entire structure
	WSAPROTOCOL_INFO protInfo;		// information on protocol to be used
	int mcastFlags;				// default ignored for now
	SOCKADDR localAddr;			// default requested local address of SRC ports
	SOCKADDR remoteAddr;		// default remote address of SNK ports
	char	*cName;				// unique identifier for user, usually mail ID
	char	*userName;			// Full name of user
	// limit of version 1 defined fields
	// limit of version 2 defined fields
} RTPMSPININIT, *LPRTPMSPININIT;

// pass a pointer to this structure as the lParam2 parameter
// to MSM_OpenService with only version and len fields filled in.
// remainder of fields will be filled in on return.  
typedef struct _LPRTPMSPOUTINIT
{
	UINT	version;			// value of RTPMSPINITVER
	UINT	len;				// length of the entire structure
	// limit of version 1 defined fields
	WSAPROTOCOL_INFO protInfo;		// information on protocol used
	// limit of version 2 defined fields
} RTPMSPOUTINIT, *LPRTPMSPOUTINIT;

#define RTPPORTINITVER	3

// pass a pointer to this structure as the lParam1 parameter
// to MSM_OpenPort with fields filled in.  
typedef struct _RTPPORTININIT
{
	UINT	version;			// value of RTPPORTINITVER
	UINT	len;				// length of the entire structure
	int mcastFlags;				// ignored for now
	SOCKADDR localAddr;			// requested local address of port to open
	SOCKADDR remoteAddr;		// remote address of port to open
	// limit of version 1 defined fields
	BOOL	specific_ssrc;		// whether SSRC value has been specified
	DWORD	ssrc;				// requested SSRC ID
	// limit of version 2 defined fields
	DWORD    clockFrequency;	// media sample frequency
	UINT	 buffCount;			// number of buffers to allocate for this port
	UINT	 buffSize;			// size of buffers to allocate for this port
	// limit of version 3 defined fields
} RTPPORTININIT, *LPRTPPORTININIT;

// pass a pointer to this structure as the lParam2 parameter
// to MSM_OpenPort with only version and len fields filled in.
// remainder of fields will be filled in on return.  
typedef struct _LPRTPPORTOUTINIT
{
	UINT	version;			// value of RTPMSPINITVER
	UINT	len;				// length of the entire structure
	SOCKADDR localAddr;			// actual local address of port opened
	// limit of version 1 defined fields
	BOOL	assigned_ssrc;		// whether SSRC value has been assigned
	DWORD	ssrc;				// assigned SSRC ID
	// limit of version 2 defined fields
	UINT	 buffCount;			// number of buffers to allocate for this port
	UINT	 buffSize;			// size of buffers to allocate for this port
	// limit of version 3 defined fields
} RTPPORTOUTINIT, *LPRTPPORTOUTINIT;

// Command values for MSP_ServiceCmdProc
#define RTPMSP_SETMCASTSCOPE	0x0001
// inParam contains value of TTL
// outParam is ignored

#define RTPMSP_GETMCASTSCOPE	0x8001
// inParam is ignored
// outParam contains a pointer to DWORD where current TTL is returned

#define RTPMSP_GETMTUSIZE		0x8002
// inParam is ignored
// outParam contains a pointer to UINT where MTU size is returned

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // RTPMSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\rtp.h ===
/*
 * Filename: RTP.H
 *
 * RTP related data structures.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#ifndef _RTP_H_
#define _RTP_H_

#define RTP_HDR_MIN_LEN	12
#define RTP_SEQ_MOD 	(1<<16)
#define RTP_TS_MOD  	(0xffffffff)

#define RTP_TYPE		2		/* Current version */
#define RTP_MAX_SDES	256		/* maximum text length for SDES */

#define RTCP_SIZE_GAIN	(1./16.)
#define NTWRK_HDR_SIZE	28

typedef enum {
	RTCP_SR   = 200,
	RTCP_RR   = 201,
	RTCP_SDES = 202,
	RTCP_BYE  = 203,
	RTCP_APP  = 204
	} RTCP_TYPE_T;

typedef enum {
	RTCP_SDES_END,
	RTCP_SDES_CNAME,
	RTCP_SDES_NAME,
	RTCP_SDES_EMAIL,
	RTCP_SDES_PHONE,
	RTCP_SDES_LOC,
	RTCP_SDES_TOOL,
	RTCP_SDES_TXT,
	RTCP_SDES_PRIV
	} RTCP_SDES_TYPE_T;

typedef struct {                             
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			cc:4;       /* CSRC count */  
	WORD 			x:1;        /* header extension flag */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* version type 1/2 */
	WORD		 	pt:7;       /* payload type */
	WORD			m:1;        /* marker bit */  

	WORD			seq;		/* sequence number */
	DWORD 			ts;         /* timestamp */
	DWORD 			ssrc;       /* synchronization source */
	DWORD 			csrc[1];    /* optional CSRC list */
	} RTP_HDR_T;

typedef struct {
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			count:5;    /* varies by payload type */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* protocol version */
	WORD		 	pt:8;       /* payload type */

    WORD			length;     /* packet length in words, without this word */
	} RTCP_COMMON_T;

/* reception report */
typedef struct {
	DWORD			ssrc;       /* data source being reported */
	DWORD			received;   /* cumulative number of packets received */
	DWORD			expected;   /* cumulative number of packets expected */
	DWORD			jitter;     /* interarrival jitter */
	DWORD			lsr;        /* last SR packet from this source */
	DWORD			dlsr;       /* delay since last SR packet */
	} RTCP_RR_T;

typedef struct {
	BYTE			sdesType;       /* type of SDES item (rtcp_sdes_type_t) */
	BYTE			sdesLength;     /* length of SDES item (in octets) */
	char 			sdesData[1];    /* text, not zero-terminated */
	} RTCP_SDES_ITEM_T;

typedef struct {
	DWORD 		ssrc;       /* source this RTCP packet refers to */
	DWORD 		ntp_sec;    /* NTP timestamp */
	DWORD 		ntp_frac;
	DWORD 		rtp_ts;     /* RTP timestamp */
	DWORD 		psent;      /* packets sent */
	DWORD 		osent;      /* octets sent */ 
		
	RTCP_RR_T 	rr[1];		/* variable-length list */
	} SENDER_RPT;

typedef struct {
	DWORD 		ssrc;        /* source this generating this report */
	RTCP_RR_T rr[1];		 /* variable-length list */
	} RECEIVER_RPT;

typedef struct {
	DWORD 		src[1];   	 /* list of sources */
		
	/* can't express trailing text */
	} BYE_PCKT;

typedef struct {
	DWORD 	src;              /* first SSRC/CSRC */
	RTCP_SDES_ITEM_T item[1]; /* list of SDES items */
	} RTCP_SDES_T;

/* one RTCP packet */
typedef struct {
	RTCP_COMMON_T	common;     /* common header */
	
	union 
		{
		SENDER_RPT		sr;		/* sender report (SR) */
		RECEIVER_RPT	rr;		/* reception report (RR) */
		BYE_PCKT		bye;	/* BYE */
		RTCP_SDES_T		sdes;	/* source description (SDES) */
		} r;
	} RTCP_T;


typedef DWORD MEMBER_T;


#endif /* ifndef _RTP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\smtypes.h ===
/*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
// Filename : SMTypes.h
// Purpose  : Declares structures used in the external interfaces of
//            the RTP Streams Manager. Must be #included by any
//            program which uses ISM.h.
// Contents :
//      STRM_HSTREAM    Typedef for the Stream Handle type used
//                      in STRM_CreateRecvStream, STRM_CreateSendStream,
//                      and a couple of other routines.
//      STRM_SESSION_ADDRESSES  Structure whichb contains the addresses
//                              to bind a RTP and RTCP socket to.
//      STRM_USER_DESCRIPTION_ID Enumeration of the possible fields used
//                               in a stream user description.
//      STRM_USER_DESCRIPTION_FIELD Field for an individual user description.
//      STRM_USER_DESCRIPTION   One or more user description fields.
//      STRM_SESSIONSTATUS      Enumeration of the stream status message types.
//      STRM_ENCRYPTION_TYPE    Enumeration of the possible encryption types
//                              supported by the SM.
//      STRM_SOCKET_GROUP_INFO  Socket group info.
//      STRM_XXXXX_INFO         Series of possible status messages from
//                              the SM to the external app.
//      STRM_BUFFERING_INFO     Buffering info for a stream.
*M*/

#ifndef _SMTYPES_H_
#define _SMTYPES_H_

typedef UINT                    STRM_HSTREAM;
#define STRM_INVALID_HSTREAM    0

/*D*
// Name     : STRM_SESSION_ADDRESSES
// Purpose  : Indicates the addresses to bind our RTP and RTCP sockets to.
// Context  : Passed to the RTP Streams Manager in STRM_InitSession().
// Fields   :
//      lpControlAddr   Address of the RTCP socket.
//      iControlAddrLen Length of lpControlAddr structure.
//      lpDataAddr      Address of the RTP socket.
//      iDataAddrLen    Length of lpDataAddr structure.
*D*/
typedef struct _strm_session_addresses
{
    LPSOCKADDR  lpControlAddr;
    int         iControlAddrLen;
    LPSOCKADDR  lpDataAddr;
    int         iDataAddrLen;
} STRM_SESSION_ADDRESSES;


typedef enum _strm_user_description_id
{
    CNAME = 0,
    NAME = 1,
    EMAIL = 2,
    PHONE = 3,
    LOC = 4,
    TOOL = 5,
    NOTE = 6,
    PRIV =7,
    STRM_USER_DESCRIPTION_ID_INVALID = 8
} STRM_USER_DESCRIPTION_ID;


/*D*
// Name     : STRM_USED_DESCRIPTION_FIELD
// Purpose  : Individual field value of a used description.
// Context  : A vararray of these is passed to the 
//            RTP Streams Manager in STRM_InitSession()
// Fields   :
//      dType           Constant indicating the description field type
//      pDescription    String with the actual info.
//                      Should be 255 chars or less.
//		iDescriptionLen Number of characters in the pDescription field.
//      iFrequency      Percentage value between 0 and 100 for how
//                      often in the SDES reports this should be xmitted.
//      bEncrypted      Whether this field should be encrypted or not.
*D*/
#define MAX_STRM_USER_DESCRIPTION	256

typedef struct _strm_user_description_field
{
    STRM_USER_DESCRIPTION_ID    dType;
    char                        pDescription[MAX_STRM_USER_DESCRIPTION];
    int                         iDescriptionLen;
    int                         iFrequency;
    BOOL                        bEncrypted;
} STRM_USER_DESCRIPTION_FIELD;


/*D*
// Name     : STRM_USER_DESCRIPTION
// Purpose  : User description information used in SDES reports.
// Context  : Passed into the RTP Streams Manager in STRM_InitSession()
// Fields   :
//      iNumFields  Number of user description fields passed in.
//      aField      Vararray of STRM_USER_DESCRIPTION_FIELDS.
*D*/
typedef struct _strm_user_description
{
    int                         iNumFields;
    STRM_USER_DESCRIPTION_FIELD aField[8];
} STRM_USER_DESCRIPTION;


typedef enum _strm_sessionstatus
{
    STRM_NEWSOURCE,
    STRM_RECVREPORT,
    STRM_STREAMMAPPED,
    STRM_LOCALCOLLISION,
    STRM_REMOTECOLLISION,
    STRM_QOSCHANGE,
    STRM_TIMEOUT,
    STRM_BYE
} STRM_SESSIONSTATUS;


typedef enum
{
    STRM_NOENCRYPTION,
    STRM_DES,
    STRM_TRIPLEDES
} STRM_ENCRYPTION_TYPE;


/*D*
// Name     : STRM_ENCRYPTION_INFORMATION
// Purpose  : Information necessary to encrypt a RTP session, if desired.
// Context  : Passed to RTP Streams Manager in STRM_StartSession()
// Fields   :
//      eType       Constant indicating the encryption type to use.
//      iKeyLength  Length of the key passed in.
//      pKey        Pointer to a buffer of length iKeyLength
//                  containing the actual key to use.
// Notes    :
//      Note that just because an eType is specified for the RTP 
//      Streams Manager does not mean that the underlying RRCM
//      supports the encryption type in question. Currently,
//      STRM_DES works (RRCM supports DES) but STRM_TRIPLEDES does not.
*D*/
typedef struct _strm_encryption_information
{
    STRM_ENCRYPTION_TYPE        eType;
    int                         iKeyLength;
    BYTE *                      pKey;
} STRM_ENCRYPTION_INFORMATION;


/*D*
// Name     : STRM_SOCKET_GROUP_INFO
// Purpose  : Encapsulates info about socket group and relative
//            priority for sockets created in Streams Manager sessions.
// Context  : Passed to the RTP Streams Manager in STRM_InitSession()
// Fields   :
//      groupID     Identifier for a socket group. On input should
//                  either be initialized to a valid socket group
//                  identifier or should be SG_UNCONSTRAINED_GROUP 
//                  (from WinSock 2) if sockets belong to a newly
//                  created group.
//      iPriority   Relative priority of this socket within the socket group.
*D*/
typedef struct _strm_socket_group_info
{
    GROUP                       groupID;
    int                         iPriority;
} STRM_SOCKET_GROUP_INFO;


/*D*
// Name     : STRM_NEWSOURCE_INFO
// Purpose  : Indicates a new stream (SSRC) has been detected.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRC   SSRC of the new stream.
*D*/
typedef struct _strm_newsource_info
{
    DWORD                       dSSRC;
    WORD                        wPayloadType;
} STRM_NEWSOURCE_INFO;


/*D*
// Name     : STRM_RECVREPORT_INFO
// Purpose  : Indicates that a new SDES report was received.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRC           SSRC of the mapped stream
//      dStreamUserRef  User reference value passed in when
//                      the stream was requested to be mapped.
*D*/
typedef struct _strm_recvreport_info
{
    DWORD                       dSSRC;
    DWORD                       dStreamUserRef;
} STRM_RECVREPORT_INFO;

/*D*
// Name     : STRM_STREAMMAPPED_INFO
// Purpose  : Indicates that a particular SSRC has been
//            successfully mapped to a stream.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRC           SSRC of the mapped stream
//      dStreamUserRef  User reference value passed in when
//                      the stream was requested to be mapped.
*D*/
typedef struct _strm_streammapped_info
{
    DWORD                       dSSRC;
    WORD                        wPayloadType;
    DWORD                       dStreamUserRef;
} STRM_STREAMMAPPED_INFO;


/*D*
// Name     : STRM_LOCALCOLLISION_INFO
// Purpose  : Indicates that a local SSRC collided with some
//            other detected SSRC in this RTP session.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRCold        Old (collided) SSRC.
//      dSSRC           New SSRC for this stream.
//      dStreamUserRef  User reference value passed in when
//                      the stream was requested to be mapped.
*D*/
typedef struct _strm_localcollision_info
{
    DWORD                       dSSRCold;
    DWORD                       dSSRC;
    DWORD                       dStreamUserRef;
} STRM_LOCALCOLLISION_INFO;


/*D*
// Name     : STRM_REMOTECOLLISION_INFO
// Purpose  : Indicates that a remote SSRC was discarded
//            because it collided with another SSRC.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRC   SSRC of the collided stream in question.
*D*/
typedef struct _strm_remotecollision_info
{
    DWORD                       dSSRC;
} STRM_REMOTECOLLISION_INFO;


/*D*
// Name     : STRM_QOSCHANGE_INFO
// Purpose  : Indicates that a QOS change has occurred which applies
//            to either this socket group or just this session.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      bGroup      TRUE if it applies to the socket group,
//                  FALSE if it only applies to this session.
//      lpNewQOS    New QOS parameters for this group/session.
*D*/
typedef struct _strm_qoschange_info
{
    BOOL                        forGroup;
    QOS                         *lpNewQOS;
} STRM_QOSCHANGE_INFO;


/*D*
// Name     : STRM_TIMEOUT_INFO
// Purpose  : Indicates that a SSRC sender or listener timed out
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRC           SSRC of the sender/listener that timed out.
//      dStreamUserRef  User reference value passed in when
//                      the stream was requested to be mapped.
*D*/
typedef struct _strm_timeout_info
{
    DWORD                       dSSRC;
    DWORD                       dStreamUserRef;
} STRM_TIMEOUT_INFO;


/*D*
// Name     : STRM_BYE_INFO
// Purpose  : Indicates that a SSRC sender or listener
//            has left the session.
// Context  : RTP Streams Manager passes this structure to
//            controlling app via a SessionStatusCallback()
// Fields   :
//      dSSRC           SSRC of the sender/listener that left.
//      dStreamUserRef  User reference value passed in when
//                      the stream was requested to be mapped.
*D*/
typedef struct _strm_bye_info
{
    DWORD                       dSSRC;
    DWORD                       dStreamUserRef;
    char                        *lpszReason;
} STRM_BYE_INFO;


typedef union _strm_statusspecific
{
    STRM_NEWSOURCE_INFO         newsource;
    STRM_RECVREPORT_INFO        recvreport;
    STRM_STREAMMAPPED_INFO      streammapped;
    STRM_LOCALCOLLISION_INFO    localcollision;
    STRM_REMOTECOLLISION_INFO   remotecollision;
    STRM_QOSCHANGE_INFO         qoschange;
    STRM_TIMEOUT_INFO           timeout;
    STRM_BYE_INFO               bye;
} STRM_STATUSSPECIFIC;


typedef void (CALLBACK STRM_STATUS_CALLBACK) (
	DWORD				        dSessionUserRef,           
	STRM_SESSIONSTATUS	        uStatusCode,             
	STRM_STATUSSPECIFIC	        *lpStatusSpecific        
);                                 


/*D*
// Name     : STRM_BUFFERING_INFO
// Purpose  : Used to specify buffering info 
// Context  : Passed to RTP Streams Manager in 
//            STRM_CreateRecvStream and STRM_CreateSendStream
// Fields   :
//      bufferSize      Size of the buffers to use. Maximum size of the
//                      MTU for the underlying transport.
//      minimumCount    Minimum number of buffers. This is the value
//                      things are initialized to.
//      maximumCount    Maximum number of buffers count is allowed to
//                      grow to.
*D*/
typedef struct _strm_buffering_info
{
    UINT                        bufferSize;
    UINT                        minimumCount;
    UINT                        maximumCount;
} STRM_BUFFERING_INFO;

// OLE2 mandates that interface specific error codes
// be HRESULTs of type FACILITY_INF (eg, 8002 for the
// first two bytes) and that the second two bytes be
// in the range of 0x0200 to 0xFFFF. I chose 0xBA00-
// arbitrarily as a value within that range. Note that
// OLE2 explicitly states that two different interfaces
// may return numerically identical error values, so
// it is critical that an app not only take into account
// the numerical value of a returned error code but the
// function & interface which returned the error as well.
#define STRME_PARAM_1       0x8004BA01
#define STRME_PARAM_2       0x8004BA02
#define STRME_PARAM_3       0x8004BA03
#define STRME_PARAM_4       0x8004BA04
#define STRME_PARAM_5       0x8004BA05
#define STRME_PARAM_6       0x8004BA06
#define STRME_PARAM_7       0x8004BA07
#define STRME_PARAM_8       0x8004BA08
#define STRME_PARAM_9       0x8004BA09
#define STRME_PARAM_10      0x8004BA0A
#define STRME_PARAM_11      0x8004BA0B
#define STRME_PARAM_12      0x8004BA0C
#define STRME_NOGROUP       0x8004BA10
#define STRME_NOCNAME       0x8004BA11
#define STRME_SSRC          0x8004BA12
#define STRME_NOSESS        0x8004BA13
#define STRME_NOSTREAM      0x8004BA14
#define STRME_SESSSTATE     0x8004BA15
#define STRME_NOSUPPORT     0x8004BA16
#define STRME_QOSFAIL		0x8004BA17
#define STRME_GROUPQOSFAIL	0x8004BA18
#define STRME_DUPCNAME		0x8004BA19
#define STRME_DUPSSRC		0x8004BA1A
#define STRME_NOMAP			0x8004BA1B
#define STRME_BUFSIZE		0x8004BA1C
#define STRME_NOTIMPL		0x8004BA1D
#define STRME_DESTSET		0x8004BA1E
#define STRME_NODEST		0x8004BA1F

#endif  _SMTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\smuids.h ===
#ifndef _ACTIVERTPUIDS_H_
#define _ACTIVERTPUIDS_H_

// CLSID_RTPStreamsManager
// {CD59C044-AE58-11cf-B839-00AA0053A236}
DEFINE_GUID(CLSID_RTPStreamsManager, 
0xcd59c044, 0xae58, 0x11cf, 0xb8, 0x39, 0x0, 0xaa, 0x0, 0x53, 0xa2, 0x36);

#endif _ACTIVERTPUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\strmspif.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/strmspif.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.5  $
 *	$Date:   09 Oct 1996 08:48:50  $
 *	$Author:   RKUHN  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		Media Service Manager "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with MSM. Any EXE or DLL which interacts with
 *		MSM will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

// strmspif.h

#ifndef _STRMSPIF_H_
#define _STRMSPIF_H_

#include "smtypes.h"
#include "rrcm_dll.h"
#include "apimsp.h"
#include "apierror.h"

// define Source and Sink MSP IDs
#define STRMSP_SRC "IntelNetIORTPStreamSrc"
#define STRMSP_SNK "IntelNetIORTPStreamSnk"

// version number
#define STRMSP_INTERFACE_VERSION           0x1

typedef DWORD STRMSP_HSESSION;


//**********************************
// structures used in interface calls
//**********************************

//***************************************************************************************
/* STRMSP_SESSION_ATTRIBUTES 

uMulticastFlags	Flags defining the multicast characteristics of this session.  
				Valid flag values are WSA_FLAG_MULTIPOINT_C_ROOT, 
				WSA_FLAG_MULTIPOINT_C_LEAF, WSA_FLAG_MULTIPOINT_D_ROOT, and 
				WSA_FLAG_MULTIPOINT_D_LEAF with usage and semantics as defined 
				in the Winsock 2 used.

dwSSRC			Is a DWORD specifying the SSRC value to be used to identify the 
				RTP session.  This will be the SSRC value used for the first 
				sending stream created within this session or for RTCP receiver 
				reports for this session even if no sending stream is opened.  
				If the value of the SSRCSpecified parameter is FALSE, the value 
				of this parameter is ignored and an SSRC value will be generated 
				during the call.  NOTE:  The SSRC value of a stream can be 
				reassigned dynamically because of collisions.  Applications should 
				use the STRMSP_NEWSOURCE Application Command facility to track any 
				such changes.

bSSRCSpecified	Is a BOOLEAN specifying whether a user supplied SSRC value has been 
				placed in the buffer pointed to by dSSRC.  If TRUE, the user has 
				specified an SSRC value to use used.

pGroupInfo		Pointer to a STRM_SOCKET_GROUP_INFO structure specifying group id 
				and relative priority for sockets created for this RTP session.  
				If the groupID field is zero, sockets are not grouped.  If the 
				groupID field is SG_UNCONSTRAINED_GROUP, a new socket group will 
				be created.  Otherwise any sockets created will be part of the socket 
				group specified by the GroupID field used. 

pSessionUser	Pointer to a STRM_USER_DESCRIPTION structure containing information 
				about the user of this session.  This information is used by RTCP to 
				generate session description packets.  A CNAME description field must 
				be included, and other fields may be required based on the RTP profile 
				being used.
*/
typedef struct _strmsp_session_attributes
{
	UINT					uMulticastFlags;
	DWORD					dwSSRC;
	BOOL					bSSRCSpecified;
	STRM_SOCKET_GROUP_INFO	*pGroupInfo;
	STRM_USER_DESCRIPTION	*pSessionUser;
} STRMSP_SESSION_ATTRIBUTES, *LPSTRMSP_SESSION_ATTRIBUTES;


//***************************************************************************************
/* STRMSP_SESSION_STARTUP_PARAMS

DestAddr		Is a STRM_SESSION_ADDRESSES structure containing the addresses that 
				data and control messages for this RTP session will be sent to.  
				These values must be specified even if no sink ports will be created 
				on this RTP session.

uMulticastScope	Is a UINT specifying the IP multicast time-to-live (TTL) value to use 
				for transmitting streams on this session.  The multicast scope for this 
				session may also be modified at any time by using 
				STRMSP_SETMULTICASTSCOPE MSP command.  If the DestAddr field does not 
				specify a multicast address, this field is ignored.

SingleQOS		Is a QOS structure containing the requested QOS parameters for this RTP 
				session.

GroupQOS		Is a QOS structure containing the requested QOS parameters for the group 
				this RTP session belongs to.  This field is only valid when used in 
				conjunction with the initial RTP session in a group.

BufferInfo		Is a STRM_BUFFERING_INFO structure where the initial buffering 
				requirements for this session are specified. The value of the uBufferSize 
				field of this structure will be used as the size for all buffers required 
				on this session. The uMinimumCount field value will set the initial and 
				minimum number of buffers for the session (and maximum also if the Streams 
				manager implementation does not support dynamic buffer allocation.)  The 
				uMaximumCount field value will set an upper limit for the total number of 
				buffers allowed in this session.

EncriptionInfo	Is a STRM_ENCRYPTION_INFORMATION structure containing information about 
				any encryption or decryption to be done on the session.

iStreamClock	Is an integer specifying the clocking frequency for the initial sending 
				stream in this session (in hz.).
*/
typedef struct _strmsp_session_startup_params
{
	STRM_SESSION_ADDRESSES		DestAddr;	
	UINT						uMulticastScope;
	QOS							SingleQOS;
	QOS							GroupQOS;
	STRM_BUFFERING_INFO			BufferInfo;
	STRM_ENCRYPTION_INFORMATION EncryptionInfo;
	int							iStreamClock;
} STRMSP_SESSION_STARTUP_PARAMS, *LPSTRMSP_SESSION_STARTUP_PARAMS;


//***************************************************************************************
/* STRMSP_OPENSERVICE_IN_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

protInfo	Is a pointer to a WSAPROTOCOL_INFO structure that contains information about the network 
			protocol to use and the type of sockets to create for this service instance.  
			The structure may be empty (all nulls) when passed to this function, in 
			which case a UDP service provider will be searched for and used for data 
			transport.  The structure also may be initialized with only the iProtocol 
			field initialized, in which case a service provider of the specified type 
			and supporting an unconnected socket type will be searched for and used.  
			Finally, the entire structure may be initialized (as with WSAEnumProtocols) 
			to unequivocally specify the protocol and socket type to be used.
*/
typedef struct _strmsp_openservice_in_info
{
	UINT				uVersion;
	WSAPROTOCOL_INFO	*pProtocolInfo;
} STRMSP_OPENSERVICE_IN_INFO, *LPSTRMSP_OPENSERVICE_IN_INFO;


//***************************************************************************************
/* STRMSP_OPENSERVICE_OUT_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

protInfo	A pointer to a WSAPROTOCOL_INFO structure where the Winsock 2 Service Provider 
			protocol information actual used for this STRMSP service instance will be returned.
*/
typedef struct _strmsp_openservice_out_info
{
	UINT				uVersion;
	WSAPROTOCOL_INFO	*pProtocolInfo;
} STRMSP_OPENSERVICE_OUT_INFO, *LPSTRMSP_OPENSERVICE_OUT_INFO;


//***************************************************************************************
/* STRMSP_CREATESESSION_IN_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

SessionAddr		Is a STRM_SESSION_ADDRESSES structure containing requested RTP and RTCP 
				network addresses for this session.  If session addresses specified here 
				are empty (null) when passed to MSM_SendServiceCmd(), appropriate 
				addresses will be assigned and returned in the corresponding output 
				structure.  If the addresses are specified, they must conform to the 
				conventions established for RTP/RTCP sockets in RFC 1889.  The value of 
				the sa_family fields of these addresses, if specified, must be the address 
				family supported by the protocol specified (implicitly or explicitly) in 
				MSM_OpenService() call.

SessionAttribs	Is a STRMSP_SESSION_ATTRIBUTES structure containing requested attributes 
				for this session.  See description of STRMSP_SESSION_ATTRIBUTES above for 
				specifics on the contents of each field.

dwSessionToken	Is a uninterpreted DWORD value which will be passed back as a parameter 
				to application commands relating to this session.  The application may use 
				this as a reference to session specific data.
*/
typedef struct _strmsp_createsession_in_info
{
	UINT						uVersion;
	STRM_SESSION_ADDRESSES		SessionAddr;
	STRMSP_SESSION_ATTRIBUTES	SessionAttribs;
	DWORD						dwSessionToken;
} STRMSP_CREATESESSION_IN_INFO, *LPSTRMSP_CREATESESSION_IN_INFO;


//***************************************************************************************
/* STRMSP_CREATESESSION_OUT_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession	Returns a handle to be used in commands referring to this session.

SessionAddr	Returns a STRM_SESSION_ADDRESSES structure containing the actual RTP and RTCP 
			network addresses for this session.

dwSSRC		Returns a DWORD containing the actual SSRC value assigned to this session.

uGroup		Returns a UINT containing the socket group assigned to sockets in this session.  
			This is only returned in a non-zero group identifier was specified in the group 
			information field of the Session Attributes structure of the input information.
*/
typedef struct _strmsp_createsession_out_info
{
	UINT						uVersion;
	STRMSP_HSESSION				hSession;
	STRM_SESSION_ADDRESSES		SessionAddr;
	DWORD						dwSSRC;
	UINT						uGroup;
} STRMSP_CREATESESSION_OUT_INFO, *LPSTRMSP_CREATESESSION_OUT_INFO;


//***************************************************************************************
/* STRMSP_STARTSESSION_IN_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession		Is a STRMSP_HSESSION containing the handle for the session to be started, 
				as returned from a successful CREATESESSION command.

StartupParams	Is a STRMSP_SESSION_STARTUP_PARAMS structure containing startup parameters 
				for this session.  See description of STRMSP_SESSION_STARTUP_PARAMS above 
				for specifics on the contents of each field.
*/
typedef struct _strmsp_startsession_in_info
{
	UINT							uVersion;
	STRMSP_HSESSION					hSession;
	STRMSP_SESSION_STARTUP_PARAMS	StartupParams;
} STRMSP_STARTSESSION_IN_INFO, *LPSTRMSP_STARTSESSION_IN_INFO;


//***************************************************************************************
/* STRMSP_CLOSESESSION_IN_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession	Is a STRMSP_HSESSION containing the handle for the session to be started, 
			as returned from a successful CREATESESSION command.

lpReason	Is a pointer to a optional null terminated string declaring a reason for 
			closing the RTP Streams Manager session.  The contents of this string are 
			passed to remote participants for application use.
*/
typedef struct _strmsp_closesession_in_info
{
	UINT			uVersion;
	STRMSP_HSESSION	hSession;
	const char*		lpReason;
} STRMSP_CLOSESESSION_IN_INFO, *LPSTRMSP_CLOSESESSION_IN_INFO;


//***************************************************************************************
/* STRMSP_GETMTUSIZE_OUT_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession	Is a STRMSP_HSESSION containing the handle for the session referenced, as 
			returned from a successful CREATESESSION command.

uMTUSize	UINT that is the maximum size of a transport data unit.
			This is the size of the largest buffer that may be submitted to a port created 
			from this STRMSP session.
*/
typedef struct _strmsp_getmtusize_out_info
{
	UINT			uVersion;
	STRMSP_HSESSION hSession;
	int				iMTUSize;
} STRMSP_GETMTUSIZE_OUT_INFO, *LPSTRMSP_GETMTUSIZE_OUT_INFO;


//***************************************************************************************
/* STRMSP_SETMULTICASTSCOPE_IN_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession		Is a STRMSP_HSESSION containing the handle for the session, as returned 
				from a successful CREATESESSION command.

uMulticastScope Is a UINT that specifies the IP multicast time-to-live (TTL) value to use 
				for transmitting streams on this session.
*/
typedef struct _strmsp_setmulticastscope_in_info
{
	UINT			uVersion;
	STRMSP_HSESSION hSession;
	UINT			uMulticastScope;
} STRMSP_SETMULTICASTSCOPE_IN_INFO, *LPSTRMSP_SETMULTICASTSCOPE_IN_INFO;


//***************************************************************************************
/* STRMSP_SETQOS_IN_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession	Is a STRMSP_HSESSION containing the handle for the session, as returned from 
			a successful CREATESESSION command.

bGroupQOS	Is a BOOLEAN specifying whether the QOS structure field is for a socket group 
			(TRUE) or for this session only (FALSE.)  If this value is TRUE, the Handle 
			field must contain the session handle for the initial session of the group 
			(the session on which the creation of the group was specified.)

RequestedQOS	is a QOS structure containing the newly requested QOS parameters.
*/
typedef struct _strmsp_setqos_in_info
{
	UINT			uVersion;
	STRMSP_HSESSION hSession;
	BOOL			bGroupQOS;
	QOS				RequestedQOS;
} STRMSP_SETQOS_IN_INFO, *LPSTRMSP_SETQOS_IN_INFO;


//***************************************************************************************
/* STRMSP_GETSESSIONREPORTS_IN_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession		Is a STRMSP_HSESSION containing the handle for the session, as returned 
				from a successful CREATESESSION command.

iFilterFlags	Is an int containing bit flags specifying filters that can be used to 
				select subsets of the RTCP_REPORT structures available on this session.  
				The value 0 disables all filtering and allows all available report data 
				to be read.  Other filter flag definitions TBD.

iFilterPattern	Is an int containing a pattern to be used for filtering the reports.  
				Format of this pattern depends on the filter flags selected in the 
				iFilterFlags parameter.  Specifics TBD.

iEntryIndex		Is an int containing the index of first RTCP_REPORT structure to be 
				returned.  Valid index values start from 0 (for the first RTCP_REPORT 
				structure) and go up to one less that the total number of entries.

lpReport		Is a pointer to a caller supplied buffer where RTCP_REPORT structures will 
				be copied.  This buffer should be sized to hold an integral number of 
				RTCP_REPORT structures.

iReportLen		Is an int containing the size in bytes of the buffer pointed to by the 
				lpReport field.
*/
typedef struct _strmsp_getsessionreports_in_info
{
	UINT			uVersion;
	STRMSP_HSESSION hSession;
	int				iFilterFlags;
	int				iFilterPattern;
	int				iEntryIndex;
	RTCP_REPORT*	lpReport;
	int				iReportLen;
} STRMSP_GETSESSIONREPORTS_IN_INFO, *LPSTRMSP_GETSESSIONREPORTS_IN_INFO;


//***************************************************************************************
/* STRMSP_GETSESSIONREPORTS_OUT_INFO

uVersion			Is the version identifier for this data structure.  The value 
					STRMSP_INTERFACE_VERSION should always be used to initialize it.

iEntriesReturned	Is an int where the number of RTCP_REPORT structures actually copied 
					into buffer pointer to by the lpReport field will be returned.

iNextIndex  		Is an int where the index of the next RTCP_REPORT structure will be 
					returned.  This value can be used as the value of the iEntryIndex 
					field of subsequent calls to obtain all reports when the report buffer 
					size is too small to hold then all at once.  A value of zero (0) 
					returned here indicates that all remaining reports have been returned.
*/
typedef struct _strmsp_getsessionreports_out_info
{
	UINT			uVersion;
	int				iEntriesReturned;
	int				iNextIndex;
} STRMSP_GETSESSIONREPORTS_OUT_INFO, *LPSTRMSP_GETSESSIONREPORTS_OUT_INFO;


//***************************************************************************************
/* STRMSP_SETDESTINATIONADDRESS_IN_INFO

uVersion				Is the version identifier for this data structure.  The value 
						STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession				Is a STRMSP_HSESSION containing the handle for the session referenced, as 
						returned from a successful CREATESESSION command.

pDestinationAddr		is a pointer to the network address to be used for sending data

iDestinationAddrLength	is the length in bytes of the data network address

*/
typedef  struct _strmsp_setdestinationaddress_in_info
{
		UINT					uVersion;
		STRMSP_HSESSION			hSession;
		LPSOCKADDR				pDestinationAddr;
		int						iDestinationAddrLength;
} STRMSP_SETDESTINATIONADDRESS_IN_INFO;


//***************************************************************************************
/* STRMSP_GENERATESSRC_IN_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession	Is a STRMSP_HSESSION containing the handle for the session referenced, as 
			returned from a successful CREATESESSION command.

pdwSSRC		pointer to where the newly generated SSRC will be stored

*/
typedef  struct _strmsp_generatessrc_out_info
{
		UINT					uVersion;	
		STRMSP_HSESSION			hSession;						
		DWORD					*pdwSSRC;
} STRMSP_GENERATESSRC_OUT_INFO;


//***************************************************************************************
/* STRMSP_NEWSOURCE_IN_INFO

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure is are valid.

uSessionToken	Is the UINT value the application provided as a reference when creating 
				this session.

dwSSRC			Is the RTP SSRC identifier for the newly detected source.  This value can 
				be used for creating a STRMSP source port mapped to this data stream.

wPayloadType	Is the RTP payload type identifier for the newly detected source.  This 
				value is used to match this stream of data with an appropriate payload 
				handler.
*/
typedef struct _strmsp_newsource_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
	WORD	wPayloadType;
} STRMSP_NEWSOURCE_IN_INFO, *LPSTRMSP_NEWSOURCE_IN_INFO;


//***************************************************************************************
/* STRMSP_RECVREPORT_IN_INFO

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure are valid.

dwSessionToken	Is the DWORD value the application provided as a reference when creating 
				this session.

dwSSRC			Is the RTP SSRC identifier for the data stream a report has been received 
				for.  This value can be used for identifying the newly arrived report when 
				using the GETSESSIONREPORTS service command.
*/
typedef struct _strmsp_recvreport_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
} STRMSP_RECVREPORT_IN_INFO, *LPSTRMSP_RECVREPORT_IN_INFO;


//***************************************************************************************
/* STRMSP_QOSCHANGE_IN_INFO

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure are valid.

dwSessionToken	Is the DWORD value the application provided as a reference when creating 
				this session.

bGroup			Is a Boolean indicating whether the QOS change is associated with a socket 
				group (TRUE) or with this session only (FALSE.)

NewQOS			Is a QOS structure giving the new QOS parameters for this sessions data 
				socket or socket group.
*/
typedef struct _strmsp_qoschange_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	BOOL	bGroup;
	QOS		NewQOS;
} STRMSP_QOSCHANGE_IN_INFO, *LPSTRMSP_QOSCHANGE_IN_INFO;


//***************************************************************************************
/* STRMSP_SRCTIMEOUT_IN_INFO 

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure are valid.

uSessionToken	Is the UINT value the application provided as a reference when creating 
				this session.

dwSSRC			Is the RTP SSRC identifier for the data stream that has timed-out.
*/
typedef struct _strmsp_srctimeout_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
} STRMSP_SRCTIMEOUT_IN_INFO, *LPSTRMSP_SRCTIMEOUT_IN_INFO;


//***************************************************************************************
/* STRMSP_SRCBYE_IN_INFO 

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure are valid.

dwSessionToken	Is the DWORD value the application provided as a reference when creating 
				this session.

dwSSRC			Is the RTP SSRC identifier for the data stream that is closing.
*/
typedef struct _strmsp_srcbye_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
} STRMSP_SRCBYE_IN_INFO, *LPSTRMSP_SRCBYE_IN_INFO;


//***************************************************************************************
/* STRMSP_NEWSSRC_IN_INFO

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure are valid.

dwSessionToken	Is the DWORD value the application provided as a reference when creating 
				this session.

dwSSRC			Is the newly assigned RTP SSRC identifier for this data stream.
*/
typedef struct _strmsp_newssrc_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
} STRMSP_NEWSSRC_IN_INFO, *LPSTRMSP_NEWSSRC_IN_INFO;


//***************************************************************************************
/* STRMSP_SINK_OPENPORT_IN_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession		Is a STRMSP_HSESSION containing the handle for the session to be started, 
				as returned from a successful CREATESESSION command.

dwSSRC			Is a DWORD where the SSRC value to be used for this port may be specified.  
				If the value of the SSRCSpecified parameter is FALSE, the input value of 
				this parameter is ignored and an SSRC value will be generated during the call. 
				NOTE:  The SSRC value of a stream can be reassigned dynamically because of 
				collisions.  Applications should use the STRMSP_NEWSSRC command passed to the 
				port callback handler to track any such changes.

bSSRCSpecified	Boolean specifying whether a user supplied SSRC value has been placed in SSRC.  
				If TRUE, the user has specified an SSRC value to use.

pStreamUser		Pointer to a STRM_USER_DESCRIPTION structure containing information about 
				the user of this stream.  This information is used by RTCP to generate session 
				description packets.  A CNAME description field must be included, and other 
				fields may be required based on the RTP profile being used. If this is the 
				first send stream being created this field will be ignored and the user 
				description information specified in the CREATESESSION service command for 
				this session will be used instead.

uBufferCount	Is a UINT requesting the number of buffer resources to have available for 
				the use of this stream.  In the case of send streams, this is the number of 
				buffers that may be expected to sent in a single burst.  Although the caller 
				provides the data buffers themselves, the Streams MSP must allocate resources 
				for tracking those buffers.  This value allows versions of the Streams MSP that 
				support dynamic buffer allocation to efficiently allocate buffer resources.  
				Note that this value is advisory only and may be ignored by some Streams MSP 
				implementations.

iStreamClock	Is an integer specifying the clocking frequency for this stream (in hz.). If 
				this is the first send stream being created this field will be ignored and the 
				iStreamClock value specified in the STARTSESSION service command for this 
				session will be used instead.
*/
typedef struct _strmsp_sink_openport_in_info
{
	UINT					uVersion;
	STRMSP_HSESSION			hSession;
	STRM_USER_DESCRIPTION	*pStreamUser;
	DWORD					dwSSRC;
	BOOL					bSSRCSpecified;
	UINT					uBufferCount;
	int						iStreamClock;
} STRMSP_SINK_OPENPORT_IN_INFO, *LPSTRMSP_SINK_OPENPORT_IN_INFO;


//***************************************************************************************
/* STRMSP_SINK_OPENPORT_OUT_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

dwSSRC		Is a DWORD returning the actual SSRC assigned to this output stream.  This 
			value is used for determining what RTCP reports apply to this data stream.
*/
typedef struct _strmsp_sink_openport_out_info
{
	UINT					uVersion;
	DWORD					dwSSRC;
} STRMSP_SINK_OPENPORT_OUT_INFO, *LPSTRMSP_SINK_OPENPORT_OUT_INFO;


//***************************************************************************************
/* STRMSP_SETUSERDESCRIPTION_IN_INFO

uVersion	Is the version identifier for this data structure.  The value 
			STRMSP_INTERFACE_VERSION should always be used to initialize it.

pStreamUser	Is a pointer to a STRM_USER_DESCRIPTION structure containing information 
			about the user of this session.  This information is used by RTCP to generate 
			session description packets.  A CNAME description field must be included, and 
			other fields may be required based on the RTP profile being used.
*/
typedef struct _strmsp_setuserdescription_in_info
{
	UINT					uVersion;
	STRM_USER_DESCRIPTION	*pStreamUser;
} STRMSP_SETUSERDESCRIPTION_IN_INFO, *LPSTRMSP_SETUSERDESCRIPTION_IN_INFO;


//***************************************************************************************
/* STRMSP_GETMAPPING_OUT_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

dwSessionToken	Is the DWORD value the application provided as a reference to the session 
				this source port is a part of.

dwSSRC			Is the RTP SSRC identifier for the arriving data stream that has been 
				mapped to this source port.
*/
typedef struct _strmsp_getmapping_out_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
} STRMSP_GETMAPPING_OUT_INFO, *LPSTRMSP_GETMAPPING_OUT_INFO;


//***************************************************************************************
/* STRMSP_SOURCE_OPNEPORT_IN_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value STRMSP_INTERFACE_VERSION should always be used to initialize it.

hSession		Is a STRMSP_HSESSION containing the handle for the session to be started, 
				as returned from a successful CREATESESSION command.

dwSSRC			Is a DWORD where the SSRC value of the data source to be mapped to may be 
				specified.  If the value of the SSRCSpecified field is FALSE, the value of 
				this field is ignored and the stream will be automatically mapped to the 
				next available data source.

bSSRCSpecified	Boolean specifying whether a user supplied SSRC value has been placed in 
				SSRC.  If TRUE, the user has specified an SSRC value and the stream will 
				be mapped to the data source with that SSRC value only.

uBufferCount	Is a UINT requesting the number of buffer resources to have available for 
				the use of this stream.  In the case of receive streams, this is the number 
				of buffers that may be expected to be in process at any one time. The 
				Streams MSP must allocate these buffers itself for receiving from the 
				network.  This value allows versions of the Streams MSP that support 
				dynamic buffer allocation to efficiently allocate buffer resources.  Note 
				that this value is advisory only and may be ignored by some Streams manager 
				implementations.
*/
typedef struct _strmsp_source_openport_in_info
{
	UINT			uVersion;
	STRMSP_HSESSION	hSession;
	DWORD			dwSSRC;
	BOOL			bSSRCSpecified;
	UINT			uBufferCount;
} STRMSP_SOURCE_OPENPORT_IN_INFO, *LPSTRMSP_SOURCE_OPENPORT_IN_INFO;


//***************************************************************************************
/* STRMSP_MAPPED_IN_INFO

uVersion		Is the version identifier for this data structure.  A value of 1 or 
				greater indicates that the fields of this data structure are valid.

dwSessionToken	Is the DWORD value the application provided as a reference when creating 
				this session.

dwSSRC			Is the newly assigned RTP SSRC identifier for the arriving data stream.
*/
typedef struct _strmsp_mapped_in_info
{
	UINT	uVersion;
	DWORD	dwSessionToken;
	DWORD	dwSSRC;
} STRMSP_MAPPED_IN_INFO, *LPSTRMSP_MAPPED_IN_INFO;


//*****************************************
// MSP Service Commands
//*****************************************
// MSP_ServiceCmdProc()
#define STRMSP_CREATESESSION               0x0001    // create session
#define STRMSP_STARTSESSION                0x0002    // start session
#define STRMSP_CLOSESESSION                0x0003    // close session
#define STRMSP_GETMTUSIZE                  0x0004    // get max packet size
#define STRMSP_SETMULTICASTSCOPE           0x0005    // set multicast scope
#define STRMSP_SETQOS                      0x0006    // set QOS
#define STRMSP_GETSESSIONREPORTS           0x0007    // get session reports

// Sink Port Service Commands
#define STRMSP_SETUSERDESCRIPTION          0x0008	 // set user desc info

// Sink or Source  Port Service Command.
// The GETMAPPING command allows the application to determine
// the SSRC value of the data stream to the SINK or SOURCE port.
#define STRMSP_GETMAPPING                  0x0009	 // get mapping info

#define STRMSP_SETDESTINATIONADDRESS	   0x0010
#define STRMSP_GENERATESSRC				   0x0011


//*****************************************
// Application Commands from MSP
//*****************************************
#define STRMSP_NEWSOURCE					0x0001
#define STRMSP_RECVREPORT					0x0002
#define STRMSP_QOSCHANGE					0x0003
#define STRMSP_SRCTIMEOUT					0x0004
#define STRMSP_SRCBYE						0x0005
#define STRMSP_NEWSSRC						0x0006
#define STRMSP_MAPPED						0x0007

//**********************************
// error code definitions
//**********************************

// STRMSP defined error codes
#define STRMSP_ERR_BASE                     (ERROR_BASE_ID)
#define STRMSP_ERR_NOPROVIDER           	(STRMSP_ERR_BASE +1)

// these error codes are standard codes within the RMS architecture
#define STRMSP_ERR_INVALID_SERVICE          (ERROR_INVALID_SERVICE)
#define STRMSP_ERR_INVALID_MSPTYPE          (ERROR_INVALID_SERVICE_DLL)
#define STRMSP_ERR_INVALID_PORT             (ERROR_INVALID_PORT)
#define STRMSP_ERR_INVALID_BUFFER           (ERROR_INVALID_BUFFER)
#define STRMSP_ERR_INVALID_VERSION          (ERROR_INVALID_VERSION)
#define STRMSP_ERR_NOTINITIALIZED			(ERROR_INVALID_CALL_ORDER)

// these error codes are defined in "winerror.h"
#define STRMSP_ERR_NOTIMPL                  E_NOTIMPL		// not implemented
#define STRMSP_ERR_NOT_ENOUGH_MEMORY        E_OUTOFMEMORY   // out of memory
#define STRMSP_ERR_NOINTERFACE              E_NOINTERFACE   // no such interface            
#define STRMSP_ERR_INVALIDARG               E_INVALIDARG	// one or more parameters invalid
#define STRMSP_ERR_FAIL                     E_FAIL          // simply failed(unspecified error)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\wsw.h ===
/*
 * wsw.h
 *
 * $Revision:   1.5  $
 * $Date:   Jul 30 1996 15:27:14  $
 * $Author:   MLEWIS1  $
 *
 * Notes:
 * Winsock2.h must be included before including this file.
 * Before including winsock2.h, the symbol INCL_WINSOCK_API_TYPEDEFS
 * must be #defined as 1.
 */

#ifndef __WSW_H
#define __WSW_H

#ifndef INCL_WINSOCK_API_TYPEDEFS
#define INCL_WINSOCK_API_TYPEDEFS 1
#endif
#include <winsock2.h>

#ifdef __cplusplus
extern "C" {
#endif

extern LPFN_WSASTARTUP WSWStartup;
extern LPFN_WSACLEANUP WSWCleanup;
extern LPFN_BIND WSWbind;
extern LPFN_CLOSESOCKET WSWclosesocket;
extern LPFN_GETHOSTBYNAME WSWgethostbyname;
extern LPFN_GETHOSTBYADDR WSWgethostbyaddr;
extern LPFN_GETHOSTNAME WSWgethostname;
extern LPFN_GETSOCKNAME WSWgetsockname;
extern LPFN_GETSOCKOPT WSWgetsockopt;
extern LPFN_HTONL WSWhtonl;
extern LPFN_HTONS WSWhtons;
extern LPFN_INET_ADDR WSWinet_addr;
extern LPFN_INET_NTOA WSWinet_ntoa;
extern LPFN_IOCTLSOCKET WSWioctlsocket;
extern LPFN_NTOHL WSWntohl;
extern LPFN_NTOHS WSWntohs;
extern LPFN_RECVFROM WSWrecvfrom;
extern LPFN_SENDTO WSWsendto;
extern LPFN_SETSOCKOPT WSWsetsockopt;
extern LPFN_SHUTDOWN WSWshutdown;
extern LPFN_SOCKET WSWsocket;
extern LPFN_WSAHTONL WSWHtonl;
extern LPFN_WSAHTONS WSWHtons;
extern LPFN_WSANTOHL WSWNtohl;
extern LPFN_WSANTOHS WSWNtohs;
extern LPFN_WSAIOCTL WSWIoctl;
extern LPFN_WSAASYNCSELECT WSWAsyncSelect;
extern LPFN_WSAGETLASTERROR WSWGetLastError;
extern LPFN_WSAENUMPROTOCOLSW WSWEnumProtocolsW;
extern LPFN_WSAENUMPROTOCOLSA WSWEnumProtocolsA;
extern LPFN_WSARECVFROM WSWRecvFrom;
extern LPFN_WSASENDTO WSWSendTo;
extern LPFN_WSASOCKETW WSWSocketW;
extern LPFN_WSASOCKETA WSWSocketA;

#define WSAStartup WSWStartup
#define WSACleanup WSWCleanup
#define bind WSWbind
#define closesocket WSWclosesocket
#define gethostbyname WSWgethostbyname
#define gethostbyaddr WSWgethostbyaddr
#define gethostname WSWgethostname
#define getsockname WSWgetsockname
#define getsockopt WSWgetsockopt
#define htonl WSWhtonl
#define htons WSWhtons
#define inet_addr WSWinet_addr
#define inet_ntoa WSWinet_ntoa
#define ioctlsocket WSWioctlsocket
#define ntohl WSWntohl
#define ntohs WSWntohs
#define recvfrom WSWrecvfrom
#define sendto WSWsendto
#define setsockopt WSWsetsockopt
#define shutdown WSWshutdown
#define socket WSWsocket
#define WSAHtonl WSWHtonl
#define WSAHtons WSWHtons
#define WSANtohl WSWNtohl
#define WSANtohs WSWNtohs
#define WSAIoctl WSWIoctl
#define WSAAsyncSelect WSWAsyncSelect
#define WSAGetLastError WSWGetLastError
#undef WSAEnumProtocols
#ifdef UNICODE
#define WSAEnumProtocols WSWEnumProtocolsW
#else
#define WSAEnumProtocols WSWEnumProtocolsA
#endif
#define WSARecvFrom WSWRecvFrom
#define WSASendTo WSWSendTo
#undef WSASocket
#ifdef UNICODE
#define WSASocket WSWSocketW
#else
#define WSASocket WSWSocketA
#endif

#ifdef __cplusplus
}
#endif

#endif	// not __WSW_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\tpkt.h ===
/*
 * TPKT_Send_Setup
 * TPKT_Send_Setup should be called before a TPKT message is sent. It fills in the TPKT
 * header in the message. The caller passes TPKT_Send_Setup the wsabuf array before it is
 * passed to Winsock to be sent. The caller must allocate an extra TPKT_HEADER_SIZE bytes
 * at the beginning of the first buffer in the wsabuf, which TPKT_Send_Setup can fill in.
 * The length of the buffer specified in wsabuf must include these bytes. TPKT_Send_Setup
 * adds the len fields in the wsabuf array to compute the length of the message.
 *
 * TPKT_Receive_Init
 * TPKT_Receive_Init is called to begin receiving TPKT (RFC 1006) formatted data on a
 * connected socket. The socket must have been created as an overlapped socket, and must
 * have been connected before TPKT_Init is called.
 *
 * TPKT_RECEIVE_CALLBACK
 * Each complete TPKT message received on the socket is passed to the callback function
 * (which was passed to the TPKT_Receive_Init call). The TPKT header is not included. The
 * same callback function is called if there is an error in Winsock or an internal error in
 * the TPKT module. In this case, the buffer pointer will be NULL and the byte count
 * will be 0. When the socket is closed normally, the callback will be called with the
 * buffer pointer equal to NULL, the byte count equal to 0, and the error code equal to
 * NOERROR.
 *
 * TPKT_Receive_Close
 * TPKT_Receive_Close must be called *after* the socket has been closed, so that the TPKT
 * module can free its resources. The following procedure should be used to close a socket:
 *   shutdown(s, SD_SEND);
 *   (wait for TPKT receive callback with 0 bytes)
 *   closesocket(s);
 *   TPKT_Receive_Close(s);
 */

#ifndef TPKT_H
#define TPKT_H

#include <winsock2.h>

#define TPKT_HEADER_SIZE 4
typedef long HRESULT;
typedef void (*TPKT_RECEIVE_CALLBACK)(SOCKET s, void *buf, unsigned long nbytes, HRESULT error);

void TPKT_Send_Setup(WSABUF *wsabuf, DWORD BufferCount);

HRESULT TPKT_Receive_Init(SOCKET s, TPKT_RECEIVE_CALLBACK callback);
HRESULT TPKT_Receive_Close(SOCKET s);

#endif /* TPKT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\tstable.h ===
/****************************************************************************
 *
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *
 *	Abstract:   
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef __TSTABLE_H
#define __TSTABLE_H

#include <windows.h>

typedef struct _LOCK_ENTRY
{
	HANDLE        hLock;
	int           iLockCount;
	BOOL          bCleanup,
								bDeleted;
	WORD          wNextFree,
								wUniqueID;

} LOCK_ENTRY, *PLOCK_ENTRY;


// definition of an invalid ID
#define TSTABLE_INVALID_ID				(DWORD) 0xFFFFFFFF

// return codes that the callback function used in conjunction with EnumerateEntries can return
const DWORD CALLBACK_CONTINUE                = 1;
const DWORD CALLBACK_ABORT                   = 2;
const DWORD CALLBACK_DELETE_ENTRY            = 3;
const DWORD CALLBACK_DELETE_ENTRY_AND_OBJECT = 4;



// used in call to Lock
#define TSTABLE_INVALID_UNIQUE_ID            (WORD) 0xFFFF
#define TSTABLE_INVALID_INDEX                (WORD) 0xFFFF

// This is a compare function that we aren't using right now.  It
// will be useful in the future if there is a reason to search
// the table 

typedef INT (*ENTRY_COMPARE) (LPVOID ptr1, LPVOID ptr2);

#if defined(DBG) && defined(ENABLE_DUMP_ENTRIES)

VOID
TSDbgPrint(
    LPSTR szFormat,
    ...
    )
{
#define DEBUG_FORMAT_HEADER     "TABLE "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "

    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[512+1];
    int nLengthRemaining;
    int nLength = 0;

    // retrieve local time
    GetLocalTime(&SystemTime);

    // add component header to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_HEADER
                       );

    // add timestamp to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_TIMESTAMP,
                       SystemTime.wHour,
                       SystemTime.wMinute,
                       SystemTime.wSecond,
                       SystemTime.wMilliseconds
                       );

    // add thread id to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_THREADID,
                       GetCurrentThreadId()
                       );

    // point at first argument
    va_start(Args, szFormat);

    // determine number of bytes left in buffer
    nLengthRemaining = sizeof(szDebugMessage) - nLength;

    // add user specified debug message
    _vsnprintf(&szDebugMessage[nLength],
               nLengthRemaining,
               szFormat,
               Args
               );

    // release pointer
    va_end(Args);

    // output message to specified sink
    OutputDebugString(szDebugMessage);
}

#endif

template <class EntryData> class TSTable
{
typedef DWORD (*TABLE_CALLBACK) (EntryData* ptr, LPVOID context);

public:
	           TSTable         (WORD            _size);
	          ~TSTable         ();
	BOOL       Resize          (WORD            wNewSize);
	BOOL       CreateAndLock   (EntryData*      pEntryData,
															LPDWORD         lpdwID);
	BOOL       Validate        (DWORD           dwID);
	EntryData *Lock            (DWORD           dwID,
															DWORD           timeout = INFINITE);
	BOOL       Unlock          (DWORD           dwID);
	BOOL       Delete          (DWORD           dwID,
															BOOL            bCleanup = FALSE);
	EntryData *EnumerateEntries(TABLE_CALLBACK  callBackFunc,
															void*           context,
															BOOL            bUnlockTable = FALSE);
	
	BOOL       IsInitialized   () {return bInitialized;}
	WORD       GetSize         () {return wNumUsed;}

#if defined(DBG) && defined(ENABLE_DUMP_ENTRIES)
        VOID       DumpEntries     ();
#endif

private:
	// data

	EntryData**       pDataTable;
	PLOCK_ENTRY       pLockTable;
	CRITICAL_SECTION  csTableLock;
	WORD              wSize,
					  wNumUsed,
					  wFirstFree,
				      wLastFree,
					  wUniqueID;
	BOOL              bInitialized;

	// private methods

	BOOL LockEntry   (WORD wIndex,
									 DWORD timeout = INFINITE);
	BOOL UnLockEntry(WORD wIndex);
	void LockTable  () { EnterCriticalSection(&csTableLock); };
	void UnLockTable() { LeaveCriticalSection(&csTableLock); };
	WORD GenerateUniqueID();
	DWORD MakeID(WORD wIndex, WORD wUniqueID)
		{
			DWORD theID = wUniqueID;
			theID = (theID << 16) & 0xFFFF0000;
			theID |= wIndex;
			return(theID);
		};
	void BreakID(DWORD theID, WORD* pwIndex, WORD* pwUID)
		{
			*pwIndex = (WORD) (theID & 0x0000FFFF);
			*pwUID   = (WORD) ((theID >> 16) & 0x0000FFFF);
		};

};

/*
 ** TSTable::TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\tstable.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::TSTable(WORD _size) :
														wSize(_size),
														wNumUsed((WORD) 0),
														wFirstFree((WORD) 0),
														wLastFree((WORD) (_size - 1)),
														wUniqueID((WORD) 0),
														bInitialized(TRUE),
														pDataTable(NULL),
														pLockTable(NULL)
{
	WORD wIndex;

	// Create the table lock

	InitializeCriticalSection(&csTableLock);

	// Lock the table

	LockTable();

	// Create the data table

	pDataTable = new EntryData*[wSize];
	
	if(pDataTable == NULL) 
	{
		bInitialized = FALSE;
		return;
	}   

	// Init the pointers

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		pDataTable[wIndex] = NULL;
	}

	// Create the lock table

#if defined(DBG) && defined(ENABLE_BOGUS_ENTRY)
        pLockTable = new LOCK_ENTRY[wSize+1];
#else
        pLockTable = new LOCK_ENTRY[wSize];
#endif


	if (pLockTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}   

	// Initialize the lock table entries...each entry begins with
	// a NULL mutex handle, a zero lock count and it's next free is
	// the next successive entry.

	for (wIndex = 0; wIndex < wSize; wIndex++ )
	{
		pLockTable[wIndex].hLock      = NULL;
		pLockTable[wIndex].iLockCount = 0;
		pLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}   

#if defined(DBG) && defined(ENABLE_BOGUS_ENTRY)
        pLockTable[wSize].hLock      = (HANDLE)0xBAADBAAD;
        pLockTable[wSize].iLockCount = 0xBAADBAAD;
        pLockTable[wSize].bCleanup   = 0xBAADBAAD;
        pLockTable[wSize].bDeleted   = 0xBAADBAAD;
        pLockTable[wSize].wNextFree  = 0xBAAD;
        pLockTable[wSize].wUniqueID  = 0xBAAD;
#endif

	// note: the wNextFree in the last table entry points to an invalid index, however,
	// this is OK since if the table ever fills, it is automatically resized making what 
	// was an invalid index, the index into the first entry of newly added part of the 
	// enlargened table.  Trust me...

	// Unlock the table

	UnLockTable();
}

/*
 ** TSTable::~TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::~TSTable()
{
	DWORD wIndex;

	// Lock the table

	LockTable();

	// Delete the data table

	if (pDataTable != NULL)
	{
		delete pDataTable;
	}

	// Delete the lock table

	if (pLockTable != NULL)
	{
		// Destroy the mutexes

		for (wIndex = 0; wIndex < wSize; wIndex++)
		{
			if (pLockTable[wIndex].hLock != NULL)
			{
				CloseHandle(pLockTable[wIndex].hLock);
			}
		}

		delete pLockTable;
	}

	// Unlock the table

	UnLockTable();

	// Destroy the table lock

	DeleteCriticalSection(&csTableLock);

	bInitialized = FALSE; 
}

/*
 ** TSTable::Resize
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Resize(WORD wNewSize) 
{
	BOOL        bRetCode = TRUE;
	EntryData** pNewDataTable;
	PLOCK_ENTRY pNewLockTable;
	WORD        wIndex;

	// Lock the table

	LockTable();

	// If the table is shrinking, pretend we did it

	if (wNewSize <= wSize)
	{
		goto EXIT;
	}
	
	// Allocate new data and lock tables and make sure that succeeds.

	pNewDataTable = new EntryData*[wNewSize];

	if(pNewDataTable == NULL) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

#if defined(DBG) && defined(ENABLE_BOGUS_ENTRY)
        pNewLockTable = new LOCK_ENTRY[wNewSize+1];
#else
        pNewLockTable = new LOCK_ENTRY[wNewSize];
#endif

	if(pNewLockTable == NULL) 
	{
		bRetCode = FALSE;
		goto CLEANUP1;
	}

	// Initialize the new section of the lock and data tables

	for (wIndex = wSize; wIndex < wNewSize; wIndex++)
	{
		pNewDataTable[wIndex]            = NULL;

		pNewLockTable[wIndex].hLock      = NULL;
		pNewLockTable[wIndex].iLockCount = 0;
		pNewLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}

#if defined(DBG) && defined(ENABLE_BOGUS_ENTRY)
        pNewLockTable[wNewSize].hLock      = (HANDLE)0xBAADBAAD;
        pNewLockTable[wNewSize].iLockCount = 0xBAADBAAD;
        pNewLockTable[wNewSize].bCleanup   = 0xBAADBAAD;
        pNewLockTable[wNewSize].bDeleted   = 0xBAADBAAD;
        pNewLockTable[wNewSize].wNextFree  = 0xBAAD;
        pNewLockTable[wNewSize].wUniqueID  = 0xBAAD;
#endif // DBG

	// Copy the old data table pointers to the new data table

	memcpy((PCHAR) pNewDataTable,
				 (PCHAR) pDataTable,
				 sizeof(EntryData*) * wSize);

	// Delete the old data table and fix the pointer 

	delete pDataTable;
	pDataTable = pNewDataTable;

	// Copy the old lock table to the new lock table

	memcpy((PCHAR) pNewLockTable,
				 (PCHAR) pLockTable,
				 sizeof(LOCK_ENTRY) * wSize);

	// Delete the old lock table and fix the pointer 

	delete pLockTable;
	pLockTable = pNewLockTable;

	// Fix the size variable

	wSize = wNewSize;

        // Fix the last free index

        wLastFree = wSize - 1;

	goto EXIT;

CLEANUP1:

	// Delete the new data table

	delete pNewDataTable;

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::CreateAndLock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::CreateAndLock(EntryData* pEntryData,
																			 LPDWORD    lpdwID)
{
	BOOL  bRetCode = FALSE;
	WORD wIndex;

	// If the pointer passed in is bad, then don't even try to do anything for them

	if (pEntryData == NULL || lpdwID == NULL)
	{
		goto EXIT;
	}

        // Lock the table

	LockTable();

	// If the table is full, then resize it.

	if (wNumUsed == wSize)
	{
		if (Resize((WORD) (wSize + 20)) == FALSE)
		{
			goto EXIT;
		}
	}

	// Get the first free entry

	wIndex = wFirstFree;

	// Create the mutex for the object

	if ((pLockTable[wIndex].hLock = CreateMutexA(NULL, FALSE, NULL)) == NULL)
	{
		goto EXIT;
	}

	// Lock the entry (no need checking the return code as the entire
	// table is locked) - since this is a new entry, that means that nobody
	// could have locked the entry already.

	LockEntry(wIndex, 0);

	// Copy pointer to the data table

	pDataTable[wIndex] = pEntryData;

	// Init the corresponding lock table entry

	pLockTable[wIndex].bDeleted   = FALSE;
	pLockTable[wIndex].iLockCount = 1;
	pLockTable[wIndex].wUniqueID = GenerateUniqueID();

	// Set the id for the caller

	*lpdwID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

	// Bump up the count of number used

	wNumUsed++;

	// Fix the next free index

	wFirstFree = pLockTable[wIndex].wNextFree;

        // Fix the last free index

        if (wIndex == wLastFree)
        {
            wLastFree = wFirstFree;
        }

	// Signal success

	bRetCode = TRUE;

EXIT:

	// Unlock the table

        UnLockTable();

        return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::Lock(DWORD dwID,
																		DWORD timeout) 
{
	EntryData* pEntryData = NULL;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, and the unique ID matches).

	if (pLockTable[wIndex].hLock    == NULL ||
			pLockTable[wIndex].bDeleted == TRUE ||
			pLockTable[wIndex].wUniqueID != wUID)
	{
		goto EXIT;
	}

	// If the timeout is INFINITE, then try to lock the entry using a more
	// "thread friendly" method.	 If a timeout is specified, then don't do
	// the spin lock since it could be implemented at a higher level.

	if(timeout == INFINITE)
	{
		// simulate infinity with a pseudo "spin lock"
		// This is more "thread friendly" in that it unlocks the table allowing some
		// other thread that is trying to unlock the same entry to be able to lock the
		// table.

		while(LockEntry(wIndex, 0) == FALSE)
		{
			UnLockTable();

			// give up the rest of this thread quantum, allowing others to run and potentially
			// unlock the entry

			Sleep(0); 
			LockTable();

			// If the entry has been replaced, deleted or marked for deletion then
			// bag it (give up)

			if((pLockTable[wIndex].wUniqueID != wUID)  ||
				 (pLockTable[wIndex].hLock      == NULL)  || 
				 (pLockTable[wIndex].bDeleted   == TRUE))
			{
				goto EXIT;
			}
		}

		// we got the lock

		pEntryData = pDataTable[wIndex];
	}
	
	// Otherwise, do a normal lock

	else
	{	
		if (LockEntry(wIndex, timeout) == TRUE) 
		{
			pEntryData = pDataTable[wIndex];
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return pEntryData;
}

/*
 ** TSTable::Unlock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Unlock(DWORD dwID)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 
	
	// Lock the table

	LockTable();

	// Verify the id is within bounds

	if (wIndex >= wSize) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the lock is actually valid and that the entry has not been
	// deleted

	if (pLockTable[wIndex].hLock == NULL)
	{
		goto EXIT;
	}

	// Make sure that that thread has the lock on the entry

	if ((bRetCode = LockEntry(wIndex, 0)) == TRUE) 
	{
		// if this table entry is marked for delete and the lock count is less than 2
		// (since the thread could have called delete after unlocking the entry...although
		// this is a no-no) then clean up the table entry

		if (pLockTable[wIndex].bDeleted   == TRUE &&
				pLockTable[wIndex].iLockCount <= 2)
		{
			// If the caller specifed cleanup on delete, then get rid of memory

			if (pLockTable[wIndex].bCleanup == TRUE)
			{
				delete pDataTable[wIndex];
			}

			// Set the pointer to NULL

			pDataTable[wIndex] = NULL;

                        // See if table is full

                        if (wNumUsed == wSize) {

                            // Fix the entry so that it's next free index points to end of
                            // table.  No need to update last entry since it was virtual.
                            pLockTable[wIndex].wNextFree = wLastFree;
                            wFirstFree                   = wIndex;
                            wLastFree                    = wIndex;

                        } else {

                            // Fix the entry so that it's next free index is what is currently
                            // the next free pointed to by the current last free entry.
                            // Then update the last free entry's next pointer, and finally,
                            // update the last free index to this entry
                            pLockTable[wIndex].wNextFree    = pLockTable[wLastFree].wNextFree;
                            pLockTable[wLastFree].wNextFree = wIndex;
                            wLastFree                       = wIndex;
                        }

                        // Decrement the count of used entries

			wNumUsed--;
                }

		// Do two unlocks on the entry ... one for the original lock and another for
		// the lock we obtained during the test

		UnLockEntry(wIndex);
		UnLockEntry(wIndex);

		// Since the entire table is locked, then we can get away with this.  If
		// the code is ever changed so that the entire table is not locked during
		// these operations, then this will cause a race condition.

		// If we got rid of the data, then close the handle to the mutex and
		// set the handle to NULL

		if (pDataTable[wIndex] == NULL)
                {
                        CloseHandle(pLockTable[wIndex].hLock);
			pLockTable[wIndex].hLock = NULL;
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Delete
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Delete(DWORD dwID,
																BOOL  bCleanup) 
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

        // Lock the table

	LockTable();

	// Verify that the ID is within bounds

	if (wIndex >= wSize) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is valid

	if (pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Try to lock the entry (ie check to see if we had the entry locked)

	if (LockEntry(wIndex, 0) == TRUE)
	{
		// mark it for deletion, set the cleanp flag and then unlock it

		pLockTable[wIndex].bDeleted = TRUE;
		pLockTable[wIndex].bCleanup = bCleanup;

		UnLockEntry(wIndex);

		// Note: this function does not call ::Unlock() on behalf of the user.
		// Thus, the entry is only marked as deleted at this point and can no
		// longer be locked by any threads (including the one that marked it for delete).
		// The thread that marked the entry as deleted must call ::Unlock() to actually
		// free up the entry.
	}

EXIT:

	// Unlock the table

	UnLockTable();

        return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:  Validates that an object still exists.  Can be called
 *								regardless if caller has entry locked or not.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Validate(DWORD dwID)
{
	BOOL bRetCode = TRUE;
	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, the unique ID matches, and the data ptr is not null).

	if (pLockTable[wIndex].hLock    == NULL  ||
			pLockTable[wIndex].bDeleted == TRUE  ||
			pLockTable[wIndex].wUniqueID != wUID ||
			pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::EnumerateEntries
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::EnumerateEntries(TABLE_CALLBACK callbackFunc,
																								LPVOID         context,
																								BOOL           bUnlockTable) 
{
	DWORD      dwAction;
	WORD       wIndex = wSize;
	EntryData* pEntryData = NULL;
	DWORD      dwEntryID;

	// Make sure they passed a good function

	if (callbackFunc == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// Run through the data table and pass the data to the callback function

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		// Verify that there is actually data in the entry and that the entry has not
		// been marked for deletion.

		if (pDataTable[wIndex]          == NULL ||
				pLockTable[wIndex].bDeleted == TRUE)
		{
			continue;
		}


		// Try to lock the entry...if we cannot, then we don't have the lock and
		// we will only report entries that we have locked (or are unlocked)

		if (LockEntry(wIndex, 0) == FALSE)
		{
			continue;
		}
		
		// build and remember the "full" entry ID so we can use it to unlock the entry
		dwEntryID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

		// Save the pointer to the object.

		pEntryData = pDataTable[wIndex];

		// note: only unlock the table during the callback if we are explicitly asked to (the 
		// default is not to unlock the table). 
		if(bUnlockTable == TRUE)
			UnLockTable();

		// Call their function
		dwAction = callbackFunc(pDataTable[wIndex], context);

		if(bUnlockTable == TRUE)
			LockTable();

		// If the action says to delete the entry, then do so...if we are also to delete
		// the object, pass in a TRUE.

		if (dwAction == CALLBACK_DELETE_ENTRY ||
				dwAction == CALLBACK_DELETE_ENTRY_AND_OBJECT)
		{
			Delete(dwEntryID, (dwAction == CALLBACK_DELETE_ENTRY ? FALSE : TRUE));
		}

		// If the action says abort, then break the loop...notice that means that
		// the entry is still locked

		else if (dwAction == CALLBACK_ABORT)
		{
			goto EXIT;
		}

		// Unlock the entry...notice we don't use UnLockEntry.  The reason is that
		// if the entry has been marked as deleted, then we need to have
		// it destroyed and UnLockEntry doesn't do that.

		Unlock(dwEntryID);
	}

EXIT:

	// Unlock the table

	UnLockTable();

	// Return NULL if we processed the entire table...if we were told to abort,
	// return a pointer to the entry we stopped on.

	return (wIndex == wSize ? NULL : pEntryData);
}

// helper functions - these assume table is locked and index is good

/*
 ** TSTable::LockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::LockEntry(WORD wIndex,
																	 DWORD timeout) 
{
	BOOL  bRetCode = TRUE;
	DWORD dwRetCode;


	// Try to lock the entry.  If it succeeds, we'll bump up the lock count.  If
	// the wait ended because another thread abandoned the mutex, then set the count
	// to one.

	dwRetCode = WaitForSingleObject(pLockTable[wIndex].hLock, timeout);
	
	if (dwRetCode == WAIT_OBJECT_0)
	{
		pLockTable[wIndex].iLockCount++;
	}
	else if (dwRetCode == WAIT_ABANDONED)
	{
		pLockTable[wIndex].iLockCount = 1;
	}
	else
	{
		bRetCode = FALSE;
	}

	return bRetCode;
}

/*
 ** TSTable::UnLockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::UnLockEntry(WORD wIndex)
{
	BOOL bRetCode;

	// Release the mutex...if that succeeds, reduce the count

	if((bRetCode = ReleaseMutex(pLockTable[wIndex].hLock)) == TRUE) 
	{
		pLockTable[wIndex].iLockCount--;
	}

	return bRetCode;
}


/*
 ** TSTable::GenerateUniqueID
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION: table should be locked before calling this function.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
WORD TSTable<EntryData>::GenerateUniqueID()
{
	// table must be locked
	if(++wUniqueID == TSTABLE_INVALID_UNIQUE_ID)
		wUniqueID++;
	return(wUniqueID);
}

#if defined(DBG) && defined(ENABLE_DUMP_ENTRIES)

/*
 ** TSTable::DumpEntries
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
VOID TSTable<EntryData>::DumpEntries()
{
        WORD       wIndex;
        WORD       wNumFree;

        // Lock the table

	LockTable();

#ifdef ENABLE_DUMP_ENTRIES_VERBOSE

        for (wIndex = 0; wIndex < wSize; wIndex++)
        {
            if (pLockTable[wIndex].hLock == NULL) {

                TSDbgPrint("[Entry %d] - FREE"
                           "\n\thLock      = %x"
                           "\n\tiLockCount = %d"
                           "\n\tbCleanup   = %s"
                           "\n\tbDeleted   = %s"
                           "\n\twNextFree  = %d"
                           "\n\tpEntryData = 0x%08lx\n",
                           wIndex,
                           pLockTable[wIndex].hLock,
                           pLockTable[wIndex].iLockCount,
                           pLockTable[wIndex].bCleanup ? "TRUE" : "FALSE",
                           pLockTable[wIndex].bDeleted ? "TRUE" : "FALSE",
                           pLockTable[wIndex].wNextFree,
                           pDataTable[wIndex]
                           );

            } else if (LockEntry(wIndex, 0) == TRUE) {

                TSDbgPrint("[Entry %d] - USED"
                           "\n\thLock      = %x"
                           "\n\tiLockCount = %d"
                           "\n\tbCleanup   = %s"
                           "\n\tbDeleted   = %s"
                           "\n\twNextFree  = %d"
                           "\n\tpEntryData = 0x%08lx\n",
                           wIndex,
                           pLockTable[wIndex].hLock,
                           pLockTable[wIndex].iLockCount,
                           pLockTable[wIndex].bCleanup ? "TRUE" : "FALSE",
                           pLockTable[wIndex].bDeleted ? "TRUE" : "FALSE",
                           pLockTable[wIndex].wNextFree,
                           pDataTable[wIndex]
                           );

                UnLockEntry(wIndex);

            } else {

                TSDbgPrint("[Entry %d] - LOCKED\n",wIndex);
            }
        }

#endif

        TSDbgPrint("[Free List] - "
                   "wFirstFree=%d,"
                   "wLastFree=%d\n",
                   wFirstFree,
                   wLastFree
                   );

        wIndex = wFirstFree;
        wNumFree = (wFirstFree < wSize) ? 1 : 0;

        while (wIndex != wLastFree) {

            TSDbgPrint("\t%d -> %d\n",wIndex,pLockTable[wIndex].wNextFree);

            wIndex = pLockTable[wIndex].wNextFree;

            wNumFree++;
        }

        TSDbgPrint("[Summary] - "
                   "wSize=%d,"
                   "wNumUsed=%d,"
                   "wNumFree=%d %s\n\n",
                   wSize,
                   wNumUsed,
                   wNumFree,
                   ((wSize - wNumUsed) != wNumFree)
                        ? "ERROR"
                        : "OKAY"
                   );

	// Unlock the table

	UnLockTable();
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\wscb.h ===
/***************************************************************************
 *
 * File: wscb.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   wscb.h  $
 * $Revision:   1.2  $
 * $Modtime:   05 Apr 1996 12:00:00  $
 * $Log:   S:/STURGEON/SRC/INCLUDE/VCS/wscb.h_v  $
 * 
 *    Rev 1.2   05 Apr 1996 15:20:20   WYANG
 * 
 * added WSCB_E_MPOOLUSEDUP
 * 
 *    Rev 1.1   09 Mar 1996 14:47:30   EHOWARDX
 * 
 * Added extern "C" to function prototypes.
 *
 *****************************************************************************/

// this file defines the export functions for
// WSCB.DLL, and import functions for users of WSCB.DLL module.

#ifndef WSCB_H
#define WSCB_H

#include "winsock2.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// declare exported functions
#if defined(WSCB_MYLIB)
#define WSCB_MYLIBAPI __declspec(dllexport)
#else
#define WSCB_MYLIBAPI __declspec(dllimport)
#endif

// error code
#define WSCB_E_MPOOLUSEDUP  (WSABASEERR+200)


// This function wraps the Winsock2 WSARecvFrom function call, and it is
// responsible to make callback to the caller of this function once the
// Winsock receive operation is signaled by the Winsock network layer.
// The return result is Winsock errors (please see Winsocket 2 API).

WSCB_MYLIBAPI int   WSCB_WSARecvFrom(
    SOCKET                      s,
    LPWSABUF                    lpBuffers,
    DWORD                       dwBufferCount,
    LPDWORD                     lpNumberOfBytesRecvd,
    LPDWORD                     lpFlags,
    struct sockaddr FAR *       lpFrom,
    LPINT                       lpFromlen,
    LPWSAOVERLAPPED             lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

// This functions wraps the Winsock2 WSASendTo function call, and it is
// responsible to make callback to the caller of this function once the
// Winsock send operation is signaled by the Winsock network layer.
// The return result is Winsock errors (please see Winsocket 2 APi).

WSCB_MYLIBAPI int   WSCB_WSASendTo(
    SOCKET                      s,
    LPWSABUF                    lpBuffers,
    DWORD                       dwBufferCount,
    LPDWORD                     lpNumberOfBytesSent,
    DWORD                       dwFlags,
    const struct sockaddr FAR * lpTo,
    int                         iToLen,
    LPWSAOVERLAPPED             lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);


#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // WSCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\tstmsp.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/tstmsp.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.0  $
 *	$Date:   Nov 19 1996 09:16:08  $
 *	$Author:   MLEWIS1  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		RMS Test MSP "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with Test MSP. Any EXE or DLL which interacts with
 *		test MSP will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

// tstmsp.h

#ifndef _TSTMSP_H_
#define _TSTMSP_H_

// define Source and Sink MSP IDs
#define TSTMSPSRC	"IntelTestSrc"
#define TSTMSPSNK	"IntelTestSnk"

// version number
#define TSTMSP_INTERFACE_VERSION           0x1

//**********************************
// structures used in interface calls
//**********************************

//***************************************************************************************
/* TSTMSP_SINK_OPENPORT_IN_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value TSTMSP_INTERFACE_VERSION should always be used to initialize it.

uBufferFrequency	Is a UINT specifying the number of milleseconds to delay before releasing
				a received buffer.  A value of TSTMSP_DEF_FREQUENCY causes a default delay time
				to be used.
*/
typedef struct _tstmsp_sink_openport_in_info
{
	UINT			uVersion;
	UINT			uBufferFrequency;
} TSTMSP_SINK_OPENPORT_IN_INFO, *LPTSTMSP_SINK_OPENPORT_IN_INFO;


//***************************************************************************************
/* TSTMSP_SINK_OPENPORT_OUT_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value TSTMSP_INTERFACE_VERSION should always be used to initialize it.

uBufferFrequency	Is a UINT specifying the actual number of milleseconds of delay before 
				releasing a received buffer.
*/
typedef struct _tstmsp_sink_openport_out_info
{
	UINT			uVersion;
	UINT			uBufferFrequency;
} TSTMSP_SINK_OPENPORT_OUT_INFO, *LPTSTMSP_SINK_OPENPORT_OUT_INFO;


//***************************************************************************************
/* TSTMSP_SOURCE_OPENPORT_IN_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

uBufferCount	Is a UINT specifying the number of buffers to allocate for transmitting.
				A value of TSTMSP_DEF_BUFFERCOUNT causes a default number of buffers to 
				be created.

uBufferSize		Is a UINT specifying the size of buffers to allocate for transmitting. 
				A value of TSTMSP_DEF_BUFFERSIZE causes a default buffer size to be used.

uBufferFrequency	Is a UINT specifying the number of milleseconds to wait between 
				buffer transmissions.  A value of TSTMSP_DEF_FREQUENCY causes a default 
				send interval to be used.

uBurstCount		Is a UINT specifying the number of buffers to send on each buffer 
				transmissions.  A value of TSTMSP_DEF_BURSTCOUNT causes a default
				value to be used. 
*/
typedef struct _tstmsp_source_openport_in_info
{
	UINT					uVersion;
	UINT					uBufferCount;
	UINT					uBufferSize;
	UINT					uBufferFrequency;
	UINT					uBurstCount;
} TSTMSP_SOURCE_OPENPORT_IN_INFO, *LPTSTMSP_SOURCE_OPENPORT_IN_INFO;

//***************************************************************************************
/* TSTMSP_SOURCE_OPENPORT_OUT_INFO

uVersion		Is the version identifier for this data structure.  The value 
				STRMSP_INTERFACE_VERSION should always be used to initialize it.

uBufferCount	Is a UINT specifying the number of buffers actually allocated for 
				transmitting.

uBufferSize		Is a UINT specifying the actual size of buffers allocated for 
				transmitting. 

uBufferFrequency	Is a UINT specifying the actual number of milleseconds to waited
				between buffer transmissions.

uBurstCount		Is a UINT specifying the actual number of buffers to be sent on each 
				buffer transmissions.
*/
typedef struct _tstmsp_source_openport_out_info
{
	UINT					uVersion;
	UINT					uBufferCount;
	UINT					uBufferSize;
	UINT					uBufferFrequency;
	UINT					uBurstCount;
} TSTMSP_SOURCE_OPENPORT_OUT_INFO, *LPTSTMSP_SOURCE_OPENPORT_OUT_INFO;

//***************************************************************************************
/* TSTMSP_SET_BUFFERFREQUENCY_IN_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value TSTMSP_INTERFACE_VERSION should always be used to initialize it.

uBufferFrequency	Is a UINT specifying:
				SINK -	the number of milleseconds to delay before releasing a received 
						buffer.  A value of TSTMSP_DEF_FREQUENCY causes a default delay 
						time to be used.
				SRC -	the number of milleseconds to wait between buffer transmissions.
						A value of TSTMSP_DEF_FREQUENCY causes a default send interval 
						to be used.
*/
typedef struct _tstmsp_set_bufferfrequency_in_info
{
	UINT			uVersion;
	UINT			uBufferFrequency;
} TSTMSP_SET_BUFFERFREQUENCY_IN_INFO, *LPTSTMSP_SET_BUFFERFREQUENCY_IN_INFO;

//***************************************************************************************
/* TSTMSP_SET_BUFFERFREQUENCY_OUT_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value TSTMSP_INTERFACE_VERSION should always be used to initialize it.

uBufferFrequency	Is a UINT specifying the actual delay value used.
*/
typedef struct _tstmsp_set_bufferfrequency_out_info
{
	UINT			uVersion;
	UINT			uBufferFrequency;
} TSTMSP_SET_BUFFERFREQUENCY_OUT_INFO, *LPTSTMSP_SET_BUFFERFREQUENCY_OUT_INFO;

//***************************************************************************************
/* TSTMSP_SET_BURSTCOUNT_IN_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value TSTMSP_INTERFACE_VERSION should always be used to initialize it.

uBurstCount		Is a UINT specifying the number of buffers to send on each buffer 
				transmissions.  A value of TSTMSP_DEF_BURSTCOUNT causes a default
				value to be used.
*/
typedef struct _tstmsp_set_burstcount_in_info
{
	UINT			uVersion;
	UINT			uBurstCount;
} TSTMSP_SET_BURSTCOUNT_IN_INFO, *LPTSTMSP_SET_BURSTCOUNT_IN_INFO;

//***************************************************************************************
/* TSTMSP_SET_BURSTCOUNT_OUT_INFO

uVersion		Is a UINT specifying the version identifier for this data structure.  
				The value TSTMSP_INTERFACE_VERSION should always be used to initialize it.

uBurstCount		Is a UINT specifying the actual number of buffers to be sent on each 
				buffer transmissions.
*/
typedef struct _tstmsp_set_burstcount_out_info
{
	UINT			uVersion;
	UINT			uBurstCount;
} TSTMSP_SET_BURSTCOUNT_OUT_INFO, *LPTSTMSP_SET_BURSTCOUNT_OUT_INFO;


//*****************************************
// MSP Port Attribute Defaults
//*****************************************
#define TSTMSP_DEF_BUFFERCOUNT			0
#define TSTMSP_DEF_BUFFERSIZE			0
#define TSTMSP_DEF_FREQUENCY			((UINT)-1)
#define TSTMSP_DEF_BURSTCOUNT			0

//*****************************************
// MSP Service Commands
//*****************************************
// MSP_ServiceCmdProc()
#define TSTMSP_SETBUFFERFREQUENCY          0x0001    // set buffer frequency
#define TSTMSP_SETBURSTCOUNT               0x0002    // set burst count

//*****************************************
// MSP Global Limits
//*****************************************
#define TST_MAX_WSA_BUFS	16			// Max WSABUF elements in MSP2MSMSend

//*****************************************
// MSP Error codes
//*****************************************
#define TSTMSP_ERR_INVALIDARG              E_INVALIDARG	// one or more parameters invalid

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\vidinfo.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/vidinfo.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Author:   MLAKSHMX  $
 *
 *	Deliverable:
 *
 *	Abstract: Header file for the video MSP to share information with the App.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef VIDINFO_H
#define VIDINFO_H
#include	"h245api.h"

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


//Unique ID for this version of MSP.
#define VIDEOSRCMSP "IntelIPhoneVideoH2631.0Src"
#define VIDEOSNKMSP "IntelIPhoneVideoH2631.0Snk"

// This function allows the MSM to make IO Control (IOCTL) type calls into 
// the MSP. The following controls can be exercised on the sink instance of
// VIDMSP.

//  Change the display frame size.
//  lparam2 = pointer to a RECT
#define	VIDCMD_RESIZE_VIDEO		0x00000001

/**********************
Please Ignore these defunct	#defines for Video Attributes!!
//
//	Change the display frame rate.
//  lparam2 = frame rate in msec/frame
#define	VIDCMD_SET_DISPLAY_RATE	0x00000002

// Specify whether quality or frame rate is more desirable for remote
// video.
//  lparam1 = TRUE - 
//  lparam2 = Quality (1-10000)
//
// or
//  lparam1 = FALSE
//  lparam2 = Frame rate in msec/frame.
//
#define	VIDCMD_QUALITY_FRAMERATE	0x00000003


//The following controls can be exercised on the source instance of VIDMSP.

// Use the constant quality bit rate controller.	
//  lparam1 = Byte rate in bytes/sec.
//  lparam2 = Quality.
#define	VIDCMD_SET_QUALITY_BRC		0x00000004

// Use constant frame rate bit rate  controller.
//  lparam1 = Byte rate in bytes/sec.
//  lparam2 = frame rate in	msec/frame.
#define	VIDCMD_SET_FRAME_RATE_BRC	0x00000005 
// Use constant frame size bit rate  controller.
//  lparam1 = Byte rate in bytes/sec.
//  lparam2 = frame rate in msec/frame.

#define	VIDCMD_SET_FRAME_SIZE_BRC	0x00000006

// Turn PB frames on/off.
// lparam1 = TRUE - PB frames on.
//       FALSE - PB frames off.

#define	VIDCMD_CNTL_PB_FRAMES		0x00000007	
								
// Set the packet-size
// lparam1 = 0 for Get, 1 for Set.
// lparam2 = packet size in bytes.
#define	VIDCMD_PACKET_SIZE		0x00000008
******************************************/

// this command instructs the Video MSP to launch the Video config
// dialog box, to allow user to set frame rate,data rate , quality etc.
#define VIDCMD_CONFIG_VIDEO             0x0000000A
#define VIDCMD_GET_VIDCFG	            0x0000000B

// Mute & Unmute Video
#define	VIDCMD_PAUSE_VIDEO				0x0000000C
#define	VIDCMD_UNPAUSE_VIDEO			0x0000000D

// Commands for the Video Source. These will xlate to 
// commands for the encoder
#define	VIDCMD_SET_SRC_FRAMERATE		0x0000000E
#define	VIDCMD_SET_SRC_BITRATE			0x0000000F
#define	VIDCMD_SET_SRC_QUALITY			0x00000010

// commands for the Video Sink. These will xlate to
// commands for the decoder
#define VIDCMD_SET_SNK_BRIGHTNESS		0x00000011
#define VIDCMD_SET_SNK_CONTRAST			0x00000012


#define	AVPHONE_APP		1
#define	MSMTEST_APP		0

typedef struct _VIDEOCONFIG
{
	int	m_FrameRate;
	int	m_DataRate;
	int	m_Quality;
	BOOL	AppOrMsmtest; // need to diff between a H323 based app and msmtest
}
VIDEOCONFIG,*PVIDEOCONFIG;

// Set the expected packet loss rate.
// lparam1 = 0 for Get, 1 for Set.
// lparam2 = a number from 0 - 100.
#define	VIDCMD_EXPECTED_PACKET_LOSS	0x00000009

// Video MSP Open Port structure
// To be passed in lParamIn by MSM in the MSP_OpenPort call
typedef struct _VIDMSPOPENPORT
{
	H245_TOTCAP_T	*pH245TotCapT;
	HWND hAppWnd;
	BYTE	RTPPayloadType;
}
VIDMSPOPENPORT, *LPVIDMSPOPENPORT;


// ISDM Keys & Values
#define IPHONE_VIDEO    "IIPHONE_VIDEO"
#define	VIDEO_SEND		"Send"
#define	VIDEO_RCV		"Receive"

typedef	struct	_IPHONE_VIDEO_VALUE
{
	DWORD	dwRevNumber; // 1 for Release
	DWORD	dwTargetFrameRate; // frames/sec
	DWORD	dwFrameRate; // Frames/sec since last updated
	DWORD	dwTargetDataRate; // bits/sec
	DWORD	dwDataRate;	// bits/sec rate since value last updated
	DWORD	Reserved[59];
}IPHONEVIDEOVALUE,*LPIPHONEVIDEOVALUE;

// Video MSP Error Codes
#define EVID_ERROR_BASE					0xA000
#define FIRST_EVID_ID					-400 + EVID_ERROR_BASE//Same as next err.
#define EVID_BAD_MSP_HND				-400 + EVID_ERROR_BASE
#define EVID_NULL_INSTANCE_HANDLE		-400 + EVID_ERROR_BASE
#define EVID_BAD_MSP_TYPE				-401 + EVID_ERROR_BASE
#define EVID_BAD_CALL_ORDER 			-402 + EVID_ERROR_BASE
#define EVID_BAD_BUF_PTR				-403 + EVID_ERROR_BASE
#define EVID_CANT_LOAD_DLL				-404 + EVID_ERROR_BASE
#define EVID_VM_INIT_FAILED 			-405 + EVID_ERROR_BASE
#define EVID_VM_OPEN_FAILED 			-406 + EVID_ERROR_BASE
#define EVID_VM_CAPT_FAILED 			-407 + EVID_ERROR_BASE
#define EVID_VM_LINKIN_FAILED			-408 + EVID_ERROR_BASE
#define EVID_VM_UNLINKIN_FAILED 		-409 + EVID_ERROR_BASE
#define EVID_VM_LINKOUT_FAILED			-410 + EVID_ERROR_BASE
#define EVID_VM_UNLINKOUT_FAILED		-411 + EVID_ERROR_BASE
#define EVID_VM_PLAY_FAILED 			-412 + EVID_ERROR_BASE
#define EVID_VM_ENDPLAY_FAILED			-413 + EVID_ERROR_BASE
#define EVID_BAD_CONFIG_SETTING			-414 + EVID_ERROR_BASE
#define EVID_MALLOC_FAILED				-415 + EVID_ERROR_BASE
#define EVID_VM_REGISTER_FAILED			-450 + EVID_ERROR_BASE
#define EVID_VM_UNREGISTER_FAILED		-451 + EVID_ERROR_BASE
#define EVID_BAD_PARAMETER				-452 + EVID_ERROR_BASE
#define EVID_VM_START_SENDING_FAILED	-453 + EVID_ERROR_BASE
#define EVID_VM_STOP_SENDING_FAILED		-454 + EVID_ERROR_BASE
#define EVID_VM_CREATEWINDOW_FAILED		-455 + EVID_ERROR_BASE
#define LAST_EVID_ID					-414 + EVID_ERROR_BASE

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus


#endif // VIDINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\common.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/common.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.4  $
 *	$Date:   31 May 1996 15:48:44  $
 *	$Author:   rodellx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef COMMON_H
#define COMMON_H

#ifdef __cplusplus
extern "C" {
#endif



#ifdef DBG

// #include <crtdbg.h>

#define Malloc(size) malloc(size)
#define Free(p) free(p)

//#define Malloc(size) _malloc_dbg((size), _NORMAL_BLOCK, __FILE__, __LINE__)
//#define Free(p) _free_dbg((p), _NORMAL_BLOCK)

#else

//#define Malloc(size) GlobalAlloc(GMEM_FIXED, size)
//#define Free(p) GlobalFree(p)

#define Malloc(size) malloc(size)
#define Free(p) free(p)

#endif



#ifdef __cplusplus
}
#endif

#endif COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\inc\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#ifndef _YVALS
#define _YVALS

 #pragma warning(4: 4018 4114 4146 4245)
 #pragma warning(4: 4663 4664 4665)
 #pragma warning(disable: 4237 4244 4290)
		/* NAMESPACE */
  #define _STD			::
  #define _STD_BEGIN
  #define _STD_END


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

		/* TYPE bool */
typedef int bool;
#if !defined(false)
 #define false	0
#endif
#if !defined(true)
 #define true	1
#endif
 #if defined(__cplusplus)
struct _Bool {
	_Bool()
		: _Val(0) {}
	_Bool(int _V)
		: _Val(_V != 0) {}
	_Bool& operator=(int _V)
		{_Val = _V != 0;
		return (*this); }
	_Bool& operator+=(const _Bool& _X)
		{_Val += _X._Val;	// for valarray
		return (*this); }
	operator int() const
		{return (_Val); }
private:
	char _Val;
	};
 #endif
		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36
		/* wchar_t PROPERTIES */
typedef unsigned short   _Wchart;
 #if !defined(__cplusplus)
typedef _Wchart	_Wchart_unique;
 #else
struct _Wchart_unique {
	_Wchart_unique()
		: _Val(0) {}
	_Wchart_unique(_Wchart _V)
		: _Val(_V) {}
	_Wchart_unique(const _Wchart_unique& _R)
		: _Val(_R._Val) {}
	_Wchart_unique& operator=(_Wchart _V)
		{_Val = _V;
		return (*this); }
	operator _Wchart() const
		{return (_Val); }
private:
	_Wchart _Val;
	};
 #endif /* __cplusplus */
		/* STDIO PROPERTIES */
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)	((long)(fp))
#endif		/* _FPOS_T_DEFINED */

		/* NAMING PROPERTIES */
 #if defined(__cplusplus)
  #define _C_LIB_DECL extern "C" {
  #define _END_C_LIB_DECL }
 #else
  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
 #endif /* __cplusplus */
		/* MISCELLANEOUS MACROS */
#define _L(c)	L##c
#define _Mbstinit(x)	mbstate_t x = {0}

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\protocol.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/protocol.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.3  $
 *	$Date:   Apr 25 1996 21:21:48  $
 *	$Author:   plantz  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Line Protocol Definitions.
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef PROTOCOL_H
#define PROTOCOL_H

#ifdef __cplusplus
extern "C" {
#endif


#define TYPE_Q931_SETUP                 1
#define TYPE_Q931_CONNECT               2
#define TYPE_Q931_RELEASE_COMPLETE      3
#define TYPE_Q931_ALERTING              4
// and more later....


#define Q931_PROTOCOL ((WORD)0x1)

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
} MSG_Q931, *PMSG_Q931;

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    ADDR            CallerAddr;     // needed because call may be made from gatekeeper.
    ADDR            CalleeAddr;     // needed because call may be made to gatekeeper.
    WORD            wConferenceID;
    WORD            wGoal;
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_SETUP, *PMSG_Q931_SETUP;

typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    WORD            wConferenceID;
    ADDR            H245Addr;       // address returned by callee.
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_CONNECT, *PMSG_Q931_CONNECT;


typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
    WORD            wConferenceID;  //   I think this should be passed from the user...
	BYTE            bReason;        // defined above.
    ADDR            AlternateAddr;  // alternative address to use.
	H323USERINFO    H323UserInfo;
    char            H323UserData[0];
} MSG_Q931_RELEASE_COMPLETE, *PMSG_Q931_RELEASE_COMPLETE;


typedef struct 
{
	WORD            wProtocol;      // identifies Q931 protocol.
	WORD            wType;          // defined above.
    HQ931CALL       hCallID;
} MSG_Q931_ALERTING, *PMSG_Q931_ALERTING;


#ifdef __cplusplus
}
#endif

#endif PROTOCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\hcall.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hcall.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.27.2.0  $
 *	$Date:   20 Jun 1997 14:12:22  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Call Object Methods
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef HCALL_H
#define HCALL_H

#include "av_asn1.h"


#ifdef __cplusplus
extern "C" {
#endif

// Call Object states                     // OUT          // IN
#define CALLSTATE_NULL              0x00  // relcomp*     // relcomp*
#define CALLSTATE_INITIATED         0x01  // setup*       // 
#define CALLSTATE_OUTGOING          0x03  //              // proceeding*
#define CALLSTATE_DELIVERED         0x04  //              // alerting*         
#define CALLSTATE_PRESENT           0x06  //              // setup*
#define CALLSTATE_RECEIVED          0x07  // alerting*    // 
#define CALLSTATE_CONNECT_REQUEST   0x08  //              // 
#define CALLSTATE_INCOMING          0x09  // proceeding-  // 
#define CALLSTATE_ACTIVE            0x0A  // connect*     // connect*

// Call Timer limits
#define Q931_TIMER_301             301
#define Q931_TICKS_301             180000L        // 3 minutes
#define Q931_TIMER_303             303
#define Q931_TICKS_303             4000L          // 4 seconds

typedef struct CALL_OBJECT_tag
{
    HQ931CALL           hQ931Call;
    WORD                wCRV;              // Call Reference Value (0..7FFF).
    DWORD               dwListenToken;
    DWORD               dwUserToken;
    Q931_CALLBACK       Callback;
    BYTE                bCallState;
    BOOL                fIsCaller;
    DWORD               dwPhysicalId;
    BOOL                bResolved;         // re-connect phase is over.
    BOOL                bConnected;        // has a live channel.

    CC_ADDR             LocalAddr;         // Local address on which channel is connected
    CC_ADDR             PeerConnectAddr;   // Address to which channel is connected

    CC_ADDR             PeerCallAddr;      // Address of opposite call end-point.
    BOOL                PeerCallAddrPresent;  // Address is present.

    CC_ADDR             SourceAddr;        // Address of this end-point.
    BOOL                SourceAddrPresent; // Address is present.

    CC_CONFERENCEID     ConferenceID;
    WORD                wGoal;
    BOOL                bCallerIsMC;
    WORD                wCallType;

    BOOL                NonStandardDataPresent;
    CC_NONSTANDARDDATA  NonStandardData;

    char                szDisplay[CC_MAX_DISPLAY_LENGTH];
                                           // length = 0 means not present.
    char                szCalledPartyNumber[CC_MAX_PARTY_NUMBER_LEN];
                                           // length = 0 means not present.

    PCC_ALIASNAMES      pCallerAliasList;
    PCC_ALIASNAMES      pCalleeAliasList;
    PCC_ALIASNAMES      pExtraAliasList;

    PCC_ALIASITEM       pExtensionAliasItem;

    // these are part of EndpointType...
    BOOL                VendorInfoPresent;
    CC_VENDORINFO       VendorInfo;
    BYTE                bufVendorProduct[CC_MAX_PRODUCT_LENGTH];
    BYTE                bufVendorVersion[CC_MAX_VERSION_LENGTH];
    BOOL                bIsTerminal;
    BOOL                bIsGateway;

    ASN1_CODER_INFO     World;

    DWORD               dwTimerAlarm301;
    DWORD               dwTimerAlarm303;
	DWORD				dwBandwidth;
} CALL_OBJECT, *P_CALL_OBJECT, **PP_CALL_OBJECT;

CS_STATUS CallListCreate();

CS_STATUS CallListDestroy();

CS_STATUS CallObjectCreate(
    PHQ931CALL          phQ931Call,
    DWORD               dwListenToken,
    DWORD               dwUserToken,
    Q931_CALLBACK       ConnectCallback,
    BOOL                fIsCaller,
    CC_ADDR             *pLocalAddr,         // Local address on which channel is connected
    CC_ADDR             *pPeerConnectAddr,   // Address to which channel is connected
    CC_ADDR             *pPeerCallAddr,      // Address of opposite call end-point.
    CC_ADDR             *pSourceAddr,        // Address of this call end-point.
    CC_CONFERENCEID     *pConferenceID,
    WORD                wGoal,
    WORD                wCallType,
    BOOL                bCallerIsMC,
    char *              pszDisplay,
    char *              pszCalledPartyNumber,
    PCC_ALIASNAMES      pCallerAliasList,
    PCC_ALIASNAMES      pCalleeAliasList,
    PCC_ALIASNAMES      pExtraAliasList,
    PCC_ALIASITEM       pExtensionAliasItem,
    PCC_ENDPOINTTYPE    pEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData,
	DWORD				dwBandwidth,
    WORD                wCRV);

CS_STATUS CallObjectDestroy(
    P_CALL_OBJECT  pCallObject);

CS_STATUS CallObjectLock(
    HQ931CALL         hQ931Call,
    PP_CALL_OBJECT    ppCallObject);

CS_STATUS CallObjectUnlock(
    P_CALL_OBJECT     pCallObject);

CS_STATUS CallObjectValidate(
    HQ931CALL hQ931Call);

BOOL CallObjectFind(
    HQ931CALL *phQ931Call,
    WORD wCRV,
    PCC_ADDR pPeerAddr);

CS_STATUS CallObjectMarkForDelete(
    HQ931CALL hQ931Call);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CallBackT301(P_CALL_OBJECT pCallObject);
void CallBackT303(P_CALL_OBJECT pCallObject);
void CALLBACK Q931TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);
HRESULT Q931StartTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId);
HRESULT Q931StopTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId);

#ifdef __cplusplus
}
#endif

#endif HCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\hlisten.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/HLISTEN.C_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.15  $
 *	$Date:   08 Jan 1997 14:10:34  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 4514 )

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include "common.h"
#include "q931.h"
#include "hlisten.h"
#include "utils.h"
#include "provider.h"

static BOOL bListenListCreated = FALSE;

static struct
{
    P_LISTEN_OBJECT     pHead;
	CRITICAL_SECTION	Lock;
} ListenList;

static struct
{
    HQ931LISTEN           hQ931Listen;
	CRITICAL_SECTION	Lock;
} ListenHandleSource;


//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
_ListenObjectListAdd(
    P_LISTEN_OBJECT  pListenObject)
{
    if ((pListenObject == NULL) || (pListenObject->bInList == TRUE))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
	EnterCriticalSection(&ListenList.Lock);

	pListenObject->pNextInList = ListenList.pHead;
	pListenObject->pPrevInList = NULL;
	if (ListenList.pHead != NULL)
    {
		ListenList.pHead->pPrevInList = pListenObject;
    }
	ListenList.pHead = pListenObject;

	pListenObject->bInList = TRUE;
	LeaveCriticalSection(&ListenList.Lock);

	return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
_ListenObjectListRemove(
    P_LISTEN_OBJECT  pListenObject)
{
    HQ931LISTEN hQ931Listen;

    if ((pListenObject == NULL) || (pListenObject->bInList == FALSE))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
    // caller must have a lock on the listen object;
    // in order to avoid deadlock, we must:
    //   1. unlock the listen object,
    //   2. lock the ListenList,
    //   3. locate the listen object in the ListenList (note that
    //      after step 2, the listen object may be deleted from the
    //      ListenList by another thread),
    //   4. lock the listen object (someone else may have the lock)
    //   5. remove the listen object from the ListenList,
    //   6. unlock the ListenList
    //
    // the caller can now safely unlock and destroy the listen object,
    // since no other thread will be able to find the object (its been
    // removed from the ListenList), and therefore no other thread will
    // be able to lock it.

    // Save the listen handle; its the only way to look up
    // the listen object in the ListenList. Note that we
    // can't use pListenObject to find the listen object, because
    // the pointer will no longer be usable after step 1.
    hQ931Listen = pListenObject->hQ931Listen;

    // step 1
    LeaveCriticalSection(&pListenObject->Lock);

    // step 2
    EnterCriticalSection(&ListenList.Lock);

    // step 3
    pListenObject = ListenList.pHead;
    while ((pListenObject != NULL) && (pListenObject->hQ931Listen != hQ931Listen))
    {
        pListenObject = pListenObject->pNextInList;
    }

    if (pListenObject != NULL)
    {
        // step 4
        EnterCriticalSection(&pListenObject->Lock);

        // step 5
        if (pListenObject->pPrevInList == NULL)
        {
            ListenList.pHead = pListenObject->pNextInList;
        }
        else
        {
            pListenObject->pPrevInList->pNextInList = pListenObject->pNextInList;
        }

        if (pListenObject->pNextInList != NULL)
        {
            pListenObject->pNextInList->pPrevInList = pListenObject->pPrevInList;
        }

        pListenObject->bInList = FALSE;
    }

    // step 6
    LeaveCriticalSection(&ListenList.Lock);

    if (pListenObject == NULL)
    {
        return CS_BAD_PARAM;
    }
    return CS_OK;
}


//====================================================================================
//====================================================================================
CS_STATUS
_ListenHandleNew(
    PHQ931LISTEN phQ931Listen)
{
	EnterCriticalSection(&(ListenHandleSource.Lock));
	*phQ931Listen = ListenHandleSource.hQ931Listen++;
	LeaveCriticalSection(&(ListenHandleSource.Lock));
	return CS_OK;
}



//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
#if 0

BOOL
ListenListAddrSearch(
	WORD wListenPort)          // UDP or TCP port (host byte order)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    BOOL found = FALSE;

    EnterCriticalSection(&ListenList.Lock);

    pListenObject = ListenList.pHead;

    while ((pListenObject != NULL) && (pListenObject->ListenSocketAddr.sin_port != wListenPort))
    {
        pListenObject = pListenObject->pNextInList;
    }
    if (pListenObject != NULL)
    {
        found = TRUE;
    }

    LeaveCriticalSection(&ListenList.Lock);

    return found;
}
#endif

//====================================================================================
//====================================================================================
CS_STATUS
ListenListCreate()
{
    if (bListenListCreated == TRUE)
    {
    	ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    __try {

        // list creation is not protected against multiple threads because it is only
        // called when a process is started, not when a thread is started.
        ListenList.pHead = NULL;
        InitializeCriticalSectionAndSpinCount(&(ListenList.Lock),H323_SPIN_COUNT);

        ListenHandleSource.hQ931Listen = 1;
        InitializeCriticalSectionAndSpinCount(&(ListenHandleSource.Lock),H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // failure
        return CS_NO_MEMORY;
    }

	bListenListCreated = TRUE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenListDestroy()
{
    P_LISTEN_OBJECT  pListenObject;
    HQ931LISTEN hCurrent;

	if (bListenListCreated == FALSE)
    {
    	ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

    for ( ; ; )
    {
        // first, get the top-most listen handle in the list (safely)
        EnterCriticalSection(&(ListenList.Lock));
        pListenObject = ListenList.pHead;
        if (pListenObject == NULL)
        {
            LeaveCriticalSection(&(ListenList.Lock));
            break;
        }
        EnterCriticalSection(&pListenObject->Lock);
        hCurrent = pListenObject->hQ931Listen;
        LeaveCriticalSection(&(pListenObject->Lock));
        LeaveCriticalSection(&(ListenList.Lock));

        // try to cancel the listen object.
        Q931CancelListen(hCurrent);

        // destroy the listen object. (if the object is still around for some reason)
        if (ListenObjectLock(hCurrent, &pListenObject) == CS_OK)
        {
            ListenObjectDestroy(pListenObject);
        }
    }

	DeleteCriticalSection(&(ListenList.Lock));
	DeleteCriticalSection(&(ListenHandleSource.Lock));

	bListenListCreated = FALSE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectCreate(
    PHQ931LISTEN        phQ931Listen,
    DWORD               dwUserToken,
    Q931_CALLBACK       ListenCallback)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS status = CS_OK;

    // make sure the listen list has been created.	
    if (bListenListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

	// validate all parameters for bogus values.
    if ((phQ931Listen == NULL) || (ListenCallback == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    // set phQ931Listen now, in case we encounter an error later.
    *phQ931Listen = 0;

    pListenObject = (P_LISTEN_OBJECT)Malloc(sizeof(LISTEN_OBJECT));
    if (pListenObject == NULL)
    {
        return CS_NO_MEMORY;
    }

    pListenObject->bInList = FALSE;

    if (_ListenHandleNew(&(pListenObject->hQ931Listen)) != CS_OK)
    {
        Free(pListenObject);
        return CS_INTERNAL_ERROR;
    }

    pListenObject->dwUserToken = dwUserToken;
    pListenObject->ListenCallback = ListenCallback;

        Q931MakePhysicalID(&pListenObject->dwPhysicalId);

    __try {

        InitializeCriticalSectionAndSpinCount(&pListenObject->Lock,H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // destroy object
        ListenObjectDestroy(pListenObject);

        // failure
        return CS_NO_MEMORY;
    }

    *phQ931Listen = pListenObject->hQ931Listen;

    // add the listen object to the listen list.
    status = _ListenObjectListAdd(pListenObject);
    if (status != CS_OK)
    {
        ListenObjectDestroy(pListenObject);
    }
    return status;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectDestroy(
    P_LISTEN_OBJECT  pListenObject)
{
    if (pListenObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
	
	// caller must have a lock on the listen object,
	// so there's no need to re-lock it
	
	if (pListenObject->bInList == TRUE)
    {
		if (_ListenObjectListRemove(pListenObject) == CS_BAD_PARAM)
        {
			// the listen object was deleted by another thread,
			// so just return CS_OK
			return CS_OK;
        }
    }

	// since the listen object has been removed from the ListenList,
	// no other thread will be able to find the listen object and obtain
	// a lock, so its safe to unlock the listen object and delete it here.
	LeaveCriticalSection(&(pListenObject->Lock));
	DeleteCriticalSection(&(pListenObject->Lock));
	Free(pListenObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectLock(
    HQ931LISTEN         hQ931Listen,
    PP_LISTEN_OBJECT    ppListenObject)
{
	if ((hQ931Listen == 0) || (ppListenObject == NULL))
    {
    	ASSERT(FALSE);
		return CS_BAD_PARAM;
    }

	EnterCriticalSection(&(ListenList.Lock));

	*ppListenObject = ListenList.pHead;
	while ((*ppListenObject != NULL) && ((*ppListenObject)->hQ931Listen != hQ931Listen))
    {
		*ppListenObject = (*ppListenObject)->pNextInList;
    }

	if (*ppListenObject != NULL)
    {
		EnterCriticalSection(&((*ppListenObject)->Lock));
    }

	LeaveCriticalSection(&(ListenList.Lock));

    if (*ppListenObject == NULL)
    {
        // the handle was not found in the list, so this is treated as a bad parm.
        return CS_BAD_PARAM;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
ListenObjectUnlock(
    P_LISTEN_OBJECT  pListenObject)
{
    if (pListenObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    LeaveCriticalSection(&pListenObject->Lock);
    return CS_OK;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\hcall.cpp ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hcall.cpv  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   2.7.1.0  $
 *	$Date:   20 Jun 1997 14:12:08  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4100 4115 4201 4214 4514 4702 4710 )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <time.h>

#include "q931asn.h"

#include "isrg.h"

#include "common.h"
#include "q931.h"

#include "hcall.h"
#include "utils.h"

#include "tstable.h"
#include "provider.h"

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif

static BOOL bCallListCreated = FALSE;

// Pointer to our global table.  Note that this table replaces the previous
// linked-list implementation.

TSTable<CALL_OBJECT>* gpCallObjectTable = NULL;

// Our call back function for enumerating the table when we want to tear down
// all existing calls

DWORD Q931HangUpAllCalls(P_CALL_OBJECT pCallObject, LPVOID context);

// Our call back function for determining if a timer has expired

DWORD Q931CheckForTimeout(P_CALL_OBJECT pCallObject, LPVOID context);

// Our call back function for determining if a timer has expired

DWORD Q931CallObjectFind(P_CALL_OBJECT pCallObject, LPVOID context);


static struct
{
    WORD                wCRV;              // Call Reference Value (0..7FFF).
    CRITICAL_SECTION    Lock;
} CRVSource;

static struct
{
    BOOL bBusy;
    DWORD dwTimerCount;
    DWORD dwTicks301;
    DWORD dwTicks303;
    UINT_PTR uTimerId;
    CRITICAL_SECTION Lock;
} Q931GlobalTimer = {0};



typedef struct 
{
		BOOL bFound;
		WORD wCRV;
		PCC_ADDR pPeerAddr;
		HQ931CALL hQ931Call;
} Q931CALLOBJKEY, *PQ931CALLOBJKEY;


//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
Q931CRVNew(
    WORD *pwCRV)
{
    EnterCriticalSection(&(CRVSource.Lock));
    CRVSource.wCRV = (WORD)((CRVSource.wCRV + 1) & 0x7fff);
    if (CRVSource.wCRV == 0)
    {
        CRVSource.wCRV = 1;
    }
    *pwCRV = CRVSource.wCRV;
    LeaveCriticalSection(&(CRVSource.Lock));
    return CS_OK;
}

//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
CallListCreate()
{
    if (bCallListCreated == TRUE)
    {
        ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    // list creation is not protected against multiple threads because it is only
    // called when a process is started, not when a thread is started.

		// Create the call object table.  We will initially create 30 entries.  The
		// TSTable can automatically grow, so no worrying about running out of entries.

		gpCallObjectTable = new TSTable <CALL_OBJECT> (30);

		if (gpCallObjectTable == NULL || gpCallObjectTable->IsInitialized() == FALSE)
		{
			return CS_NO_MEMORY;
		}

    __try {

        CRVSource.wCRV = (WORD) (time(NULL) & 0x7fff);
        InitializeCriticalSectionAndSpinCount(&(CRVSource.Lock),H323_SPIN_COUNT);

        Q931GlobalTimer.dwTicks301 = Q931_TICKS_301;
        Q931GlobalTimer.dwTicks303 = Q931_TICKS_303;
        InitializeCriticalSectionAndSpinCount(&(Q931GlobalTimer.Lock),H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // failure
        return CS_NO_MEMORY;
    }

    bCallListCreated = TRUE;

    return CS_OK;
}


//====================================================================================
// this routine assumes all of the events and sockets belonging to each object
// are already destroyed.  It just makes sure memory is cleaned up.
//====================================================================================
CS_STATUS
CallListDestroy()
{
    if (bCallListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

		// For all entries, hang up the calls

		gpCallObjectTable->EnumerateEntries(Q931HangUpAllCalls,
																				NULL);

		// Get rid of the call object table

		delete gpCallObjectTable;
		gpCallObjectTable = NULL;

    DeleteCriticalSection(&(Q931GlobalTimer.Lock));
    DeleteCriticalSection(&(CRVSource.Lock));

    bCallListCreated = FALSE;

    return CS_OK;
}

//====================================================================================
//====================================================================================
void
CallObjectFree(P_CALL_OBJECT pCallObject)
{
    if (pCallObject->NonStandardData.sData.pOctetString != NULL)
    {
        Free(pCallObject->NonStandardData.sData.pOctetString);
        pCallObject->NonStandardData.sData.pOctetString = NULL;
    }
    if (pCallObject->VendorInfoPresent)
    {
        if (pCallObject->VendorInfo.pProductNumber != NULL)
        {
            Free(pCallObject->VendorInfo.pProductNumber);
        }
        if (pCallObject->VendorInfo.pVersionNumber != NULL)
        {
            Free(pCallObject->VendorInfo.pVersionNumber);
        }
    }
    
    Q931FreeAliasNames(pCallObject->pCallerAliasList);
    pCallObject->pCallerAliasList = NULL;
    Q931FreeAliasNames(pCallObject->pCalleeAliasList);
    pCallObject->pCalleeAliasList = NULL;
    Q931FreeAliasNames(pCallObject->pExtraAliasList);
    pCallObject->pExtraAliasList = NULL;
    Q931FreeAliasItem(pCallObject->pExtensionAliasItem);
    pCallObject->pExtensionAliasItem = NULL;
    Free(pCallObject);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectCreate(
    PHQ931CALL          phQ931Call,
    DWORD               dwListenToken,
    DWORD               dwUserToken,
    Q931_CALLBACK       ConnectCallback,
    BOOL                fIsCaller,
    CC_ADDR             *pLocalAddr,         // Local address on which channel is connected
    CC_ADDR             *pPeerConnectAddr,   // Address to which channel is connected
    CC_ADDR             *pPeerCallAddr,      // Address of opposite call end-point.
    CC_ADDR             *pSourceAddr,        // Address of this call end-point.
    CC_CONFERENCEID     *pConferenceID,
    WORD                wGoal,
    WORD                wCallType,
    BOOL                bCallerIsMC,
    char                *pszDisplay,
    char                *pszCalledPartyNumber,
    PCC_ALIASNAMES      pCallerAliasList,
    PCC_ALIASNAMES      pCalleeAliasList,
    PCC_ALIASNAMES      pExtraAliasList,
    PCC_ALIASITEM       pExtensionAliasItem,
    PCC_ENDPOINTTYPE    pEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData,    // questionable!
	DWORD				dwBandwidth,
    WORD                wCRV)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS status = CS_OK;
    CS_STATUS CopyStatus = CS_OK;
    DWORD dwIndex = 0;
    int rc = 0;

    // make sure the call list has been created.    
    if (bCallListCreated == FALSE)
    {
        ASSERT(FALSE);
        return CS_INTERNAL_ERROR;
    }

    // validate all parameters for bogus values.
    if ((phQ931Call == NULL) || (ConnectCallback == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    // set phQ931Call now, in case we encounter an error later.
    *phQ931Call = 0;

    pCallObject = (P_CALL_OBJECT)Malloc(sizeof(CALL_OBJECT));
    if (pCallObject == NULL)
    {
        return CS_NO_MEMORY;
    }
    memset(pCallObject, 0, sizeof(CALL_OBJECT));


    // create and init an oss world struct for each call object.  This is 
                // necessary to work in MT environments.
    rc = Q931_InitWorld(&pCallObject->World);
    if (rc != ASN1_SUCCESS)
    {
        Q931DBG((DBGERROR, "Q931_InitCoder() returned: %d ", rc));
        return CS_SUBSYSTEM_FAILURE;
    }

    pCallObject->LocalAddr.bMulticast = FALSE;
    pCallObject->PeerConnectAddr.bMulticast = FALSE;
    pCallObject->PeerCallAddr.bMulticast = FALSE;
    pCallObject->SourceAddr.bMulticast = FALSE;


    if (wCRV == 0)
    {
        if (Q931CRVNew(&pCallObject->wCRV) != CS_OK)
        {
            CallObjectFree(pCallObject);
            return CS_INTERNAL_ERROR;
        }
    }
    else
    {
        pCallObject->wCRV = wCRV;
    }

    pCallObject->szDisplay[0] = '\0';
    if (pszDisplay)
    {
        strcpy(pCallObject->szDisplay, pszDisplay);
    }

    pCallObject->szCalledPartyNumber[0] = '\0';
    if (pszCalledPartyNumber)
    {
        strcpy(pCallObject->szCalledPartyNumber, pszCalledPartyNumber);
    }

    pCallObject->dwListenToken = dwListenToken;
    pCallObject->dwUserToken = dwUserToken;
    pCallObject->Callback = ConnectCallback;
    pCallObject->bCallState = CALLSTATE_NULL;
    pCallObject->fIsCaller = fIsCaller;

    if (pLocalAddr)
    {
        pCallObject->LocalAddr = *pLocalAddr;
    }
    if (pPeerConnectAddr)
    {
        pCallObject->PeerConnectAddr = *pPeerConnectAddr;
    }
    if (pPeerCallAddr)
    {
        pCallObject->PeerCallAddr = *pPeerCallAddr;
        pCallObject->PeerCallAddrPresent = TRUE;
    }
    else
    {
        pCallObject->PeerCallAddrPresent = FALSE;
    }

    if (pSourceAddr)
    {
        pCallObject->SourceAddr = *pSourceAddr;
        pCallObject->SourceAddrPresent = TRUE;
    }
    else
    {
        pCallObject->SourceAddrPresent = FALSE;
    }

    if (pConferenceID == NULL)
    {
        memset(&(pCallObject->ConferenceID), 0, sizeof(CC_CONFERENCEID));
    }
    else
    {
        int length = min(sizeof(pConferenceID->buffer),
            sizeof(pCallObject->ConferenceID.buffer));
        memcpy(pCallObject->ConferenceID.buffer,
            pConferenceID->buffer, length);
    }

    pCallObject->wGoal = wGoal;
    pCallObject->bCallerIsMC = bCallerIsMC;
    pCallObject->wCallType = wCallType;

    if (pNonStandardData != NULL)
    {
        pCallObject->NonStandardData = *pNonStandardData;
        if (pNonStandardData->sData.wOctetStringLength > 0)
        {
            pCallObject->NonStandardData.sData.pOctetString =
                (BYTE *) Malloc(pNonStandardData->sData.wOctetStringLength);
            if (pCallObject->NonStandardData.sData.pOctetString == NULL)
            {
                CallObjectFree(pCallObject);
                return CS_NO_MEMORY;
            }
            memcpy(pCallObject->NonStandardData.sData.pOctetString,
                pNonStandardData->sData.pOctetString,
                pNonStandardData->sData.wOctetStringLength);
        }
        pCallObject->NonStandardDataPresent = TRUE;
    }
    else
    {
        pCallObject->NonStandardDataPresent = FALSE;
    }

    CopyStatus = Q931CopyAliasNames(&(pCallObject->pCallerAliasList),
        pCallerAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasNames(&(pCallObject->pCalleeAliasList),
        pCalleeAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasNames(&(pCallObject->pExtraAliasList),
        pExtraAliasList);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }
    CopyStatus = Q931CopyAliasItem(&(pCallObject->pExtensionAliasItem),
        pExtensionAliasItem);
    if (CopyStatus != CS_OK)
    {
        CallObjectFree(pCallObject);
        return CopyStatus;
    }

    pCallObject->bResolved = FALSE;
    pCallObject->VendorInfoPresent = FALSE;
    pCallObject->bIsTerminal = TRUE;
    pCallObject->bIsGateway = FALSE;
    if (pEndpointType != NULL)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo != NULL)
        {
            pCallObject->VendorInfoPresent = TRUE;
            pCallObject->VendorInfo = *(pVendorInfo);

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                memcpy(pCallObject->bufVendorProduct,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
                pCallObject->VendorInfo.pProductNumber = (CC_OCTETSTRING*) Malloc(sizeof(CC_OCTETSTRING));
                if (pCallObject->VendorInfo.pProductNumber == NULL)
                {
                    CallObjectFree(pCallObject);
                    return CS_NO_MEMORY;
                }
                pCallObject->VendorInfo.pProductNumber->pOctetString =
                    pCallObject->bufVendorProduct;
                pCallObject->VendorInfo.pProductNumber->wOctetStringLength =
                    pVendorInfo->pProductNumber->wOctetStringLength;
            }
            else
            {
                pCallObject->VendorInfo.pProductNumber = NULL;
            }

            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                memcpy(pCallObject->bufVendorVersion,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
                pCallObject->VendorInfo.pVersionNumber = (CC_OCTETSTRING*) Malloc(sizeof(CC_OCTETSTRING));
                if (pCallObject->VendorInfo.pVersionNumber == NULL)
                {
                    CallObjectFree(pCallObject);
                    return CS_NO_MEMORY;
                }
                pCallObject->VendorInfo.pVersionNumber->pOctetString =
                    pCallObject->bufVendorVersion;
                pCallObject->VendorInfo.pVersionNumber->wOctetStringLength =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
            }
            else
            {
                pCallObject->VendorInfo.pVersionNumber = NULL;
            }

        }
        pCallObject->bIsTerminal = pEndpointType->bIsTerminal;
        pCallObject->bIsGateway = pEndpointType->bIsGateway;
		pCallObject->dwBandwidth = dwBandwidth;
    }

	Q931MakePhysicalID(&pCallObject->dwPhysicalId);
				
		// Insert the object into the table...if that doesn't work, blow away the object.

		if (gpCallObjectTable->CreateAndLock(pCallObject,
																				 &dwIndex) == FALSE)
		{
			CallObjectFree(pCallObject);
			return CS_INTERNAL_ERROR;
		}

		// Save the index as the handle (this makes it easier to find the object later).

    *phQ931Call = pCallObject->hQ931Call = (HQ931CALL) dwIndex;
		Q931DBG((DBGTRACE, "CallObjectCreate() -returned-> 0x%08x", dwIndex));
		// Unlock the entry

		gpCallObjectTable->Unlock(dwIndex);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectDestroy(
    P_CALL_OBJECT  pCallObject)
{
    if (pCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

		Q931DBG((DBGTRACE, "CallObjectDestroy(0x%08lx)", pCallObject->hQ931Call));

                Q931_TermWorld(&pCallObject->World);

		// Since the caller must already have a lock on the object, remove the entry from
		// the table.  We won't let the table delete the object as we want to clean up.

		if (gpCallObjectTable->Delete((DWORD) pCallObject->hQ931Call) == FALSE)
		{
			return CS_OK;
		}

    Q931StopTimer(pCallObject, Q931_TIMER_301);
    Q931StopTimer(pCallObject, Q931_TIMER_303);

		// Unlock the object

		gpCallObjectTable->Unlock((DWORD) pCallObject->hQ931Call);

		// Free up the call object

    CallObjectFree(pCallObject);
   
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectLock(
    HQ931CALL         hQ931Call,
    PP_CALL_OBJECT    ppCallObject)
{
    if (ppCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

	// Attempt to lock the entry.  If that fails, we'll return CS_BAD_PARAM under
	// the assumption that the entry is invalid.

	*ppCallObject = gpCallObjectTable->Lock((DWORD) hQ931Call);

	return (*ppCallObject == NULL ? CS_BAD_PARAM : CS_OK);
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectUnlock(
    P_CALL_OBJECT  pCallObject)
{
    if (pCallObject == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

		// Unlock the entry

		if (gpCallObjectTable->Unlock((DWORD) pCallObject->hQ931Call) == FALSE)
		{
			Q931DBG((DBGERROR, "gpCallObjectTable->Unlock(0x%08lx) FAILED!!!!", pCallObject->hQ931Call));
			return CS_BAD_PARAM;
		}

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
CallObjectValidate(
    HQ931CALL hQ931Call)
{
	if (gpCallObjectTable->Validate((DWORD) hQ931Call) == TRUE)
	{
		return CS_OK;
	}

	return CS_BAD_PARAM;
}

//====================================================================================
//====================================================================================
BOOL
CallObjectFind(
    HQ931CALL *phQ931Call,
    WORD wCRV,
    PCC_ADDR pPeerAddr)
{
		Q931CALLOBJKEY Q931CallObjKey;
		Q931CallObjKey.wCRV = wCRV;
		Q931CallObjKey.pPeerAddr = pPeerAddr;
		Q931CallObjKey.bFound = FALSE;
		
		gpCallObjectTable->EnumerateEntries(Q931CallObjectFind,
																				(LPVOID) &Q931CallObjKey);
	 
		if(Q931CallObjKey.bFound == TRUE) 
		{
        *phQ931Call = Q931CallObjKey.hQ931Call;
        return TRUE;
    }
    return FALSE;
}

//====================================================================================
//====================================================================================
CS_STATUS CallObjectMarkForDelete(HQ931CALL hQ931Call)
{
	// User must have the object already locked to call this.

	// Mark the object as deleted but don't let the table delete the object's
	// memory.

	return (gpCallObjectTable->Delete((DWORD) hQ931Call) == FALSE ? CS_BAD_PARAM : CS_OK);
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//====================================================================================
// This routine will be called every 1000 ms if any call object
// has caused the Q931GlobalTimer to be created.
//====================================================================================
VOID CALLBACK
Q931TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    DWORD dwTickCount = GetTickCount();

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (Q931GlobalTimer.bBusy)
    {
        LeaveCriticalSection(&(Q931GlobalTimer.Lock));
        return;
    }
    Q931GlobalTimer.bBusy = TRUE;

		// Check all of the entries for timeout

		gpCallObjectTable->EnumerateEntries(Q931CheckForTimeout,
																				(LPVOID) &dwTickCount);

    Q931GlobalTimer.bBusy = FALSE;
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));
}

//====================================================================================
//====================================================================================
HRESULT
Q931StartTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId)
{
    if (pCallObject == NULL)
    {
        return CS_BAD_PARAM;
    }

    switch (wTimerId)
    {
        case Q931_TIMER_301:
            if (pCallObject->dwTimerAlarm301)
            {
                // timer is already set for this call object...
                return CS_INTERNAL_ERROR;
            }
            EnterCriticalSection(&(Q931GlobalTimer.Lock));
            pCallObject->dwTimerAlarm301 = GetTickCount() + Q931GlobalTimer.dwTicks301;
            LeaveCriticalSection(&(Q931GlobalTimer.Lock));
            break;
        case Q931_TIMER_303:
            if (pCallObject->dwTimerAlarm303)
            {
                // timer is already set for this call object...
                return CS_INTERNAL_ERROR;
            }
            EnterCriticalSection(&(Q931GlobalTimer.Lock));
            pCallObject->dwTimerAlarm303 = GetTickCount() + Q931GlobalTimer.dwTicks303;
            LeaveCriticalSection(&(Q931GlobalTimer.Lock));
            break;
        default:
            return CS_BAD_PARAM;
            break;
    }

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (!Q931GlobalTimer.dwTimerCount)
    {
        Q931GlobalTimer.uTimerId = SetTimer(NULL, 0, 1000, (TIMERPROC)Q931TimerProc);
    }
    Q931GlobalTimer.dwTimerCount++;
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));

    return CS_OK;
}

//====================================================================================
//====================================================================================
HRESULT
Q931StopTimer(P_CALL_OBJECT pCallObject, DWORD wTimerId)
{
    if (pCallObject == NULL)
    {
        return CS_BAD_PARAM;
    }
    switch (wTimerId)
    {
        case Q931_TIMER_301:
            if (!pCallObject->dwTimerAlarm301)
            {
                return CS_OK;
            }
            pCallObject->dwTimerAlarm301 = 0;
            break;
        case Q931_TIMER_303:
            if (!pCallObject->dwTimerAlarm303)
            {
                return CS_OK;
            }
            pCallObject->dwTimerAlarm303 = 0;
            break;
        default:
            return CS_BAD_PARAM;
            break;
    }

    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (Q931GlobalTimer.dwTimerCount > 0)
    {
        Q931GlobalTimer.dwTimerCount--;
        if (!Q931GlobalTimer.dwTimerCount)
        {
            KillTimer(NULL, Q931GlobalTimer.uTimerId);
            Q931GlobalTimer.uTimerId = 0;
        }
    }
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SetAlertingTimeout(DWORD dwDuration)
{
    EnterCriticalSection(&(Q931GlobalTimer.Lock));
    if (dwDuration)
    {
        Q931GlobalTimer.dwTicks303 = dwDuration;
    }
    else
    {
        Q931GlobalTimer.dwTicks303 = Q931_TICKS_303;
    }
    LeaveCriticalSection(&(Q931GlobalTimer.Lock));
    return CS_OK;
}

//====================================================================================
//====================================================================================
DWORD Q931HangUpAllCalls(P_CALL_OBJECT pCallObject, LPVOID context)
{
	HQ931CALL hQ931Call = pCallObject->hQ931Call;

	// Try to hangup the call object.

	Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);

	// Try to lock the object.  If that succeeds, then we want to force the object to
	// be deleted.  We should never have to do this as the hang up is supposed to
	// take care of that for us.

	if (gpCallObjectTable->Lock(hQ931Call) != NULL)
	{
		CallObjectDestroy(pCallObject);
	}

	return CALLBACK_DELETE_ENTRY;
}

//====================================================================================
//====================================================================================
DWORD
Q931CallObjectFind(P_CALL_OBJECT pCallObject, LPVOID context)
{
	PQ931CALLOBJKEY pQ931CallObjKey = (PQ931CALLOBJKEY) context;
	PCC_ADDR pPeerAddr = pQ931CallObjKey->pPeerAddr;
	WORD wCRV = pQ931CallObjKey->wCRV;

	if (!pCallObject->bResolved)
	{
		return(CALLBACK_CONTINUE);
	}
	
	if ((pCallObject->wCRV & (~0x8000)) == (wCRV & (~0x8000)))
	{
		if (!pPeerAddr)
		{
			pQ931CallObjKey->bFound = TRUE;
			pQ931CallObjKey->hQ931Call = pCallObject->hQ931Call;
			return(CALLBACK_ABORT);
		}
                else if ((pPeerAddr->nAddrType == CC_IP_BINARY) &&
                         (pPeerAddr->Addr.IP_Binary.dwAddr == INADDR_LOOPBACK))
                {
                        pQ931CallObjKey->bFound = FALSE;
                        pQ931CallObjKey->hQ931Call = NULL;
                        return(CALLBACK_CONTINUE); // allow loopback calls
                }
                else if ((pCallObject->LocalAddr.nAddrType == CC_IP_BINARY) &&
                         (pPeerAddr->nAddrType == CC_IP_BINARY) &&
                         (pCallObject->LocalAddr.Addr.IP_Binary.dwAddr == pPeerAddr->Addr.IP_Binary.dwAddr))
                {
                        pQ931CallObjKey->bFound = FALSE;
                        pQ931CallObjKey->hQ931Call = NULL;
                        return(CALLBACK_CONTINUE); // allow loopback calls
                }
                else if ((pCallObject->PeerConnectAddr.nAddrType == CC_IP_BINARY) &&
                         (pPeerAddr->nAddrType == CC_IP_BINARY) &&
                         (pCallObject->PeerConnectAddr.Addr.IP_Binary.dwAddr == pPeerAddr->Addr.IP_Binary.dwAddr))
                {
                        pQ931CallObjKey->bFound = TRUE;
                        pQ931CallObjKey->hQ931Call = pCallObject->hQ931Call;
                        return(CALLBACK_ABORT);
		}
	}
	return(CALLBACK_CONTINUE);
}


//====================================================================================
//====================================================================================

DWORD Q931CheckForTimeout(P_CALL_OBJECT pCallObject, LPVOID context)
{
	DWORD dwTickCount = *((LPDWORD) context);

	// Determine if a timer has expired for the entry

	if (pCallObject->dwTimerAlarm301 &&
			(pCallObject->dwTimerAlarm301 <= dwTickCount))
	{
		Q931StopTimer(pCallObject, Q931_TIMER_301);
		Q931StopTimer(pCallObject, Q931_TIMER_303);

		if (pCallObject->dwTimerAlarm303 &&
				(pCallObject->dwTimerAlarm303 < pCallObject->dwTimerAlarm301) &&
				(pCallObject->dwTimerAlarm303 <= dwTickCount))
		{
			CallBackT303(pCallObject);
		}
		else
		{
			CallBackT301(pCallObject);
		}
	}
	else if (pCallObject->dwTimerAlarm303 &&
					 (pCallObject->dwTimerAlarm303 <= dwTickCount))
	{
		Q931StopTimer(pCallObject, Q931_TIMER_301);
		Q931StopTimer(pCallObject, Q931_TIMER_303);
		CallBackT303(pCallObject);
	}

	return CALLBACK_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\q931.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/q931.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.122.1.0  $
 *	$Date:   20 Jun 1997 14:12:46  $
 *	$Author:   MANDREWS  $
 *
 *	BCL's revision info:
 *	Revision:   1.99  
 *	Date:   19 Nov 1996 14:54:02  
 *	Author:   rodellx  
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/
// [ ] Add facility ie to FACILITY MSG.
// [ ] Read Q931 Appendix D.

#pragma warning ( disable : 4057 4100 4115 4201 4214 4514 )

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <stdio.h>

#include <rpc.h>

#include "apierror.h"
#include "isrg.h"
#include "incommon.h"
#include "linkapi.h"

#include "common.h"
#include "q931.h"
#include "utils.h"
#include "hlisten.h"
#include "hcall.h"
#include "q931pdu.h"
#include "provider.h"

#if (defined(_DEBUG) && defined(PCS_COMPLIANCE))
#include "interop.h"
#include "q931plog.h"
LPInteropLogger Q931Logger;
#endif

#define RECEIVE_BUFFER_SIZE 0x2000
#define HANGUP_TIMEOUT              1000        // 1 second
#define CANCEL_LISTEN_TIMEOUT       5000        // 5 seconds

// variable needed to support ISR debug facility.
#if (ISRDEBUGINFO >= 1)
WORD ghISRInst = 0;
#endif

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif

#define _Unicode(x) L ## x
#define Unicode(x) _Unicode(x)

// global data used by WinSock.
static BOOL bQ931Initialized = FALSE;

static Q931_RECEIVE_PDU_CALLBACK gReceivePDUHookProc = NULL;

static struct
{
    DWORD TempID;
    CC_CONFERENCEID ConferenceID;
    CRITICAL_SECTION Lock;
} ConferenceIDSource;

//====================================================================================
//
// PRIVATE FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
void _FreeSetupASN(Q931_SETUP_ASN *pSetupASN)
{
	ASSERT(pSetupASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pSetupASN->NonStandardData.sData.pOctetString)
	{
		Free(pSetupASN->NonStandardData.sData.pOctetString);
		pSetupASN->NonStandardData.sData.pOctetString = NULL;
	}
	if (pSetupASN->VendorInfo.pProductNumber)
	{
		Free(pSetupASN->VendorInfo.pProductNumber);
		pSetupASN->VendorInfo.pProductNumber = NULL;
	}
	if (pSetupASN->VendorInfo.pVersionNumber)
	{
		Free(pSetupASN->VendorInfo.pVersionNumber);
		pSetupASN->VendorInfo.pVersionNumber = NULL;
	}
	Q931FreeAliasNames(pSetupASN->pCallerAliasList);
	pSetupASN->pCallerAliasList = NULL;
	Q931FreeAliasNames(pSetupASN->pCalleeAliasList);
	pSetupASN->pCalleeAliasList = NULL;
	Q931FreeAliasNames(pSetupASN->pExtraAliasList);
	pSetupASN->pExtraAliasList = NULL;
	Q931FreeAliasItem(pSetupASN->pExtensionAliasItem);
	pSetupASN->pExtensionAliasItem = NULL;
}


void _FreeReleaseCompleteASN(Q931_RELEASE_COMPLETE_ASN *pReleaseCompleteASN)
{
	ASSERT(pReleaseCompleteASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pReleaseCompleteASN->NonStandardData.sData.pOctetString)
	{
		Free(pReleaseCompleteASN->NonStandardData.sData.pOctetString);
		pReleaseCompleteASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeFacilityASN(Q931_FACILITY_ASN *pFacilityASN)
{
	ASSERT(pFacilityASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pFacilityASN->NonStandardData.sData.pOctetString)
	{
		Free(pFacilityASN->NonStandardData.sData.pOctetString);
		pFacilityASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeProceedingASN(Q931_CALL_PROCEEDING_ASN *pProceedingASN)
{
	ASSERT(pProceedingASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pProceedingASN->NonStandardData.sData.pOctetString)
	{
		Free(pProceedingASN->NonStandardData.sData.pOctetString);
		pProceedingASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeAlertingASN(Q931_ALERTING_ASN *pAlertingASN)
{
	ASSERT(pAlertingASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pAlertingASN->NonStandardData.sData.pOctetString)
	{
		Free(pAlertingASN->NonStandardData.sData.pOctetString);
		pAlertingASN->NonStandardData.sData.pOctetString = NULL;
	}
}


void _FreeConnectASN(Q931_CONNECT_ASN *pConnectASN)
{
	ASSERT(pConnectASN != NULL);

	// Cleanup any dynamically allocated fields within SetupASN
	if (pConnectASN->NonStandardData.sData.pOctetString)
	{
		Free(pConnectASN->NonStandardData.sData.pOctetString);
		pConnectASN->NonStandardData.sData.pOctetString = NULL;
	}
	if (pConnectASN->VendorInfo.pProductNumber)
    {
        Free(pConnectASN->VendorInfo.pProductNumber);
        pConnectASN->VendorInfo.pProductNumber = NULL;
    }
    if (pConnectASN->VendorInfo.pVersionNumber)
    {
        Free(pConnectASN->VendorInfo.pVersionNumber);
        pConnectASN->VendorInfo.pVersionNumber = NULL;
    }
}


void
_ConferenceIDNew(
    CC_CONFERENCEID *pConferenceID)
{
    UUID id;
    int iresult;
    
    EnterCriticalSection(&(ConferenceIDSource.Lock));

    memset(ConferenceIDSource.ConferenceID.buffer, 0,
        sizeof(ConferenceIDSource.ConferenceID.buffer));
    iresult = UuidCreate(&id);
  
    if ((iresult == RPC_S_OK) || (iresult ==RPC_S_UUID_LOCAL_ONLY))
    {
        memcpy(ConferenceIDSource.ConferenceID.buffer, &id,
            min(sizeof(ConferenceIDSource.ConferenceID.buffer), sizeof(UUID)));
    }
    else
        ASSERT(0);
    
    memcpy(pConferenceID->buffer, ConferenceIDSource.ConferenceID.buffer,
        sizeof(pConferenceID->buffer));

    LeaveCriticalSection(&(ConferenceIDSource.Lock));
    return;
}

//====================================================================================
// This function is used internally whenever a function needs to send a PDU.
// Note that before a datalinkSendRequest() is done, the call object is unlocked
// and then subsequently locked after returning.  This is necessary to prevent deadlock
// in MT apps.  Further, it is the responsibility of calling functions to revalidate
// the call object before using it.
//====================================================================================
CS_STATUS 
Q931SendMessage(
    P_CALL_OBJECT       pCallObject,
    BYTE*               CodedPtrPDU, 
    DWORD               CodedLengthPDU,
    BOOL                bOkToUnlock)
{
    HQ931CALL           hQ931Call;
    DWORD               dwPhysicalId;
    HRESULT             result;

    ASSERT(pCallObject != NULL);
    ASSERT(CodedPtrPDU != NULL);
    ASSERT(CodedLengthPDU != 0);

    hQ931Call    = pCallObject->hQ931Call;
    dwPhysicalId = pCallObject->dwPhysicalId;

    // send the message.
    if (pCallObject->bConnected)
    {
        // Unlock the call object before we call down to Link Layer (if caller said it was ok)
        if(bOkToUnlock)
            CallObjectUnlock(pCallObject);

#if (defined(_DEBUG) && defined(PCS_COMPLIANCE))
        InteropOutput(Q931Logger, (BYTE FAR*)CodedPtrPDU, CodedLengthPDU, Q931LOG_SENT_PDU);
#endif

        result = datalinkSendRequest(dwPhysicalId, CodedPtrPDU, CodedLengthPDU);

        // Now attempt to lock the object again.  Note: higher level funcs must
        // be sure to call CallObjectValidate before assuming they have a valid lock
        if (bOkToUnlock && ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL)))
        {
            Q931DBG((DBGERROR, "CallObjectLock() returned error (object not found)."));
        }

        // Note: if we can't get the lock, perhaps we should pass back a specific return code
        // that higher layers can check for??? For now, they should call CallObjectValidate()
        // before assuming the call object is still good.
        if (FAILED(result))
        {
            Q931DBG((DBGERROR, "datalinkSendRequest() failed"));
            Free(CodedPtrPDU);
        }
        return result;
    }

    Q931DBG((DBGWARNING, "Q931SendMessage: message not sent because bConnected is FALSE"));
    Free(CodedPtrPDU);
    return CS_OK;
}


//====================================================================================
//====================================================================================
CS_STATUS
Q931RingingInternal(P_CALL_OBJECT pCallObject, WORD wCRV)
{
    CC_ENDPOINTTYPE EndpointType;
    DWORD CodedLengthASN;
    BYTE *CodedPtrASN;
    BINARY_STRING UserUserData;
    DWORD CodedLengthPDU;
    BYTE *CodedPtrPDU;
    HRESULT result = CS_OK;
    int nError = 0;
	HQ931CALL hQ931Call = pCallObject->hQ931Call;

    if (pCallObject->VendorInfoPresent)
        EndpointType.pVendorInfo = &pCallObject->VendorInfo;
    else
        EndpointType.pVendorInfo = NULL;
    EndpointType.bIsTerminal = pCallObject->bIsTerminal;
    EndpointType.bIsGateway = pCallObject->bIsGateway;

    result = Q931AlertingEncodeASN(
        NULL, /* pNonStandardData */
        NULL, /* h245Addr */
        &EndpointType,
        &pCallObject->World,
        &CodedPtrASN,
        &CodedLengthASN);

    if (result != CS_OK || CodedLengthASN == 0 || CodedPtrASN == NULL)
    {
        Q931DBG((DBGERROR, "Q931AlertingEncodeASN() failed, nothing to send."));
        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }
        return (result != CS_OK) ? result : CS_INTERNAL_ERROR;
    }

    UserUserData.length = (WORD)CodedLengthASN;
    UserUserData.ptr = CodedPtrASN;

    result = Q931AlertingEncodePDU(wCRV, &UserUserData, &CodedPtrPDU,
        &CodedLengthPDU);

    if (CodedPtrASN != NULL)
    {
        Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
    }

    if ((result != CS_OK) || (CodedLengthPDU == 0) ||
            (CodedPtrPDU == NULL))
    {
        Q931DBG((DBGERROR, "Q931AlertingEncodePDU() failed, nothing to send."));
        if (CodedPtrPDU != NULL)
        {
            Free(CodedPtrPDU);
        }
        if (result != CS_OK)
        {
            return result;
        }
        return CS_INTERNAL_ERROR;
    }
    else
    {
        result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
        if(CallObjectValidate(hQ931Call) != CS_OK)
            return(CS_INTERNAL_ERROR);

    }
    return result;
}


//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallSetup(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_SETUP_ASN *pSetupASN)
{
    DWORD		result;
	HQ931CALL	hQ931Call;
	HRESULT		Status;

    // if the callstate is anything other than null, ignore...
//    if (pCallObject->bCallState != CALLSTATE_NULL)
//    {
//        return CS_OK;
//    }

	hQ931Call = pCallObject->hQ931Call;

    if (pMessage->CallReference & 0x8000)
    {
        // the message came from the callee, so this should be ignored???
    }
    pMessage->CallReference &= ~(0x8000);    // strip off the high bit.
    pCallObject->wCRV = pMessage->CallReference;

    pCallObject->wGoal = pSetupASN->wGoal;
    pCallObject->bCallerIsMC = pSetupASN->bCallerIsMC;
    pCallObject->wCallType = pSetupASN->wCallType;
    pCallObject->ConferenceID = pSetupASN->ConferenceID;

    pCallObject->bCallState = CALLSTATE_PRESENT;

    {
        CSS_CALL_INCOMING EventData;
        WCHAR szUnicodeDisplay[CC_MAX_DISPLAY_LENGTH + 1];
        WCHAR szUnicodeCalledPartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];
        WCHAR szUnicodeCallingPartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];

        EventData.wGoal = pCallObject->wGoal;
        EventData.wCallType = pCallObject->wCallType;
        EventData.bCallerIsMC = pCallObject->bCallerIsMC;
        EventData.ConferenceID = pCallObject->ConferenceID;

        EventData.pSourceAddr = NULL;
        if (pSetupASN->SourceAddrPresent)
        {
            EventData.pSourceAddr = &(pSetupASN->SourceAddr);
        }

        EventData.pCallerAddr = NULL;
        if (pSetupASN->CallerAddrPresent)
        {
            EventData.pCallerAddr = &(pSetupASN->CallerAddr);
        }

        EventData.pCalleeDestAddr = NULL;
        if (pSetupASN->CalleeDestAddrPresent)
        {
            EventData.pCalleeDestAddr = &(pSetupASN->CalleeDestAddr);
        }

        EventData.pLocalAddr = NULL;
        if (pSetupASN->CalleeAddrPresent)
        {
            EventData.pLocalAddr = &(pSetupASN->CalleeAddr);
        }

        if (!(pSetupASN->NonStandardDataPresent) ||
                (pSetupASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pSetupASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pSetupASN->NonStandardData);
        }

        EventData.pCallerAliasList = pSetupASN->pCallerAliasList;
        EventData.pCalleeAliasList = pSetupASN->pCalleeAliasList;
        EventData.pExtraAliasList = pSetupASN->pExtraAliasList;
        EventData.pExtensionAliasItem = pSetupASN->pExtensionAliasItem;

        EventData.pszDisplay = NULL;
        if (pMessage->Display.Present && pMessage->Display.Contents)
        {
            MultiByteToWideChar(CP_ACP, 0, (const char *)pMessage->Display.Contents, -1,
                szUnicodeDisplay, sizeof(szUnicodeDisplay) / sizeof(szUnicodeDisplay[0]));
            EventData.pszDisplay = szUnicodeDisplay;
        }

        EventData.pszCalledPartyNumber = NULL;
        if (pMessage->CalledPartyNumber.Present && pMessage->CalledPartyNumber.PartyNumberLength)
        {
            

            MultiByteToWideChar(CP_ACP, 0, (const char *)pMessage->CalledPartyNumber.PartyNumbers, -1,
                szUnicodeCalledPartyNumber, sizeof(szUnicodeCalledPartyNumber) / sizeof(szUnicodeCalledPartyNumber[0]));
            EventData.pszCalledPartyNumber = szUnicodeCalledPartyNumber;
        }

        //nikhilb:change for CPR
        if (pMessage->CallingPartyNumber.Present && (pMessage->CallingPartyNumber.Length > 1) )
        {
            if( (EventData.pCallerAliasList == NULL) || 
                (EventData.pCallerAliasList->wCount == 0) || 
                (EventData.pCallerAliasList->pItems == NULL) )
            {
                // Always skip 1st byte in the contents.
                // Skip the 2nd byte if its not an e.164 char (could be the screening indicator byte)

                BYTE* pstrTemp = pMessage->CallingPartyNumber.Contents +
                    ((pMessage->CallingPartyNumber.Contents[1] & 0x80)? 2 : 1);

                MultiByteToWideChar(CP_ACP, 0, (const char *)(pstrTemp), -1,
                    szUnicodeCallingPartyNumber, 
                    sizeof(szUnicodeCallingPartyNumber) / sizeof(szUnicodeCallingPartyNumber[0]));
            
                if( EventData.pCallerAliasList == NULL )
                {
                    EventData.pCallerAliasList = (PCC_ALIASNAMES)malloc( sizeof(CC_ALIASNAMES) );
                }
                
                if( EventData.pCallerAliasList != NULL )
                {
                    EventData.pCallerAliasList->wCount = 1;
                
                    EventData.pCallerAliasList->pItems = (PCC_ALIASITEM)malloc( sizeof(CC_ALIASITEM) );
                    if( EventData.pCallerAliasList->pItems == NULL )
                    {
                        free( EventData.pCallerAliasList );
                        EventData.pCallerAliasList = NULL;
                    }
                    else
                    {
                        ZeroMemory( EventData.pCallerAliasList->pItems, sizeof(CC_ALIASITEM) );
                        EventData.pCallerAliasList->pItems[0].wType = CC_ALIAS_H323_PHONE;
                        EventData.pCallerAliasList->pItems[0].wDataLength = (WORD)wcslen( szUnicodeCallingPartyNumber );
                
                        EventData.pCallerAliasList->pItems[0].pData = 
                            (WCHAR*) malloc( (EventData.pCallerAliasList->pItems[0].wDataLength+1) * sizeof(WCHAR) );
                
                        if( EventData.pCallerAliasList->pItems[0].pData == NULL )
                        {
                            free( EventData.pCallerAliasList->pItems );
                            free( EventData.pCallerAliasList );
                            EventData.pCallerAliasList = NULL;
                        }
                        else
                        {
                            CopyMemory( EventData.pCallerAliasList->pItems[0].pData,
                                szUnicodeCallingPartyNumber, 
                                (EventData.pCallerAliasList->pItems[0].wDataLength+1) * sizeof(WCHAR) );
                        }
                    }
                }
            }
        }


        //nikhilb:change for CPR
        if (pMessage->CalledPartyNumber.Present && (pMessage->CalledPartyNumber.PartyNumberLength > 0) )
        {
            if( (EventData.pCalleeAliasList == NULL) || 
                (EventData.pCalleeAliasList->wCount == 0) || 
                (EventData.pCalleeAliasList->pItems == NULL) )
            {
                MultiByteToWideChar(CP_ACP, 0, (const char *)(pMessage->CalledPartyNumber.PartyNumbers), -1,
                    szUnicodeCalledPartyNumber, sizeof(szUnicodeCalledPartyNumber) / sizeof(szUnicodeCalledPartyNumber[0]));
            
                if( EventData.pCalleeAliasList == NULL )
                {
                    EventData.pCalleeAliasList = (PCC_ALIASNAMES)malloc( sizeof(CC_ALIASNAMES) );
                }
                
                if( EventData.pCalleeAliasList != NULL )
                {
                    EventData.pCalleeAliasList->wCount = 1;
                
                    EventData.pCalleeAliasList->pItems = (PCC_ALIASITEM)malloc( sizeof(CC_ALIASITEM) );
                    if( EventData.pCalleeAliasList->pItems == NULL )
                    {
                        free( EventData.pCalleeAliasList );
                        EventData.pCalleeAliasList = NULL;
                    }
                    else
                    {
                        ZeroMemory( EventData.pCalleeAliasList->pItems, sizeof(CC_ALIASITEM) );
                        EventData.pCalleeAliasList->pItems[0].wType = CC_ALIAS_H323_PHONE;
                        EventData.pCalleeAliasList->pItems[0].wDataLength = (WORD)wcslen( szUnicodeCalledPartyNumber );
                
                        EventData.pCalleeAliasList->pItems[0].pData = 
                            (WCHAR*) malloc( (EventData.pCalleeAliasList->pItems[0].wDataLength+1) * sizeof(WCHAR) );
                
                        if( EventData.pCalleeAliasList->pItems[0].pData == NULL )
                        {
                            free( EventData.pCalleeAliasList->pItems );
                            free( EventData.pCalleeAliasList );
                            EventData.pCalleeAliasList = NULL;
                        }
                        else
                        {
                            CopyMemory( EventData.pCalleeAliasList->pItems[0].pData,
                                szUnicodeCalledPartyNumber, 
                                (EventData.pCalleeAliasList->pItems[0].wDataLength+1) * sizeof(WCHAR) );
                        }
                    }
                }
            }
        }

        EventData.pSourceEndpointType = &(pSetupASN->EndpointType);

        EventData.wCallReference = pMessage->CallReference;

        result = pCallObject->Callback((BYTE)Q931_CALL_INCOMING,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);

    }

	Status = CallObjectValidate(hQ931Call);
	if (Status != CS_OK)
		return Status;

    if (result == 0)
    {
        WORD wCRV = (WORD)(pMessage->CallReference | 0x8000);
        HRESULT Status;

        Status = Q931RingingInternal(pCallObject, wCRV);
        if (Status != CS_OK)
        {
            return Status;
        }
        pCallObject->bCallState = CALLSTATE_RECEIVED;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS Status;
    WORD wCRV;

    if (bQ931Initialized == FALSE)
    {
    	ASSERT(FALSE);
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Entering Q931Ringing()..."));

    // need parameter checking...
    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error (object not found)."));
        return CS_BAD_PARAM;
    }

    if (pwCRV != NULL)
    {
        wCRV = *pwCRV;
    }
    else
    {
        wCRV = pCallObject->wCRV;
    }

    Status = Q931RingingInternal(pCallObject, wCRV);
    if (Status != CS_OK)
    {
        return Status;
    }

    pCallObject->bCallState = CALLSTATE_RECEIVED;
    Status = CallObjectUnlock(pCallObject);

    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallProceeding(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_CALL_PROCEEDING_ASN *pProceedingASN)
{
    pCallObject->bCallState = CALLSTATE_OUTGOING;

    Q931StopTimer(pCallObject, Q931_TIMER_303);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallAlerting(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_ALERTING_ASN *pAlertingASN)
{
    DWORD result;

    pCallObject->bCallState = CALLSTATE_DELIVERED;

    if (pAlertingASN != NULL)
    {
        // we could pass h245addr, userinfo, and conferenceid
        // if desired later...
        // (this would be passed in the pAlertingASN field)
    }

    Q931StopTimer(pCallObject, Q931_TIMER_303);
    Q931StartTimer(pCallObject, Q931_TIMER_301);

    result = pCallObject->Callback((BYTE)Q931_CALL_RINGING,
        pCallObject->hQ931Call, pCallObject->dwListenToken,
        pCallObject->dwUserToken, NULL);

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallConnect(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_CONNECT_ASN *pConnectASN)
{
    DWORD result;

    if ((pMessage->CallReference & 0x8000) == 0)
    {
        // the message came from the caller, so this should be ignored???
    }
    pMessage->CallReference &= ~(0x8000);    // strip off the high bit.

    pCallObject->ConferenceID = pConnectASN->ConferenceID;

    pCallObject->bCallState = CALLSTATE_ACTIVE;

    {
        CSS_CALL_ACCEPTED EventData;
        WCHAR szUnicodeDisplay[CC_MAX_DISPLAY_LENGTH + 1];

        // populate the event data struct.

        EventData.ConferenceID = pCallObject->ConferenceID;

        if (pCallObject->PeerCallAddrPresent)
        {
            EventData.pCalleeAddr = &(pCallObject->PeerCallAddr);
        }
        else
        {
            EventData.pCalleeAddr = NULL;
        }
        EventData.pLocalAddr = &(pCallObject->LocalAddr);

        EventData.pH245Addr = NULL;
        if (pConnectASN->h245AddrPresent)
        {
            EventData.pH245Addr = &(pConnectASN->h245Addr);
        }

        if (!(pConnectASN->NonStandardDataPresent) ||
                (pConnectASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pConnectASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pConnectASN->NonStandardData);
        }

        EventData.pszDisplay = NULL;
        if (pMessage->Display.Present && pMessage->Display.Contents)
        {
            MultiByteToWideChar(CP_ACP, 0, (const char *)pMessage->Display.Contents, -1,
                szUnicodeDisplay, sizeof(szUnicodeDisplay) / sizeof(szUnicodeDisplay[0]));
            EventData.pszDisplay = szUnicodeDisplay;
        }

        EventData.pDestinationEndpointType = &(pConnectASN->EndpointType);

        EventData.wCallReference = pMessage->CallReference;

        Q931StopTimer(pCallObject, Q931_TIMER_303);
        Q931StopTimer(pCallObject, Q931_TIMER_301);

        result = pCallObject->Callback((BYTE)Q931_CALL_ACCEPTED,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallReleaseComplete(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_RELEASE_COMPLETE_ASN *pReleaseCompleteASN)
{
    DWORD result;
    BYTE bCause = 0;

    if (pMessage && pMessage->Cause.Present &&
            (pMessage->Cause.Length >= 3))
    {
        bCause = (BYTE)(pMessage->Cause.Contents[2] & (~CAUSE_EXT_BIT));
    }

    Q931StopTimer(pCallObject, Q931_TIMER_303);
    Q931StopTimer(pCallObject, Q931_TIMER_301);

    // if this is the callee, or the call has been connected already,
    // then this message should be treated as hangup (not reject).
    if (!(pCallObject->fIsCaller) ||
            (pCallObject->bCallState == CALLSTATE_ACTIVE) ||
            (bCause == CAUSE_VALUE_NORMAL_CLEAR))
    {
        CSS_CALL_REMOTE_HANGUP EventData;

        EventData.bReason = CC_REJECT_NORMAL_CALL_CLEARING;
        pCallObject->bCallState = CALLSTATE_NULL;

        result = pCallObject->Callback((BYTE)Q931_CALL_REMOTE_HANGUP,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }
    else
    {
        CSS_CALL_REJECTED EventData;

        pCallObject->bCallState = CALLSTATE_NULL;

        // populate the event data struct.
        switch (bCause)
        {
            case CAUSE_VALUE_NORMAL_CLEAR:
                EventData.bRejectReason = CC_REJECT_NORMAL_CALL_CLEARING;
                break;
            case CAUSE_VALUE_USER_BUSY:
                EventData.bRejectReason = CC_REJECT_USER_BUSY;
                break;
            case CAUSE_VALUE_NO_ANSWER:
                EventData.bRejectReason = CC_REJECT_NO_ANSWER;
                break;
            case CAUSE_VALUE_NOT_IMPLEMENTED:
                EventData.bRejectReason = CC_REJECT_NOT_IMPLEMENTED;
                break;
            case CAUSE_VALUE_INVALID_CRV:
                EventData.bRejectReason = CC_REJECT_INVALID_IE_CONTENTS;
                break;
            case CAUSE_VALUE_IE_MISSING:
                EventData.bRejectReason = CC_REJECT_MANDATORY_IE_MISSING;
                break;
            case CAUSE_VALUE_IE_CONTENTS:
                EventData.bRejectReason = CC_REJECT_INVALID_IE_CONTENTS;
                break;
            case CAUSE_VALUE_TIMER_EXPIRED:
                EventData.bRejectReason = CC_REJECT_TIMER_EXPIRED;
                break;
            default:
                EventData.bRejectReason = pReleaseCompleteASN->bReason;
                break;
        }

        EventData.ConferenceID = pCallObject->ConferenceID;

        EventData.pAlternateAddr = NULL;

        if (!(pReleaseCompleteASN->NonStandardDataPresent) ||
                (pReleaseCompleteASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pReleaseCompleteASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pReleaseCompleteASN->NonStandardData);
        }

        result = pCallObject->Callback((BYTE)Q931_CALL_REJECTED,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallFacility(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    Q931_FACILITY_ASN *pFacilityASN)
{
    DWORD result;

    // if this is the callee, or the call has been connected already,
    // then this message should be treated as hangup (not reject).
    if (!(pCallObject->fIsCaller) ||
            (pCallObject->bCallState == CALLSTATE_ACTIVE))
    {
        CSS_CALL_REMOTE_HANGUP EventData;

        EventData.bReason = pFacilityASN->bReason;
        pCallObject->bCallState = CALLSTATE_NULL;

        result = pCallObject->Callback((BYTE)Q931_CALL_REMOTE_HANGUP,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }
    else
    {
        CSS_CALL_REJECTED EventData;

        pCallObject->bCallState = CALLSTATE_NULL;

        // populate the event data struct.
        EventData.bRejectReason = pFacilityASN->bReason;

        EventData.ConferenceID = pFacilityASN->ConferenceIDPresent ?
            pFacilityASN->ConferenceID : pCallObject->ConferenceID;

        EventData.pAlternateAddr = &(pFacilityASN->AlternativeAddr);

        if (!(pFacilityASN->NonStandardDataPresent) ||
                (pFacilityASN->NonStandardData.sData.wOctetStringLength == 0) ||
                (pFacilityASN->NonStandardData.sData.pOctetString == NULL))
        {
            EventData.pNonStandardData = NULL;
        }
        else
        {
            EventData.pNonStandardData = &(pFacilityASN->NonStandardData);
        }

        result = pCallObject->Callback((BYTE)Q931_CALL_REJECTED,
            pCallObject->hQ931Call, pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendReleaseCompleteMessage(
    P_CALL_OBJECT pCallObject,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData)
{
    CS_STATUS result = CS_OK;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;

    // since this call is going away, mark the call object for deletion so any other 
    // threads attempting to use this object will fail to get a lock on it.
    CallObjectMarkForDelete(hQ931Call);

    if((bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER) ||
            (bRejectReason == CC_REJECT_CALL_FORWARDED) ||
            (bRejectReason == CC_REJECT_ROUTE_TO_MC))
    {
        // send the FACILITY message to the peer to reject the call.
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;
        CC_ADDR AltAddr;

        MakeBinaryADDR(pAlternateAddr, &AltAddr);

        ResultASN = Q931FacilityEncodeASN(pNonStandardData,
            (pAlternateAddr ? &AltAddr : NULL),
            bRejectReason, pConferenceID, NULL, &pCallObject->World,
            &CodedPtrASN, &CodedLengthASN);
        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            Q931DBG((DBGERROR, "Q931FacilityEncodeASN() failed, nothing to send."));
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            result = CS_INTERNAL_ERROR;
        }
        else
        {
            DWORD CodedLengthPDU;
            BYTE *CodedPtrPDU;
            BINARY_STRING UserUserData;
            HRESULT ResultEncode = CS_OK;
            WORD wCRV;
            if (pCallObject->fIsCaller)
            {
                wCRV = (WORD)(pCallObject->wCRV & 0x7FFF);
            }
            else
            {
                wCRV = (WORD)(pCallObject->wCRV | 0x8000);
            }

            UserUserData.length = (WORD)CodedLengthASN;
            UserUserData.ptr = CodedPtrASN;

            ResultEncode = Q931FacilityEncodePDU(wCRV,
                &UserUserData, &CodedPtrPDU, &CodedLengthPDU);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                    (CodedPtrPDU == NULL))
            {
                Q931DBG((DBGERROR, "Q931FacilityEncodePDU() failed, nothing to send."));
                if (CodedPtrPDU != NULL)
                {
                    Free(CodedPtrPDU);
                }
                result = CS_INTERNAL_ERROR;
            }
            else
            {
                result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, FALSE);
            }
        }
    }
    else
    {
        // send the RELEASE COMPLETE message to the peer to reject call.
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;
        BYTE bReasonUU = bRejectReason;
        BYTE *pbReasonUU = &bReasonUU;

        switch (bReasonUU)
        {
            case CC_REJECT_NO_BANDWIDTH:
            case CC_REJECT_GATEKEEPER_RESOURCES:
            case CC_REJECT_UNREACHABLE_DESTINATION:
            case CC_REJECT_DESTINATION_REJECTION:
            case CC_REJECT_INVALID_REVISION:
            case CC_REJECT_NO_PERMISSION:
            case CC_REJECT_UNREACHABLE_GATEKEEPER:
            case CC_REJECT_GATEWAY_RESOURCES:
            case CC_REJECT_BAD_FORMAT_ADDRESS:
            case CC_REJECT_ADAPTIVE_BUSY:
            case CC_REJECT_IN_CONF:
            case CC_REJECT_CALL_DEFLECTION:
            case CC_REJECT_USER_BUSY:
                break;
            default:
                pbReasonUU = NULL;
                break;
        }

        ResultASN = Q931ReleaseCompleteEncodeASN(pNonStandardData,
            pConferenceID, pbReasonUU, &pCallObject->World,
            &CodedPtrASN, &CodedLengthASN);
        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            Q931DBG((DBGERROR, "Q931ReleaseCompleteEncodeASN() failed, nothing to send."));
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            result = CS_INTERNAL_ERROR;
        }
        else
        {
            DWORD CodedLengthPDU;
            BYTE *CodedPtrPDU;
            BINARY_STRING UserUserData;
            HRESULT ResultEncode = CS_OK;
            BYTE bCause = 0;
            BYTE *pbCause = &bCause;
            WORD wCRV;

            if (pCallObject->fIsCaller)
            {
                wCRV = (WORD)(pCallObject->wCRV & 0x7FFF);
            }
            else
            {
                wCRV = (WORD)(pCallObject->wCRV | 0x8000);
            }

            UserUserData.length = (WORD)CodedLengthASN;
            UserUserData.ptr = CodedPtrASN;

            switch (bRejectReason)
            {
                case CC_REJECT_NORMAL_CALL_CLEARING:
                    bCause = CAUSE_VALUE_NORMAL_CLEAR;
                    break;
                case CC_REJECT_USER_BUSY:
                    bCause = CAUSE_VALUE_USER_BUSY;
                    break;
                case CC_REJECT_NO_ANSWER:
                    bCause = CAUSE_VALUE_NO_ANSWER;
                    break;
                case CC_REJECT_NOT_IMPLEMENTED:
                    bCause = CAUSE_VALUE_NOT_IMPLEMENTED;
                    break;
                case CC_REJECT_MANDATORY_IE_MISSING:
                    bCause = CAUSE_VALUE_IE_MISSING;
                    break;
                case CC_REJECT_INVALID_IE_CONTENTS:
                    bCause = CAUSE_VALUE_IE_CONTENTS;
                    break;
                case CC_REJECT_TIMER_EXPIRED:
                    bCause = CAUSE_VALUE_TIMER_EXPIRED;
                    break;
                default:
                    pbCause = NULL;
                    break;
            }

            ResultEncode = Q931ReleaseCompleteEncodePDU(wCRV,
                pbCause, &UserUserData,
                &CodedPtrPDU, &CodedLengthPDU);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                    (CodedPtrPDU == NULL))
            {
                Q931DBG((DBGERROR, "Q931ReleaseCompleteEncodePDU() failed, nothing to send."));
                if (CodedPtrPDU != NULL)
                {
                    Free(CodedPtrPDU);
                }
                result = CS_INTERNAL_ERROR;
            }
            else
            {
                result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, FALSE);
            }
        }
    }

    pCallObject->bCallState = CALLSTATE_NULL;

    if (result != CS_OK)
    {
        return result;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendStatusMessage(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage,
    BYTE bCause)
{
    CS_STATUS result = CS_OK;

    DWORD CodedLengthPDU;
    BYTE *CodedPtrPDU;
    HRESULT EncodePDU = CS_OK;
	int nError = 0;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;
    WORD wCRV;
    if (pCallObject->fIsCaller)
    {
        wCRV = (WORD)(pCallObject->wCRV & 0x7FFF);
    }
	else
	{
        wCRV = (WORD)(pCallObject->wCRV | 0x8000);
	}

    EncodePDU = Q931StatusEncodePDU(wCRV, NULL, bCause,
        pCallObject->bCallState, &CodedPtrPDU, &CodedLengthPDU);
    if ((EncodePDU != CS_OK) || (CodedLengthPDU == 0) ||
            (CodedPtrPDU == NULL))
    {
        Q931DBG((DBGERROR, "Q931StatusEncodePDU() failed, nothing to send."));
        if (CodedPtrPDU != NULL)
        {
            Free(CodedPtrPDU);
        }
        result = CS_INTERNAL_ERROR;
    }
    else
    {
        result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
        if(CallObjectValidate(hQ931Call) != CS_OK)
            return(CS_INTERNAL_ERROR);
    }
    return(result);
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData)
{
    CS_STATUS result = CS_OK;

    DWORD CodedLengthASN;
    BYTE *CodedPtrASN;
    HRESULT ResultASN = CS_OK;
    DWORD dwPhysicalId = INVALID_PHYS_ID;
    P_CALL_OBJECT pCallObject = NULL;


    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error"));
        return CS_SUBSYSTEM_FAILURE;
    }
    dwPhysicalId = pCallObject->dwPhysicalId;

    // first build the ASN portion of the message (user to user part)
    ResultASN = Q931ProceedingEncodeASN(
        pNonStandardData,
        NULL,                          // No H245 address.
        pDestinationEndpointType,      // EndpointType information.
                &pCallObject->World,
        &CodedPtrASN,
        &CodedLengthASN);

    if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
            (CodedPtrASN == NULL))
    {
        Q931DBG((DBGERROR, "Q931ProceedingEncodeASN() failed, nothing to send."));

        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }
        result = CS_INTERNAL_ERROR;
    }
    else
    {
        // now build the rest of the message
        DWORD CodedLengthPDU;
        BYTE *CodedPtrPDU;
        BINARY_STRING UserUserData;
        HRESULT ResultEncode = CS_OK;
        WORD wCRV = (WORD)(wCallReference | 0x8000);

        UserUserData.length = (WORD)CodedLengthASN;
        UserUserData.ptr = CodedPtrASN;

        ResultEncode = Q931ProceedingEncodePDU(wCRV,
            &UserUserData, &CodedPtrPDU, &CodedLengthPDU);
        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }
        if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                (CodedPtrPDU == NULL))
        {
            Q931DBG((DBGERROR, "Q931ProceedingEncodePDU() failed, nothing to send."));
            if (CodedPtrPDU != NULL)
            {
                Free(CodedPtrPDU);
            }
            result = CS_INTERNAL_ERROR;
        }
        else
        {
            result = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);

						if (CallObjectValidate(hQ931Call) != CS_OK)
							return(CS_INTERNAL_ERROR);
        }
    }
    CallObjectUnlock(pCallObject);
    return(result);
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931SendPDU(HQ931CALL hQ931Call, BYTE* CodedPtrPDU, DWORD CodedLengthPDU)
{
    CS_STATUS result = CS_OK;
    HRESULT TempResult;
    P_CALL_OBJECT pCallObject = NULL;

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) ||
            (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error"));
        return CS_SUBSYSTEM_FAILURE;
    }


    TempResult = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);

    if (CallObjectValidate(hQ931Call) != CS_OK)
        return(CS_INTERNAL_ERROR);

    if(FAILED(TempResult))
    {
        CSS_CALL_FAILED EventData;
        EventData.error = TempResult;
        if ((pCallObject->bCallState == CALLSTATE_ACTIVE) &&
                (pCallObject->bResolved))
        {
            pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, NULL);
        }
        else
        {
            pCallObject->Callback(Q931_CALL_FAILED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
        }

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
           DWORD dwId = pCallObject->dwPhysicalId;
           if ((pCallObject->bCallState != CALLSTATE_ACTIVE) ||
                   (!pCallObject->bResolved))
           {
               CallObjectDestroy(pCallObject);
               pCallObject = NULL;
           }
           linkLayerShutdown(dwId);
           if (pCallObject)
           {
               pCallObject->bConnected = FALSE;
           }
        }
        return TempResult;
    }
	CallObjectUnlock(pCallObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931OnCallStatusEnquiry(
    P_CALL_OBJECT pCallObject,
    Q931MESSAGE *pMessage)
{
    CS_STATUS SendStatus;

    SendStatus = Q931SendStatusMessage(pCallObject, pMessage,
        CAUSE_VALUE_ENQUIRY_RESPONSE);

    return SendStatus;
}

//====================================================================================
//====================================================================================
void
Q931SendComplete(DWORD instance, HRESULT msg, PBYTE buf, DWORD length)
{
    HQ931CALL hQ931Call = (HQ931CALL)instance;
    P_CALL_OBJECT pCallObject = NULL;

    Q931DBG((DBGTRACE, "Entering Q931SendComplete()..."));

    if (buf != NULL)
    {
        Free(buf);
    }

    if (FAILED(msg))
    {
        // shut down link layer; report failure to client
        CSS_CALL_FAILED EventData;

        Q931DBG((DBGERROR, "error in datalinkSendRequest()"));

        if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
        {
            Q931DBG((DBGERROR, "CallObjectLock() returned error"));
            return;
        }

        EventData.error = msg;
        if ((pCallObject->bCallState == CALLSTATE_ACTIVE) &&
                (pCallObject->bResolved))
        {
            pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, NULL);
        }
        else
        {
            pCallObject->Callback(Q931_CALL_FAILED,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
        }

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             if ((pCallObject->bCallState != CALLSTATE_ACTIVE) ||
                     (!pCallObject->bResolved))
             {
                 CallObjectDestroy(pCallObject);
                 pCallObject = NULL;
             }
             linkLayerShutdown(dwId);
             if (pCallObject)
             {
                 pCallObject->bConnected = FALSE;
             }
        }
        return;
    }
    return;
}

//====================================================================================
//====================================================================================
static DWORD
PostReceiveBuffer(DWORD dwPhysicalId, BYTE *buf)
{
    if (buf == NULL)
    {
        buf = Malloc(RECEIVE_BUFFER_SIZE);
    }
    return datalinkReceiveRequest(dwPhysicalId, buf, RECEIVE_BUFFER_SIZE);
}

//====================================================================================
//====================================================================================
void
OnReceiveCallback(DWORD instance, HRESULT message, Q931MESSAGE *pMessage, BYTE *buf, DWORD nbytes)
{
    HQ931CALL hQ931Call = (HQ931CALL)instance;
    P_CALL_OBJECT pCallObject = NULL;
    DWORD dwPhysicalId;
    
    Q931DBG((DBGTRACE, "Entering ReceiveCallback()..."));

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        if (buf)
        {
            Free(buf);
        }
        Q931DBG((DBGTRACE, "Call Object no longer available: 0x%08lx", hQ931Call));
        return;
    }

    if (message == LINK_RECV_DATA)
    {
        HRESULT Result = CS_OK;

        if ((buf == NULL) || (nbytes == 0))
        {
            Q931DBG((DBGERROR, "Empty buffer received as data."));
            CallObjectUnlock(pCallObject);
            return;
        }

        // This block is the Q931 call re-connect implementation:
        // if the object related to the incoming message is not yet resolved...
        if (pCallObject->bResolved == FALSE)
        {
            // try to resolve the object.
            HQ931CALL hFoundCallObject;
            P_CALL_OBJECT pFoundCallObject = NULL;

            // If found another object with matching CRV/Addr...
            if (CallObjectFind(&hFoundCallObject, pCallObject->wCRV,
                    &(pCallObject->PeerConnectAddr)) &&
                    ((CallObjectLock(hFoundCallObject, &pFoundCallObject) == CS_OK) &&
                    (pFoundCallObject != NULL)))
            {
                // friendly channel close of the pFoundCallObject.
                Q931SendReleaseCompleteMessage(pFoundCallObject,
                    CC_REJECT_UNDEFINED_REASON, &(pFoundCallObject->ConferenceID), NULL, NULL);

                // unlock the call object before calling shutdown
                CallObjectUnlock(pFoundCallObject);
                
                linkLayerShutdown(pFoundCallObject->dwPhysicalId);

                if((CallObjectLock(hFoundCallObject, &pFoundCallObject) != CS_OK) ||
                  (pFoundCallObject == NULL))
                  return;

                // assign the new dwPhysicalId to found object.
                pFoundCallObject->dwPhysicalId = pCallObject->dwPhysicalId;

                // new object should be destroyed.
                CallObjectDestroy(pCallObject);
                pCallObject = pFoundCallObject;
            }
            else
            {
                // The call is a newly established call, so resolve it now.
                pCallObject->bResolved = TRUE;
            }
        }

        Result = Q931ParseMessage((BYTE *)buf, nbytes, pMessage);

#if (defined(_DEBUG) && defined(PCS_COMPLIANCE))
        InteropOutput(Q931Logger, buf, nbytes, Q931LOG_RECEIVED_PDU);
#endif

	// A message is to be ignored (per 5.8.1 and 5.8.2) if:
	//		- protocol discriminator is not recognized 
	//		- message is too short to contain a complete message
	//		  type information element
        if (   Result != CS_OK
			&& Result != CS_MESSAGE_TOO_SHORT
			&& Result != CS_INVALID_PROTOCOL)
		{
            Result = Q931SendStatusMessage(pCallObject, pMessage,
                CAUSE_VALUE_INVALID_MSG);

            Q931DBG((DBGERROR, "Q931ParseMessage(): failed."));

            if(CallObjectValidate(hQ931Call) != CS_OK) 
            {
			        if (buf)
			        {
			            Free(buf);
			        }
              return;
            }

            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectUnlock(pCallObject);
            PostReceiveBuffer(dwPhysicalId, buf);
            return;
        }

        if (pMessage->Shift.Present)
        {
            Q931DBG((DBGERROR, "Shift present in message:  dropped."));
            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectUnlock(pCallObject);
            PostReceiveBuffer(dwPhysicalId, buf);
            return;
        }

        // If a hooking procedure has been installed,
        // give it first shot at acting on the received PDU.
        // If it returns TRUE, then processing is finished.
        if (gReceivePDUHookProc)
        {
            BOOL bHookProcessedMessage;
        
            bHookProcessedMessage = gReceivePDUHookProc(pMessage,
                pCallObject->hQ931Call, pCallObject->dwListenToken,
                pCallObject->dwUserToken);
        
            if (bHookProcessedMessage)
            {
                if (CallObjectValidate(hQ931Call) == CS_OK)
                {
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                }
                return;
            }
        }

        // Message now contains the values of the Q931 PDU elements...
        switch (pMessage->MessageType)
        {
        case SETUPMESSAGETYPE:
            {
                Q931_SETUP_ASN SetupASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Message is missing ASN.1 UserUser data..."));
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                Q931DBG((DBGTRACE, "ReceiveCallback(): received Setup message..."));
                Result = Q931SetupParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &SetupASN);
                if (Result == CS_OPTION_NOT_IMPLEMENTED)
                {
                    //... maybe callback callcont in later drop.
  
                    // initiate a disconnect sequence from the caller side.
                    if (Q931SendReleaseCompleteMessage(pCallObject,
                            CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) != CS_OK)
                    {
             