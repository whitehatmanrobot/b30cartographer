 currently exist)" );
    }
    
    dprintf( "\n\t\t      NewSize : 0x%I64x", ReadField (NewSize));
    
    if (ReadField (NewSize) == -1) {
        dprintf( " (will be deleted)" );
    }
    dprintf("\n");

}

VOID
DumpXDirectory(
    ULONG64 pxdir,
    ULONG64 mask
    )
{
    ULONG64 pst;
    DWORD i;
    ULONG64 offset;
    ULONG64 stdata = 0,pextradata = 0;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    //PXFILE pxf;
    ULONG64 node = 0, boffset = 0, count = 0;
    WCHAR Buffer [200];
    ULONG64 pxf = 0;

    if ((mask & 2) == 0 ) {
        return;
    }

    InitTypeRead (pxdir, SETUPAPI!XDIRECTORY);

    dprintf( "\t\t   ***XDIRECTORY structure***\n");
    dprintf( "\t\t    SpaceRequired : 0x%x\n", ReadField (SpaceRequired));
    dprintf( "\t\t    FilesTable : 08%08x\n", ReadField (FilesTable));
    
    pst = ReadField (FilesTable);
    
    DumpStringTableHeader (pst);
    stdata = GetStringTableData (pst);
    
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pxf = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpXFile(pxf, mask );
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

}

VOID
DumpXDrive(
    ULONG64 pxd,
    ULONG64 mask
    )
{
    DWORD i;
    ULONG64 offset = 0;
    ULONG64 stdata = 0, pextradata = 0, pst = 0;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    //PXDIRECTORY pxdir;
    ULONG64 node = 0, pxdir = 0, boffset = 0, count = 0;
    WCHAR Buffer [200];

    if ((mask & 1) == 0) {
        return;
    }

    InitTypeRead (pxd, SETUPAPI!XDRIVE);
    
    dprintf( "\t\t***XDRIVE structure***\n");
    dprintf( "\t\t SpaceRequired : 0x%I64x\n", ReadField (SpaceRequired));
    dprintf( "\t\t BytesPerCluster : 0x%I64x\n", ReadField (BytesPerCluster));
    dprintf( "\t\t Slop : 0x%I64x\n", ReadField (Slop));
    dprintf( "\t\t DirsTable : 0x%016I64x\n", ReadField (DirsTable));

    pst = ReadField (DirsTable);
    
    DumpStringTableHeader (pst);
    
    stdata = GetStringTableData(pst );

    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pxdir = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpXDirectory(pxdir, mask );
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

}

VOID
DumpInfVersionNode(
    ULONG64 ver
    )
{
    WCHAR Buffer[200];
    
    InitTypeRead (ver, SETUPAPI!INF_VERSION_NODE);

    dprintf("***INF_VERSION_NODE***\n");
    dprintf("\t  FilenameSize : 0x%x\n", ReadField (FilenameSize));
    dprintf("\t  DataBlock : 0x%x\n", ReadField (DataBlock));
    dprintf("\t  DataSize : 0x%x\n", ReadField (DataSize));
    dprintf("\t  DatumCount : 0x%x\n", ReadField (DatumCount));
    
    UtilGetWStringField (ver, "SETUPAPI!INF_VERSION_NODE", "Filename", Buffer, sizeof (Buffer));
    dprintf("\t  Filename : %ws\n", Buffer);

    return;
}

VOID
DumpInfLine(
    ULONG64 line,
    ULONG64 valuedata
    )
{
    DWORD i;
    ULONG64 ptr = 0;
    ULONG64 data = 0;
    ULONG ulongptrsize = GetTypeSize ("SETUPAPI!ULONG_PTR");

    InitTypeRead (line, SETUPAPI!INF_LINE);

    dprintf("\t  ValueCount : 0x%I64x\n", ReadField (ValueCount));
    dprintf("\t  Flags : 0x%I64x\n", ReadField (Flags));
    dprintf("\t  Values : 0x%I64x\n", ReadField (Values));

    if (ReadField (Flags) > 3) {
        return;
    }

    for (i = 0; i< ReadField (ValueCount); i++) {
        ptr = valuedata + (ReadField (Values) * ulongptrsize) + (i * ulongptrsize);
        ReadMemory (ptr, &data, ulongptrsize, NULL);
        
        dprintf("\t data [%ld] : 0x%I64x [0x%I64x]\n", i, ptr, data);

        if (CheckInterupted()) {
            return;
        }
    }
}

VOID
DumpInfSection(
    ULONG64 section,
    ULONG64 linedata,
    ULONG64 valuedata
    )
{
    DWORD i;
    //INF_LINE line;
    ULONG64 line;
    ULONG64 data;

    InitTypeRead (section, SETUPAPI!INF_SECTION);

    dprintf("***INF_SECTION***\n");
    dprintf("\t  SectionName : 0x%I64x\n", ReadField (SectionName));
    dprintf("\t  LineCount : 0x%I64x\n", ReadField (LineCount));
    dprintf("\t  Lines : 0x%I64x\n", ReadField (Lines));

    for (i = 0; i< ReadField (LineCount); i++) {

        data = linedata + (GetTypeSize ("SETUPAPI!INF_LINE") * ReadField (Lines)) + GetTypeSize ("SETUPAPI!INF_LINE") * i;
        dprintf("***INF_LINE [%ld] at 0x%I64x***\n", i, data);

        DumpInfLine (data, valuedata);
        
        //
        // Have to reinit type read because of DumpInfLine
        //
        
        InitTypeRead (section, SETUPAPI!INF_SECTION);

        if (CheckInterupted()) {
            return;
        }
    }
}


VOID
DumpStringTableHeader(
    ULONG64 st
    )
{
    //
    // dump the string table header
    //

    InitTypeRead (st, SETUPAPI!STRING_TABLE);

    dprintf("\tBase Data ptr:\t0x%016I64x\n",  ReadField (Data));
    dprintf("\tDataSize:\t0x%016I64x\n",       ReadField (DataSize));
    dprintf("\tBufferSize:\t0x%016I64x\n",     ReadField (BufferSize));
    dprintf("\tExtraDataSize:\t0x%016I64x\n",  ReadField (ExtraDataSize));

}

ULONG64
GetStringTableData(
    ULONG64 st
    )
{   
    InitTypeRead (st, SETUPAPI!STRING_TABLE);
    return ReadField (Data);
}

ULONG64
GetFirstNode(
    ULONG64 stdata,
    ULONG64 offset,
    PULONG64 poffset
    )
{
    ULONG64 NodeAddress = 0;
    
    ReadPtr (offset, &NodeAddress);
    *poffset = NodeAddress;
    
    if (NodeAddress == -1) {
        return 0;
    }

    return NodeAddress + stdata;

}

ULONG64
GetNextNode(
    ULONG64 stdata,
    ULONG64 node,
    PULONG64 offset
    )
{
    ULONG64 next, nextoffset;

    //
    // BUG BUG: Hack for ptr - STRING_NODEW is not built into any file
    // so I will cheat because I know that the offset is the first entry
    //

    ReadPtr (node, &nextoffset);
    
    if (nextoffset == -1) {
        *offset = 0;
        return 0;
    }

    next = stdata + nextoffset;
    *offset = nextoffset;

    return next;

}

BOOL
CheckInterupted(
    VOID
    )
{
    if ( CheckControlC() ) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
    }
    return FALSE;
}

LPCSTR
GetWizPage(
    DWORD i
    )
{
    LPCSTR  WizPage[] = {
        "WizPagesWelcome",        // welcome page
        "WizPagesMode",           // setup mode page
        "WizPagesEarly",          // pages that come after the mode page and before prenet pages
        "WizPagesPrenet",         // pages that come before network setup
        "WizPagesPostnet",        // pages that come after network setup
        "WizPagesLate",           // pages that come after postnet pages and before the final page
        "WizPagesFinal",          // final page
        "WizPagesTypeMax"
    };

    return WizPage[i];

}

VOID
DumpOcComponent(
    ULONG64 offset,
    ULONG64 node,
    ULONG64 pcomp
    )
{
    DWORD i;
    ULONG count;
    WCHAR Buffer[200];

    UtilReadWString (node + GetTypeSize ("SETUPAPI!ULONG_PTR"),
                     Buffer,
                     sizeof (Buffer));

    InitTypeRead (pcomp, OCMANAGE!OPTIONAL_COMPONENT);

    dprintf("OC_COMPONENT Data for node %ws : 0x%p\n", Buffer, offset );
    dprintf( "\t InfStringId:\t\t0x%016I64x\n", ReadField (InfStringId));
    dprintf( "\t TopLevelStringId:\t0x%016I64x\n", ReadField (TopLevelStringId));
    dprintf( "\t ParentStringId:\t0x%016I64x\n", ReadField (ParentStringId));
    dprintf( "\t FirstChildStringId:\t0x%016I64x\n", ReadField (FirstChildStringId));
    dprintf( "\t ChildrenCount:\t\t0x%016I64x\n", ReadField (ChildrenCount));
    dprintf( "\t NextSiblingStringId:\t0x%016I64x\n", ReadField (NextSiblingStringId));
    dprintf( "\t NeedsCount:\t\t%d\n", ReadField (NeedsCount));
    
    if (ReadField (NeedsCount)) {
        // read and dump needs list
        for (i = 0; i < ReadField (NeedsCount); i++) {
            ReadMemory(ReadField (NeedsStringIds) + (i * sizeof (ULONG)), &count, sizeof (count), NULL);
            dprintf("\t NeedsStringIds #%d:\t0x%08x\n", i, count);
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t NeededByCount:\t\t%d\n", ReadField (NeededByCount));
    
    if (ReadField (NeededByCount)) {
        // read and dump needs list
        
        for (i = 0; i < ReadField (NeededByCount); i++) {
            ReadMemory(ReadField (NeededByStringIds) + (i * sizeof (ULONG)), &count, sizeof (count), NULL);
            dprintf("\t NeededByStringIds #%d: 0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t ExcludeCount:\t\t%d\n", ReadField (ExcludeCount));
    
    if (ReadField (ExcludeCount)) {

        // read and dump Excludes list
        
        for (i = 0; i < ReadField (ExcludeCount); i++) {
            
            ReadMemory(ReadField (ExcludeStringIds) + (i * sizeof (ULONG)), &count, sizeof (ULONG), NULL);
            
            dprintf("\t ExcludeStringIds #%d: 0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t ExcludedByCount:\t%d\n", ReadField (ExcludedByCount));
    
    if (ReadField (ExcludedByCount)) {

        // read and dump Excludes list
        
        for (i = 0; i < ReadField (ExcludedByCount); i++) {

            ReadMemory(ReadField (ExcludedByStringIds) + (i * sizeof (ULONG)), &count, sizeof (ULONG), NULL);
            dprintf("\t ExcludesStringIds #%d:\t0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t InternalFlags:\t\t0x%08x\n", ReadField (InternalFlags));
    
    //
    // bugbug correct identifier
    //
    dprintf( "\t SizeApproximation:\t0x%016I64x\n", ReadField (SizeApproximation));
    dprintf( "\t IconIndex:\t\t0x%016I64x\n", ReadField (IconIndex));
    
    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "IconDll", Buffer, sizeof (Buffer));
    dprintf( "\t IconDll:\t\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "IconResource", Buffer, sizeof (Buffer));
    dprintf( "\t IconResource:\t\t%ws\n", Buffer);

    dprintf( "\t SelectionState:\t0x%016I64x\n", ReadField (SelectionState));
    dprintf( "\t OriginalSelectionState:0x%016I64x\n", ReadField (OriginalSelectionState));
    dprintf( "\t InstalledState:\t0x%016I64x\n", ReadField (InstalledState));
    dprintf( "\t ModeBits:\t\t0x%08x\n", ReadField (ModeBits));

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "Description", Buffer, sizeof (Buffer));
    dprintf( "\t Description:\t\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "Tip", Buffer, sizeof (Buffer));
    dprintf( "\t Tip:\t\t\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "InstallationDllName", Buffer, sizeof (Buffer));
    dprintf( "\t InstallationDllName:\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "InterfaceFunctionName", Buffer, sizeof (Buffer));
    dprintf( "\t InterfaceFunctionName:\t%s\n", Buffer);
    
    dprintf( "\t InstallationDll:\t0x%016I64x\n", ReadField (InstallationDll));
    dprintf( "\t ExpectedVersion:\t0x%016I64x\n", ReadField (ExpectedVersion));
    dprintf( "\t Exists:\t\t0x%016I64x\n", ReadField (Exists));
    dprintf( "\t Flags:\t\t\t0x%016I64x\n\n\n", ReadField (Flags));

    return;
}

DECLARE_API( setuphelp )
{
    dprintf("setupexts help:\n\n");
    dprintf("!setuphelp                   - This message\n");
    dprintf("!ocm [address] [opt. flag]   - Dump the OC_MANAGER structure at address, flag increased verbosity\n");
    dprintf("!space [address] [opt. flag] - Dump the DISK_SPACE_LIST structure at specified address\n");
    dprintf("!st  [address]               - Dump the contents of a STRING_TABLE structure at specified address\n");
    dprintf("!stfind [address] [element]  - Dump the specified string table element\n");
    dprintf("!queue [address] [opt. flag] - Dump the specified file queue\n");
    dprintf("!qcontext [address]          - Dump the specified default queue context \n");
    dprintf("!infdump [addr] [opt. flag]  - Dump the specified hinf \n");
    
}

DECLARE_API( st )
/*++

Routine Description:

    This debugger extension dumps a string table at the address specified.

Arguments:


Return Value:

--*/
{
    ULONG64 pst;
    DWORD i;
    ULONG64 offset;
    ULONG64 pextradata;
    ULONG64 stdata;
    WCHAR Buffer[200];
    ULONG64 boffset, node;
    ULONG count = 0;
    
    if (args==0) {

        dprintf ("st: no string table specified.\n");
        return;
    }

    ZeroMemory (&Buffer, sizeof (Buffer));
    
    pst = UtilStringToUlong64 ((UCHAR *)args);
    dprintf("Base String Table Address:\t0x%p\n", pst);
    DumpStringTableHeader(pst);
    stdata = GetStringTableData(pst);
    
    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                //
                // BUG BUG: Hack for offset - STRING_NODEW is not built into any file
                // so I will cheat because I know that the offset is after a ptr
                //

                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );
                        
                node = GetNextNode(stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
}

DECLARE_API( stfind )
/*++

Routine Description:

    This debugger extension dumps the data for a given string table number

Arguments:


Return Value:

--*/

{
    ULONG64 pst, element, stdata, boffset;
    DWORD i;
    ULONG64 offset;
    ULONG64 pextradata;
    ULONG64 node;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG64 count = 0, argcount = 0;
    PUCHAR argptr = (PUCHAR) args;
    
    ZeroMemory (&arg, sizeof (arg));
    ZeroMemory (&Buffer, sizeof (Buffer));
    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0] || !arg[1][0]) {

        dprintf ("stfind: missing one or more parameters\nusage:!stfind [address] [element]\n");
        return;
    }

    pst = UtilStringToUlong64 (arg[0]);
    element = UtilStringToUlong64 (arg[1]);
    
    stdata = GetStringTableData(pst);

    if (!stdata) {
        dprintf("Error retrieving string table data!\n");
        return;
    }
    
    //
    // search each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );
        if (!node) {

        } else {

            while (node) {
                if (element == offset) {
                    //
                    // BUG BUG: Hack for offset - STRING_NODEW is not built into any file
                    // so I will cheat because I know that the offset is after a ptr
                    //
    
                    boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                    count = 0;
                    
                    while (1)
                    {
                        
                        if (count == sizeof (Buffer)) {
                            break;
                        }
                        
                        ReadMemory (node + boffset + count,
                                    (PWCHAR) &Buffer + count/2,
                                    sizeof (WCHAR),
                                    NULL);
    
                        if (!Buffer[count/2]) {
                            break;
                        }
                        
                        count +=2;
                    }
                    dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                    InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                    pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                    dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );
                    return;
                }

                node = GetNextNode( stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    
    dprintf("Couldn't find element\n");

}


DECLARE_API( ocm )
/*++

Routine Description:

    This debugger extension dumps an OC_MANAGER (UNICODE!) structure at the specified address

Arguments:


Return Value:

--*/
{
    ULONG64 pocm;
    DWORD i;
    ULONG64 infdata,compdata;
    ULONG64 Mask = 0;
    LONG count = 0;
    UCHAR arg[2][100];
    PUCHAR argptr = (PUCHAR) args;
    ULONG64 offset = 0;
    WCHAR Buffer[200];
    ULONG argcount = 0;
    ULONG64 node = 0, boffset = 0;
    
    ZeroMemory (&arg, sizeof (arg));
    
    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("ocm: missing one or more parameters\nusage:!ocm [address] [verbosity]\n");
        return;
    }
    
    pocm = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);
    
    InitTypeRead (pocm, OCMANAGE!OC_MANAGER);

    //
    // dump the OCM structure
    //
    dprintf("OC_MANAGER structure at Address:\t0x%016I64x\n", pocm);
    
    dprintf("\tCallbacks :\n");
    dprintf("\t\tFillInSetupDataA:\t0x%016I64x\n", ReadField (Callbacks.FillInSetupDataA));
    dprintf("\t\tLogError:\t\t0x%016I64x\n", ReadField (Callbacks.LogError));
    dprintf("\t\tSetReboot:\t\t0x%016I64x\n", ReadField (Callbacks.SetReboot));
    dprintf("\t\tFillInSetupDataW:\t0x%016I64x\n", ReadField (Callbacks.FillInSetupDataW));

    dprintf("\tMasterOcInf:\t\t0x%016I64x\n", ReadField (MasterOcInf));
    dprintf("\tUnattendedInf:\t\t0x%016I64x\n", ReadField (UnattendedInf));
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "MasterOcInfPath", Buffer, sizeof (Buffer));
    dprintf("\tMasterOcInfPath:\t%ws\n", Buffer);
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "UnattendedInfPath", Buffer, sizeof (Buffer));
    dprintf("\tUnattendInfPath:\t%ws\n",  Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SourceDir", Buffer, sizeof (Buffer));
    dprintf("\tSourceDir:\t\t%ws\n", Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SuiteName", Buffer, sizeof (Buffer));
    dprintf("\tSuiteName:\t\t%ws\n", Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SetupPageTitle", Buffer, sizeof (Buffer));
    dprintf("\tSetupPageTitle:\t\t%ws\n", Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "WindowTitle", Buffer, sizeof (Buffer));
    dprintf("\tWindowTitle:\t\t%ws\n", Buffer);

    dprintf("\tInfListStringTable:\t0x%016I64x\n", ReadField (InfListStringTable));
    dprintf("\tComponentStringTable:\t0x%016I64x\n", ReadField (ComponentStringTable));
    dprintf("\tOcSetupPage:\t\t0x%016I64x\n", ReadField (OcSetupPage));
    dprintf("\tSetupMode:\t\t%d\n", ReadField (SetupMode));
    
    dprintf("\tTopLevelOcCount:\t%d\n", ReadField (TopLevelOcCount));
    
    if (ReadField (TopLevelOcCount)) {
        
        // read and dump needs list

        for (i = 0; i < ReadField (TopLevelOcCount); i++) {

            //
            // BUG BUG - No way to read size of String Ids off target, so assume LONG
            //

            ReadMemory(ReadField (TopLevelOcStringIds) + (i * sizeof (LONG)), &count, sizeof (count), NULL);
            dprintf("\t TopLevelOcStringIds #%d:\t0x%08x\n", i, count);

            if (CheckInterupted()) {
                return;
            }
        }
    }
    
    dprintf("\tTopLevelParenOcCount:\t%d\n", ReadField (TopLevelParentOcCount));
    
    if (ReadField (TopLevelParentOcCount)) {
        
        // read and dump needs list
        
        for (i = 0; i < ReadField (TopLevelParentOcCount); i++) {

            //
            // BUG BUG - No way to read size of String Ids off target, so assume LONG
            //

            ReadMemory(ReadField (TopLevelParentOcStringIds) + (i * sizeof (LONG)), &count, sizeof (count), NULL);
            dprintf("\t TopLevelParentOcStringIds #%d:\t0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf("\tSubComponentsPresent:\t%d\n", ReadField (SubComponentsPresent));

    //
    // BugBug WizardPagesOrder there's not really any way to tell the exact upper bound of
    // each array, though we know that it's <= TopLevelParentOcCount...since this is the case
    // we just dump the point to each array of pages...
    //
     
    for (i = 0; i < WizPagesTypeMax; i++) {
        
        ULONG wizardpageorder = 0;

        //
        // BUG BUG - Again, assuming that this type will always be ULONG
        //

        GetFieldOffset ("OCMANAGE!OC_MANAGER", "WizardPagesOrder", (PULONG) &offset);
        
        ReadMemory (pocm + offset + (i * sizeof (ULONG)), &wizardpageorder, sizeof (ULONG), NULL);
        
        dprintf("\tWizardPagesOrder[%i] (%s)\t: 0x%08x\n",
                i,
                GetWizPage(i),
                wizardpageorder);
        
        if (CheckInterupted()) {
                return;
            }
    }

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "PrivateDataSubkey", Buffer, sizeof (Buffer));
    dprintf("\tPrivateDataSubkey:\t\t%ws\n", Buffer);

    dprintf("\thKeyPrivateData:\t\t0x%016I64x\n", ReadField (hKeyPrivateData));
    dprintf("\thKeyPrivateDataRoot:\t\t0x%016I64x\n", ReadField (hKeyPrivateDataRoot));
    dprintf("\tProgressTextWindow:\t\t0x%016I64x\n", ReadField (ProgressTextWindow));
    dprintf("\tCurrentComponentStringId:\t0x%016I64x\n", ReadField(CurrentComponentStringId));
    dprintf("\tAbortedCount:\t\t%d\n", ReadField (AbortedCount));
    
    if (ReadField (AbortedCount)) {
        
        // read and dump needs list
        
        for (i = 0; i < ReadField (AbortedCount); i++) {

            ReadMemory(ReadField (AbortedComponentIds) + (i * sizeof (LONG)), &count, sizeof(count), NULL);

            dprintf("\t AbortedComponentIds #%d:\t0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf("\tInternalFlags:\t\t0x%016I64x\n\n\n", ReadField (InternalFlags));

    dprintf("\tSetupData.SetupMode :\t\t0x%016I64x\n", ReadField (SetupData.SetupMode));
    dprintf("\tSetupData.ProductType :\t\t0x%016I64x\n", ReadField (SetupData.ProductType));
    dprintf("\tSetupData.OperationFlags :\t0x%016I64x\n", ReadField (SetupData.OperationFlags));
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SetupData.SourcePath", Buffer, sizeof (Buffer));
    dprintf("\tSetupData.SourcePath :\t\t%ws\n", Buffer);
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SetupData.UnattendFile", Buffer, sizeof (Buffer));
    dprintf("\tSetupData.UnattendFile :\t\t%ws\n", Buffer);

    //
    // Verbose print
    //
    
    if ((Mask&1) && ReadField (InfListStringTable)) {
        ULONG64 pinfdata = 0;

        dprintf("\t\t***InfListStringTable***\n");
        
        pinfdata = GetStringTableData( ReadField (InfListStringTable));
        
        if (!pinfdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        // now, dump each node with data in the string table
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            
            node = GetFirstNode(pinfdata, (pinfdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset);
            
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    ULONG64 pocinf = 0;
                    //dprintf("\tNode Name:%ws\n", node->String);
                    
                    UtilReadWString (node + GetTypeSize ("SETUPAPI!ULONG_PTR"),
                                     Buffer,
                                     sizeof (Buffer)
                                     );

                    boffset = wcslen (Buffer) * sizeof (WCHAR);

                    ReadPtr (node + GetTypeSize ("SETUPAPI!ULONG_PTR") + boffset + 1,
                             &pocinf);

                    pocinf = node + GetTypeSize ("SETUPAPI!ULONG_PTR") + boffset + 2;
                    
                    if (pocinf) {
                        
                        InitTypeRead (pocinf, OCMANAGE!OC_INF);
                        
                        dprintf("\tNode Data for %ws\t (0x%08x): 0x%016I64x\n",
                                Buffer,
                                offset,
                                ReadField (Handle)
                                );
                    } else {
                        dprintf("\tNo Node Data for %ws\n",
                                Buffer
                                );
                    }
                    node = GetNextNode(pinfdata, node, &offset );

                    if (CheckInterupted()) {
                        return;
                    }
                }
            }
        }
        dprintf("\n\n");
    }

    InitTypeRead (pocm, OCMANAGE!OC_MANAGER);
    
    if ((Mask&1) && ReadField (ComponentStringTable)) {
        ULONG64 compdata = 0;

        dprintf("\t\t***ComponentStringTable***\n");
        
        compdata = GetStringTableData(ReadField (ComponentStringTable));
        
        if (!compdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // dump each node with data in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(compdata, (compdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset);

            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    ULONG64 pcomp = 0;
                    //dprintf("\tNode Name:%ws\n", node->String);
                    
                    UtilReadWString (node + GetTypeSize ("SETUPAPI!ULONG_PTR"),
                                     Buffer,
                                     sizeof (Buffer)
                                     );

                    boffset = wcslen (Buffer) * sizeof (WCHAR);
                    
                    pcomp = node + GetTypeSize ("SETUPAPI!ULONG_PTR") + boffset + 2;
                    
                    if (pcomp) {
                        
                        DumpOcComponent( offset , node, pcomp );
                    
                    } else {

                        dprintf("\tNo Node Data for %ws\n",
                                Buffer
                                );
                    }

                    if (CheckInterupted()) {
                       return;
                    }

                    node = GetNextNode( compdata, node, &offset );
                }
            }
        }
    }

    return;
}

DECLARE_API( infdump )
/*++

Routine Description:

    This debugger extension dumps the data related to an HINF  structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    ULONG64 pinf;
    //LOADED_INF inf;
    //INF_SECTION InfSection;
    //INF_LINE InfLine;
    DWORD i;
    ULONG64 offset = 0, count = 0;
    ULONG64 stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;
    ULONG64 node = 0, boffset = 0, pst = 0;
    ULONG64 Mask = 0;
    
    ZeroMemory (&arg, sizeof (arg));
    
    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("infdump: missing one or more parameters\nusage:!infdump [address] [verbosity]\n");
        return;
    }
    
    pinf = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);
    
    InitTypeRead (pinf, SETUPAPI!LOADED_INF);

    count = ReadField (Signature);
    
    dprintf("LOADED_INF at :\t0x%016I64x\n", pinf);
    dprintf("\t Signature : 0x%08x (%s)\n", (ULONG) count, ((count == LOADED_INF_SIG) ? "Valid" : "Invalid"));
    
    if (ReadField (Signature) != LOADED_INF_SIG) {
        return;
    }

    dprintf("\t FileHandle:\t0x%016I64x\n", ReadField (FileHandle));
    dprintf("\t MappingHandle:\t0x%016I64x\n", ReadField (MappingHandle));
    dprintf("\t ViewAddress:\t0x%016I64x\n", ReadField (ViewAddress));

    if (ReadField (FileHandle) == (ULONG64) INVALID_HANDLE_VALUE) {
        dprintf(" *** In memory INF ***\n" );
    } else {
        dprintf(" *** PNF ***\n" );
    }

    dprintf("\t StringTable:\t0x%016I64x\n", ReadField (StringTable));
    dprintf("\t SectionCount:\t0x%016I64x\n", ReadField (SectionCount));

    dprintf("\tSectionBlock:\t0x%016I64x\n", ReadField (SectionBlock));

    for (i = 0; i < ReadField (SectionCount); i++) {

        dprintf("***INF_SECTION [%d] at 0x%016I64x***\n",i, ReadField (SectionBlock) + (GetTypeSize ("SETUPAPI!INF_SECTION") * i));
        DumpInfSection( ReadField (SectionBlock) + (GetTypeSize ("SETUPAPI!INF_SECTION") * i), ReadField (LineBlock), ReadField (ValueBlock));

        //
        // Need to reinit type read because previous functions change the
        // default read structure type
        //
        
        InitTypeRead (pinf, SETUPAPI!LOADED_INF);

        if (CheckInterupted()) {
            return;
        }
    }

    dprintf("\tLineBlock : 0x%I64x\n", ReadField (LineBlock));
    dprintf("\t ValueBlock : 0x%I64x\n", ReadField (ValueBlock));

    DumpInfVersionNode(ReadField (VersionBlock));

    InitTypeRead (pinf, SETUPAPI!LOADED_INF);

    dprintf("\t HasStrings : 0x%I64x\n", ReadField (HasStrings));

    UtilGetWStringField (pinf, "SETUPAPI!LOADED_INF", "OsLoaderPath", Buffer, sizeof (Buffer));
    dprintf("\t OsLoaderPath : %ws\n", Buffer);

    dprintf("\t InfSourceMediaType : 0x%I64x ( ", ReadField (InfSourceMediaType));
    
    if (ReadField (InfSourceMediaType)) {
        if (ReadField (InfSourceMediaType) & SPOST_PATH ) {
            dprintf("SPOST_PATH ");
        }
        if (ReadField (InfSourceMediaType) & SPOST_URL) {
            dprintf("SPOST_URL ");
        }
    } else {
        dprintf("SPOST_NONE ");
    }

    dprintf(")\n");

    UtilGetWStringField (pinf, "SETUPAPI!LOADED_INF", "InfSourcePath", Buffer, sizeof (Buffer));
    dprintf("\t InfSourcePath : %ws\n", Buffer);

    UtilGetWStringField (pinf, "SETUPAPI!LOADED_INF", "OriginalInfName", Buffer, sizeof (Buffer));
    dprintf("\t OriginalInfName : %ws\n", Buffer);
    dprintf("\t SubstValueList : 0x%I64x\n", ReadField (SubstValueList));
    dprintf("\t SubstValueCount : 0x%I64x\n", ReadField (SubstValueCount));
    dprintf("\t Style : 0x%x ( ", ReadField (Style));

    if (ReadField (Style) & INF_STYLE_OLDNT) {
        dprintf("INF_STYLE_OLDNT ");
    }
    if (ReadField (Style) & INF_STYLE_WIN4) {
        dprintf("INF_STYLE_WIN4 ");
    }

    dprintf(")\n");

    dprintf("\t SectionBlockSizeBytes : 0x%x\n", ReadField (SectionBlockSizeBytes));
    dprintf("\t LineBlockSizeBytes : 0x%x\n", ReadField (LineBlockSizeBytes));
    dprintf("\t ValueBlockSizeBytes : 0x%x\n", ReadField (ValueBlockSizeBytes));
    dprintf("\t LanguageId : 0x%x\n", ReadField (LanguageId));

    dprintf("\t UserDirIdList : 0x%x\n", ReadField (UserDirIdList));
    dprintf("\tLock[0] : 0x%x\n", ReadField (Lock.handles[0]));
    dprintf("\tLock[1] : 0x%x\n", ReadField (Lock.handles[1]));

    dprintf("\tPrev : 0x%x\n", ReadField (Prev));
    dprintf("\tNext : 0x%x\n", ReadField (Next));
    
    pst = ReadField (StringTable);
    
    DumpStringTableHeader (pst);
                                
    stdata = GetStringTableData (pst);
    
    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                //
                // BUG BUG: Hack for offset - STRING_NODEW is not built into any file
                // so I will cheat because I know that the offset is after a ptr
                //

                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );
                        
                node = GetNextNode(stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    
    return;
}

DECLARE_API( space )
/*++

Routine Description:

    This debugger extension dumps the data related to a HDSKSPC structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    ULONG64 pst = 0;
    ULONG64 dsl = 0;
    DWORD i;
    ULONG64 offset = 0, count = 0, boffset = 0;
    ULONG64 stdata = 0,pextradata = 0;
    ULONG64 Mask = 0;
    ULONG64 node = 0, pxd = 0, pte = 0;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;

    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("space: missing one or more parameters\nusage:!space [address] [verbosity]\n");
        return;
    }
    
    dsl = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);

    InitTypeRead (dsl, SETUPAPI!DISK_SPACE_LIST);

    dprintf("DISK_SPACE_LIST at :\t0x%016I64x\n", dsl);

    GetFieldOffset ("SETUPAPI!DISK_SPACE_LIST", "Lock", (ULONG *) &offset);
    boffset = GetTypeSize ("SETUPAPI!HANDLE");
    
    ReadMemory (dsl + offset, &count, (ULONG) boffset, NULL);
    dprintf("\tLock[0] : 0x%016I64x\n", count);
    
    ReadMemory (dsl + offset + boffset, &count, (ULONG) boffset, NULL);
    dprintf("\tLock[1] : 0x%016I64x\n", count);
    
    dprintf("\tDrivesTable : 0x%016I64x\n", ReadField (DrivesTable));
    dprintf("\tFlags : 0x%016I64x\n", ReadField (Flags));
    
    pst = ReadField (DrivesTable);

    dprintf("\t ***DrivesTable***\n");
    DumpStringTableHeader(pst);

    stdata = GetStringTableData(pst);
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pxd = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpXDrive( pxd, Mask );
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }
}

DECLARE_API( queue )
/*++

Routine Description:

    This debugger extension dumps the data related to a HSPFILEQ

Arguments:


Return Value:

--*/
{
    ULONG64 ReturnLength;
    ULONG64 pfq = 0,pst = 0, pte = 0;
    //SP_FILE_QUEUE fq;
    //PSP_TARGET_ENT pte;
    DWORD i;
    ULONG64 offset = 0, count = 0, boffset = 0;
    ULONG64 stdata = 0, pextradata = 0, node = 0;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    ULONG64 Mask = 0;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;

    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("queue: missing one or more parameters\nusage:!queue [address] [verbosity]\n");
        return;
    }
    
    pfq = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);
    
    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

    dprintf("SP_FILE_QUEUE at :\t0x%016I64x\n", pfq);
    dprintf("\t BackupQueue : 0x%016I64x\n", ReadField (BackupQueue));
    dprintf("\t DeleteQueue : 0x%016I64x\n", ReadField (DeleteQueue));
    dprintf("\t RenameQueue : 0x%016I64x\n", ReadField (RenameQueue));

    dprintf("\t CopyNodeCount : 0x%016I64x\n", ReadField (CopyNodeCount));
    dprintf("\t DeleteNodeCount : 0x%016I64x\n", ReadField (DeleteNodeCount));
    dprintf("\t RenameNodeCount : 0x%016I64x\n", ReadField (RenameNodeCount));
    dprintf("\t BackupNodeCount : 0x%016I64x\n", ReadField (BackupNodeCount));

    dprintf("\t SourceMediaList : 0x%016I64x\n", ReadField (SourceMediaList));
    dprintf("\t SourceMediaCount : 0x%016I64x\n", ReadField (SourceMediaCount));

    dprintf("\t CatalogList : 0x%016I64x\n", ReadField (CatalogList));
    dprintf("\t DriverSigningPolicy : 0x%016I64x (%s)\n",
            ReadField (DriverSigningPolicy),
            (ReadField (DriverSigningPolicy) == DRIVERSIGN_BLOCKING) ? "DRIVERSIGN_BLOCKING" :
            (ReadField (DriverSigningPolicy) == DRIVERSIGN_WARNING) ? "DRIVERSIGN_WARNING" :
            "DRIVERSIGN_NONE" );

    dprintf("\t hWndDriverSigningUi : 0x%016I64x\n", ReadField (hWndDriverSigningUi));
    dprintf("\t DeviceDescStringId : 0x%016I64x\n", ReadField (DeviceDescStringId));
    dprintf("\t AltPlatformInfo : 0x%016I64x\n", ReadField (AltPlatformInfo));

    GetFieldOffset ("SETUPAPI!SP_FILE_QUEUE", "AltPlatformInfo", (ULONG *) &offset);
    
    DumpAltPlatformInfo(pfq + offset);

    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

    dprintf("\t AltCatalogFile : 0x%016I64x\n", ReadField (AltCatalogFile));
    dprintf("\t StringTable : 0x%016I64x\n", ReadField (StringTable));
    dprintf("\t LockRefCount : 0x%016I64x\n", ReadField (LockRefCount));
    dprintf("\t Flags : 0x%016I64x\n", ReadField (Flags));
    dprintf("\t SisSourceHandle : 0x%016I64x\n", ReadField (SisSourceHandle));
    dprintf("\t SisSourceDirectory : 0x%016I64x\n", ReadField (SisSourceDirectory));
    dprintf("\t BackupInfID : 0x%016I64x\n", ReadField (BackupInfID));
    dprintf("\t TargetLookupTable : 0x%016I64x\n", ReadField (TargetLookupTable));
    dprintf("\t UnwindQueue : 0x%016I64x\n", ReadField (UnwindQueue));
    dprintf("\t DelayMoveQueue : 0x%016I64x\n", ReadField (DelayMoveQueue));
    dprintf("\t DelayMoveQueueTail : 0x%016I64x\n", ReadField (DelayMoveQueueTail));

    dprintf("\t Signature : 0x%016I64x (%s)\n",
            ReadField (Signature),
            (ReadField (Signature) == SP_FILE_QUEUE_SIG) ? "VALID" : "INVALID" );

    //
    // dump the queue nodes
    //

    if (Mask & 1) {
        
        if (ReadField (BackupQueue)) {
            dprintf("\t ***BackupQueue***\n");
            DumpFileQueueNodeList(ReadField (BackupQueue), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }

        if (ReadField (DeleteQueue)) {
            dprintf("\t ***DeleteQueue***\n");
            DumpFileQueueNodeList(ReadField (DeleteQueue), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }

        if (ReadField (RenameQueue)) {
            dprintf("\t ***RenameQueue***\n");
            DumpFileQueueNodeList( ReadField (RenameQueue), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }

        if (ReadField (SourceMediaList)) {
            dprintf("\t ***source media list***\n");
            DumpSourceMediaInfoList( ReadField (SourceMediaList), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }
    }

    //
    // dump the catalog info
    //
    if (Mask & 2) {
        
        if (ReadField (CatalogList)) {
            dprintf("\t ***CatalogList***\n");
            DumpCatalogInfoList( ReadField (CatalogList), Mask, TRUE );
        }
    }

    //
    // dump the string table
    //
    
    if (Mask & 4) {
        dprintf("\t ***StringTable***\n");
        
        pst = ReadField (StringTable);

        DumpStringTableHeader (pst);

        stdata = GetStringTableData (pst);

        if (!stdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }
    }

        

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );

                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

    dprintf("\t ***TargetLookupTable***\n");
    
    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
    pst = ReadField (TargetLookupTable);
        
    DumpStringTableHeader (pst);

    stdata = GetStringTableData (pst);
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pte = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpTargetEnt(pte);
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

    //
    // backup stuff
    //
    
    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

    if (Mask & 8) {
        
        if (ReadField (UnwindQueue)) {
            dprintf("\t ***UnwindQueue***\n");
            DumpUnwindList( ReadField (UnwindQueue), TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

        }
    
        if (ReadField (DelayMoveQueue)) {
            dprintf("\t ***DelayMoveQueue***\n");
            DumpDelayMoveList(ReadField (DelayMoveQueue), TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

        }
    
        if (ReadField (DelayMoveQueueTail)) {
            dprintf("\t ***DelayMoveQueueTail***\n");
            DumpDelayMoveList( ReadField (DelayMoveQueueTail), TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

        }
    }

    return;
}

DECLARE_API( qcontext )
/*++

Routine Description:

    This debugger extension dumps the data related to a queue context structure

Arguments:


Return Value:

--*/
{
    ULONG64 pqc = 0, count = 0;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;

    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("qcontext: missing one or more parameters\nusage:!qcontext [address]\n");
        return;
    }
    
    pqc = UtilStringToUlong64 (arg[0]);
    
    
    InitTypeRead (pqc, SETUPAPI!QUEUECONTEXT);

    dprintf("QUEUECONTEXT at :\t0x%016I64x\n", pqc);
    dprintf("\t OwnerWindow : 0x%016I64x\n", ReadField (OwnerWindow));
    dprintf("\t MainThreadId : 0x%016I64x\n", ReadField (MainThreadId));
    dprintf("\t ProgressDialog : 0x%016I64x\n", ReadField (ProgressDialog));
    dprintf("\t ProgressBar : 0x%016I64x\n", ReadField (ProgressBar));
    dprintf("\t Cancelled : 0x%016I64x\n", ReadField (Cancelled));
    
    UtilGetWStringField (pqc, "SETUPAPI!QUEUECONTEXT", "CurrentSourceName", Buffer, sizeof (Buffer));
    dprintf("\t CurrentSourceName : %ws\n", Buffer);
    
    dprintf("\t ScreenReader : 0x%016I64x\n", ReadField (ScreenReader));
    dprintf("\t MessageBoxUp : 0x%016I64x\n", ReadField (MessageBoxUp));
    dprintf("\t PendingUiType : 0x%016I64x\n", ReadField (PendingUiType));
    dprintf("\t PendingUiParameters : 0x%016I64x\n", ReadField (PendingUiParameters));
    dprintf("\t CancelReturnCode : 0x%016I64x\n", ReadField (CancelReturnCode));
    dprintf("\t DialogKilled : 0x%016I64x\n", ReadField (DialogKilled));
    dprintf("\t AlternateProgressWindow : 0x%016I64x\n", ReadField (AlternateProgressWindow));
    dprintf("\t ProgressMsg : 0x%016I64x\n", ReadField (ProgressMsg));
    dprintf("\t NoToAllMask : 0x%016I64x\n", ReadField (NoToAllMask));
    dprintf("\t UiThreadHandle : 0x%016I64x\n", ReadField (UiThreadHandle));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\database.h ===
#ifndef _UMDH_DATABASE_H_
#define _UMDH_DATABASE_H_


BOOL
TraceDbInitialize (
    HANDLE Process
    );

VOID
TraceDbDump (
    );

VOID
UmdhDumpStack (
    IN PTRACE Trace
    );

VOID
UmdhDumpStackByIndex(
    IN USHORT TraceIndex
    );

BOOL
TraceDbBinaryDump (
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\dhcmp.h ===
BOOL 
DHCMP(
    ULONG argc, 
    PCHAR * argv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\database.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    database.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

    This module contains the functions and structures used to
    read the whole stack trace database of a target process and
    subsequently querying it.

Author(s):

    Silviu Calinoiu (SilviuC) 07-Feb-00

Revision History:

    SilviuC 06-Feb-00 Initial version
    
--*/

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <lmcons.h>
// #include <imagehlp.h>
#include <dbghelp.h>

#include <heap.h>
#include <heappagi.h>
#include <stktrace.h>

#include "types.h"
#include "symbols.h"
#include "miscellaneous.h"
#include "database.h"

// SilviuC: do we really need all these includes?

PVOID 
GetTargetProcessDatabaseAddress (
    HANDLE Process
    )
{
    PVOID Address;
    BOOL Result;
    PVOID DbAddress;

    //
    // SymbolAddress will return a NULL address on error.
    //

    Address = SymbolAddress (STACK_TRACE_DB_NAME);

    if (Address == NULL) {
        return NULL;
    }

    Result = READVM (Address, &DbAddress, sizeof DbAddress);

    if (Result == FALSE) {
        
        Comment ( "ntdll.dll symbols are bad or we are not tracking "
                  "allocations in the target process.");
        return NULL;
    }

    if (DbAddress == NULL) {

        Comment ( "Stack trace collection is not enabled for this process. "
                  "Please use the gflags tool with the +ust option to enable it. \n");

        Error (NULL, 0,
               "Stack trace collection is not enabled for this process. "
               "Please use the gflags tool with the +ust option to enable it. \n");

        return NULL;
    }


    return DbAddress;
}


// returns TRUE if successful

BOOL
TraceDbInitialize (
    HANDLE Process
    )
{
    SIZE_T Index;
    BOOL Result;
    SIZE_T BytesRead;
    DWORD OldProtect;
    PVOID TargetAddress;
    PVOID SourceAddress;
    SYSTEM_INFO SystemInfo;
    SIZE_T PageSize;
    ULONG PageCount = 0;
    PVOID TargetDbAddress;
    SIZE_T DatabaseSize;
    SIZE_T TotalDbSize;
    STACK_TRACE_DATABASE Db;

    GetSystemInfo (&SystemInfo);
    PageSize = (SIZE_T)(SystemInfo.dwPageSize);

    TargetDbAddress = GetTargetProcessDatabaseAddress (Process);

    if( TargetDbAddress == NULL ) {
        return FALSE;
    }

    //
    // Figure out the trace database size.
    //

    Result = ReadProcessMemory (Process,
                                TargetDbAddress,
                                &Db,
                                sizeof Db,
                                &BytesRead);

    if (Result == FALSE) {
            
        Error (NULL, 0,
               "Failed to read trace database header (error %u)",
               GetLastError());

        return FALSE;
    }

    TotalDbSize = (ULONG_PTR)(Db.EntryIndexArray) - (ULONG_PTR)(Db.CommitBase);


    //
    // Allocate memory for the database duplicate.
    //

    Globals.Database = VirtualAlloc (NULL,
                                     TotalDbSize,
                                     MEM_RESERVE | MEM_COMMIT,
                                     PAGE_READWRITE);

    if (Globals.Database == NULL) {
        
        Error (NULL, 0,
               "Failed to allocate memory for database (error %u)",
               GetLastError());

        return FALSE;
    }

    //
    // Read the whole thing
    //
    
    Comment ("Reading target process trace database ...");

    DatabaseSize = PageSize;

    for (Index = 0; Index < DatabaseSize; Index += PageSize) {
        
        SourceAddress = (PVOID)((SIZE_T)(TargetDbAddress) + Index);
        TargetAddress = (PVOID)((SIZE_T)(Globals.Database) + Index);

        Result = ReadProcessMemory (Process,
                                    SourceAddress,
                                    TargetAddress,
                                    PageSize,
                                    &BytesRead);

        if (Index == 0) {

            //
            // This is the first page of the database. We can now detect
            // the real size of what we need to read.
            //

            if (Result == FALSE) {

                Comment ("Failed to read trace database (error %u)", GetLastError());
                return FALSE;
                
            }
            else {

                PSTACK_TRACE_DATABASE pDb;

                pDb= (PSTACK_TRACE_DATABASE)(Globals.Database);

                DatabaseSize= (SIZE_T)(pDb->EntryIndexArray) - (SIZE_T)(pDb->CommitBase);

                Comment ("Database size %p", DatabaseSize);
            }
        }
    }

    Comment ("Trace database read.", PageCount);

    if (Globals.DumpFileName) {
        TraceDbBinaryDump ();
        return FALSE;
    }

    return TRUE;
}


PVOID
RelocateDbAddress (
    PVOID TargetAddress
    )
{
    ULONG_PTR TargetBase;
    ULONG_PTR LocalBase;
    PVOID LocalAddress;

    LocalBase = (ULONG_PTR)(Globals.Database);
    TargetBase = (ULONG_PTR)(((PSTACK_TRACE_DATABASE)LocalBase)->CommitBase);
    LocalAddress = (PVOID)((ULONG_PTR)TargetAddress - TargetBase + LocalBase);

    return LocalAddress;
}


VOID
TraceDbDump (
    )
{
    PSTACK_TRACE_DATABASE Db;
    USHORT I;
    PRTL_STACK_TRACE_ENTRY Entry;
    PRTL_STACK_TRACE_ENTRY * IndexArray;

    Comment ("Dumping raw data from the trace database ...");
    Info ("");

    Db = (PSTACK_TRACE_DATABASE)(Globals.Database);

    Globals.ComplainAboutUnresolvedSymbols = TRUE;

    for (I = 1; I <= Db->NumberOfEntriesAdded; I += 1) {

        if (Globals.RawIndex > 0 && Globals.RawIndex != I) {
            continue;
        }

        IndexArray = (PRTL_STACK_TRACE_ENTRY *) RelocateDbAddress (Db->EntryIndexArray);

        if (IndexArray[-I] == NULL) {

            Warning (NULL, 0, "Null/inaccessible trace pointer for trace index %u", I);
            continue;
        }

        Entry = (PRTL_STACK_TRACE_ENTRY) RelocateDbAddress (IndexArray[-I]);

        if (I != Entry->Index) {

            Warning (NULL, 0, "Allocation trace index %u does not match trace entry index %u",
                   I, Entry->Index);

            continue;
        }

        Info ("        %u alloc(s) by: BackTrace%05u", Entry->TraceCount, I);
        
        UmdhDumpStackByIndex (I);
    }
}


BOOL
TraceDbBinaryDump (
    )
{
    PSTACK_TRACE_DATABASE Db;
    SIZE_T DatabaseSize;
    HANDLE DumpFile;
    DWORD BytesWritten;
    BOOL Result;

    Db = (PSTACK_TRACE_DATABASE)(Globals.Database);
    DatabaseSize = (SIZE_T)(Db->EntryIndexArray) - (SIZE_T)(Db->CommitBase);

    Comment ("Creating the binary dump for the trace database in `%s'.",
             Globals.DumpFileName);
    
    DumpFile = CreateFile (Globals.DumpFileName,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (DumpFile == INVALID_HANDLE_VALUE) {

        Comment ( "Failed to create the binary dump file (error %u)",
                   GetLastError());
        return FALSE;
    }

    Result = WriteFile (DumpFile,
                        Globals.Database,
                        (DWORD)DatabaseSize,
                        &BytesWritten,
                        NULL);

    if (Result == FALSE || BytesWritten != DatabaseSize) {

        Comment ("Failed to write the binary dump of trace database (error %u)",
                 GetLastError());
        return FALSE;
    }

    CloseHandle (DumpFile);

    Comment ("Finished the binary dump.");
    return TRUE;
}


VOID
UmdhDumpStackByIndex(
    IN USHORT TraceIndex
    )
/*++

Routine Description:

    This routine dumps a stack as it is stored in the stack trace database.
    The trace index is used to find out the actual stack trace.

Arguments:

    TraceIndex - index of the stack trace.

Return Value:

    None. 
    
Side effects:
    
    The trace is dumped to standard output.
    
--*/
{
    PSTACK_TRACE_DATABASE StackTraceDb;
    PRTL_STACK_TRACE_ENTRY Entry;
    PRTL_STACK_TRACE_ENTRY * IndexArray;
    PVOID Addr;
    BOOL Result;
    TRACE StackTrace;

    if (TraceIndex == 0) {

        //
        // An index of 0 is returned by RtlLogStackBackTrace for an error
        // condition, typically when the stack trace db has not been
        // initialized.
        //

        Info ("No trace was saved for this allocation (Index == 0).");

        return;
    }

    StackTraceDb = (PSTACK_TRACE_DATABASE)(Globals.Database);

    //
    // Read the pointer to the array of pointers to stack traces, then read
    // the actual stack trace.
    //

    IndexArray = (PRTL_STACK_TRACE_ENTRY *) RelocateDbAddress (StackTraceDb->EntryIndexArray);

    if (IndexArray[-TraceIndex] == NULL) {

        Info ("Null/inaccessible trace pointer for trace index %u", TraceIndex);
        return;
    }

    Entry = (PRTL_STACK_TRACE_ENTRY) RelocateDbAddress (IndexArray[-TraceIndex]);
    
    if (TraceIndex != Entry->Index) {

        Error (NULL, 0, "Allocation trace index %u does not match trace entry index %u",
               TraceIndex, Entry->Index);
        
        return;
    }

    //
    // Read the stack trace pointers
    //

    ZeroMemory (&StackTrace, sizeof StackTrace);

    StackTrace.te_EntryCount = min (Entry->Depth, MAX_STACK_DEPTH);
    StackTrace.te_Address = (PULONG_PTR)(&(Entry->BackTrace));
    
    UmdhDumpStack (&StackTrace);

    //
    // StackTrace is about to go out of scope, free any data we allocated
    // for it.  te_Address points to stack, but the te_Module, te_Name, and
    // te_Offset fields were allocated by UmdhResolveName.
    //

    XFREE(StackTrace.te_Module);
    XFREE(StackTrace.te_Name);
    XFREE(StackTrace.te_Offset);

    //
    // SilviuC: We should probably read the whole trace database during
    // process startup instead of poking the process space all the time.
    // 
}


/*
 * UmdhDumpStack
 *
 * Send data in a LIST of TRACE_ENTRYs to the log function.
 *
 * t is the TRACE which we are to 'dump'.
 */
// silviuc: sanitize
VOID
UmdhDumpStack (
    IN PTRACE Trace
    )
{
    ULONG i;
    PCHAR FullName;
    IMAGEHLP_LINE LineInfo;
    DWORD Displacement;
    BOOL LineInfoPresent;

    if (Trace == NULL) {
        return;
    }
    
    for (i = 0; i < Trace->te_EntryCount; i += 1) {

        if (Trace->te_Address[i] != 0) {

            FullName = GetSymbolicNameForAddress (Globals.Target, 
                                                  Trace->te_Address[i]);

            LineInfoPresent = FALSE;

            if (Globals.LineInfo) {

                ZeroMemory (&LineInfo, sizeof LineInfo);
                LineInfo.SizeOfStruct = sizeof LineInfo;

                LineInfoPresent = SymGetLineFromAddr (Globals.Target,
                                                      Trace->te_Address[i],
                                                      &Displacement,
                                                      &LineInfo);

            }

            if (FullName) {
                
                if (Globals.Verbose) {

                    if (LineInfoPresent) {

                        Info ("        %p : %s (%s, %u)", 
                              Trace->te_Address[i], 
                              FullName,
                              FullName, 
                              LineInfo.FileName, 
                              LineInfo.LineNumber);
                    }
                    else {

                        Info ("        %p : %s", 
                              Trace->te_Address[i], 
                              FullName);
                    }
                }
                else {

                    if (LineInfoPresent) {

                        Info ("        %s (%s, %u)", 
                              FullName, 
                              LineInfo.FileName, 
                              LineInfo.LineNumber);
                    }
                    else {

                        Info ("        %s", 
                              FullName);
                    }
                }
            }
            else {

                Info ("        %p : <no module information>", Trace->te_Address[i]);
            }
        }
    }

    Info ("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\heapwalk.h ===
//
// Copyright (c) 2000 Microsoft Corporation
//
// Module Name
//
//    heapwalk.h
//
// Abstract        
//
//    Contains function prototypes that create/modify/update the 
//    datastructure HEAP_ENTRY_LIST. HEAP_ENTRY_LIST maintains 
//    miminum amount of data for a HEAP Object.
//
//    These functions are defined in heapwalk.c
//
// Author
//
//    Narayana Batchu (nbatchu) [May 11, 2001]
//

#ifndef _HEAPWALK_HPP_
#define _HEAPWALK_HPP_

#include <windows.h>
#include <stdio.h>
//
// NO_MATCH   Constant used to initialize the Index into 
//            HEAP_ENTRY_LIST
//
#define NO_MATCH         -1

//
// INITIAL_CAPACITY Initial array size for HEAP_ENTRY_LIST.
//
#define INITIAL_CAPACITY 512


//
// BLOCK_STATE Enumeration
//
//     Enumeration of all the possible states a heap
//     block exists.
//
// Possible States
//
//    HEAP_BLOCK_FREE   - The block is free
// HEAP_BLOCK_BUSY   - The block is busy (allocated).
//
typedef enum _BLOCK_STATE 
{

    HEAP_BLOCK_FREE = 0,
    HEAP_BLOCK_BUSY = 1

} BLOCK_STATE ;

//
// HEAP_ENTRY_INFO structure.
//
//   This structure represents a group of heap blocks whose SIZE
//   and STATUS are same. 
//
//   BlockSize   - Holds the size of the allocated/free blocks of the 
//                 heap
//
//   BlockCount  - Holds the number of blocks whose status and size are 
//                 same.
//
//   BlockState - Holds the status of the collection of blocks. They 
//                can be either allocated (HEAP_ENTRY_BUSY) or free 
//                (HEAP_ENTRY_FREE).
//
typedef struct _HEAP_ENTRY_INFO
{
    ULONG       BlockSize;
    UINT        BlockCount;
    BLOCK_STATE BlockState;

} HEAP_ENTRY_INFO, *LPHEAP_ENTRY_INFO;

//
// HEAP_ENTRY_LIST structure
//
//   This structure represents a heap (with only minimum amount of
//   date collected for each block, such as size and status). 
//
//   pHeapEntries    - Pointer to an array of HEAP_ENTRY_INFO 
//                     structure.
//
//   HeapEntryCount  - Holds the count of HEAP_ENTRY_INFO structures 
//                     stored in the array 'pHeapEntries'
//
//   PresentCapacity - Represents the number of HEAP_ENTRY_INFO structs
//                     that can be possibly stored with the memory
//                     allocated.
//
//   ListSorted      - Boolean that says whether the list is sorted in
//                     its present state.
//
typedef struct _HEAP_ENTRY_LIST
{

    LPHEAP_ENTRY_INFO pHeapEntries;
    UINT HeapEntryCount;
    UINT PresentCapacity;
    BOOL ListSorted;
    
} HEAP_ENTRY_LIST, *LPHEAP_ENTRY_LIST;


//*************************************************
//
// Allocating memory for heap list.
//
//*************************************************

VOID   
Initialize(
    LPHEAP_ENTRY_LIST pList
    );

BOOL   
IncreaseCapacity(
    LPHEAP_ENTRY_LIST pList
    );

//*************************************************
//
// Cleaning up the datastrcuture HEAP_ENTRY_LIST.
//
//*************************************************

VOID 
DestroyList(
    LPHEAP_ENTRY_LIST pList
    );


//*************************************************
//
// Extracting Maximum Block Sizes.
//
//*************************************************

ULONG
GetMaxBlockSize(
    LPHEAP_ENTRY_LIST pList, 
    BLOCK_STATE BlockState
    );

ULONG
GetMaxFreeBlockSize(
    LPHEAP_ENTRY_LIST pList
    );

ULONG
GetMaxAllocBlockSize(
    LPHEAP_ENTRY_LIST pList
    );

//*************************************************
//
// Extracting Top N Entries.
//
//*************************************************

BOOL   
GetTopNentries(
    BLOCK_STATE BlockState, 
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pArray, 
    UINT Entries
    );

BOOL  
GetTopNfreeEntries(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntries, 
    UINT Entries
    );

BOOL  
GetTopNallocEntries(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntries, 
    UINT Entries
    );

//*************************************************
//
// Modifying the heap with Insertions & Deletions.
//
//*************************************************

UINT 
InsertHeapEntry(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntry
    );

UINT 
DeleteHeapEntry(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntry
    );

UINT 
FindMatch(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntry
    );

//*************************************************
//
// Sorting the heap list.
//
//*************************************************

VOID   
SortHeapEntries(
    LPHEAP_ENTRY_LIST pList
    );

static int __cdecl 
SortByBlockSize(
    const void * arg1, 
    const void * arg2
    );

//*************************************************
//
// Display functions for HEAP_ENTRY_LIST.
//
//*************************************************

VOID
DisplayHeapFragStatistics(
    FILE * File,
    PVOID HeapAddress,
    LPHEAP_ENTRY_LIST pList
    );

VOID   
PrintList(
    FILE * File,
    LPHEAP_ENTRY_LIST pList,
    BLOCK_STATE BlockState
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\dhcmp.c ===
/*****************************************************************************\
* DHCMP - Compare DH.EXE outputs.
*
* Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved.
*
* DHCMP is a character-mode tool which processes DH output file(s) into forms
* which may be more useful in investigate memory leaks etc.
*
* DH is a useful tool which displays heap allocations in a properly enabled
* system, but the output is sometimes hard to analyze and interpret.
* The output is a list of allocation backtraces:  each backtrace contains up to
* MAX_BT call-sites, and is accompanied by the number of bytes allocated.
*
* 02-01-95 IanJa    bugfixes and handle BackTraceNNNNN identifiers from dh.exe
* 03/22/95 IanJa    modify to cope with current DH output format.
* 07/27/98 t-mattba added -v switch
\*****************************************************************************/



char *pszHow =
" DHCMP has two modes:\n"
"\n"
" 1)  DHCMP [-d] dh_dump1.txt dh_dump2.txt\n"
"     This compares two DH dumps, useful for finding leaks.\n"
"     dh_dump1.txt & dh_dump2.txt are obtained before and after some test\n"
"     scenario.  DHCMP matches the backtraces from each file and calculates\n"
"     the increase in bytes allocated for each backtrace. These are then\n"
"     displayed in descending order of size of leak\n"
"     The first line of each backtrace output shows the size of the leak in\n"
"     bytes, followed by the (last-first) difference in parentheses.\n"
"     Leaks of size 0 are not shown.\n"
"\n"
" 2)  DHCMP [-d] dh_dump.txt\n"
"     For each allocation backtrace, the number of bytes allocated will be\n"
"     attributed to each callsite (each line of the backtrace).  The number\n"
"     of bytes allocated per callsite are summed and the callsites are then\n"
"     displayed in descending order of bytes allocated.  This is useful for\n"
"     finding a leak that is reached via many different codepaths.\n"
"     ntdll!RtlAllocateHeap@12 will appear first when analyzing DH dumps of\n"
"     csrss.exe, since all allocation will have gone through that routine.\n"
"     Similarly, ProcessApiRequest will be very prominent too, since that\n"
"     appears in most allocation backtraces.  Hence the useful thing to do\n"
"     with mode 2 output is to use dhcmp to comapre two of them:\n"
"         dhcmp dh_dump1.txt > tmp1.txt\n"
"         dhcmp dh_dump2.txt > tmp2.txt\n"
"         dhcmp tmp1.txt tmp2.txt\n"
"     the output will show the differences.\n"
"\n"
" Flags:\n"
"     -d   Output in decimal (default is hexadecimal)\n"
// "     -t   Find Totals (NOT YET IMPLEMENTED)\n"
"     -v   Verbose output: include the actual backtraces as well as summary information\n"
"          (Verbose output is only interesting in mode 1 above.)\n"
"     -?   This help\n";


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NHASH 47
#define TRUE 1
#define FALSE 0
typedef int BOOL;

#define TYPE_WHOLESTACK 0
#define TYPE_FUNCTIONS  1

#define MAXLINELENGTH       4096
#define MAXFUNCNAMELENGTH   1024
#define MAX_BT 48                   /* max length of back trace stack */

void AddToName(char *fnname, unsigned __int64 nb, int sign);
void SetAllocs(char *fnname, unsigned __int64 nb, int sign);
void Process(char *fnam, int sign, int type);
void SortAll();
void AddToStackTrace(char *fnname, char *line);
void ResetStackTrace(char *fnname);

/*
 * Hashing
 */

int MakeHash(char *pName);
void InitHashTab();

#define DUMPF_FIRST   (1)
#define DUMPF_SECOND  (2)
#define DUMPF_RESULT  (4)
#define DUMPF_ALL     (DUMPF_FIRST | DUMPF_SECOND | DUMPF_RESULT)

void DumpNodes(int Flags);

#define F_DECIMAL 0x0001
#define F_TOTAL   0x0002
#define F_VERBOSE 0x0004

//
// Globals
//

int gFlags = 0;

BOOL DHCMP(ULONG argc, PCHAR * argv) {
    int n, DumpType;

    InitHashTab();

    for (n = 1; n < (int)argc; n++) {
        if ((argv[n][0] == '-') || (argv[n][0] == '/')) {
            /*
             * Flags
             */
            switch (argv[n][1]) {
            case 'd':
                gFlags |= F_DECIMAL;
                break;
            //NOT YET IMPLEMENTED
            //case 't':
            //    gFlags |= F_TOTAL;
            //    break;
            case 'v':
                gFlags |= F_VERBOSE;
                break;
            case '?':
            default:
                return FALSE;
            }
        } else {
            /*
             * No more flags
             */

            break;
        }
    }

    if ((argc - n) == 2) {
        DumpType = DUMPF_ALL;
        Process(argv[n],   -1, TYPE_WHOLESTACK);
        Process(argv[n+1], +1, TYPE_WHOLESTACK);
    } else if ((argc - n) == 1) {
        //
        // F_VERBOSE is not meaningful when groveling only one dump.
        //

        gFlags &= ~F_VERBOSE;

        DumpType = DUMPF_RESULT;
        Process(argv[n], +1, TYPE_FUNCTIONS);
    } else {
        return FALSE;
    }

    // printf("==================== BEFORE SORTING ====================\n");
    // DumpNodes(DUMPF_ALL);
    SortAll();
    // printf("==================== AFTER SORTING ====================\n");
    DumpNodes(DumpType);
    return TRUE;
}


void Process(char *fname, int sign, int type) {
    FILE *stream;
    char linebuff[MAXLINELENGTH];
    char fnnamebuff[MAXFUNCNAMELENGTH];
    char BackTraceBuff[MAXFUNCNAMELENGTH * MAX_BT] = {0};
    char *p;
    int lineno = 0;
    BOOL skip = TRUE;       // start out skipping lines

    int iT;
    unsigned __int64 ulT = 0L;
    unsigned __int64 nBytes = 0L;
    unsigned __int64 ulConsumed;
    unsigned __int64 lAllocs;

    // printf("PROCESS %s %d %d\n", fname, sign, type);

    stream = fopen(fname, "r");
    if (stream == NULL) {
        fprintf(stderr, "Can't open %s for reading\n", fname);
        exit (2);
    }

    nBytes = 0;

    while (fgets(linebuff, sizeof(linebuff), stream) != NULL) {
        lineno++;

        //fprintf(stderr, "Line #%d\r", lineno);

        if (linebuff[0] == '*') {
            //
            // If we find a "hogs" line, stack traces follow, any other line
            // started by "*" should cause us to go back to searching for a
            // hogs block.
            //

            if (strstr(linebuff,
                       "Hogs")) {
                skip = FALSE;
            } else {
                skip = TRUE;
            }

            continue;
        }

        if (skip) {
            //
            // Skip is enabled, skip this line, it is data about the heap
            // between 'heap information' and 'heap hogs' lines.
            //

            continue;
        }

        if (linebuff[0] != ' ') 
        {
            //
            // Scan for byte count and find out how many characters have
            // been consumed by this action.
            // 

            ulConsumed = 0;
            iT = sscanf(linebuff, "%I64x bytes in %I64x", &ulT, &lAllocs);

            if (iT > 0) 
            {
                nBytes = ulT;
                p = strstr(linebuff, "BackTrace");
                if (!p) 
                {
                    //
                    // What's this ?
                    //

                    continue;
                } 

                strcpy(BackTraceBuff, p);
                p = strchr(BackTraceBuff, '\n');
                if (p) 
                {
                    *p = '\0';
                }

                if (type == TYPE_FUNCTIONS) 
                {
                    //
                    // BackTraceBuff is now saved for use with the rest of the
                    // trace.
                    //

                    continue;
                }

                AddToName(BackTraceBuff, nBytes, sign);

                if(iT == 1)
                {
                    lAllocs = 1;
                }

                SetAllocs(BackTraceBuff, lAllocs, sign);
                                                
                ResetStackTrace(BackTraceBuff);
            }
        } 
        else if (nBytes != 0) 
        {
            /*
             * If TYPE_WHOLESTACK, then add the count to each line of the
             * stack backtrace.
             */
            
            if (sscanf(linebuff, "        %[^+]+0x", fnnamebuff) == 1) {
                if (type == TYPE_FUNCTIONS) {
                    AddToName(fnnamebuff, nBytes, sign);
                }
                if ((gFlags & F_VERBOSE) == F_VERBOSE) {
                    AddToStackTrace(BackTraceBuff, linebuff);
                }
                continue;
            } else {
                nBytes = 0;
            }
        }
    }

    /*
     * make sure to account for the final one.
     */
    if (type == TYPE_WHOLESTACK) {
        AddToName(BackTraceBuff, nBytes, sign);
    }

    if (fname != NULL) {
        fclose(stream);
    }
}

/*
 * Hashing
 */

typedef struct tagNODE {
    char *pName;
    __int64  lValue;
    __int64 lFirst;
    __int64 lSecond;
    char BackTrace[MAX_BT][MAXFUNCNAMELENGTH];
    long lPosition;
    __int64 lAllocsFirst;
    __int64 lAllocsSecond;
    struct tagNODE *pNext;
} NODE, *PNODE;


VOID 
DumpStackTrace (
    PNODE pNode
    );

VOID
DumpLogDescription (
    VOID
    );


PNODE HashTab[NHASH];

void InitHashTab() {
    int i;
    for (i = 0; i < NHASH; i++) {
        HashTab[i] = NULL;
    }
}

int MakeHash(char *pName) {
    int hash = 0;

    while (*pName) {
        hash += *pName;
        pName++;
    }
    return hash % NHASH;
}

void DumpNodes(int Flags) {
    PNODE pNode;
    int i;
    unsigned __int64 ulTotal = 0;
    char *fmt1;
    char *fmt2;
    char *fmt3;
    char *fmt4;
    char *fmt5;
    char *fmt6;
    char *fmt7;

    DumpLogDescription ();

    if ((gFlags & F_VERBOSE) == F_VERBOSE) {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64d\n";
            fmt6 = "+% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
            fmt7 = "-% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64x\n";
            fmt6 = "+% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
            fmt7 = "-% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
        }        
    } else {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "\n-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s";
            fmt5 = "\nTotal increase == %I64d\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "\n-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s";
            fmt5 = "\nTotal increase == %I64x\n";
        }
    }

    for (i = 0; i < NHASH; i++) {
        // printf("========= HASH %d ==========\n", i);
        for (pNode = HashTab[i]; pNode != NULL; pNode = pNode->pNext) {
            switch (Flags) {
            case DUMPF_FIRST:
                printf(fmt1, pNode->lFirst, pNode->pName);
                break;

            case DUMPF_SECOND:
                printf(fmt1, pNode->lSecond, pNode->pName);
                break;

            case DUMPF_RESULT:
                printf(fmt2, pNode->lValue, pNode->pName);
                break;

            case DUMPF_ALL:
                if (pNode->lValue > 0) {
                    printf(fmt3, pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                } else if (pNode->lValue < 0) {
                    printf(fmt4, -pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                }
                if((gFlags & F_VERBOSE) == F_VERBOSE) {
                    if(pNode->lAllocsSecond-pNode->lAllocsFirst > 0) {
                        printf(fmt6, pNode->lAllocsSecond-pNode->lAllocsFirst,
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    } else if(pNode->lAllocsSecond-pNode->lAllocsFirst < 0) {
                        printf(fmt7, -(pNode->lAllocsSecond-pNode->lAllocsFirst),
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    }
                }

                break;
            }
            ulTotal += pNode->lValue;
            if(((gFlags & F_VERBOSE) == F_VERBOSE) && (pNode->lValue != 0)) {
                DumpStackTrace(pNode);
            }
        }
    }
    if (Flags == DUMPF_ALL) {
        printf(fmt5, ulTotal);
    }
}

PNODE FindNode(char *pName) {
    int i;
    PNODE pNode;

    i = MakeHash(pName);
    pNode = HashTab[i];
    while (pNode) {
        if (strcmp(pName, pNode->pName) == 0) {
            return pNode;
        }
        pNode = pNode->pNext;
    }

    // Not found

    // fprintf(stderr, "NEW %s\n", pName);

    pNode = malloc(sizeof(NODE));
    if (!pNode) {
        fprintf(stderr, "malloc failed in FindNode\n");
        exit(2);
    }

    pNode->pName = _strdup(pName);
    if (!pNode->pName) {
        fprintf(stderr, "strdup failed in FindNode\n");
        exit(2);
    }

    pNode->pNext = HashTab[i];
    HashTab[i] = pNode;
    pNode->lValue = 0L;
    pNode->lFirst = 0L;
    pNode->lSecond = 0L;
    pNode->lPosition = 0L;
    pNode->lAllocsFirst = 0L;
    pNode->lAllocsSecond = 0L;

    return pNode;
}
    
void AddToName(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
    pNode->lValue += nb * sign;
    if (sign == -1) {
        pNode->lFirst += nb;
    } else {
        pNode->lSecond += nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void SetAllocs(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
 
    if (sign == -1) {
        pNode->lAllocsFirst = nb;
    } else {
        pNode->lAllocsSecond = nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void ResetStackTrace(char *fnname) {   
    PNODE pNode;
    
    pNode = FindNode(fnname);
    pNode->lPosition = 0L;    
}

void AddToStackTrace(char *fnname, char *line)
{
    PNODE pNode;
    
    pNode = FindNode(fnname);

    //
    // Make sure we don't write too much data in the BackTrace field.
    //

    if (pNode -> lPosition >= MAX_BT) {
        //
        // MAX_BT should be the number of entries in a stack trace that
        // DH/UMDH captures.  If we trigger this we have tried to attach
        // more than MAX_BT entries in this stack.
        //

        fprintf(stderr,
                "More than %d entries in this stack trace, "
                "did the max change ?\n",
                MAX_BT);

        exit(EXIT_FAILURE);
    }

    strcpy(pNode->BackTrace[pNode->lPosition++], line);
}

/*
 * Insert pNode into the list at ppNodeHead.
 * Sort in ascending order.
 * Insert pNode BEFORE the first item >= pNode.
 */
void Reinsert(PNODE pNode, PNODE *ppNodeHead) {
    PNODE *ppT;
    ppT = ppNodeHead;
    while (*ppT && (pNode->lValue < (*ppT)->lValue)) {
        ppT = &((*ppT)->pNext);
    }
    /*
     * Insert pNode before *ppT
     */
    pNode->pNext = *ppT;
    *ppT = pNode;
}

void SortList(PNODE *ppNodeHead) {
    PNODE pNode;
    PNODE pNext;

    pNode = *ppNodeHead;
    if (pNode == NULL) {
        return;
    }
    pNext = pNode->pNext;
    if (pNext == NULL) {
        return;
    }

    while (TRUE) {
        while (pNext != NULL) {
            if (pNode->lValue < pNext->lValue) {
    
                /*
                 * cut the unordered node from the list
                 */
                pNode->pNext = pNext->pNext;
                Reinsert(pNext, ppNodeHead);
                break;
            }
            pNode = pNext;
            pNext = pNode->pNext;
        }
        if (pNext == NULL) {
            return;
        }
        pNode = *ppNodeHead;
        pNext = pNode->pNext;
    }
}

/*
 * Merge ordered list 1 into ordered list 2
 * Leaves list 1 empty; list 2 ordered
 */
void MergeLists(PNODE *ppNode1, PNODE *ppNode2) {
    PNODE *pp1;
    PNODE *pp2;
    PNODE p1;
    PNODE p2;

    pp1 = ppNode1;
    pp2 = ppNode2;
    while (TRUE) {
        p1 = *pp1;
        p2 = *pp2;

        if (p1 == NULL) {
           return;
        }
        if (p2 == NULL) {
            *pp2 = *pp1;
            *pp1 = NULL;
            return;
        }

        if (p1->lValue > p2->lValue) {
            *pp1 = p1->pNext;
            p1->pNext = p2;
            *pp2 = p1;
            pp2 = &(p1->pNext);
        } else {
            pp2 = &(p2->pNext);
        }
    }
}

void SortAll() {
    int i;

    for (i = 0; i < NHASH; i++) {
        SortList(&HashTab[i]);
    }
    // printf(" ======================== SORTED ========================\n");
    // DumpNodes(DUMPF_ALL);
    for (i = 0; i < NHASH-1; i++) {
        // printf(" ======================== MERGING %d and %d ======================== \n", i, i+1);
        MergeLists(&HashTab[i], &HashTab[i+1]);
        // DumpNodes(DUMPF_ALL);
    }
}

VOID 
DumpStackTrace (
    PNODE pNode
    )
{
    int n;
    
    printf ("\n");

    for (n = 0; n < pNode->lPosition; n += 1) {

        printf ("%s", pNode->BackTrace[n]);
    }
    
    printf ("\n");
}
        
CHAR LogDescription [] = 
    "//                                                                          \n"
    "// Each log entry has the following syntax:                                 \n"
    "//                                                                          \n"
    "// + BYTES_DELTA (NEW_BYTES - OLD_BYTES) NEW_COUNT allocs BackTrace TRACEID \n"
    "// + COUNT_DELTA (NEW_COUNT - OLD_COUNT) BackTrace TRACEID allocations      \n"
    "//     ... stack trace ...                                                  \n"
    "//                                                                          \n"
    "// where:                                                                   \n"
    "//                                                                          \n"
    "//     BYTES_DELTA - increase in bytes between before and after log         \n"
    "//     NEW_BYTES - bytes in after log                                       \n"
    "//     OLD_BYTES - bytes in before log                                      \n"
    "//     COUNT_DELTA - increase in allocations between before and after log   \n"
    "//     NEW_COUNT - number of allocations in after log                       \n"
    "//     OLD_COUNT - number of allocations in before log                      \n"
    "//     TRACEID - decimal index of the stack trace in the trace database     \n"
    "//         (can be used to search for allocation instances in the original  \n"
    "//         UMDH logs).                                                      \n"
    "//                                                                          \n\n";

VOID
DumpLogDescription (
    VOID
    )
{
    fputs (LogDescription, stdout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\symbols.h ===
#ifndef _UMDH_SYMBOLS_H_
#define _UMDH_SYMBOLS_H_


PCHAR
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address
    );

BOOL
SymbolsHeapInitialize (
    );

PVOID
SymbolsHeapAllocate (
    SIZE_T Size
    );

PVOID
SymbolAddress (
    IN PCHAR Name
    );

BOOL CALLBACK
SymbolDbgHelpCallback (
    HANDLE Process,
    ULONG ActionCode,
    PVOID CallbackData,
    PVOID USerContext
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\miscellaneous.h ===
#ifndef _UMDH_MISCELLANEOUS_H_
#define _UMDH_MISCELLANEOUS_H_


PVOID
Xalloc (
    PCHAR File,
    ULONG Line,
    SIZE_T Size
    );

VOID
Xfree (
    PVOID Object
    );

PVOID
Xrealloc (
    PCHAR File,
    ULONG Line,
    PVOID Object,
    SIZE_T Size
    );

#define XALLOC(sz) Xalloc(__FILE__, __LINE__, (sz))
#define XREALLOC(ob, sz) Xrealloc(__FILE__, __LINE__, (ob), (sz))
#define XFREE(ob) Xfree(ob);

VOID
ReportStatistics (
    );

VOID
Info (
    PCHAR Format,
    ...
    );

VOID
Comment (
    PCHAR Format,
    ...
    );

VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

VOID
Debug (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

VOID
Error (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );


BOOL
UmdhReadAtVa(
    IN PCHAR File,
    IN ULONG Line,
    IN HANDLE Process,
    IN PVOID Address,
    IN PVOID Data,
    IN SIZE_T Size
    );

#define READVM(Addr, Buf, Sz) UmdhReadAtVa(__FILE__, __LINE__, (Globals.Target), (Addr), (Buf), (Sz))

typedef struct _GLOBALS
{
    SIZE_T MaximumHeapUsage;
    SIZE_T CurrentHeapUsage;

    ULONG InfoLevel;

    PCHAR Version;

    //
    // Verbose (debug) mode active?
    //

    BOOL Verbose;

    //
    // Load and print file and line number information?
    //
    
    BOOL LineInfo;

    //
    // Do we print just a raw dump of the trace database?
    //

    BOOL RawDump;

    USHORT RawIndex;

    //
    // File name for the binary dump of trace database
    //

    PCHAR DumpFileName;

    //
    // Output and error files.
    //

    FILE * OutFile;
    FILE * ErrorFile;

    //
    // Complain about unresolved symbols?
    //

    BOOL ComplainAboutUnresolvedSymbols;
    
    //
    // Handle of the process from which we are retrieving information.
    //

    HANDLE Target;

    BOOL TargetSuspended;

    //
    // Page heap was enabled for the process.
    //

    BOOL PageHeapActive;
    BOOL LightPageHeapActive;

    //
    // Address of the copy kept in umdh of the entire trace database
    // of the target process.
    //

    PVOID Database;

    //
    // Symbols heap (support for persistent allocations)
    //

    PCHAR SymbolsHeapBase;
    PCHAR SymbolsHeapLimit;
    PCHAR SymbolsHeapFree;

    // 
    // Suspend the process while doing dump
    //

    BOOL Suspend;

} GLOBALS, * PGLOBALS;

extern GLOBALS Globals;

BOOL
SetSymbolsPath (
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\heapwalk.c ===
//
// Copyright (c) 2000 Microsoft Corporation
//
// Module Name
//
//    heapwalk.c
//
// Abstract        
//
//   Contains functions that create/modify/update the datastructure
//   HEAP_ENTRY_LIST. HEAP_ENTRY_LIST maintains miminum amount of data 
//   for a HEAP Object.
//
// Author
//
//   Narayana Batchu (nbatchu) [May 11, 2001]
//

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include "heapwalk.h"

//
// Initialize
//
//    Initializes and allocates memory for the private member 
//    variables of the HEAP_ENTRY_LIST datastructure.
//
// Arguments
// 
//    pList   Pointer to HEAP_ENTRY_LIST whose member variables
//            to be initialized.
//
// Return Value
//
VOID Initialize(LPHEAP_ENTRY_LIST pList)
{   
    if (!pList) return;

    pList->HeapEntryCount  = 0;
    pList->ListSorted      = TRUE;
    pList->PresentCapacity = INITIAL_CAPACITY;

    pList->pHeapEntries = (LPHEAP_ENTRY_INFO)HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        sizeof(HEAP_ENTRY_INFO) * pList->PresentCapacity
        );

    if (!pList->pHeapEntries)
        pList->PresentCapacity = 0;
}

//
// DestroyList
//
//    Cleans up the datastructure HEAP_ENTRY_LIST and frees up the
//    memory associated with the pHeapEntries member.
//
// Arguments
// 
//    pList   Pointer to HEAP_ENTRY_LIST whose member variables
//            to be cleaned up.
//
// Return Value
//
VOID DestroyList(LPHEAP_ENTRY_LIST pList)
{
    if (!pList) return;

    pList->HeapEntryCount = 0;
    pList->ListSorted = TRUE;
    pList->PresentCapacity = 0;
    HeapFree(GetProcessHeap(), 0, pList->pHeapEntries);
}

// 
// GetMaxBlockSize
//
//    This function searches through the HEAP_ENTRY_LIST to find out
//    the maximum block size whose status is defined by 'State'. 
//    
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    State    Specifies the status to search for the maximum size. 
//             State of any block can be 0 (FREE) and 1 (BUSY). 
//             There are other valid status values also, 
//             but we dont maintain those entries.
//
//  Return Value
//
//     DWORD   Returns the maximum size of the block with status 'State'.
//
ULONG GetMaxBlockSize(LPHEAP_ENTRY_LIST pList, BLOCK_STATE State)
{
    ULONG MaxBlockSize = 0;
    UINT Index;

    if (!pList) goto ERROR1;

    if (FALSE == pList->ListSorted)
    {
        SortHeapEntries(pList);
    }

    for (Index=0; Index < pList->HeapEntryCount; Index++)
    {                                            
        if (State == pList->pHeapEntries[Index].BlockState)
        {
            MaxBlockSize = pList->pHeapEntries[Index].BlockSize;
            break;
        }
    }

    ERROR1:
    return MaxBlockSize;
}

// 
// GetMaxFreeBlockSize
//
//    This function searches through the HEAP_ENTRY_LIST to find out
//    the maximum free block size.
//    
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//  Return Value
//
//     DWORD   Returns the maximum size of the available block
//
ULONG GetMaxFreeBlockSize(LPHEAP_ENTRY_LIST pList)  
{ 
    return GetMaxBlockSize(pList, HEAP_BLOCK_FREE); 
}

// 
// GetMaxAllocBlockSize
//
//    This function searches through the HEAP_ENTRY_LIST to find out
//    the maximum allocated block size.
//    
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//  Return Value
//
//     DWORD   Returns the maximum size of the allocated block.
//
ULONG GetMaxAllocBlockSize(LPHEAP_ENTRY_LIST pList) 
{ 
    return GetMaxBlockSize(pList, HEAP_BLOCK_BUSY);
}


//
// GetTopNfreeEntries
//
//    This function scans through the entry list to find the top
//    n free entries in the list.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    pArray   Array of HEAP_ENTRY_INFO structures. This holds the 
//             top n free block sizes available for the process.
//
//    Entries  Specifies the top number of entries to be read from
//             the list.
//
// Return Value
//    
//    BOOL     Returns TRUE if successful.
//                  
BOOL GetTopNfreeEntries(
    LPHEAP_ENTRY_LIST pList,
    LPHEAP_ENTRY_INFO pArray, 
    UINT EntriesToRead)
{   
    return GetTopNentries(
        HEAP_BLOCK_FREE, 
        pList,
        pArray, 
        EntriesToRead
        );
}

//
// GetTopNallocEntries
//
//    This function scans through the entry list to find the top
//    n allocated entries in the list.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    pArray   Array of HEAP_ENTRY_INFO structures. This holds the 
//             top n allocated block sizes available for the process.
//
//    Entries  Specifies the top number of entries to be read from
//             the list.
//
// Return Value
//    
//    BOOL     Returns TRUE if successful.
//                  
BOOL GetTopNallocEntries(
    LPHEAP_ENTRY_LIST pList,
    LPHEAP_ENTRY_INFO pArray,
    UINT EntriesToRead
    )
{
    return GetTopNentries(
        HEAP_BLOCK_BUSY, 
        pList,
        pArray, 
        EntriesToRead
        );
}

//
// GetTopNallocEntries
//
//    This function scans through the entry list to find the top
//    n entries in the list, whose staus matches 'State'.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    pArray   Array of HEAP_ENTRY_INFO structures. This holds the 
//             top n block sizes available for the process, whose status
//             matches 'State'.
//
//    Entries  Specifies the top number of entries to be read from
//             the list.
//
// Return Value
//    
//    BOOL     Returns TRUE if successful.
//                  
BOOL GetTopNentries(
    BLOCK_STATE State,
    LPHEAP_ENTRY_LIST pList,
    LPHEAP_ENTRY_INFO pArray,
    UINT EntriesToRead
    )
{
    BOOL   fSuccess    = FALSE;
    UINT EntriesRead = 0;
    UINT Index;
    
    if (!pArray || !pList) goto ERROR2;
    if (FALSE == pList->ListSorted)
    {
        SortHeapEntries(pList);
    }
    
    for (Index=0; Index < pList->HeapEntryCount; Index++)
    {
        if (EntriesRead == EntriesToRead)
            break;

        if (State == pList->pHeapEntries[Index].BlockState)
        {   
            pArray[EntriesRead].BlockSize = 
                pList->pHeapEntries[Index].BlockSize;

            pArray[EntriesRead].BlockCount = 
                pList->pHeapEntries[Index].BlockCount;

            pArray[EntriesRead].BlockState = 
                pList->pHeapEntries[Index].BlockState;

            EntriesRead++;
        }
    }

    if (EntriesRead == EntriesToRead)
        fSuccess = TRUE;

    ERROR2:
    return fSuccess;
}


//
// IncreaseCapacity
//
//    Increases the array capacity by double. This function is called
//    when tried to insert at the end of the array which is full.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
// Return Value
//
//    BOOL     Returns TRUE if successful in increasing the capacity.
//
BOOL IncreaseCapacity(LPHEAP_ENTRY_LIST pList)
{
    BOOL fSuccess = FALSE;
    UINT NewCapacity;

    if (!pList) goto ERROR3;
    NewCapacity = pList->PresentCapacity * 2;

    if (0 == NewCapacity)
        NewCapacity = INITIAL_CAPACITY;

    __try
    {
        pList->pHeapEntries = (LPHEAP_ENTRY_INFO)HeapReAlloc(
            GetProcessHeap(),
            HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
            pList->pHeapEntries,
            sizeof(HEAP_ENTRY_INFO) * NewCapacity
            );

        pList->PresentCapacity = NewCapacity;
        fSuccess = TRUE;
    }
    __except(GetExceptionCode() == STATUS_NO_MEMORY || 
             GetExceptionCode() == STATUS_ACCESS_VIOLATION)
    {   
        //
        // Ignoring the exceptions raised by HeapReAlloc().
        //
    }

    ERROR3:
    return fSuccess;
}


//
// FindMatch
//
//    Finds an entry in the HEAP_ENTRY_LIST that matches the size and
//    status of pHeapEntry. 
//
// Arguments
//
//    pList      Pointer to HEAP_ENTRY_LIST. 
//               
//    pHeapEntry Pointer to HEAP_ENTRY_INFO to be serached for in 'pList'.
//
// Return Value
//
//   DWORD       Index of the heap entry that matched the input heap entry 
//               'pHeapEntry'
//
//
UINT FindMatch(LPHEAP_ENTRY_LIST pList, LPHEAP_ENTRY_INFO pHeapEntry)
{
    UINT MatchedEntry = NO_MATCH;
    UINT Index;
    if (!pList || !pHeapEntry) goto ERROR4;

    for (Index = 0; Index < pList->HeapEntryCount; Index++)
    {
        if (pList->pHeapEntries[Index].BlockSize == pHeapEntry->BlockSize &&
            pList->pHeapEntries[Index].BlockState == pHeapEntry->BlockState)
        {
            MatchedEntry = Index;
            break;
        }
    }

    ERROR4:
    return MatchedEntry;
}

//
// InsertHeapEntry
//
//    Inserts a new heap entry to the list. It updates the block count if 
//    a match is found else a new entry is made at the end of the HEAP_
//    ENTRY_INFO array.
//
// Arguments
//
//    pList      Pointer to HEAP_ENTRY_LIST.
//
//    pHeapEntry Pointer to HEAP_ENTRY_INFO that is to be added to 'pList'.
//
// Return Value
//
//    DWORD      Returns the index at which it is added to the array. If 
//               for any reason, it is not added to the list, then it 
//               returns NO_MATCH value.
//
UINT InsertHeapEntry(LPHEAP_ENTRY_LIST pList, LPHEAP_ENTRY_INFO pHeapEntry)
{
    UINT MatchedEntry = NO_MATCH;
    if (!pList || !pHeapEntry) goto ERROR5;
    
    MatchedEntry = FindMatch(pList, pHeapEntry);
    if (NO_MATCH != MatchedEntry)
        pList->pHeapEntries[MatchedEntry].BlockCount++;
    else
    {
        UINT Index = pList->HeapEntryCount;
        
        if (Index == pList->PresentCapacity && !IncreaseCapacity(pList))
            goto ERROR5;

        pList->pHeapEntries[Index].BlockSize   = pHeapEntry->BlockSize;
        pList->pHeapEntries[Index].BlockState = pHeapEntry->BlockState;
        pList->pHeapEntries[Index].BlockCount  = 1;

        MatchedEntry = Index;
        pList->HeapEntryCount++;
        pList->ListSorted = FALSE;
    }

    ERROR5:
    return MatchedEntry;

}

//
// DeleteHeapEntry
//
//    Deletes a new heap entry to the list. It decrements the block count 
//    if a match is found. 
//
//    Its possible that the block size is zero and still the heap entry 
//    exits. In such cases we dont decrement the block count (which would 
//    make it negative) and return a NO_MATCH.
//
// Arguments
//
//    pList      Pointer to HEAP_ENTRY_LIST
//
//    pHeapEntry Pointer to HEAP_ENTRY_INFO that is to be removed from 'pList'.
//
// Return Value
//
//    DWORD      Returns the index at which it is removed from the array. If for 
//               any reason (Count==0), it is not removed to the list, then it 
//               returns NO_MATCH value.
//
UINT DeleteHeapEntry(LPHEAP_ENTRY_LIST pList, LPHEAP_ENTRY_INFO pHeapEntry)
{
    UINT MatchedEntry = NO_MATCH;
    if (!pList || !pHeapEntry) goto ERROR6;

    MatchedEntry = FindMatch(pList, pHeapEntry);
    if (NO_MATCH != MatchedEntry &&
        0 != pList->pHeapEntries[MatchedEntry].BlockCount)
    {
        pList->pHeapEntries[MatchedEntry].BlockCount--;
    }
    else
        MatchedEntry = NO_MATCH;

    ERROR6:
    return MatchedEntry;
}

//
// SortByBlockSize
//
//    Compare function required by qsort (uses quick sort to sort 
//    the elements in the array).
//
//    More info about the arguments and the return values could be 
//    found in MSDN.
//
int __cdecl SortByBlockSize(const void * arg1, const void *arg2)
{
    int iCompare;
    LPHEAP_ENTRY_INFO hpEntry1 = (LPHEAP_ENTRY_INFO)arg1;
    LPHEAP_ENTRY_INFO hpEntry2 = (LPHEAP_ENTRY_INFO)arg2;

    iCompare = (hpEntry2->BlockSize - hpEntry1->BlockSize);
    return iCompare;
}

//
// DisplayHeapFragStatistics
//
//    Sorts and displays the fragmentation statistics. It displays
//    two tables one for free blocks and another for allocated blocks.
//
// Arguments
//
//    File       Pointer to C FILE structure, to which the heap frag-
//               mentation statistics have to be dumped.
//
//    pList      Pointer to HEAP_ENTRY_LIST, to be sorted and 
//               dumped to 'File'.
//
// Return Value
//
VOID DisplayHeapFragStatistics(
    FILE * File,
    PVOID HeapAddress,
    LPHEAP_ENTRY_LIST pList
    )
{
    if (!pList) return;

    fprintf(
        File, 
        "\n*- - - - - - - - - - Heap %p Fragmentation Statistics - - - - - - - - - -\n\n",
        HeapAddress
        );
    SortHeapEntries(pList);
    PrintList(File, pList, HEAP_BLOCK_BUSY);
    PrintList(File, pList, HEAP_BLOCK_FREE);
}

//
// SortHeapEntries
//
//    Sorts the heap entries based on their sizes. The top most entry
//    would be having the maximun block size.
//
//    Also, removes those heap entries from the array whose block count
//    has dropped to zero, making available more space.
//
// Arguments
//
//    pList  Pointer to HEAP_ENTRY_LIST, whose entries to be sorted by
//           their sizes.
//
// Return Value
//
VOID SortHeapEntries(LPHEAP_ENTRY_LIST pList)
{
    UINT Index;
    if (!pList) return;

    if (FALSE == pList->ListSorted)
    {
        qsort(
            pList->pHeapEntries, 
            pList->HeapEntryCount, 
            sizeof(HEAP_ENTRY_INFO), 
            &SortByBlockSize
            );

        for (Index = pList->HeapEntryCount-1; Index > 0; Index--)
        {
            if (0 != pList->pHeapEntries[Index].BlockCount)
                break;
        }
        pList->HeapEntryCount = Index + 1;
        pList->ListSorted = TRUE;
    }
}

//
// PrintList
//
//    Utility function that prints out the heap entries to the stdout/
//    file, whose status is equal to "State".
//  
// Arguments
//
//    File       Pointer to C FILE structure, to which the heap frag-
//               mentation statistics have to be dumped.
//
//    pList      Pointer to HEAP_ENTRY_LIST, to be sorted and 
//               dumped to 'File'.
//
//    State     State of the blocks to be displayed.
//
// Return Value
//
VOID PrintList(FILE * File, LPHEAP_ENTRY_LIST pList, BLOCK_STATE State)
{
    UINT Index;

    if (!pList) return;

    if (HEAP_BLOCK_FREE == State)
        fprintf(File, "\nTable of Free Blocks\n\n");
    else if (HEAP_BLOCK_BUSY == State)
        fprintf(File, "\nTable of Allocated Blocks\n\n");

    fprintf(File, "  SIZE   |  COUNT\n");
    fprintf(File, "  --------------\n");
    for (Index = 0; Index < pList->HeapEntryCount; Index++)
    {
        if (State == pList->pHeapEntries[Index].BlockState)
        {
            fprintf(
                File,
                "  0x%04x |  0x%02x\n",
                pList->pHeapEntries[Index].BlockSize,
                pList->pHeapEntries[Index].BlockCount
                );
        }
    }
    fprintf(File, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\miscellaneous.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    miscellaneous.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

Author(s):

    Silviu Calinoiu (SilviuC) 06-Feb-00

Revision History:

    SilviuC 06-Feb-00 Initial version
    
--*/

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include "miscellaneous.h"

GLOBALS Globals;

PVOID
Xalloc (
    PCHAR File,
    ULONG Line,
    SIZE_T Size
    )
{
    PSIZE_T Result;

    Result = (PSIZE_T) malloc (Size + sizeof (SIZE_T));

    if (Result == NULL) {

        //
        // We will never return from this call.
        //
           
        Comment( "malloc(%p) failed %s:%d",Size-sizeof(SIZE_T),File,Line);
        return NULL;
    }

    Globals.CurrentHeapUsage += Size;

    if (Globals.CurrentHeapUsage > Globals.MaximumHeapUsage) {
        Globals.MaximumHeapUsage = Globals.CurrentHeapUsage;
    }

    ZeroMemory (Result, Size + sizeof(SIZE_T));
    *Result = Size;

    return (PVOID)(Result + 1);
}

VOID
Xfree (
    PVOID Object
    )
{
    PSIZE_T Block;

    if (Object) {

        Block = (PSIZE_T)Object;
        Block -= 1;

        Globals.CurrentHeapUsage -= *Block;

        free (Block);
    }
}

PVOID
Xrealloc (
    PCHAR File,
    ULONG Line,
    PVOID Object,
    SIZE_T Size
    )
{
    PVOID Block;
    SIZE_T OldSize;

    Block = Xalloc (File, Line, Size);

    if (Block == NULL) {
        return NULL;
    }
    
    OldSize = *((PSIZE_T)Object - 1);
    CopyMemory (Block, Object, (Size > OldSize) ? OldSize : Size);
    Xfree (Object);
    
    return Block;;
}

VOID
ReportStatistics (
    )
{
    Comment ("UMDH version: %s", Globals.Version);
    Comment ("Peak heap usage: %p bytes", Globals.MaximumHeapUsage);
}

VOID
Info (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    vfprintf (Globals.OutFile, Format, Params);
    fprintf (Globals.OutFile, "\n");
    fflush( Globals.OutFile );
}

VOID
Comment (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    fprintf (Globals.OutFile, "// ");
    vfprintf (Globals.OutFile, Format, Params);
    fprintf (Globals.OutFile, "\n");
    fflush( Globals.OutFile );
}

VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (Globals.ErrorFile, "Warning: %s: %u: ", File, Line);
    } 
    else {
        fprintf (Globals.ErrorFile, "Warning: ");
    }

    vfprintf (Globals.ErrorFile, Format, Params);
    fprintf (Globals.ErrorFile, "\n");
    fflush( Globals.ErrorFile );
}

VOID
Error (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (Globals.ErrorFile, "Error: %s: %u: ", File, Line);
    } 
    else {
        fprintf (Globals.ErrorFile, "Error: ");
    }

    vfprintf (Globals.ErrorFile, Format, Params);
    fprintf (Globals.ErrorFile, "\n");
    fflush( Globals.ErrorFile );
}

VOID
Debug (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (Globals.Verbose) {

        if (File) {
            fprintf (Globals.ErrorFile, "Debug: %s: %u: ", File, Line);
        } 
        else {
            fprintf (Globals.ErrorFile, "Debug: ");
        }

        vfprintf (Globals.ErrorFile, Format, Params);
        fprintf (Globals.ErrorFile, "\n");
        fflush( Globals.ErrorFile );
    }
}


BOOL
UmdhReadAtVa(
    IN PCHAR File,
    IN ULONG Line,
    IN HANDLE Process,
    IN PVOID Address,
    IN PVOID Data,
    IN SIZE_T Size
    )
/*++

Routine Description:

    UmdhReadAtVa

Arguments:

    Address - address in the target process at which we begin reading;
    Data - pointer to the buffer (in our process) to be written to the
       with data read from the target process;
    Size - number of bytes to be read.

Return Value:

    Returns TRUE if the write was successful, FALSE otherwise.
    
--*/
{
    BOOL Result;
    SIZE_T BytesRead = 0;

    Result = ReadProcessMemory(Process,
                               Address,
                               Data,
                               Size,
                               &BytesRead);

    if (Result == FALSE) {

        Error (File, Line,
               "ReadProcessMemory (%p for %d) failed with winerror %u (bytes read: %d)",
               Address, 
               Size,
               GetLastError(),
               BytesRead);

        //
        // Try to give more information about why we failed.
        //

        {
            MEMORY_BASIC_INFORMATION MemoryInfo;
            SIZE_T Bytes;

            Bytes = VirtualQueryEx (Process,
                                    Address,
                                    &MemoryInfo,
                                    sizeof MemoryInfo);

            if (Bytes != sizeof MemoryInfo) {
                Error (NULL, 0, "VirtualQueryEx (%p) failed with error %u",
                       Address, GetLastError());
            }

            Error (NULL, 0, "    BaseAddress    %p", MemoryInfo.BaseAddress);
            Error (NULL, 0, "    AllocationBase %p", MemoryInfo.AllocationBase);
            Error (NULL, 0, "    RegionSize     %p", MemoryInfo.RegionSize);
            Error (NULL, 0, "    State          %08X", MemoryInfo.State);
            Error (NULL, 0, "    Protect        %08X", MemoryInfo.Protect);
            Error (NULL, 0, "    Type           %08X", MemoryInfo.Type);

            if (MemoryInfo.State == MEM_RESERVE) {
                Error (NULL, 0, "    Uncommitted memory area");
            }
        }

        return FALSE;
    }
    else {
        if( Globals.InfoLevel > 0 ) {
            Comment( "ReadProcessMemory( %p for % d)",Address,BytesRead);
        }

        return TRUE;
    }
}


BOOL
SetSymbolsPath (
    )
/*++

Routine Description:

    SetSymbolsPath tries to set automatically the symbol path if
    _NT_SYMBOL_PATH environment variable is not already defined. 

Arguments:

    None.

Return Value:

    Returns TRUE if the symbols path seems to be ok, that is
    _NT_SYMBOL_PATH was defined or we managed to define it to
    a meaningful value.
    
--*/
{
    TCHAR Buffer [MAX_PATH];
    DWORD Length;
    BOOL Result;

    Length = GetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                     Buffer,
                                     MAX_PATH);

    if (Length == 0) {
        
        Warning (NULL, 0, 
               "_NT_SYMBOL_PATH variable is not defined. Will be set to %%windir%%\\symbols.");

        Length = GetEnvironmentVariable (TEXT("windir"),
                                         Buffer,
                                         MAX_PATH);

        if (Length == 0) {
            Error (NULL, 0,
                   "Cannot get value of WINDIR environment variable.");
            return FALSE;
        }

        strcat (Buffer, TEXT("\\symbols"));

        Result = SetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                         Buffer);

        if (Result == FALSE) {

            Error (NULL, 0,
                   "Failed to set _NT_SYMBOL_PATH to `%s'", Buffer);

            return FALSE;
        }

        Comment ("_NT_SYMBOL_PATH set by default to %s", Buffer);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\symbols.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    symbols.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

    This module contains the functions to map addresses to
    symbol names.

Author(s):

    Pat Kenny (PKenny) 09-Aug-2000
    Silviu Calinoiu (SilviuC) 07-Feb-00

Revision History:

    PKenny 09-Aug-2000 Hash optimization code for dh symbol lookup
    SilviuC 06-Feb-00 Initial version and steal Pat's code from dh
    
--*/

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <lmcons.h>
// #include <imagehlp.h>
#include <dbghelp.h>

#include <heap.h>
#include <heappagi.h>
#include <stktrace.h>

#include "types.h"
#include "symbols.h"
#include "miscellaneous.h"
#include "database.h"

#define MAXDWORD    0xffffffff  //this is the max value for a DWORD

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

#define NUM_BUCKETS 4096

struct SymMapNode
{
    struct SymMapNode* Next;
    DWORD_PTR Address;
    PBYTE Symbol;
};

struct SymMapNode* SymMapBuckets[NUM_BUCKETS];

PBYTE FindSymbol( DWORD_PTR Address )
{
    DWORD_PTR Bucket = (Address >> 2) % NUM_BUCKETS;

    struct SymMapNode* pNode = SymMapBuckets[Bucket];

    while( pNode != NULL )
    {
        if ( pNode->Address == Address )
        {
            return pNode->Symbol;
        }

        pNode = pNode->Next;
    }

    return NULL;
}

void InsertSymbol( PCHAR Symbol, DWORD_PTR Address )
{
    DWORD_PTR Bucket = (Address >> 2) % NUM_BUCKETS;

    struct SymMapNode* pNew = (struct SymMapNode*) SymbolsHeapAllocate (sizeof (struct SymMapNode));
    
    pNew->Symbol = Symbol;
    pNew->Address = Address;
    pNew->Next = SymMapBuckets[Bucket];

    SymMapBuckets[Bucket] = pNew;
}


PCHAR
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address
    )
{
    IMAGEHLP_MODULE ModuleInfo;
    CHAR SymbolBuffer[512];
    PIMAGEHLP_SYMBOL Symbol;
    ULONG_PTR Offset;
    LPSTR Name;
    SIZE_T TotalSize;
    BOOL Result;

    if (Address == (ULONG_PTR)-1) {
        return "<< FUZZY STACK TRACE >>";
    }

    //
    // Lookup in map first ..
    //

    Name = FindSymbol( Address );

    if ( Name != NULL ) {
        return Name;
    }
    
    TotalSize = 0;
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (SymGetModuleInfo( UniqueProcess, Address, &ModuleInfo )) {

        TotalSize += strlen( ModuleInfo.ModuleName );
    }
    else {

        if (Globals.ComplainAboutUnresolvedSymbols) {

            Debug (NULL, 0,
                   "Symbols: cannot identify module for address %p", 
                   Address);
        }
        
        return NULL;
    }

    Symbol = (PIMAGEHLP_SYMBOL)SymbolBuffer;
    Symbol->MaxNameLength = 512 - sizeof(IMAGEHLP_SYMBOL) - 1;

    if (SymGetSymFromAddr( UniqueProcess, Address, &Offset, Symbol )) {

        TotalSize += strlen (Symbol->Name) + 16 + 3;

        Name = (LPSTR) SymbolsHeapAllocate (TotalSize);

        if (Name == NULL) {
            return "<out of memory>";
        }

        sprintf (Name, "%s!%s+%08X", ModuleInfo.ModuleName, Symbol->Name, Offset);
        InsertSymbol( Name, Address );

        return Name;
    }
    else {

        if (Globals.ComplainAboutUnresolvedSymbols) {
            
            Debug (NULL, 0,
                   "Symbols: incorrect symbols for module %s (address %p)", 
                   ModuleInfo.ModuleName,
                   Address);
        }

        TotalSize += strlen ("???") + 16 + 5;

        Name = (LPSTR) SymbolsHeapAllocate (TotalSize);

        if (Name == NULL) {
            return "<out of memory>";
        }

        sprintf (Name, "%s!%s @ %p", ModuleInfo.ModuleName, "???", Address);
        InsertSymbol( Name, Address );

        return Name;
    }
}


BOOL
SymbolsHeapInitialize (
    )
{
    Globals.SymbolsHeapBase = (PCHAR) VirtualAlloc (NULL,
                                                    0x800000,
                                                    MEM_RESERVE | MEM_COMMIT,
                                                    PAGE_READWRITE);

    if (Globals.SymbolsHeapBase == NULL) {
        return FALSE;
    }

    Globals.SymbolsHeapFree = Globals.SymbolsHeapBase;
    Globals.SymbolsHeapLimit = Globals.SymbolsHeapBase + 0x800000;

    return TRUE;
}


PVOID
SymbolsHeapAllocate (
    SIZE_T Size
    )
{
    //
    // Aligning size is a must on IA64 since otherwise we will get
    // alignment exceptions. On x86 it is just a matter of better speed.
    //
    
    Size = ((Size + sizeof(ULONG_PTR) - 1) & ~(sizeof(ULONG_PTR) - 1));
    
    if (Globals.SymbolsHeapBase 
        && (Globals.SymbolsHeapFree + Size < Globals.SymbolsHeapLimit)) {
        
        PVOID Result = (PVOID)(Globals.SymbolsHeapFree);
        Globals.SymbolsHeapFree += Size;
        return Result;
    }
    else {

        return XALLOC (Size);
    }
}


PVOID
SymbolAddress (
    IN PCHAR Name
    )
/*++

Routine Description:

    SymbolAddress

Arguments:

    Name - name we wsih to resolve into an address.

Return Value:

    Address associated with the name or NULL if an error occurs.
    
--*/
{
    PVOID Address = NULL;
    BYTE Buffer [SYMBOL_BUFFER_LEN];
    PIMAGEHLP_SYMBOL Symbol;
    BOOL Result;

    Symbol = (PIMAGEHLP_SYMBOL)(&(Buffer[0]));
    
    Symbol->SizeOfStruct = sizeof (IMAGEHLP_SYMBOL);
    Symbol->MaxNameLength = SYMBOL_BUFFER_LEN - sizeof (IMAGEHLP_SYMBOL);

    Result = SymGetSymFromName(Globals.Target, Name, Symbol);

    if (Result == FALSE) {

        Comment ( "SymGetSymFromName (%p, %s, xxx) failed with error %u",
                  Globals.Target, Name, GetLastError());

        Comment (
        "Please make sure you have correct symbols for ntdll.dll library");

        Address = NULL;

    } else {

        Address = (PVOID)(Symbol->Address);
    }

    return Address;
}


BOOL CALLBACK
SymbolDbgHelpCallback (
    HANDLE Process,
    ULONG ActionCode,
    PVOID CallbackData,
    PVOID USerContext
    )
{
    // Comment ("callback call: %p %x ", Process, ActionCode);

    if (ActionCode == CBA_DEBUG_INFO) {

        Debug (NULL, 0, "%s", CallbackData);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\types.h ===
#ifndef _UMDH_TYPES_H_ 
#define _UMDH_TYPES_H_ 

//
// SilviuC: comment ?
//         

#define PID_NOT_PASSED_FLAG     0xFFFFFFCC

//
// SHOW_NO_ALLOC_BLOCKS is used by the '-d' command-line switch and should be
// larger than the maximum possible stack trace value (currently limited to a
// USHORT) to avoid spurious hits.
//

#define SHOW_NO_ALLOC_BLOCKS   -1

//
// SYMBOL_BUFFER_LEN the maximum expected length of a symbol-name.
//

#define SYMBOL_BUFFER_LEN       256

//
// Symbolic names of variable we need to look at in the target process.
//

#define STACK_TRACE_DB_NAME           "ntdll!RtlpStackTraceDataBase"
#define DEBUG_PAGE_HEAP_NAME          "ntdll!RtlpDebugPageHeap"
#define DEBUG_PAGE_HEAP_FLAGS_NAME    "ntdll!RtlpDphGlobalFlags"

//
// This value is taken from ntdll\ldrinit.c where the
// stack trace database for a process gets initialized.
//

#define STACK_TRACE_DATABASE_RESERVE_SIZE 0x800000

//
// SilviuC: comment?
//

#define CACHE_BLOCK_SIZE        (4096 / sizeof (CHAR *))

//
// NAME_CACHE
//

typedef struct  _name_cache     {

    PCHAR                   *nc_Names;
    ULONG                   nc_Max;
    ULONG                   nc_Used;

} NAME_CACHE;

//
// TRACE
//
// Note. Each pointer array should have te_EntryCount elements.
//

typedef struct  _trace  {

    PULONG_PTR               te_Address;
    PULONG_PTR               te_Offset;
    ULONG                    te_EntryCount;
    PCHAR                    *te_Module;
    PCHAR                    *te_Name;

} TRACE, * PTRACE;

//
// STACK_TRACE_DATA
//
// BytesExtra is # of bytes over the minimum size of this allocation.
//

typedef struct  _stack_trace_data   {

    PVOID                   BlockAddress;
    SIZE_T                  BytesAllocated;
    SIZE_T                  BytesExtra;
    ULONG                   AllocationCount;
    USHORT                  TraceIndex;

} STACK_TRACE_DATA, * PSTACK_TRACE_DATA;

//
// HEAPDATA
//
//
// See ntos\dll\query.c:RtlpQueryProcessEnumHeapsRoutine for where I figured
// this out.  It is also possible to calculate the number of bytes allocated in
// the heap if we look at each heap segment.  Then based on the maximum size
// of the heap, subtract the TotalFreeSize.  This seems like considerable work
// for very little information; summing outstanding allocations which we grab
// later should yield the same information.
//

typedef struct          _heapdata   {

    PHEAP                   BaseAddress;
    PSTACK_TRACE_DATA       StackTraceData;
    SIZE_T                  BytesCommitted;
    SIZE_T                  TotalFreeSize;
    ULONG                   Flags;
    ULONG                   VirtualAddressChunks;
    ULONG                   TraceDataEntryMax;
    ULONG                   TraceDataEntryCount;
    USHORT                  CreatorBackTraceIndex;

} HEAPDATA, * PHEAPDATA;

//
// HEAPINFO
//

typedef struct          _heapinfo   {

    PHEAPDATA               Heaps;
    ULONG                   NumberOfHeaps;

} HEAPINFO, * PHEAPINFO;

//
// SilviuC: comment?
//

#define SORT_DATA_BUFFER_INCREMENT  (4096 / sizeof (STACK_TRACE_DATA))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\umdh\umdh.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    umdh.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

Author(s):

    Tim Fleehart (TimF) 18-Jun-1999
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

    TimF    18-Jun-99 Initial version
    SilviuC 30-Jun-00 TIMF_DBG converted to -v option
    SilviuC 06-Feb-00 Massage the code in preparation for speedup fixes
    ChrisW  22-Mar-01 Added process suspend code
    
--*/

//
// Wish List
//
// [-] Option to dump as much as possible without any symbols
// [-] Switch to dbghelp.dll library (get rid of imagehlp.dll)
// [+] Fast symbol lookup
// [+] Faster stack database manipulation
// [-] Faster heap metadata manipulation
// [+] Better memory management for huge processes
// [+] More debug info for PSS issues
// [+] File, line info and umdh version for each reported error (helps PSS).
// [+] Cache for read from target virtual space in case we do it repeatedly.
// [+] Set a symbols path automatically
// [+] Continue to work even if you get errors from imagehlp functions.
//
// [-] Use (if present) dbgexts.dlls library (print file, line info, etc.)
// [-] Integrate dhcmp type of functionality and new features
// [-] No symbols required for page heap groveling (use magic patterns)
// [-] Load/save raw trace database (based on start address)
// [-] Consistency check for a raw trace database
// [-] Log symbol file required for unresolved stacks
// [-] Option to do partial dumps (e.g. only ole32 related).
//

//
// Bugs
//
// [-] Partial copy error when dumping csrss.
// [-] (null) function names in the dump once in a while.
// [-] we can get error reads because the process is not suspended (heaps get destroyed etc.)
// [-] Perf problems have been reported
// [-] Work even if suspend permission not available
//

//
// Versioning
//
// 5.1.001 - standard Whistler version (back compatible with Windows 2000)
// 5.1.002 - umdh works now on IA64
// 5.1.003 - allows target process to be suspended
//

#define UMDH_VERSION "5.1.003 "
#define UMDH_OS_MAJOR_VERSION 5
#define UMDH_OS_MINOR_VERSION 1

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <lmcons.h>
// #include <imagehlp.h>
#include <dbghelp.h>

#include <heap.h>
#include <heappagi.h>
#include <stktrace.h>

#include "types.h"
#include "symbols.h"
#include "miscellaneous.h"
#include "database.h"

#include "heapwalk.h"
#include "dhcmp.h"

#include "ntpsapi.h"

//
// FlaggedTrace holds the trace index of which we want to show all allocated
// blocks, or one of two flag values, 0, to dump all, or SHOW_NO_ALLOC_BLOCKS
// to dump none.
//

ULONG FlaggedTrace = SHOW_NO_ALLOC_BLOCKS;


BOOL
UmdhEnumerateModules(
    IN LPSTR ModuleName,
    IN ULONG_PTR BaseOfDll,
    IN PVOID UserContext
    )
/*
 * UmdhEnumerateModules
 *
 * Module enumeration 'proc' for imagehlp.  Call SymLoadModule on the
 * specified module and if that succeeds cache the module name.
 *
 * ModuleName is an LPSTR indicating the name of the module imagehlp is
 *      enumerating for us;
 * BaseOfDll is the load address of the DLL, which we don't care about, but
 *      SymLoadModule does;
 * UserContext is a pointer to the relevant SYMINFO, which identifies
 *      our connection.
 */
{
    DWORD64 Result;

    Result = SymLoadModule(Globals.Target,
                           NULL,             // hFile not used
                           NULL,             // use symbol search path
                           ModuleName,       // ModuleName from Enum
                           BaseOfDll,        // LoadAddress from Enum
                           0);               // Let ImageHlp figure out DLL size

    // SilviuC: need to understand exactly what does this function return

    if (Result) {

        Error (NULL, 0,
               "SymLoadModule (%s, %p) failed with error %X (%u)",
               ModuleName, BaseOfDll,
               GetLastError(), GetLastError());

        return FALSE;
    }

    if (Globals.InfoLevel > 0) {
        Comment ("    %s (%p) ...", ModuleName, BaseOfDll);
    }

    return TRUE;
}



/*
 * Collect the data required in the STACK_TRACE_DATA entry from the HEAP_ENTRY
 * in the target process.
 */

USHORT
UmdhCollectHeapEntryData(
    IN OUT  HEAP_ENTRY              *CurrentBlock,
    IN OUT  STACK_TRACE_DATA        *Std,
    IN OUT  UCHAR                   *Flags
)
{
    UCHAR                   UnusedSize;
    USHORT                  BlockSize = 0;
    BOOL PageHeapBlock;

    PageHeapBlock = FALSE;

    /*
     * Read Flags for this entry, Size, and UnusedBytes fields to calculate the
     * actual size of this allocation.
     */

    if (!READVM(&(CurrentBlock -> Flags),
                             Flags,
                             sizeof *Flags)) {

        /*
         * Failed to read Flags field of the current block.
         */

        fprintf(stderr,
                "READVM(CurrentBlock Flags) failed.\n");

    } else if (!READVM(&(CurrentBlock -> Size),
                      &BlockSize,
                      sizeof BlockSize)) {

        fprintf(stderr,
                "READVM(CurrentBlock Size) failed.\n");

        /*
         * One never knows if an API will trash output parameters on failure.
         */

        BlockSize = 0;

    } else if (!(*Flags & HEAP_ENTRY_BUSY)) {

        /*
         * This block is not interesting if *Flags doesn't contain
         * HEAP_ENTRY_BUSY; it is free and need not be considered further.  It
         * is important however to have read the block-size (above), as there
         * may be more allocations to consider past this free block.
         */

        ;

    } else if (!READVM(&(CurrentBlock -> UnusedBytes),
                             &UnusedSize,
                             sizeof UnusedSize)) {

        fprintf(stderr,
                "READVM(CurrentBlock UnusedSize) failed.\n");

    } else {

        // UCHAR
        Debug (NULL, 0,
                "CurrentBlock -> Flags:0x%p:0x%x\n",
                &(CurrentBlock-> Flags),
                *Flags);

        // USHORT
        Debug (NULL, 0,
                "CurrentBlock -> Size:0x%p:0x%x\n",
                &(CurrentBlock -> Size),
                BlockSize);

        // UCHAR
        Debug (NULL, 0,
                "CurrentBlock -> UnusedBytes:0x%p:0x%x\n",
                &(CurrentBlock -> UnusedBytes),
                UnusedSize);

        //
        // Try to determine the stack trace index for this allocation.
        //

        if (Globals.LightPageHeapActive) {

            /*
             * Read trace index from DPH_BLOCK_INFORMATION, which is at
             * (DPH_BLOCK_INFORMATION *)(CurrentBlock + 1) -> TraceIndex.
             */

            DPH_BLOCK_INFORMATION   *Block, DphBlock;

            Block = (DPH_BLOCK_INFORMATION *)(CurrentBlock + 1);

            if (!READVM(Block,
                              &DphBlock,
                              sizeof DphBlock)) {

                fprintf(stderr,
                        "READVM(DPH_BLOCK_INFORMATION) failed.\n");

            } else if (DphBlock.StartStamp ==
                       DPH_NORMAL_BLOCK_START_STAMP_FREE) {

                /*
                 * Ignore this record.  When debug-page-heap is used, heap
                 * blocks point to allocated blocks and 'freed' blocks.  Heap
                 * code is responsible for these 'freed' blocks not application
                 * code.
                 */

                ;

            } else if (DphBlock.StartStamp == 0) {

                /*
                 * The first block in the heap is created specially by the
                 * heap code and does not contain debug-page-heap
                 * information.  Ignore it.
                 */

                ;

            } else if ((DphBlock.StartStamp !=
                        DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED)) {
#if 0 //silviuc: this can happen for fixed address heaps (they are never page heap)
                fprintf(stderr,
                        "Unexpected value (0x%lx) of DphBlock -> StartStamp "
                        "read from Block %p\n",
                        DphBlock.StartStamp,
                        Block);
#endif
                PageHeapBlock = FALSE;

            } else if ((DphBlock.EndStamp !=
                        DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED)) {
#if 0 //silviuc: this can happen for fixed address heaps (they are never page heap)
                fprintf(stderr,
                        "Unexpected value (0x%lx) of DphBlock -> EndStamp "
                        "read from Block %p\n",
                        DphBlock.EndStamp,
                        Block);
#endif
                PageHeapBlock = FALSE;

            } else {

                Std -> TraceIndex = DphBlock.TraceIndex;
                Std -> BlockAddress = DphBlock.Heap;
                Std -> BytesAllocated = DphBlock.ActualSize;

                /*
                 * This stack is one allocation.
                 */

                Std -> AllocationCount = 1;
                
                PageHeapBlock = TRUE;
            }

            if (PageHeapBlock) {

                // ULONG
                Debug (NULL, 0,
                       "DPH Block: StartStamp:0x%p:0x%lx\n",
                        &(Block -> StartStamp),
                        DphBlock.StartStamp);

                // PVOID
                Debug (NULL, 0,
                        "           Heap = 0x%p\n",
                        DphBlock.Heap);

                // SIZE_T
                Debug (NULL, 0,
                        "           RequestedSize = 0x%x\n",
                        DphBlock.RequestedSize);

                // SIZE_T
                Debug (NULL, 0,
                        "           ActualSize = 0x%x\n",
                        DphBlock.ActualSize);

                // USHORT
                Debug (NULL, 0,
                        "           TraceIndex = 0x%x\n",
                        DphBlock.TraceIndex);

                // PVOID
                Debug (NULL, 0,
                        "           StackTrace = 0x%p\n",
                        DphBlock.StackTrace);

                // ULONG
                Debug (NULL, 0,
                        "           EndStamp = 0x%lx\n",
                        DphBlock.EndStamp);

            }
        } 
        else if (*Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            /*
             * If HEAP_ENTRY_EXTRA information is present it is at the end of
             * the allocated block.  Try to read the trace-index of the stack
             * which made the allocation.
             */

            HEAP_ENTRY_EXTRA        *Hea;

            /*
             * BlockSize includes the bytes used by HEAP_ENTRY_EXTRA.  The
             * HEAP_ENTRY_EXTRA block is at the end of the heap block.  Add
             * the BlockSize and subtract a HEAP_EXTRA_ENTRY to get the
             * address of the HEAP_ENTRY_EXTRA block.
             */

            Hea = (HEAP_ENTRY_EXTRA *)(CurrentBlock + BlockSize) - 1;

            if (!READVM(&(Hea -> AllocatorBackTraceIndex),
                              &(Std -> TraceIndex),
                              sizeof Std -> TraceIndex)) {

                /*
                 * Just in case READVM puts stuff here on failure.
                 */

                Std -> TraceIndex = 0;

                fprintf(stderr,
                        "READVM(HeapEntryExtra TraceIndex) failed.\n");
            } else {
                /*
                 * Save the address that was returned to the allocator (rather
                 * than the raw address of the heap block).
                 */

                Std -> BlockAddress = (CurrentBlock + 1);

                /*
                 * We have enough data to calculate the block size.
                 */

                Std -> BytesAllocated = (BlockSize << HEAP_GRANULARITY_SHIFT);

#ifndef DH_COMPATIBLE
                /*
                 * DH doesn't subtract off the UnusedSize in order to be usable
                 * interchangeably with DH we need to leave it on too.  This tends
                 * to inflate the size of an allocation reported by DH or UMDH.
                 */

                Std -> BytesAllocated -= UnusedSize;
#endif

                /*
                 * This stack is one allocation.
                 */

                Std -> AllocationCount = 1;
            }

            if (Globals.Verbose) {
                // USHORT
                fprintf(stderr,
                        "Hea -> AllocatorBackTraceIndex:0x%p:0x%x\n",
                        &(Hea -> AllocatorBackTraceIndex),
                        Std -> TraceIndex);

            }

        }
    }

    return BlockSize;
}


VOID
UmdhCollectVirtualAllocdData(
    IN OUT  HEAP_VIRTUAL_ALLOC_ENTRY *CurrentBlock,
    IN OUT  STACK_TRACE_DATA        *Std
)
{
    if (!READVM(&(CurrentBlock -> CommitSize),
                      &(Std -> BytesAllocated),
                      sizeof Std -> BytesAllocated)) {

        fprintf(stderr,
                "READVM(CurrentBlock CommitSize) failed.\n");

    } else if (!READVM(&(CurrentBlock -> ExtraStuff.AllocatorBackTraceIndex),
                             &(Std -> TraceIndex),
                             sizeof Std -> TraceIndex)) {

        fprintf(stderr,
                "READVM(CurrentBlock TraceIndex) failed.\n");

    } else {
        /*
         * From this view, each stack represents one allocation.
         */

        Std -> AllocationCount = 1;
    }
}


VOID
UmdhGetHEAPDATA(
    IN OUT  HEAPDATA                *HeapData
)
{
    HEAP_VIRTUAL_ALLOC_ENTRY *Anchor, *VaEntry;
    ULONG                   Segment;

    /*
     * List that helps keep track of heap fragmentation 
     * statistics.
     */

    HEAP_ENTRY_LIST List;
    Initialize(&List);
    
    if (HeapData -> BaseAddress == NULL) {
        /*
         * This was in the process heap list but it's not active or it's
         * signature didn't match HEAP_SIGNATURE; skip it.
         */

        return;
    }

    /*
     * Examine each segment of the heap.
     */

    for (Segment = 0; Segment < HEAP_MAXIMUM_SEGMENTS; Segment++) {
        /*
         * Read address of segment, and then first and last blocks within
         * the segment.
         */

        HEAP_ENTRY              *CurrentBlock, *LastValidEntry;
        HEAP_SEGMENT            *HeapSegment;
        HEAP_UNCOMMMTTED_RANGE  *pUncommittedRanges;
        ULONG                   NumberOfPages, Signature, UncommittedPages;

        if (!READVM(&(HeapData -> BaseAddress -> Segments[Segment]),
                          &HeapSegment,
                          sizeof HeapSegment)) {

            fprintf(stderr,
                    "READVM(Segments[%d]) failed.\n",
                    Segment);

        } else if (!HeapSegment) {
            /*
             * This segment looks empty.
             *
             * DH agrees here.
             */

            continue;

        } else if (!READVM(&(HeapSegment -> Signature),
                                 &Signature,
                                 sizeof Signature)) {

            fprintf(stderr,
                    "READVM(HeapSegment Signature) failed.\n");

        } else if (Signature != HEAP_SEGMENT_SIGNATURE) {
            /*
             * Signature mismatch.
             */

            fprintf(stderr,
                    "Heap 'segment' at %p has and unexpected signature "
                    "of 0x%lx\n",
                    &(HeapSegment -> Signature),
                    Signature);

        } else if (!READVM(&(HeapSegment -> FirstEntry),
                                 &CurrentBlock,
                                 sizeof CurrentBlock)) {

            fprintf(stderr,
                    "READVM(HeapSegment FirstEntry) failed.\n");

        } else if (!READVM(&(HeapSegment -> LastValidEntry),
                                 &LastValidEntry,
                                 sizeof LastValidEntry)) {

            fprintf(stderr,
                    "READVM(HeapSegment LastValidEntry) failed.\n");

        } else if (!READVM(&(HeapSegment -> NumberOfPages),
                                 &NumberOfPages,
                                 sizeof NumberOfPages)) {

            fprintf(stderr,
                    "READVM(HeapSegment NumberOfPages) failed.\n");

        } else if (!READVM(&(HeapSegment -> NumberOfUnCommittedPages),
                                 &UncommittedPages,
                                 sizeof UncommittedPages)) {

            fprintf(stderr,
                    "READVM(HeapSegment NumberOfUnCommittedPages) failed.\n");

        } else if (!READVM(&(HeapSegment -> UnCommittedRanges),
                                 &pUncommittedRanges,
                                 sizeof pUncommittedRanges)) {

            fprintf(stderr,
                    "READVM(HeapSegment UncommittedRanges) failed.\n");

        } else {
            /*
             * Examine each block in the Segment.
             */

            if (Globals.Verbose) {

                // HEAP_SEGMENT *
                fprintf(stderr,
                        "\nHeapData -> BaseAddress -> Segments[%d]:0x%p:0x%p\n",
                        Segment,
                        &(HeapData -> BaseAddress -> Segments[Segment]),
                        HeapSegment);

                // HEAP_ENTRY *
                fprintf(stderr,
                        "HeapSegment -> FirstEntry:0x%p:0x%p\n",
                        &(HeapSegment -> FirstEntry),
                        CurrentBlock);

                // HEAP_ENTRY *
                fprintf(stderr,
                        "HeapSegment -> LastValidEntry:0x%p:0x%p\n",
                        &(HeapSegment -> LastValidEntry),
                        LastValidEntry);

                // ULONG
                fprintf(stderr,
                        "HeapSegment -> NumberOfPages:0x%p:0x%lx\n",
                        &(HeapSegment -> NumberOfPages),
                        NumberOfPages);

                // ULONG
                fprintf(stderr,
                        "HeapSegment -> NumberOfUncommittedPages:0x%p:0x%lx\n",
                        &(HeapSegment -> NumberOfUnCommittedPages),
                        UncommittedPages);

            }

            /*
             * Each heap segment is one VA chunk.
             */

            HeapData -> VirtualAddressChunks += 1;

            HeapData -> BytesCommitted += (NumberOfPages - UncommittedPages) *
                                          PAGE_SIZE;

            /*
             * LastValidEntry indicate the end of the reserved region; make it
             * the end of the committed region.  We should also be able to
             * calculate this value as (BaseAddress + ((NumberOfPages -
             * NumberOfUnCommittedPages) * PAGE_SIZE)).
             */

            while (CurrentBlock < LastValidEntry) {
                UCHAR                   Flags;
                USHORT                  BlockSize;

                if (Globals.Verbose) {
                    // HEAP_ENTRY *
                    fprintf(stderr,
                            "\nNew LastValidEntry = %p\n",
                            LastValidEntry);

                }

                /*
                 * inserting all the blocks for this heap into HeapEntryList.
                 */
                
                
                {
                    UCHAR  State;
                    USHORT Size;
                    
                    if (!READVM(&(CurrentBlock -> Flags),
                               &State,
                               sizeof State)) {

                        fprintf(stderr,
                                "READVM (CurrentBlock Flags) failed.\n");

                    } 
                    else if (!READVM(&(CurrentBlock -> Size),
                                     &Size,
                                     sizeof Size)) {

                        fprintf(stderr,
                                "READVM (CurrentBlock Size) failed.\n");
                        
                    } 
                    else {

                        HEAP_ENTRY_INFO HeapEntryInfo;

                        HeapEntryInfo.BlockState = HEAP_BLOCK_FREE;
                        if ((State & 0x1) == HEAP_ENTRY_BUSY) {
                            HeapEntryInfo.BlockState = HEAP_BLOCK_BUSY;
                        }
                        HeapEntryInfo.BlockSize = Size;
                        HeapEntryInfo.BlockCount = 1;

                        InsertHeapEntry(&List, &HeapEntryInfo);

                    }
                }
                
                
                /*
                 * If the stack sort data buffer is full, try to make it
                 * larger.
                 */

                if (HeapData -> TraceDataEntryMax == 0) {
                    HeapData -> StackTraceData = XALLOC(SORT_DATA_BUFFER_INCREMENT *
                                                        sizeof (STACK_TRACE_DATA));

                    if (HeapData -> StackTraceData == NULL) {
                        fprintf(stderr,
                                "xalloc of %d bytes failed.\n",
                                SORT_DATA_BUFFER_INCREMENT *
                                    sizeof (STACK_TRACE_DATA));
                    } else {
                        HeapData -> TraceDataEntryMax = SORT_DATA_BUFFER_INCREMENT;
                    }
                } else if (HeapData -> TraceDataEntryCount ==
                           HeapData -> TraceDataEntryMax) {

                    STACK_TRACE_DATA        *tmp;
                    ULONG                   OriginalCount;

                    OriginalCount = HeapData -> TraceDataEntryMax;

                    HeapData -> TraceDataEntryMax += SORT_DATA_BUFFER_INCREMENT;

                    tmp = XREALLOC(HeapData -> StackTraceData,
                                  HeapData -> TraceDataEntryMax *
                                      sizeof (STACK_TRACE_DATA));

                    if (tmp == NULL) {
                        fprintf(stderr,
                                "realloc(%d) failed.\n",
                                HeapData -> TraceDataEntryMax *
                                    sizeof (STACK_TRACE_DATA));

                        /*
                         * Undo the increase in size so we don't actually try
                         * to use it.
                         */

                        HeapData -> TraceDataEntryMax -= SORT_DATA_BUFFER_INCREMENT;

                    } else {
                        /*
                         * Zero newly allocated bytes in the region.
                         */

                        RtlZeroMemory(tmp + OriginalCount,
                                      SORT_DATA_BUFFER_INCREMENT *
                                          sizeof (STACK_TRACE_DATA));

                        /*
                         * Use the new pointer.
                         */

                        HeapData -> StackTraceData = tmp;
                    }
                }

                /*
                 * If there is space in the buffer, collect data.
                 */

                if (HeapData -> TraceDataEntryCount <
                    HeapData -> TraceDataEntryMax) {

                    BlockSize = UmdhCollectHeapEntryData(CurrentBlock,
                                                         &(HeapData -> StackTraceData[
                                                             HeapData -> TraceDataEntryCount]),
                                                         &Flags);

                    if (BlockSize == 0) {
                        /*
                         * Something went wrong.
                         */

                        fprintf(stderr,
                                "UmdhGetHEAPDATA got BlockSize == 0\n");

                        fprintf(stderr,
                                "HeapSegment = 0x%p, LastValidEntry = 0x%p\n",
                                HeapSegment,
                                LastValidEntry);

                        break;
                    } else {

                        /*
                         * Keep track of data in sort data buffer.
                         */

                        HeapData -> TraceDataEntryCount += 1;
                    }
                } else {
                    fprintf(stderr,
                            "UmdhGetHEAPDATA ran out of TraceDataEntries\n");
                }

                if (Flags & HEAP_ENTRY_LAST_ENTRY) {

                    /*
                     * BlockSize is the number of units of size (sizeof
                     * (HEAP_ENTRY)) to move forward to find the next block.
                     * This makes the pointer arithmetic appropriate below.
                     */

                    CurrentBlock += BlockSize;

                    if (pUncommittedRanges == NULL) {
                        CurrentBlock = LastValidEntry;
                    } else {
                        HEAP_UNCOMMMTTED_RANGE  UncommittedRange;

                        if (!READVM(pUncommittedRanges,
                                          &UncommittedRange,
                                          sizeof UncommittedRange)) {

                            fprintf(stderr,
                                    "READVM(pUncommittedRanges) failed.\n");

                            /*
                             * On failure the only reasonable thing we can do
                             * is stop looking at this segment.
                             */

                            CurrentBlock = LastValidEntry;
                        } else {

                            if (Globals.Verbose) {
                                // HEAP_UNCOMMITTED_RANGE
                                fprintf(stderr,
                                        "pUncomittedRanges:0x%p:0x%x\n",
                                        pUncommittedRanges,
                                        UncommittedRange);

                            }

                            CurrentBlock = (PHEAP_ENTRY)((PCHAR)UncommittedRange.Address +
                                                         UncommittedRange.Size);

                            pUncommittedRanges = UncommittedRange.Next;
                        }
                    }
                } else {
                    /*
                     * BlockSize is the number of units of size (sizeof
                     * (HEAP_ENTRY)) to move forward to find the next block.
                     * This makes the pointer arithmetic appropriate below.
                     */

                    CurrentBlock += BlockSize;
                }
            }
        }
    }

    /*
     * Display heap fragmentation statistics.
     */

    DisplayHeapFragStatistics(Globals.OutFile, HeapData->BaseAddress, &List);
    DestroyList(&List);

    /*
     * Examine entries for the blocks created by NtAllocateVirtualMemory.  For
     * these, it looks like when they are in the list they are live.
     */

    if (!READVM(&(HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink),
                      &Anchor,
                      sizeof Anchor)) {

        fprintf(stderr,
                "READVM(reading heap VA anchor) failed.\n");
    } else if (!READVM(&(Anchor -> Entry.Flink),
                             &VaEntry,
                             sizeof VaEntry)) {

        fprintf(stderr,
                "READVM(Anchor Flink) failed.\n");
    } else {

        if (Globals.Verbose) {

            fprintf(stderr,
                    "\nHeapData -> BaseAddress -> VirtualAllocdBlocks.Flink:%p:%p\n",
                    &(HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink),
                    Anchor);

            fprintf(stderr,
                    "Anchor -> Entry.Flink:%p:%p\n",
                    &(Anchor -> Entry.Flink),
                    VaEntry);

        }

        /*
         * If the list is empty
         * &(HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink) will be equal to
         *   HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink and Anchor
         * will be equal to VaEntry).  Advancing VaEntry each time through will
         * cause it to be equal to Anchor when we have examined the entire list.
         */

        while (Anchor != VaEntry) {
            /*
             * If the stack sort data buffer is full, try to make it larger.
             */

            if (HeapData -> TraceDataEntryMax == 0) {
                HeapData -> StackTraceData = XALLOC(SORT_DATA_BUFFER_INCREMENT *
                                                    sizeof (STACK_TRACE_DATA));

                if (HeapData -> StackTraceData == NULL) {
                    fprintf(stderr,
                            "xalloc of %d bytes failed.\n",
                            SORT_DATA_BUFFER_INCREMENT *
                                sizeof (STACK_TRACE_DATA));
                } else {
                    HeapData -> TraceDataEntryMax = SORT_DATA_BUFFER_INCREMENT;
                }
            } else if (HeapData -> TraceDataEntryCount ==
                       HeapData -> TraceDataEntryMax) {

                STACK_TRACE_DATA        *tmp;
                ULONG                   OriginalCount;

                OriginalCount = HeapData -> TraceDataEntryMax;

                HeapData -> TraceDataEntryMax += SORT_DATA_BUFFER_INCREMENT;

                tmp = XREALLOC(HeapData -> StackTraceData,
                              HeapData -> TraceDataEntryMax * sizeof (STACK_TRACE_DATA));

                if (tmp == NULL) {
                    fprintf(stderr,
                            "realloc(%d) failed.\n",
                            HeapData -> TraceDataEntryMax *
                                sizeof (STACK_TRACE_DATA));

                    /*
                     * Undo the increase in size so we don't actually try to
                     * use it.
                     */

                    HeapData -> TraceDataEntryMax -= SORT_DATA_BUFFER_INCREMENT;

                } else {
                    /*
                     * Zero newly allocated bytes in the region.
                     */

                    RtlZeroMemory(tmp + OriginalCount,
                                  SORT_DATA_BUFFER_INCREMENT *
                                      sizeof (STACK_TRACE_DATA));


                    /*
                     * Use the new pointer.
                     */

                    HeapData -> StackTraceData = tmp;
                }
            }

            /*
             * If there is space in the buffer, collect data.
             */

            if (HeapData -> TraceDataEntryCount < HeapData -> TraceDataEntryMax) {

                UmdhCollectVirtualAllocdData(VaEntry,
                                             &(HeapData -> StackTraceData[HeapData ->
                                                 TraceDataEntryCount]));

                HeapData -> TraceDataEntryCount += 1;
            }

            /*
             * Count the VA chunk.
             */

            HeapData -> VirtualAddressChunks += 1;

            /*
             * Advance the next element in the list.
             */

            if (!READVM(&(VaEntry -> Entry.Flink),
                              &VaEntry,
                              sizeof VaEntry)) {

                fprintf(stderr,
                        "READVM(VaEntry Flink) failed.\n");

                /*
                 * If this read failed, we may be unable to terminate this loop
                 * properly; do it explicitly.
                 */

                break;
            }

            if (Globals.Verbose) {

                fprintf(stderr,
                        "VaEntry -> Entry.Flink:%p:%p\n",
                        &(VaEntry -> Entry.Flink),
                        VaEntry);

            }
        }
    }
}


#define HEAP_TYPE_UNKNOWN   0
#define HEAP_TYPE_NT_HEAP   1
#define HEAP_TYPE_PAGE_HEAP 2

BOOL
UmdhDetectHeapType (
    PVOID HeapAddress,
    PDWORD HeapType
    )
{
    BOOL Result;
    HEAP HeapData;

    *HeapType = HEAP_TYPE_UNKNOWN;

    Result = READVM (HeapAddress,
                     &HeapData,
                     sizeof HeapData);

    if (Result == FALSE) {
        return FALSE;
    }

    if (HeapData.Signature == 0xEEFFEEFF) {

        *HeapType =  HEAP_TYPE_NT_HEAP;
        return TRUE;
    }
    else if (HeapData.Signature == 0xEEEEEEEE) {

        *HeapType =  HEAP_TYPE_PAGE_HEAP;
        return TRUE;
    }
    else {

        *HeapType =  HEAP_TYPE_UNKNOWN;
        return TRUE;
    }
}


BOOLEAN
UmdhGetHeapsInformation (
    IN OUT PHEAPINFO HeapInfo
    )
/*++

Routine Description:

    UmdhGetHeaps

    Note that when the function is called it assumes the trace database
    was completely read from the target process.

Arguments:


Return Value:

    True if operation succeeded.
    
--*/
{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION Pbi;
    PVOID Addr;
    BOOL Result;
    PHEAP * ProcessHeaps;
    ULONG j;
    ULONG PageHeapFlags;

    //
    // Get some information about the target process.
    //

    Status = NtQueryInformationProcess(Globals.Target,
                                       ProcessBasicInformation,
                                       &Pbi,
                                       sizeof Pbi,
                                       NULL);

    if (! NT_SUCCESS(Status)) {

        Error (__FILE__, __LINE__,
                "NtQueryInformationProcess failed with status %X\n",
                Status);

        return FALSE;
    }

    //
    // Dump the stack trace database pointer.
    //

    Comment ("Stack trace data base @ %p", ((PSTACK_TRACE_DATABASE)(Globals.Database))->CommitBase);
    Comment ("# traces in the data base %u", ((PSTACK_TRACE_DATABASE)(Globals.Database))->NumberOfEntriesAdded);

    //
    // Find out if this process is using debug-page-heap functionality.
    //

    Addr = SymbolAddress (DEBUG_PAGE_HEAP_NAME);

    Result = READVM(Addr,
                    &(Globals.PageHeapActive),
                    sizeof (Globals.PageHeapActive));

    if (Result == FALSE) {

        Error (NULL, 0,
               "READVM(&RtlpDebugPageHeap) failed.\n"
               "\nntdll.dll symbols are probably incorrect.\n");
    }

    if (Globals.PageHeapActive) {

        Addr = SymbolAddress (DEBUG_PAGE_HEAP_FLAGS_NAME);

        Result = READVM(Addr,
                        &PageHeapFlags,
                        sizeof PageHeapFlags);

        if (Result == FALSE) {

            Error (NULL, 0,
                   "READVM(&RtlpDphGlobalFlags) failed.\n"
                   "\nntdll.dll symbols are probably incorrect.\n");
        }

        if ((PageHeapFlags & PAGE_HEAP_ENABLE_PAGE_HEAP) == 0) {
            Globals.LightPageHeapActive = TRUE;
        }
    }

    //
    // ISSUE: SilviuC: we do not work yet if full page heap is enabled.
    //

    if (Globals.PageHeapActive && !Globals.LightPageHeapActive) {

        Comment ("UMDH cannot be used if full page heap or application "
                 "verifier with full page heap is enabled for the process.");

        Error (NULL, 0, 
               "UMDH cannot be used if full page heap or application "
               "verifier with full page heap is enabled for the process.");

        return FALSE;
    }

    //
    // Get the number of heaps from the PEB.
    //

    Result = READVM (&(Pbi.PebBaseAddress->NumberOfHeaps),
                      &(HeapInfo->NumberOfHeaps),
                      sizeof (HeapInfo->NumberOfHeaps));

    if (Result == FALSE) {

        Error (NULL, 0, "READVM(Peb.NumberOfHeaps) failed.\n");
        return FALSE;
    }

    Debug (NULL, 0,
           "Pbi.PebBaseAddress -> NumberOfHeaps:0x%p:0x%lx\n",
           &(Pbi.PebBaseAddress -> NumberOfHeaps),
           HeapInfo -> NumberOfHeaps);

    HeapInfo->Heaps = XALLOC(HeapInfo->NumberOfHeaps * sizeof (HEAPDATA));

    if (HeapInfo->Heaps == NULL) {

        Error (NULL, 0,
               "xalloc of %d bytes failed.\n",
               HeapInfo -> NumberOfHeaps * sizeof (HEAPDATA));

        return FALSE;
    }

    Result = READVM(&(Pbi.PebBaseAddress -> ProcessHeaps),
                             &ProcessHeaps,
                             sizeof ProcessHeaps);

    if (Result == FALSE) {

        XFREE (HeapInfo->Heaps);
        HeapInfo->Heaps = NULL;

        Error (NULL, 0,
               "READVM(Peb.ProcessHeaps) failed.\n");

        return FALSE;
    }

    Debug (NULL, 0,
           "Pbi.PebBaseAddress -> ProcessHeaps:0x%p:0x%p\n",
           &(Pbi.PebBaseAddress -> ProcessHeaps),
           ProcessHeaps);

    //
    // Iterate heaps
    //

    for (j = 0; j < HeapInfo -> NumberOfHeaps; j += 1) {

        PHEAP HeapBase;
        PHEAPDATA HeapData;
        ULONG Signature;
        USHORT ProcessHeapsListIndex;

        HeapData = &(HeapInfo -> Heaps[j]);

        //
        // Read the address of the heap.
        //

        Result = READVM (&(ProcessHeaps[j]),
                         &(HeapData -> BaseAddress),
                         sizeof HeapData -> BaseAddress);

        if (Result == FALSE) {

            Error (NULL, 0,
                   "READVM(ProcessHeaps[%d]) failed.\n",
                   j);

            Warning (NULL, 0,
                     "Skipping heap @ %p because we cannot read it.",
                     HeapData -> BaseAddress);

            //
            // Error while reading. Forget the address of this heap.
            //

            HeapData->BaseAddress = NULL;

            continue;
        }

        Debug (NULL, 0,
               "**  ProcessHeaps[0x%x]:0x%p:0x%p\n",
               j,
               &(ProcessHeaps[j]),
               HeapData -> BaseAddress);

        HeapBase = HeapData->BaseAddress;

        //
        // What type of heap is this ? It should be an NT heap because page heaps
        // are not inserted into the PEB list of heaps.
        //

        {
            DWORD Type;
            BOOL DetectResult;

            DetectResult = UmdhDetectHeapType (HeapBase, &Type);

            if (! (DetectResult && Type == HEAP_TYPE_NT_HEAP)) {

                Error (NULL, 0, 
                       "Detected a heap that is not an NT heap @ %p", 
                       HeapBase);
            }
        }


        /*
         * Does the heap think that it is within range ?  (We
         * already think it is.)
         */

        if (!READVM(&(HeapBase -> ProcessHeapsListIndex),
                    &ProcessHeapsListIndex,
                    sizeof ProcessHeapsListIndex)) {

            fprintf(stderr,
                    "READVM(HeapBase ProcessHeapsListIndex) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {
            fprintf(stderr,
                    "&(HeapBase -> ProcessHeapsListIndex):0x%p:0x%lx\n",
                    &(HeapBase -> ProcessHeapsListIndex),
                    ProcessHeapsListIndex);

        }

        /*
         * A comment in
         * ntos\rtl\heapdll.c:RtlpRemoveHeapFromProcessList
         * states:  "Note that the heaps stored index is bias by
         * one", thus ">" in the following test.
         */

        if (ProcessHeapsListIndex > HeapInfo -> NumberOfHeaps) {
            /*
             * Invalid index.  Forget the base address of this
             * heap.
             */

            fprintf(stderr,
                    "Heap at index %d has index of %d, but max "
                    "is %d\n",
                    j,
                    ProcessHeapsListIndex,
                    HeapInfo -> NumberOfHeaps);

            fprintf(stderr,
                    "&(Pbi.PebBaseAddress -> NumberOfHeaps) = 0x%p\n",
                    &(Pbi.PebBaseAddress -> NumberOfHeaps));

            HeapData -> BaseAddress = NULL;

            continue;
        }

        /*
         * Check the signature to see if it is really a heap.
         */

        if (!READVM(&(HeapBase -> Signature),
                    &Signature,
                    sizeof Signature)) {

            fprintf(stderr,
                    "READVM(HeapBase Signature) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;

        }
        else if (Signature != HEAP_SIGNATURE) {
            fprintf(stderr,
                    "Heap at index %d does not have a correct "
                    "signature (0x%lx)\n",
                    j,
                    Signature);

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        /*
         * And read other interesting heap bits.
         */

        if (!READVM(&(HeapBase -> Flags),
                    &(HeapData -> Flags),
                    sizeof HeapData -> Flags)) {

            fprintf(stderr,
                    "READVM(HeapBase Flags) failed.\n");
            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {

            fprintf(stderr,
                    "HeapBase -> Flags:0x%p:0x%lx\n",
                    &(HeapBase -> Flags),
                    HeapData -> Flags);

        }

        if (!READVM(&(HeapBase -> AllocatorBackTraceIndex),
                    &(HeapData -> CreatorBackTraceIndex),
                    sizeof HeapData -> CreatorBackTraceIndex)) {

            fprintf(stderr,
                    "READVM(HeapBase AllocatorBackTraceIndex) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {

            fprintf(stderr,
                    "HeapBase -> AllocatorBackTraceIndex:0x%p:0x%lx\n",
                    &(HeapBase -> AllocatorBackTraceIndex),
                    HeapData -> CreatorBackTraceIndex);

        }

        if (!READVM(&(HeapBase -> TotalFreeSize),
                    &(HeapData -> TotalFreeSize),
                    sizeof HeapData -> TotalFreeSize)) {

            fprintf(stderr,
                    "READVM(HeapBase TotalFreeSize) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {

            fprintf(stderr,
                    "HeapBase -> TotalFreeSize:0x%p:0x%p\n",
                    &(HeapBase -> TotalFreeSize),
                    HeapData -> TotalFreeSize);

        }

    }

    /*
     * We got as much as we could.
     */

    return TRUE;
}


int
__cdecl
UmdhSortSTACK_TRACE_DATAByTraceIndex(
    const STACK_TRACE_DATA  *h1,
    const STACK_TRACE_DATA  *h2
)
{
    LONG                    Result;

    /*
     * Sort such that items with identical TraceIndex are adjacent.  (That
     * this results in ascending order is irrelevant).
     */

    Result = h1 -> TraceIndex - h2 -> TraceIndex;

    if (0 == Result) {
        /*
         * For two items with identical TraceIndex, sort into ascending order
         * by BytesAllocated.
         */

        if (h1 -> BytesAllocated > h2 -> BytesAllocated) {
            Result = 1;
        } else if (h1 -> BytesAllocated < h2 -> BytesAllocated) {
            Result = -1;
        } else {
            Result = 0;
        }
    }

    return Result;
}


int
__cdecl
UmdhSortSTACK_TRACE_DATABySize(
    const STACK_TRACE_DATA  *h1,
    const STACK_TRACE_DATA  *h2
)
{
    LONG                    Result = 0;

//    if (SortByAllocs) {
        /*
         * Sort into descending order by AllocationCount.
         */

        if (h2 -> AllocationCount > h1 -> AllocationCount) {
            Result = 1;
        } else if (h2 -> AllocationCount < h1 -> AllocationCount) {
            Result = -1;
        } else {
            Result = 0;
        }
//    }

    if (!Result) {
        /*
         * Sort into descending order by total bytes.
         */

        if (((h1 -> BytesAllocated * h1 -> AllocationCount) + h1 -> BytesExtra) >
            ((h2 -> BytesAllocated * h2 -> AllocationCount) + h2 -> BytesExtra)) {
            Result = -1;
        } else if (((h1 -> BytesAllocated * h1 -> AllocationCount) + h1 -> BytesExtra) <
                   ((h2 -> BytesAllocated * h2 -> AllocationCount) + h2 -> BytesExtra)) {
            Result = +1;
        } else {
            Result = 0;
        }
    }

    if (!Result) {
        /*
         * Bytes or AllocationCounts are equal, sort into ascending order by
         * stack trace index.
         */

        Result = h1 -> TraceIndex - h2 -> TraceIndex;
    }

    if (!Result) {
        /*
         * Previous equal; sort by heap address.  This should result in heap
         * addresses dumpped by -d being in sorted order.
         */

        if (h1 -> BlockAddress < h2 -> BlockAddress) {
            Result = -1;
        } else {
            /*
             * No other sort, just make it "after".
             */

            Result = 1;
        }
    }

    return Result;
}


VOID
UmdhCoalesceSTACK_TRACE_DATA(
    IN OUT  STACK_TRACE_DATA        *Std,
    IN      ULONG                   Count
)
{
    ULONG                   i = 0;

    /*
     * For every entry allocated from the same stack trace, coalesce them into
     * a single entry by moving allocation count and any extra bytes into the
     * first entry then zeroing the AllocationCount on the other entry.
     */

    while ((i + 1) < Count) {
        ULONG                   j;

        /*
         * Identical entries should be adjacent, so start with the next.
         */

        j = i + 1;

        while (j < Count) {
            if (Std[i].TraceIndex == Std[j].TraceIndex) {

                /*
                 * These two allocations were made from the same stack trace,
                 * coalesce.
                 */

                if (Std[j].BytesAllocated > Std[i].BytesAllocated) {

                    /*
                     * Add any extra bytes from the second allocation so we
                     * can determine the total number of bytes from this trace.
                     */

                    Std[i].BytesExtra += Std[j].BytesAllocated -
                                         Std[i].BytesAllocated;
                }

                /*
                 * Move the AllocationCount of the second trace into the first.
                 */

                Std[i].AllocationCount += Std[j].AllocationCount;
                Std[j].AllocationCount = 0;

                ++j;
            } else {
                /*
                 * Mismatch; look no further.
                 */

                break;
            }
        }

        /*
         * Advance to the next uncoalesced entry.
         */

        i = j;
    }
}


VOID
UmdhShowHEAPDATA(
    IN PHEAPDATA HeapData
    )
{
    Info("    Flags: %08lx", HeapData -> Flags);
    Info("    Number Of Entries: %d", HeapData -> TraceDataEntryCount);
    Info("    Number Of Tags: <unknown>");
    Info("    Bytes Allocated: %p", HeapData -> BytesCommitted - (HeapData -> TotalFreeSize << HEAP_GRANULARITY_SHIFT));
    Info("    Bytes Committed: %p",HeapData -> BytesCommitted);
    Info("    Total FreeSpace: %p", HeapData -> TotalFreeSize << HEAP_GRANULARITY_SHIFT);
    Info("    Number of Virtual Address chunks used: %lx", HeapData -> VirtualAddressChunks);
    Info("    Address Space Used: <unknown>");
    Info("    Entry Overhead: %d", sizeof (HEAP_ENTRY));
    Info("    Creator:  (Backtrace%05d)", HeapData -> CreatorBackTraceIndex);

    UmdhDumpStackByIndex(HeapData->CreatorBackTraceIndex);
}


VOID
UmdhShowStacks(
    STACK_TRACE_DATA        *Std,
    ULONG                   StackTraceCount,
    ULONG                   Threshold
)
{
    ULONG                   i;

    for (i = 0; i < StackTraceCount; i++) {
        /*
         * The default Threshold is set to 0 in main(), so stacks with
         * AllocationCount == 0 as a result of the Coalesce will skipped here.
         */

        if (Std[i].AllocationCount > Threshold) {

            if ((Std[i].TraceIndex == 0) ||
                ((ULONG)Std[i].TraceIndex == 0xFEEE)) {
                /*
                 * I'm not sure where either of these come from, I suspect
                 * that the zero case comes from the last entry in some list.
                 * The too-large case being 0xFEEE, suggests that I'm looking
                 * at free pool.  In either case we don't have any useful
                 * information; don't print it.
                 */

                continue;
            }

            /*
             * This number of allocations from this point exceeds the
             * threshold, dump interesting information.
             */

            fprintf(Globals.OutFile, "%p bytes ",
                   (Std[i].AllocationCount * Std[i].BytesAllocated) +
                       Std[i].BytesExtra);

            if (Std[i].AllocationCount > 1) {
                if (Std[i].BytesExtra) {
                    fprintf(Globals.OutFile, "in 0x%lx allocations (@ 0x%p + 0x%p) ",
                           Std[i].AllocationCount,
                           Std[i].BytesAllocated,
                           Std[i].BytesExtra);
                } else {
                    fprintf(Globals.OutFile, "in 0x%lx allocations (@ 0x%p) ",
                           Std[i].AllocationCount,
                           Std[i].BytesAllocated);
                }
            }

            fprintf(Globals.OutFile, "by: BackTrace%05d\n",
                   Std[i].TraceIndex);

            UmdhDumpStackByIndex(Std[i].TraceIndex);

            /*
             * If FlaggedTrace == the trace we are currently looking at, then
             * dump the blocks that come from that trace.  FlaggedTrace == 0
             * indicates 'dump all stacks'.
             */

            if ((FlaggedTrace != SHOW_NO_ALLOC_BLOCKS) &&
                ((FlaggedTrace == Std[i].TraceIndex) ||
                 (FlaggedTrace == 0))) {

                ULONG                   ColumnCount, l;

                fprintf(Globals.OutFile, "Allocations for trace BackTrace%05d:\n",
                       Std[i].TraceIndex);

                ColumnCount = 0;

                /*
                 * Here we rely on the remaining stack having AllocationCount
                 * == 0, so should be at greater indexes than the current
                 * stack.
                 */

                for (l = i; l < StackTraceCount; l++) {

                    /*
                     * If the stack at [l] matches the stack at [i], dump it
                     * here.
                     */

                    if (Std[l].TraceIndex == Std[i].TraceIndex) {

                        fprintf(Globals.OutFile, "%p  ",
                               Std[l].BlockAddress);

                        ColumnCount += 10;

                        if ((ColumnCount + 10) > 80) {
                            fprintf(Globals.OutFile, "\n");
                            ColumnCount = 0;
                        }
                    }
                }

                fprintf(Globals.OutFile, "\n\n\n");
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// resume/suspend
/////////////////////////////////////////////////////////////////////

//
// Note. We need to dynamically discover the NtSuspend/ResumeProcess
// entry points because these where not present in W2000.
//

VOID 
UmdhSuspendProcess( 
    VOID 
    )
{
    HINSTANCE hLibrary;
    NTSTATUS NtStatus;
    typedef NTSTATUS (NTAPI* NTSUSPENDPROC)(HANDLE);
    NTSUSPENDPROC pSuspend;

    hLibrary= LoadLibrary( TEXT("ntdll.dll") );

    if( hLibrary ) {

        pSuspend= (NTSUSPENDPROC) GetProcAddress( hLibrary, "NtSuspendProcess" );

        if( pSuspend ) {

           NtStatus= (*pSuspend)( Globals.Target );
           Comment ( "NtSuspendProcess  Status= %08x",NtStatus);

           if (NT_SUCCESS(NtStatus)) {
               Globals.TargetSuspended = TRUE;
           }

        }
        FreeLibrary( hLibrary ); hLibrary= NULL;
    }
    return;
}


VOID 
UmdhResumeProcess( 
    VOID 
    )
{
    HINSTANCE hLibrary;
    NTSTATUS NtStatus;
    typedef NTSTATUS (NTAPI* NTRESUMEPROC)(HANDLE);
    NTRESUMEPROC pResume;

    if (Globals.TargetSuspended == FALSE) {
        return;
    }

    hLibrary= LoadLibrary( TEXT("ntdll.dll") );

    if( hLibrary ) {
        pResume= (NTRESUMEPROC) GetProcAddress( hLibrary, "NtResumeProcess" );
        if( pResume ) {

           NtStatus= (*pResume)( Globals.Target );
           Comment ( "NtResumeProcess  Status= %08x",NtStatus);
           
           if (NT_SUCCESS(NtStatus)) {
               Globals.TargetSuspended = FALSE;
           }
        }
        FreeLibrary( hLibrary ); hLibrary= NULL;
    }
    return;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
UmdhGrovel (
    IN ULONG Pid,
    IN ULONG Threshold
    )
/*++

Routine Description:

    UmdhGrovel

Arguments:

    Pid = PID of target process
    
    Threshold - ???         

Return Value:

    None.
    
--*/
{
    BOOL Result;
    HEAPINFO HeapInfo;
    ULONG Heap;
    PHEAPDATA HeapData;

    Comment ("Connecting to process %u ...", Pid);

    //
    // Imagehlp library needs the query privilege for the process
    // handle and of course we need also read privilege because
    // we will read all sorts of things from the process.
    //

    Globals.Target = OpenProcess(
                                  PROCESS_QUERY_INFORMATION | 
                                  PROCESS_VM_READ           |
                                  PROCESS_SUSPEND_RESUME,
                                  FALSE,
                                  Pid);

    if (Globals.Target == NULL) {

        Error (__FILE__, __LINE__,
               "OpenProcess(%u) failed with error %u", Pid, GetLastError());

        return;
    }

    //
    // Attach ImageHlp and enumerate the modules.
    //

    Comment ("Process %u opened  (handle=%d) ...", Pid, Globals.Target );

    Result = SymInitialize(Globals.Target, // target process
                           NULL,           // standard symbols search path
                           TRUE);          // invade process space with symbols

    if (Result == FALSE) {

        ULONG ErrorCode = GetLastError();

        if (ErrorCode >= 0x80000000) {
            
            Error (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %X", ErrorCode);
        }
        else {

            Error (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %u", ErrorCode);
        }
        
        goto ErrorReturn;
    }

    Comment ("Debug library initialized ...", Pid);

    SymSetOptions(SYMOPT_CASE_INSENSITIVE | 
                  SYMOPT_DEFERRED_LOADS |
                  (Globals.LineInfo ? SYMOPT_LOAD_LINES : 0) |
                  SYMOPT_UNDNAME);

    Comment ("Debug options set: %08X", SymGetOptions());

    // Result = SymRegisterCallback (Globals.Target,
    //                               SymbolDbgHelpCallback,
    //                               NULL);

    if (Result == FALSE) {

        Warning (NULL, 0, "Failed to register symbol callback function.");
    }

    Result = SymEnumerateModules (Globals.Target,
                                  UmdhEnumerateModules,
                                  Globals.Target);
    if (Result == FALSE) {

        Error (__FILE__, __LINE__,
               "imagehlp.SymEnumerateModules() failed with error %u", GetLastError());
         
        goto ErrorReturn;
    }

    Comment ("Module enumeration completed.");

    //
    // Initialize local trace database. Note that order is important.
    // Initialize() assumes the process handle to the target process
    // already exists and the symbol management package was initialized.
    //

    if (TraceDbInitialize (Globals.Target) == FALSE) {
        goto ErrorReturn;
    }

    //
    // Suspend target process.
    //

    // ISSUE: SilviuC: cannot suspend csrss.exe. Need to code to avoid that.

    // UmdhSuspendProcess();

    try {
        //
        // If we want just a raw dump then do it and return withouth getting any information
        // about heaps.
        //

        if (Globals.RawDump) {

            TraceDbDump ();
            goto ErrorReturn;
        }

        //
        // Read heap information.
        //

        Result = UmdhGetHeapsInformation (&HeapInfo);

        if (Result == FALSE) {

            Error (__FILE__, __LINE__,
                   "Failed to get heaps information.");
            goto ErrorReturn;
        }

        //
        // Print heap summary
        //

        Info ("\n - - - - - - - - - - Heap summary - - - - - - - - - -\n");

        for (Heap = 0; Heap < HeapInfo.NumberOfHeaps; Heap += 1) {

            HeapData = &(HeapInfo.Heaps[Heap]);

            if (HeapData->BaseAddress == NULL) {
                continue;
            }

            Info ("    %p", HeapData->BaseAddress);
        }

        //
        // Examine each heap.
        //

        for (Heap = 0; Heap < HeapInfo.NumberOfHeaps; Heap += 1) {

            HeapData = &(HeapInfo.Heaps[Heap]);

            if (HeapData->BaseAddress == NULL) {

                //
                // SilviuC: Can this really happen?
                //
                // This was in the process heap list but it's not
                // active or it's signature didn't match
                // HEAP_SIGNATURE; skip it.
                //

                Warning (__FILE__, __LINE__, "Got a null heap base address");
                continue;
            }

            //
            // Get information about this heap.
            //
            // Silviuc: Waht if we fail reading?
            //

            UmdhGetHEAPDATA(HeapData);

            //
            // Sort the HeapData->StackTraceData by TraceIndex.
            //

            qsort(HeapData->StackTraceData,
                  HeapData->TraceDataEntryCount,
                  sizeof (HeapData->StackTraceData[0]),
                  UmdhSortSTACK_TRACE_DATAByTraceIndex);

            //
            // Coalesce HeapData->StackTraceEntries by
            // AllocationCount, zeroing allocation count for
            // duplicate entries.
            //

            UmdhCoalesceSTACK_TRACE_DATA(HeapData->StackTraceData,
                                         HeapData->TraceDataEntryCount);

            //
            // Sort the HeapData -> StackTraceData in ascending
            // order by Size (BytesAllocated * AllocationCount) or
            // if SortByAllocs is set, into descending order by
            // number of allocations.
            //

            qsort(HeapData->StackTraceData,
                  HeapData->TraceDataEntryCount,
                  sizeof (HeapData->StackTraceData[0]),
                  UmdhSortSTACK_TRACE_DATABySize);

            //
            // Display Heap header info. The first `*' character is used by the
            // dhcmp to synchronize log parsing.
            //

            Info ("\n*- - - - - - - - - - Start of data for heap @ %p - - - - - - - - - -\n", 
                  HeapData->BaseAddress);

            UmdhShowHEAPDATA(HeapData);

            //
            // The following line is required by dhcmp tool.
            //

            Info ("*- - - - - - - - - - Heap %p Hogs - - - - - - - - - -\n",
                  HeapData->BaseAddress);

            //
            // Display Stack trace info for stack in this heap.
            //

            UmdhShowStacks(HeapData->StackTraceData,
                           HeapData->TraceDataEntryCount,
                           Threshold);

            Info ("\n*- - - - - - - - - - End of data for heap @ %p - - - - - - - - - -\n",
                  HeapData->BaseAddress);

            //
            // Clean up the allocations we made during this loop.
            //

            XFREE (HeapData->StackTraceData);
            HeapData->StackTraceData = NULL;
        }

        XFREE(HeapInfo.Heaps);
        HeapInfo.Heaps = NULL;
    }
    finally {

        //
        // Super important to resume target process even if umdh
        // has a bug and crashes.
        //

        // UmdhResumeProcess ();
    }
    
    //
    // Clean up.
    //

ErrorReturn:

    SymCleanup(Globals.Target);

    CloseHandle(Globals.Target);  Globals.Target= NULL;
}


VOID
UmdhUsage(
    char                    *BadArg
)
{
    if (BadArg) {
        fprintf(stderr,
                "\nUnexpected argument \"%s\"\n\n",
                BadArg);
    }

    fprintf(stderr,
            "umdh version %s                                                                \n"
            "1. umdh {-p:(int)Process-id {-t:(int)Threshold} {-f:(char *)Filename}          \n"
            "                            {-d{:(int)Trace-Number}} {-v{:(char *)Filename}}   \n"
            "                            {-i:(int)Infolevel} {-l} {-r{:(int)Index}}         \n"
            "        }                                                                      \n"
       "\n"
            "2. umdh { {-h} {-v} File1 { File2 } }                                          \n"
       "\n"
            "umdh can be used in two modes -                                                \n"
       "\n"
            "When used in the first mode, it dumps the user mode heap (acts as old-umdh),   \n"
            "while used in the second mode acts as dhcmp.                                   \n"
            "                                                                               \n"
            "  Options when used in MODE 1:                                                                     \n"
            "                                                                               \n"
            "    -t  Optional.  Only dump stack that account for more allocations than      \n"
            "        specified value.  Defaults to 0; dump all stacks.                      \n"
       "\n"
            "    -f  Optional.  Indicates output file.  Destroys an existing file of the    \n"
            "        same name.  Default is to dump to stdout.                              \n"
       "\n"
            "    -p  Required.  Indicates the Process-ID to examine.                        \n"
       "\n"
            "    -d  Optional.  Dump address of each outstanding allocation.                \n"
            "        Optional inclusion of an integer numeric argument causes dump of       \n"
            "        only those blocks allocated from this BackTrace.                       \n"
       "\n"
            "    -v  Optional.  Dumps debug output to stderr or to a file.                  \n"
       "\n"
            "    -i  Optional.  Zero is default (no additional info). The greater the       \n"
            "        number the more data is displayed. Supported numbers: 0, 1.            \n"
       "\n"
            "    -l  Optional. Print file and line number information for traces.           \n"
       "\n"
            "    -r  Optional. Print a raw dump of the trace database without any           \n"
            "        heap information. If an index is specified then only the trace         \n"
            "        with that particular index will be dumped.                             \n"
       "\n"
            "    -x  Optional.  Suspend the Process while dumping heaps.                    \n"
       "\n"
            "    -h  Optional.  Usage message.  ie This message.                            \n"
            "                                                                               \n"
            "    Parameters are accepted in any order.                                      \n"
            "                                                                               \n"
            "                                                                               \n"
            "    UMDH uses the dbghelp library to resolve symbols, therefore                \n"
            "    _NT_SYMBOL_PATH must be set appropriately. For example:                    \n"
            "                                                                               \n"
            "        set _NT_SYMBOL_PATH=symsrv*symsrv.dll*\\\\symbols\\symbols             \n"
            "                                                                               \n"
            "    to use the symbol server, otherwise the appropriate local or network path. \n"
            "    If no symbol path is set, umdh will use by default %%windir%%\\symbols.    \n"
            "                                                                               \n"
            "    See http://dbg/symbols for more information about setting up symbols.      \n"
            "                                                                               \n"
            "    UMDH requires also to have stack trace collection enabled for the process. \n"
            "    This can be done with the gflags tool. For example to enable stack trace   \n"
            "    collection for notepad, the command is: `gflags -i notepad.exe +ust'.      \n"
            "                                                                               \n"
       "\n"
            "  When used in MODE 2:                                                         \n"
       "\n"
            "  I) UMDH [-d] dh_dump1.txt dh_dump2.txt                                       \n"
            "     This compares two DH dumps, useful for finding leaks.                     \n"
            "     dh_dump1.txt & dh_dump2.txt are obtained before and after some test       \n"
            "     scenario.  DHCMP matches the backtraces from each file and calculates     \n"
            "     the increase in bytes allocated for each backtrace. These are then        \n"
            "     displayed in descending order of size of leak                             \n"
            "     The first line of each backtrace output shows the size of the leak in     \n"
            "     bytes, followed by the (last-first) difference in parentheses.            \n"
            "     Leaks of size 0 are not shown.                                            \n"
       "\n"
            " II) UMDH [-d] dh_dump.txt                                                     \n"
            "     For each allocation backtrace, the number of bytes allocated will be      \n"
            "     attributed to each callsite (each line of the backtrace).  The number     \n"
            "     of bytes allocated per callsite are summed and the callsites are then     \n"
            "     displayed in descending order of bytes allocated.  This is useful for     \n"
            "     finding a leak that is reached via many different codepaths.              \n"
            "     ntdll!RtlAllocateHeap@12 will appear first when analyzing DH dumps of     \n"
            "     csrss.exe, since all allocation will have gone through that routine.      \n"
            "     Similarly, ProcessApiRequest will be very prominent too, since that       \n"
            "     appears in most allocation backtraces.  Hence the useful thing to do      \n"
            "     with mode 2 output is to use dhcmp to comapre two of them:                \n"
            "         umdh dh_dump1.txt > tmp1.txt                                          \n"
            "         umdh dh_dump2.txt > tmp2.txt                                          \n"
            "         umdh tmp1.txt tmp2.txt                                                \n"
            "     the output will show the differences.                                     \n"
       "\n"
            " Flags:                                                                        \n"
            "     -d   Output in decimal (default is hexadecimal)                           \n"
            "     -v   Verbose output: include the actual backtraces as well as summary     \n"
            "          information                                                          \n"
            "          (Verbose output is only interesting in mode 1 above.)                \n",
            UMDH_VERSION);
    exit(EXIT_FAILURE);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// OS versioning
/////////////////////////////////////////////////////////////////////

// return TRUE if we can run on this version

BOOL
UmdhCheckOsVersion (
    )
{
    OSVERSIONINFO OsInfo;
    BOOL Result;

    ZeroMemory (&OsInfo, sizeof OsInfo);
    OsInfo.dwOSVersionInfoSize = sizeof OsInfo;

    Result = GetVersionEx (&OsInfo);

    if (Result == FALSE) {
        
        Comment (  "GetVersionInfoEx() failed with error %u",
                    GetLastError());
        return FALSE;
    }

    Comment ("OS version %u.%u %s", 
             OsInfo.dwMajorVersion, OsInfo.dwMinorVersion,
             OsInfo.szCSDVersion);
    Comment ("Umdh OS version %u.%u", 
              UMDH_OS_MAJOR_VERSION, UMDH_OS_MINOR_VERSION);

    if (OsInfo.dwMajorVersion < 4) {
        
        Comment ( "Umdh does not run on systems older than 4.0");
        return FALSE;
    }
    else if (OsInfo.dwMajorVersion == 4) {
        
        //
        // ISSUE: silviuc: add check to run only on NT4 SP6.
        //

        if (OsInfo.dwMajorVersion != UMDH_OS_MAJOR_VERSION 
            || OsInfo.dwMinorVersion != UMDH_OS_MINOR_VERSION) {
            
            Comment (
                   "Cannot run umdh for OS version %u.%u on a %u.%u system",
                   UMDH_OS_MAJOR_VERSION, UMDH_OS_MINOR_VERSION, 
                   OsInfo.dwMajorVersion, OsInfo.dwMinorVersion);
            return FALSE;
        }
    }
    else if (OsInfo.dwMajorVersion == 5) {
        
        if (OsInfo.dwMajorVersion != UMDH_OS_MAJOR_VERSION 
            || OsInfo.dwMinorVersion != UMDH_OS_MINOR_VERSION) {
            
            if (! (OsInfo.dwMinorVersion == 0 && UMDH_OS_MINOR_VERSION == 1)) {
                
                Comment (
                       "Cannot run umdh for OS version %u.%u on a %u.%u system",
                       UMDH_OS_MAJOR_VERSION, UMDH_OS_MINOR_VERSION, 
                       OsInfo.dwMajorVersion, OsInfo.dwMinorVersion);
                return FALSE;
            }
        }
    }
    else {

        Warning (NULL, 0, "OS version %u.%u", 
                 OsInfo.dwMajorVersion,
                 OsInfo.dwMinorVersion);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////// main
/////////////////////////////////////////////////////////////////////

BOOL UMDH( ULONG argc, PCHAR * argv)
{
    BOOLEAN WasEnabled;
    CHAR CompName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD CompNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    NTSTATUS Status;
    SYSTEMTIME st;
    ULONG Pid = PID_NOT_PASSED_FLAG;
    ULONG Threshold = 0;
    ULONG i;

    LARGE_INTEGER StartStamp;
    LARGE_INTEGER EndStamp;

    FILE * File;

    ZeroMemory( &Globals, sizeof(Globals) );

    Globals.Version = UMDH_VERSION;

    Globals.OutFile = stdout;
    Globals.ErrorFile = stderr;

    /*
     * Make an effort to understand passed arguments.
     */

    if ((argc < 2) || (argc > 6)) {
        return FALSE;
    }

    if (argc == 2 && strstr (argv[1], "?") != NULL) {
        return FALSE;
    }

    i = 1;

    while (i < argc) {

        //
        // Accept either '-' or '/' as argument specifier.
        //

        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {

            switch (tolower(argv[i][1])) {
            
            case 'd':

                if (argv[i][2] == ':') {
                    FlaggedTrace = atoi(&(argv[i][3]));
                }
                else {
                    FlaggedTrace = 0;
                }

                break;

            case 't':

                if (argv[i][2] == ':') {
                    Threshold = atoi(&(argv[i][3]));
                }
                else {
                    return FALSE;
                }

                break;

            case 'p':

                /*
                 * Is the first character of the remainder of this
                 * argument a number ?  If not don't try to send it to
                 * atoi.
                 */

                if (argv[i][2] == ':') {
                    if (!isdigit(argv[i][3])) {
                        fprintf(stderr,
                                "\nInvalid pid specified with \"-p:\"\n");

                        return FALSE;
                    }
                    else {
                        Pid = atoi(&(argv[i][3]));
                    }
                }
                else {
                    return FALSE;
                }

                break;

            case 'f':

                if (argv[i][2] == ':') {

                    File = fopen (&(argv[i][3]), "w");
                    
                    if (File == NULL) {

                        Comment ( "Failed to open output file `%s'", 
                                  &(argv[i][3]));
                        exit( EXIT_FAILURE );
                    }
                    else {

                        Globals.OutFile = File;
                    }
                }
                else {
                    return FALSE;
                }

                break;

            //
            // Possible future option for saving the trace database in a binary format.
            // Not really useful right now because we still need access to the target
            // process in order to get various data (modules loaded, heaps, etc.).
#if 0
            case 's':

                if (argv[i][2] == ':') {

                    Globals.DumpFileName = &(argv[i][3]);
                }
                else {

                    return FALSE;
                }

                break;
#endif

            case 'v':

                Globals.Verbose = TRUE;

                if (argv[i][2] == ':') {

                    File = fopen (&(argv[i][3]), "w");
                    
                    if (File == NULL) {

                        Comment ( "Failed to open error file `%s'", 
                                   &(argv[i][3]));
                        exit( EXIT_FAILURE );
                    }
                    else {

                        Globals.ErrorFile = File;
                    }
                }

                break;

            case 'i':

                Globals.InfoLevel = 1;

                if (argv[i][2] == ':') {
                    Globals.InfoLevel = atoi (&(argv[i][3]));
                }

                break;

            case 'l':
                Globals.LineInfo = TRUE;
                break;

            case 'r':
                Globals.RawDump = TRUE;
                
                if (argv[i][2] == ':') {
                    Globals.RawIndex = (USHORT)(atoi (&(argv[i][3])));
                }

                break;

            case 'x':
                Globals.Suspend = TRUE;
                break;


            case 'h':               /* FALLTHROUGH */
            case '?':

                return FALSE;

                break;

            default:

                return FALSE;

                break;
            }
        }
        else {
            return FALSE;
        }

        i++;
    }

    if (Pid == PID_NOT_PASSED_FLAG) {
        fprintf(stderr,
                "\nNo pid specified.\n");

        return FALSE;

    }

    //
    // Stamp umdh log with time and computer name.
    //

    GetLocalTime(&st);
    GetComputerName(CompName, &CompNameLength);

    Comment ("");
    Comment ("UMDH: version %s: Logtime %4u-%02u-%02u %02u:%02u - Machine=%s - PID=%u",
             Globals.Version,
             st.wYear,
             st.wMonth,
             st.wDay,
             st.wHour,
             st.wMinute,
             CompName,
             Pid);
    Comment ("\n");

    if( !UmdhCheckOsVersion() ) {
        exit(EXIT_FAILURE);;
    } 

    QueryPerformanceCounter (&StartStamp);

    //
    // Try to come up with a guess for the symbols path if none is defined.
    //

    SetSymbolsPath ();

    //
    // Enable debug privilege, so that we can attach to the indicated
    // process.  If it fails complain but try anyway just in case the user can
    // actually open the process without privilege.
    //
    // SilviuC: do we need debug privilege?
    //

    WasEnabled = TRUE;

    Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &WasEnabled);

    if (! NT_SUCCESS(Status)) {

        Warning (__FILE__, __LINE__,
                 "RtlAdjustPrivilege(enable) failed with status = %X",
                 Status);

        //
        // If we could not enable the privilege, indicate that it was already
        // enabled so that we do not attempt to disable it later.
        //

        WasEnabled = TRUE;
    }
    else {

        Comment ("Debug privilege has been enabled.");
    }

    //
    // Increase priority of umdh as much as possible. This has the role of
    // preventing heap activity in the process being grovelled.
    //
    // SilviuC: we might need to enable the SE_INC_BASE_PRIORITY privilege.
    //

#if 0
    {
        BOOL Result;

        Result = SetPriorityClass (GetCurrentProcess(), 
                                   HIGH_PRIORITY_CLASS);

        if (Result == FALSE) {

            Warning (NULL, 0,
                     "SetPriorityClass failed with error %u");
        }
        else {

            Result = SetThreadPriority (GetCurrentThread(), 
                                        THREAD_PRIORITY_HIGHEST);
            if (Result == FALSE) {

                Warning (NULL, 0,
                         "SetThreadPriority failed with error %u");
            }
            else {

                Comment ("Priority of UMDH thread has been increased.");
            }
        }
    }
#endif

    //
    // Initialize heap for persistent allocations.
    //

    SymbolsHeapInitialize();

    //
    // We may not have SeDebugPrivilege, but try anyway.
    // SilviuC: we should print an error if we do not have this privilege
    //

    UmdhGrovel(Pid, Threshold);

    //
    // Disable SeDebugPrivilege if we enabled it.
    //

    if (! WasEnabled) {

        Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    FALSE,
                                    FALSE,
                                    &WasEnabled);

        if (! NT_SUCCESS(Status)) {

            Warning (__FILE__, __LINE__,
                     "RtlAdjustPrivilege(disable) failed with status = %X\n",
                     Status);
        }

    }

    //
    // Statistics
    //

    ReportStatistics ();

    {
        LARGE_INTEGER Frequency;

        QueryPerformanceCounter (&EndStamp);
        QueryPerformanceFrequency (&Frequency);

        Debug (NULL, 0, "Start stamp %I64u", StartStamp.QuadPart);
        Debug (NULL, 0, "End stamp %I64u", EndStamp.QuadPart);
        Debug (NULL, 0, "Frequency %I64u", Frequency.QuadPart);

        Frequency.QuadPart /= 1000; // ticks per msec

        if (Frequency.QuadPart) {
            Comment ("Elapse time %I64u msecs.",
                     (EndStamp.QuadPart - StartStamp.QuadPart) / (Frequency.QuadPart));
        }
    }

    {
        FILETIME CreateTime, ExitTime, KernelTime, UserTime;
        BOOL bSta;

        bSta= GetProcessTimes( NtCurrentProcess(),
                               &CreateTime,
                               &ExitTime,
                               &KernelTime,
                               &UserTime );
        if( bSta ) {
           LONGLONG User64, Kernel64;
           DWORD dwUser, dwKernel;
           Kernel64= *(LONGLONG*) &KernelTime;
           User64=   *(LONGLONG*) &UserTime;
           dwKernel= (DWORD) (Kernel64/10000);
           dwUser=   (DWORD) (User64/10000);
           Comment( "CPU time  User: %u msecs. Kernel: %u msecs.", 
                    dwUser, dwKernel );
        }
    }

    //
    // Cleanup
    //

    SymCleanup(Globals.Target);
    Globals.Target = NULL;

    fflush (Globals.OutFile);
    fflush (Globals.ErrorFile);

    if (Globals.OutFile != stdout) {
        fclose (Globals.OutFile);
    }
    
    if (Globals.ErrorFile != stderr) {
        fclose (Globals.ErrorFile);
    }

    return TRUE;
}


VOID __cdecl
#if defined (_PART_OF_DH_)
UmdhMain(
#else
main(
#endif
    ULONG argc,
    PCHAR *argv
    )
/*
VOID __cdecl 
main(
    ULONG argc,
    PCHAR *argv
    )
*/
{
    
    /*
     * Make an effort to understand passed arguments.
     */

    if (UMDH (argc, argv)) {
    } 
    else if (DHCMP (argc, argv)) {
    }
    else {
        UmdhUsage (NULL);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\winerror\winerror.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <limits.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "error.h"

#include "ntstatus.dbg"
#include "winerror.dbg"

#define HEAP_INCREMENT 100

#define HEAP_FLAGS 0

typedef struct _PAIRLIST {
    ULONG Status;
    ULONG WinError;
} PAIRLIST, *PPAIRLIST;

PPAIRLIST PairList;
ULONG PairCount;
ULONG MaxPairs;

PUCHAR ProgramName;

void
usage(
    void
    );

void
error(
    PUCHAR String
    );

void
ReconstructPairs(
    void
    );

void
StatusFromWinError(
    ULONG WinError
    );

PUCHAR
ntsSymbolicName(
    NTSTATUS Id
    );

PUCHAR
weSymbolicName(
    DWORD Id
    );

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    int i;
    BOOL IsWinError;
    ULONG WinError;
    NTSTATUS Status;

    ProgramName = argv[0];

    if (argc < 2) {
        usage();
    }

    ReconstructPairs();

    //
    // parse cmdline
    //

    IsWinError = TRUE;
    for (i = 1; i < argc; i++) {

        if (argv[i][0] == '-') {

            switch (argv[i][1]) {

                case 's':
                case 'S':
                    IsWinError = FALSE;
                    break;

                default:
                    usage();
                    break;

            }
            continue;

        } else {
            if (IsWinError) {
                WinError = strtoul(argv[i], NULL, 0);
                StatusFromWinError(WinError);
            } else {
                Status = strtoul(argv[i], NULL, 16);
                printf("%6d %s <--> %08lx %s\n",
                    RtlNtStatusToDosError(Status),
                    weSymbolicName(RtlNtStatusToDosError(Status)),
                    Status,
                    ntsSymbolicName(Status)
                    );
            }

        }

    }

    return 0;
}

void
StatusFromWinError(
    ULONG WinError
    )
{
    ULONG Index;
    BOOL Hit = FALSE;
    for (Index = 0; Index < PairCount; Index++) {
        if (WinError == PairList[Index].WinError) {
            printf("%6d %s <--> 0x%08lx %s\n",
                    WinError,
                    weSymbolicName(WinError),
                    PairList[Index].Status,
                    ntsSymbolicName(PairList[Index].Status)
                   );
            Hit = TRUE;
        }
    }
    if (!Hit) {
        printf("%6d %s <--> No NTSTATUS matched\n",
                WinError,
                weSymbolicName(WinError)
               );
    }
}

void
AddPair(
    ULONG Status,
    ULONG WinError
    )
{
    if (PairCount >= MaxPairs) {
        MaxPairs += HEAP_INCREMENT;
        if (PairList == NULL) {
            PairList = (PPAIRLIST)RtlAllocateHeap(RtlProcessHeap(),
                                                  HEAP_FLAGS,
                                                  MaxPairs * sizeof(PAIRLIST)
                                                  );
        } else {
            PairList = (PPAIRLIST)RtlReAllocateHeap(RtlProcessHeap(),
                                                    HEAP_FLAGS,
                                                    PairList,
                                                    MaxPairs * sizeof(PAIRLIST)
                                                    );
        }
        if (PairList == NULL) {
            error("out of memory");
        }
    }
    PairList[PairCount].Status = Status;
    PairList[PairCount].WinError = WinError;
    PairCount++;
}

void
ReconstructPairs(
    void
    )
{
    ULONG Index;
    ULONG Entry;
    ULONG Offset;
    ULONG Status;
    ULONG WinError;

    Index = 0;
    for (Entry = 0; RtlpRunTable[Entry].RunLength != 0; Entry++) {

        Status = RtlpRunTable[Entry].BaseCode;

        for (Offset = 0; Offset < RtlpRunTable[Entry].RunLength; Offset++, Status++ ) {

            if (RtlpRunTable[Entry].CodeSize == 1) {
                WinError = (ULONG)RtlpStatusTable[Index];
                Index += 1;

            } else {
                WinError = (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                            (ULONG)RtlpStatusTable[Index]);
                Index += 2;
            }

            AddPair(Status, WinError);

        }
    }
}

void
usage(
    void
    )
{
    fprintf(stderr,
            "usage: %s errorcode ... [-s ntstatus ...]\n",
            ProgramName);
    ExitProcess(1);
}

void
error(
    PUCHAR String
    )
{
    fprintf(stderr, "%s: %s\n", ProgramName, String);
    ExitProcess(2);
}

PUCHAR
ntsSymbolicName(
    NTSTATUS Id
    )
{
    int i = 0;

    while (ntstatusSymbolicNames[i].SymbolicName) {
        if (ntstatusSymbolicNames[i].MessageId == Id) {
            return ntstatusSymbolicNames[i].SymbolicName;
        }
        ++i;
    }

    return "No Symbolic Name";
}

PUCHAR
weSymbolicName(
    DWORD Id
    )
{
    int i = 0;

    while (winerrorSymbolicNames[i].SymbolicName) {
        if (winerrorSymbolicNames[i].MessageId == Id) {
            return winerrorSymbolicNames[i].SymbolicName;
        }
        ++i;
    }

    return "No Symbolic Name";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\urtl\startup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    startup.c

Abstract:

    This module contains the startup code for an NT Application

Author:

    Steve Wood (stevewo) 22-Aug-1989

Environment:

    User Mode only

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// User mode process entry point.
//

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    );

VOID
NtProcessStartup(
    PPEB Peb
    )
{
    int argc;
    char **argv;
    char **envp;
    char **dst;
    char *nullPtr = NULL;
    PCH s, d;

    LPWSTR ws,wd;

    ULONG n, DebugParameter;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PUNICODE_STRING p;
    ANSI_STRING AnsiString;
    ULONG NumberOfArgPointers;
    ULONG NumberOfEnvPointers;
    ULONG TotalNumberOfPointers;
    NTSTATUS Status;

    ASSERT( Peb != NULL );
    ProcessParameters = RtlNormalizeProcessParams( Peb->ProcessParameters );

    DebugParameter = 0;
    argc = 0;
    argv = &nullPtr;
    envp = &nullPtr;

    NumberOfEnvPointers = 1;
    NumberOfArgPointers = 1;

    Status = STATUS_SUCCESS;
    
    if (ARGUMENT_PRESENT( ProcessParameters )) {

        //
        // Compute how many pointers are needed to pass argv[] and envp[]
        //

        //
        // Now extract the arguments from the process command line.
        // using whitespace as separator characters.
        //

        p = &ProcessParameters->CommandLine;
        if (p->Buffer == NULL || p->Length == 0) {
            p = &ProcessParameters->ImagePathName;
            }
        RtlUnicodeStringToAnsiString( &AnsiString, p, TRUE );
        s = AnsiString.Buffer;
        n = AnsiString.Length;
        if (s != NULL) {
            while (*s) {
                //
                // Skip over any white space.
                //

                while (*s && *s <= ' ') {
                    s++;
                    }

                //
                // Copy token to next white space separator and null terminate
                //

                if (*s) {
                    NumberOfArgPointers++;
                    while (*s > ' ') {
                        s++;
                        }
                    }
                }
            }
        NumberOfArgPointers++;

        ws = ProcessParameters->Environment;
        if (ws != NULL) {
            while (*ws) {
                NumberOfEnvPointers++;
                while (*ws++) {
                    ;
                    }
                }
            }
        NumberOfEnvPointers++;
        }

    //
    // both counters also have a trailing pointer to NULL, so count this twice for each
    //

    TotalNumberOfPointers = NumberOfArgPointers + NumberOfEnvPointers + 4;

    if (ARGUMENT_PRESENT( ProcessParameters )) {
        DebugParameter = ProcessParameters->DebugFlags;

        NtCurrentTeb()->LastStatusValue = STATUS_SUCCESS;
        dst = RtlAllocateHeap( Peb->ProcessHeap, 0, TotalNumberOfPointers * sizeof( PCH ) );
        if (! dst) {
            Status = NtCurrentTeb()->LastStatusValue;
            if (NT_SUCCESS(Status)) {
                Status = STATUS_NO_MEMORY;
                }
            goto InitFailed;
        }
        argv = dst;
        *dst = NULL;

        //
        // Now extract the arguments from the process command line.
        // using whitespace as separator characters.
        //

        p = &ProcessParameters->CommandLine;
        if (p->Buffer == NULL || p->Length == 0) {
            p = &ProcessParameters->ImagePathName;
            }
        RtlUnicodeStringToAnsiString( &AnsiString, p, TRUE );
        s = AnsiString.Buffer;
        n = AnsiString.Length;
        if (s != NULL) {
            NtCurrentTeb()->LastStatusValue = STATUS_SUCCESS;
            d = RtlAllocateHeap( Peb->ProcessHeap, 0, n+2 );
            if (! d) {
                Status = NtCurrentTeb()->LastStatusValue;
                if (NT_SUCCESS(Status)) {
                    Status = STATUS_NO_MEMORY;
                    }
                goto InitFailed;
            }
            while (*s) {
                //
                // Skip over any white space.
                //

                while (*s && *s <= ' ') {
                    s++;
                    }

                //
                // Copy token to next white space separator and null terminate
                //

                if (*s) {
                    *dst++ = d;
                    argc++;
                    while (*s > ' ') {
                        *d++ = *s++;
                        }
                    *d++ = '\0';
                    }
                }
            }
        *dst++ = NULL;

        envp = dst;
        ws = ProcessParameters->Environment;
        if (ws != NULL) {
            while (*ws) {
                *dst++ = (char *)ws;
                while (*ws++) {
                    ;
                    }
                }
            }
        *dst++ = NULL;
        }

 InitFailed:

    if (DebugParameter != 0) {
        DbgBreakPoint();
        }

    if (NT_SUCCESS(Status)) {
        Status = main( argc, argv, envp, DebugParameter );
        }

    NtTerminateProcess( NtCurrentProcess(), Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\urtl\turtl1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    turtl1.c

Abstract:

    Sub-Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ULONG i;

    DbgPrint( "Entering URTL1 User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }

    DbgPrint( "Leaving URTL1 User Mode Test Program\n" );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\urtl\turtl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    turtl.c

Abstract:

    Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    STRING ImagePathName;
    CHAR ImageNameBuffer[ 128 ];
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    ULONG i, CountBytes, envc, Bogus;
    PSTRING DstString;
    PCH Src, Dst;

#if DBG
    DbgPrint( "Entering URTL User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }
#endif
    envc = 0;
    for (i=0; envp[i]; i++) {
        envc++;
        }
    if (envc > argc) {
        envc = argc;
        }
    CountBytes = sizeof( *ProcessParameters ) +
                 argc * sizeof( STRING ) + envc * sizeof( STRING );
    for (i=0; i<argc; i++) {
        CountBytes += strlen( argv[ i ] );
        }
    for (i=0; i<envc; i++) {
        CountBytes += strlen( envp[ i ] );
        }
    ProcessParameters = (PRTL_USER_PROCESS_PARAMETERS)RtlAllocate( CountBytes );
    DstString = (PSTRING)((PCH)ProcessParameters +
                          sizeof( *ProcessParameters ));
    ProcessParameters->TotalLength = CountBytes;
    ProcessParameters->ArgumentCount = argc;
    ProcessParameters->Arguments = DstString;
    DstString += argc;
    ProcessParameters->VariableCount = envc;
    ProcessParameters->Variables = DstString;
    DstString += envc;
    Dst = (PCH)DstString;
    DstString = ProcessParameters->Arguments;
    for (i=0; i<argc; i++) {
        DstString->Buffer = Dst;
        Src = argv[ i ];
        while (*Dst++ = *Src++) {
            DstString->Length++;
            }
        DstString->MaximumLength = DstString->Length + 1;
        DstString++;
        }
    for (i=0; i<envc; i++) {
        DstString->Buffer = Dst;
        Src = envp[ i ];
        while (*Dst++ = *Src++) {
            DstString->Length++;
            }
        DstString->MaximumLength = DstString->Length + 1;
        DstString++;
        }
    RtlDeNormalizeProcessParameters( ProcessParameters );

    ImagePathName.Buffer = ImageNameBuffer;
    ImagePathName.Length = 0;
    ImagePathName.MaximumLength = sizeof( ImageNameBuffer );
    if (RtlResolveImageName( "TURTL1.SIM", &ImagePathName )) {
        Status = RtlCreateUserProcess( &ImagePathName,
                                       NULL,
                                       NULL,
                                       NULL,
                                       TRUE,
                                       ProcessParameters,
                                       &ProcessInformation,
                                       NULL
                                     );
        if (NT_SUCCESS( Status )) {
            Status = NtResumeThread( ProcessInformation.Thread, &Bogus );
            if (NT_SUCCESS( Status )) {
#if DBG
                DbgPrint( "URTL waiting for URTL1...\n" );
#endif
                Status = NtWaitForSingleObject( ProcessInformation.Process,
                                                TRUE,
                                                NULL
                                              );
                }
            }
        }

#if DBG
    DbgPrint( "Leaving URTL User Mode Test Program\n" );
#endif

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\tools\vadump\vadump.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   vadump.c

Abstract:

    This module contains the routines to dump the virtual address space
    of a process.

Author:

    Lou Perazzoli (loup) 22-May-1989
    Landy Wang (landyw) 02-June-1997

Revision History:

--*/

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <search.h>
#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <heap.h>
#include <dbghelp.h>
#include "psapi.h"

#define SYM_HANDLE INVALID_HANDLE_VALUE
#define DEFAULT_INCR (64*1024)
#define P2KB(x) (((x) * SystemInfo.dwPageSize) / 1024)

#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL ThisSymbol;

ULONG_PTR SystemRangeStart;
LIST_ENTRY VaList;
ULONG_PTR ProcessId;
PCHAR ExeName;
ULONG_PTR IsSystemWithShareCount = 0;
ULONG_PTR PageSize;
ULONG_PTR PtesPerPage;
ULONG_PTR PteWidth;
PVOID PteBase;
PVOID UserPteMax;
ULONG_PTR VaMappedByPageTable;

#define IS_USER_PAGE_TABLE_PAGE(Va) (((PVOID)(Va) >= PteBase) && ((PVOID)(Va) < UserPteMax))

SYSTEM_INFO SystemInfo;

typedef struct _VAINFO {
    LIST_ENTRY Links;
    LIST_ENTRY AllocationBaseHead;
    MEMORY_BASIC_INFORMATION BasicInfo;
} VAINFO, *PVAINFO;

PVAINFO LastAllocationBase;

SIZE_T ReservedBytes;
SIZE_T FreeBytes;
SIZE_T ImageReservedBytes;
SIZE_T ImageFreeBytes;
SIZE_T Displacement;

#define OPTIONS_CODE_TOO            0x1
#define OPTIONS_RAW_SYMBOLS         0x2
#define OPTIONS_VERBOSE             0x4
#define OPTIONS_WORKING_SET         0x8
#define OPTIONS_WORKING_SET_OLD    0x10
#define OPTIONS_PAGE_TABLES        0x20

ULONG Options;

BOOLEAN fSummary = FALSE;
BOOLEAN fFast = FALSE;
BOOLEAN fRunning = FALSE;

#define NOACCESS            0
#define READONLY            1
#define READWRITE           2
#define WRITECOPY           3
#define EXECUTE             4
#define EXECUTEREAD         5
#define EXECUTEREADWRITE    6
#define EXECUTEWRITECOPY    7
#define MAXPROTECT          8

ULONG_PTR ImageCommit[MAXPROTECT];
ULONG_PTR MappedCommit[MAXPROTECT];
ULONG_PTR PrivateCommit[MAXPROTECT];
CHAR LogFileName[256];
FILE *LogFile;
BOOL InCtrlc = FALSE;
typedef struct _WSINFOCOUNTS {
    ULONG_PTR FaultingPc;
    ULONG Faults;
} WSINFOCOUNTS, *PWSINFOCOUNTS;

typedef struct _MODINFO {
    PVOID BaseAddress;
    ULONG VirtualSize;
    LPSTR Name;
    ULONG_PTR CommitVector[MAXPROTECT];
    ULONG WsHits;
    ULONG WsSharedHits;
    ULONG WsPrivateHits;
    BOOL  SymbolsLoaded;
} MODINFO, *PMODINFO;
#define MODINFO_SIZE 100
ULONG ModInfoMax;
MODINFO ModInfo[MODINFO_SIZE];
BOOLEAN bHitModuleMax = FALSE;

typedef struct _SYSTEM_PAGE {
    ULONG_PTR Va;
    PVOID BaseAddress;
    ULONG ResidentPages;
} SYSTEM_PAGE, *PSYSTEM_PAGE;

//
// room for 4 million pagefaults
//
#define MAX_RUNNING_WORKING_SET_BUFFER (4*1024*1024)
ULONG_PTR RunningWorkingSetBuffer[MAX_RUNNING_WORKING_SET_BUFFER];
LONG CurrentWsIndex;

#define INITIAL_WORKING_SET_BLOCK_ENTRYS 4000
PMEMORY_WORKING_SET_INFORMATION WorkingSetInfo;

#define WORKING_SET_BUFFER_ENTRYS 64*1024
PROCESS_WS_WATCH_INFORMATION NewWorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS];

const PCHAR ProtectTable[] = {
    "NoAccess",
    "ReadOnly",
    "Execute",
    "ExecuteRead",
    "ReadWrite",
    "WriteCopy",
    "ExecuteReadWrite",
    "ExecuteWriteCopy",
    "NoAccess",
    "ReadOnly Nocache",
    "Execute  Nocache",
    "ExecuteRead Nocache",
    "ReadWrite Nocache",
    "WriteCopy Nocache",
    "ExecuteReadWrite Nocache",
    "ExecuteWriteCopy Nocache",
    "NoAccess",
    "ReadOnly Guard",
    "Execute  Guard",
    "ExecuteRead Guard",
    "ReadWrite Guard",
    "WriteCopy Guard",
    "ExecuteReadWrite Guard",
    "ExecuteWriteCopy Guard",
    "NoAccess",
    "ReadOnly Nocache Guard",
    "Execute  Nocache Guard",
    "ExecuteRead Nocache Guard",
    "ReadWrite Nocache Guard",
    "WriteCopy Nocache Guard",
    "ExecuteReadWrite Nocache Guard",
    "ExecuteWriteCopy Nocache Guard"
};

const PCHAR SharedTable[] = {
    " ",
    "Shared" };


LIST_ENTRY LoadedHeapList;
int UnknownHeapCount = 0;
typedef struct _LOADED_HEAP_SEGMENT {
    PVOID BaseVa;
    ULONG Length;
    ULONG HitsFromThisSegment;
} LOADED_HEAP_SEGMENT, *PLOADED_HEAP_SEGMENT;

typedef struct _LOADED_HEAP {
    LIST_ENTRY HeapsList;
    LPSTR HeapName;
    ULONG HitsFromThisHeap;
    PVOID HeapAddress;
    ULONG HeapClass;
    LOADED_HEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];
} LOADED_HEAP, *PLOADED_HEAP;

typedef struct _LOADED_THREAD {
    HANDLE ThreadID;
    PBYTE ThreadTEB;
    PBYTE StackBase;
    PBYTE StackEnd;
    ULONG HitsFromThisStack;
} LOADED_THREAD, *PLOADED_THREAD;

ULONG NumberOfThreads = 0;
PLOADED_THREAD TheThreads;

LOGICAL
SetCurrentPrivilege(
    IN LPCTSTR Privilege,      // Privilege to enable/disable
    IN OUT BOOL *bEnablePrivilege  // to enable or disable privilege
    );

VOID
Usage(
    VOID
    );

void
ConvertAppToOem (
    IN unsigned argc,
    IN char* argv[]
    )

/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs.

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    ULONG i;
    LPSTR pSrc;
    LPSTR pDst;
    WCHAR Wide;

    for (i = 0; i < argc; i += 1) {

        pSrc = argv[i];
        pDst = argv[i];

        do {

            //
            // Convert Ansi to Unicode and then to OEM.
            //

            MultiByteToWideChar (CP_ACP,
                                 MB_PRECOMPOSED,
                                 pSrc++,
                                 1,
                                 &Wide,
                                 1);
                
            WideCharToMultiByte (CP_OEMCP,
                                 0,
                                 &Wide,
                                 1,
                                 pDst++,
                                 1,
                                 "_",
                                 NULL);
                
        } while (*pSrc);

    }

    SetFileApisToOEM ();
}


BOOLEAN
FindAndIncHeapContainingThisVa (
    IN PVOID Va,
    IN ULONG ShareCount
    )
{
    PLIST_ENTRY Next;
    PLOADED_HEAP pHeap;
    PLOADED_HEAP_SEGMENT Segment;
    PLOADED_HEAP_SEGMENT LastSegment;

    Next = LoadedHeapList.Flink;

    while (Next != &LoadedHeapList) {

        pHeap = CONTAINING_RECORD(Next, LOADED_HEAP, HeapsList);
        Segment = pHeap->Segments;
        LastSegment = Segment + HEAP_MAXIMUM_SEGMENTS;

        Next = Next->Flink;

        while (Segment < LastSegment) {

            if (Segment->BaseVa == NULL) {
                break;
            }

            if ((Va > Segment->BaseVa) &&
                (Va < (PVOID)((ULONG_PTR)Segment->BaseVa + Segment->Length))) {

                pHeap->HitsFromThisHeap += 1;

                Segment->HitsFromThisSegment += 1;

                if (ShareCount > 1) {
                    fprintf(stderr, "Error: Heap ShareCount > 1, 0x%p\n", Va);
                }

                if (!fSummary) {

                    printf("0x%p ", Va);

                    if (IsSystemWithShareCount) {
                        printf("(%d) ", ShareCount);
                    }

                    printf("%s\n", pHeap->HeapName);
                }
                return TRUE;
            }

            Segment += 1;
        }
    }

    return FALSE;
}

VOID
DumpLoadedHeap (
    IN PLOADED_HEAP LoadedHeap
    )
{
    PLOADED_HEAP_SEGMENT Segment;
    PLOADED_HEAP_SEGMENT LastSegment;

    printf ("%4d pages from %s (class 0x%08x)\n",
                        LoadedHeap->HitsFromThisHeap,
                        LoadedHeap->HeapName,
                        LoadedHeap->HeapClass);

    Segment = LoadedHeap->Segments;
    LastSegment = Segment + HEAP_MAXIMUM_SEGMENTS;

    while (Segment < LastSegment) {

        if (Segment->BaseVa == NULL) {
            break;
        }

        printf("\t0x%p - 0x%p %d pages\n",
                    Segment->BaseVa,
                    (ULONG_PTR)Segment->BaseVa + Segment->Length,
                    Segment->HitsFromThisSegment);

        Segment += 1;
    }
}

VOID
LoadTheHeaps (
    IN HANDLE Process
    )
{
    HEAP TheHeap;
    PLOADED_HEAP LoadedHeap;
    PHEAP *ProcessHeaps;
    HEAP_SEGMENT TheSegment;
    BOOL b;
    ULONG cb, i, j;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PEB ThePeb;

    InitializeListHead (&LoadedHeapList);

    Status = NtQueryInformationProcess (Process,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        fprintf(stderr, "NtQueryInformationProcess for ProcessBasicInformation"
                        " failed %lx\n", GetLastError());
        return;
    }

    //
    // Read the process's PEB.
    //

    b = ReadProcessMemory (Process,
                           ProcessInformation.PebBaseAddress,
                           &ThePeb,sizeof(ThePeb),
                           NULL);
    if (!b) {
        return;
    }

    //
    // Allocate space for and read the array of process heap pointers.
    //

    cb = ThePeb.NumberOfHeaps * sizeof( PHEAP );

    ProcessHeaps = LocalAlloc(LMEM_ZEROINIT,cb);
    if (ProcessHeaps == NULL) {
        return;
    }

    b = ReadProcessMemory (Process,
                           ThePeb.ProcessHeaps,
                           ProcessHeaps,
                           cb,
                           NULL);

    if (b) {

        for (i = 0; i < ThePeb.NumberOfHeaps; i += 1) {

            //
            // Read the heap.
            //

            b = ReadProcessMemory (Process,
                                   ProcessHeaps[i],
                                   &TheHeap,
                                   sizeof(TheHeap),
                                   NULL);
            if (!b) {
                break;
            }

            //
            // We got the heap, now initialize our heap structure
            //

            LoadedHeap = LocalAlloc (LMEM_ZEROINIT, sizeof(*LoadedHeap));

            if (!LoadedHeap) {
                break;
            }

            LoadedHeap->HeapAddress = ProcessHeaps[i];
            LoadedHeap->HeapClass = TheHeap.Flags & HEAP_CLASS_MASK;

            switch ( LoadedHeap->HeapClass ) {
                case HEAP_CLASS_0:
                    LoadedHeap->HeapName = "Process Heap";
                    break;

                case HEAP_CLASS_1:
                    LoadedHeap->HeapName = HeapAlloc(GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    16);
                    if (LoadedHeap->HeapName) {
                        sprintf(LoadedHeap->HeapName,
                                "Private Heap %d",
                                UnknownHeapCount++);
                    } else {
                        LoadedHeap->HeapName = "Private Heap";
                    }
                    break;

                case HEAP_CLASS_2:
                    LoadedHeap->HeapName = "Kernel Heap";
                    break;

                case HEAP_CLASS_3:
                    LoadedHeap->HeapName = "GDI Heap";
                    break;

                case HEAP_CLASS_4:
                    LoadedHeap->HeapName = "User Heap";
                    break;

                case HEAP_CLASS_5:
                    LoadedHeap->HeapName = "Console Heap";
                    break;

                case HEAP_CLASS_6:
                    LoadedHeap->HeapName = "User Desktop Heap";
                    break;

                case HEAP_CLASS_7:
                    LoadedHeap->HeapName = "Csrss Shared Heap";
                    break;

                default:
                    LoadedHeap->HeapName = HeapAlloc(GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    16);
                    if (LoadedHeap->HeapName) {
                        sprintf(LoadedHeap->HeapName,
                                    "UNKNOWN Heap %d",
                                    UnknownHeapCount++);
                    } else {
                        LoadedHeap->HeapName = "UNKNOWN Heap";
                    }
                    break;
            }

            //
            // Now go through the heap segments to compute the
            // area covered by the heap.
            //

            for (j = 0; j < HEAP_MAXIMUM_SEGMENTS; j += 1) {

                if (!TheHeap.Segments[j]) {
                    break;
                }

                b = ReadProcessMemory (Process,
                                       TheHeap.Segments[j],
                                       &TheSegment,
                                       sizeof(TheSegment),
                                       NULL);
                if (!b) {
                    break;
                }

                LoadedHeap->Segments[j].BaseVa = TheSegment.BaseAddress;
                LoadedHeap->Segments[j].Length = TheSegment.NumberOfPages *
                                                    SystemInfo.dwPageSize;
            }

            InsertTailList (&LoadedHeapList,&LoadedHeap->HeapsList);
        }
    }

    LocalFree (ProcessHeaps);
    return;
}

BOOLEAN
FindAndIncStackContainingThisVa (
    IN PBYTE Va,
    IN ULONG ShareCount
    )
{
    ULONG i;
    for (i = 0 ; i < NumberOfThreads ; i++) {
        if ((Va > TheThreads[i].StackBase) &&
            (Va < TheThreads[i].StackEnd)) {
            TheThreads[i].HitsFromThisStack++;
            if (ShareCount > 1) {
                fprintf(stderr, "Error: Stack ShareCount > 1, 0x%p\n", Va);
            }
            if (!fSummary) {
                printf("0x%p ", Va);
                if (IsSystemWithShareCount) {
                    printf("(%d) ", ShareCount);
                }
                printf("Stack for ThreadID %p\n", TheThreads[i].ThreadID);
            }
            return TRUE;
        }
    }
    return FALSE;
}


VOID
DumpLoadedStacks (
    VOID
    )
{
    ULONG i;
    for (i = 0 ; i < NumberOfThreads ; i++) {
        printf("%4d pages from stack for thread %p\n",
                TheThreads[i].HitsFromThisStack,
                TheThreads[i].ThreadID);
    }
    return;
}

VOID
LoadTheThreads (
    IN HANDLE Process,
    IN ULONG_PTR ProcessID
    )
{
    BOOL b;
    ULONG i;
    NTSTATUS Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    TEB TheTeb;
    HANDLE Thread;
    OBJECT_ATTRIBUTES Obja;

    //
    // To get the thread IDs of the process, load the system process info
    // and look for the matching process.  For each thread in it, open the
    // thread to get the Teb address, then, read the stack information from
    // the Teb in the processes memory.
    //

    Status = NtQuerySystemInformation(
            SystemProcessInformation,
            &RunningWorkingSetBuffer,       // not in use yet for WS
            512*1024,                       // don't give the whole thing
                                            // or it will be probed
            NULL
            );

    if (!NT_SUCCESS(Status)) {
        fprintf(stderr, "NtQuerySystemInformation for SystemProcessInformation"
                        " failed %lx\n", GetLastError());
        return;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &RunningWorkingSetBuffer;
    while (ProcessInfo) {
        if (ProcessInfo->UniqueProcessId == (HANDLE)ProcessID) {
            break;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            ProcessInfo = NULL;
            break;
        }

        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) ((PBYTE)ProcessInfo +
                        ProcessInfo->NextEntryOffset);
    }
    if (ProcessInfo == NULL) {
        fprintf(stderr, "Error: Failed to find process for Stack lookup\n");
        return;
    }

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) (ProcessInfo + 1);


    NumberOfThreads = ProcessInfo->NumberOfThreads;
    TheThreads = (PLOADED_THREAD) LocalAlloc(LMEM_ZEROINIT,
                                    sizeof(LOADED_THREAD) * NumberOfThreads);

    if (TheThreads == NULL) {
        printf("FAILURE: Couldn't allocate memory for thread database\n");
        ExitProcess(0);
    }

    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);

    for (i = 0; i < NumberOfThreads; i += 1, ThreadInfo += 1) {

        Status = NtOpenThread (&Thread,
                               MAXIMUM_ALLOWED,
                               &Obja,
                               &ThreadInfo->ClientId);

        if (!NT_SUCCESS( Status )) {
            fprintf(stderr, "NtOpenThread %p failed %lx\n",
                            ThreadInfo->ClientId.UniqueThread,
                            GetLastError());
            return;
        }

        Status = NtQueryInformationThread (Thread,
                                           ThreadBasicInformation,
                                           &ThreadBasicInfo,
                                           sizeof( ThreadBasicInfo ),
                                           NULL);

        if (!NT_SUCCESS( Status )) {
            fprintf(stderr, "NtQueryInformationThread for"
                            " ThreadBasicInformation failed %lx\n",
                            GetLastError());
            CloseHandle (Thread);
            return;
        }

        //
        // Read the threads's TEB.
        //

        b = ReadProcessMemory (Process,
                               ThreadBasicInfo.TebBaseAddress,
                               &TheTeb,
                               sizeof(TheTeb),
                               NULL);

        if (!b) {
            fprintf(stderr, "ReadProcessMemory for"
                            " TEB %d failed %lx\n",
                            i,
                            GetLastError());
            CloseHandle (Thread);
            return;
        }

        TheThreads[i].ThreadID = TheTeb.ClientId.UniqueThread;

        TheThreads[i].ThreadTEB = (PBYTE)ThreadBasicInfo.TebBaseAddress;
        TheThreads[i].StackBase = TheTeb.DeallocationStack;
        TheThreads[i].StackEnd = TheTeb.NtTib.StackBase;

        CloseHandle(Thread);
    }
}

PMODINFO
LocateModInfo(
    PVOID Address
    )
{
    ULONG i;
    for (i=0;i<ModInfoMax;i++){
        if ( Address >= ModInfo[i].BaseAddress &&
             Address <= (PVOID)((ULONG_PTR)ModInfo[i].BaseAddress+ModInfo[i].VirtualSize) ) {
            return &ModInfo[i];
        }
    }
    return NULL;
}

VOID
CaptureWorkingSet(
    HANDLE Process
    )
{
    ULONG_PTR NumEntries = INITIAL_WORKING_SET_BLOCK_ENTRYS;
    BOOLEAN Done;
    SIZE_T Size;
    DWORD Error;

    Done = FALSE;
    while (!Done) {

        Size = FIELD_OFFSET(MEMORY_WORKING_SET_INFORMATION, WorkingSetInfo) +
                NumEntries * sizeof(MEMORY_WORKING_SET_BLOCK);

        WorkingSetInfo = HeapAlloc(GetProcessHeap(), 0, Size);
        if (WorkingSetInfo == NULL) {
            printf("FAILURE Couldn't allocate working set info buffer\n");
            exit(0);
        }

        if (!QueryWorkingSet(Process, WorkingSetInfo, (DWORD) Size)) {
            Error = GetLastError();
            if (Error != ERROR_BAD_LENGTH) {
                printf("FAILURE query working set %lu\n", Error);
                exit(0);
            }
        }
        if (WorkingSetInfo->NumberOfEntries > NumEntries) {
            //
            // Not big enough so increase the number of entries and
            // free the old one.
            //

            NumEntries = WorkingSetInfo->NumberOfEntries + 100;  // Add in some fudge for growth
            HeapFree(GetProcessHeap(), 0, WorkingSetInfo);
        } else {
            Done = TRUE;
        }
    }
}

int
__cdecl
ulcomp(
    const void *e1,
    const void *e2
    )
{
    PULONG p1;
    PULONG p2;

    p1 = (PULONG)e1;
    p2 = (PULONG)e2;

    if (*p1 > *p2) {
        return 1;
    }
    if (*p1 < *p2) {
        return -1;
    }

    return 0;
}

int
__cdecl
WSBlockComp(
    const void *e1,
    const void *e2
    )
{
    PMEMORY_WORKING_SET_BLOCK p1;
    PMEMORY_WORKING_SET_BLOCK p2;

    p1 = (PMEMORY_WORKING_SET_BLOCK)e1;
    p2 = (PMEMORY_WORKING_SET_BLOCK)e2;

    if (p1->VirtualPage > p2->VirtualPage) {
        return 1;
    }

    if (p1->VirtualPage < p2->VirtualPage) {
        return -1;
    }

    return 0;
}

int
__cdecl
wsinfocomp(
    const void *e1,
    const void *e2
    )
{
    PWSINFOCOUNTS p1;
    PWSINFOCOUNTS p2;

    p1 = (PWSINFOCOUNTS)e1;
    p2 = (PWSINFOCOUNTS)e2;

    return (p1->Faults - p2->Faults);
}

BOOL
CtrlcH (
    IN DWORD dwCtrlType
    )
{
    PWSINFOCOUNTS    WsInfoCount;
    LONG             RunIndex;
    LONG             CountIndex;
    IMAGEHLP_MODULE  Mi;
    ULONG_PTR        Offset;
    CHAR             Line[256];

    if ( dwCtrlType != CTRL_C_EVENT ) {
        return FALSE;
    }

    if ((Options & (OPTIONS_WORKING_SET | OPTIONS_WORKING_SET_OLD)) == OPTIONS_WORKING_SET) {
        ;
    }
    else {
        return FALSE;
    }

    Mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);
    InCtrlc = TRUE;

    //
    // Sort the running working set buffer
    //

    qsort((void *)RunningWorkingSetBuffer,(size_t)CurrentWsIndex,(size_t)sizeof(ULONG),ulcomp);

    WsInfoCount = LocalAlloc(LMEM_ZEROINIT,CurrentWsIndex*sizeof(*WsInfoCount));

    if ( !WsInfoCount ) {
        ExitProcess(0);
    }

    //
    // Sum unique PC values
    //

    CountIndex = 0;
    RunIndex = 0;
    WsInfoCount[CountIndex].FaultingPc = RunningWorkingSetBuffer[RunIndex];
    WsInfoCount[CountIndex].Faults++;

    for(RunIndex = 1; RunIndex < CurrentWsIndex; RunIndex++){
        if ( WsInfoCount[CountIndex].FaultingPc == RunningWorkingSetBuffer[RunIndex] ) {
            WsInfoCount[CountIndex].Faults++;
        }
        else {
            CountIndex++;
            WsInfoCount[CountIndex].FaultingPc = RunningWorkingSetBuffer[RunIndex];
            WsInfoCount[CountIndex].Faults++;
        }
    }

    //
    // Now sort the counted pc/fault count pairs
    //

    qsort(WsInfoCount,CountIndex,sizeof(*WsInfoCount),wsinfocomp);

    //
    // Now print the sorted pc/fault count pairs
    //

    for ( RunIndex = CountIndex-1; RunIndex >= 0 ; RunIndex-- ) {

        if (!SymGetModuleInfo((HANDLE)ProcessId, WsInfoCount[RunIndex].FaultingPc, &Mi )) {
            printf("%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
            if ( LogFile ) {
                fprintf(LogFile,"%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
            }

        } else {

            if (SymGetSymFromAddr((HANDLE)ProcessId, WsInfoCount[RunIndex].FaultingPc, &Displacement, ThisSymbol )) {
                Offset = (ULONG_PTR)WsInfoCount[RunIndex].FaultingPc - ThisSymbol->Address;
                if ( Offset ) {
                    sprintf(Line,"%8d, %s+%x\n",WsInfoCount[RunIndex].Faults,ThisSymbol->Name,Offset);
                } else {
                    sprintf(Line,"%8d, %s\n",WsInfoCount[RunIndex].Faults, ThisSymbol->Name);
                }
                printf("%s",Line);
                if ( LogFile ) {
                    fprintf(LogFile,"%s",Line);
                }
            } else {
                printf("%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
                if ( LogFile ) {
                    fprintf(LogFile,"%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
                }
            }
        }
    }
    exit(1);
    return FALSE;
}


VOID
DumpWorkingSetSnapshot (
    IN HANDLE Process
    )
{
    LOGICAL NewLine;
    PSYSTEM_PAGE SystemPageBase;
    ULONG i;
    ULONG_PTR BaseVa = 0;
    ULONG_PTR Va = 0;
    ULONG_PTR PteIndex;
    ULONG_PTR BaseAddress;
    ULONG SystemPages = 0;
    ULONG HeapPages = 0;
    ULONG StackPages = 0;
    ULONG MappedPages = 0;
    ULONG SharedMappedPages = 0;
    ULONG PrivateMappedPages = 0;
    ULONG DataPages = 0;
    ULONG SharedDataPages = 0;
    ULONG PrivateDataPages = 0;
    ULONG ErrorPages = 0;
    ULONG QuickPages = 0;
    ULONG LpcPages = 0;
    ULONG CsrSharedPages = 0;
    ULONG SharedCsrSharedPages = 0;
    ULONG TebPages = 0;
    ULONG TotalStaticCodeData = 0;
    ULONG TotalStaticCodeDataShared = 0;
    ULONG TotalStaticCodeDataPrivate = 0;
    ULONG TotalDynamicData = 0;
    ULONG TotalDynamicDataShared = 0;
    ULONG TotalDynamicDataPrivate = 0;
    ULONG TotalSystem = 0;
    ULONG Total, Shareable, Private, Shared;
    PMODINFO Mi;
    PLOADED_HEAP pHeap;
    PLIST_ENTRY Next;
    MEMORY_BASIC_INFORMATION BasicInfo;
    BOOL b;
    ULONG Mstack[7];
    WCHAR FileName[MAX_PATH+1];
    PWCHAR pwch;
    ULONG ShareCount;
    BOOLEAN IsShareable;
    PMEMORY_WORKING_SET_BLOCK WorkingSetBlock;
    PMEMORY_WORKING_SET_BLOCK LastWorkingSetBlock;
    ULONG PageTablePageCount;
    ULONG PageTablePageMax;
    ULONG_PTR SPBase;
    ULONG_PTR MIBase;
    ULONG_PTR MIEnd;
    ULONG_PTR HSBase;
    ULONG_PTR HSEnd;
    ULONG_PTR SSBase;
    ULONG_PTR SSEnd;

    NewLine = FALSE;

    if (Options & OPTIONS_RAW_SYMBOLS) {
        fSummary = FALSE;
    }

    qsort (&WorkingSetInfo->WorkingSetInfo[0],
           WorkingSetInfo->NumberOfEntries,
           sizeof(MEMORY_WORKING_SET_BLOCK),
           WSBlockComp);

    //
    // Count the number of user page table page references that faulted.
    //

    PageTablePageCount = 0;
    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];
    LastWorkingSetBlock = WorkingSetBlock + WorkingSetInfo->NumberOfEntries;

    while (WorkingSetBlock < LastWorkingSetBlock) {
        Va = WorkingSetBlock->VirtualPage << 12;
        if (IS_USER_PAGE_TABLE_PAGE(Va)) {
            PageTablePageCount += 1;
        }
        WorkingSetBlock += 1;
    }

    //
    // Allocate memory to hold the user page table page references.
    //

    SystemPageBase = NULL;
    PageTablePageMax = PageTablePageCount;

    if (PageTablePageMax != 0) {

        SystemPageBase = LocalAlloc (LMEM_ZEROINIT,
                                     PageTablePageMax * sizeof(SYSTEM_PAGE));

        if (SystemPageBase == NULL) {
            return;
        }
    }

    PageTablePageCount = 0;
    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];

    while (WorkingSetBlock < LastWorkingSetBlock) {

        Va = WorkingSetBlock->VirtualPage << 12;

        IsSystemWithShareCount |= (ULONG_PTR)WorkingSetBlock->ShareCount;

        if (IS_USER_PAGE_TABLE_PAGE(Va)) {

            SystemPageBase[PageTablePageCount].Va = Va;

            PteIndex = (Va - (ULONG_PTR)PteBase) / PteWidth;
            BaseAddress = (PteIndex / PtesPerPage) * VaMappedByPageTable;

            SystemPageBase[PageTablePageCount].BaseAddress = (PVOID)BaseAddress;

            PageTablePageCount += 1;
        }

        WorkingSetBlock += 1;
    }

    //
    // Attribute each user space page into the system page that backs it.
    //

    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];

    LastWorkingSetBlock = WorkingSetBlock + WorkingSetInfo->NumberOfEntries;

    while (WorkingSetBlock < LastWorkingSetBlock) {

        Va = WorkingSetBlock->VirtualPage << 12;

        if (Va < SystemRangeStart) {

            for (i = 0; i < PageTablePageCount; i += 1) {

                if ((Va >= (ULONG_PTR)SystemPageBase[i].BaseAddress) &&
                    (Va < ((ULONG_PTR)SystemPageBase[i].BaseAddress + VaMappedByPageTable))) {

                    SystemPageBase[i].ResidentPages += 1;
                    break;
                }
            }
        }

        WorkingSetBlock += 1;
    }

    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];

    for ( ; WorkingSetBlock < LastWorkingSetBlock; WorkingSetBlock += 1) {

        Va = WorkingSetBlock->VirtualPage << 12;
        IsShareable = (BOOLEAN) (WorkingSetBlock->Shared == 1);
        ShareCount = (ULONG) WorkingSetBlock->ShareCount;

        if (Va >= SystemRangeStart) {

            if ((!fSummary || (Options & OPTIONS_PAGE_TABLES)) &&
                (IS_USER_PAGE_TABLE_PAGE(Va))) {

                //
                // For each system page, dump the range spanned, number of
                // resident pages, and the modules and heaps covered.
                //

                for (i = 0; Va != SystemPageBase[i].Va; i += 1) {
                    ;
                }

                SPBase = (ULONG_PTR) SystemPageBase[i].BaseAddress;

                if (NewLine) {
                    printf("\n");
                    NewLine = FALSE;
                }

                printf("0x%p -> (0x%p : 0x%p) %4d "
                        "Resident Pages\n",
                        Va,
                        SPBase,
                        SPBase + VaMappedByPageTable - 1,
                        SystemPageBase[i].ResidentPages);

                //
                // Figure out which modules are covered by this
                // page table page. If the base of the module is
                // within the page, or the base+size of the
                // module is covered, then it is in the page
                //

                for (i = 0 ; i < ModInfoMax ; i += 1) {

                    MIBase = (ULONG_PTR) ModInfo[i].BaseAddress;

                    MIEnd = MIBase + (ULONG_PTR)ModInfo[i].VirtualSize;

                    if ((MIEnd >= SPBase) &&
                        (MIBase < SPBase + VaMappedByPageTable)) {

                        printf("              (0x%p : 0x%p) "
                                "-> %s\n",
                                MIBase,
                                MIEnd,
                                ModInfo[i].Name
                                );
                        NewLine = TRUE;
                    }
                }

                //
                // Figure out which heaps are covered by this
                // page table page.
                //

                Next = LoadedHeapList.Flink;

                while (Next != &LoadedHeapList) {

                    pHeap = CONTAINING_RECORD (Next,
                                               LOADED_HEAP,
                                               HeapsList);
                    Next = Next->Flink;

                    for (i = 0 ; i < HEAP_MAXIMUM_SEGMENTS ; i += 1) {

                        if (pHeap->Segments[i].BaseVa == NULL) {
                            break;
                        }

                        HSBase = (ULONG_PTR) pHeap->Segments[i].BaseVa;
                        HSEnd = HSBase +
                                    (ULONG_PTR)pHeap->Segments[i].Length;
                        if ((HSEnd >= SPBase) &&
                            (HSBase < (SPBase + VaMappedByPageTable))) {

                            printf("              (0x%p : 0x%p) "
                                    "-> %s segment %d\n",
                                    HSBase,
                                    HSEnd,
                                    pHeap->HeapName,
                                    i);

                            NewLine = TRUE;
                        }
                    }
                }

                //
                // Figure out which stacks are covered by this
                // page table page.
                //

                for (i = 0 ; i < NumberOfThreads ; i += 1) {
                    SSBase = (ULONG_PTR)TheThreads[i].StackBase;
                    SSEnd = (ULONG_PTR)TheThreads[i].StackEnd;

                    if ((SSEnd >= SPBase) &&
                        (SSBase < (SPBase + VaMappedByPageTable))) {

                        printf("              (0x%p : 0x%p) "
                                "-> Stack for thread %d\n",
                                SSBase,
                                SSEnd,
                                i);

                        NewLine = TRUE;
                    }
                }
            }

            SystemPages += 1;
            TotalSystem += 1;

            continue;
        }

        Mi = LocateModInfo ((PVOID)Va);

        if (Mi == NULL) {

            if (FindAndIncHeapContainingThisVa ((PVOID)Va, ShareCount)) {
                HeapPages += 1;
                TotalDynamicData += 1;
                TotalDynamicDataPrivate += 1;
                continue;
            }

            if (FindAndIncStackContainingThisVa ((PVOID)Va, ShareCount)) {
                StackPages += 1;
                TotalDynamicData += 1;
                TotalDynamicDataPrivate += 1;
                continue;
            }

            if (VirtualQueryEx (Process,
                                (LPVOID) Va,
                                &BasicInfo,
                                sizeof(BasicInfo)) ) {

                if (BasicInfo.Type == MEM_MAPPED) {
                    if (ProcessId == 0xffffffff) {
                        //
                        // Look to see if this is a quick thread message
                        // stack window
                        //

                        b = ReadProcessMemory(
                                        Process,
                                        BasicInfo.AllocationBase,
                                        &Mstack,
                                        sizeof(Mstack),
                                        NULL);
                        if (!b) {
                            goto unknownmapped;
                        }
                        if ((Mstack[0] >= Mstack[1]) &&
                            (Mstack[2] == 0x10000)) {

                            if (!fSummary) {
                                printf("0x%p ", Va);
                                if (IsSystemWithShareCount) {
                                    printf("(%d) ", ShareCount);
                                }
                                printf("CSRQUICK Base 0x%p\n", BasicInfo.AllocationBase);
                            }
                            QuickPages += 1;
                            TotalDynamicData += 1;
                            TotalDynamicDataPrivate += 1;
                            if (ShareCount > 1) {
                                fprintf(stderr, "Error: QuickPage ShareCount > 1, "
                                                " 0x%x\n", Va);
                            }

                            continue;
                        }

                        if ((BasicInfo.AllocationBase == NtCurrentPeb()->ReadOnlySharedMemoryBase) ||
                                (Va == (ULONG_PTR)NtCurrentPeb()->ReadOnlySharedMemoryBase)) {
                            if (!fSummary) {
                                printf("0x%p", Va);
                                if (IsSystemWithShareCount) {
                                    printf("(%d) ", ShareCount);
                                }
                                printf("CSRSHARED Base 0x%p", BasicInfo.AllocationBase);
                                }
                            TotalDynamicData++;
                            CsrSharedPages++;
                            if (IsShareable) {
                                if (ShareCount > 1) {
                                    TotalDynamicDataShared++;
                                    SharedCsrSharedPages++;
                                }
                            } else {
                                fprintf(stderr, "Error: CsrShared not "
                                               " sharable, 0x%x\n", Va);
                            }

                            continue;
                        }

                        // Fall Through if not found
                    }

                    //
                    // It's mapped but wasn't CSRSS special page.
                    //
unknownmapped:
                    if ( !fSummary ) {
                        DWORD cch;

                        //
                        // See if we can figure out the name associated with
                        // this mapped region
                        //

                        cch = GetMappedFileNameW(Process,
                                                 (LPVOID) Va,
                                                 FileName,
                                                 sizeof(FileName));

                        if (cch != 0) {
                            //
                            // Now go back through the string to
                            // find the seperator
                            //

                            pwch = FileName + cch;
                            while ( *pwch != (WCHAR)'\\' ) {
                                pwch--;
                                }
                            pwch++;

                            printf("0x%p ", Va);
                            if (IsSystemWithShareCount) {
                                printf("(%d) ", ShareCount);
                            }
                            printf("DATAFILE_MAPPED Base 0x%p %ws\n",
                                    BasicInfo.AllocationBase,
                                    pwch
                                    );
                        } else {
                            printf("0x%p ", Va);
                            if (IsSystemWithShareCount) {
                                printf("(%d) ", ShareCount);
                            }
                            printf("UNKNOWN_MAPPED Base 0x%p\n", BasicInfo.AllocationBase);
                        }
                    }

                    TotalDynamicData++;
                    MappedPages++;
                    if (IsShareable) {
                        if (ShareCount > 1) {
                            TotalDynamicDataShared++;
                            SharedMappedPages++;
                        }
                    } else {
                        TotalDynamicDataPrivate++;
                        PrivateMappedPages++;
                    }

                    continue;
                }

                //
                // Not Mapped section
                //

                for (i = 0 ; i < NumberOfThreads; i += 1) {

                    if ((ULONG_PTR) TheThreads[i].ThreadTEB == Va) {
                        if (!fSummary) {
                            printf("0x%p ", Va);
                            if (IsSystemWithShareCount) {
                                printf("(%d) ", ShareCount);
                            }
                            printf("TEB Base 0x%p\n",
                                    BasicInfo.AllocationBase);
                        }
                        TotalDynamicData++;
                        TebPages++;
                        if (ShareCount > 1) {
                            fprintf(stderr, "Error: TEB ShareCount > 1, "
                                            " 0x%x\n", Va);
                        }
                        TotalDynamicDataPrivate++;
                        continue;
                    }
                }

                //
                // Wasn't a TEB either it must have been VirtualAlloc'd.
                //

                if (!fSummary) {
                    printf("0x%p ", Va);
                    if (IsSystemWithShareCount) {
                        printf("(%d) ", ShareCount);
                    }
                    printf("PRIVATE Base 0x%p\n", BasicInfo.AllocationBase );
                }

                TotalDynamicData += 1;
                DataPages += 1;

                if (Va != MM_SHARED_USER_DATA_VA) {
                    if (ShareCount > 1) {
                        fprintf(stderr, "Error: Private ShareCount > 1, "
                                        " 0x%x %x\n", Va, ShareCount);
                    }
                    TotalDynamicDataPrivate += 1;
                    PrivateDataPages += 1;
                }

                continue;
            }

            //
            // Hmm, couldn't find out about the page.  Say it's data.
            //
            if (!fSummary) {
                printf("0x%p ", Va);
                if (IsSystemWithShareCount) {
                    printf("(%d) ", ShareCount);
                }
                printf("UNKOWN\n");
            }

            TotalDynamicData++;
            DataPages++;
            if (IsShareable) {
                if (ShareCount > 1) {
                    TotalDynamicDataShared++;
                    SharedDataPages++;
                }
            }
            else {
                TotalDynamicDataPrivate++;
                PrivateDataPages++;
            }

            continue;
        }

        //
        // It's from a module.
        //

        Mi->WsHits += 1;
        TotalStaticCodeData += 1;

        if (IsShareable) {
            if (ShareCount > 1) {
                TotalStaticCodeDataShared += 1;
                Mi->WsSharedHits += 1;
            }
        }
        else {
            Mi->WsPrivateHits += 1;
            TotalStaticCodeDataPrivate += 1;
        }

        if ( !fSummary ) {
            printf("0x%p ", Va);
            if (IsSystemWithShareCount) {
                printf("(%d) ", ShareCount);
            }
            printf("%s\n",Mi->Name);
            if (Options & OPTIONS_RAW_SYMBOLS) {
                if (SymGetSymFromAddr((HANDLE)ProcessId,
                                            Va,
                                            &Displacement,
                                            ThisSymbol )) {

                    BaseVa = Va;
                    if (ThisSymbol->Size) {
                        printf("\t(%4x) %s\n",
                                ThisSymbol->Size,
                                ThisSymbol->Name
                                );
                        Va += ThisSymbol->Size;
                        while ((Va < BaseVa + 4096) &&
                                ThisSymbol->Size) {

                            if (SymGetSymFromAddr((HANDLE)ProcessId,
                                                    Va,
                                                    &Displacement,
                                                    ThisSymbol)) {
                                printf("\t(%4x) %s\n",
                                            ThisSymbol->Size,
                                            ThisSymbol->Name
                                            );
                                Va += ThisSymbol->Size;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
                else {
                    ErrorPages++;
                }
            }
        }
    }

    if (!fSummary || (Options & OPTIONS_PAGE_TABLES)) {
        printf("\n");
    }
    
    if (IsSystemWithShareCount) {
        printf("Category                        Total        Private Shareable    Shared\n");
        printf("                           Pages    KBytes    KBytes    KBytes    KBytes\n");
        } else {
            printf("Category                        Total        Private Shareable\n");
            printf("                           Pages    KBytes    KBytes    KBytes\n");
    }

    Total = PageTablePageCount;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
            "      Page Table Pages     %5d %9d %9d %9d %9d\n" :
            "      Page Table Pages     %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = SystemPages - PageTablePageCount;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
            "      Other System         %5d %9d %9d %9d %9d\n" :
            "      Other System         %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalStaticCodeData;
    Private = TotalStaticCodeDataPrivate;
    Shared = TotalStaticCodeDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Code/StaticData      %5d %9d %9d %9d %9d\n" :
        "      Code/StaticData      %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = HeapPages;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Heap                 %5d %9d %9d %9d %9d\n" :
        "      Heap                 %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = StackPages;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Stack                %5d %9d %9d %9d %9d\n" :
        "      Stack                %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );
    if ( ProcessId == 0xffffffff ) {

        Total = QuickPages;
        Private = Total;
        Shared = 0;
        Shareable = 0;
        printf(IsSystemWithShareCount ?
            "      Quick Thread Stack   %5d %9d %9d %9d %9d\n" :
            "      Quick Thread Stack   %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

        Total = LpcPages;
        Private = 0;
        Shareable = 0;
        Shared = 0;
        printf(IsSystemWithShareCount ?
            "      Lpc Message Windows  %5d %9d %9d %9d %9d\n" :
            "      Lpc Message Windows  %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

        Total = CsrSharedPages;
        Private = 0;
        Shared = SharedCsrSharedPages;
        Shareable = Total - Shared - Private;
        printf(IsSystemWithShareCount ?
            "      Csr Shared Memory    %5d %9d %9d %9d %9d\n" :
            "      Csr Shared Memory    %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );
        }

    Total = TebPages;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Teb                  %5d %9d %9d %9d %9d\n" :
        "      Teb                  %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = MappedPages;
    Private = PrivateMappedPages;
    Shared = SharedMappedPages;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Mapped Data          %5d %9d %9d %9d %9d\n" :
        "      Mapped Data          %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = DataPages;
    Private = PrivateDataPages;
    Shared = SharedDataPages;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Other Data           %5d %9d %9d %9d %9d\n" :
        "      Other Data           %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );


    printf("\n");
    Total = TotalStaticCodeData;
    Private = TotalStaticCodeDataPrivate;
    Shared = TotalStaticCodeDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Total Modules        %5d %9d %9d %9d %9d\n" :
        "      Total Modules        %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalDynamicData;
    Private = TotalDynamicDataPrivate;
    Shared = TotalDynamicDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Total Dynamic Data   %5d %9d %9d %9d %9d\n" :
        "      Total Dynamic Data   %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalSystem;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Total System         %5d %9d %9d %9d %9d\n" :
        "      Total System         %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalSystem + TotalDynamicData + TotalStaticCodeData;
    Private = TotalSystem + TotalDynamicDataPrivate +
                TotalStaticCodeDataPrivate;
    Shared =  TotalDynamicDataShared + TotalStaticCodeDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "Grand Total Working Set    %5d %9d %9d %9d %9d\n" :
        "Grand Total Working Set    %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );


    printf("\nModule Working Set Contributions in pages\n");
    printf(IsSystemWithShareCount ?
            "    Total   Private Shareable    Shared Module\n" :
            "    Total   Private Shareable Module\n"
            );

    for (i=0 ; i < ModInfoMax ; i++){
        if ( ModInfo[i].WsHits ) {
            if (IsSystemWithShareCount) {
                printf("%9d %9d %9d %9d %s\n",
                                ModInfo[i].WsHits,
                                ModInfo[i].WsPrivateHits,
                                ModInfo[i].WsHits -
                                    ModInfo[i].WsSharedHits -
                                    ModInfo[i].WsPrivateHits,
                                ModInfo[i].WsSharedHits,
                                ModInfo[i].Name
                                );
                }
            else {
                printf("%9d %9d %9d %s\n",
                                ModInfo[i].WsHits,
                                ModInfo[i].WsPrivateHits,
                                ModInfo[i].WsHits -
                                    ModInfo[i].WsSharedHits -
                                    ModInfo[i].WsPrivateHits,
                                ModInfo[i].Name
                                );
                }
            }
        }

    printf("\nHeap Working Set Contributions\n");

    Next = LoadedHeapList.Flink;

    while ( Next != &LoadedHeapList ) {
        pHeap = CONTAINING_RECORD(Next, LOADED_HEAP, HeapsList);
        Next = Next->Flink;
        DumpLoadedHeap(pHeap);
    }

    printf("\nStack Working Set Contributions\n");
    DumpLoadedStacks();

#if 0
    if ( Options & OPTIONS_VERBOSE ) {
        printf("Raw Working Set Blocks\n\n");
        for (i = 0; i < WorkingSetInfo->NumberOfEntries ; i++) {
            printf("%d %p\n", i, (ULONG_PTR) WorkingSetInfo->WorkingSetInfo[i]);
            i++;
            }
        }
#endif

    if (SystemPageBase != NULL) {
        LocalFree (SystemPageBase);
    }
}


VOID
DumpWorkingSet (
    IN HANDLE Process
    )
{
    ULONG i;
    PMODINFO Mi,Mi2;
    NTSTATUS Status;
    ULONG_PTR Offset;
    CHAR Line[256];
    BOOLEAN didone;
    HANDLE ScreenHandle;
    INPUT_RECORD InputRecord;
    DWORD NumRead;

    ScreenHandle = GetStdHandle (STD_INPUT_HANDLE);

    if (ScreenHandle == NULL) {
        printf("Error obtaining screen handle, error was: 0x%lx\n",
                GetLastError());
        ExitProcess(1);
    }

    Status = NtSetInformationProcess (Process, ProcessWorkingSetWatch, NULL, 0);

    if (!NT_SUCCESS(Status) &&
        !(Status == STATUS_PORT_ALREADY_SET) &&
        !(Status == STATUS_ACCESS_DENIED)) {

        return;
    }

    SetConsoleCtrlHandler(CtrlcH,TRUE);

    EmptyWorkingSet(Process);

    while (TRUE) {

        Status = NtQueryInformationProcess (Process,
                                            ProcessWorkingSetWatch,
                                            (PVOID *)&NewWorkingSetBuffer,
                                            sizeof (NewWorkingSetBuffer),
                                            NULL);

        if (fFast) {
            fFast = FALSE;
            Status = STATUS_NO_MORE_ENTRIES;
        }
        if ( NT_SUCCESS(Status) ) {

            //
            // For each PC/VA pair, print the pc and referenced VA
            // symbolically
            //

            didone = FALSE;
            i = 0;
            while (NewWorkingSetBuffer[i].FaultingPc) {
                if ( NewWorkingSetBuffer[i].FaultingVa ) {
                    if ( InCtrlc ) {
                        ExitThread(0);
                    }
                    Mi2 = LocateModInfo((PVOID)NewWorkingSetBuffer[i].FaultingVa);
                    if ( !Mi2 || (Mi2 && (Options & OPTIONS_CODE_TOO))) {

                        //
                        // Add the pc to the running working set
                        // watch buffer
                        //

                        RunningWorkingSetBuffer[CurrentWsIndex++] = (ULONG_PTR)NewWorkingSetBuffer[i].FaultingPc;

                        if ( CurrentWsIndex >= MAX_RUNNING_WORKING_SET_BUFFER ) {
                            CtrlcH(CTRL_C_EVENT);
                        }
                        if ( fRunning ) {
                            //
                            // Print the PC symbolically.
                            //
                            didone = TRUE;
                            Mi = LocateModInfo((PVOID)NewWorkingSetBuffer[i].FaultingPc);
                            if ( !Mi ) {
                                printf("0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                if ( LogFile ) {
                                    fprintf(LogFile,"0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                }
                            }
                            else {
                                if (SymGetSymFromAddr((HANDLE)ProcessId, (DWORD_PTR)NewWorkingSetBuffer[i].FaultingPc, &Displacement, ThisSymbol )) {
                                    Offset = (ULONG_PTR)NewWorkingSetBuffer[i].FaultingPc - ThisSymbol->Address;
                                    if ( Offset ) {
                                        sprintf(Line,"%s+%x",ThisSymbol->Name,Offset);
                                    }
                                    else {
                                        sprintf(Line,"%s",ThisSymbol->Name);
                                    }
                                    printf("%s",Line);
                                    if ( LogFile ) {
                                        fprintf(LogFile,"%s",Line);
                                    }
                                }
                                else {
                                    printf("0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                    if ( LogFile ) {
                                        fprintf(LogFile,"0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                    }
                                }
                            }

                            //
                            // Print the VA Symbolically
                            //

                            Mi = LocateModInfo((PVOID)NewWorkingSetBuffer[i].FaultingVa);
                            if ( !Mi ) {
                                printf(" : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                if ( LogFile ) {
                                    fprintf(LogFile," : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                }
                            }
                            else {
                                if (SymGetSymFromAddr((HANDLE)ProcessId, (DWORD_PTR)NewWorkingSetBuffer[i].FaultingVa, &Displacement, ThisSymbol )) {
                                    Offset = (ULONG_PTR)NewWorkingSetBuffer[i].FaultingVa - ThisSymbol->Address;
                                    if ( Offset ) {
                                        sprintf(Line," : %s+%x",ThisSymbol->Name,Offset);
                                    }
                                    else {
                                        sprintf(Line," : %s",ThisSymbol->Name);
                                    }
                                    printf("%s",Line);
                                    if ( LogFile ) {
                                        fprintf(LogFile,"%s",Line);
                                    }
                                }
                                else {
                                    printf(" : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                    if ( LogFile ) {
                                        fprintf(LogFile," : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                    }
                                }
                            }
                            printf("\n");
                            if ( LogFile ) {
                                fprintf(LogFile,"\n");
                            }
                        }
                    }
                }
                i++;
            }
            if ( didone ) {
                printf("\n");
                if ( LogFile ) {
                    fprintf(LogFile,"\n");
                }
            }
        }

        Sleep(1000);

        while (PeekConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead) && NumRead != 0) {
            if (!ReadConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead)) {
                break;
            }
            if (InputRecord.EventType == KEY_EVENT) {

                //
                // Ignore control characters.
                //

                if (InputRecord.Event.KeyEvent.uChar.AsciiChar >= ' ') {

                    switch (InputRecord.Event.KeyEvent.uChar.AsciiChar) {

                        case 'F':
                        case 'f':
                            EmptyWorkingSet(Process);
                            printf("\n*** Working Set Flushed ***\n\n");
                            if ( LogFile ) {
                                fprintf(LogFile,"\n*** Working Set Flushed ***\n\n");
                                }
                            break;

                        default:
                            break;
                    }
                }
            }
        }
    }
}


VOID
ComputeModInfo(
    HANDLE Process,
    DWORD_PTR ProcessId
    )
{
    HMODULE rghModule[MODINFO_SIZE];
    DWORD cbNeeded;
    ULONG ModInfoNext;
    PVOID BaseAddress;
    IMAGEHLP_MODULE ModuleInfo;
    MODULEINFO PsapiModuleInfo;
    ULONG i;


    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    SymInitialize((HANDLE)ProcessId, NULL, FALSE );
    SymSetOptions(SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME);

    for (i=0 ; i < ModInfoMax ; i++){
        if ( ModInfo[i].BaseAddress &&
             ModInfo[i].BaseAddress != (PVOID)-1 &&
             ModInfo[i].Name
             ) {
            LocalFree(ModInfo[i].Name);
        }
    }

    RtlZeroMemory(ModInfo, sizeof(ModInfo));
    if (!EnumProcessModules(Process, rghModule, sizeof(rghModule), &cbNeeded)) {
        return;
    }

    if (cbNeeded > sizeof(rghModule)) {
        cbNeeded = sizeof(rghModule);
    }

    ModInfoMax = cbNeeded / sizeof(HMODULE);

    for (ModInfoNext = 0; ModInfoNext < ModInfoMax; ModInfoNext++) {


        HMODULE hModule;
        DWORD cch;
        CHAR DllName[MAX_PATH];

        hModule = rghModule[ModInfoNext];

        ModInfo[ModInfoNext].BaseAddress = (PVOID) hModule;

        //
        // Get the base name of the module
        //

        cch = GetModuleBaseName(Process, hModule, DllName, sizeof(DllName));

        if (cch == 0) {
            return;
        }

        ModInfo[ModInfoNext].Name = LocalAlloc(LMEM_ZEROINIT, cch+1);

        if ( !ModInfo[ModInfoNext].Name) {
            return;
        }

        memcpy(ModInfo[ModInfoNext].Name, DllName, cch);

        //
        // Get the full path to the module.
        //

        cch = GetModuleFileNameEx (Process, hModule, DllName, sizeof(DllName));

        if (cch == 0) {
            return;
        }

        GetModuleInformation (Process,
                              hModule,
                              &PsapiModuleInfo,
                              sizeof(MODULEINFO));

        ModInfo[ModInfoNext].VirtualSize = PsapiModuleInfo.SizeOfImage;

        BaseAddress = (PVOID)SymLoadModule ((HANDLE)ProcessId,
                                            NULL,
                                            DllName,
                                            NULL,
                                            (DWORD_PTR)hModule,
                                            PsapiModuleInfo.SizeOfImage);

        if ((ModInfo[ModInfoNext].BaseAddress) &&
            (ModInfo[ModInfoNext].BaseAddress == BaseAddress)) {
            SymGetModuleInfo(
                (HANDLE)ProcessId,
                (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                &ModuleInfo
                );

            if (ModuleInfo.SymType == SymNone) {
                ModInfo[ModInfoNext].SymbolsLoaded = FALSE;
                if (Options & OPTIONS_VERBOSE) {
                    fprintf(stderr, "Could not load symbols: %p : %p  %s\n",
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress +
                            ModInfo[ModInfoNext].VirtualSize,
                        ModInfo[ModInfoNext].Name
                        );
                }
            } else {
                ModInfo[ModInfoNext].SymbolsLoaded = TRUE;
                if (Options & OPTIONS_VERBOSE) {
                    fprintf(stderr, "Symbols loaded: %p : %p  %s\n",
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress +
                            ModInfo[ModInfoNext].VirtualSize,
                        ModInfo[ModInfoNext].Name
                        );
                }
            }
        } else {
            ModInfo[ModInfoNext].SymbolsLoaded = FALSE;
            if (Options & OPTIONS_VERBOSE) {
                fprintf(stderr, "Symbols not loaded and conflicting Base: %p (%p) : %p  %s\n",
                    (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                    BaseAddress,
                    (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress +
                        ModInfo[ModInfoNext].VirtualSize,
                    ModInfo[ModInfoNext].Name
                    );
            }
        }
    }
    if (bHitModuleMax) {
        fprintf(stderr, "\nERROR: The number of modules in the process more than the buffer size\n");
    }
}

ProtectionToIndex(
    ULONG Protection
    )
{
    Protection &= ~PAGE_GUARD;

    switch ( Protection ) {

        case PAGE_NOACCESS:
                return NOACCESS;

        case PAGE_READONLY:
                return READONLY;

        case PAGE_READWRITE:
                return READWRITE;

        case PAGE_WRITECOPY:
                return WRITECOPY;

        case PAGE_EXECUTE:
                return EXECUTE;

        case PAGE_EXECUTE_READ:
                return EXECUTEREAD;

        case PAGE_EXECUTE_READWRITE:
                return EXECUTEREADWRITE;

        case PAGE_EXECUTE_WRITECOPY:
                return EXECUTEWRITECOPY;
        default:
            return 0;
    }
}

VOID
DumpCommit (
    PSZ Header,
    ULONG_PTR *CommitVector
    )
{
    ULONG_PTR TotalCommitCount;
    ULONG i;

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
    }
    printf("\nTotal %s Commitment %8ld\n",Header,TotalCommitCount);

    if ( CommitVector[NOACCESS] ) {
        printf("    NOACCESS:          %9ld\n",CommitVector[NOACCESS]);
    }

    if ( CommitVector[READONLY] ) {
        printf("    READONLY:          %9ld\n",CommitVector[READONLY]);
    }
    if ( CommitVector[READWRITE] ) {
        printf("    READWRITE:         %9ld\n",CommitVector[READWRITE]);
    }
    if ( CommitVector[WRITECOPY] ) {
        printf("    WRITECOPY:         %9ld\n",CommitVector[WRITECOPY]);
    }
    if ( CommitVector[EXECUTE] ) {
        printf("    EXECUTE:           %9ld\n",CommitVector[EXECUTE]);
    }
    if ( CommitVector[EXECUTEREAD] ) {
        printf("    EXECUTEREAD:       %9ld\n",CommitVector[EXECUTEREAD]);
    }
    if ( CommitVector[EXECUTEREADWRITE] ) {
        printf("    EXECUTEREADWRITE:  %9ld\n",CommitVector[EXECUTEREADWRITE]);
    }
    if ( CommitVector[EXECUTEWRITECOPY] ) {
        printf("    EXECUTEWRITECOPY:  %9ld\n",CommitVector[EXECUTEWRITECOPY]);
    }
}

VOID
DumpModInfo (
    )
{
    ULONG i;
    for (i=0 ; i < ModInfoMax ; i++){
        DumpCommit(ModInfo[i].Name, &ModInfo[i].CommitVector[0]);
    }
}


VOID
CaptureVaSpace (
    IN HANDLE Process
    )
{

    PVOID BaseAddress;
    PVAINFO VaInfo;
    PMODINFO Mod;

    BaseAddress = NULL;
    LastAllocationBase = NULL;
    InitializeListHead(&VaList);

    while ( (ULONG_PTR)BaseAddress < SystemRangeStart ) {
        VaInfo = LocalAlloc(LMEM_ZEROINIT, sizeof(*VaInfo));
        if (!VaInfo) {
            return;
        }

        if ( !VirtualQueryEx(Process,
                             BaseAddress,
                             &VaInfo->BasicInfo,
                             sizeof(VaInfo->BasicInfo)) ) {
            LocalFree (VaInfo);
            return;
        }

        switch (VaInfo->BasicInfo.State ) {

            case MEM_COMMIT :
                if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                    ImageCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    Mod = LocateModInfo(BaseAddress);
                    if ( Mod ) {
                        Mod->CommitVector[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    }
                }
                else {
                    if ( VaInfo->BasicInfo.Type == MEM_MAPPED ) {
                        MappedCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    }
                    else {
                        PrivateCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    }
                }
                break;
            case MEM_RESERVE :
                if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                    ImageReservedBytes += VaInfo->BasicInfo.RegionSize;
                }
                else {
                    ReservedBytes += VaInfo->BasicInfo.RegionSize;
                }
                break;
            case MEM_FREE :
                if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                    ImageFreeBytes += VaInfo->BasicInfo.RegionSize;
                }
                else {
                    FreeBytes += VaInfo->BasicInfo.RegionSize;
                }
                break;
        }

        if ( LastAllocationBase ) {

            //
            // Normal case
            //

            //
            // See if last one is 0, or if this one doesn't match the
            // last one.
            //

            if ( LastAllocationBase->BasicInfo.AllocationBase == NULL ||
                 LastAllocationBase->BasicInfo.AllocationBase != VaInfo->BasicInfo.AllocationBase ) {
                LastAllocationBase = VaInfo;
                InsertTailList(&VaList,&VaInfo->Links);
                InitializeListHead(&VaInfo->AllocationBaseHead);
            }
            else {

                //
                // Current Entry Matches
                //

                InsertTailList(&LastAllocationBase->AllocationBaseHead,&VaInfo->Links);
            }
        }
        else {
            LastAllocationBase = VaInfo;
            InsertTailList(&VaList,&VaInfo->Links);
            InitializeListHead(&VaInfo->AllocationBaseHead);
        }
        BaseAddress = (PVOID)((ULONG_PTR)BaseAddress + VaInfo->BasicInfo.RegionSize);
    }
}

PSZ
MemProtect(
    IN ULONG Protection
    )
{
    switch ( Protection ) {

        case PAGE_NOACCESS:
                return "No Access";

        case PAGE_READONLY:
                return "Read Only";

        case PAGE_READWRITE:
                return "Read/Write";

        case PAGE_WRITECOPY:
                return "Write Copy";

        case PAGE_EXECUTE:
                return "Execute";

        case PAGE_EXECUTE_READ:
                return "Execute Read";

        case PAGE_EXECUTE_READWRITE:
                return "Execute Read/Write";

        case PAGE_EXECUTE_WRITECOPY:
                return "Execute Write Copy";

        default :
            if ( Protection & PAGE_GUARD ) {
                switch ( Protection & 0xff ) {

                    case PAGE_NOACCESS:
                            return "-- GUARD -- No Access";

                    case PAGE_READONLY:
                            return "-- GUARD -- Read Only";

                    case PAGE_READWRITE:
                            return "-- GUARD -- Read/Write";

                    case PAGE_WRITECOPY:
                            return "-- GUARD -- Write Copy";

                    case PAGE_EXECUTE:
                            return "-- GUARD -- Execute";

                    case PAGE_EXECUTE_READ:
                            return "-- GUARD -- Execute Read";

                    case PAGE_EXECUTE_READWRITE:
                            return "-- GUARD -- Execute Read/Write";

                    case PAGE_EXECUTE_WRITECOPY:
                            return "-- GUARD -- Execute Write Copy";
                    default:
                            return "-- GUARD -- Unknown";
                }
            }
            return "Unknown";
    }
}

PSZ
MemState(
    IN ULONG State
    )
{
    switch ( State ) {
        case MEM_COMMIT :
            return "Committed";
        case MEM_RESERVE :
            return "Reserved";
        case MEM_FREE :
            return "Free";
        default:
            return "Unknown State";
    }
}

PSZ
MemType(
    IN ULONG Type
    )
{
    switch ( Type ) {
        case MEM_PRIVATE :
            return "Private";
        case MEM_MAPPED :
            return "Mapped";
        case MEM_IMAGE :
            return "Image";
        default:
            return "Unknown Type";
    }
}

VOID
DumpVaSpace(
    VOID
    )
{
    PLIST_ENTRY Next;
    PVAINFO VaInfo;
    ULONG_PTR VirtualSize;

    Next = VaList.Flink;

    while ( Next != &VaList) {

        VaInfo = (PVAINFO)(CONTAINING_RECORD(Next,VAINFO,Links));

        printf("\n");

        if ( !IsListEmpty(&VaInfo->AllocationBaseHead) ) {
            PLIST_ENTRY xNext;
            PVAINFO xVaInfo;

            VirtualSize = VaInfo->BasicInfo.RegionSize;

            xNext = VaInfo->AllocationBaseHead.Flink;

            while ( xNext != &VaInfo->AllocationBaseHead) {

                xVaInfo = (PVAINFO)(CONTAINING_RECORD(xNext,VAINFO,Links));
                VirtualSize += xVaInfo->BasicInfo.RegionSize;
                xNext = xNext->Flink;
            }
        }
        else {
            VirtualSize = 0;
        }

        printf("Address: %p Size: %p",
            VaInfo->BasicInfo.BaseAddress,
            VaInfo->BasicInfo.RegionSize);

        if ( VirtualSize ) {
            printf(" RegionSize: %lx\n",VirtualSize);
        }
        else {
            printf("\n");
        }
        printf("    State %s\n",MemState(VaInfo->BasicInfo.State));

        if ( VaInfo->BasicInfo.State == MEM_COMMIT ) {
            printf("    Protect %s\n",MemProtect(VaInfo->BasicInfo.Protect));
        }

        if ( VaInfo->BasicInfo.State == MEM_COMMIT ||
             VaInfo->BasicInfo.State == MEM_RESERVE ) {
            printf("    Type %s\n",MemType(VaInfo->BasicInfo.Type));
        }

        if ( Options & OPTIONS_VERBOSE ) {
            if ( !IsListEmpty(&VaInfo->AllocationBaseHead) ) {
                PLIST_ENTRY xNext;
                PVAINFO xVaInfo;

                xNext = VaInfo->AllocationBaseHead.Flink;

                while ( xNext != &VaInfo->AllocationBaseHead) {

                    xVaInfo = (PVAINFO)(CONTAINING_RECORD(xNext,VAINFO,Links));
                    printf("\n");
                    printf("        Address: %p Size: %p\n",
                        xVaInfo->BasicInfo.BaseAddress,
                        xVaInfo->BasicInfo.RegionSize
                        );
                    printf("            RegionSize %p\n",xVaInfo->BasicInfo.RegionSize);
                    printf("            State %s\n",MemState(xVaInfo->BasicInfo.State));

                    if ( xVaInfo->BasicInfo.State == MEM_COMMIT ) {
                        printf("            Protect %s\n",MemProtect(xVaInfo->BasicInfo.Protect));
                    }

                    if ( xVaInfo->BasicInfo.State == MEM_COMMIT ||
                         xVaInfo->BasicInfo.State == MEM_RESERVE ) {
                        printf("            Type %s\n",MemType(xVaInfo->BasicInfo.Type));
                    }
                    xNext = xNext->Flink;
                }
            }
        }
        Next = Next->Flink;
    }
}

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    HANDLE Process;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Unicode;
    NTSTATUS Status;
    LPSTR lpstrCmd;
    CHAR ch;
    ULONG_PTR Temp;
    VM_COUNTERS VmCounters;
    LPSTR p;
    SYSTEM_BASIC_INFORMATION SystemInformation;
    BOOL bEnabledDebugPriv;

    UNREFERENCED_PARAMETER (envp);

    ExeName = argv[0];
    if (argc == 1) {
        Usage();
    }

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation,
                                             &SystemInformation,
                                             sizeof(SystemInformation),
                                             NULL))) {
        fprintf(stderr, "Failed to get system basic information\n");
        return 1;
    }

    PageSize = SystemInformation.PageSize;

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // assume usermode is the low half of the address space
        SystemRangeStart = (ULONG_PTR)MAXLONG_PTR;
    }

#if defined (_X86_)
    PteWidth = 4;
    PteBase = (PVOID)0xC0000000;
#else
    PteWidth = 8;
    PteBase = (PVOID)0x1FFFFF0000000000;
#endif

    if ((USER_SHARED_DATA) && (USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED])) {
        PteWidth = 8;
    }

    PtesPerPage = PageSize / PteWidth;
    VaMappedByPageTable = PtesPerPage * PageSize;

    UserPteMax = (PVOID)((ULONG_PTR)PteBase + (SystemRangeStart / PageSize) * PteWidth);

    ThisSymbol = (PIMAGEHLP_SYMBOL) symBuffer;
    ThisSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
    ProcessId = 0;

    GetSystemInfo(&SystemInfo);

    ConvertAppToOem( argc, argv );
    lpstrCmd = GetCommandLine();
    if( lpstrCmd != NULL ) {
        CharToOem( lpstrCmd, lpstrCmd );
    }

    do {
        ch = *lpstrCmd++;
    } while (ch != ' ' && ch != '\t' && ch != '\0');

    while (ch == ' ' || ch == '\t') {
        ch = *lpstrCmd++;
    }

    while (ch == '-') {
        ch = *lpstrCmd++;

        //  process multiple switch characters as needed

        do {
            switch (ch) {

                case '?':
                    Usage();
                case 'C':
                case 'c':
                    Options |= OPTIONS_CODE_TOO;
                    ch = *lpstrCmd++;
                    break;

                case 'F':
                case 'f':
                    fFast = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'L':
                case 'l':

                    //
                    // l takes log-file-name as argument.
                    //

                    do
                        ch = *lpstrCmd++;
                    while (ch == ' ' || ch == '\t');

                    p = LogFileName;

                    while (ch && (ch != ' ' && ch != '\t')) {
                        *p++ = ch;
                        ch = *lpstrCmd++;
                    }
                    LogFile = fopen(LogFileName,"wt");
                    break;

                case 'M':
                case 'm':
                    Options |= OPTIONS_RAW_SYMBOLS;
                    ch = *lpstrCmd++;
                    break;

                case 'P':
                case 'p':

                    //
                    // pid takes a decimal argument.
                    //

                    do {
                        ch = *lpstrCmd++;
                    } while (ch == ' ' || ch == '\t');

                    if (ch == '-') {
                        ch = *lpstrCmd++;
                        if (ch == '1') {
                            ProcessId = 0xffffffff;
                            ch = *lpstrCmd++;
                        }
                    }
                    else {
                        while (ch >= '0' && ch <= '9') {
                            Temp = ProcessId * 10 + ch - '0';
                            if (Temp < ProcessId) {
                                fprintf(stderr, "pid number overflow\n");
                                ExitProcess(1);
                            }
                            ProcessId = Temp;
                            ch = *lpstrCmd++;
                        }
                    }
                    if (!ProcessId) {
                        fprintf(stderr, "bad pid '%ld'\n", ProcessId);
                        ExitProcess(1);
                    }
                    break;

                case 'R':
                case 'r':
                    fRunning = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'S':
                case 's':
                    fSummary = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'T':
                case 't':
                    Options |= OPTIONS_PAGE_TABLES;
                    ch = *lpstrCmd++;
                    break;

                case 'O':
                case 'o':
                    Options |= OPTIONS_WORKING_SET_OLD;
                    //
                    // Fall through ...
                    //

                case 'W':
                case 'w':
                    Options |= OPTIONS_WORKING_SET;
                    ch = *lpstrCmd++;
                    break;

                case 'V':
                case 'v':
                    Options |= OPTIONS_VERBOSE;
                    ch = *lpstrCmd++;
                    break;

                default:
                    Usage();
            }

        } while (ch != ' ' && ch != '\t' && ch != '\0');

        //  skip over any following white space

        while (ch == ' ' || ch == '\t') {
            ch = *lpstrCmd++;
        }
    }

    //
    // try to enable SeDebugPrivilege to allow opening any process
    //

    bEnabledDebugPriv = TRUE;
    if (!SetCurrentPrivilege(SE_DEBUG_NAME, &bEnabledDebugPriv)) {
        fprintf(stderr, "Failed to set debug privilege\n");
        return 1;
    }

    if ( ProcessId == 0 || ProcessId == 0xffffffff ) {
        ProcessId = 0xffffffff;
        RtlInitUnicodeString(&Unicode,L"\\WindowsSS");
        InitializeObjectAttributes(
            &Obja,
            &Unicode,
            0,
            NULL,
            NULL
            );
        Status = NtOpenProcess(
                    &Process,
                    MAXIMUM_ALLOWED, //PROCESS_VM_READ | PROCESS_VM_OPERATION | PROCESS_SET_INFORMATION | PROCESS_QUERY_INFORMATION,
                    &Obja,
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            fprintf(stderr, "OpenProcess Failed %lx\n",Status);
            return 1;
        }
    }
    else {
        Process = OpenProcess (PROCESS_ALL_ACCESS,FALSE, (ULONG)ProcessId);
        if ( !Process ) {
            fprintf(stderr, "OpenProcess %ld failed %lx\n",ProcessId,GetLastError());
            return 1;
        }
    }

    if (Options & OPTIONS_WORKING_SET_OLD) {
        CaptureWorkingSet (Process);
        LoadTheHeaps (Process);
        LoadTheThreads (Process, ProcessId);
    }

    ComputeModInfo (Process, ProcessId);

    CaptureVaSpace (Process);

    //
    // disable the SeDebugPrivilege if we enabled it above
    //

    if(bEnabledDebugPriv) {
        bEnabledDebugPriv = FALSE;
        SetCurrentPrivilege (SE_DEBUG_NAME, &bEnabledDebugPriv);
    }

    if (Options & OPTIONS_WORKING_SET) {
        if (Options & OPTIONS_WORKING_SET_OLD) {
            DumpWorkingSetSnapshot (Process);
        }
        else {
            DumpWorkingSet (Process);
        }
        return 1;
    }

    if ( !fSummary ) {
        DumpVaSpace();
    }

    DumpCommit(" Image",ImageCommit);
    DumpModInfo();
    DumpCommit("Mapped",MappedCommit);
    DumpCommit("  Priv",PrivateCommit);
    printf("\n");
    printf("Dynamic Reserved Memory %ld\n",
        ReservedBytes
        );

    Status = NtQueryInformationProcess(
                Process,
                ProcessVmCounters,
                (PVOID)&VmCounters,
                sizeof(VmCounters),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return 1;
    }
    printf("\n");
    printf("PageFaults:            %9ld\n",VmCounters.PageFaultCount);
    printf("PeakWorkingSetSize     %9ld\n",VmCounters.PeakWorkingSetSize);
    printf("WorkingSetSize         %9ld\n",VmCounters.WorkingSetSize);
    printf("PeakPagedPoolUsage     %9ld\n",VmCounters.QuotaPeakPagedPoolUsage);
    printf("PagedPoolUsage         %9ld\n",VmCounters.QuotaPagedPoolUsage);
    printf("PeakNonPagedPoolUsage  %9ld\n",VmCounters.QuotaPeakNonPagedPoolUsage);
    printf("NonPagedPoolUsage      %9ld\n",VmCounters.QuotaNonPagedPoolUsage);
    printf("PagefileUsage          %9ld\n",VmCounters.PagefileUsage);
    printf("PeakPagefileUsage      %9ld\n",VmCounters.PeakPagefileUsage);

    return 0;
}

VOID
Usage (
    VOID
    )
{
    fprintf(stderr, "Usage:\n"
                    " Dump the address space:\n"
                    "    %s [-sv] -p decimal_process_id\n"
                    "\n"
                    " Dump the current workingset:\n"
                    "    %s -o [-mpsv] [-l logfile] -p decimal_process_id\n"
                    "\n"
                    " Dump new additions to the workingset (Stop with ^C):\n"
                    "    %s -w [-crv] [-l logfile] -p decimal_process_id\n"
                    "\n"
                    "       -c Include code faults faulting PC summary\n"
                    "       -m Show all code symbols on page\n"
                    "       -o Workingset snapshot w/ summary\n"
                    "       -r Print info on individual faults\n"
                    "       -s Summary info only\n"
                    "       -t Include pagetable info in summary\n"
                    "       -w Track new working set additions\n"
                    "       -v Verbose\n",
                    ExeName,
                    ExeName,
                    ExeName);
    ExitProcess(1);
}

LOGICAL
SetCurrentPrivilege (
    IN LPCTSTR Privilege,      // Privilege to enable/disable
    IN OUT BOOL *bEnablePrivilege  // to enable or disable privilege
    )
/*

    If successful, *bEnablePrivlege is set to the new state.
    If NOT successful, bEnablePrivlege is invalid

    Returns:
        TRUE - success
        FALSE - failure
 */
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LOGICAL bSuccess;
    BOOL bEnableIt;

    bEnableIt = *bEnablePrivilege;

    if (!LookupPrivilegeValue(NULL, Privilege, &luid)) {
        return FALSE;
    }

    if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) {
        return FALSE;
    }

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    bSuccess = FALSE;

    if(GetLastError() == ERROR_SUCCESS) {
        //
        // second pass.  set privilege based on previous setting
        //
        tpPrevious.PrivilegeCount     = 1;
        tpPrevious.Privileges[0].Luid = luid;

        *bEnablePrivilege = tpPrevious.Privileges[0].Attributes | (SE_PRIVILEGE_ENABLED);

        if(bEnableIt) {
            tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        }
        else {
            tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
                tpPrevious.Privileges[0].Attributes);
        }

        AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tpPrevious,
                cbPrevious,
                NULL,
                NULL
                );

        if (GetLastError() == ERROR_SUCCESS) {
            bSuccess=TRUE;
        }
    }

    CloseHandle(hToken);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmdrv\makefile.inc ===
#
# Build wdm.lib.  This consists of wdmguid.lib, wdmnt.lib and wdmhal.lib, all
# built below.
#

WDMLIBDEP=$(O)\wdmnt.lib \
          $(O)\wdmhal.lib \
          $(O)\wdmguid.obj

!if exist($(SDK_LIB_PATH)\exsup.lib)
WDMLIBDEP=$(WDMLIBDEP) $(SDK_LIB_PATH)\exsup.lib
!endif

!if exist($(SDK_LIB_PATH)\int64.lib)
WDMLIBDEP=$(WDMLIBDEP) $(SDK_LIB_PATH)\int64.lib
!endif

!if exist($(PROJECT_ROOT)\ntos\init\$(TARGET_DIRECTORY)\excptlst.obj)
WDMLIBDEP=$(WDMLIBDEP) $(PROJECT_ROOT)\ntos\init\$(TARGET_DIRECTORY)\excptlst.obj
!endif

#
# __NULL_IMPORT_DESCRIPTOR is found in both wdmhal.lib and wdmnt.lib, which
# generates warning 4006.
#

$(O)\wdm.lib: $(WDMLIBDEP)
     -$(LIB_NAME) -out:$(@R).lib @<<
$(LINK_LIB_IGNORE_FLAG)
-ignore:4006
$(WDMLIBDEP)
<<NOKEEP

#
# Build wdmnt.lib
#

$(O)\wdmnt.def: i386nt.src alphant.src ia64nt.src amd64nt.src

$(O)\wdmnt.lib : $(O)\wdmnt.def $(DDK_LIB_PATH)\ntoskrnl.lib
    -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\wdmnt.def
$(DDK_LIB_PATH)\ntoskrnl.lib
<<NOKEEP

#
# Build wdmhal.lib
#

$(O)\wdmhal.def: i386hal.src alphahal.src ia64hal.src amd64hal.src

$(O)\wdmhal.lib : $(O)\wdmhal.def $(DDK_LIB_PATH)\hal.lib
    -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\wdmhal.def
$(DDK_LIB_PATH)\hal.lib
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\urtl\uheap.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>

BOOLEAN DebugFlag;

PVOID HeapHandle;

PVOID
TestAlloc(
    IN ULONG Size
    )
{
    PVOID a;

    if ((a = RtlAllocateHeap( HeapHandle, 0, Size )) == NULL) {
        RtlValidateHeap( HeapHandle, TRUE );
        DbgPrint( "\nUHEAP: RtlAllocateHeap( %lx ) failed\n", Size );
        DbgBreakPoint();
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }

    if (DebugFlag) {
        DbgPrint( "\n" );
        DbgPrint( "\nRtlAllocateHeap( %lx ) => %lx\n", Size, a );
        }

    if (!RtlValidateHeap( HeapHandle, DebugFlag )) {
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }

    return( a );
}


PVOID
TestFree(
    IN PVOID BaseAddress,
    IN ULONG Size
    )
{
    PVOID a;

    if ((a = RtlFreeHeap( HeapHandle, 0, BaseAddress )) != NULL) {
        DbgPrint( "\nUHEAP: RtlFreeHeap( %lx ) failed\n", BaseAddress );
        RtlValidateHeap( HeapHandle, TRUE );
        DbgBreakPoint();
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }

    if (DebugFlag) {
        DbgPrint( "\n" );
        DbgPrint( "\nRtlFreeHeap( %lx ) => %lx\n", BaseAddress, a );
        }

    if (!RtlValidateHeap( HeapHandle, DebugFlag )) {
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }
    return( a );
}


BOOLEAN
TestHeap(
    IN PVOID UserHeapBase,
    IN BOOLEAN Serialize,
    IN BOOLEAN Sparse,
    IN ULONG GrowthThreshold,
    IN ULONG InitialSize
    )
{
    PVOID a1,a2,a3,a4;
    DWORD Flags;

    Flags = 0;
    if (!Serialize) {
        Flags |= HEAP_NO_SERIALIZE;
        }

    if (!Sparse) {
        Flags |= HEAP_GROWABLE;
        }

    HeapHandle = RtlCreateHeap( Flags,
                                UserHeapBase,
                                InitialSize,
                                0,
                                0,
                                GrowthThreshold
                              );
    if ( HeapHandle == NULL ) {
        DbgPrint( "UHEAP: RtlCreateHeap failed\n" );
        DbgBreakPoint();
        goto exit;
        }
    if (!RtlValidateHeap( HeapHandle, DebugFlag )) {
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }


    //
    // TEST 0:
    // Allocate and free a large chunk of memory so that the following
    // tests are valid.
    //

    DbgPrint( "UHEAP: Test #0\n" );
    a1 = TestAlloc( 4096-16 );
    TestFree( a1, 0 );


    //
    // TEST 1:
    // Allocate three chunks, deallocate the middle one, and reallocate it.
    //

    DbgPrint( "UHEAP: Test #1\n" );
    a1 = TestAlloc( 16 );
    a2 = TestAlloc( 32 );
    a3 = TestAlloc( 112 );
    TestFree( a2, 32 );
    a4 = TestAlloc( 32 );


    //
    // TEST 2:
    // Deallocate first chunk and reallocate it.
    //

    DbgPrint( "UHEAP: Test #2\n" );
    TestFree( a1, 16 );
    a4 = TestAlloc( 16 );


    //
    // TEST 3:
    // Deallocate last chunk and reallocate it.
    //

    DbgPrint( "UHEAP: Test #3\n" );
    TestFree( a3, 112 );
    a4 = TestAlloc( 112 );


    //
    // TEST 4:
    // Deallocate last chunk and reallocate larger one.
    //

    DbgPrint( "UHEAP: Test #4\n" );
    TestFree( a4, 112 );
    a4 = TestAlloc( 112+64 );


    //
    // TEST 5:
    // Deallocate first two chunks and reallocate combined one.
    //

    DbgPrint( "UHEAP: Test #5\n" );
    TestFree( a1, 16  );
    TestFree( a2, 32  );
    a4 = TestAlloc( 16+32-4 );


    //
    // TEST 6:
    // There should be room between blocks 2 and 3 for a small allocation.
    // Make sure zero byte allocations work.
    //

    DbgPrint( "UHEAP: Test #6\n" );
    a4 = TestAlloc( 0 );


    //
    // TEST 7:
    // Deallocate last two chunks and reallocate one.  Address should change.
    //

    DbgPrint( "UHEAP: Test #7\n" );
    TestFree( a3, 112+64 );
    TestFree( a4, 0 );
    a3 = TestAlloc( 112 );


    //
    // TEST 8:
    // Deallocate everything and make sure it can be reallocated.
    //

    DbgPrint( "UHEAP: Test #8\n" );
    TestFree( a1, 16+32-4 );
    TestFree( a3, 112 );
    a2 = TestAlloc( 200 );


    //
    // TEST 9:
    // Allocate more than is committed.
    //

    DbgPrint( "UHEAP: Test #9\n" );
    a1 = TestAlloc( 100000 );
    TestFree( a2, 200 );
    TestFree( a1, 100000 );


    //
    // TEST 10:
    // Allocate more than maximum size of heap
    //

    DbgPrint( "UHEAP: Test #10\n" );
    a3 = TestAlloc( 100000 );
    TestFree( a3, 100000 );


    //
    // TEST 11:
    // Destroy the heap
    //

    DbgPrint( "UHEAP: Test #11\n" );
    HeapHandle = RtlDestroyHeap( HeapHandle );
    if ( HeapHandle != NULL ) {
        DbgPrint( "UHEAP: RtlDestroyHeap failed\n" );
        DbgBreakPoint();
        goto exit;
        }

    return( TRUE );

exit:
    if (HeapHandle != NULL) {
        HeapHandle = RtlDestroyHeap( HeapHandle );
        }

    return( FALSE );
}


VOID
Usage( VOID )
{
    DbgPrint( "Usage: UHEAP [-s ReserveSize] | [-g InitialSize GrowthThreshold]\n" );

    (VOID)NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
}

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    )
{
    NTSTATUS Status;
    PCH s;
    PVOID UserHeapBase = NULL;
    BOOLEAN Serialize = FALSE;
    BOOLEAN Sparse = FALSE;
    ULONG GrowthThreshold = 0;
    ULONG InitialSize = 0x8000;

    DebugFlag = DebugParameter;

    DbgPrint( "** Start of User Mode Test of RtlAllocateHeap/RtlFreeHeap **\n" );

    while (--argc) {
        s = *++argv;
        if (*s == '-') {
            switch( *++s ) {
                case 'x':
                case 'X':
                    Serialize = TRUE;
                    break;

                case 's':
                case 'S':
                    Sparse = TRUE;
                    if (--argc) {
                        InitialSize = atoi( *++argv );
                        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                                          (PVOID *)&UserHeapBase,
                                                          0,
                                                          &InitialSize,
                                                          MEM_RESERVE,
                                                          PAGE_READWRITE
                                                        );
                        if (!NT_SUCCESS( Status )) {
                            DbgPrint( "UHEAP: Unable to allocate heap - 0x%lx bytes\n",
                                      InitialSize
                                    );
                            Usage();
                            }
                        }
                    else {
                        Usage();
                        }
                    break;

                case 'g':
                case 'G':
                    if (argc >= 2) {
                        argc -= 2;
                        InitialSize = atoi( *++argv );
                        GrowthThreshold = atoi( *++argv );
                        }
                    else {
                        Usage();
                        }
                    break;

                default:
                    Usage();
                }
            }
        else {
            Usage();
            }
        }

    TestHeap( UserHeapBase,
              Serialize,
              Sparse,
              GrowthThreshold,
              InitialSize
            );

    if (UserHeapBase != NULL) {
        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&UserHeapBase,
                                      &InitialSize,
                                      MEM_RELEASE
                                    );
        }

    DbgPrint( "** End of User Mode Test of RtlAllocateHeap/RtlFreeHeap **\n" );

    (VOID)NtTerminateProcess( NtCurrentProcess(), STATUS_SUCCESS );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\cm\cmpregutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CmpRegUtil.h

Abstract:

    This header contains private information for implementing various utility
    routines for accessing the registry. This file is meant to be included only
    by cmregutil.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTSTATUS
CmpRegUtilAllocateUnicodeString(
    IN OUT  PUNICODE_STRING String,
    IN      USHORT          Length
    );

VOID
CmpRegUtilFreeAllocatedUnicodeString(
    IN  PUNICODE_STRING String
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\inc\wldef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlDef.h

Abstract:

    This header collects together the various files neccessary to create a basic
    set of definitions for the WDM library.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlMacro.h"
#define _NTDDK_
#include <ntifs.h> // Best path to get interesting defines
#include <wchar.h>
#define _IN_KERNEL_
#include <regstr.h>
#include <sddl.h>
#include <wdmsec.h>
#include "Wl\wlprivate.h"
#include "Io\IoDevobj.h"
#include "Pp\PpRegState.h"
#include "Cm\CmRegUtil.h"
#include "Se\SeSddl.h"
#include "Se\SeUtil.h"

//
// For the sake of good coding practice, no macros or defines should be
// declared in this file, but rather they should be defined in seperate headers.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmdrv\wdmguid.c ===
#ifdef WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#endif

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <ole2.h>
#define INITGUID
#include <initguid.h>

#include <wdmguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\cm\cmregutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CmRegUtil.h

Abstract:

    This header exposes various utility routines for accessing the registry.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// A handy macro for converting regstr.h paths into full kernel HKLM paths
//
#define CM_REGISTRY_MACHINE(x) L"\\Registry\\Machine\\"##x

//
// This macro returns the pointer to the beginning of the data area of
// KEY_VALUE_FULL_INFORMATION structure. In the macro, k is a pointer to
// KEY_VALUE_FULL_INFORMATION structure.
//
#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

//
// Unicode primitives - these are the best functions to use.
//
NTSTATUS
CmRegUtilOpenExistingUcKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PUNICODE_STRING     KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    );

NTSTATUS
CmRegUtilCreateUcKey(
    IN  HANDLE                  BaseHandle,
    IN  PUNICODE_STRING         KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    );

NTSTATUS
CmRegUtilUcValueGetDword(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DefaultValue,
    OUT ULONG              *Value
    );

NTSTATUS
CmRegUtilUcValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PUNICODE_STRING                 ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    );

NTSTATUS
CmRegUtilUcValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    );

NTSTATUS
CmRegUtilUcValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PUNICODE_STRING     ValueData
    );

//
// WSTR and mixed primitives
//
NTSTATUS
CmRegUtilOpenExistingWstrKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PWSTR               KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    );

NTSTATUS
CmRegUtilCreateWstrKey(
    IN  HANDLE                  BaseHandle,
    IN  PWSTR                   KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    );

NTSTATUS
CmRegUtilWstrValueGetDword(
    IN  HANDLE  KeyHandle,
    IN  PWSTR   ValueName,
    IN  ULONG   DefaultValue,
    OUT ULONG  *Value
    );

NTSTATUS
CmRegUtilWstrValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PWSTR                           ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    );

NTSTATUS
CmRegUtilWstrValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    );

NTSTATUS
CmRegUtilWstrValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  PUNICODE_STRING     ValueData
    );

NTSTATUS
CmRegUtilUcValueSetWstrString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PWSTR               ValueData
    );

NTSTATUS
CmRegUtilWstrValueSetWstrString(
    IN  HANDLE      KeyHandle,
    IN  PWSTR       ValueName,
    IN  PWSTR       ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\cm\cmregutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CmRegUtil.c

Abstract:

    This module contains registry utility functions.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "CmpRegutil.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CmRegUtilOpenExistingUcKey)
#pragma alloc_text(PAGE, CmRegUtilCreateUcKey)
#pragma alloc_text(PAGE, CmRegUtilUcValueGetDword)
#pragma alloc_text(PAGE, CmRegUtilUcValueGetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilUcValueSetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilUcValueSetUcString)
#pragma alloc_text(PAGE, CmRegUtilOpenExistingWstrKey)
#pragma alloc_text(PAGE, CmRegUtilCreateWstrKey)
#pragma alloc_text(PAGE, CmRegUtilWstrValueGetDword)
#pragma alloc_text(PAGE, CmRegUtilWstrValueGetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilWstrValueSetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilWstrValueSetUcString)
#pragma alloc_text(PAGE, CmRegUtilUcValueSetWstrString)
#pragma alloc_text(PAGE, CmRegUtilWstrValueSetWstrString)
#pragma alloc_text(PAGE, CmpRegUtilAllocateUnicodeString)
#pragma alloc_text(PAGE, CmpRegUtilFreeAllocatedUnicodeString)
#endif

#define POOLTAG_REGBUFFER   'bRpP'
#define POOLTAG_UCSTRING    'cUpP'

//
// FUTURE WORK:
// - Add function to read strings from registry
// - Add function to read multisz strings from registry
// - Add function to write multisz strings from registry
// - Add function to create key *path* (see IopCreateRegistryKeyEx, who's
//   code should be cleaned up first)
// - Add function to recursively delete keys
//

//
// Unicode primitives - these are the best functions to use.
//
NTSTATUS
CmRegUtilOpenExistingUcKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PUNICODE_STRING     KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    )
/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    BaseHandle - Optional handle to the base path from which the key must be
        opened. If this parameter is specified, then KeyName must be a relative
        path.

    KeyName - UNICODE_STRING Name of the Key that must be opened (either a full
        registry path, or a relative path depending on whether BaseHandle is
        supplied)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

    STATUS_SUCCESS if the key could be opened, in which case Handle receives
    the registry key. Otherwise, failure is returned, and handle receives NULL.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE newHandle;
    NTSTATUS status;

    PAGED_CODE();

    *Handle = NULL;

    InitializeObjectAttributes(
        &objectAttributes,
        KeyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        BaseHandle,
        (PSECURITY_DESCRIPTOR) NULL
        );

    //
    // Simply attempt to open the path, as specified.
    //
    status = ZwOpenKey(
        &newHandle,
        DesiredAccess,
        &objectAttributes
        );

    if (NT_SUCCESS(status)) {

        *Handle = newHandle;
    }

    return status;
}


NTSTATUS
CmRegUtilCreateUcKey(
    IN  HANDLE                  BaseHandle,
    IN  PUNICODE_STRING         KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    )
/*++

Routine Description:

    Opens or creates a registry key using the name passed in based at the
    BaseHandle node.

Arguments:

    BaseHandle - Handle to the base path under which the key must be opened.

    KeyName - UNICODE_STRING Key Name that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    CreateOptions - Options passed to ZwCreateKey. Examples:

        REG_OPTION_VOLATILE - Key is not to be stored across boots.
        REG_OPTION_NON_VOLATILE - Key is preserved when the system is rebooted.

    SecurityDescriptor - Security to apply if the key is newly created. If NULL,
        the key will inherit settings as defined by the inheritable properties
        of its parent.

    Disposition - This optional pointer receives a ULONG indicating whether
        the key was newly created (0 on error):

        REG_CREATED_NEW_KEY - A new Registry Key was created.
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened.

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

   The function value is the final status of the operation.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;
    HANDLE newHandle;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes(
        &objectAttributes,
        KeyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        BaseHandle,
        SecurityDescriptor
        );

    //
    // Attempt to create the path as specified. We have to try it this
    // way first, because it allows us to create a key without a BaseHandle
    // (if only the last component of the registry path is not present).
    //
    status = ZwCreateKey(
        &newHandle,
        DesiredAccess,
        &objectAttributes,
        0,
        (PUNICODE_STRING) NULL,
        CreateOptions,
        &disposition
        );

    //
    // Upon failure, populate the passed in parameters with consistant values
    // (this ensures determinisity if the calling code fails to properly check
    // the return value).
    //
    if (!NT_SUCCESS(status)) {

        newHandle = NULL;
        disposition = 0;
    }

    *Handle = newHandle;
    if (ARGUMENT_PRESENT(Disposition)) {

        *Disposition = disposition;
    }

    return status;
}


NTSTATUS
CmRegUtilUcValueGetDword(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DefaultValue,
    OUT ULONG              *Value
    )
/*++

Routine Description:

    This routine reads a dword value from the registry. The value name is
    specified in UNICODE_STRING form.

Arguments:

    KeyHandle - Points to key to read.

    ValueName - Points to the value to read.

    DefaultValue - Points to the default value to use in case of an absence or
                   error.

    Value - Receives DefaultValue on error, otherwise the value stored in the
            registry.

Return Value:

    STATUS_SUCCESS if the value was present in the registry,
    STATUS_OBJECT_NAME_NOT_FOUND if it was absent,
    STATUS_OBJECT_TYPE_MISMATCH if the value was not a dword,
    or some other error value.

--*/
{
    UCHAR valueBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION keyInfo;
    ULONG keyValueLength;
    ULONG finalValue;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit
    //
    finalValue = DefaultValue;
    keyInfo = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;

    //
    // Read in the value
    //
    status = ZwQueryValueKey( KeyHandle,
                              ValueName,
                              KeyValuePartialInformation,
                              (PVOID) valueBuffer,
                              sizeof(valueBuffer),
                              &keyValueLength
                              );

    //
    // Fill in the output only as appropriate.
    //
    if (NT_SUCCESS(status)) {

        if (keyInfo->Type == REG_DWORD) {

            finalValue = *((PULONG) keyInfo->Data);

        } else {

            //
            // Closest error we can get...
            //
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }
    }

    *Value = finalValue;
    return status;
}


NTSTATUS
CmRegUtilUcValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PUNICODE_STRING                 ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    )
/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the Unicode string name of the value.

    DataType - REG_NONE if any type is allowable, otherwise the specific type
        required.

    LikelyDataLength - An optional parameter to eliminate unneccessary
                       allocations and reparses.

    Information - Receives a pointer to the allocated data buffer allocated
                  from PagedPool, NULL on error. If successful, the buffer
                  should be freed using ExFreePool.

                  Note - the allocated memory is *not* charged against the
                         calling process.

Return Value:

    STATUS_SUCCESS if the information was retrievable, error otherwise (in
    which case Information will receive NULL).

--*/

{
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength, guessSize;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for error
    //
    *Information = NULL;

    //
    // Set an initial size to try when loading a key. Note that
    // KeyValueFullInformation already comes with a single WCHAR of data.
    //
    guessSize = (ULONG)(sizeof(KEY_VALUE_FULL_INFORMATION) + ValueName->Length);

    //
    // Now round up to a natural alignment. This needs to be done because our
    // data member will naturally aligned as well.
    //
    guessSize = (ULONG) ALIGN_POINTER_OFFSET(guessSize);

    //
    // Adjust for the most likely size of the data.
    //
    guessSize += LikelyDataLength;

    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        guessSize,
        POOLTAG_REGBUFFER
        );

    if (infoBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        ValueName,
        KeyValueFullInformation,
        (PVOID) infoBuffer,
        guessSize,
        &keyValueLength
        );

    if (NT_SUCCESS(status)) {

        //
        // First guess worked, bail!
        //
        goto Success;
    }

    ExFreePool(infoBuffer);
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(!NT_SUCCESS(status));
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        keyValueLength,
        POOLTAG_REGBUFFER
        );

    if (infoBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        ValueName,
        KeyValueFullInformation,
        infoBuffer,
        keyValueLength,
        &keyValueLength
        );

    if (!NT_SUCCESS( status )) {

        ExFreePool(infoBuffer);
        return status;
    }

Success:
    //
    // One last check - validate the type field
    //
    if ((DataType != REG_NONE) && (infoBuffer->Type != DataType)) {

        //
        // Mismatched type - bail.
        //
        ExFreePool(infoBuffer);

        //
        // Closest error we can get...
        //
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //
    *Information = infoBuffer;
    return STATUS_SUCCESS;
}


NTSTATUS
CmRegUtilUcValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    )
/*++

Routine Description:

    This function writes a buffer of information to a specific value key in
    the registry.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the UNICODE_STRING name of the value key.

    DataType - Specifies the type of data to write.

    Buffer - Points to the buffer to write.

    BufferSize - Specifies the size of the buffer to write.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PAGED_CODE();

    return ZwSetValueKey(
        KeyHandle,
        ValueName,
        0,
        DataType,
        Buffer,
        BufferSize
        );
}



NTSTATUS
CmRegUtilUcValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PUNICODE_STRING     ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the UNICODE_STRING name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING tempString;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueName->Buffer);
    ASSERT(ValueData->Buffer);

    //
    // Null terminate the string
    //
    if ((ValueData->MaximumLength - ValueData->Length) >= sizeof(UNICODE_NULL)) {

        //
        // There is room in the buffer so just append a null
        //
        ValueData->Buffer[(ValueData->Length / sizeof(WCHAR))] = UNICODE_NULL;

        //
        // Set the registry value
        //
        status = ZwSetValueKey(
            KeyHandle,
            ValueName,
            0,
            REG_SZ,
            (PVOID) ValueData->Buffer,
            ValueData->Length + sizeof(UNICODE_NULL)
            );

    } else {

        //
        // There is no room so allocate a new buffer and so we need to build
        // a new string with room
        //
        status = CmpRegUtilAllocateUnicodeString(&tempString, ValueData->Length);

        if (!NT_SUCCESS(status)) {

            goto clean0;
        }

        //
        // Copy the input string to the output string
        //
        tempString.Length = ValueData->Length;
        RtlCopyMemory(tempString.Buffer, ValueData->Buffer, ValueData->Length);

        //
        // Add the null termination
        //
        tempString.Buffer[tempString.Length / sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Set the registry value
        //
        status = ZwSetValueKey(
            KeyHandle,
            ValueName,
            0,
            REG_SZ,
            (PVOID) tempString.Buffer,
            tempString.Length + sizeof(UNICODE_NULL)
            );

        //
        // Free the temporary string
        //
        CmpRegUtilFreeAllocatedUnicodeString(&tempString);
    }

clean0:
    return status;
}


//
// WSTR and mixed primitives
//
NTSTATUS
CmRegUtilOpenExistingWstrKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PWSTR               KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    )
/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    BaseHandle - Optional handle to the base path from which the key must be
        opened. If this parameter is specified, then KeyName must be a relative
        path.

    KeyName - WSTR Name of the Key that must be opened (either a full registry
        path, or a relative path depending on whether BaseHandle is supplied)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used, as the access-mode is KernelMode,
        but we specify it anyway).

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

    STATUS_SUCCESS if the key could be opened, in which case Handle receives
    the registry key. Otherwise, failure is returned, and handle receives NULL.

--*/
{
    UNICODE_STRING unicodeStringKeyName;
    NTSTATUS status;

    PAGED_CODE();

    status = RtlInitUnicodeStringEx(&unicodeStringKeyName, KeyName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilOpenExistingUcKey(
        BaseHandle,
        &unicodeStringKeyName,
        DesiredAccess,
        Handle
        );
}


NTSTATUS
CmRegUtilCreateWstrKey(
    IN  HANDLE                  BaseHandle,
    IN  PWSTR                   KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    )
/*++

Routine Description:

    Opens or creates a registry key using the name passed in based at the
    BaseHandle node.

Arguments:

    BaseHandle - Handle to the base path under which the key must be opened.

    KeyName - WSTR Key Name that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    CreateOptions - Options passed to ZwCreateKey. Examples:

        REG_OPTION_VOLATILE - Key is not to be stored across boots.
        REG_OPTION_NON_VOLATILE - Key is preserved when the system is rebooted.

    SecurityDescriptor - Security to apply if the key is newly created. If NULL,
        the key will inherit settings as defined by the inheritable properties
        of its parent.

    Disposition - This optional pointer receives a ULONG indicating whether
        the key was newly created (0 on error):

        REG_CREATED_NEW_KEY - A new Registry Key was created.
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened.

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

   The function value is the final status of the operation.

--*/
{
    UNICODE_STRING unicodeStringKeyName;
    NTSTATUS status;

    PAGED_CODE();

    status = RtlInitUnicodeStringEx(&unicodeStringKeyName, KeyName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilCreateUcKey(
        BaseHandle,
        &unicodeStringKeyName,
        DesiredAccess,
        CreateOptions,
        SecurityDescriptor,
        Disposition,
        Handle
        );
}


NTSTATUS
CmRegUtilWstrValueGetDword(
    IN  HANDLE  KeyHandle,
    IN  PWSTR   ValueName,
    IN  ULONG   DefaultValue,
    OUT ULONG  *Value
    )
/*++

Routine Description:

    This routine reads a dword value from the registry. The value name is
    specified in WSTR form.

Arguments:

    KeyHandle - Points to key to read.

    ValueName - Points to the value to read.

    DefaultValue - Points to the default value to use in case of an absence or
                   error.

    Value - Receives DefaultValue on error, otherwise the value stored in the
            registry.

Return Value:

    STATUS_SUCCESS if the value was present in the registry,
    STATUS_OBJECT_NAME_NOT_FOUND if it was absent,
    STATUS_OBJECT_TYPE_MISMATCH if the value was not a dword,
    or some other error value.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueGetDword(
        KeyHandle,
        &unicodeStringValueName,
        DefaultValue,
        Value
        );
}


NTSTATUS
CmRegUtilWstrValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PWSTR                           ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    )
/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated WSTR name of the value.

    DataType - REG_NONE if any type is allowable, otherwise the specific type
        required.

    LikelyDataLength - Most likely size of the data to retrieve (used to
                       optimize queries).

    Information - Receives a pointer to the allocated data buffer allocated
                  from PagedPool, NULL on error. If successful, the buffer
                  should be freed using ExFreePool.

                  Note - the allocated memory is *not* charged against the
                         calling process.

Return Value:

    STATUS_SUCCESS if the information was retrievable, error otherwise (in
    which case Information will receive NULL).

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueGetFullBuffer(
        KeyHandle,
        &unicodeStringValueName,
        DataType,
        LikelyDataLength,
        Information
        );
}


NTSTATUS
CmRegUtilWstrValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    )
/*++

Routine Description:

    This function writes a buffer of information to a specific value key in
    the registry.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the WSTR name of the value key.

    DataType - Specifies the type of data to write.

    Buffer - Points to the buffer to write.

    BufferSize - Specifies the size of the buffer to write.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetFullBuffer(
        KeyHandle,
        &unicodeStringValueName,
        DataType,
        Buffer,
        BufferSize
        );
}


NTSTATUS
CmRegUtilWstrValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  PUNICODE_STRING     ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.
    The value name is specified in WSTR form, while the value data is in
    UNICODE_STRING format.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a WSTR pointer to the name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueData->Buffer);

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetUcString(
        KeyHandle,
        &unicodeStringValueName,
        ValueData
        );
}


NTSTATUS
CmRegUtilUcValueSetWstrString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PWSTR               ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the UNICODE_STRING name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING valueString;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueName->Buffer);

    //
    // Construct the unicode data
    //
    status = RtlInitUnicodeStringEx(&valueString, ValueData);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetUcString(
        KeyHandle,
        ValueName,
        &valueString
        );
}


NTSTATUS
CmRegUtilWstrValueSetWstrString(
    IN  HANDLE      KeyHandle,
    IN  PWSTR       ValueName,
    IN  PWSTR       ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the WSTR name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    UNICODE_STRING valueString;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);

    //
    // Construct the unicode data
    //
    status = RtlInitUnicodeStringEx(&valueString, ValueData);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetUcString(
        KeyHandle,
        &unicodeStringValueName,
        &valueString
        );
}


NTSTATUS
CmpRegUtilAllocateUnicodeString(
    IN OUT  PUNICODE_STRING String,
    IN      USHORT          Length
    )
/*++

Routine Description:

    This routine allocates a buffer for a unicode string of a given length
    and initialises the UNICODE_STRING structure appropriately. When the
    string is no longer required it can be freed using
    CmpRegUtilFreeAllocatedString. The buffer also can be directly deleted by
    ExFreePool and so can be handed back to a caller.

Parameters:

    String - Supplies a pointer to an uninitialised unicode string which will
        be manipulated by the function.

    Length - The number of BYTES long that the string will be.

Return Value:

    Either STATUS_INSUFFICIENT_RESOURCES indicating paged pool is exhausted or
    STATUS_SUCCESS.

Remarks:

    The buffer allocated will be one character (2 bytes) more than length specified.
    This is to allow for easy null termination of the strings - eg for registry
    storage.

--*/
{
    PAGED_CODE();

    String->Length = 0;
    String->MaximumLength = Length + sizeof(UNICODE_NULL);

    String->Buffer = ExAllocatePoolWithTag(
        PagedPool,
        Length + sizeof(UNICODE_NULL),
        POOLTAG_UCSTRING
        );

    if (String->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        return STATUS_SUCCESS;
    }
}


VOID
CmpRegUtilFreeAllocatedUnicodeString(
    IN  PUNICODE_STRING String
    )
/*++

Routine Description:

    This routine frees a string previously allocated with
    CmpRegUtilAllocateUnicodeString.

Parameters:

    String - Supplies a pointer to the string that has been previously allocated.

Return Value:

    None

--*/
{
    PAGED_CODE();

    ASSERT(String);

    RtlFreeUnicodeString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\inc\wlmacro.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wlmacro.h

Abstract:

    This header contains a collection of macros used by the wdm library.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:


--*/

//
// This is to make all the TEXT(...) macros come out right. As of 07/27/2000,
// UNICODE isn't defined in kernel space by default.
//
#define UNICODE

//
// This macro takes an array and returns the number of elements in it.
//
#define ARRAY_COUNT(array) (sizeof(array)/sizeof(array[0]))

//
// This macro realigns a pointer to a pointer boundary.
//
#define ALIGN_POINTER(Offset) (PVOID) \
        ((((ULONG_PTR)(Offset) + sizeof(ULONG_PTR)-1)) & (~(sizeof(ULONG_PTR) - 1)))

//
// This macro realigns a ULONG_PTR offset onto a pointer boundary.
//
#define ALIGN_POINTER_OFFSET(Offset) (ULONG_PTR) ALIGN_POINTER(Offset)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\io\iodevobj.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoDevObj.h

Abstract:

    This header exposes various routines for managing device objects.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTSTATUS
IoDevObjCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid,
    OUT PDEVICE_OBJECT     *DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\io\iodevobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoDevObj.c

Abstract:

    This module contains functions for managing device objects.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "IopDevObj.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoDevObjCreateDeviceSecure)
#pragma alloc_text(PAGE, IopDevObjAdjustNewDeviceParameters)
#pragma alloc_text(PAGE, IopDevObjApplyPostCreationSettings)
#endif


NTSTATUS
IoDevObjCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid         OPTIONAL,
    OUT PDEVICE_OBJECT     *DeviceObject
    )
/*++

Routine Description:

    This routine creates a securable named device object. The security settings
    for the device object are retrieved from the registry or constructed using
    the passed in defaults if registry overrides are not available.

    It should be used
      1. To secure legacy device objects
      2. To secure raw PnP PDOs

    It should not be used to create FDOs, non-raw PDOs, or any unnamed objects.
    For those operations, IoCreateDevice should be used.

Arguments:

    DriverObject - A pointer to the driver object for this device.

    DeviceExtensionSize - Size, in bytes, of extension to device object;
        i.e., the size of the driver-specific data for this device object.

    DeviceName - Optional name that should be associated with this device.
        If the DeviceCharacteristics has the FILE_AUTOGENERATED_DEVICE_NAME
        flag set, this parameter is ignored.

    DeviceType - The type of device that the device object should represent.
        Possibly overriden by registry.

    DeviceCharacteristics - The characteristics for the device. Additional
        flags may be supplied by the registry.

    Exclusive - Indicates that the device object should be created with using
        the exclusive object attribute. Possibly overriden by registry.

        NOTE: This flag should not be used for WDM drivers.  Since only the
        PDO is named, it is the only device object in a devnode attachment
        stack that is openable.  However, since this device object is created
        by the underlying bus driver (which has no knowledge about what type
        of device this is), there is no way to know whether this flag should
        be set.  Therefore, this parameter should always be FALSE for WDM
        drivers.  Drivers attached to the PDO (e.g., the function driver) must
        enforce any exclusivity rules.

    DefaultSDDLString - In the absense of registry settings, this string
        specifies the security to supply for the device object.

        Only the subset of the SDDL format is currently supported. The format
        is:
          D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

        Where:

          AceType - Only Allow ("A") is supported.
          Access - Rights specified in either hex format (0xnnnnnnnn), or via the
                   SDDL Generic/Standard abbreviations
          SID - Abbreviated security ID
                (WD, BA, SY, IU, RC, AU, NU, AN, BG, BU, LS, NS)
                The S-w-x-y-z form for SIDs is not supported

          The unimplemented ace fields are:

            AceFlags - Describes features such as inheritance for sub-objects
                (ie files) and containers (ie keys/folders). An example SDDL
                AceFlag string would be ("OICI"). While control over
                inheritance is crucial for registry keys and files, it's
                irrelevant for device objects. As such, this function supports
                no ACE flags.

            ObjectGuid - Used for describing rights that transcent the 32bit
                mask supplied by the OS. Typically used for Active Directory
                objects.

            InheritObjectGuid - - Used for describing rights that transcent the
                32bit mask supplied by the OS. Typically used for Active
                Directory objects.

        Example -
          "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access.

    DeviceClassGuid - Supplies a device install class GUID. This class is
        looked up in the registry to see if any potential overrides exist.
        For legacy device objects, the caller may need to invent an appropriate
        class GUID (see IoCreateDeviceSecure documention on how to properly
        install a full class).

        Note that if no registry override exists, the registry will
        automatically be updated to *reflect* the default SDDL string.
        Therefore it is a very bad idea to use the same device class GUID with
        different DefaultSDDLString values (objects needing different default
        security should have different classes, or be secured via INFs where
        possible).

    DeviceObject - Pointer to the device object pointer this routine will
        return.

Return Value:

    NTSTATUS.

--*/
{
    PSECURITY_DESCRIPTOR securityDescriptor;
    STACK_CREATION_SETTINGS stackSettings, updateSettings;
    PDEVICE_OBJECT newDeviceObject;
    UNICODE_STRING classKeyName;
    DEVICE_TYPE finalDeviceType;
    ULONG finalCharacteristics;
    BOOLEAN finalExclusivity;
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for failure
    //
    *DeviceObject = NULL;
    newDeviceObject = NULL;

    //
    // The device object is securable only if it has a name. Therefore, we fail
    // the create call if the device doesn't have a name.
    //
    if (!(ARGUMENT_PRESENT(DeviceName) ||
        (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME))) {

        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT(DeviceClassGuid)) {

        //
        // Try to find the appropriate security descriptor for the device. First
        // look for an override in the registry using the class GUID. We will
        // create a section in the registry if one doesn't exist as well. This is
        // a clue to the system administrator that there is something to lock down
        // in the system.
        //
        status = PpRegStateReadCreateClassCreationSettings(
            DeviceClassGuid,
            DriverObject,
            &stackSettings
            );

        if (!NT_SUCCESS(status)) {

            return status;
        }

    } else {

        PpRegStateInitEmptyCreationSettings(&stackSettings);
    }

    //
    // If a registry setting wasn't specified, parse the default SDDL string.
    //
    if (!(stackSettings.Flags & DSIFLAG_SECURITY_DESCRIPTOR)) {

        //
        // Parse the SDDL string into a security descriptor, and mark it
        // "default" as well. SE_DACL_DEFAULT means the DACL came from a
        // "default" mechanism, typically implying parental inheritance or
        // object default security. In our case, the "default source" is the
        // library as opposed to the user or an INF.
        //
        status = SeSddlSecurityDescriptorFromSDDL(
            DefaultSDDLString,
            TRUE,
            &securityDescriptor
            );

        if (!NT_SUCCESS(status)) {

            goto Exit;
        }

        PpRegStateLoadSecurityDescriptor(
            securityDescriptor,
            &stackSettings
            );

        if (ARGUMENT_PRESENT(DeviceClassGuid)) {

            //
            // Update the registry with the default SDDL string so that the
            // admin knows what settings are being used for this class. Note
            // that we don't free updateSettings, as the security descriptor
            // is also used by stackSettings.
            //
            PpRegStateInitEmptyCreationSettings(&updateSettings);

            PpRegStateLoadSecurityDescriptor(
                securityDescriptor,
                &updateSettings
                );

            status = PpRegStateUpdateStackCreationSettings(
                DeviceClassGuid,
                &updateSettings
                );

            if (!NT_SUCCESS(status)) {

                goto Exit;
            }
        }
    }

    //
    // Fill out the default values
    //
    finalDeviceType = DeviceType;
    finalCharacteristics = DeviceCharacteristics;
    finalExclusivity = Exclusive;

    //
    // Adjust the parameters based on the registry overrides
    //
    IopDevObjAdjustNewDeviceParameters(
        &stackSettings,
        &finalDeviceType,
        &finalCharacteristics,
        &finalExclusivity
        );

    //
    // Create the device object. The newly created object should have the
    // DO_DEVICE_INITIALIZING flag on it, meaning it cannot be opened. We
    // therefore still have an opportunity to apply security.
    //
    status = IoCreateDevice(
        DriverObject,
        DeviceExtensionSize,
        DeviceName,
        finalDeviceType,
        finalCharacteristics,
        finalExclusivity,
        &newDeviceObject
        );

    if (!NT_SUCCESS(status)) {

        goto Exit;
    }

    ASSERT(newDeviceObject->Flags & DO_DEVICE_INITIALIZING);

    status = IopDevObjApplyPostCreationSettings(
        newDeviceObject,
        &stackSettings
        );

    if (!NT_SUCCESS(status)) {

        IoDeleteDevice(newDeviceObject);
        goto Exit;
    }

    *DeviceObject = newDeviceObject;

Exit:

    //
    // Clean up the security descriptor as appropriate.
    //
    PpRegStateFreeStackCreationSettings(&stackSettings);

    return status;
}


VOID
IopDevObjAdjustNewDeviceParameters(
    IN      PSTACK_CREATION_SETTINGS    StackCreationSettings,
    IN OUT  PDEVICE_TYPE                DeviceType,
    IN OUT  PULONG                      DeviceCharacteristics,
    IN OUT  PBOOLEAN                    Exclusive
    )
/*++

Routine Description:

    This routine adjusts a newly created device object to reflect the passed
    in stack creation settings.

Arguments:

    StackCreationSettings - Information reflecting the settings to apply.

    DeviceType - On input, the device type specified by the caller. This field
        is updated to reflect any changes specified in the registry.

    DeviceCharacteristics - On input, the characteristics specified by the
        caller. This field is updated to reflect any changes specified in the
        registry.

    Exclusive - On input, the exclusivity specified by the caller. This field
        is updated to reflect any changes specified in the registry.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if (StackCreationSettings->Flags & DSIFLAG_DEVICE_TYPE) {

        *DeviceType = StackCreationSettings->DeviceType;
    }

    if (StackCreationSettings->Flags & DSIFLAG_CHARACTERISTICS) {

        *DeviceCharacteristics = StackCreationSettings->Characteristics;
    }

    if (StackCreationSettings->Flags & DSIFLAG_EXCLUSIVE) {

        *Exclusive = (BOOLEAN) StackCreationSettings->Exclusivity;
    }
}


NTSTATUS
IopDevObjApplyPostCreationSettings(
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine adjusts a newly created device object to reflect the passed
    in stack creation settings.

Arguments:

    DeviceObject - Device object who's settings to adjust.

    StackCreationSettings - Information reflecting the settings to apply.

Return Value:

    NTSTATUS.

--*/
{
    SECURITY_INFORMATION securityInformation;
    ACCESS_MASK desiredAccess;
    BOOLEAN fromDefaultSource;
    NTSTATUS status;
    HANDLE handle;

    PAGED_CODE();

    if (!(StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR)) {

        return STATUS_SUCCESS;
    }

    //
    // Get the corresponding securityInformation from the descriptor.
    //
    status = SeUtilSecurityInfoFromSecurityDescriptor(
        StackCreationSettings->SecurityDescriptor,
        &fromDefaultSource,
        &securityInformation
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

#ifdef _KERNELIMPLEMENTATION_

    status = ObSetSecurityObjectByPointer(
        DeviceObject,
        securityInformation,
        StackCreationSettings->SecurityDescriptor
        );

#else

    //
    // Since ObSetSecurityObjectByPointer isn't available on Win2K, we have to
    // use a rather sneaky trick. The device technically isn't openable yet.
    // However, ObOpenObjectByPointer doesn't bother doing any parse stuff.
    // Therefore, we can get a quick handle to the object, set the security
    // descriptor, and then dump the handle without the driver being any wiser.
    //
    SeSetSecurityAccessMask(securityInformation, &desiredAccess);

    status = ObOpenObjectByPointer(
        DeviceObject,
        OBJ_KERNEL_HANDLE,
        NULL,
        desiredAccess,
        *IoDeviceObjectType,
        KernelMode,
        &handle
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    status = ZwSetSecurityObject(
        handle,
        securityInformation,
        StackCreationSettings->SecurityDescriptor
        );

    ZwClose(handle);

#endif // _KERNELIMPLEMENTATION_

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\pp\piregstate.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PiRegState.h

Abstract:

    This header contains private information for reading and writing PnP
    registry state information. This file is meant to be included only
    by ppregstate.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// Define a private value for a device type that doesn't exist.
//
#define FILE_DEVICE_UNSPECIFIED 0

typedef enum {

    NOT_VALIDATED = 0,
    VALIDATED_SUCCESSFULLY,
    VALIDATED_UNSUCCESSFULLY

} PIDESCRIPTOR_STATE;

NTSTATUS
PiRegStateReadStackCreationSettingsFromKey(
    IN  HANDLE                      ClassOrDeviceKey,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

NTSTATUS
PiRegStateOpenClassKey(
    IN  LPCGUID         DeviceClassGuid,
    IN  ACCESS_MASK     DesiredAccess,
    IN  LOGICAL         CreateIfNotPresent,
    OUT ULONG          *Disposition         OPTIONAL,
    OUT HANDLE         *ClassKeyHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\io\iopdevobj.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IopDevObj.h

Abstract:

    This header contains private information for managing device objects. This
    file is meant to be included only by IoDevObj.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// Define PDEVICE_TYPE field (grrr... not declared in any headers today)
//
typedef DEVICE_TYPE *PDEVICE_TYPE;

//
// This one is exported, but isn't in any of the headers!
//
extern POBJECT_TYPE *IoDeviceObjectType;

VOID
IopDevObjAdjustNewDeviceParameters(
    IN      PSTACK_CREATION_SETTINGS    StackCreationSettings,
    IN OUT  PDEVICE_TYPE                DeviceType,
    IN OUT  PULONG                      DeviceCharacteristics,
    IN OUT  PBOOLEAN                    Exclusive
    );

NTSTATUS
IopDevObjApplyPostCreationSettings(
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\pp\ppregstate.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpRegState.h

Abstract:

    This header exposes routines for reading and writing PnP registry state
    information.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#define DSIFLAG_DEVICE_TYPE             0x00000001
#define DSIFLAG_SECURITY_DESCRIPTOR     0x00000002
#define DSIFLAG_CHARACTERISTICS         0x00000004
#define DSIFLAG_EXCLUSIVE               0x00000008

typedef struct {

    ULONG                   Flags;
    DEVICE_TYPE             DeviceType;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    ULONG                   Characteristics;
    ULONG                   Exclusivity;

} STACK_CREATION_SETTINGS, *PSTACK_CREATION_SETTINGS;

NTSTATUS
PpRegStateReadCreateClassCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PDRIVER_OBJECT              DriverObject,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

NTSTATUS
PpRegStateUpdateStackCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

VOID
PpRegStateFreeStackCreationSettings(
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

VOID
PpRegStateLoadSecurityDescriptor(
    IN      PSECURITY_DESCRIPTOR        SecurityDescriptor,
    IN OUT  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

VOID
PpRegStateInitEmptyCreationSettings(
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\io\iosddl.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoSddl.c

Abstract:

    This module contains definitions for default SDDL strings. See wdmsec.h
    for better documentation on these.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#pragma hdrstop

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_KERNEL_ONLY,
    L"D:P"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL,
    L"D:P(A;;GA;;;SY)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_ALL,
    L"D:P(A;;GA;;;SY)(A;;GA;;;BA)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RX,
    L"D:P(A;;GA;;;SY)(A;;GRGX;;;BA)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)(A;;GR;;;RC)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGW;;;WD)(A;;GR;;;RC)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)"
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\published\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\se\sesddl.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    SeSddl.c

Abstract:

    This module implements the Security Descriptor Definition Language support
    functions for kernel mode

Author:

    Mac McLain          (MacM)       Nov 07, 1997

Environment:

    Kernel Mode

Revision History:

    Jin Huang           (JinHuang)  3/4/98   Fix validity flags (GetAceFlagsInTable)
    Jin Huang           (JinHuang)  3/10/98  Add SD controls (GetSDControlForString)
                                             Set SidsInitialized flag
                                             Skip any possible spaces in string
    Jin Huang           (JinHuang)  5/1/98   Fix memory leek, error checking
                                             improve performance
    Alaa Abdelhalim     (Alaa)      7/20/99  Initialize sbz2 field to 0 in LocalGetAclForString
                                             function.
    Vishnu Patankar     (VishnuP)   7/5/00   Added new API ConvertStringSDToSDDomain(A/W)

    Adrian J. Oney      (AdriaO)    3/27/02  Ported small subset of
                                             advapi32\sddl.c to KernelMode

--*/

#include "WlDef.h"
#include "SepSddl.h"
#pragma hdrstop

#pragma alloc_text(PAGE, SeSddlSecurityDescriptorFromSDDL)
#pragma alloc_text(PAGE, SepSddlSecurityDescriptorFromSDDLString)
#pragma alloc_text(PAGE, SepSddlDaclFromSDDLString)
#pragma alloc_text(PAGE, SepSddlGetAclForString)
#pragma alloc_text(PAGE, SepSddlLookupAccessMaskInTable)
#pragma alloc_text(PAGE, SepSddlGetSidForString)
#pragma alloc_text(PAGE, SepSddlAddAceToAcl)
#pragma alloc_text(PAGE, SepSddlParseWideStringUlong)

#define POOLTAG_SEACL           'lAeS'
#define POOLTAG_SESD            'dSeS'
#define POOLTAG_SETS            'sTeS'

static STRSD_SID_LOOKUP SidLookup[] = {

    // World (WD) == SECURITY_WORLD_SID_AUTHORITY, also called Everyone.
    // Typically everyone but restricted code (in XP, anonymous logons also
    // lack world SID)
    DEFINE_SDDL_ENTRY(                                      \
      SeWorldSid,                                           \
      WIN2K_OR_LATER,                                       \
      SDDL_EVERYONE,                                        \
      SDDL_LEN_TAG( SDDL_EVERYONE ) ),

    // Administrators (BA) == DOMAIN_ALIAS_RID_ADMINS, Administrator group on
    // the machine
    DEFINE_SDDL_ENTRY(                                      \
      SeAliasAdminsSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_BUILTIN_ADMINISTRATORS,                          \
      SDDL_LEN_TAG( SDDL_BUILTIN_ADMINISTRATORS ) ),

    // System (SY) == SECURITY_LOCAL_SYSTEM_RID, the OS itself (including its
    // user mode components)
    DEFINE_SDDL_ENTRY(                                      \
      SeLocalSystemSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_LOCAL_SYSTEM,                                    \
      SDDL_LEN_TAG( SDDL_LOCAL_SYSTEM ) ),

    // Interactive User (IU) == SECURITY_INTERACTIVE_RID, users logged on
    // locally (doesn't include TS users)
    DEFINE_SDDL_ENTRY(                                      \
      SeInteractiveSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_INTERACTIVE,                                     \
      SDDL_LEN_TAG( SDDL_INTERACTIVE ) ),

    // Restricted Code (RC) == SECURITY_RESTRICTED_CODE_RID, used to control
    // access by untrusted code (ACL's must contain World SID as well)
    DEFINE_SDDL_ENTRY(                                      \
      SeRestrictedSid,                                      \
      WIN2K_OR_LATER,                                       \
      SDDL_RESTRICTED_CODE,                                 \
      SDDL_LEN_TAG( SDDL_RESTRICTED_CODE ) ),

    // Authenticated Users (AU) == SECURITY_AUTHENTICATED_USER_RID, any user
    // recognized by the local machine or by a domain.
    DEFINE_SDDL_ENTRY(                                      \
      SeAuthenticatedUsersSid,                              \
      WIN2K_OR_LATER,                                       \
      SDDL_AUTHENTICATED_USERS,                             \
      SDDL_LEN_TAG( SDDL_AUTHENTICATED_USERS ) ),

    // Network Logon User (NU) == SECURITY_NETWORK_RID, any user logged in
    // remotely.
    DEFINE_SDDL_ENTRY(                                      \
      SeNetworkSid,                                         \
      WIN2K_OR_LATER,                                       \
      SDDL_NETWORK,                                         \
      SDDL_LEN_TAG( SDDL_NETWORK ) ),

    // Anonymous Logged-on User (AN) == SECURITY_ANONYMOUS_LOGON_RID, users
    // logged on without an indentity. No effect before Windows XP (SID
    // presense is harmless though)
    // Note: By default, World does not include Anonymous users on XP!
    DEFINE_SDDL_ENTRY(                                      \
      SeAnonymousLogonSid,                                  \
      WIN2K_OR_LATER,                                       \
      SDDL_ANONYMOUS,                                       \
      SDDL_LEN_TAG( SDDL_ANONYMOUS ) ),

    // Builtin guest account (BG) == DOMAIN_ALIAS_RID_GUESTS, users logging in
    // using the local guest account.
    DEFINE_SDDL_ENTRY(                                      \
      SeAliasGuestsSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_BUILTIN_GUESTS,                                  \
      SDDL_LEN_TAG( SDDL_BUILTIN_GUESTS ) ),

    // Builtin user account (BU) == DOMAIN_ALIAS_RID_USERS, local user accounts,
    // or users on the domain.
    DEFINE_SDDL_ENTRY(                                      \
      SeAliasUsersSid,                                      \
      WIN2K_OR_LATER,                                       \
      SDDL_BUILTIN_USERS,                                   \
      SDDL_LEN_TAG( SDDL_BUILTIN_USERS ) ),

    //
    // Don't expose these - they are either invalid or depricated
    //
    //{ SePrincipalSelfSid,      SDDL_PERSONAL_SELF,          SDDL_LEN_TAG( SDDL_PERSONAL_SELF ) },
    //{ SeServiceSid,            SDDL_SERVICE,                SDDL_LEN_TAG( SDDL_SERVICE ) },
    //{ SeAliasPowerUsersSid,    SDDL_POWER_USERS,            SDDL_LEN_TAG( SDDL_POWER_USERS ) },

    // Local Service (LS) == SECURITY_LOCAL_SERVICE_RID, a predefined account
    // for local services (which also belong to Authenticated and World)
    DEFINE_SDDL_ENTRY(                                      \
      SeLocalServiceSid,                                    \
      WINXP_OR_LATER,                                       \
      SDDL_LOCAL_SERVICE,                                   \
      SDDL_LEN_TAG( SDDL_LOCAL_SERVICE ) ),

    // Network Service (NS) == SECURITY_NETWORK_SERVICE_RID, a predefined
    // account for network services (which also belong to Authenticated and
    // World)
    DEFINE_SDDL_ENTRY(                                      \
      SeNetworkServiceSid,                                  \
      WINXP_OR_LATER,                                       \
      SDDL_NETWORK_SERVICE,                                 \
      SDDL_LEN_TAG( SDDL_NETWORK_SERVICE ) )
};

//
// This is how the access mask is looked up.  Always have the multi-char rights
// before the single char ones
//
static STRSD_KEY_LOOKUP RightsLookup[] = {

    { SDDL_READ_CONTROL,    SDDL_LEN_TAG( SDDL_READ_CONTROL ),      READ_CONTROL },
    { SDDL_WRITE_DAC,       SDDL_LEN_TAG( SDDL_WRITE_DAC ),         WRITE_DAC },
    { SDDL_WRITE_OWNER,     SDDL_LEN_TAG( SDDL_WRITE_OWNER ),       WRITE_OWNER },
    { SDDL_STANDARD_DELETE, SDDL_LEN_TAG( SDDL_STANDARD_DELETE ),   DELETE },
    { SDDL_GENERIC_ALL,     SDDL_LEN_TAG( SDDL_GENERIC_ALL ),       GENERIC_ALL },
    { SDDL_GENERIC_READ,    SDDL_LEN_TAG( SDDL_GENERIC_READ ),      GENERIC_READ },
    { SDDL_GENERIC_WRITE,   SDDL_LEN_TAG( SDDL_GENERIC_WRITE ),     GENERIC_WRITE },
    { SDDL_GENERIC_EXECUTE, SDDL_LEN_TAG( SDDL_GENERIC_EXECUTE ),   GENERIC_EXECUTE },
};

//
// Exported functions
//

NTSTATUS
SeSddlSecurityDescriptorFromSDDL(
    IN  PCUNICODE_STRING        SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    )
/*++

Routine Description:

    This routine creates a security descriptor given an SDDL string in
    UNICODE_STRING format. The security descriptor is self-relative
    (sans-pointers), so it can be persisted and used on subsequent boots.

    Only a subset of the SDDL format is currently supported. This subset is
    really tailored towards device object support.

    Format:
      D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

      AceType - Only Allow ("A") is supported.
      AceFlags - No AceFlags are supported
      Access - Rights specified in either hex format (0xnnnnnnnn), or via the
               SDDL Generic/Standard abbreviations
      ObjectGuid - Not supported
      InheritObjectGuid - Not supported
      SID - Abbreviated security ID (example WD == World)
            The S-w-x-y-z form for SIDs is not supported

    Example - "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access

Arguments:

    SecurityDescriptorString - Stringized security descriptor to be converted.


    SuppliedByDefaultMechanism - TRUE if the DACL is being built due to some
                                 default mechanism (ie, not manually specified
                                 by an admin, etc).

    SecurityDescriptor - Receives the security descriptor on success, NULL
                         on error.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    WCHAR GuardChar;
    LPWSTR TempStringBuffer;

    //
    // Look to see if we have a string built by RtlInitUnicodeString. It will
    // have a terminating NULL with it, so no conversion is neccessary.
    //
    if (SecurityDescriptorString->MaximumLength ==
        SecurityDescriptorString->Length + sizeof(UNICODE_NULL)) {

        GuardChar = SecurityDescriptorString->Buffer[SecurityDescriptorString->Length/sizeof(WCHAR)];

        if (GuardChar == UNICODE_NULL) {

            return SepSddlSecurityDescriptorFromSDDLString(
                SecurityDescriptorString->Buffer,
                SuppliedByDefaultMechanism,
                SecurityDescriptor
                );
        }
    }

    //
    // We need to allocate a slightly larger buffer so we can NULL-terminate it.
    //
    TempStringBuffer = (LPWSTR) ExAllocatePoolWithTag(
        PagedPool,
        SecurityDescriptorString->Length + sizeof(UNICODE_NULL),
        POOLTAG_SETS
        );

    if (TempStringBuffer == NULL) {

        *SecurityDescriptor = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build a null terminated WCHAR string
    //
    RtlCopyMemory(
        TempStringBuffer,
        SecurityDescriptorString->Buffer,
        SecurityDescriptorString->Length
        );

    TempStringBuffer[SecurityDescriptorString->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Do the conversion
    //
    Status = SepSddlSecurityDescriptorFromSDDLString(
        TempStringBuffer,
        SuppliedByDefaultMechanism,
        SecurityDescriptor
        );

    //
    // Free the temporary string
    //
    ExFreePool(TempStringBuffer);

    return Status;
}


//
// Private functions
//

NTSTATUS
SepSddlSecurityDescriptorFromSDDLString(
    IN  LPCWSTR                 SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    )
/*++

Routine Description:

    This routine creates a security descriptor given an SDDL string in LPWSTR
    format. The security descriptor is self-relative (sans-pointers), so it can
    be persisted and used on subsequent boots.

    Only the subset of the SDDL format is currently supported. This subset is
    really tailored towards device object support.

    Format:
      D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

      AceType - Only Allow ("A") is supported.
      AceFlags - No AceFlags are supported
      Access - Rights specified in either hex format (0xnnnnnnnn), or via the
               SDDL Generic/Standard abbreviations
      ObjectGuid - Not supported
      InheritObjectGuid - Not supported
      SID - Abbreviated security ID (example WD == World)
            The S-w-x-y-z form for SIDs is not supported

    Example - "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access

Arguments:

    SecurityDescriptorString - Stringized security descriptor to be converted.

    SuppliedByDefaultMechanism - TRUE if the DACL is being built due to some
                                 default mechanism (ie, not manually specified
                                 by an admin, etc).

    SecurityDescriptor - Receives the security descriptor on success, NULL
                         on error.

Return Value:

    NTSTATUS

--*/
{
    SECURITY_DESCRIPTOR LocalSecurityDescriptor;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor;
    ULONG SecurityDescriptorControlFlags;
    PACL DiscretionaryAcl;
    ULONG BufferLength;
    NTSTATUS IgnoredStatus;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Preinit
    //
    DiscretionaryAcl = NULL;
    NewSecurityDescriptor = NULL;
    *SecurityDescriptor = NULL;

    //
    // First convert the SDDL into a DACL + Descriptor flags
    //
    Status = SepSddlDaclFromSDDLString(
        SecurityDescriptorString,
        SuppliedByDefaultMechanism,
        &SecurityDescriptorControlFlags,
        &DiscretionaryAcl
        );

    if (!NT_SUCCESS(Status)) {

        goto ErrorExit;
    }

    //
    // Create an on-stack security descriptor
    //
    IgnoredStatus = RtlCreateSecurityDescriptor( &LocalSecurityDescriptor,
                                                 SECURITY_DESCRIPTOR_REVISION );

    ASSERT(IgnoredStatus == STATUS_SUCCESS);

    //
    // Now set the control, owner, group, dacls, and sacls, etc
    //
    IgnoredStatus = RtlSetDaclSecurityDescriptor( &LocalSecurityDescriptor,
                                                  TRUE,
                                                  DiscretionaryAcl,
                                                  FALSE );
    ASSERT(IgnoredStatus == STATUS_SUCCESS);

    //
    // Add in the descriptor flags (we do this afterwords as the RtlSet...
    // functions also munge the defaulted bits.)
    //
    LocalSecurityDescriptor.Control |= SecurityDescriptorControlFlags;

    //
    // Convert the security descriptor into a self-contained binary form
    // ("self-relative", ie sans-pointers) that can be written into the
    // registry and used on subsequent boots. Start by getting the required
    // size.
    //
    BufferLength = 0;

    IgnoredStatus = RtlAbsoluteToSelfRelativeSD(
        &LocalSecurityDescriptor,
        NULL,
        &BufferLength
        );

    ASSERT(IgnoredStatus == STATUS_BUFFER_TOO_SMALL);

    //
    // Allocate memory for the descriptor
    //
    NewSecurityDescriptor = (PSECURITY_DESCRIPTOR) ExAllocatePoolWithTag(
        PagedPool,
        BufferLength,
        POOLTAG_SESD
        );

    if (NewSecurityDescriptor == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // Do the conversion
    //
    Status = RtlAbsoluteToSelfRelativeSD(
        &LocalSecurityDescriptor,
        NewSecurityDescriptor,
        &BufferLength
        );

    if (!NT_SUCCESS(Status)) {

        goto ErrorExit;
    }

    //
    // At this point, the Dacl is no longer needed.
    //
    ExFreePool(DiscretionaryAcl);
    *SecurityDescriptor = NewSecurityDescriptor;
    return Status;

ErrorExit:

    if ( DiscretionaryAcl != NULL ) {

        ExFreePool(DiscretionaryAcl);
    }

    if ( NewSecurityDescriptor != NULL ) {

        ExFreePool(NewSecurityDescriptor);
    }

    return Status;
}


NTSTATUS
SepSddlDaclFromSDDLString(
    IN  LPCWSTR SecurityDescriptorString,
    IN  LOGICAL SuppliedByDefaultMechanism,
    OUT ULONG  *SecurityDescriptorControlFlags,
    OUT PACL   *DiscretionaryAcl
    )
/*++

Routine Description:

    This routine will create a DACL given an SDDL string in LPWSTR format. Only
    the subset of the SDDL format is currently supported. This subset is really
    tailored towards device object support.

    Format:
      D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

      AceType - Only Allow ("A") is supported.
      AceFlags - No AceFlags are supported
      Access - Rights specified in either hex format (0xnnnnnnnn), or via the
               SDDL Generic/Standard abbreviations
      ObjectGuid - Not supported
      InheritObjectGuid - Not supported
      SID - Abbreviated security ID (example WD == World)
            The S-w-x-y-z form for SIDs is not supported

    Example - "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access

Arguments:

    SecurityDescriptorString - Stringized security descriptor to be converted.

    SuppliedByDefaultMechanism - TRUE if the DACL is being built due to some
                                 default mechanism (ie, not manually specified
                                 by an admin, etc).

    SecurityDescriptorControlFlags - Receives control flags to apply if a
                                     security descriptor is made from the DACL.
                                     Receives 0 on error.

    DiscretionaryAcl - Receives ACL allocated from paged pool, or NULL on
                       error. A self-contained security descriptor can be made
                       with this ACL using the RtlAbsoluteToSelfRelativeSD
                       function.

Return Value:

    NTSTATUS

--*/
{
    PACL Dacl;
    PWSTR Curr, End;
    NTSTATUS Status;
    ULONG ControlFlags;

    PAGED_CODE();

    //
    // Preinit for error.
    //
    *DiscretionaryAcl = NULL;
    *SecurityDescriptorControlFlags = 0;

    //
    // Now, we'll just start parsing and building
    //
    Curr = ( PWSTR )SecurityDescriptorString;

    //
    // skip any spaces
    //
    while(*Curr == L' ' ) {
        Curr++;
    }

    //
    // There must be a DACL entry (SDDL_DACL is a 1-char string)
    //
    if (*Curr != SDDL_DACL[0]) {

        return STATUS_INVALID_PARAMETER;

    } else {

        Curr++;
    }

    if ( *Curr != SDDL_DELIMINATORC ) {

        return STATUS_INVALID_PARAMETER;

    } else {

        Curr++;
    }

    //
    // Look for the protected control flag. We will set the SE_DACL_DEFAULTED
    // bit if the ACL is being built using a default mechanism.
    //
    ControlFlags = SuppliedByDefaultMechanism ? SE_DACL_DEFAULTED : 0;

    if (*Curr == SDDL_PROTECTED[0]) {

        //
        // This flag doesn't do much for device objects. However, we do not
        // want to discourage it, as it's use makes sense in a lot of other
        // contexts!
        //
        Curr++;
        ControlFlags |= SE_DACL_PROTECTED;
    }

    //
    // Get the DACL corresponding to this SDDL string
    //
    Status = SepSddlGetAclForString( Curr, &Dacl, &End );

    if ( Status == STATUS_SUCCESS ) {

        Curr = End;

        while(*Curr == L' ' ) {
            Curr++;
        }

        if (*Curr != L'\0') {

            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if ( Status == STATUS_SUCCESS ) {

        *DiscretionaryAcl = Dacl;
        *SecurityDescriptorControlFlags = ControlFlags;

    } else {

        if ( Dacl ) {

            ExFreePool( Dacl );
            Dacl = NULL;
        }
    }

    return Status;
}


NTSTATUS
SepSddlGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End
    )
/*++

Routine Description:

    This routine will determine which sid is an appropriate match for the
    given string, either as a sid moniker or as a string representation of a
    sid (ie: "DA" or "S-1-0-0" )

Arguments:

    String - The string to be converted

    Sid - Where the created SID is to be returned. May receive NULL if the
        specified SID doesn't exist for the current platform!

    End - Where in the string we stopped processing


Return Value:

    STATUS_SUCCESS - success

    STATUS_NONE_MAPPED - An invalid format of the SID was given

--*/
{
    ULONG_PTR sidOffset;
    ULONG i;

    //
    // Set our end of string pointer
    //
    for ( i = 0; i < ARRAY_COUNT(SidLookup); i++ ) {

        //
        // check for the current key first
        //
        if ( _wcsnicmp( String, SidLookup[i].Key, SidLookup[i].KeyLen ) == 0 ) {

            *End = String += SidLookup[i].KeyLen;

#ifndef _KERNELIMPLEMENTATION_

            if ((SidLookup[i].OsVer == WINXP_OR_LATER) &&
                (!IoIsWdmVersionAvailable(1, 0x20))) {

                *SID = NULL;

            } else {

                sidOffset = SidLookup[ i ].ExportSidFieldOffset;
                *SID = *((PSID *) (((PUCHAR) SeExports) + sidOffset));
            }
#else
            *SID = *SidLookup[ i ].Sid;
#endif
            return STATUS_SUCCESS;
        }
    }

    *SID = NULL;
    return STATUS_NONE_MAPPED;
}


LOGICAL
SepSddlLookupAccessMaskInTable(
    IN PWSTR String,
    OUT ULONG *AccessMask,
    OUT PWSTR *End
    )
/*++

Routine Description:

    This routine will determine if the given access mask or string right exists
    in the lookup table.

    A pointer to the matching static lookup entry is returned.

Arguments:

    String - The string to be looked up

    AccessMask - Receives access mask if match is found.

    End - Adjusted string pointer

Return Value:

    TRUE if found, FALSE otherwise.

--*/
{
    ULONG i;

    for ( i = 0; i < ARRAY_COUNT(RightsLookup); i++ ) {

        if ( _wcsnicmp( String, RightsLookup[ i ].Key, RightsLookup[ i ].KeyLen ) == 0 ) {

            //
            // If a match was found, return it
            //
            *AccessMask = RightsLookup[ i ].Value;
            *End = String + RightsLookup[ i ].KeyLen;
            return TRUE;
        }
    }

    *AccessMask = 0;
    *End = String;
    return FALSE;
}


NTSTATUS
SepSddlGetAclForString(
    IN  PWSTR       AclString,
    OUT PACL       *Acl,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine convert a string into an ACL.  The format of the aces is:

    Ace := ( Type; Flags; Rights; ObjGuid; IObjGuid; Sid;
    Type : = A | D | OA | OD        {Access, Deny, ObjectAccess, ObjectDeny}
    Flags := Flags Flag
    Flag : = CI | IO | NP | SA | FA {Container Inherit,Inherit Only, NoProp,
                                     SuccessAudit, FailAdit }
    Rights := Rights Right
    Right := DS_READ_PROPERTY |  blah blah
    Guid := String representation of a GUID (via RPC UuidToString)
    Sid := DA | PS | AO | PO | AU | S-* (Domain Admins, PersonalSelf, Acct Ops,
                                         PrinterOps, AuthenticatedUsers, or
                                         the string representation of a sid)
    The seperator is a ';'.

    The returned ACL must be free via a call to ExFreePool


Arguments:

    AclString - The string to be converted

    Acl - Where the created ACL is to be returned

    End - Where in the string we stopped processing


Return Value:

    STATUS_SUCCESS indicates success

    STATUS_INSUFFICIENT_RESOURCES indicates a memory allocation for the ouput
                                  acl failed

    STATUS_INVALID_PARAMETER The string does not represent an ACL


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AclSize = 0, AclUsed = 0;
    ULONG Aces = 0, i, j;
    ULONG AccessMask;
    PWSTR Curr, MaskEnd;
    LOGICAL OpRes;
    PSTRSD_KEY_LOOKUP MatchedEntry;
    PSID SidPtr = NULL;

    //
    // First, we'll have to go through and count the number of entries that
    // we have.  We'll do the by computing the length of this ACL (which is
    // delimited by either the end of the list or a ':' that seperates a key
    // from a value
    //
    *Acl = NULL;
    *End = wcschr( AclString, SDDL_DELIMINATORC );

    if ( *End == AclString ) {

        return STATUS_INVALID_PARAMETER;
    }

    if ( *End == NULL ) {

        *End = AclString + wcslen( AclString );

    } else {

        ( *End )--;
    }

    //
    // Now, do the count
    //
    Curr = AclString;

    OpRes = 0;
    while ( Curr < *End ) {

        if ( *Curr == SDDL_SEPERATORC ) {

            Aces++;

        } else if ( *Curr != L' ' ) {
            OpRes = 1;
        }

        Curr++;
    }

    //
    // Now, we've counted the total number of seperators.  Make sure we
    // have the right number.  (There is 5 seperators per ace)
    //
    if ( Aces % 5 == 0 ) {

        if ( Aces == 0 && OpRes ) {

            //
            // gabbage chars in between
            //
            Status = STATUS_INVALID_PARAMETER;

        } else {

            Aces = Aces / 5;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // This is an empty ACL (ie no access to anyone, including the system)
    //
    if (( Status == STATUS_SUCCESS ) && ( Aces == 0 )) {

        *Acl = ExAllocatePoolWithTag( PagedPool, sizeof( ACL ), POOLTAG_SEACL );

        if ( *Acl == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlZeroMemory( *Acl, sizeof( ACL ));

            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1 = ( UCHAR )0;
            ( *Acl )->AclSize = ( USHORT )sizeof( ACL );
            ( *Acl )->AceCount = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;
        }

        return Status;
    }

    //
    // Ok now do the allocation.  We'll do a sort of worst case initial
    // allocation.  This saves us from having to process everything twice
    // (once to size, once to build).  If we determine later that we have
    // an acl that is not big enough, we allocate additional space.  The only
    // time that this reallocation should happen is if the input string
    // contains a lot of explicit SIDs.  Otherwise, the chosen buffer size
    // should be pretty close to the proper size
    //
    if ( Status == STATUS_SUCCESS ) {

        AclSize = sizeof( ACL ) + ( Aces * ( sizeof( ACCESS_ALLOWED_ACE ) +
                                            sizeof( SID ) + ( 6 * sizeof( ULONG ) ) ) );
        if ( AclSize > SDDL_MAX_ACL_SIZE ) {
            AclSize = SDDL_MAX_ACL_SIZE;
        }

        *Acl = ( PACL ) ExAllocatePoolWithTag( PagedPool, AclSize, POOLTAG_SEACL );

        if ( *Acl == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            AclUsed = sizeof( ACL );

            RtlZeroMemory( *Acl, AclSize );

            //
            // We'll start initializing it...
            //
            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1        = ( UCHAR )0;
            ( *Acl )->AclSize     = ( USHORT )AclSize;
            ( *Acl )->AceCount    = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;

            //
            // Ok, now we'll go through and start building them all
            //
            Curr = AclString;

            for( i = 0; i < Aces; i++ ) {

                //
                // First, get the type..
                //
                UCHAR Flags = 0;
                USHORT Size;
                ACCESS_MASK Mask = 0;
                PWSTR  Next;
                ULONG AceSize = 0;

                //
                // skip any space before (
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Skip any parens that may exist in the ace list
                //
                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }

                //
                // skip any space after (
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Look for an allow ACE
                //
                if ( _wcsnicmp( Curr, SDDL_ACCESS_ALLOWED, SDDL_LEN_TAG( SDDL_ACCESS_ALLOWED ) ) == 0 ) {

                    Curr += SDDL_LEN_TAG( SDDL_ACCESS_ALLOWED ) + 1;

                } else {

                    //
                    // Found an invalid type
                    //
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // This function doesn't support any ACE Flags. As such, any
                // flags found are invalid
                //
                if ( *Curr == SDDL_SEPERATORC ) {

                    Curr++;

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // skip any space after ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Now, get the access mask
                //
                while( TRUE ) {

                    if ( *Curr == SDDL_SEPERATORC ) {

                        Curr++;
                        break;
                    }

                    //
                    // Skip any blanks
                    //
                    while ( *Curr == L' ' ) {

                        Curr++;
                    }

                    if (SepSddlLookupAccessMaskInTable( Curr, &AccessMask, &MaskEnd )) {

                        Mask |= AccessMask;
                        Curr = MaskEnd;

                    } else {

                        //
                        // If the rights couldn't be looked up, see if it's a
                        // converted mask
                        //
#ifndef _KERNELIMPLEMENTATION_
                        SepSddlParseWideStringUlong(Curr, &MaskEnd, &Mask);
#else
                        Mask = wcstoul( Curr, &MaskEnd, 0 );
#endif

                        if ( MaskEnd != Curr ) {

                            Curr = MaskEnd;

                        } else {

                            //
                            // Found an invalid right
                            //
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }
                }

                if ( Status != STATUS_SUCCESS ) {

                    break;
                }

                //
                // If that worked, we'll get the ids
                //
                for ( j = 0; j < 2; j++ ) {

                    //
                    // skip any space before ;
                    //
                    while(*Curr == L' ' ) {
                        Curr++;
                    }

                    if ( *Curr != SDDL_SEPERATORC ) {

                        //
                        // Object GUIDs are not supported, as this function
                        // currently doesn't handle object-allow ACEs.
                        //
                        Status = STATUS_INVALID_PARAMETER;
                    }

                    Curr++;
                }

                if ( Status != STATUS_SUCCESS ) {

                    break;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Finally, the SID
                //
                if ( STATUS_SUCCESS == Status ) {

                    PWSTR EndLocation;
                    Status = SepSddlGetSidForString( Curr, &SidPtr, &EndLocation );

                    if ( Status == STATUS_SUCCESS ) {

                        if ( EndLocation == NULL ) {

                            Status = STATUS_INVALID_ACL;

                        } else {

                            while(*EndLocation == L' ' ) {
                                EndLocation++;
                            }
                            //
                            // a ace must be terminated by ')'
                            //
                            if ( *EndLocation != SDDL_ACE_ENDC ) {

                                Status = STATUS_INVALID_ACL;

                            } else {

                                Curr = EndLocation + 1;
                            }
                        }
                    }
                }

                //
                // Quit on an error
                //
                if ( Status != STATUS_SUCCESS ) {

                    break;
                }

                //
                // Note that the SID pointer may be NULL if the SID wasn't
                // relevant for this OS version.
                //
                if (SidPtr != NULL) {

                    //
                    // Now, we'll create the ace, and add it...
                    //
                    Status = SepSddlAddAceToAcl( Acl,
                                                 &AclUsed,
                                                 ACCESS_ALLOWED_ACE_TYPE,
                                                 Flags,
                                                 Mask,
                                                 ( Aces - i ),
                                                 SidPtr );

                    //
                    // Handle any errors
                    //
                    if ( Status != STATUS_SUCCESS ) {

                        break;
                    }
                }

                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }
            }

            //
            // If something didn't work, clean up
            //
            if ( Status != STATUS_SUCCESS ) {

                ExFreePool( *Acl );
                *Acl = NULL;

            } else {

                //
                // Set a more realistic acl size
                //
                ( *Acl )->AclSize = ( USHORT )AclUsed;
            }
        }
    }

    return Status;
}


NTSTATUS
SepSddlAddAceToAcl(
    IN OUT  PACL   *Acl,
    IN OUT  ULONG  *TrueAclSize,
    IN      ULONG   AceType,
    IN      ULONG   AceFlags,
    IN      ULONG   AccessMask,
    IN      ULONG   RemainingAces,
    IN      PSID    SidPtr
    )
/*++

Routine Description:

    This routine adds an ACE to the passed in ACL, growing the ACL size as
    neccessary.

Arguments:

    Acl - Specifies the ACL to receive the new ACE. May be reallocated if
          Acl->AclSize cannot contain the ACE.

    TrueAclSize - Contains the true working size of the ACL (as opposed to
                  Acl->AclSize, which may be bigger for performance reasons)

    AceType - Type of ACE to add. Currently, only ACCESS_ALLOW ACEs are
              supported.

    AceFlags - Ace control flags, specifying inheritance, etc.
               *Currently this must be zero*!!!!

    AccessMask - Contains the ACCESS rights mask for the ACE

    SID - Contains the SID for the ACE.

Return Value:

    STATUS_SUCCESS indicates success

    STATUS_INSUFFICIENT_RESOURCES indicates a memory allocation for the ouput
                                  acl failed

--*/
{
    PACL WorkingAcl;
    ULONG WorkingAclSize;
    ULONG AceSize;

    ASSERT(AceType == ACCESS_ALLOWED_ACE_TYPE);
    ASSERT(RemainingAces != 0);

#ifndef _KERNELIMPLEMENTATION_
    ASSERT(AceFlags == 0);
#endif

    WorkingAcl = *Acl;
    WorkingAclSize = *TrueAclSize;

    //
    // First, make sure we have the room for it
    // ACCESS_ALLOWED_ACE_TYPE:
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE );

    AceSize += RtlLengthSid( SidPtr ) - sizeof( ULONG );

    if (AceSize + WorkingAclSize > WorkingAcl->AclSize) {

        //
        // We'll have to reallocate, since our buffer isn't big enough. Assume
        // all the remaining ACE's will be as big as this one is...
        //
        PACL  NewAcl;
        ULONG NewSize = WorkingAclSize + ( RemainingAces * AceSize );

        NewAcl = ( PACL ) ExAllocatePoolWithTag( PagedPool, NewSize, POOLTAG_SEACL );
        if ( NewAcl == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Copy over the new data.
            //
            RtlZeroMemory( NewAcl, NewSize);
            RtlCopyMemory( NewAcl, *Acl, WorkingAclSize );

            NewAcl->AclSize = ( USHORT )NewSize;

            ExFreePool( WorkingAcl );

            *Acl = NewAcl;
            WorkingAcl = NewAcl;
        }
    }

    WorkingAclSize += AceSize;

    *TrueAclSize = WorkingAclSize;

#ifndef _KERNELIMPLEMENTATION_

    //
    // Our ACE is an Allow ACE
    //
    return RtlAddAccessAllowedAce( WorkingAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   SidPtr );

#else

    //
    // This version is not exported by the kernel today...
    //
    return RtlAddAccessAllowedAceEx( WorkingAcl,
                                     ACL_REVISION,
                                     AceFlags,
                                     AccessMask,
                                     SidPtr );

#endif // _KERNELIMPLEMENTATION_
}


#ifndef _KERNELIMPLEMENTATION_

LOGICAL
SepSddlParseWideStringUlong(
    IN  LPCWSTR     Buffer,
    OUT LPCWSTR    *FinalPosition,
    OUT ULONG      *Value
    )
/*++

Routine Description:

    This routine parses a wide string for an unsigned long, in a similar
    fashion to wcstoul. It exists because not all CRT library string functions
    are exported by the kernel today.

Arguments:

    Buffer - Points to location in string to begin parsing.

    FinalPosition - Receives final string location, Buffer on error.

    Value - Receives value parsed by routine, 0 on error.

Return Value:

    TRUE if the parse succeeded, FALSE if it failed.

--*/
{
    ULONG oldValue, newValue, newDigit, base;
    LPCWSTR curr, initial;

    PAGED_CODE();

    //
    // Preinit
    //
    *Value = 0;
    *FinalPosition = Buffer;
    initial = Buffer;
    curr = initial;

    if ((curr[0] == L'0') && ((curr[1] == L'x') || (curr[1] == L'X'))) {

        //
        // Starts with 0x, skip the rest.
        //
        initial += 2;
        curr = initial;
        base = 16;

    } else if ((curr[0] >= L'0') && (curr[0] <= L'9')) {

        base = 10;

    } else {

        base = 16;
    }

    oldValue = 0;

    while(curr[0]) {

        if ((curr[0] >= L'0') && (curr[0] <= L'9')) {

            newDigit = curr[0] - L'0';

        } else if ((base == 16) && (curr[0] >= L'A') && (curr[0] <= L'F')) {

            newDigit = curr[0] - L'A' + 10;

        } else if ((base == 16) && (curr[0] >= L'a') && (curr[0] <= L'f')) {

            newDigit = curr[0] - L'a' + 10;

        } else {

            break;
        }

        newValue = (oldValue * base) + newDigit;
        if (newValue < oldValue) {

            //
            // Wrapped, too many digits
            //
            return FALSE;
        }

        oldValue = newValue;
        curr++;
    }

    //
    // No real digits were found.
    //
    if (curr == initial) {

        return FALSE;
    }

    *FinalPosition = curr;
    *Value = oldValue;
    return TRUE;
}

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\se\sepsddl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SepSddl.h

Abstract:

    This header contains private information for processing SDDL strings
    in kernel mode. This file is meant to be included only by sesddl.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// Define the location of our various SIDs
//
#ifndef _KERNELIMPLEMENTATION_

#define DEFINE_SDDL_ENTRY(Sid, Ver, Sddl, SddlLen) \
    { FIELD_OFFSET(SE_EXPORTS, Sid), Ver, Sddl, SddlLen }

#else

extern PSID SeServiceSid;
extern PSID SeLocalServiceSid;
extern PSID SeNetworkServiceSid;

#define DEFINE_SDDL_ENTRY(Sid, Ver, Sddl, SddlLen) \
    { &##Sid, Sddl, SddlLen }

#endif

//
// Local macros
//
#define SDDL_LEN_TAG( tagdef )  ( sizeof( tagdef ) / sizeof( WCHAR ) - 1 )

// 64K-1
#define SDDL_MAX_ACL_SIZE      0xFFFF

//
// This structure is used to do some lookups for mapping ACES
//
typedef enum {

    WIN2K_OR_LATER,
    WINXP_OR_LATER

} OS_SID_VER;

typedef struct _STRSD_KEY_LOOKUP {

    PWSTR Key;
    ULONG KeyLen;
    ULONG Value;

} STRSD_KEY_LOOKUP, *PSTRSD_KEY_LOOKUP;

//
// This structure is used to map account monikers to sids
//
typedef struct _STRSD_SID_LOOKUP {

#ifndef _KERNELIMPLEMENTATION_
    ULONG_PTR   ExportSidFieldOffset;
    OS_SID_VER  OsVer;
#else
    PSID        *Sid;
#endif

    WCHAR       Key[SDDL_ALIAS_SIZE+2];
    ULONG       KeyLen;

} STRSD_SID_LOOKUP, *PSTRSD_SID_LOOKUP;


//
// Functions private to sddl.c
//
NTSTATUS
SepSddlSecurityDescriptorFromSDDLString(
    IN  LPCWSTR                 SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    );

NTSTATUS
SepSddlDaclFromSDDLString(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  LOGICAL SuppliedByDefaultMechanism,
    OUT ULONG  *SecurityDescriptorControlFlags,
    OUT PACL   *DiscretionaryAcl
    );

NTSTATUS
SepSddlGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End
    );

LOGICAL
SepSddlLookupAccessMaskInTable(
    IN PWSTR String,
    OUT ULONG *AccessMask,
    OUT PWSTR *End
    );

NTSTATUS
SepSddlGetAclForString(
    IN  PWSTR AclString,
    OUT PACL *Acl,
    OUT PWSTR *End
    );

NTSTATUS
SepSddlAddAceToAcl(
    IN OUT  PACL   *Acl,
    IN OUT  ULONG  *TrueAclSize,
    IN      ULONG   AceType,
    IN      ULONG   AceFlags,
    IN      ULONG   AccessMask,
    IN      ULONG   RemainingAces,
    IN      PSID    SidPtr
    );

#ifndef _KERNELIMPLEMENTATION_

LOGICAL
SepSddlParseWideStringUlong(
    IN  LPCWSTR     Buffer,
    OUT LPCWSTR    *FinalPosition,
    OUT ULONG      *Value
    );

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\pp\ppregstate.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpRegState.c

Abstract:

    This module contains functions for reading and writing PnP registry state
    information.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "PiRegstate.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpRegStateReadCreateClassCreationSettings)
#pragma alloc_text(PAGE, PiRegStateReadStackCreationSettingsFromKey)
#pragma alloc_text(PAGE, PpRegStateInitEmptyCreationSettings)
#pragma alloc_text(PAGE, PiRegStateOpenClassKey)
#pragma alloc_text(PAGE, PpRegStateUpdateStackCreationSettings)
#pragma alloc_text(PAGE, PpRegStateFreeStackCreationSettings)
#pragma alloc_text(PAGE, PpRegStateLoadSecurityDescriptor)
#endif

//
// Since RtlAddAccessAllowedAceEx isn't exported by the kernel, we must
// hardcode this security descriptor. It is used to make PnP keys that are
// purposely hard to tamper with (SYS_ALL, object/container inherit).
//
ULONG PiRegStateSysAllInherittedSecurityDescriptor[0xC] = {
    0x94040001, 0x00000000, 0x00000000, 0x00000000,
    0x00000014, 0x001c0002, 0x00000001, 0x00140300,
    0x10000000, 0x00000101, 0x05000000, 0x00000012
    };

PIDESCRIPTOR_STATE PiRegStateDiscriptor = NOT_VALIDATED;

NTSTATUS
PpRegStateReadCreateClassCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PDRIVER_OBJECT              DriverObject,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine either retrieves or creates a set of stack creation settings
    for the given class GUID.

Arguments:

    DeviceClassGuid - Guid representing the class.

    DriverObject - Driver object of the device being created. This is used to
        build a class name in the event the class doesn't yet exist in the
        registry.

    StackCreationSettings - Receives settings retrieved from the registry (or
        new settings if the registry contains no information.)

Return Value:

    NTSTATUS (On error, StackCreationSettings is updated to reflect
        "no settings").

--*/
{
    PUNICODE_STRING serviceName;
    HANDLE classPropertyKey;
    HANDLE classKey;
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for failure
    //
    classKey = NULL;
    classPropertyKey = NULL;
    PpRegStateInitEmptyCreationSettings(StackCreationSettings);

    //
    // Try to find the appropriate security descriptor for the device. First
    // look for an override in the registry using the class GUID. We will
    // create a section in the registry if one doesn't exist as well. This is
    // a clue to the system administrator that there is something to lock down
    // in the system.
    //
    status = PiRegStateOpenClassKey(
        DeviceClassGuid,
        KEY_ALL_ACCESS,
        TRUE,           // CreateIfNotPresent
        &disposition,
        &classKey
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Check the disposition to see if we created the key for the first time
    //
    if (disposition == REG_OPENED_EXISTING_KEY) {

        //
        // The class is valid, but does it have a property key?
        //
        status = CmRegUtilOpenExistingWstrKey(
            classKey,
            REGSTR_KEY_DEVICE_PROPERTIES,
            KEY_READ,
            &classPropertyKey
            );

        //
        // At this point, class key is no longer needed.
        //
        ZwClose(classKey);

        if (NT_SUCCESS(status)) {

            //
            // The key exists, so try reading the settings from registry.
            //
            status = PiRegStateReadStackCreationSettingsFromKey(
                classPropertyKey,
                StackCreationSettings
                );

            //
            // At this point, class property key is no longer needed.
            //
            ZwClose(classPropertyKey);

        } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // No property key means no override, stick with defaults...
            //
            status = STATUS_SUCCESS;

        } else {

            //
            // Some sort of unexpected error, bail.
            //
            return status;
        }

    } else {

        //
        // New class key: populate the class name using the service's name.
        //
        serviceName = &DriverObject->DriverExtension->ServiceKeyName;

        //
        // In low memory scenarios, existing kernels (Win2K, etc) may choose
        // not to save the service name.
        //
        if (serviceName == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Write out the class value
            //
            status = CmRegUtilWstrValueSetUcString(
                classKey,
                REGSTR_VAL_CLASS,
                serviceName
                );
        }

        //
        // At this point, class key is no longer needed.
        //
        ZwClose(classKey);
    }

    //
    // Return the result.
    //
    return status;
}


NTSTATUS
PiRegStateReadStackCreationSettingsFromKey(
    IN  HANDLE                      ClassOrDeviceKey,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine reads stack creation settings from the registry. It assumes
    the passed in handle points to either a device-class property key or a
    devnode instance key.

Arguments:

    ClassOrDeviceKey   - Points to either a device-class *property* key, or a
        per-devnode instance key.

    StackCreationSettings - Receives settings retrieved from the registry.

Return Value:

    STATUS_SUCCESS in which case StackCreationSettings may receive any number
    of possible overrides (including no overrides at all). On error, all fields
    receive default values.

--*/
{
    PKEY_VALUE_FULL_INFORMATION keyInfo;
    PSECURITY_DESCRIPTOR embeddedSecurityDescriptor;
    PSECURITY_DESCRIPTOR newSecurityDescriptor;
    SECURITY_INFORMATION securityInformation;
    BOOLEAN daclFromDefaultMechanism;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for error
    //
    keyInfo = NULL;
    PpRegStateInitEmptyCreationSettings(StackCreationSettings);

    //
    // Read in the security descriptor
    //
    status = CmRegUtilWstrValueGetFullBuffer(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
        REG_BINARY,
        0,
        &keyInfo
        );

    //
    // Capture/validate the embedded security descriptor if present
    //
    if (NT_SUCCESS(status)) {

        embeddedSecurityDescriptor = (PSECURITY_DESCRIPTOR) KEY_VALUE_DATA(keyInfo);

        status = SeCaptureSecurityDescriptor(
            embeddedSecurityDescriptor,
            KernelMode,
            PagedPool,
            TRUE,
            &newSecurityDescriptor
            );

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Special case a missing security descriptor
        //
        newSecurityDescriptor = NULL;
        status = STATUS_SUCCESS;
    }

    //
    // Cleanup
    //
    if (keyInfo) {

        ExFreePool(keyInfo);
    }

    if (!NT_SUCCESS(status)) {

        goto ErrorExit;
    }

    //
    // Save this information away.
    //
    if (newSecurityDescriptor) {

        //
        // Was this DACL set by an admin, or is this just our own DACL written
        // out for everyone to see?
        //
        status = SeUtilSecurityInfoFromSecurityDescriptor(
            newSecurityDescriptor,
            &daclFromDefaultMechanism,
            &securityInformation
            );

        if (!NT_SUCCESS(status)) {

            goto ErrorExit;
        }

        if (daclFromDefaultMechanism) {

            //
            // The DACL is our own, possibly from a previous boot or prior
            // unload. We will ignore it, as a newer driver might have chosen
            // to update the default DACL.
            //
            ExFreePool(newSecurityDescriptor);

        } else {

            //
            // The admin manually specified an overriding DACL. Honor it.
            //
            StackCreationSettings->SecurityDescriptor = newSecurityDescriptor;
            StackCreationSettings->Flags |= DSIFLAG_SECURITY_DESCRIPTOR;
        }
    }

    //
    // Look for a device type
    //
    status = CmRegUtilWstrValueGetDword(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_TYPE,
        FILE_DEVICE_UNSPECIFIED,
        &StackCreationSettings->DeviceType
        );

    if (NT_SUCCESS(status)) {

        StackCreationSettings->Flags |= DSIFLAG_DEVICE_TYPE;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto ErrorExit;
    }

    //
    // Look for characteristics
    //
    status = CmRegUtilWstrValueGetDword(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_CHARACTERISTICS,
        0,
        &StackCreationSettings->Characteristics
        );

    if (NT_SUCCESS(status)) {

        StackCreationSettings->Flags |= DSIFLAG_CHARACTERISTICS;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto ErrorExit;
    }

    //
    // And finally, look for the exclusivity bit
    //
    status = CmRegUtilWstrValueGetDword(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_EXCLUSIVE,
        0,
        &StackCreationSettings->Exclusivity
        );

    if (NT_SUCCESS(status)) {

        StackCreationSettings->Flags |= DSIFLAG_EXCLUSIVE;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto ErrorExit;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;

ErrorExit:

    if (StackCreationSettings->SecurityDescriptor) {

        ExFreePool(StackCreationSettings->SecurityDescriptor);
    }

    PpRegStateInitEmptyCreationSettings(StackCreationSettings);

    return status;
}


VOID
PpRegStateInitEmptyCreationSettings(
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine creates an initially empty set of stack creation settings.

Arguments:

    StackCreationSettings - Structure to fill out.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    StackCreationSettings->Flags = 0;
    StackCreationSettings->SecurityDescriptor = NULL;
    StackCreationSettings->DeviceType = FILE_DEVICE_UNSPECIFIED;
    StackCreationSettings->Characteristics = 0;
    StackCreationSettings->Exclusivity = 0;
}


NTSTATUS
PiRegStateOpenClassKey(
    IN  LPCGUID         DeviceClassGuid,
    IN  ACCESS_MASK     DesiredAccess,
    IN  LOGICAL         CreateIfNotPresent,
    OUT ULONG          *Disposition         OPTIONAL,
    OUT HANDLE         *ClassKeyHandle
    )
/*++

Routine Description:

    This routine reads opens the specified class key, creating it anew as
    needed.

Arguments:

    DeviceClassGuid - Guid representing the class.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    CreateIfNotPresent - If set, the class key is created if it doesn't exist.

    Disposition - This optional pointer receives a ULONG indicating whether
        the key was newly created (0 on error):

        REG_CREATED_NEW_KEY - A new Registry Key was created.
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened.

    ClassKeyHandle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

    STATUS_SUCCESS in which case StackCreationSettings may receive any number
    of possible overrides (including no overrides at all). On error, all fields
    receive default values.

--*/
{
    WCHAR classGuidString[39];
    HANDLE classBranchKey;
    HANDLE classKey;
    ULONG createDisposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for error.
    //
    *ClassKeyHandle = NULL;
    if (ARGUMENT_PRESENT(Disposition)) {

        *Disposition = 0;
    }

    //
    // Open the class key branch.
    //
    // Note: Inside the kernel this should be a NULL path relative open off of
    // &CmRegistryMachineSystemCurrentControlSetControlClass, as that handle
    // is cached.
    //
    status = CmRegUtilOpenExistingWstrKey(
        NULL,
        CM_REGISTRY_MACHINE(REGSTR_PATH_CLASS_NT),
        KEY_READ,
        &classBranchKey
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Convert the binary GUID into it's corresponding unicode string.
    //
    _snwprintf(
        classGuidString,
        sizeof(classGuidString)/sizeof(WCHAR),
        L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        DeviceClassGuid->Data1,
        DeviceClassGuid->Data2,
        DeviceClassGuid->Data3,
        DeviceClassGuid->Data4[0],
        DeviceClassGuid->Data4[1],
        DeviceClassGuid->Data4[2],
        DeviceClassGuid->Data4[3],
        DeviceClassGuid->Data4[4],
        DeviceClassGuid->Data4[5],
        DeviceClassGuid->Data4[6],
        DeviceClassGuid->Data4[7]
        );

    //
    // Make prefast happy
    //
    classGuidString[(sizeof(classGuidString)/sizeof(WCHAR)) - 1] = UNICODE_NULL;

    if (CreateIfNotPresent) {

        //
        // Now try to open or create the class key. If newly created, the
        // security will be inherited from the parent Class\ key.
        //
        status = CmRegUtilCreateWstrKey(
            classBranchKey,
            classGuidString,
            DesiredAccess,
            REG_OPTION_NON_VOLATILE,
            NULL,
            &createDisposition,
            &classKey
            );

    } else {

        status = CmRegUtilOpenExistingWstrKey(
            classBranchKey,
            classGuidString,
            DesiredAccess,
            &classKey
            );

        //
        // Set the disposition appropriately.
        //
        createDisposition = REG_OPENED_EXISTING_KEY;
    }

    //
    // We don't need this anymore
    //
    ZwClose(classBranchKey);

    if (NT_SUCCESS(status)) {

        *ClassKeyHandle = classKey;

        if (ARGUMENT_PRESENT(Disposition)) {

            *Disposition = createDisposition;
        }
    }

    return status;
}


NTSTATUS
PpRegStateUpdateStackCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine updates the class key in the registry to reflect the passed in
    stack creation settings. The key is assumed to already exist.

Arguments:

    DeviceClassGuid - Guid representing the class.

    StackCreationSettings - Information reflecting the settings to apply.

Return Value:

    NTSTATUS.

--*/
{
    PSECURITY_DESCRIPTOR tempDescriptor;
    ULONG sizeOfDescriptor;
    HANDLE classPropertyKey;
    HANDLE classKey;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Currently this code only supports updating the security descriptor
    // in the registry.
    //
    ASSERT(StackCreationSettings->Flags == DSIFLAG_SECURITY_DESCRIPTOR);

    //
    // Open the class key (it should exist)
    //
    status = PiRegStateOpenClassKey(
        DeviceClassGuid,
        KEY_ALL_ACCESS,
        FALSE,          // CreateIfNotPresent
        NULL,
        &classKey
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Double check our hardcoded descriptor...
    //
    if (PiRegStateDiscriptor == NOT_VALIDATED) {

        status = SeCaptureSecurityDescriptor(
            (PSECURITY_DESCRIPTOR) PiRegStateSysAllInherittedSecurityDescriptor,
            KernelMode,
            PagedPool,
            TRUE,
            &tempDescriptor
            );

        if (NT_SUCCESS(status)) {

            PiRegStateDiscriptor = VALIDATED_SUCCESSFULLY;
            ExFreePool(tempDescriptor);

        } else {

            ASSERT(0);
            PiRegStateDiscriptor = VALIDATED_UNSUCCESSFULLY;
        }
    }

    //
    // Get the correct descriptor value.
    //
    if (PiRegStateDiscriptor == VALIDATED_SUCCESSFULLY) {

        //
        // Use the tamper-resistant descriptor (due to history, the class keys
        // themselves can be accessed by admins. However, the class property
        // key had tighter security placed on it. We maintain that tradition.)
        //
        tempDescriptor = (PSECURITY_DESCRIPTOR) PiRegStateSysAllInherittedSecurityDescriptor;

    } else {

        //
        // Second best, we'll inherit an admin all descriptor from the class
        // container.
        //
        tempDescriptor = (PSECURITY_DESCRIPTOR) NULL;
    }

    //
    // Now try to open or create the class property key.
    //
    status = CmRegUtilCreateWstrKey(
        classKey,
        REGSTR_KEY_DEVICE_PROPERTIES,
        KEY_ALL_ACCESS,
        REG_OPTION_NON_VOLATILE,
        tempDescriptor,
        NULL,
        &classPropertyKey
        );

    //
    // No need for the class key anymore.
    //
    ZwClose(classKey);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Write out the security descriptor to the registry
    //
    sizeOfDescriptor = RtlLengthSecurityDescriptor(
        StackCreationSettings->SecurityDescriptor
        );

    status = CmRegUtilWstrValueSetFullBuffer(
        classPropertyKey,
        REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
        REG_BINARY,
        StackCreationSettings->SecurityDescriptor,
        sizeOfDescriptor
        );

    //
    // Close the property key
    //
    ZwClose(classPropertyKey);

    //
    // Done.
    //
    return status;
}


VOID
PpRegStateFreeStackCreationSettings(
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine frees any state allocated against the passed in stack creation
    settings.

Arguments:

    StackCreationSettings - Information to free.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Clean up the security descriptor as appropriate.
    //
    if (StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR) {

        ExFreePool(StackCreationSettings->SecurityDescriptor);
    }
}


VOID
PpRegStateLoadSecurityDescriptor(
    IN      PSECURITY_DESCRIPTOR        SecurityDescriptor,
    IN OUT  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine updates the stack creation settings to reflect the passed in
    security descriptor.

Arguments:

    SecurityDescriptor - Security descriptor to load into the stack creation
        settings.

    StackCreationSettings - Stack creation settings to update.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ASSERT(!(StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR));
    StackCreationSettings->Flags = DSIFLAG_SECURITY_DESCRIPTOR;
    StackCreationSettings->SecurityDescriptor = SecurityDescriptor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\se\sesddl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SeSddl.h

Abstract:

    This header exposes routines for processing SDDL strings.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTSTATUS
SeSddlSecurityDescriptorFromSDDL(
    IN  PCUNICODE_STRING        SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\se\seutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SeUtil.h

Abstract:

    This header exposes various security utility functions.

Author:

    Adrian J. Oney  - April 23, 2002

Revision History:

--*/

NTSTATUS
SeUtilSecurityInfoFromSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor,
    OUT BOOLEAN                *DaclFromDefaultSource,
    OUT PSECURITY_INFORMATION   SecurityInformation
    );

#ifndef _KERNELIMPLEMENTATION_

VOID
SeSetSecurityAccessMask(
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT ACCESS_MASK            *DesiredAccess
    );

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\wl\wlprivate.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlPrivate.h

Abstract:

    This header contains prototypes for various routines that are exported by
    the kernel, but not exposed by any public headers.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTKERNELAPI
NTSTATUS
ObSetSecurityObjectByPointer(
    IN PVOID Object,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTKERNELAPI
NTSTATUS
SeCaptureSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    IN KPROCESSOR_MODE RequestorMode,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    IN  PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PULONG BufferLength
    );

#if 0

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PBOOLEAN OwnerDefaulted
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\wl\wlpwrap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlpWrap.h

Abstract:

    This header contains private information for wrapping library functions.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

typedef NTSTATUS (*PFN_IO_CREATE_DEVICE_SECURE)(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid,
    OUT PDEVICE_OBJECT     *DeviceObject
    );


typedef NTSTATUS
(*PFN_IO_VALIDATE_DEVICE_IOCONTROL_ACCESS)(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    );

VOID
WdmlibInit(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\se\seutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SeUtil.c

Abstract:

    This module contains various security utility functions.

Author:

    Adrian J. Oney  - April 23, 2002

Revision History:

--*/

#include "WlDef.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SeUtilSecurityInfoFromSecurityDescriptor)
#ifndef _KERNELIMPLEMENTATION_
#pragma alloc_text(PAGE, SeSetSecurityAccessMask)
#endif
#endif


NTSTATUS
SeUtilSecurityInfoFromSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor,
    OUT BOOLEAN                *DaclFromDefaultSource,
    OUT PSECURITY_INFORMATION   SecurityInformation
    )
/*++

Routine Description:

    This routine retrieves security information from a security descriptor.

Arguments:

    SecurityDescriptor - Security descriptor to retrieve information from.

    DaclFromDefaultSource - Receives TRUE if the DACL was constructed by a
        default mechanism.

    SecurityInformation - Information as extracted from the descriptor.

Return Value:

    NTSTATUS (On error, SecurityInformation receives 0).

--*/
{
    SECURITY_INFORMATION finalSecurityInformation;
    BOOLEAN fromDefaultSource;
    BOOLEAN aclPresent;
    NTSTATUS status;
    PSID sid;
    PACL acl;

    PAGED_CODE();

    //
    // Preinitialize the security information to zero.
    //
    *DaclFromDefaultSource = FALSE;
    RtlZeroMemory(SecurityInformation, sizeof(SECURITY_INFORMATION));
    finalSecurityInformation = 0;

    //
    // Extract the owner information.
    //
    status = RtlGetOwnerSecurityDescriptor(
        SecurityDescriptor,
        &sid,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (sid != NULL) {

        finalSecurityInformation |= OWNER_SECURITY_INFORMATION;
    }

    //
    // Extract the group information.
    //
    status = RtlGetGroupSecurityDescriptor(
        SecurityDescriptor,
        &sid,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (sid != NULL) {

        finalSecurityInformation |= GROUP_SECURITY_INFORMATION;
    }

    //
    // Extract the SACL (Auditing ACL) information.
    //
    status = RtlGetSaclSecurityDescriptor(
        SecurityDescriptor,
        &aclPresent,
        &acl,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (aclPresent) {

        finalSecurityInformation |= SACL_SECURITY_INFORMATION;
    }

    //
    // Extract the DACL (discretionary/access ACL) information.
    //
    status = RtlGetDaclSecurityDescriptor(
        SecurityDescriptor,
        &aclPresent,
        &acl,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (aclPresent) {

        finalSecurityInformation |= DACL_SECURITY_INFORMATION;
    }

    //
    // Return the final result.
    //
    *DaclFromDefaultSource = fromDefaultSource;
    *SecurityInformation = finalSecurityInformation;
    return STATUS_SUCCESS;
}


#ifndef _KERNELIMPLEMENTATION_

VOID
SeSetSecurityAccessMask(
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT ACCESS_MASK            *DesiredAccess
    )
/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;
}

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\ahcache.c ===
/*
    Cache handling functions for use in kernel32.dll


    VadimB




*/

#include "basedll.h"
#pragma hdrstop



#ifdef DbgPrint
#undef DbgPrint
#endif

#define DbgPrint 0 && DbgPrint


#define APPCOMPAT_CACHE_KEY_NAME \
    L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

#define APPCOMPAT_CACHE_VALUE_NAME \
    L"AppCompatCache"

static UNICODE_STRING AppcompatKeyPathLayers =
    RTL_CONSTANT_STRING(L"\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers");

//
// The number of cache entries we maintain
//
#define MAX_SHIM_CACHE_ENTRIES 96

//
// The default cache timeout. This timeout affects the maximum delay
// that we can incur due to congestion for the shared mutex.
//
#define SHIM_CACHE_TIMEOUT     100

//
// Magic DWORD to recognize valid buffer
//
#define SHIM_CACHE_MAGIC       0xDEADBEEF


//
// Reasons for having to call into apphelp.dll
// these flags are also defined in apphelp.h (windows\appcompat\apphelp)
//

#ifndef SHIM_CACHE_NOT_FOUND

#define SHIM_CACHE_NOT_FOUND 0x00000001
#define SHIM_CACHE_BYPASS    0x00000002 // bypass cache (either removable media or temp dir)
#define SHIM_CACHE_LAYER_ENV 0x00000004 // layer env variable set
#define SHIM_CACHE_MEDIA     0x00000008
#define SHIM_CACHE_TEMP      0x00000010
#define SHIM_CACHE_NOTAVAIL  0x00000020

#endif
//
// definitions of our internal data types
//

#pragma pack(8)

typedef struct tagSHIMCACHEENTRY {
    WCHAR wszPath[MAX_PATH + 1];

    //
    // Creation time and size of the file. It is used to verify that
    // the file is still there and the same (as opposed to patched exe's, etc)
    //
    LONGLONG FileTime; // creation time
    LONGLONG FileSize; // size of the file

    //
    // timestamp - when did we touch this item last
    //
    LONGLONG TimeStamp;

} SHIMCACHEENTRY;

typedef SHIMCACHEENTRY *PSHIMCACHEENTRY;

//
// The content of the shared section for use with our caching mechanism.
//
typedef struct tagSHIMCACHEHEADER {
    DWORD          dwMagic;     // expected SHIM_CACHE_MAGIC
    DWORD          dwMaxSize;   // expected MAX_SHIM_CACHE_ENTRIES
    DWORD          dwCount;     // entry count
    DWORD          dwUnused;    // keep this just so we're aligned
    int            rgIndex[0];
} SHIMCACHEHEADER, *PSHIMCACHEHEADER;

#pragma pack()

//
// Shared data, initialized in LockShimCache().
// Cleanup is done at dll unload time (when the process terminates).
//

WCHAR gwszCacheMutex[]         = L"ShimCacheMutex";
WCHAR gwszCacheSharedMemName[] = L"ShimSharedMemory";

//
// The cache is global and we initialize it as such.
// The cache code is never re-entered on the same thread.
// A mutex provides all the synchronization we need.
//

HANDLE ghShimCacheMutex;  // shared mutex handle
HANDLE ghShimCacheShared; // shared memory handle
PVOID  gpShimCacheShared; // shared memory ptr

//
// global strings that we check to see if an exe is running in temp directory
//

UNICODE_STRING gustrWindowsTemp;
UNICODE_STRING gustrSystemdriveTemp;

//
// get pointer to the entries from header
//

#define GET_SHIM_CACHE_ENTRIES(pHeader) \
    ((PSHIMCACHEENTRY)((PBYTE)(pHeader) + sizeof(SHIMCACHEHEADER) + ((pHeader)->dwMaxSize * sizeof(INT))))

#define SHIM_CACHE_SIZE(nEntries) \
    (sizeof(SHIMCACHEHEADER) + (nEntries)*sizeof(int) + (nEntries)*sizeof(SHIMCACHEENTRY))

//
// Locally defined functions
//
BOOL
BasepShimCacheInitTempDirs(
    VOID
    );

BOOL
BasepShimCacheInit(
    PSHIMCACHEHEADER pHeader,
    PSHIMCACHEENTRY  pEntries,
    DWORD            dwMaxEntries
    );

BOOL
BasepShimCacheRead(
    PVOID pCache,
    DWORD dwCacheSize // buffer global size
    );

BOOL
BasepShimCacheLock(
    PSHIMCACHEHEADER* ppHeader,
    PSHIMCACHEENTRY*  ppEntries
    );

BOOL
BasepShimCacheWrite(
    PSHIMCACHEHEADER pHeader
    );

BOOL
BasepShimCacheUnlock(
    VOID
    );

BOOL
BasepShimCacheCheckIntegrity(
    PSHIMCACHEHEADER pHeader
    );

BOOL
BasepIsRemovableMedia(
    HANDLE FileHandle,
    BOOL   bCacheNetwork
    );


VOID
WINAPI
BaseDumpAppcompatCache(
    VOID
    );

BOOL
BasepCheckCacheExcludeList(
    LPCWSTR pwszPath
    );

//
// Init support for this user - to be called from WinLogon ONLY
//

BOOL
WINAPI
BaseInitAppcompatCacheSupport(
    VOID
    )
{
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSECURITY_DESCRIPTOR     psd = NULL;
    SECURITY_ATTRIBUTES      SecurityAttributes;
    BOOL     bSuccess = FALSE;
    PSID     Anyone   = NULL;
    NTSTATUS Status;
    ULONG    AclSize;
    ACL*     pAcl;
    DWORD    dwWaitResult;
    BOOL     bShimCacheLocked = FALSE;
    BOOL     bExistingCache   = FALSE;

    Status = RtlAllocateAndInitializeSid(&WorldAuthority, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &Anyone);
    if (!NT_SUCCESS(Status)) {
        // dbgprint (failed with the sid
        return FALSE;
    }

    // calculate the size of the ACL (one ace)
    // 1 is one ACE, which includes a single ULONG from SID, since we add the size
    // of any Sids in -- we don't need to count the said ULONG twice
    AclSize = sizeof(ACL) + (1 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
              RtlLengthSid(Anyone);

    psd = (PSECURITY_DESCRIPTOR)RtlAllocateHeap(RtlProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    if (psd == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    pAcl = (ACL*)((BYTE*)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);
    Status = RtlCreateAcl(pAcl, AclSize, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }


    Status = RtlAddAccessAllowedAce(pAcl,
                                    ACL_REVISION,
                                    (SPECIFIC_RIGHTS_ALL|STANDARD_RIGHTS_ALL) & ~(WRITE_DAC|WRITE_OWNER),
                                    Anyone);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = RtlCreateSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = RtlSetDaclSecurityDescriptor(psd, TRUE, pAcl, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }


    SecurityAttributes.nLength              = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.bInheritHandle       = TRUE;
    SecurityAttributes.lpSecurityDescriptor = psd;

    //
    // First up is a mutex
    // while we are the first process, this user may already have a cache
    // and there may already be shared cache
    // we need to synchronize here - no need for cs stuff, but the mutex is
    // important indeed
    //

    ghShimCacheMutex = CreateMutexW(&SecurityAttributes, FALSE, gwszCacheMutex);

    if (ghShimCacheMutex == NULL) {
        goto Exit;
    }

    //
    // wait for the shared mutex  (essentially lock the cache out)
    //
    dwWaitResult = WaitForSingleObject(ghShimCacheMutex, SHIM_CACHE_TIMEOUT);
    if (dwWaitResult == WAIT_TIMEOUT) {
        //
        //  We could not acquire the mutex, don't retry, just exit
        //
        DbgPrint("BaseInitAppcompatCacheSupport: Timeout waiting for shared mutex\n");
        return FALSE;
    }

    bShimCacheLocked = TRUE;

    //
    // next is shared memory
    //
    ghShimCacheShared = CreateFileMappingW(INVALID_HANDLE_VALUE,
                                           &SecurityAttributes,
                                           PAGE_READWRITE,
                                           0,
                                           SHIM_CACHE_SIZE(MAX_SHIM_CACHE_ENTRIES),
                                           gwszCacheSharedMemName);
    if (ghShimCacheShared == NULL) {
        goto Exit;
    }

    //
    // see if the cache already existed, if so -- we will need to integrate
    // currently we do not support integration
    //
    bExistingCache = (ERROR_ALREADY_EXISTS == GetLastError());
    if (bExistingCache) {
        DbgPrint("ShimCache: This cache already exists!!!\n");
    }

    gpShimCacheShared = MapViewOfFile(ghShimCacheShared, FILE_MAP_WRITE, 0, 0, 0);
    if (gpShimCacheShared == NULL) {
        goto Exit;
    }

    //
    // check whether the cache is new or existing one
    //

    BasepShimCacheInit(gpShimCacheShared, NULL, MAX_SHIM_CACHE_ENTRIES);

    //
    // now read the cache
    //
    BasepShimCacheRead(gpShimCacheShared, SHIM_CACHE_SIZE(MAX_SHIM_CACHE_ENTRIES));

    //
    // Init temporary directories as well
    //
    BasepShimCacheInitTempDirs();

    DbgPrint("ShimCache Created\n");

    bSuccess = TRUE;

Exit:
    if (psd != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, psd);
    }
    if (Anyone != NULL) {
        RtlFreeSid(Anyone);
    }

    //
    // check for success and cleanup
    //
    if (!bSuccess) {
        if (gpShimCacheShared != NULL) {
            UnmapViewOfFile(gpShimCacheShared);
            gpShimCacheShared = NULL;
        }

        if (ghShimCacheShared) {
            CloseHandle(ghShimCacheShared);
            ghShimCacheShared = NULL;
        }

        if (ghShimCacheMutex) {
            if (bShimCacheLocked) {
                ReleaseMutex(ghShimCacheMutex);
            }
            CloseHandle(ghShimCacheMutex);
            ghShimCacheMutex = NULL;
        }

        DbgPrint("ShimCache Creation error\n");
    } else {
        if (bShimCacheLocked) {
            ReleaseMutex(ghShimCacheMutex);
        }
    }

    return(bSuccess);

}

VOID
WINAPI
BaseCleanupAppcompatCache(
    VOID
    )
{
    //
    // here we close global objects and cleanup stuff
    //
    if (!BasepShimCacheLock(NULL, NULL)) {
        return;
    }

    if (gpShimCacheShared != NULL) {
        UnmapViewOfFile(gpShimCacheShared);
        gpShimCacheShared = NULL;
    }

    if (ghShimCacheShared != NULL) {
        CloseHandle(ghShimCacheShared);
        ghShimCacheShared = NULL;
    }

    RtlFreeUnicodeString(&gustrWindowsTemp);
    RtlFreeUnicodeString(&gustrSystemdriveTemp);

    BasepShimCacheUnlock();

    RtlEnterCriticalSection(&gcsAppCompat);

    if (ghShimCacheMutex != NULL) {
        CloseHandle(ghShimCacheMutex);
        ghShimCacheMutex = NULL;
    }

    RtlLeaveCriticalSection(&gcsAppCompat);

}


BOOL
WINAPI
BaseCleanupAppcompatCacheSupport(
    BOOL bWrite
    )
{
    //
    // we nuke stuff here
    //
    if (!BasepShimCacheLock(NULL, NULL)) {
        return FALSE;
    }

    //
    // we have the lock
    //
    if (bWrite && gpShimCacheShared != NULL) {
        BasepShimCacheWrite((PSHIMCACHEHEADER)gpShimCacheShared);
    }

    BasepShimCacheUnlock();

    return TRUE;
}

//
// Init support for this process
// call inside our critical section!!!
//
BOOL
WINAPI
BaseInitAppcompatCache(
    VOID
    )
{
    DWORD dwWaitResult;

    //
    // first -- open mutex
    //

    RtlEnterCriticalSection(&gcsAppCompat); // enter crit sec please
    __try {
        if (ghShimCacheMutex == NULL) {

            ghShimCacheMutex = OpenMutexW(READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE,
                                          FALSE,
                                          gwszCacheMutex);
            if (ghShimCacheMutex == NULL) {
                __leave;
            }

            // if we are here -- this is the first time we are trying to do this -
            // recover then temp dir path

            BasepShimCacheInitTempDirs();

        }
    } __finally {
        RtlLeaveCriticalSection(&gcsAppCompat);
    }

    if (ghShimCacheMutex == NULL) {
        DbgPrint("BaseInitAppcompatCache: Failed to acquire shared mutex\n");
        return FALSE;
    }

    dwWaitResult = WaitForSingleObject(ghShimCacheMutex, SHIM_CACHE_TIMEOUT);
    if (dwWaitResult == WAIT_TIMEOUT) {
        //
        //  We could not acquire the mutex, don't retry, just exit
        //
        DbgPrint("BasepShimCacheLock: Timeout waiting for shared mutex\n");
        return FALSE;
    }

    //
    // acquired shared mutex, now open section
    //
    if (ghShimCacheShared == NULL) {
        ghShimCacheShared = OpenFileMappingW(FILE_MAP_WRITE, FALSE, gwszCacheSharedMemName);
        if (ghShimCacheShared == NULL) {
            DbgPrint("BaseInitAppcompatCache: Failed to open file mapping 0x%lx\n", GetLastError());
            ReleaseMutex(ghShimCacheMutex);
            return FALSE;
        }
    }

    if (gpShimCacheShared == NULL) {
        gpShimCacheShared = MapViewOfFile(ghShimCacheShared, FILE_MAP_WRITE, 0, 0, 0);
        if (gpShimCacheShared == NULL) {
            DbgPrint("BaseInitAppcompatCache: Failed to map view 0x%lx\n", GetLastError());
            ReleaseMutex(ghShimCacheMutex);
            return FALSE;
        }
    }

    DbgPrint("BaseInitAppcompatCache: Initialized\n");

    //
    // if we are here -- we have all the shared objects and we are holding mutant too
    //

    return TRUE;

}


//
// create cache buffer
//
PSHIMCACHEHEADER
BasepShimCacheAllocate(
    DWORD dwCacheSize
    )
{
    DWORD            dwBufferSize;
    PSHIMCACHEHEADER pBuffer;

    dwBufferSize = SHIM_CACHE_SIZE(dwCacheSize);

    pBuffer = (PSHIMCACHEHEADER)RtlAllocateHeap(RtlProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                dwBufferSize);
    if (pBuffer == NULL) {
        // debug out
        return NULL;
    }

    pBuffer->dwMagic = SHIM_CACHE_MAGIC;
    pBuffer->dwMaxSize = dwCacheSize;

    return pBuffer;
}

// load cache from the registry

BOOL
BasepShimCacheRead(
    PVOID pCache,
    DWORD dwCacheSize // buffer global size
    )
{
    //
    static UNICODE_STRING ustrAppcompatCacheKeyName =
            RTL_CONSTANT_STRING(APPCOMPAT_CACHE_KEY_NAME);
    static OBJECT_ATTRIBUTES objaAppcompatCacheKeyName =
            RTL_CONSTANT_OBJECT_ATTRIBUTES(&ustrAppcompatCacheKeyName, OBJ_CASE_INSENSITIVE);
    static UNICODE_STRING ustrAppcompatCacheValueName =
            RTL_CONSTANT_STRING(APPCOMPAT_CACHE_VALUE_NAME);

    HANDLE hKey = NULL;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG  KeyValueLength = 0;
    PVOID  pBuffer;
    ULONG  BufferSize;
    BOOL   bSuccess = FALSE;
    NTSTATUS Status;

    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE, (POBJECT_ATTRIBUTES) &objaAppcompatCacheKeyName);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // we have a key, read please
    //
    BufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + dwCacheSize;

    pBuffer = (PVOID)RtlAllocateHeap(RtlProcessHeap(),
                                     HEAP_ZERO_MEMORY,
                                     BufferSize);

    if (pBuffer == NULL) {
        // can't allocate memory
        NtClose(hKey);
        return FALSE;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)pBuffer;

    Status = NtQueryValueKey(hKey,
                             &ustrAppcompatCacheValueName,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             BufferSize,
                             &KeyValueLength);
    if (NT_SUCCESS(Status) &&
        KeyValueInformation->Type == REG_BINARY) {

        if (BasepShimCacheCheckIntegrity((PSHIMCACHEHEADER)KeyValueInformation->Data)) {
            RtlMoveMemory(pCache, KeyValueInformation->Data, KeyValueInformation->DataLength);
            DbgPrint("Cache Initialized from the registry\n");
            bSuccess = TRUE;
        } else {
            DbgPrint("Registry data appear to be corrupted\n");
        }
    }


    RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
    NtClose(hKey);

    /*++
        This call will dump appcompat cache at the startup
        Normally disabled so as not to slow down the boot
        Dump cache through rundll32 apphelp.dll,ShimDumpCache

#if DBG
    BaseDumpAppcompatCache();
#endif

    --*/

    return bSuccess;

}


BOOL
BasepShimCacheWrite(
    PSHIMCACHEHEADER pHeader
    )
{
    //
    static UNICODE_STRING ustrAppcompatCacheKeyName =
            RTL_CONSTANT_STRING(APPCOMPAT_CACHE_KEY_NAME);
    static OBJECT_ATTRIBUTES objaAppcompatCacheKeyName =
            RTL_CONSTANT_OBJECT_ATTRIBUTES(&ustrAppcompatCacheKeyName, OBJ_CASE_INSENSITIVE);
    static UNICODE_STRING ustrAppcompatCacheValueName =
            RTL_CONSTANT_STRING(APPCOMPAT_CACHE_VALUE_NAME);

    HANDLE hKey = NULL;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyValueInformation;
    ULONG    KeyValueLength = 0;
    ULONG    BufferSize;
    BOOL     bSuccess = FALSE;
    NTSTATUS Status;
    ULONG    CreateDisposition;

    Status = NtCreateKey(&hKey,
                         STANDARD_RIGHTS_WRITE |
                            KEY_QUERY_VALUE |
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_SET_VALUE |
                            KEY_CREATE_SUB_KEY,
                         &objaAppcompatCacheKeyName,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &CreateDisposition);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepShimCacheWrite: failed to create key 0x%lx\n", Status);
        return FALSE;
    }

    BufferSize = SHIM_CACHE_SIZE(pHeader->dwMaxSize);

    Status = NtSetValueKey(hKey,
                           &ustrAppcompatCacheValueName,
                           0,
                           REG_BINARY,
                           (PVOID)pHeader,
                           BufferSize);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepShimCacheWrite: failed to set the value 0x%lx\n", Status);
    }

    NtClose(hKey);

    DbgPrint("Cache Dumped 0x%lx\n", Status);

    return NT_SUCCESS(Status);
}

BOOL
BasepCheckStringPrefixUnicode(
    IN  PUNICODE_STRING pStrPrefix,     // the prefix to check for
    IN  PUNICODE_STRING pString,        // the string
    IN  BOOL            CaseInSensitive
    )
/*++
    Return: TRUE if the specified string contains pStrPrefix at it's start.

    Desc:   Verifies if a string is a prefix in another unicode counted string.
            It is equivalent to RtlStringPrefix.
--*/
{
    PWSTR ps1, ps2;
    UINT  n;
    WCHAR c1, c2;

    n = pStrPrefix->Length;
    if (pString->Length < n || n == 0) {
        return FALSE;                // do not prefix with blank strings
    }

    n /= sizeof(WCHAR); // convert to char count

    ps1 = pStrPrefix->Buffer;
    ps2 = pString->Buffer;

    if (CaseInSensitive) {
        while (n--) {
            c1 = *ps1++;
            c2 = *ps2++;

            if (c1 != c2) {
                c1 = RtlUpcaseUnicodeChar(c1);
                c2 = RtlUpcaseUnicodeChar(c2);
                if (c1 != c2) {
                    return FALSE;
                }
            }
        }
    } else {
        while (n--) {
            if (*ps1++ != *ps2++) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
BasepInitUserTempPath(
    PUNICODE_STRING pustrTempPath
    )
{
    DWORD dwLength;
    WCHAR wszBuffer[MAX_PATH];
    BOOL  TranslationStatus;
    BOOL  bSuccess = FALSE;

    dwLength = BasepGetTempPathW(BASEP_GET_TEMP_PATH_PRESERVE_TEB, sizeof(wszBuffer)/sizeof(wszBuffer[0]), wszBuffer);
    if (dwLength && dwLength < sizeof(wszBuffer)/sizeof(wszBuffer[0])) {
        TranslationStatus = RtlDosPathNameToNtPathName_U(wszBuffer,
                                                        pustrTempPath,
                                                        NULL,
                                                        NULL);
        if (!TranslationStatus) {
            DbgPrint("Failed to translate temp directory to nt\n");
        }

        bSuccess = TranslationStatus;
    }

    if (!bSuccess) {
        DbgPrint("BasepInitUserTempPath: Failed to obtain user's temp path\n");
    }

    return bSuccess;
}



BOOL
BasepShimCacheInitTempDirs(
    VOID
    )
{
    DWORD           dwLength;
    WCHAR           wszTemp[] = L"\\TEMP";
    LPWSTR          pwszTemp;
    NTSTATUS        Status;
    UNICODE_STRING  ustrSystemDrive;
    UNICODE_STRING  ustrSystemDriveEnvVarName;
    BOOL            TranslationStatus;
    WCHAR           wszBuffer[MAX_PATH];

    // next is windows dir

    dwLength = GetWindowsDirectoryW(wszBuffer, sizeof(wszBuffer)/sizeof(wszBuffer[0]));
    if (dwLength && dwLength < sizeof(wszBuffer)/sizeof(wszBuffer[0])) {
        pwszTemp = wszTemp;

        if (wszBuffer[dwLength - 1] == L'\\') {
            pwszTemp++;
        }

        wcscpy(&wszBuffer[dwLength], pwszTemp);

        TranslationStatus = RtlDosPathNameToNtPathName_U(wszBuffer,
                                                        &gustrWindowsTemp,
                                                        NULL,
                                                        NULL);
        if (!TranslationStatus) {
            DbgPrint("Failed to translate windows\\temp to nt\n");
        }
    }

    //
    // The last one up is Rootdrive\temp for stupid legacy apps.
    //
    // Especially stupid apps may receive c:\temp as the temp directory
    // (what if you don't have drive c, huh?)
    //

    RtlInitUnicodeString(&ustrSystemDriveEnvVarName, L"SystemDrive");
    ustrSystemDrive.Length = 0;
    ustrSystemDrive.Buffer = wszBuffer;
    ustrSystemDrive.MaximumLength = sizeof(wszBuffer);

    Status = RtlQueryEnvironmentVariable_U(NULL,
                                           &ustrSystemDriveEnvVarName,
                                           &ustrSystemDrive);
    if (NT_SUCCESS(Status)) {
        pwszTemp = wszTemp;
        dwLength = ustrSystemDrive.Length / sizeof(WCHAR);

        if (wszBuffer[dwLength - 1] == L'\\') {
            pwszTemp++;
        }

        wcscpy(&wszBuffer[dwLength], pwszTemp);

        TranslationStatus = RtlDosPathNameToNtPathName_U(wszBuffer,
                                                        &gustrSystemdriveTemp,
                                                        NULL,
                                                        NULL);
        if (!TranslationStatus) {
            DbgPrint("Failed to translate windows\\temp to nt\n");
        }

    }

    DbgPrint("BasepShimCacheInitTempDirs: Temporary Windows Dir: %S\n", gustrWindowsTemp.Buffer != NULL ? gustrWindowsTemp.Buffer : L"");
    DbgPrint("BasepShimCacheInitTempDirs: Temporary SystedDrive: %S\n", gustrSystemdriveTemp.Buffer != NULL ? gustrSystemdriveTemp.Buffer : L"");


    return TRUE;
}

BOOL
BasepShimCacheCheckBypass(
    IN  LPCWSTR pwszPath,       // the full path to the EXE to be started
    IN  HANDLE  hFile,
    IN  WCHAR*  pEnvironment,   // the environment of the starting EXE
    IN  BOOL    bCheckLayer,    // should we check the layer too?
    OUT DWORD*  pdwReason
    )
/*++
    Return: TRUE if the cache should be bypassed, FALSE otherwise.

    Desc:   This function checks if any of the conditions to bypass the cache are met.
--*/
{
    UNICODE_STRING  ustrPath;
    PUNICODE_STRING rgp[3];
    int             i;
    NTSTATUS        Status;
    UNICODE_STRING  ustrCompatLayerVarName;
    UNICODE_STRING  ustrCompatLayer;
    BOOL            bBypassCache = FALSE;
    DWORD           dwReason = 0;
    UNICODE_STRING  ustrUserTempPath = { 0 };

    //
    // Is the EXE is running from removable media we need to bypass the cache.
    //
    if (hFile != INVALID_HANDLE_VALUE && BasepIsRemovableMedia(hFile, TRUE)) {
        bBypassCache = TRUE;
        dwReason |= SHIM_CACHE_MEDIA;
        goto CheckLayer;
    }

    //
    // init user's temp path now and get up-to-date one
    //
    BasepInitUserTempPath(&ustrUserTempPath);

    //
    // Check now if the EXE is launched from one of the temp directories.
    //
    RtlInitUnicodeString(&ustrPath, pwszPath);

    rgp[0] = &gustrWindowsTemp;
    rgp[1] = &ustrUserTempPath;
    rgp[2] = &gustrSystemdriveTemp;

    for (i = 0; i < sizeof(rgp) / sizeof(rgp[0]); i++) {
        if (rgp[i]->Buffer != NULL && BasepCheckStringPrefixUnicode(rgp[i], &ustrPath, TRUE)) {
            DbgPrint("Application \"%ls\" is running in temp directory\n", pwszPath);
            bBypassCache = TRUE;
            dwReason |= SHIM_CACHE_TEMP;
            break;
        }
    }
    RtlFreeUnicodeString(&ustrUserTempPath);


CheckLayer:

    if (bCheckLayer) {

        //
        // Check if the __COMPAT_LAYER environment variable is set
        //
        RtlInitUnicodeString(&ustrCompatLayerVarName, L"__COMPAT_LAYER");

        ustrCompatLayer.Length        = 0;
        ustrCompatLayer.MaximumLength = 0;
        ustrCompatLayer.Buffer        = NULL;

        Status = RtlQueryEnvironmentVariable_U(pEnvironment,
                                               &ustrCompatLayerVarName,
                                               &ustrCompatLayer);

        //
        // If the Status is STATUS_BUFFER_TOO_SMALL this means the variable is set.
        //

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            dwReason |= SHIM_CACHE_LAYER_ENV;
            bBypassCache = TRUE;
        }
    }

    if (pdwReason != NULL) {
        *pdwReason = dwReason;
    }

    return bBypassCache;
}


NTSTATUS
BasepShimCacheQueryFileInformation(
    HANDLE    FileHandle,
    PLONGLONG pFileSize,
    PLONGLONG pFileTime
    )
/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Queries for file size and timestamp.
--*/
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IoStatusBlock;
    FILE_BASIC_INFORMATION      BasicFileInfo;
    FILE_STANDARD_INFORMATION   StdFileInfo;

    Status = NtQueryInformationFile(FileHandle,
                                    &IoStatusBlock,
                                    &BasicFileInfo,
                                    sizeof(BasicFileInfo),
                                    FileBasicInformation);

    if (!NT_SUCCESS(Status)) {
        /*
        DBGPRINT((sdlError,
                  "ShimQueryFileInformation",
                  "NtQueryInformationFile/BasicInfo failed 0x%x\n",
                  Status));
        */

        DbgPrint("BasepShimCacheQueryFileInformation: NtQueryInformationFile(BasicFileInfo) failed 0x%lx\n", Status);
        return Status;
    }

    *pFileTime = BasicFileInfo.LastWriteTime.QuadPart;

    Status = NtQueryInformationFile(FileHandle,
                                    &IoStatusBlock,
                                    &StdFileInfo,
                                    sizeof(StdFileInfo),
                                    FileStandardInformation);

    if (!NT_SUCCESS(Status)) {
        /*

        DBGPRINT((sdlError,
                  "ShimQueryFileInformation",
                  "NtQueryInformationFile/StdInfo failed 0x%x\n",
                  Status));
        */

        DbgPrint("BasepShimCacheQueryFileInformation: NtQueryInformationFile(StdFileInfo) failed 0x%lx\n", Status);
        return Status;
    }

    *pFileSize = StdFileInfo.EndOfFile.QuadPart;

    return STATUS_SUCCESS;
}

BOOL
BasepIsRemovableMedia(
    HANDLE FileHandle,
    BOOL   bCacheNetwork
    )
/*++
    Return: TRUE if the media from where the app is run is removable,
            FALSE otherwise.

    Desc:   Queries the media for being removable.
--*/
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;
    BOOL                        bRemovable = FALSE;

    Status = NtQueryVolumeInformationFile(FileHandle,
                                          &IoStatusBlock,
                                          &DeviceInfo,
                                          sizeof(DeviceInfo),
                                          FileFsDeviceInformation);

    if (!NT_SUCCESS(Status)) {
        /*
        DBGPRINT((sdlError,
                  "IsRemovableMedia",
                  "NtQueryVolumeInformationFile Failed 0x%x\n",
                  Status));
        */

        DbgPrint("BasepIsRemovableMedia: NtQueryVolumeInformationFile failed 0x%lx\n", Status);
        return TRUE;
    }

    //
    // We look at the characteristics of this particular device.
    // If the media is cdrom then we DO NOT need to convert to local time
    //
    bRemovable = (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA);

    if (!bCacheNetwork) {
        bRemovable |= (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE);
    }

    if (!bRemovable) {
        //
        // Check the device type now.
        //
        switch (DeviceInfo.DeviceType) {
        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            bRemovable = TRUE;
            break;

        case FILE_DEVICE_NETWORK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            if (!bCacheNetwork) {
                bRemovable = TRUE;
            }
            break;
        }
    }

    if (bRemovable) {

        DbgPrint("BasepIsRemovableMedia: Host device is removable, Shim cache deactivated\n");

        /*
        DBGPRINT((sdlInfo,
                  "IsRemovableMedia",
                  "The host device is removable. Shim cache deactivated for this file\n"));
        */
    }

    return bRemovable;
}


BOOL
BasepShimCacheInit(
    PSHIMCACHEHEADER pHeader,
    PSHIMCACHEENTRY  pEntries,
    DWORD            dwMaxEntries
    )
{
    // initialize the cache
    DWORD dwCacheSizeHeader;
    INT   i;

    dwCacheSizeHeader = sizeof(SHIMCACHEHEADER) +
                        dwMaxEntries * sizeof(int);

    RtlZeroMemory(pHeader, dwCacheSizeHeader);
    pHeader->dwMagic   = SHIM_CACHE_MAGIC;
    pHeader->dwMaxSize = dwMaxEntries;

    if (pEntries != NULL) {
        RtlZeroMemory(pEntries, dwMaxEntries * sizeof(SHIMCACHEENTRY));
    }

    // dwCount of active entries is set to nothing

    // now roll through the entries and set them to -1
    for (i = 0; i < (int)dwMaxEntries; ++i) {
        pHeader->rgIndex[i] = -1;
    }

    return TRUE;
}


BOOL
BasepShimCacheSearch(
    IN  PSHIMCACHEHEADER pHeader,
    IN  PSHIMCACHEENTRY  pEntries,
    IN  LPCWSTR          pwszPath,
    OUT int*             pIndex
    )
/*++
    Return: TRUE if we have a cache hit, FALSE otherwise.

    Desc:   Search the cache, return TRUE if we have a cache hit
            pIndex will receive an index into the rgIndex array that contains
            the entry which has been hit
            So that if entry 5 contains the hit, and rgIndexes[3] == 5 then
            *pIndex == 3
--*/
{
    int    nIndex, nEntry;
    WCHAR* pCachePath;
    BOOL   bSuccess;

    for (nIndex = 0; nIndex < (int)pHeader->dwCount; nIndex++) {

        nEntry = pHeader->rgIndex[nIndex];

        if (nEntry >= 0 && nEntry < (int)pHeader->dwMaxSize) { // guard against corruption

            pCachePath = pEntries[nEntry].wszPath;

            if (*pCachePath != L'\0' && !_wcsicmp(pwszPath, pCachePath)) {
                //
                // succeess
                //
                if (pIndex != NULL) {
                    *pIndex = nIndex;
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL
BasepShimCacheUpdateLRUIndex(
    OUT PSHIMCACHEHEADER pHeader,
    OUT PSHIMCACHEENTRY  pEntries,
    IN  int              nIndex
    )
/*++
    Return: TRUE.

    Desc:   Update the LRU list by taking nIndex and inserting it into the head of the list.
            For instance, rgIndexes before the update:
                2 5 9 3 1 ...
            if nIndex == 2, rgIndexes after the update:
                9 2 5 3 1
            The entry at pos. 2 containing a hit entry number (which is 9) was moved
            to the front of the index.
--*/
{
    int  nEntry;
    int* pStart;
    int* pTo;
    LARGE_INTEGER liTimeStamp;
    FILETIME ft;

    if (nIndex < 0 || nIndex >= (int)pHeader->dwMaxSize) {
        DbgPrint("BasepShimCacheUpdateLRUIndex: Bad index %ld\n", nIndex);
        return FALSE;
    }

    nEntry = pHeader->rgIndex[nIndex];

    //
    // Zap the entry by shifting memory to the right.
    //
    pStart = &pHeader->rgIndex[0];
    pTo    = &pHeader->rgIndex[1];

    RtlMoveMemory(pTo, pStart, nIndex * sizeof(int));

    pHeader->rgIndex[0] = nEntry;

    GetSystemTimeAsFileTime(&ft);
    liTimeStamp.LowPart  = ft.dwLowDateTime;
    liTimeStamp.HighPart = ft.dwHighDateTime;

    pEntries[nEntry].TimeStamp = liTimeStamp.QuadPart;


    return TRUE;
}

BOOL
BasepShimCacheRemoveEntry(
    OUT PSHIMCACHEHEADER pHeader,
    OUT PSHIMCACHEENTRY  pEntries,
    IN  int              nIndex     // the index in rgIndex array containing
                                    // the entry that is to be removed.
    )
/*++
    Return: TRUE.

    Desc:   Remove the entry from the cache.
            We remove the entry by placing it as the last lru entry
            and emptying the path. This routine assumes that the index
            passed in is valid.
--*/
{
    int             nLast, nEntry;
    int*            pTo;
    int*            pStart;
    PSHIMCACHEENTRY pEntry;

    if (nIndex < 0 || nIndex >= (int)pHeader->dwCount) {
        DbgPrint("BasepShimRemoveFromCache: Invalid index %ld\n", nIndex);
        return FALSE;
    }


    //
    // Get the entry.
    //
    nEntry = pHeader->rgIndex[nIndex];

    if (pHeader->dwCount < pHeader->dwMaxSize) {
        nLast = pHeader->dwCount - 1;
    } else {
        nLast = pHeader->dwMaxSize - 1;
    }

    //
    // 1. remove it from the LRU index in such a way that we account for
    //    number of entries.
    //
    pTo    = &pHeader->rgIndex[nIndex];
    pStart = &pHeader->rgIndex[nIndex + 1];

    RtlMoveMemory(pTo, pStart, (nLast - nIndex) * sizeof(INT));

    pHeader->rgIndex[nLast] = nEntry;

    //
    // 2. kill the path.
    //
    pEntry = pEntries + nEntry;


    DbgPrint("BasepShimCacheRemoveEntry: removing %ld \"%S\"\n", nIndex, pEntry->wszPath);

    *pEntry->wszPath  = L'\0';
    pEntry->TimeStamp = 0;
    pEntry->FileSize  = 0;
    pEntry->FileTime  = 0;

    return TRUE;
}



PSHIMCACHEENTRY
BasepShimCacheAllocateEntry(
    IN OUT PSHIMCACHEHEADER pHeader,
    IN OUT PSHIMCACHEENTRY  pEntries,
    IN     LPCWSTR          pwszPath,
    IN     LONGLONG         FileSize,
    IN     LONGLONG         FileTime
    )
/*++
    Return: The pointer to the new entry.

    Desc:   Allocate an entry in the cache. The entry is acquired using the LRU algorithm
            The least recently used entry is contained in rgIndex[MAX_SHIM_CACHE_ENTRIES-1]
            or the next available entry if cache has not filled up yet. The entry returned
            is also taken to the front of the list (making it most recently used one).
--*/
{
    int             nEntry;
    int             nIndex = -1;
    int             nFileNameSize;
    PSHIMCACHEENTRY pEntry = NULL;

    nFileNameSize = (wcslen(pwszPath) + 1) * sizeof(WCHAR);
    if (nFileNameSize > sizeof(pEntry->wszPath)) {
        DbgPrint("BasepShimCacheAllocateEntry: path is too long to be cached\n");
        return NULL;
    }

    if (pHeader->dwCount < pHeader->dwMaxSize) {
        //
        // We can add a new entry.
        //
        nIndex = (int)pHeader->dwCount++;
        nEntry = nIndex;
        pHeader->rgIndex[nIndex] = nEntry;
    } else {
        //
        // Displacement
        //
        nIndex = pHeader->dwMaxSize - 1; // displacing the very last entry
        nEntry = (int)pHeader->rgIndex[nIndex];
    }

    //
    // Now update... making this entry appear first
    //
    BasepShimCacheUpdateLRUIndex(pHeader, pEntries, nIndex);

    pEntry = pEntries + nEntry;

    //
    // Copy the path and fill out the info
    //
    RtlMoveMemory(pEntry->wszPath, pwszPath, nFileNameSize);
    pEntry->FileSize  = FileSize;
    pEntry->FileTime  = FileTime;

    DbgPrint("BaseShimCacheAllocateEntry: Entry \"%S\" index0 %ld Entry %ld\n", pwszPath, pHeader->rgIndex[0], nEntry);
    return pEntry;
}

//
// This function is called to search the cache and update the
// entry if found. It will not check for the removable media -- but
// it does check other conditions (update file for instance)
//

BOOL
BasepShimCacheLookup(
    PSHIMCACHEHEADER pHeader,
    PSHIMCACHEENTRY  pEntries,
    LPCWSTR          pwszPath,
    HANDLE           hFile
    )
{
    NTSTATUS Status;
    LONGLONG FileSize = 0;
    LONGLONG FileTime = 0;
    INT      nIndex   = 0;
    PSHIMCACHEENTRY pEntry;

    if (!BasepShimCacheSearch(pHeader, pEntries, pwszPath, &nIndex)) {
        return FALSE; // not found, sorry
    }

    //
    // query file's information so that we can make sure it is the same file
    //

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // get file's information and compare to the entry
        //
        Status = BasepShimCacheQueryFileInformation(hFile, &FileSize, &FileTime);
        if (!NT_SUCCESS(Status)) {
            //
            // we cannot confirm that the file is of certain size and/or timestamp,
            // we treat this then as a non-entry. debug message will be printed from the function
            // above. Whether we have found the file -- or not -- is quite irrelevant, do the detection
            //
            return FALSE;
        }

        pEntry = pEntries + pHeader->rgIndex[nIndex];

        //
        // check size and timestamp
        //

        if (pEntry->FileTime != FileTime || pEntry->FileSize != FileSize) {
            //
            // we will have to run detection again, this entry is bad and shall be removed
            //
            DbgPrint("BasepShimCacheLookup: Entry for file \"%S\" is invalid and will be removed\n", pwszPath);
            BasepShimCacheRemoveEntry(pHeader, pEntries, nIndex);
            return FALSE;

        }
    }

    //
    // check if this entry has been disallowed
    //
    if (!BasepCheckCacheExcludeList(pwszPath)) {
        DbgPrint("BasepShimCacheLookup: Entry for %ls was disallowed yet found in cache, cleaning up\n", pwszPath);
        BasepShimCacheRemoveEntry(pHeader, pEntries, nIndex);
        return FALSE;
    }

    BasepShimCacheUpdateLRUIndex(pHeader, pEntries, nIndex);

    return TRUE;

}

//
// This function will update the cache if need be
// called from apphelp to make sure that the file is cached (no fixes)
//

BOOL
BasepShimCacheUpdate(
    PSHIMCACHEHEADER pHeader,
    PSHIMCACHEENTRY  pEntries,
    LPCWSTR          pwszPath,
    HANDLE           hFile
    )
{
    int             nIndex;
    LONGLONG        FileSize = 0;
    LONGLONG        FileTime = 0;
    PSHIMCACHEENTRY pEntry;
    NTSTATUS        Status;

    if (hFile != INVALID_HANDLE_VALUE) {
        Status = BasepShimCacheQueryFileInformation(hFile, &FileSize, &FileTime);
        if (!NT_SUCCESS(Status)) {
            //
            // can't update entry
            //
            DbgPrint("BasepShimCacheUpdate: Failed to obtain file information\n");
            return FALSE;
        }
    }

    //
    // if bRemove is TRUE, we remove this entry from the cache
    //
    if (BasepShimCacheSearch(pHeader, pEntries, pwszPath, &nIndex)) {

        //
        // found an existing entry
        //
        pEntry = pEntries + pHeader->rgIndex[nIndex];

        if (pEntry->FileTime == FileTime && pEntry->FileSize == FileSize) {
            //
            // good entry, update lru
            //
            BasepShimCacheUpdateLRUIndex(pHeader, pEntries, nIndex);
            return TRUE; // we are done
        }

        //
        // we are here because we have found a bad entry, remove it and continue
        //
        BasepShimCacheRemoveEntry(pHeader, pEntries, nIndex);

    }

    //
    // we have not found an entry -- or removed a bad entry, allocate it anew
    //
    BasepShimCacheAllocateEntry(pHeader, pEntries, pwszPath, FileSize, FileTime);

    return TRUE;
}

DWORD
BasepBitMapCountBits(
    PULONGLONG pMap,
    DWORD      dwMapSize
    )
{
    DWORD     nBits = 0;
    ULONGLONG Element;
    INT       i;

    for (i = 0; i < (int)dwMapSize; ++i) {

        Element = *pMap++;

        while (Element) {
            ++nBits;
            Element &= (Element - 1);
        }
    }

    return nBits;

}

//
// returns previous value of a flag
//
BOOL
BasepBitMapSetBit(
    PULONGLONG pMap,
    DWORD      dwMapSize,
    INT        nBit
    )
{
    INT nElement;
    INT nElementBit;
    ULONGLONG Flag;
    BOOL bNotSet;

    nElement    = nBit / (sizeof(ULONGLONG) * 8);
    nElementBit = nBit % (sizeof(ULONGLONG) * 8);

    Flag = (ULONGLONG)1 << nElementBit;

    pMap += nElement;
    bNotSet = !(*pMap & Flag);
    if (bNotSet) {
        *pMap |= Flag;
        return FALSE;
    }

    return TRUE; // set already
}

BOOL
BasepBitMapCheckBit(
    PULONGLONG pMap,
    DWORD      dwMapSize,
    INT        nBit
    )
{
    INT nElement;
    INT nElementBit;

    nElement    = nBit / (sizeof(ULONGLONG) * 8);
    nElementBit = nBit % (sizeof(ULONGLONG) * 8);

    pMap += nElement;

    return !!(*pMap & ((ULONGLONG)1 << nElementBit));
}


BOOL
BasepShimCacheCheckIntegrity(
    PSHIMCACHEHEADER pHeader
    )
{
    ULONGLONG EntryMap[MAX_SHIM_CACHE_ENTRIES / (sizeof(ULONGLONG) * 8) + 1] = { 0 };
    INT nEntry;
    INT nIndex;

    //
    // validate magic number
    //

    if (pHeader->dwMagic != SHIM_CACHE_MAGIC) {
        DbgPrint("BasepShimCheckCacheIntegrity: Bad magic number\n");
        return FALSE;
    }

    //
    // validate counters
    //
    if (pHeader->dwMaxSize > MAX_SHIM_CACHE_ENTRIES || pHeader->dwMaxSize == 0) {
        DbgPrint("BasepShimCheckCacheIntegrity: Cache size is corrupted\n");
        return FALSE;
    }

    if (pHeader->dwCount > pHeader->dwMaxSize) {
        DbgPrint("BasepShimCheckCacheIntegrity: Cache element count is corrupted\n");
        return FALSE;
    }

    //
    // check index entries
    //

    for (nIndex = 0; nIndex < (int)pHeader->dwMaxSize; ++nIndex) {

        nEntry = pHeader->rgIndex[nIndex];

        if (nEntry >= 0 && nEntry < (int)pHeader->dwMaxSize) { // the only way we should have this condition -- is when we're traversing unused entries
            //
            // (to verify index we mark each entry in our bit-map)
            //

            if (BasepBitMapSetBit(EntryMap, sizeof(EntryMap)/sizeof(EntryMap[0]), nEntry)) {
                //
                // duplicate cache entry
                //
                DbgPrint("BasepShimCheckCacheIntegrity: Found duplicate cache entry\n");
                return FALSE;
            }

        } else { // either nEntry < 0 or nEntry > MaxSize

            if (nEntry < 0 && nIndex < (int)pHeader->dwCount) {
                //
                // trouble -- we have a bad entry
                //
                DbgPrint("BasepShimCheckCacheIntegrity: bad entry\n");
                return FALSE;
            }

            // now check for overflow
            if (nEntry >= (int)pHeader->dwMaxSize) {
                DbgPrint("BasepShimCheckCacheIntegrity: overflow\n");
                return FALSE;
            }

        }

    }

    //
    // we have survived index check - verify that the count of elements is correct
    //

    if (pHeader->dwCount != BasepBitMapCountBits(EntryMap, sizeof(EntryMap)/sizeof(EntryMap[0]))) {
        DbgPrint("BasepShimCheckCacheIntegrity: count mismatch\n");
        return FALSE;
    }

    return TRUE;

}


BOOL
BasepShimCacheUnlock(
    VOID
    )
{
    if (ghShimCacheMutex) {
        return ReleaseMutex(ghShimCacheMutex);
    }

    return FALSE;
}

BOOL
BasepShimCacheLock(
    PSHIMCACHEHEADER* ppHeader,
    PSHIMCACHEENTRY*  ppEntries
    )
{
    NTSTATUS Status;
    DWORD    dwWaitResult;
    PSHIMCACHEHEADER pHeader  = NULL;
    PSHIMCACHEENTRY  pEntries = NULL;
    BOOL bReturn = FALSE;

    //
    // the function below will open (but not create!) all the shared objects
    //
    if (!BaseInitAppcompatCache()) {
        DbgPrint("Call to BaseInitAppCompatCache failed\n");
        return FALSE;
    }

    __try {

        pHeader = (PSHIMCACHEHEADER)gpShimCacheShared;

        //
        // we have obtained global mutex - check the cache for defects
        //
        if (!BasepShimCacheCheckIntegrity(pHeader)) {
            // cannot verify cache integrity -- too bad, re-init
            BasepShimCacheInit(pHeader, NULL, MAX_SHIM_CACHE_ENTRIES);
        }

        pEntries = GET_SHIM_CACHE_ENTRIES(pHeader);

        bReturn = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER){
        DbgPrint("BasepShimCacheLock: exception while trying to check cache\n");
        bReturn = FALSE;
    }

    if (bReturn) {
        if (ppHeader != NULL) {
            *ppHeader  = pHeader;
        }
        if (ppEntries != NULL) {
            *ppEntries = pEntries;
        }
    } else {
        BasepShimCacheUnlock();
    }

    return bReturn;
}


/*++
    Callable functions, with protection, etc
    BasepCheckAppcompatCache returns true if an app has been found in cache, no fixes are needed

    if BasepCheckAppcompatCache returns false - we will have to call into apphelp.dll to check further
    apphelp.dll will then call BasepUpdateAppcompatCache if an app has no fixes to be applied to it

--*/

BOOL
WINAPI
BaseCheckAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    PVOID   pEnvironment,
    DWORD*  pdwReason
    )
{
    PSHIMCACHEHEADER pHeader  = NULL;
    PSHIMCACHEENTRY  pEntries = NULL;
    BOOL  bFoundInCache = FALSE;
    BOOL  bLayer        = FALSE;
    DWORD dwReason      = 0;

    if (BasepShimCacheCheckBypass(pwszPath, hFile, pEnvironment, TRUE, &dwReason)) {
        //
        // cache bypass was needed
        //
        dwReason |= SHIM_CACHE_BYPASS;
        DbgPrint("Application \"%S\" Cache bypassed reason 0x%lx\n", pwszPath, dwReason);
        goto Exit;
    }

    //
    // aquire cache
    //

    if (!BasepShimCacheLock(&pHeader, &pEntries)) {
        //
        // cannot lock the cache
        //
        dwReason |= SHIM_CACHE_NOTAVAIL;
        DbgPrint("Application \"%S\" cache not available\n", pwszPath);
        goto Exit;
    }

    __try {
        //
        // search the cache
        //

        bFoundInCache = BasepShimCacheLookup(pHeader, pEntries, pwszPath, hFile);
        if (!bFoundInCache) {
            dwReason |= SHIM_CACHE_NOT_FOUND;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint("BaseCheckAppcompatCache: Exception while trying to lookup cache\n");
        bFoundInCache = FALSE;
    }

    if (bFoundInCache) {
        DbgPrint("Application \"%S\" found in cache\n", pwszPath);
    } else {
        DbgPrint("Application \"%S\" not found in cache\n", pwszPath);
    }

    BasepShimCacheUnlock();

Exit:
    if (pdwReason != NULL) {
        *pdwReason = dwReason;
    }

    return bFoundInCache;
}

BOOL
WINAPI
BaseUpdateAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    BOOL    bRemove
    )
{
    PSHIMCACHEHEADER pHeader  = NULL;
    PSHIMCACHEENTRY  pEntries = NULL;
    BOOL bSuccess = FALSE;
    INT  nIndex = -1;

    if (!BasepShimCacheLock(&pHeader, &pEntries)) {
        //
        // cannot lock the cache
        //
        DbgPrint("BaseUpdateAppcompatCache: Cache not available\n");
        return FALSE;
    }

    __try {
        //
        // search the cache
        //
        if (bRemove) {
            if (BasepShimCacheSearch(pHeader, pEntries, pwszPath, &nIndex)) {
                bSuccess = BasepShimCacheRemoveEntry(pHeader, pEntries, nIndex);
            }
        } else {
            //
            // before updating check whether this entry should be bypassed
            //
            if (!BasepShimCacheCheckBypass(pwszPath, hFile, NULL, FALSE, NULL)) {
                bSuccess = BasepShimCacheUpdate(pHeader, pEntries, pwszPath, hFile);
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        bSuccess = FALSE;
    }

    BasepShimCacheUnlock();

    return bSuccess;

}

BOOL
WINAPI
BaseFlushAppcompatCache(
    VOID
    )
{
    PSHIMCACHEHEADER pHeader  = NULL;
    PSHIMCACHEENTRY  pEntries = NULL;
    BOOL bSuccess = FALSE;

    if (!BasepShimCacheLock(&pHeader, &pEntries)) {
        //
        // cannot lock the cache
        //
        return FALSE;
    }

    __try {

        //
        // init the cache
        //
        BasepShimCacheInit(pHeader, pEntries, MAX_SHIM_CACHE_ENTRIES);

        //
        // now write the value into the registry
        //
        BasepShimCacheWrite(pHeader);

        bSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        bSuccess = FALSE;
    }

    BasepShimCacheUnlock();

    if (bSuccess) {
        DbgPrint("BaseFlushAppcompatCache: Cache Initialized\n");
    }

    return bSuccess;

}

//
// returns TRUE if cache is allowed
//

BOOL
BasepCheckCacheExcludeList(
    LPCWSTR pwszPath
    )
{
    NTSTATUS           Status;
    ULONG              ResultLength;
    OBJECT_ATTRIBUTES  ObjectAttributes;
    UNICODE_STRING     KeyPathUser = { 0 }; // path to hkcu
    UNICODE_STRING     ExePathNt;           // temp holder
    KEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RTL_UNICODE_STRING_BUFFER  ExePathBuffer; // buffer to store exe path
    RTL_UNICODE_STRING_BUFFER  KeyNameBuffer;
    UCHAR              BufferKey[MAX_PATH * 2];
    UCHAR              BufferPath[MAX_PATH * 2];
    HANDLE             KeyHandle          = NULL;
    BOOL               bCacheAllowed      = FALSE;

    RtlInitUnicodeStringBuffer(&ExePathBuffer, BufferPath, sizeof(BufferPath));
    RtlInitUnicodeStringBuffer(&KeyNameBuffer, BufferKey,  sizeof(BufferKey));

    Status = RtlFormatCurrentUserKeyPath(&KeyPathUser);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to format user key path 0x%lx\n", Status);
        goto Cleanup;
    }

    //
    // allocate a buffer that'd be large enough -- or use a local buffer
    //

    Status = RtlAssignUnicodeStringBuffer(&KeyNameBuffer, &KeyPathUser);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to copy hkcu path status 0x%lx\n", Status);
        goto Cleanup;
    }

    Status = RtlAppendUnicodeStringBuffer(&KeyNameBuffer, &AppcompatKeyPathLayers);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to copy layers path status 0x%lx\n", Status);
        goto Cleanup;
    }

    // we have a string for the key path

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyNameBuffer.String,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&KeyHandle,
                       KEY_READ,  // note - read access only
                       &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        bCacheAllowed = (STATUS_OBJECT_NAME_NOT_FOUND == Status);
        goto Cleanup;
    }

    //
    // now create value name
    //
    RtlInitUnicodeString(&ExePathNt, pwszPath);

    Status = RtlAssignUnicodeStringBuffer(&ExePathBuffer, &ExePathNt);
    if (!NT_SUCCESS(Status)) {
         DbgPrint("BasepCheckCacheExcludeList: failed to acquire sufficient buffer size for path %ls status 0x%lx\n", pwszPath, Status);
         goto Cleanup;
    }

    Status = RtlNtPathNameToDosPathName(0, &ExePathBuffer, NULL, NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BasepCheckCacheExcludeList: failed to convert nt path name %ls to dos path name status 0x%lx\n", pwszPath, Status);
        goto Cleanup;
    }

    // now we shall query the value
    Status = NtQueryValueKey(KeyHandle,
                             &ExePathBuffer.String,
                             KeyValuePartialInformation,
                             &KeyValueInformation,
                             sizeof(KeyValueInformation),
                             &ResultLength);

    bCacheAllowed = (Status == STATUS_OBJECT_NAME_NOT_FOUND); // does not exist is more like it

Cleanup:

    if (KeyHandle) {
        NtClose(KeyHandle);
    }

    RtlFreeUnicodeString(&KeyPathUser);

    RtlFreeUnicodeStringBuffer(&ExePathBuffer);
    RtlFreeUnicodeStringBuffer(&KeyNameBuffer);

    if (!bCacheAllowed) {
        DbgPrint("BasepCheckCacheExcludeList: Cache not allowed for %ls\n", pwszPath);
    }

    return bCacheAllowed;
}



#undef DbgPrint

VOID
WINAPI
BaseDumpAppcompatCache(
    VOID
    )
{
    PSHIMCACHEHEADER pHeader  = NULL;
    PSHIMCACHEENTRY  pEntries = NULL;
    INT  i;
    INT  iEntry;
    PSHIMCACHEENTRY  pEntry;

    if (!BasepShimCacheLock(&pHeader, &pEntries)) {
        DbgPrint("Can't get ShimCacheLock\n");
        return;
    }

    DbgPrint("---------------------------------------------\n");
    DbgPrint("Total Entries = 0x%x\n", pHeader->dwCount);

    if (pHeader->dwCount) {  //             " 01.  0x12345678 0x12345678 0x12345678  "
        DbgPrint("(LRU)   (Exe Name) (FileSize)\n");
    }

    for (i = 0; i < (int)pHeader->dwCount; ++i) {
        iEntry = pHeader->rgIndex[i];
        pEntry = pEntries + iEntry;

        DbgPrint(" %2d.  \"%ls\" %ld\n",
                  i + 1,
                  pEntry->wszPath,
                  (DWORD)pEntry->FileSize);

    }

    DbgPrint("---------------------------------------------\n");

    BasepShimCacheUnlock();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wdmlib\wdmsec\wl\wlwrap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlWrap.c

Abstract:

    This module wraps library functions, rerouting them to native
    implementations as available.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "WlpWrap.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, WdmlibInit)
#pragma alloc_text(PAGE, WdmlibIoCreateDeviceSecure)
#endif

BOOLEAN WdmlibInitialized = FALSE;

//
// Here is a list of global variables through which we route our function calls
//
PFN_IO_CREATE_DEVICE_SECURE             PfnIoCreateDeviceSecure = NULL;
PFN_IO_VALIDATE_DEVICE_IOCONTROL_ACCESS PfnIoValidateDeviceIoControlAccess = NULL;


VOID
WdmlibInit(
    VOID
    )
{
    UNICODE_STRING functionName;

    RtlInitUnicodeString(&functionName, L"IoCreateDeviceSecure");

    PfnIoCreateDeviceSecure = MmGetSystemRoutineAddress(&functionName);

    if (PfnIoCreateDeviceSecure == NULL) {

        PfnIoCreateDeviceSecure = IoDevObjCreateDeviceSecure;
    }

    RtlInitUnicodeString(&functionName, L"IoValidateDeviceIoControlAccess");

    PfnIoValidateDeviceIoControlAccess = MmGetSystemRoutineAddress(&functionName);

    WdmlibInitialized = TRUE;
}


NTSTATUS
WdmlibIoCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid,
    OUT PDEVICE_OBJECT     *DeviceObject
    )
/*++

Routine Description:

    This routine is a library wrapper for IoCreateDeviceSecure. It calls either
    the internal library version of IoCreateDeviceSecure, or it calls the
    native implementation in the Operating System.

Parameters:

    See IoCreateDeviceSecure documentation.

Return Value:

    See IoCreateDeviceSecure documentation.

--*/
{
    if (WdmlibInitialized == FALSE) {

        WdmlibInit();
    }

    return PfnIoCreateDeviceSecure(
        DriverObject,
        DeviceExtensionSize,
        DeviceName,
        DeviceType,
        DeviceCharacteristics,
        Exclusive,
        DefaultSDDLString,
        DeviceClassGuid,
        DeviceObject
        );
}


NTSTATUS
WdmlibRtlInitUnicodeStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN  PCWSTR          SourceString        OPTIONAL
    )
{
    SIZE_T Length;

    if (SourceString != NULL) {

        Length = wcslen(SourceString);

        //
        // We are actually limited to 32765 characters since we want to store a
        // meaningful MaximumLength also.
        //
        if (Length > (UNICODE_STRING_MAX_CHARS - 1)) {

            return STATUS_NAME_TOO_LONG;
        }

        Length *= sizeof(WCHAR);

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + sizeof(WCHAR));
        DestinationString->Buffer = (PWSTR) SourceString;

    } else {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
WdmlibIoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    )
/*++

Routine Description:


    This routine validates ioctl access bits based on granted access
    information passed in the IRP. This routine is called by a driver to
    validate IOCTL access bits for IOCTLs that were originally defined as
    FILE_ANY_ACCESS and cannot be changed for compatibility reasons but really
    has to be validated for read/write access.

    This routine is actually a wrapper around the kernel function exported in
    XPSP1 and .NET server versions of Windows. This wrapper allows a driver to
    call this function on all versions of Windows starting with WIN2K. On
    Windows platforms which don't support the kernel function
    IoValidateDeviceIoControlAccess this wrapper reverts back to the old
    behaviour. This wrapper allows a driver to have the same source code and
    get the added benefit of the security check on newer operating systems.

Arguments:

    IRP - IRP for the device control

    RequiredAccess - Is the expected access required by the driver. Should be
        FILE_READ_ACCESS, FILE_WRITE_ACCESS or both.

Return Value:

    Returns NTSTATUS

--*/
{

    //
    // In older versions, assume access check succeeds
    // to retain old behaviour.
    //

    if (PfnIoValidateDeviceIoControlAccess == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // If the function is present use the appropriate access check.
    //

    return (PfnIoValidateDeviceIoControlAccess(Irp, RequiredAccess));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\basesxs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    basesxs.h

Abstract:

    Side-by-side stuff that has to be factored out of basedll.h and ntwow64b.h.

Author:

    Jay Krell (a-JayK) June 2000

Revision History:

--*/

#ifndef _BASESXS_
#define _BASESXS_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Passing a run of three handles into functions is confusing.
// There's nothing enforcing getting them in the right order.
// I had it wrong. This addresses that.
//
typedef struct _BASE_MSG_SXS_HANDLES {
    HANDLE File;

    //
    // Process is the process to map section into, it can
    // be NtCurrentProcess; ensure that case is optimized.
    //
    HANDLE Process;
    HANDLE Section;

    PVOID ViewBase; // Don't use this is in 32bit code on 64bit.
} BASE_MSG_SXS_HANDLES, *PBASE_MSG_SXS_HANDLES;
typedef const BASE_MSG_SXS_HANDLES* PCBASE_MSG_SXS_HANDLES;

typedef struct _SXS_OVERRIDE_STREAM {
    UNICODE_STRING Name;
    PVOID          Address;
    SIZE_T         Size;
} SXS_OVERRIDE_STREAM, *PSXS_OVERRIDE_STREAM;
typedef const SXS_OVERRIDE_STREAM* PCSXS_OVERRIDE_STREAM;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\backup.c ===
//
//        Copyright (c) 1991  Microsoft Corporation & Maynard Electornics
//
//        Module Name:
//
//            backup.c
//
//        Abstract:
//
//            This module implements Win32 Backup APIs
//
//        Author:
//
//            Steve DeVos (@Maynard)    2 March, 1992   15:38:24
//
//        Revision History:

#include <basedll.h>
#pragma hdrstop

#include <windows.h>


#define CWCMAX_STREAMNAME        512
#define CB_NAMELESSHEADER        FIELD_OFFSET(WIN32_STREAM_ID, cStreamName)

typedef struct
{
    DWORD BufferSize;
    DWORD AllocSize;
    BYTE *Buffer;
} BUFFER;

//
//  BACKUPCONTEXT is the structure used to note the state of the backup.
//  

typedef struct
{
    //
    //  Public header describing current stream. Since this structure precedes
    //  a variable-length stream name, we must reserve space for that name
    //  following the header.
    //
    
    WIN32_STREAM_ID head;
    union {
         WCHAR            awcName[CWCMAX_STREAMNAME];
    } ex ;

    LARGE_INTEGER    cbSparseOffset ;

    //
    //  Offset in the current segment of the backup stream.  This includes
    //  the size of the above header (including variable length name).
    //

    LONGLONG        liStreamOffset;

    //
    //  BackupRead machine state
    //
    
    DWORD            StreamIndex;
    
    //
    //  Calculated size of the above header.
    //

    DWORD            cbHeader;
    
    //
    //  Handle to alternate data stream
    //

    HANDLE            hAlternate;

    //
    //  Buffers
    //

    BUFFER          DataBuffer;         //  Data buffer
    DWORD           dwSparseMapSize ;   //  size of the sparse file map
    DWORD           dwSparseMapOffset ; //  offset into the sparse map
    BOOLEAN         fSparseBlockStart ; //  TRUE if start of sparse block
    BOOLEAN         fSparseHandAlt  ;   //  TRUE if sparse stream is alt stream

    DWORD           iNameBuffer;        //  Offset into stream name buffer
    BUFFER          StreamNameBuffer;   //  Stream name buffer
    BOOLEAN            NamesReady;         //  TRUE if stream name buffer has data in it
    
    BOOLEAN            fStreamStart;       //  TRUE if start of new stream
    BOOLEAN            fMultiStreamType;   //  TRUE if stream type has > 1 stream hdr
    BOOLEAN            fAccessError;       //  TRUE if access to a stream was denied
    DWORD              fAttribs;           //  object attributes...
} BACKUPCONTEXT;


//
//  BACKUPIOFRAME describes the current user BackupRead/Write request
//

typedef struct
{
    BYTE   *pIoBuffer;
    DWORD  *pcbTransferred;
    DWORD   cbRequest;
    BOOLEAN fProcessSecurity;
} BACKUPIOFRAME;


#define CBMIN_BUFFER  1024

#define BufferOverflow(s) \
    ((s) == STATUS_BUFFER_OVERFLOW || (s) == STATUS_BUFFER_TOO_SMALL)

int mwStreamList[] =
{
    BACKUP_SECURITY_DATA,
    BACKUP_REPARSE_DATA,
    BACKUP_DATA,
    BACKUP_EA_DATA,
    BACKUP_ALTERNATE_DATA,
    BACKUP_OBJECT_ID,
    BACKUP_INVALID,
};



__inline VOID *
BackupAlloc (DWORD cb)
/*++

Routine Description:

    This is an internal routine that wraps heap allocation with tags.

Arguments:

    cb - size of block to allocate

Return Value:

    pointer to allocated memory or NULL

--*/
{
    return RtlAllocateHeap( RtlProcessHeap( ), MAKE_TAG( BACKUP_TAG ), cb );
}


__inline VOID
BackupFree (IN VOID *pv)
/*++

Routine Description:

    This is an internal routine that wraps heap freeing.

Arguments:

    pv - memory to be freed

Return Value:

    None.

--*/
{
    RtlFreeHeap( RtlProcessHeap( ), 0, pv );
}


BOOL
GrowBuffer (IN OUT BUFFER *Buffer, IN DWORD cbNew)
/*++

Routine Description:

    Attempt to grow the buffer in the backup context.

Arguments:

    Buffer - pointer to buffer
    
    cbNew - size of buffer to allocate

Return Value:

    TRUE if buffer was successfully allocated.

--*/
{
    VOID *pv;

    if ( Buffer->AllocSize < cbNew ) {
         pv = BackupAlloc( cbNew );
    
         if (pv == NULL) {
             SetLastError( ERROR_NOT_ENOUGH_MEMORY );
             return FALSE;                                                     
         }
    
         RtlCopyMemory( pv, Buffer->Buffer, Buffer->BufferSize );
         
         BackupFree( Buffer->Buffer );
    
         Buffer->Buffer = pv;
         Buffer->AllocSize = cbNew ;
     }
    
     Buffer->BufferSize = cbNew;

     return TRUE;
}

__inline VOID
FreeBuffer (IN OUT BUFFER *Buffer)
/*++

Routine Description:

    Free the buffer

Arguments:

    Buffer - pointer to buffer
    
Return Value:

    Nothing

--*/
{
    if (Buffer->Buffer != NULL) {
        BackupFree( Buffer->Buffer );
        Buffer->Buffer = NULL;
    }
}

VOID ResetAccessDate( HANDLE hand )
{
        
   LONGLONG tmp_time = -1 ;
   FILETIME *time_ptr ;

   time_ptr = (FILETIME *)(&tmp_time);

   if (hand != INVALID_HANDLE_VALUE) {
       SetFileTime( hand,
             time_ptr, 
             time_ptr, 
             time_ptr ) ; 

   }
   
}


VOID
FreeContext (IN OUT LPVOID *lpContext)
/*++

Routine Description:

    Free a backup context and release all resources assigned to it.

Arguments:

    lpContext - pointer to pointer backup context

Return Value:

    None.

--*/
{
    BACKUPCONTEXT *pbuc = *lpContext;

    if (pbuc != INVALID_HANDLE_VALUE) {
        
        FreeBuffer( &pbuc->DataBuffer );
        FreeBuffer( &pbuc->StreamNameBuffer );
        
        ResetAccessDate( pbuc->hAlternate ) ;
        if (pbuc->hAlternate != INVALID_HANDLE_VALUE) {

            CloseHandle( pbuc->hAlternate );
        }
        
        BackupFree(pbuc);
        
        *lpContext = INVALID_HANDLE_VALUE;
    }
}


BACKUPCONTEXT *
AllocContext (IN DWORD cbBuffer)
/*++

Routine Description:

    Allocate a backup context with a buffer of a specified size

Arguments:

    cbBuffer - desired length of the buffer

Return Value:

    pointer to initialized backupcontext or NULL if out of memory.

--*/
{
    BACKUPCONTEXT *pbuc;

    pbuc = BackupAlloc( sizeof( *pbuc ));

    if (pbuc != NULL) {
        RtlZeroMemory( pbuc, sizeof( *pbuc ));
        pbuc->fStreamStart = TRUE;

        if (cbBuffer != 0 && !GrowBuffer( &pbuc->DataBuffer, cbBuffer )) {
            BackupFree( pbuc );
            pbuc = NULL;
        }
    }
    
    if (pbuc == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return(pbuc);
}



LONGLONG
ComputeRemainingSize (IN BACKUPCONTEXT *pbuc)
/*++

Routine Description:

    (Re)Compute the number of bytes required to store the current 
    stream.  This needs to take into account the header length as
    well.

Arguments:

    pbuc - backup context

Return Value:

    Amount of data still remaining to transfer.  Includes header
    size.

--*/
{
    LARGE_INTEGER ret_size ;

    ret_size.QuadPart = pbuc->cbHeader + pbuc->head.Size.QuadPart 
                               - pbuc->liStreamOffset;

    //
    // since the internally we treat the sparse buffer offset 
    // as part of the header and since the caller need to see it
    // as part of the data, this code make the internal correction.
    //
    if ( pbuc->head.dwStreamId == BACKUP_SPARSE_BLOCK  ) {

         ret_size.QuadPart -= sizeof(LARGE_INTEGER) ;
    }

    return ret_size.QuadPart ; 
}


DWORD
ComputeRequestSize (BACKUPCONTEXT *pbuc, DWORD cbrequest)
/*++

Routine Description:

    Given a transfer size request, return the number of
    bytes remaining that can safely be returned to the
    caller

Arguments:

    pbuc - context of call
    
    cbRequest - desired transfer size

Return Value:

    amount of data available to return.

--*/
{
    LONGLONG licbRemain;

    licbRemain = ComputeRemainingSize( pbuc );
    
    return (DWORD) min( cbrequest, licbRemain );
}


VOID
ReportTransfer(BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif, DWORD cbtransferred)
/*++

Routine Description:

    Note that a transfer has occurred and update contexts

Arguments:

    pbuc - context of call
    
    pbif - BACKUPIOFRAME of call detailing call
    
    cbtransferred - amount successfully transferred

Return Value:

    None.

--*/
{
    pbuc->liStreamOffset += cbtransferred;
    *pbif->pcbTransferred += cbtransferred;
    pbif->cbRequest -= cbtransferred;
    pbif->pIoBuffer += cbtransferred;
}



VOID
BackupReadBuffer (BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from the buffer in the backup
    context.

Arguments:

    pbuc - context of call
    
    pbif - frame describing desired user BackupRead request

Return Value:

    None.

--*/
{
    DWORD cbrequest;
    BYTE *pb;

    //
    //  Determine size of allowable transfer and pointer to source
    //  data
    //
    
    cbrequest = ComputeRequestSize( pbuc, pbif->cbRequest );
    pb = &pbuc->DataBuffer.Buffer[ pbuc->liStreamOffset - pbuc->cbHeader ];

    //
    //  Move the data to the user's buffer
    //
    
    RtlCopyMemory(pbif->pIoBuffer, pb, cbrequest);

    //
    //  Update statistics
    //
    
    ReportTransfer(pbuc, pbif, cbrequest);
}



BOOL
BackupReadStream (HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from the stream.

Arguments:

    hFile - handle to file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    DWORD cbrequest;
    DWORD cbtransferred;
    BOOL fSuccess;

    if (pbuc->fSparseBlockStart) {

        PFILE_ALLOCATED_RANGE_BUFFER range_buf ;
        LARGE_INTEGER licbFile ;

        range_buf = (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer + pbuc->dwSparseMapOffset) ;

        pbuc->head.Size.QuadPart = range_buf->Length.QuadPart + sizeof(LARGE_INTEGER) ;

        pbuc->head.dwStreamId = BACKUP_SPARSE_BLOCK ;
        pbuc->head.dwStreamAttributes = STREAM_SPARSE_ATTRIBUTE;

        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER + sizeof( LARGE_INTEGER ) ;

        pbuc->cbSparseOffset = range_buf->FileOffset ;

        RtlCopyMemory( pbuc->head.cStreamName, &pbuc->cbSparseOffset, sizeof( LARGE_INTEGER ) ) ;

        pbuc->fSparseBlockStart = FALSE;

        licbFile.HighPart = 0;

        licbFile.HighPart = range_buf->FileOffset.HighPart;

        licbFile.LowPart = SetFilePointer( hFile,
                              range_buf->FileOffset.LowPart,
                              &licbFile.HighPart,
                              FILE_BEGIN );

        if ( licbFile.QuadPart != range_buf->FileOffset.QuadPart ) {
            pbuc->fAccessError = TRUE;
            return FALSE ;
        } else {
            return TRUE ;
        }
    }    


    if (pbuc->liStreamOffset < pbuc->cbHeader) {

       return TRUE ;
    }

    cbrequest = ComputeRequestSize( pbuc, pbif->cbRequest );

    fSuccess = ReadFile( hFile, pbif->pIoBuffer, cbrequest, &cbtransferred, NULL );

    if (cbtransferred != 0) {
        
        ReportTransfer( pbuc, pbif, cbtransferred );
    
    } else if (fSuccess && cbrequest != 0) {
        
        SetLastError( ERROR_IO_DEVICE );
        fSuccess = FALSE;
    }
    
    return(fSuccess);
}



BOOL
BackupGetSparseMap (HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Reads the sparse data map.

Arguments:

    hFile - handle to file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
     FILE_ALLOCATED_RANGE_BUFFER  req_buf ;
     PFILE_ALLOCATED_RANGE_BUFFER last_ret_buf ;
     DWORD     out_buf_size ;
     DWORD     data_size = 4096 ;
     IO_STATUS_BLOCK iosb ;
     LARGE_INTEGER   file_size ;
     NTSTATUS        Status ;
     BOOLEAN         empty_file = FALSE ;

     req_buf.FileOffset.QuadPart = 0 ;

     pbuc->dwSparseMapSize   = 0 ;
     pbuc->dwSparseMapOffset = 0 ;
     pbuc->fSparseBlockStart = FALSE ;

     req_buf.Length.LowPart = GetFileSize( hFile, 
                                           &req_buf.Length.HighPart );

     file_size = req_buf.Length ;

     do {
          if ( GrowBuffer( &pbuc->DataBuffer, 
                           data_size ) ) {
          
               iosb.Information = 0 ;

               Status = NtFsControlFile( hFile,
                                NULL,  // overlapped event handle
                                NULL,  // Apc routine
                                NULL,  // overlapped structure
                                &iosb,
                                FSCTL_QUERY_ALLOCATED_RANGES,   
                                &req_buf,
                                sizeof( req_buf ),
                                pbuc->DataBuffer.Buffer + pbuc->dwSparseMapSize,
                                pbuc->DataBuffer.AllocSize - pbuc->dwSparseMapSize ) ;

               out_buf_size = 0 ;

               if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS( Status ) ) {
                    out_buf_size = (DWORD)iosb.Information ;
                    if ( out_buf_size == 0 ) {
                         empty_file = TRUE ;
                    }
               }

               if ( out_buf_size != 0 ) {
                    pbuc->dwSparseMapSize += out_buf_size ;

                    last_ret_buf = 
                         (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer +
                                                    pbuc->dwSparseMapSize -
                                                    sizeof(FILE_ALLOCATED_RANGE_BUFFER)) ;

                    req_buf.FileOffset = last_ret_buf->FileOffset ;
                    req_buf.FileOffset.QuadPart += last_ret_buf->Length.QuadPart ;

                    //
                    // if we can't fit any more in the buffer lets increase
                    //   the size and get more data otherwise assume were done.
                    //
                    if ( pbuc->dwSparseMapSize + sizeof(FILE_ALLOCATED_RANGE_BUFFER) >
                         pbuc->DataBuffer.AllocSize ) {
                         data_size += 4096 ;

                    } else {

                         break ;
                    }

               } else {

                    // reallocate for one more buffer entry
                    if ( out_buf_size + sizeof(FILE_ALLOCATED_RANGE_BUFFER) > data_size ) {
                         data_size += 4096 ;
                         continue ;
                    }

                    break ;
               }
          
          } else {

               pbuc->dwSparseMapSize = 0 ;
               break ;

          }
               
     } while ( TRUE ) ;

     //
     // if there are RANGE_BUFFERS and it isn't simply the whole file, then
     //     go into sparse read mode.
     //

     // hold on to your hat...   

     //  If there are no allocated ranges and the file is NOT 0 length
     //    then we want to manufacture a record for the file length.
     //

     if ( (empty_file && ( file_size.QuadPart != 0 )) || (pbuc->dwSparseMapSize >= sizeof( FILE_ALLOCATED_RANGE_BUFFER) ) ) {

          last_ret_buf = (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer ) ;

          if ( empty_file ||
               ( last_ret_buf->FileOffset.QuadPart != 0 ) ||
               ( last_ret_buf->Length.QuadPart != file_size.QuadPart ) ) {


               // first lets add a record for the EOF marker 
               pbuc->dwSparseMapSize += sizeof(FILE_ALLOCATED_RANGE_BUFFER) ;
               last_ret_buf = 
                      (PFILE_ALLOCATED_RANGE_BUFFER)(pbuc->DataBuffer.Buffer +
                                                 pbuc->dwSparseMapSize -
                                                    sizeof(FILE_ALLOCATED_RANGE_BUFFER)) ;

               last_ret_buf->FileOffset.QuadPart = file_size.QuadPart ;
               last_ret_buf->Length.QuadPart = 0 ;

               pbuc->fSparseBlockStart = TRUE ;
               return TRUE ;
          }
     } 

     pbuc->dwSparseMapSize = 0 ;
     return FALSE ;
}
     

BOOL
BackupReadData (HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Read default data for a user BackupRead request.

Arguments:

    hFile - handle to file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    LARGE_INTEGER licbFile ;

    //
    //  If the context is not initialized for this transfer,
    //  set up based on file size.
    //
    
    if (pbuc->fStreamStart) {

        if (pbuc->fAttribs & FILE_ATTRIBUTE_ENCRYPTED) {
            return TRUE;
        }

        if (pbuc->fAttribs & FILE_ATTRIBUTE_DIRECTORY) {
            return TRUE;
        }

        licbFile.LowPart = GetFileSize( hFile, &licbFile.HighPart );

        if (licbFile.QuadPart == 0) {
            return TRUE;
        }
        
        if (licbFile.LowPart == 0xffffffff && GetLastError() != NO_ERROR) {
            return FALSE;
        }


        pbuc->head.dwStreamId = BACKUP_DATA;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;

        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;
        pbuc->fStreamStart = FALSE;

        if ( BackupGetSparseMap( hFile, pbuc, pbif ) ) {

            pbuc->head.Size.QuadPart = 0 ;
            pbuc->head.dwStreamAttributes = STREAM_SPARSE_ATTRIBUTE;

        } else {

            pbuc->head.Size = licbFile;

            licbFile.HighPart = 0;
            SetFilePointer( hFile, 0, &licbFile.HighPart, FILE_BEGIN );
        }


        return TRUE;
    }

    //
    //  If there's more data for us to read, then go and
    //  get it from the stream
    //
    

    return BackupReadStream( hFile, pbuc, pbif );
}



BOOL
BackupReadAlternateData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from alternate data streams.

Arguments:

    hFile - handle to base file for transfer
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    //
    //  If we haven't started transferring alternate data streams then
    //  buffer all the stream information from the file system
    //
    
    if (pbuc->fStreamStart) {
        NTSTATUS Status;
        FILE_STREAM_INFORMATION *pfsi;
        IO_STATUS_BLOCK iosb;

        if (pbuc->fAttribs & FILE_ATTRIBUTE_ENCRYPTED) {
             if ( !(pbuc->fAttribs & FILE_ATTRIBUTE_DIRECTORY) ) {

                 return TRUE;
             }
        }

        //
        //  Loop, growing the names buffer, until it is large enough to 
        //  contain all the alternate data
        //
        
        if (!pbuc->NamesReady) {
            
            if (!GrowBuffer( &pbuc->StreamNameBuffer, 1024 ) ) {
                    
                 return FALSE;
            }
            
            while (TRUE) {
                //
                //  Resize the buffer.  If we cannot grow it, then fail.
                //
                
                Status = NtQueryInformationFile(
                            hFile,
                            &iosb,
                            pbuc->StreamNameBuffer.Buffer,
                            pbuc->StreamNameBuffer.BufferSize,
                            FileStreamInformation);

                //
                //  If we succeeded in reading some data, set the buffer
                //  up and finish initializing
                //
                
                if (NT_SUCCESS(Status) && iosb.Information != 0) {
                    pbuc->iNameBuffer = 0;
                    pbuc->NamesReady = TRUE;
                    break;
                }
                
                //
                //  If the error was not due to overflow, then skip
                //  all alternate streams
                //
                
                if (!BufferOverflow(Status)) {
                    return TRUE;        
                }

                //
                // simply inlarge the buffer and try again.
                //
                if (!GrowBuffer( &pbuc->StreamNameBuffer, 
                                 pbuc->StreamNameBuffer.BufferSize * 2)) {
                    
                    return FALSE;
                }

            }
        }

        pbuc->hAlternate = INVALID_HANDLE_VALUE;
        pbuc->fStreamStart = FALSE;
        pfsi = (FILE_STREAM_INFORMATION *) &pbuc->StreamNameBuffer.Buffer[pbuc->iNameBuffer];

        //
        //  Skip first stream if it is the default data stream.  This 
        //  code is NTFS-specific and relies on behaviour not documented anywhere.
        //
        
        if (pfsi->StreamNameLength >= 2 * sizeof(WCHAR) &&
            pfsi->StreamName[1] == ':') {
            
            if (pfsi->NextEntryOffset == 0) {
                return TRUE;                // No more, do next stream type
            }
            
            pbuc->iNameBuffer += pfsi->NextEntryOffset;
        
        }
        
        pbuc->head.Size.LowPart = 1;
    
    //
    //  If we don't have an open stream
    //

    } else if (pbuc->hAlternate == INVALID_HANDLE_VALUE) {
        NTSTATUS Status;
        PFILE_STREAM_INFORMATION pfsi;
        UNICODE_STRING strName;
        OBJECT_ATTRIBUTES oa;
        IO_STATUS_BLOCK iosb;
        DWORD reparse_flg = 0 ;

        pbuc->head.Size.QuadPart = 0;

        //
        //  Form the relative name of the stream and try to
        //  open it relative to the base file
        //
        
        pfsi = (FILE_STREAM_INFORMATION *) &pbuc->StreamNameBuffer.Buffer[pbuc->iNameBuffer];

        strName.Length = (USHORT) pfsi->StreamNameLength;
        strName.MaximumLength = strName.Length;
        strName.Buffer = pfsi->StreamName;


        if (pbuc->fAttribs & FILE_ATTRIBUTE_REPARSE_POINT ) {

             reparse_flg = FILE_OPEN_REPARSE_POINT ;

        }

        InitializeObjectAttributes(
                 &oa,
                 &strName,
                 OBJ_CASE_INSENSITIVE,
                 hFile,
                 NULL);

        Status = NtOpenFile(
                    &pbuc->hAlternate,
                    FILE_READ_DATA | SYNCHRONIZE,
                    &oa,
                    &iosb,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | reparse_flg);

        //
        //  If we did not succeed, skip this entry and set up for another stream
        //

        if (!NT_SUCCESS( Status )) {
            pbuc->iNameBuffer += pfsi->NextEntryOffset;
            if (pfsi->NextEntryOffset != 0) {
                pbuc->head.Size.LowPart = 1;
                pbuc->fMultiStreamType = TRUE;        // more to come
            }
            SetLastError( ERROR_SHARING_VIOLATION );
            return FALSE;
        }

        // if we can't lock all records, return an error
        if (!LockFile( pbuc->hAlternate, 0, 0, 0xffffffff, 0xffffffff )) {
            SetLastError( ERROR_SHARING_VIOLATION );
            return FALSE;
        }

        //
        //  Perform common header initialization
        //
        
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = pfsi->StreamNameLength;

        pbuc->cbHeader = CB_NAMELESSHEADER + pfsi->StreamNameLength;

        RtlCopyMemory(
            pbuc->head.cStreamName,
            pfsi->StreamName,
            pfsi->StreamNameLength);

        //
        //  Advance to the next stream in the stream information block
        //
        
        if (pfsi->NextEntryOffset != 0) {
            pbuc->iNameBuffer += pfsi->NextEntryOffset;
            pbuc->fMultiStreamType = TRUE;
        }
    
        //
        //  If we are a data stream, set up for data stream copy
        //

        if (BasepIsDataAttribute( pfsi->StreamNameLength, pfsi->StreamName )) {

            pbuc->head.dwStreamId = BACKUP_ALTERNATE_DATA;


            if ( BackupGetSparseMap( pbuc->hAlternate, pbuc, pbif ) ) {

                 pbuc->head.Size.QuadPart = 0 ;
                 pbuc->head.dwStreamAttributes = STREAM_SPARSE_ATTRIBUTE;

            } else {

                pbuc->head.Size.LowPart = GetFileSize(
                    pbuc->hAlternate,
                    &pbuc->head.Size.HighPart );

            }
        }

    //
    //  If we need to return the name
    //
    } else if ( pbuc->liStreamOffset < pbuc->cbHeader) {
        return TRUE ;

    //
    //  If there is more data in this stream to transfer
    //
    
    } else if ( (pbuc->head.dwStreamId == BACKUP_ALTERNATE_DATA) ||
                (pbuc->head.dwStreamId == BACKUP_SPARSE_BLOCK) ) {
    
        return BackupReadStream( pbuc->hAlternate, pbuc, pbif );
    
    }
    return TRUE;
}


BOOL
BackupReadEaData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from EA data.

Arguments:

    hFile - handle to file with EAs
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    //
    //  If we are just starting out on the EA data
    //
    
    if (pbuc->fStreamStart) {
        IO_STATUS_BLOCK iosb;

        //
        //  Loop trying to read all EA data into the buffer and
        //  resize the buffer if necessary
        //
        
        while (TRUE) {
            NTSTATUS Status;
            FILE_EA_INFORMATION fei;

            Status = NtQueryEaFile(
                        hFile,
                        &iosb,
                        pbuc->DataBuffer.Buffer,
                        pbuc->DataBuffer.BufferSize,
                        FALSE,
                        NULL,
                        0,
                        0,
                        (BOOLEAN) TRUE );
            
            //
            //  If we successfully read all the data, go complete
            //  the initialization
            //
            if (NT_SUCCESS( Status ) && iosb.Information != 0) {
                pbuc->NamesReady = TRUE;
                break;
            }

            //
            //  If we received a status OTHER than buffer overflow then
            //  skip EA's altogether
            //

            if (!BufferOverflow(Status)) {
                return TRUE;
            }

            //
            //  Get a stab at the total EA size 
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &iosb,
                        &fei,
                        sizeof(fei),
                        FileEaInformation);

            //
            //  This call should never have failed (since we were able to 
            //  QueryEaFile) above.  However, if it does, skip EAs altogether
            //
            
            if (!NT_SUCCESS(Status)) {
                return TRUE;
            }
            
            //
            //  Resize the buffer to something that seems reasonable.  No guarantees
            //  about whether this will work or not...  If we couldn't grow the buffer
            //  fail this call.
            //
            
            if (!GrowBuffer( &pbuc->DataBuffer, (fei.EaSize * 5) / 4)) {
                pbuc->fAccessError = TRUE;
                return FALSE;
            }
        }

        //
        //  Set up the header for the EA stream
        //
        
        pbuc->head.dwStreamId = BACKUP_EA_DATA;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        pbuc->head.Size.QuadPart = iosb.Information;

        pbuc->fStreamStart = FALSE;
    
    //
    //  If we have more data in the buffer to read then go
    //  copy it out.
    //
    
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        BackupReadBuffer( pbuc, pbif );
    }

    return TRUE;
}


BOOL
BackupReadObjectId(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from NtObject ID data.

Arguments:

    hFile - handle to file with EAs
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{
    //
    //  If we are just starting out on the Object ID data
    //
    
    if (pbuc->fStreamStart) {
        IO_STATUS_BLOCK iosb;
        NTSTATUS Status ;

        if (!GrowBuffer( &pbuc->DataBuffer, 1024 ) ) {
            pbuc->fAccessError = TRUE;
            return FALSE;
        }


        Status = NtFsControlFile( hFile,
                         NULL,  // overlapped event handle
                         NULL,  // Apc routine
                         NULL,  // overlapped structure
                         &iosb,
                         FSCTL_GET_OBJECT_ID,
                         NULL,
                         0,
                         pbuc->DataBuffer.Buffer,
                         pbuc->DataBuffer.BufferSize ) ;

        if ( !NT_SUCCESS(Status) ) {
             return TRUE ;
        }

        //
        //  Set up the header for the Object ID stream
        //

        pbuc->NamesReady = TRUE;
        
        pbuc->head.dwStreamId = BACKUP_OBJECT_ID ;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        pbuc->head.Size.QuadPart = iosb.Information;

        pbuc->fStreamStart = FALSE;
    
    //
    //  If we have more data in the buffer to read then go
    //  copy it out.
    //
    
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        BackupReadBuffer( pbuc, pbif );
    }

    return TRUE;
}


BOOL
BackupReadReparseData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    Perform a read to user buffer from Reparse tag data.

Arguments:

    hFile - handle to file with EAs
    
    pbuc - context of call
    
    pbif - frame describing BackupRead request

Return Value:

    True if transfer succeeded..

--*/
{

    IO_STATUS_BLOCK iosb;
    PREPARSE_DATA_BUFFER rp_buf_ptr ;
    NTSTATUS Status ;

    struct RP_SUMMARY {
           USHORT tag ;
           USHORT rp_size ;
    } *rp_summary_ptr =(struct RP_SUMMARY*) &(iosb.Information) ;


    //
    //  If the object is not a reparse then simply return
    //
    if ( !(pbuc->fAttribs & FILE_ATTRIBUTE_REPARSE_POINT) ) { 
         return TRUE ;
    }
 
    //
    //  If we are just starting out on the ReParse data
    //
    
    if (pbuc->fStreamStart) {

        //
        //  Loop trying to read all EA data into the buffer and
        //  resize the buffer if necessary
        //
     
        // for some reason a TOO_SMALL error is not setting the information
        //    member of the iosb....

        rp_summary_ptr->rp_size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE ;

        Status = NtFsControlFile( hFile,
                         NULL,  // overlapped event handle
                         NULL,  // Apc routine
                         NULL,  // overlapped structure
                         &iosb,
                         FSCTL_GET_REPARSE_POINT,
                         NULL,
                         0,
                         pbuc->DataBuffer.Buffer,
                         pbuc->DataBuffer.BufferSize ) ;


        if ( BufferOverflow( Status ) ) {
                    
            if ( rp_summary_ptr->rp_size == 0 ) {
                 rp_summary_ptr->rp_size = MAXIMUM_REPARSE_DATA_BUFFER_SIZE ;
            }

            if (!GrowBuffer( &pbuc->DataBuffer, 
                            rp_summary_ptr->rp_size ) ) {

                 pbuc->fAccessError = TRUE;
                 return FALSE;
            }

            Status = NtFsControlFile( hFile,
                             NULL,  // overlapped event handle
                             NULL,  // Apc routine
                             NULL,  // overlapped structure
                             &iosb,
                             FSCTL_GET_REPARSE_POINT,
                             NULL,
                             0,
                             pbuc->DataBuffer.Buffer,
                             pbuc->DataBuffer.BufferSize ) ;

        }

        //
        //  If we successfully read all the data, go complete
        //  the initialization
        //
        if ( !NT_SUCCESS( Status ) ) {
            return TRUE ;
        }


        //
        //  Set up the header for the ReParse stream
        //
        
        rp_buf_ptr = (PREPARSE_DATA_BUFFER)(pbuc->DataBuffer.Buffer) ;

        pbuc->NamesReady = TRUE;

        pbuc->head.dwStreamId = BACKUP_REPARSE_DATA;
        pbuc->head.dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        if ( IsReparseTagMicrosoft( rp_buf_ptr->ReparseTag ) ) {
             pbuc->head.Size.QuadPart = rp_buf_ptr->ReparseDataLength +
                                        FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) ;
        } else {
             pbuc->head.Size.QuadPart = rp_buf_ptr->ReparseDataLength +
                                        FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer.DataBuffer) ;
        }

        pbuc->fStreamStart = FALSE;
    
    //
    //  If we have more data in the buffer to read then go
    //  copy it out.
    //
    
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        BackupReadBuffer( pbuc, pbif );
    }

    return TRUE;
}



BOOL
BackupReadSecurityData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
{
    //
    //  If we are to skip security then do so.
    //
    
    if (!pbif->fProcessSecurity) {
        return TRUE;
    }

    //
    //  If we are just starting out on the security data
    //
    
    if (pbuc->fStreamStart) {
        
        //
        //  Loop trying to read all security data into the buffer and
        //  resize the buffer if necessary
        //
        
        while (TRUE) {
            NTSTATUS Status;
            DWORD cbSecurityInfo;

            RtlZeroMemory( pbuc->DataBuffer.Buffer, pbuc->DataBuffer.BufferSize );

            Status = NtQuerySecurityObject(
                        hFile,
                        OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION |
                            SACL_SECURITY_INFORMATION,
                        pbuc->DataBuffer.Buffer,
                        pbuc->DataBuffer.BufferSize,
                        &cbSecurityInfo );

            //
            //  If we failed but it wasn't due to buffer overflow
            //
            
            if (!NT_SUCCESS( Status ) && !BufferOverflow( Status )) {

                //
                //  Try reading everything but SACL
                //

                Status = NtQuerySecurityObject(
                            hFile,
                            OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                            pbuc->DataBuffer.Buffer,
                            pbuc->DataBuffer.BufferSize,
                            &cbSecurityInfo );
            }
            
            //
            //  If we got it all, then go continue initialization
            //

            if (NT_SUCCESS( Status )) {
                pbuc->NamesReady = TRUE;
                break;
            }


            //
            //  If not due to overflowing buffer, skip security altogether
            //
            
            if (!BufferOverflow( Status )) {
                return TRUE;
            }

            //
            //  Resize the buffer to the expected size.  If we fail, fail
            //  the entire call
            //

            if (!GrowBuffer( &pbuc->DataBuffer, cbSecurityInfo )) {
                return FALSE;
            }
        }

        //
        //  Initialize the stream header
        //

        pbuc->head.dwStreamId = BACKUP_SECURITY_DATA;
        pbuc->head.dwStreamAttributes = STREAM_CONTAINS_SECURITY;
        pbuc->head.dwStreamNameSize = 0;

        pbuc->cbHeader = CB_NAMELESSHEADER;

        pbuc->head.Size.QuadPart = RtlLengthSecurityDescriptor(pbuc->DataBuffer.Buffer);

        pbuc->fStreamStart = FALSE;
    
    //
    //  If there is more data in the buffer to transfer, go
    //  do it
    //
    } else if (pbuc->liStreamOffset >= pbuc->cbHeader) {
        
        BackupReadBuffer( pbuc, pbif );
    
    }
    
    return TRUE;
}



VOID
BackupTestRestartStream(BACKUPCONTEXT *pbuc)
{
    LONGLONG licbRemain;

    licbRemain = ComputeRemainingSize( pbuc );
    if (licbRemain == 0) {

        if ( pbuc->dwSparseMapOffset != pbuc->dwSparseMapSize ) {   // only true at backup

             if ( !pbuc->fSparseBlockStart ) {
                  pbuc->dwSparseMapOffset += sizeof ( FILE_ALLOCATED_RANGE_BUFFER ) ;
             }
        }

        if ( pbuc->dwSparseMapOffset != pbuc->dwSparseMapSize ) {   // only true at backup
             pbuc->fSparseBlockStart = TRUE ;

             pbuc->cbHeader = 0 ;
             pbuc->liStreamOffset = 0;                

        } else {
             if ( !pbuc->fSparseHandAlt && (pbuc->hAlternate != NULL)) {
                 CloseHandle(pbuc->hAlternate);        // releases any locks
                 pbuc->hAlternate = NULL;
             }
             pbuc->cbHeader = 0;
             pbuc->fStreamStart = TRUE;
             pbuc->fSparseBlockStart = TRUE;

             pbuc->liStreamOffset = 0;                // for BackupWrite

             if (!pbuc->fMultiStreamType) {                // for BackupRead
                 pbuc->StreamIndex++;
                 pbuc->head.dwStreamId = mwStreamList[pbuc->StreamIndex] ;
                 pbuc->NamesReady = FALSE;
             }
        }
    }
}



//  Routine Description:
//
//    Data can be Backed up from an object using BackupRead.
//
//    This API is used to read data from an object.  After the
//    read completes, the file pointer is adjusted by the number of bytes
//    actually read.  A return value of TRUE coupled with a bytes read of
//    0 indicates that end of file has been reached.
//
//  Arguments:
//
//    hFile - Supplies an open handle to a file that is to be read.  The
//          file handle must have been created with GENERIC_READ access.
//
//    lpBuffer - Supplies the address of a buffer to receive the data read
//          from the file.
//
//    nNumberOfBytesToRead - Supplies the number of bytes to read from the
//          file.
//
//    lpNumberOfBytesRead - Returns the number of bytes read by this call.
//          This parameter is always set to 0 before doing any IO or error
//          checking.
//
//    bAbort - If TRUE, then all resources associated with the context will
//          be released.
//
//    bProcessSecurity - If TRUE, then the NTFS ACL data will be read.
//          If FALSE, then the ACL stream will be skipped.
//
//    lpContext - Points to a buffer pointer setup and maintained by
//          BackupRead.
//
//
//  Return Value:
//
//    TRUE - The operation was successul.
//
//    FALSE - The operation failed.  Extended error status is available
//          using GetLastError.
//
//
// NOTE:
// The NT File Replication Service (NTFRS) performs an MD5 checksum on the 
// stream of data returned by BackupRead().  If the sequence of file information 
// returned changes then two machines, one downlevel and one uplevel will 
// compute different MD5 checksums for the same file data.  Under certain 
// conditions this will cause needless file replication.  Bear this in mind 
// if a change in the returned data sequence is contemplated.  The sources for
// NTFRS are in \nt\private\net\svcimgs\ntrepl.
// 

BOOL WINAPI
BackupRead(
    HANDLE  hFile,
    LPBYTE  lpBuffer,
    DWORD   nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL    bAbort,
    BOOL    bProcessSecurity,
    LPVOID  *lpContext)
{
    BACKUPCONTEXT *pbuc;
    BACKUPIOFRAME bif;
    BOOL fSuccess = FALSE;
    IO_STATUS_BLOCK iosb ;

    pbuc = *lpContext;
    bif.pIoBuffer = lpBuffer;
    bif.cbRequest = nNumberOfBytesToRead;
    bif.pcbTransferred = lpNumberOfBytesRead;
    bif.fProcessSecurity = (BOOLEAN)bProcessSecurity;

    if (bAbort) {
        if (pbuc != NULL) {
            ResetAccessDate( hFile ) ;
            FreeContext(lpContext);
        }
        return TRUE;
    }
    *bif.pcbTransferred = 0;

    if (pbuc == INVALID_HANDLE_VALUE || bif.cbRequest == 0) {
        return TRUE;
    }

    if (pbuc != NULL && mwStreamList[pbuc->StreamIndex] == BACKUP_INVALID) {
        ResetAccessDate( hFile ) ;
        FreeContext(lpContext);
        return TRUE;
    }

    // Allocate our Context Control Block on first call.

    if (pbuc == NULL) {
        pbuc = AllocContext(CBMIN_BUFFER);        // Alloc initial buffer

        // ok, we allocated the context, Lets initialize it.
        if (pbuc != NULL) {
            NTSTATUS Status ;
            FILE_BASIC_INFORMATION fbi;

            Status = NtQueryInformationFile(
                        hFile,
                        &iosb,
                        &fbi,
                        sizeof(fbi),
                        FileBasicInformation );

            if ( NT_SUCCESS( Status ) ) {
               pbuc->fAttribs = fbi.FileAttributes ;
            } else {
               BaseSetLastNTError( Status );
               return FALSE ;
            }

        }
          
    }

    if (pbuc != NULL) {
        *lpContext = pbuc;

        do {

            if (pbuc->fStreamStart) {
                pbuc->head.Size.QuadPart = 0;

                pbuc->liStreamOffset = 0;

                pbuc->dwSparseMapOffset = 0;
                pbuc->dwSparseMapSize   = 0;

                pbuc->fMultiStreamType = FALSE;
            }
            fSuccess = TRUE;

            switch (mwStreamList[pbuc->StreamIndex]) {
                case BACKUP_DATA:
                    fSuccess = BackupReadData(hFile, pbuc, &bif);
                    break;

                case BACKUP_ALTERNATE_DATA:
                    fSuccess = BackupReadAlternateData(hFile, pbuc, &bif);
                    break;

                case BACKUP_EA_DATA:
                    fSuccess = BackupReadEaData(hFile, pbuc, &bif);
                    break;

                case BACKUP_OBJECT_ID:
                    fSuccess = BackupReadObjectId(hFile, pbuc, &bif);
                    break;

                case BACKUP_REPARSE_DATA:
                    fSuccess = BackupReadReparseData(hFile, pbuc, &bif);
                    break;

                case BACKUP_SECURITY_DATA:
                    fSuccess = BackupReadSecurityData(hFile, pbuc, &bif);
                    break;

                default:
                    pbuc->StreamIndex++;
                    pbuc->fStreamStart = TRUE;
                    break;
            }

            // if we're in the phase of reading the header, copy the header

            if (pbuc->liStreamOffset < pbuc->cbHeader) {

                DWORD cbrequest;

                //  Send the current stream header;

                cbrequest = 
                    (ULONG)min( pbuc->cbHeader - pbuc->liStreamOffset,
                                bif.cbRequest);

                RtlCopyMemory(
                    bif.pIoBuffer,
                    (BYTE *) &pbuc->head + pbuc->liStreamOffset,
                    cbrequest);

                ReportTransfer(pbuc, &bif, cbrequest);
            }

            //
            // if we are at the end of a stream then
            //          start at the beginning of the next stream
            //

            if (pbuc->liStreamOffset >= pbuc->cbHeader) {
                 BackupTestRestartStream(pbuc);
            }

        } while (fSuccess &&
                 mwStreamList[pbuc->StreamIndex] != BACKUP_INVALID &&
                 bif.cbRequest != 0);
    }
    
    if (fSuccess && *bif.pcbTransferred == 0) {
        ResetAccessDate( hFile ) ;
        FreeContext(lpContext);
    }
    
    return(fSuccess);
}



//  Routine Description:
//
//    Data can be skiped during BackupRead or BackupWrite by using
//    BackupSeek.
//
//    This API is used to seek forward from the current position the
//    specified number of bytes.  This function does not seek over a
//    stream header.  The number of bytes actually seeked is returned.
//    If a caller wants to seek to the start of the next stream it can
//    pass 0xffffffff, 0xffffffff as the amount to seek.  The number of
//    bytes actually skiped over is returned.
//
//  Arguments:
//
//    hFile - Supplies an open handle to a file that is to be read.  The
//          file handle must have been created with GENERIC_READ or
//          GENERIC_WRITE access.
//
//    dwLowBytesToSeek - Specifies the low 32 bits of the number of bytes
//          requested to seek.
//
//    dwHighBytesToSeek - Specifies the high 32 bits of the number of bytes
//          requested to seek.
//
//    lpdwLowBytesSeeked - Points to the buffer where the low 32 bits of the
//          actual number of bytes to seek is to be placed.
//
//    lpdwHighBytesSeeked - Points to the buffer where the high 32 bits of the
//          actual number of bytes to seek is to be placed.
//
//    bAbort - If true, then all resources associated with the context will
//          be released.
//
//    lpContext - Points to a buffer pointer setup and maintained by
//          BackupRead.
//
//
//  Return Value:
//
//    TRUE - The operation successfuly seeked the requested number of bytes.
//
//    FALSE - The requested number of bytes could not be seeked. The number
//          of bytes actually seeked is returned.

BOOL WINAPI
BackupSeek(
    HANDLE  hFile,
    DWORD   dwLowBytesToSeek,
    DWORD   dwHighBytesToSeek,
    LPDWORD lpdwLowBytesSeeked,
    LPDWORD lpdwHighBytesSeeked,
    LPVOID *lpContext)
{
    BACKUPCONTEXT *pbuc;
    LONGLONG licbRemain;
    LARGE_INTEGER licbRequest;
    BOOL fSuccess;
    LARGE_INTEGER sparse_bytes ;

    pbuc = *lpContext;

    sparse_bytes.QuadPart = 0 ;

    *lpdwHighBytesSeeked = 0;
    *lpdwLowBytesSeeked = 0;

    if (pbuc == INVALID_HANDLE_VALUE || pbuc == NULL || pbuc->fStreamStart) {
        return FALSE;
    }

    if (pbuc->liStreamOffset < pbuc->cbHeader) {
        return FALSE;
    }

    //
    // If we made it here, we are in the middle of a stream
    //

    licbRemain = ComputeRemainingSize( pbuc );

    licbRequest.LowPart = dwLowBytesToSeek;
    licbRequest.HighPart = dwHighBytesToSeek & 0x7fffffff;

    if (licbRequest.QuadPart > licbRemain) {
        licbRequest.QuadPart = licbRemain;
    }
    fSuccess = TRUE;

    switch (pbuc->head.dwStreamId) {
    case BACKUP_EA_DATA:
    case BACKUP_SECURITY_DATA:
    case BACKUP_OBJECT_ID :
    case BACKUP_REPARSE_DATA :

        // assume less than 2gig of data

        break;

    case BACKUP_SPARSE_BLOCK :
         if ( pbuc->liStreamOffset < sizeof(LARGE_INTEGER) ) {
              sparse_bytes.QuadPart = ( sizeof(LARGE_INTEGER) - pbuc->liStreamOffset ) ;
              if ( sparse_bytes.QuadPart < licbRequest.QuadPart ) {
                  licbRequest.QuadPart -= sparse_bytes.QuadPart ;
              } else {
                  licbRequest.QuadPart = 0 ;
              }
         }
    case BACKUP_DATA:
    case BACKUP_ALTERNATE_DATA:
        {
            LARGE_INTEGER liCurPos;
            LARGE_INTEGER liNewPos;
            HANDLE hf;
    
            //        set up the correct handle to seek with
    
            if (pbuc->head.dwStreamId == BACKUP_DATA) {
                hf = hFile;
            }
            else {
                hf = pbuc->hAlternate;
            }
    
            // first, let's get the current position
    
            liCurPos.HighPart = 0;
            liCurPos.LowPart = SetFilePointer(
                    hf,
                    0,
                    &liCurPos.HighPart,
                    FILE_CURRENT);
    
            // Now seek the requested number of bytes
    
            liNewPos.HighPart = licbRequest.HighPart;
            liNewPos.LowPart = SetFilePointer(
                    hf,
                    licbRequest.LowPart,
                    &liNewPos.HighPart,
                    FILE_CURRENT);
    
            // Assume that we seek the requested amount because if we do not,
            // subsequent reads will fail and the caller will never be able
            // to read to the next stream.
    
            break;
        }

    default:
        break;
    }
    
    if (dwHighBytesToSeek != (DWORD) licbRequest.HighPart ||
        dwLowBytesToSeek != licbRequest.LowPart) {
        fSuccess = FALSE;
    }
    licbRequest.QuadPart += sparse_bytes.QuadPart ;
    pbuc->liStreamOffset += licbRequest.QuadPart ;

    *lpdwLowBytesSeeked = licbRequest.LowPart;
    *lpdwHighBytesSeeked = licbRequest.HighPart;

    BackupTestRestartStream(pbuc);

    if (!fSuccess) {
        SetLastError(ERROR_SEEK);
    }
    return(fSuccess);
}



BOOL
BackupWriteHeader(BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif, DWORD cbHeader)
/*++

Routine Description:

    This is an internal routine that fills our internal backup header
    from the user's data.

Arguments:

    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
    cbHeader - size of header to fill

Return Value:

    None.

--*/
{
    //
    //  Determine how much data we can transfer into our header.  
    //
    
    DWORD cbrequest = 
        (DWORD) min( pbif->cbRequest, cbHeader - pbuc->liStreamOffset );

    //
    //  Copy from user buffer into header
    //


    if ( pbuc->liStreamOffset+cbrequest > CWCMAX_STREAMNAME + CB_NAMELESSHEADER ) {
         return FALSE ;
    }

    RtlCopyMemory(
        (CHAR *) &pbuc->head + pbuc->liStreamOffset,
        pbif->pIoBuffer,
        cbrequest);

    //
    //  Update transfer statistics
    //
    
    ReportTransfer(pbuc, pbif, cbrequest);

    //
    //  If we've filled up the header, mark the header as complete
    //  even though we might need more if names are present
    //
    
    if (pbuc->liStreamOffset == cbHeader) {
        pbuc->cbHeader = cbHeader;
    }

    return TRUE ;
}



typedef enum {
    BRB_FAIL,
    BRB_DONE,
    BRB_MORE,
} BUFFERSTATUS;

BUFFERSTATUS
BackupWriteBuffer(BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that fills our internal buffer
    from the user's data.

Arguments:

    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    BRB_FAIL if an error occurred (out of memory)
    
    BRB_DONE if buffer is full or was successfully filled
    
    BRB_MORE if buffer is partially full

--*/
{
    DWORD cbrequest;

    //
    //  If we're starting out on the buffer, we make sure
    //  we have a buffer to contain all of the data since
    //  the Nt calls we'll use must have all the data 
    //  present
    //

    if (pbuc->fStreamStart) {
        pbuc->fStreamStart = FALSE;

        if (pbuc->DataBuffer.BufferSize < pbuc->head.Size.QuadPart &&
            !GrowBuffer( &pbuc->DataBuffer, pbuc->head.Size.LowPart )) {

            return(BRB_FAIL);
        }
    }

    //
    //  Determine how much data from the user buffer is
    //  needed to fill our buffer
    //
    
    cbrequest = ComputeRequestSize( pbuc, pbif->cbRequest );
    
    //
    //  Fill in the next portion of the buffer
    //
    
    RtlCopyMemory(
        pbuc->DataBuffer.Buffer + pbuc->liStreamOffset - pbuc->cbHeader,
        pbif->pIoBuffer,
        cbrequest);

    //
    //  Update transfer statistics
    //
    
    ReportTransfer(pbuc, pbif, cbrequest);

    //
    //  If we've entirely filled the buffer, let our caller know
    //
    
    return ComputeRemainingSize( pbuc ) == 0 ? BRB_DONE : BRB_MORE;
}


BOOL
BackupWriteSparse(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes sparse block of stream data from
    the user's buffer into the output handle.  The BACKUPCONTEXT contains
    the total length of data to be output.

Arguments:

    hFile - output file handle
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if data was successfully written, FALSE otherwise.

--*/
{
     LARGE_INTEGER licbFile ;
     DWORD cbrequest;
     DWORD cbtransferred;
     BOOL fSuccess;

     if ( pbuc->fSparseBlockStart ) {

         RtlCopyMemory( &pbuc->cbSparseOffset, pbuc->head.cStreamName, sizeof( LARGE_INTEGER ) ) ;

         licbFile = pbuc->cbSparseOffset;

         licbFile.LowPart = SetFilePointer( pbuc->fSparseHandAlt?pbuc->hAlternate:hFile,
                              licbFile.LowPart,
                              &licbFile.HighPart,
                              FILE_BEGIN );

         if ( licbFile.QuadPart != pbuc->cbSparseOffset.QuadPart ) {
            return FALSE ;
         }

         if ( pbuc->head.Size.QuadPart == sizeof( LARGE_INTEGER ) ) {
              SetEndOfFile(pbuc->fSparseHandAlt?pbuc->hAlternate:hFile) ;
         }    
         pbuc->fSparseBlockStart = FALSE ;
     }

     //
     //  Determine how much data from the user buffer is
     //  needed to be written into the stream and perform
     //  the transfer.
     //
     
     cbrequest = ComputeRequestSize(pbuc, pbif->cbRequest);

     fSuccess = WriteFile(
                     pbuc->fSparseHandAlt?pbuc->hAlternate:hFile,
                     pbif->pIoBuffer,
                     cbrequest,
                     &cbtransferred,
                     NULL);

     //
     //  Update transfer statistics
     //

     ReportTransfer(pbuc, pbif, cbtransferred);
     
     return(fSuccess);

     return TRUE ;
}


BOOL
BackupWriteStream(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes stream data from the user's
    buffer into the output handle.  The BACKUPCONTEXT contains the total
    length of data to be output.

Arguments:

    hFile - output file handle
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if data was successfully written, FALSE otherwise.

--*/
{
    DWORD cbrequest;
    DWORD cbtransferred;
    BOOL fSuccess;
    IO_STATUS_BLOCK iosb;


    if ( pbuc->fStreamStart ) {

       if  ( pbuc->head.dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE ) {

            // if it was sparse when be backed it up make is sparse again.
            NtFsControlFile( hFile,
              NULL,  // overlapped event handle
              NULL,  // Apc routine
              NULL,  // overlapped structure
              &iosb,
              FSCTL_SET_SPARSE ,
              NULL,
              0,
              NULL,
              0 ) ;

       } else {

              LARGE_INTEGER end_of_file ;

              end_of_file.QuadPart = pbuc->head.Size.QuadPart ;
              SetFilePointer( hFile,
                              end_of_file.LowPart,
                              &end_of_file.HighPart,
                              FILE_BEGIN );

              SetEndOfFile(hFile) ;

              end_of_file.QuadPart = 0 ;
              SetFilePointer( hFile,
                              end_of_file.LowPart,
                              &end_of_file.HighPart,
                              FILE_BEGIN );


       }

       pbuc->fStreamStart = FALSE;
    }

    //
    //  Determine how much data from the user buffer is
    //  needed to be written into the stream and perform
    //  the transfer.
    //
    
    cbrequest = ComputeRequestSize(pbuc, pbif->cbRequest);

    fSuccess = WriteFile(
                    hFile,
                    pbif->pIoBuffer,
                    cbrequest,
                    &cbtransferred,
                    NULL);

    //
    //  Update transfer statistics
    //
    
    ReportTransfer(pbuc, pbif, cbtransferred);
    
    return(fSuccess);
}



BOOL
BackupWriteAlternateData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that overwrites an alternate data stream with
    data from the user's buffer.  

Arguments:

    hFile - handle to the file itself.  This is not the handle to the stream
        being overwritten.
    
    pbuc - CONTEXT of call.  This contains the name of the stream.
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if data was successfully written, FALSE otherwise.

--*/
{
    //
    //  If we are just starting out on this stream then attempt to
    //  overwrite the new stream.
    //
    
    if (pbuc->fStreamStart) {
        NTSTATUS Status;
        UNICODE_STRING strName;
        OBJECT_ATTRIBUTES oa;
        IO_STATUS_BLOCK iosb;
        DWORD reparse_flg = 0 ;

        strName.Length = (USHORT) pbuc->head.dwStreamNameSize;
        strName.MaximumLength = strName.Length;
        strName.Buffer = pbuc->head.cStreamName;

        if (pbuc->hAlternate != INVALID_HANDLE_VALUE) {
             CloseHandle(pbuc->hAlternate);        
             pbuc->hAlternate = INVALID_HANDLE_VALUE;
             pbuc->fSparseHandAlt = FALSE ;
        }


        if (pbuc->fAttribs & FILE_ATTRIBUTE_REPARSE_POINT ) {
             reparse_flg = FILE_OPEN_REPARSE_POINT ;
        }

        InitializeObjectAttributes(
                &oa,
                &strName,
                OBJ_CASE_INSENSITIVE,
                hFile,
                NULL);

        Status = NtCreateFile(
                    &pbuc->hAlternate,
                    FILE_WRITE_DATA | SYNCHRONIZE,
                    &oa,
                    &iosb,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    FILE_OVERWRITE_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | reparse_flg,
                    NULL,
                    0L);

        //
        //  If we failed, map the error, record the failure, and return failure.
        //
        
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            pbuc->fAccessError = TRUE;
            return FALSE;
        }

        if ( pbuc->head.dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE ) {
           pbuc->fSparseHandAlt = TRUE ;

           // if it was sparse when be backed it up make is sparse again.
           NtFsControlFile( pbuc->hAlternate,
                  NULL,  // overlapped event handle
                  NULL,  // Apc routine
                  NULL,  // overlapped structure
                  &iosb,
                  FSCTL_SET_SPARSE ,
                  NULL,
                  0,
                  NULL,
                  0 ) ;
        }

        // don't reset stream start because WriteStream will do it.

    }

    //
    //  If we have no handle for the transfer, record this failure
    //  and return failure.
    //
    
    if (pbuc->hAlternate == INVALID_HANDLE_VALUE) {
        pbuc->fAccessError = TRUE;
        return FALSE;
    }
    
    //
    //  Let the normal stream copy perform the transfer
    //
    
    return BackupWriteStream( pbuc->hAlternate, pbuc, pbif );
}



BOOL
BackupWriteEaData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes EA data on the file from 
    the user's buffer

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if EA data was successfully written, FALSE otherwise.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer( pbuc, pbif )) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our EA data.  Set the
    //  EA data on the file.
    //
    
    Status = NtSetEaFile(
                hFile,
                &iosb,
                pbuc->DataBuffer.Buffer,
                pbuc->head.Size.LowPart );

    //
    //  If we failed, map the error and return failure
    //
    
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }
    
    return TRUE;
}


BOOL
BackupWriteReparseData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes Reparse data on the file from 
    the user's buffer

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if EA data was successfully written, FALSE otherwise.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;
    DWORD *rp_tag_ptr ;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer( pbuc, pbif )) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our Reparse data.  Set the
    //  Reparse data on the file.
    //


    rp_tag_ptr = (DWORD *)(pbuc->DataBuffer.Buffer) ;
    
    pbuc->fAttribs |= FILE_ATTRIBUTE_REPARSE_POINT ;


    Status = NtFsControlFile( hFile,
                     NULL,  // overlapped event handle
                     NULL,  // Apc routine
                     NULL,  // overlapped structure
                     &iosb,
                     FSCTL_SET_REPARSE_POINT,
                     pbuc->DataBuffer.Buffer,
                     pbuc->head.Size.LowPart,
                     NULL,
                     0 ) ;
    
    //
    //  If we failed, map the error and return failure
    //
    
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }
    
    return TRUE;
}


BOOL
BackupWriteObjectId(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that writes the Object IDa on the file from 
    the user's buffer. Birth ids are made reborn. i.e. the volume id component
    of the birth id is changed to the current volume's id, and the object id
    component of the birth id is changed to the current object id.

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if Object ID was successfully written, FALSE otherwise.

--*/
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS  Status ;
    FILE_FS_OBJECTID_INFORMATION fsobOID;
    GUID guidZero;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer( pbuc, pbif )) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    // Zero out the birth ID (the extended 48 bytes)
    //

    memset(&pbuc->DataBuffer.Buffer[sizeof(GUID)], 0, 3*sizeof(GUID));

    //
    //  Set the ID on the file.
    //
    
    Status = NtFsControlFile( hFile,
                     NULL,  // overlapped event handle
                     NULL,  // Apc routine
                     NULL,  // overlapped structure
                     &iosb,
                     FSCTL_SET_OBJECT_ID,
                     pbuc->DataBuffer.Buffer,
                     pbuc->head.Size.LowPart,
                     NULL,
                     0);


    //
    //  Ignore errors
    //

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
    }

    return( TRUE );
    
}




BOOL
BackupWriteSecurityData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that sets security information on the 
    file from data in the user's buffer.

Arguments:

    hFile - handle to output file
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if security was successfully written, FALSE otherwise.

--*/
{
    NTSTATUS Status;
    SECURITY_INFORMATION si;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer(pbuc, pbif)) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our security data.  If we 
    //  are to ignore it, then return success
    //
    
    if (!pbif->fProcessSecurity) {
        return TRUE;
    }
    
    //  
    //  Find out what security information is present so we know what to 
    //  set.

    si = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION;

    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_DACL_PRESENT) {
        si |= DACL_SECURITY_INFORMATION;
    }

    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_SACL_PRESENT) {
        si |= SACL_SECURITY_INFORMATION;
    }

    //
    // If the security descriptor has AUTO_INHERITED set, set the appropriate REQ bits.
    //
    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_DACL_AUTO_INHERITED) {
        ((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if (((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control & SE_SACL_AUTO_INHERITED) {
        ((PISECURITY_DESCRIPTOR) pbuc->DataBuffer.Buffer)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }
    
    Status = NtSetSecurityObject( hFile, si, pbuc->DataBuffer.Buffer );

    if (!NT_SUCCESS( Status )) {

        NTSTATUS Status2;

        //
        //  If that didn't work, the caller is probably not running as Backup
        //  Operator, so we can't set the owner and group.  Keep the current
        //  status code, and attempt to set the DACL and SACL while ignoring
        //  failures.
        //

        if (si & SACL_SECURITY_INFORMATION) {
            NtSetSecurityObject(
                        hFile,
                        SACL_SECURITY_INFORMATION,
                        pbuc->DataBuffer.Buffer );
        }

        if (si & DACL_SECURITY_INFORMATION) {
            Status = NtSetSecurityObject(
                            hFile,
                            DACL_SECURITY_INFORMATION,
                            pbuc->DataBuffer.Buffer);
        }

        Status2 = NtSetSecurityObject(
                            hFile,
                            OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION,
                            pbuc->DataBuffer.Buffer);

        if (NT_SUCCESS(Status)) {
            Status = Status2;
        }
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    
    return TRUE;
}



BOOL
BackupWriteLinkData(HANDLE hFile, BACKUPCONTEXT *pbuc, BACKUPIOFRAME *pbif)
/*++

Routine Description:

    This is an internal routine that establishes links based on the
    user's data.

Arguments:

    hFile - handle of file being restored
    
    pbuc - CONTEXT of call
    
    pbif - IOCONTEXT of call
    
Return Value:

    TRUE if link was successfully established, FALSE otherwise.

--*/
{
    FILE_LINK_INFORMATION *pfli;
    WCHAR *pwc;
    WCHAR *pwcSlash;
    INT cbName;
    INT cSlash;
    WCHAR wcSave;
    BOOL fSuccess;

    //
    //  Attempt to fill up the buffer from the input.
    //
    
    switch (BackupWriteBuffer(pbuc, pbif)) {
    default:
    case BRB_FAIL:
        return FALSE;

    case BRB_MORE:
        return TRUE;

    case BRB_DONE:
        break;
    }

    //
    //  The buffer is now completely filled with our link data.  
    //  Find the last component of the name.
    //
    
    cSlash = 0;
    pwcSlash = NULL;
    pwc = (WCHAR *) pbuc->DataBuffer.Buffer;
    cbName = sizeof(WCHAR);

    while (*pwc != L'\0') {
        if (*pwc == L'\\') {
            pwcSlash = pwc;
            cSlash++;
            cbName = 0;
        }
        pwc++;
        cbName += sizeof(WCHAR);
    }

    pfli = BackupAlloc( sizeof(*pfli) + cbName );

    if (pfli == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RtlCopyMemory( pfli->FileName, pwcSlash + 1, cbName );
    pfli->FileNameLength = cbName - sizeof(WCHAR);
    if (cSlash > 1) {
        wcSave = L'\\';
    }
    else {
        wcSave = *pwcSlash++;
    }
    *pwcSlash = L'\0';

    //
    //  Open the parent of the link target
    //
    
    pfli->RootDirectory = CreateFileW(
        (WCHAR *) pbuc->DataBuffer.Buffer,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL| FILE_FLAG_BACKUP_SEMANTICS,
        NULL );

    *pwcSlash = wcSave;
    pfli->ReplaceIfExists = TRUE;

    fSuccess = TRUE;

    if (pfli->RootDirectory == INVALID_HANDLE_VALUE) {
        SetLastError( ERROR_FILE_NOT_FOUND );
        fSuccess = FALSE;
    }
    else {
        NTSTATUS Status;
        IO_STATUS_BLOCK iosb;

        Status = NtSetInformationFile(
                    hFile,
                    &iosb,
                    pfli,
                    sizeof(*pfli) + cbName,
                    FileLinkInformation );

        CloseHandle( pfli->RootDirectory );
        pfli->RootDirectory = INVALID_HANDLE_VALUE;
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            fSuccess = FALSE;
        } else {
            if (iosb.Information == FILE_OVERWRITTEN) {
                SetLastError( ERROR_ALREADY_EXISTS );
            } else {
                SetLastError( 0 );
            }
        }
    }
    
    BackupFree( pfli );
    
    return fSuccess;
}



//  Routine Description:
//
//    Data can be written to a file using BackupWrite.
//
//    This API is used to Restore data to an object.  After the
//    write completes, the file pointer is adjusted by the number of bytes
//    actually written.
//
//    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
//    or extend the file.  If this function is required, SetEndOfFile
//    should be used.
//
//  Arguments:
//
//    hFile - Supplies an open handle to a file that is to be written.  The
//          file handle must have been created with GENERIC_WRITE access to
//          the file.
//
//    lpBuffer - Supplies the address of the data that is to be written to
//          the file.
//
//    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
//          file. Unlike DOS, a value of zero is interpreted a null write.
//
//    lpNumberOfBytesWritten - Returns the number of bytes written by this
//          call. Before doing any work or error processing, the API sets this
//          to zero.
//
//    bAbort - If true, then all resources associated with the context will
//          be released.
//
//    bProcessSecurity - If TRUE, then the NTFS ACL data will be written.
//          If FALSE, then the ACL stream will be ignored.
//
//    lpContext - Points to a buffer pointer setup and maintained by
//          BackupRead.
//
//
//  Return Value:
//
//    TRUE - The operation was a success.
//
//    FALSE - The operation failed.  Extended error status is
//          available using GetLastError.

BOOL WINAPI
BackupWrite(
    HANDLE  hFile,
    LPBYTE  lpBuffer,
    DWORD   nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL    bAbort,
    BOOL    bProcessSecurity,
    LPVOID  *lpContext)
{
    BACKUPCONTEXT *pbuc;
    BACKUPIOFRAME bif;
    BOOL fSuccess = FALSE;

    pbuc = *lpContext;
    bif.pIoBuffer = lpBuffer;
    bif.cbRequest = nNumberOfBytesToWrite;
    bif.pcbTransferred = lpNumberOfBytesWritten;
    bif.fProcessSecurity = (BOOLEAN)bProcessSecurity;

    //
    // Allocate our Context Control Block on first call.
    //

    if (bAbort) {
        if (pbuc != NULL) {
            FreeContext(lpContext);
        }
        return TRUE;
    }

    *bif.pcbTransferred = 0;
    if (pbuc == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    // Allocate our Context Control Block on first call.

    if (pbuc == NULL) {
        pbuc = AllocContext(0);                        // No initial buffer

        //
        //  If we have no space then return failure
        //
        
        if (pbuc == NULL) {
            return FALSE;           
        }

    }

    *lpContext = pbuc;

    do {
        DWORD cbrequest;
        LONGLONG licbRemain;

        //
        //  If we do not have a complete header, go
        //  fill it in.
        //
        
        if (pbuc->cbHeader == 0) {

            pbuc->fMultiStreamType = TRUE ;    //restore does not auto inc stream index.
            pbuc->fStreamStart = TRUE ;

            BackupWriteHeader(pbuc, &bif, CB_NAMELESSHEADER) ;

        }

        //
        //  If no more data, then exit
        //
        
        if (bif.cbRequest == 0) {
            return TRUE;
        }

        //
        //  If a stream name was expected, go read it in
        //
        
        if (pbuc->cbHeader == CB_NAMELESSHEADER &&
            pbuc->head.dwStreamNameSize != 0) {

            if ( !BackupWriteHeader(
                    pbuc,
                    &bif,
                    pbuc->cbHeader + pbuc->head.dwStreamNameSize) )
            {
                 SetLastError( ERROR_INVALID_DATA );
                 return FALSE ;
            }

            //
            //  If no more data then exit
            //
            
            if (bif.cbRequest == 0) {
                return TRUE;
            }
        } 

     
        if ( ( pbuc->cbHeader == CB_NAMELESSHEADER ) &&
             ( pbuc->head.dwStreamId == BACKUP_SPARSE_BLOCK ) ) {
      
            BackupWriteHeader(
                pbuc,
                &bif,
                pbuc->cbHeader + sizeof(LARGE_INTEGER) );

            //
            //  If no more data then exit
            //
            
            if (bif.cbRequest == 0) {

               if ( pbuc->cbHeader == CB_NAMELESSHEADER ) {
                   return TRUE;
               }
            }
        }
        
        //
        //  Determine amount of data remaining in user buffer
        //  that can be transferred as part of this section
        //  of the backup stream
        //

        cbrequest = ComputeRequestSize(pbuc, bif.cbRequest);

        //
        //  Determine total amount of data left in this section
        //  of backup stream.
        //
        
        licbRemain = ComputeRemainingSize( pbuc );

        //
        //  If we had an error in the transfer and we're done
        //  doing the transfer then pretend that we successfully 
        //  completed the section.
        //
        
        if (pbuc->fAccessError && licbRemain == 0) {

            ReportTransfer(pbuc, &bif, cbrequest);
            continue;
        }
        
        //
        //  Begin or continue the transfer of data.  We assume that there
        //  are no errors
        //
        
        pbuc->fAccessError = FALSE;

        switch (pbuc->head.dwStreamId) {

        case BACKUP_SPARSE_BLOCK :
            fSuccess = BackupWriteSparse( hFile, pbuc, &bif ) ;
            break ;

        case BACKUP_DATA:
            fSuccess = BackupWriteStream( hFile, pbuc, &bif );
            break;

        case BACKUP_ALTERNATE_DATA:
            fSuccess = BackupWriteAlternateData( hFile, pbuc, &bif );
            break;

        case BACKUP_EA_DATA:
            fSuccess = BackupWriteEaData( hFile, pbuc, &bif );
            break;

        case BACKUP_OBJECT_ID:
            fSuccess = BackupWriteObjectId( hFile, pbuc, &bif );
            break;

        case BACKUP_REPARSE_DATA:
            fSuccess = BackupWriteReparseData( hFile, pbuc, &bif );
            break;

        case BACKUP_SECURITY_DATA:
            fSuccess = BackupWriteSecurityData( hFile, pbuc, &bif );
            break;

        case BACKUP_LINK:
            fSuccess = BackupWriteLinkData( hFile, pbuc, &bif );
            break;

        default:
            SetLastError(ERROR_INVALID_DATA);
            fSuccess = FALSE;
            break;
        }

        BackupTestRestartStream(pbuc);
    } while (fSuccess && bif.cbRequest != 0);

    if (fSuccess && *bif.pcbTransferred == 0) {
        FreeContext(lpContext);
    }
    
    return(fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\alignstr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    alignstr.c

Abstract:

    This module implements a number of UNICODE string routines.  These
    routines are equivalent to the corresponding C runtime routines
    with the exception that they can handle unaligned parameters.

Author:

    Forrest Foltz (forrestf) 1-Jan-2000

Revision History:

--*/


#include "basedll.h"

#if !defined(_X86_)

//
// These routines are not intended to be called directly from source,
// rather they are worker functions designed to be called from corresponding
// inlines in alignstr.h.
//
// alignstr.h will never reference these routines on an x86 platform.
//

//++
//
// PUWSTR
// __cdecl
// uaw_wcschr(
//     IN PCUWSTR String,
//     IN WCHAR   Character
//     )
//
// Routine Description:
//
//    Searches String for the first occurence of Character.
//
// Arguments:
//
//    String - Supplies an unaligned pointer to the null-terminated UNICODE
//             string to search.
//
//    Character - Supplies the UNICODE character to search for.
//
// Return Value:
//
//    Returns an unaligned pointer to the first matching character within String
//    if found, or NULL if no match was located.
//
//--

PUWSTR
__cdecl
uaw_wcschr(
    IN PCUWSTR String,
    IN WCHAR   Character
    )
{
    PUWSTR pch;

    //
    // Search the whole string looking for the first matching character.
    // Note that the search INCLUDES the terminating null character.
    //

    pch = (PUWSTR)String;
    while (TRUE) {

        if (*pch == Character) {
            return pch;
        }

        if (*pch == 0) {
            return NULL;
        }
        pch++;
    }
}

//++
//
// PUWSTR
// __cdecl
// uaw_wcscpy(
//     IN PUWSTR  Destination,
//     IN PCUWSTR Source
//     )
//
// Routine Description:
//
//    Copies a null-terminated UNICODE string.
//
// Arguments:
//
//    Destination - Supplies a possibly unaligned pointer to the destination
//                  of the copy.
//
//    Source - Supplies a possibly unaligned pointer to the UNICODE string
//             to be copied.
//
// Return Value:
//
//    Returns a possibly unaligned pointer to the destination of the copy.
//
//--

PUWSTR
_cdecl
uaw_wcscpy(
    IN PUWSTR  Destination,
    IN PCUWSTR Source
    )
{
    PCUWSTR src;
    PUWSTR dst;

    src = Source;
    dst = Destination;

    while (TRUE) {

        *dst = *src;
        if (*src == 0) {
            return Destination;
        }

        dst++;
        src++;
    }
}

//++
//
// size_t
// __cdecl
// uaw_wcslen(
//     IN PCUWSTR String
//     )
//
// Routine Description:
//
//    Determines the number of characters within a null-terminated UNICODE
//    string, excluding the null-terminator.
//
// Arguments:
//
//    String - Supplies an unaligned pointer to the null-terminated UNICODE
//             string.
//
// Return Value:
//
//    Returns the number of characters within String.
//
//--

size_t
__cdecl
uaw_wcslen(
    IN PCUWSTR String
    )
{
    PCUWSTR pch;
    
    pch = String;
    while (*pch != 0) {
        pch++;
    }
    return pch - String;
}

//++
//
// PUWSTR
// __cdecl
// uaw_wcsrchr(
//     IN PCUWSTR String,
//     IN WCHAR   Character
//     )
//
// Routine Description:
//
//    Searches String for the last occurence of Character.
//
// Arguments:
//
//    String - Supplies an unaligned pointer to the null-terminated UNICODE
//             string to search.
//
//    Character - Supplies the UNICODE character to search for.
//
// Return Value:
//
//    Returns an unaligned pointer to the last matching character within String
//    if found, or NULL if no match was located.
//
//--

PUWSTR
__cdecl
uaw_wcsrchr(
    IN PCUWSTR String,
    IN WCHAR   Character
    )
{
    PCUWSTR pch;
    PUWSTR lastMatch;

    lastMatch = NULL;
    pch = String;

    //
    // Search the whole string looking for the last matching character.
    // Note that the search INCLUDES the terminating null character.
    //

    while (TRUE) {
        if (*pch == Character) {

            //
            // Found either the first match or a new match closer to the end,
            // record its position.
            //

            lastMatch = (PUWSTR)pch;
        }

        if (*pch == 0) {
            return lastMatch;
        }
        pch++;
    }
}

int
APIENTRY
uaw_lstrcmpW(
    PCUWSTR String1,
    PCUWSTR String2
    )
{
    PCWSTR alignedString1;
    PCWSTR alignedString2;

    //
    // Create aligned copies of these strings and pass to the real
    // function.
    //

    WSTR_ALIGNED_STACK_COPY( &alignedString1, String1 );
    WSTR_ALIGNED_STACK_COPY( &alignedString2, String2 );

    return lstrcmpW( alignedString1, alignedString2 );
}

int
APIENTRY
uaw_lstrcmpiW(
    PCUWSTR String1,
    PCUWSTR String2
    )
{
    PCWSTR alignedString1;
    PCWSTR alignedString2;

    //
    // Create aligned copies of these strings and pass to the real
    // function.
    //

    WSTR_ALIGNED_STACK_COPY( &alignedString1, String1 );
    WSTR_ALIGNED_STACK_COPY( &alignedString2, String2 );

    return lstrcmpiW( alignedString1, alignedString2 );
}

int
APIENTRY
uaw_lstrlenW(
    LPCUWSTR lpString
    )
{
    if (!lpString)
        return 0;
    __try {
        return uaw_wcslen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}


#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\baseinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    baseinit.c

Abstract:

    This module implements Win32 base initialization

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

//
// Divides by 10000
//

BOOLEAN BaseRunningInServerProcess;
UINT_PTR SystemRangeStart;

#if defined(_WIN64) || defined(BUILD_WOW6432)
SYSTEM_BASIC_INFORMATION SysInfo;
#endif

WCHAR BaseDefaultPathBuffer[ 3072 ];

WCHAR PsapiDllString[] = L"psapi.dll";

ULONG
GetPerUserWindowsDirectory(PWCHAR TermSrvWindowsPath, ULONG len);

//
//  Dispatch functions for Oem/Ansi sensitive conversions
//

NTSTATUS (*Basep8BitStringToUnicodeString)(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    ) = RtlAnsiStringToUnicodeString;

NTSTATUS (*BasepUnicodeStringTo8BitString)(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    ) = RtlUnicodeStringToAnsiString;

ULONG (*BasepUnicodeStringTo8BitSize)(
    PUNICODE_STRING UnicodeString
    ) = BasepUnicodeStringToAnsiSize;

ULONG (*Basep8BitStringToUnicodeSize)(
    PANSI_STRING AnsiString
    ) = BasepAnsiStringToUnicodeSize;


VOID
WINAPI
SetFileApisToOEM(
    VOID
    )
{
    Basep8BitStringToUnicodeString = RtlOemStringToUnicodeString;
    BasepUnicodeStringTo8BitString = RtlUnicodeStringToOemString;
    BasepUnicodeStringTo8BitSize  = BasepUnicodeStringToOemSize;
    Basep8BitStringToUnicodeSize = BasepOemStringToUnicodeSize;
}

VOID
WINAPI
SetFileApisToANSI(
    VOID
    )
{
    Basep8BitStringToUnicodeString = RtlAnsiStringToUnicodeString;
    BasepUnicodeStringTo8BitString = RtlUnicodeStringToAnsiString;
    BasepUnicodeStringTo8BitSize  = BasepUnicodeStringToAnsiSize;
    Basep8BitStringToUnicodeSize = BasepAnsiStringToUnicodeSize;
}

BOOL
WINAPI
AreFileApisANSI(
    VOID
    )
{
    return Basep8BitStringToUnicodeString == RtlAnsiStringToUnicodeString;
}

BOOLEAN
ConDllInitialize(
    IN ULONG Reason,
    IN PWSTR pObjectDirectory OPTIONAL
    );

BOOLEAN
NlsDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PBASE_STATIC_SERVER_DATA BaseStaticServerData
    );

BOOLEAN
NlsThreadCleanup(void);


#if DBG
VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    );
#endif

UNICODE_STRING BasePathVariableName = RTL_CONSTANT_STRING(L"PATH");
UNICODE_STRING BaseUserProfileVariableName = RTL_CONSTANT_STRING(L"USERPROFILE");
UNICODE_STRING BaseTmpVariableName = RTL_CONSTANT_STRING(L"TMP");
UNICODE_STRING BaseTempVariableName = RTL_CONSTANT_STRING(L"TEMP");
UNICODE_STRING BaseDotVariableName = RTL_CONSTANT_STRING(L".");
UNICODE_STRING BaseDotTmpSuffixName = RTL_CONSTANT_STRING(L".tmp");
UNICODE_STRING BaseDotComSuffixName = RTL_CONSTANT_STRING(L".com");
UNICODE_STRING BaseDotPifSuffixName = RTL_CONSTANT_STRING(L".pif");
UNICODE_STRING BaseDotExeSuffixName = RTL_CONSTANT_STRING(L".exe");

UNICODE_STRING BaseConsoleInput = RTL_CONSTANT_STRING(L"CONIN$");
UNICODE_STRING BaseConsoleOutput = RTL_CONSTANT_STRING(L"CONOUT$");
UNICODE_STRING BaseConsoleGeneric = RTL_CONSTANT_STRING(L"CON");

BOOLEAN
BaseDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function implements Win32 base dll initialization.
    It's primary purpose is to create the Base heap.

Arguments:

    DllHandle - Saved in BaseDllHandle global variable

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/

{
    BOOLEAN Success;
    NTSTATUS Status;
    PPEB Peb;
    LPWSTR p, p1;
    BOOLEAN ServerProcess;
    HANDLE hNlsCacheMutant;
    USHORT Size;
#if !defined(BUILD_WOW6432)
    ULONG SizeMutant;
#endif
    WCHAR szSessionDir[MAX_SESSION_PATH];


    SessionId = NtCurrentPeb()->SessionId;

    BaseDllHandle = DllHandle;

    Success = TRUE;

    Peb = NtCurrentPeb();

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        Basep8BitStringToUnicodeString = RtlAnsiStringToUnicodeString;

        RtlSetThreadPoolStartFunc( BaseCreateThreadPoolThread,
                                   BaseExitThreadPoolThread );

        LdrSetDllManifestProber(&BasepProbeForDllManifest);

        BaseDllTag = RtlCreateTagHeap( RtlProcessHeap(),
                                       0,
                                       L"BASEDLL!",
                                       L"TMP\0"
                                       L"BACKUP\0"
                                       L"INI\0"
                                       L"FIND\0"
                                       L"GMEM\0"
                                       L"LMEM\0"
                                       L"ENV\0"
                                       L"RES\0"
                                       L"VDM\0"
                                     );

        BaseIniFileUpdateCount = 0;

        BaseDllInitializeMemoryManager();

        RtlInitUnicodeString( &BaseDefaultPath, NULL );

        //
        // Connect to BASESRV.DLL in the server process
        //

#if !defined(BUILD_WOW6432)
        SizeMutant = sizeof(hNlsCacheMutant);
#endif

        if ( SessionId == 0 ) {
           //
           // Console Session
           //
           wcscpy(szSessionDir, WINSS_OBJECT_DIRECTORY_NAME);
        } else {
           swprintf(szSessionDir,L"%ws\\%ld%ws",SESSION_ROOT,SessionId,WINSS_OBJECT_DIRECTORY_NAME);
        }

#if defined(BUILD_WOW6432) || defined(_WIN64)
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &SysInfo,
                                          sizeof(SYSTEM_BASIC_INFORMATION),
                                          NULL
                                         );

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

#endif

#if defined(BUILD_WOW6432)
        Status = CsrBaseClientConnectToServer(szSessionDir,
                                              &hNlsCacheMutant,
                                              &ServerProcess
                                             );
#else
        Status = CsrClientConnectToServer( szSessionDir,
                                           BASESRV_SERVERDLL_INDEX,
                                           &hNlsCacheMutant,
                                           &SizeMutant,
                                           &ServerProcess
                                         );
#endif

        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }

        BaseStaticServerData = BASE_SHARED_SERVER_DATA;

        if (!ServerProcess) {
            CsrNewThread();
            BaseRunningInServerProcess = FALSE;
            }
        else {
            BaseRunningInServerProcess = TRUE;
            }

        BaseCSDVersion = BaseStaticServerData->CSDVersion;
        BaseCSDNumber = BaseStaticServerData->CSDNumber;
        BaseRCNumber = BaseStaticServerData->RCNumber;
        if ((BaseCSDVersion) &&
            (!Peb->CSDVersion.Buffer)) {

            RtlInitUnicodeString(&Peb->CSDVersion, BaseCSDVersion);

        }

        BASE_SERVER_STR_TO_LOCAL_STR(&BaseWindowsDirectory, &BaseStaticServerData->WindowsDirectory);
        BASE_SERVER_STR_TO_LOCAL_STR(&BaseWindowsSystemDirectory, &BaseStaticServerData->WindowsSystemDirectory);

#ifdef WX86
        BASE_SERVER_STR_TO_LOCAL_STR(&BaseWindowsSys32x86Directory, &BaseStaticServerData->WindowsSys32x86Directory);
#endif
        BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
        Status = RtlUnicodeStringToAnsiString(
                    &BaseAnsiCommandLine,
                    &BaseUnicodeCommandLine,
                    TRUE
                    );
        if ( !NT_SUCCESS(Status) ){
            BaseAnsiCommandLine.Buffer = NULL;
            BaseAnsiCommandLine.Length = 0;
            BaseAnsiCommandLine.MaximumLength = 0;
            }

        p = BaseDefaultPathBuffer;

        p1 = BaseWindowsSystemDirectory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';

#ifdef WX86

        //
        // Wx86 system dir follows 32 bit system dir
        //

        p1 = BaseWindowsSys32x86Directory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';
#endif


        //
        // 16bit system directory follows 32bit system directory
        //
        p1 = BaseWindowsDirectory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        p1 = L"\\system";
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';

        p1 = BaseWindowsDirectory.Buffer;
        while( *p = *p1++) {
            p++;
            }
        *p++ = L';';

        if (IsTerminalServer()) {

           WCHAR TermSrvWindowsPath[MAX_PATH];
           if (GetPerUserWindowsDirectory(TermSrvWindowsPath, MAX_PATH)) {
              p1 = TermSrvWindowsPath;
              while( *p = *p1++) {
                  p++;
                  }
              *p++ = L';';
           }
        }

        *p = UNICODE_NULL;

        BaseDefaultPath.Buffer = BaseDefaultPathBuffer;
        BaseDefaultPath.Length = (USHORT)((ULONG_PTR)p - (ULONG_PTR)BaseDefaultPathBuffer);
        BaseDefaultPath.MaximumLength = sizeof( BaseDefaultPathBuffer );

        BaseDefaultPathAppend.Buffer = p;
        BaseDefaultPathAppend.Length = 0;
        BaseDefaultPathAppend.MaximumLength = (USHORT)
            (BaseDefaultPath.MaximumLength - BaseDefaultPath.Length);

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&BaseDllDirectoryLock))) {
           return FALSE;
        }

        BaseDllInitializeIniFileMappings( BaseStaticServerData );


        if ( Peb->ProcessParameters ) {
            if ( Peb->ProcessParameters->Flags & RTL_USER_PROC_PROFILE_USER ) {

                LoadLibraryW(PsapiDllString);

                }

            if (Peb->ProcessParameters->DebugFlags) {
                DbgBreakPoint();
                }
            }

        //
        // call the NLS API initialization routine
        //
        if ( !NlsDllInitialize( DllHandle,
                                Reason,
                                BaseStaticServerData ) )
        {
            return FALSE;
        }

        //
        // call the console initialization routine
        //
        if ( !ConDllInitialize(Reason,szSessionDir) ) {
            return FALSE;
            }


        InitializeListHead( &BasepAppCertDllsList );

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&gcsAppCert))) {
           return FALSE;
        }

        if (!NT_SUCCESS(RtlInitializeCriticalSection(&gcsAppCompat))) {
           return(FALSE);
        }


#if DBG

        AssertDelayLoadFailureMapsAreSorted ();
#endif

        break;

    case DLL_PROCESS_DETACH:

        //
        // Make sure any open registry keys are closed.
        //

        if (BaseIniFileUpdateCount != 0) {
            WriteProfileStringW( NULL, NULL, NULL );
            }

        break;

    case DLL_THREAD_ATTACH:
        //
        // call the console initialization routine
        //
        if ( !ConDllInitialize(Reason,NULL) ) {
            return FALSE;
            }
        break;

    case DLL_THREAD_DETACH:

        //
        // Delete the thread NLS cache, if exists.
        //
        NlsThreadCleanup();

        break;

    default:
        break;
    }

    return Success;
}

NTSTATUS
NTAPI
BaseProcessInitPostImport()
/*

    Routine Description:

        Called by the ntdll process initialization code after all of the
        import tables for the static imports of the EXE have been processed,
        but before any DLL_PROCESS_ATTACHes are sent with the exception of
        kernel32.dll's.

        Needed for the terminal server app compat hooks.


*/
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;

    //
    // Intialize TerminalServer(Hydra) hook function pointers for app compatibility
    //
    if (IsTerminalServer())
        InitializeTermsrvFpns();

    Status = STATUS_SUCCESS;
// Exit:
    return Status;
}


HANDLE
BaseGetNamedObjectDirectory(
    VOID
    )
{
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    UNICODE_STRING RestrictedObjectDirectory;
    ACCESS_MASK DirAccess = DIRECTORY_ALL_ACCESS &
                            ~(DELETE | WRITE_DAC | WRITE_OWNER);
    HANDLE hRootNamedObject;
    HANDLE BaseHandle;


    if ( BaseNamedObjectDirectory != NULL) {
        return BaseNamedObjectDirectory;
    }

    RtlAcquirePebLock();

    if ( !BaseNamedObjectDirectory ) {

        BASE_READ_REMOTE_STR_TEMP(TempStr);
        InitializeObjectAttributes( &Obja,
                                    BASE_READ_REMOTE_STR(BaseStaticServerData->NamedObjectDirectory, TempStr),
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );

        Status = NtOpenDirectoryObject( &BaseHandle,
                                        DirAccess,
                                        &Obja
                                      );

        // if the intial open failed, try again with just traverse, and
        // open the restricted subdirectory

        if ( !NT_SUCCESS(Status) ) {
            Status = NtOpenDirectoryObject( &hRootNamedObject,
                                            DIRECTORY_TRAVERSE,
                                            &Obja
                                          );
            if ( NT_SUCCESS(Status) ) {
                RtlInitUnicodeString( &RestrictedObjectDirectory, L"Restricted");

                InitializeObjectAttributes( &Obja,
                                            &RestrictedObjectDirectory,
                                            OBJ_CASE_INSENSITIVE,
                                            hRootNamedObject,
                                            NULL
                                            );
                Status = NtOpenDirectoryObject( &BaseHandle,
                                                DirAccess,
                                                &Obja
                                              );
                NtClose( hRootNamedObject );
            }

        }
        if ( NT_SUCCESS(Status) ) {
            BaseNamedObjectDirectory = BaseHandle;
        }
    }
    RtlReleasePebLock();
    return BaseNamedObjectDirectory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\basedll.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basedll.h

Abstract:

    This module contains private function prototypes
    and types for the 32-bit windows base APIs.

Author:

    Mark Lucovsky (markl) 18-Sep-1990

Revision History:

--*/

#ifndef _BASEP_
#define _BASEP_
#if _MSC_VER > 1000
#pragma once
#endif

#undef UNICODE
//
// Include Common Definitions.
//

#include <base.h>
#include <dbt.h>

#include <sxstypes.h>

//
// Include DLL definitions for CSR
//

#include "ntcsrdll.h"
#include "ntcsrsrv.h"

#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>

//
// Include message definitions for communicating between client and server
// portions of the Base portion of the Windows subsystem
//

#include "basemsg.h"
#include "winuserp.h"
#include "basesxs.h"

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;

typedef struct _LOAD_MODULE_PARAMS {
    LPVOID lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

typedef struct _RELATIVE_NAME {
    STRING RelativeName;
    HANDLE ContainingDirectory;
} RELATIVE_NAME, *PRELATIVE_NAME;


HANDLE BaseDllHandle;
HANDLE BaseNamedObjectDirectory;

PVOID BaseHeap;
RTL_HANDLE_TABLE BaseHeapHandleTable;


UNICODE_STRING BaseWindowsDirectory;
UNICODE_STRING BaseWindowsSystemDirectory;
#ifdef WX86
UNICODE_STRING BaseWindowsSys32x86Directory;
#endif

extern UNICODE_STRING BasePathVariableName;
extern UNICODE_STRING BaseTmpVariableName;
extern UNICODE_STRING BaseTempVariableName;
extern UNICODE_STRING BaseUserProfileVariableName;
extern UNICODE_STRING BaseDotVariableName;
extern UNICODE_STRING BaseDotTmpSuffixName;
extern UNICODE_STRING BaseDotComSuffixName;
extern UNICODE_STRING BaseDotPifSuffixName;
extern UNICODE_STRING BaseDotExeSuffixName;

UNICODE_STRING BaseDefaultPath;
UNICODE_STRING BaseDefaultPathAppend;
UNICODE_STRING BaseDllDirectory;
RTL_CRITICAL_SECTION BaseDllDirectoryLock;
PWSTR BaseCSDVersion;
WORD BaseCSDNumber;
WORD BaseRCNumber;

extern UNICODE_STRING BaseConsoleInput;
extern UNICODE_STRING BaseConsoleOutput;
extern UNICODE_STRING BaseConsoleGeneric;
UNICODE_STRING BaseUnicodeCommandLine;
ANSI_STRING BaseAnsiCommandLine;

LPSTARTUPINFOA BaseAnsiStartupInfo;

PBASE_STATIC_SERVER_DATA BaseStaticServerData;

#if defined(BUILD_WOW6432) || defined(_WIN64)
extern SYSTEM_BASIC_INFORMATION SysInfo;
#endif

extern UINT_PTR SystemRangeStart;
extern BOOLEAN BaseRunningInServerProcess;

ULONG BaseIniFileUpdateCount;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG_PTR)(SIZE) + (ULONG_PTR)BASE_SYSINFO.PageSize - 1) & ~((ULONG_PTR)BASE_SYSINFO.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG_PTR)(SIZE)) & ~((ULONG_PTR)BASE_SYSINFO.PageSize - 1))

#define BASE_COPY_FILE_CHUNK (64*1024)
#define BASE_MAX_PATH_STRING 4080

extern BOOLEAN BasepFileApisAreOem;

#define DATA_ATTRIBUTE_NAME         L":$DATA"
#define DATA_ATTRIBUTE_LENGTH       (sizeof( DATA_ATTRIBUTE_NAME ) - sizeof( WCHAR ))

extern WCHAR BasepDataAttributeType[];

#define CERTAPP_KEY_NAME L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls"
#define CERTAPP_ENTRYPOINT_NAME "CreateProcessNotify"
#define CERTAPP_EMBEDDED_DLL_NAME L"EmbdTrst.DLL"
#define CERTAPP_EMBEDDED_DLL_EP "ImageOkToRunOnEmbeddedNT"
RTL_CRITICAL_SECTION gcsAppCert;
LIST_ENTRY BasepAppCertDllsList;

RTL_CRITICAL_SECTION gcsAppCompat;

NTSTATUS
BasepConfigureAppCertDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
BasepSaveAppCertRegistryValue(
    IN OUT PLIST_ENTRY ListHead,
    IN PWSTR Name,
    IN PWSTR Value OPTIONAL
    );


typedef struct _BASEP_APPCERT_ENTRY {
    LIST_ENTRY Entry;
    UNICODE_STRING Name;
    NTSTATUS (WINAPI *fPluginCertFunc)(LPCWSTR lpApplicationName,ULONG Reason);
} BASEP_APPCERT_ENTRY, *PBASEP_APPCERT_ENTRY;

extern RTL_QUERY_REGISTRY_TABLE BasepAppCertTable[];

#define APPCERT_IMAGE_OK_TO_RUN     1
#define APPCERT_CREATION_ALLOWED    2
#define APPCERT_CREATION_DENIED     3


__inline
BOOL
BasepIsDataAttribute(
    ULONG Count,
    const WCHAR *Name
    )
{
    return Count > DATA_ATTRIBUTE_LENGTH &&
         !_wcsnicmp( &Name[(Count - DATA_ATTRIBUTE_LENGTH) / sizeof( WCHAR )],
                     BasepDataAttributeType,
                     DATA_ATTRIBUTE_LENGTH / sizeof( WCHAR ));
}

PUNICODE_STRING
Basep8BitStringToStaticUnicodeString(
    IN LPCSTR SourceString
    );

BOOL
Basep8BitStringToDynamicUnicodeString(
    OUT PUNICODE_STRING UnicodeString,
    IN LPCSTR lpSourceString
    );

NTSTATUS
(*Basep8BitStringToUnicodeString)(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
(*BasepUnicodeStringTo8BitString)(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

ULONG
(*BasepUnicodeStringTo8BitSize)(
    PUNICODE_STRING UnicodeString
    );

ULONG
BasepUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    );

ULONG
BasepUnicodeStringToOemSize(
    PUNICODE_STRING UnicodeString
    );

ULONG
(*Basep8BitStringToUnicodeSize)(
    PANSI_STRING AnsiString
    );

ULONG
BasepAnsiStringToUnicodeSize(
    PANSI_STRING AnsiString
    );

ULONG
BasepOemStringToUnicodeSize(
    PANSI_STRING OemString
    );

HANDLE
BaseGetNamedObjectDirectory(
    VOID
    );

void
BaseDllInitializeMemoryManager( VOID );

typedef
NTSTATUS
(*BASECLIENTCONNECTROUTINE)(
    PVOID MustBeNull,
    PVOID ConnectionInformation,
    PULONG ConnectionInformationLength
    );


POBJECT_ATTRIBUTES
BaseFormatObjectAttributes(
    POBJECT_ATTRIBUTES ObjectAttributes,
    PSECURITY_ATTRIBUTES SecurityAttributes,
    PUNICODE_STRING ObjectName
    );

PLARGE_INTEGER
BaseFormatTimeOut(
    PLARGE_INTEGER TimeOut,
    DWORD Milliseconds
    );

ULONG
BaseSetLastNTError(
    NTSTATUS Status
    );

VOID
BaseSwitchStackThenTerminate(
    PVOID CurrentStack,
    PVOID NewStack,
    DWORD ExitCode
    );

VOID
BaseFreeStackAndTerminate(
    PVOID OldStack,
    DWORD ExitCode
    );

NTSTATUS
BaseCreateStack(
    HANDLE Process,
    SIZE_T StackSize,
    SIZE_T MaximumStackSize,
    PINITIAL_TEB InitialTeb
    );

VOID
BasepSwitchToFiber(
    PFIBER CurrentFiber,
    PFIBER NewFiber
    );

VOID
BaseFiberStart(
    VOID
    );

VOID
BaseThreadStart(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

typedef DWORD (WINAPI *PPROCESS_START_ROUTINE)(
    VOID
    );

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    );

VOID
BaseThreadStartThunk(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

VOID
BaseProcessStartThunk(
    LPVOID lpProcessStartAddress,
    LPVOID lpParameter
    );

typedef enum _BASE_CONTEXT_TYPE {
    BaseContextTypeProcess,
    BaseContextTypeThread,
    BaseContextTypeFiber
} BASE_CONTEXT_TYPE, *PBASE_CONTEXT_TYPE;

VOID
BaseInitializeContext(
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp,
    BASE_CONTEXT_TYPE ContextType
    );

#if defined(WX86) || defined(_AXP64_)
NTSTATUS
BaseCreateWx86Tib(
    HANDLE Process,
    HANDLE Thread,
    ULONG InitialPc,
    ULONG CommittedStackSize,
    ULONG MaximumStackSize,
    BOOLEAN EmulateInitialPc
    );
#endif

VOID
BaseFreeThreadStack(
     HANDLE hProcess,
     HANDLE hThread,
     PINITIAL_TEB InitialTeb
     );

#define BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT  (0x00000001)

BOOL
BasePushProcessParameters(
    DWORD dwFlags,
    HANDLE Process,
    PPEB Peb,
    LPCWSTR ApplicationPathName,
    LPCWSTR CurrentDirectory,
    LPCWSTR CommandLine,
    LPVOID Environment,
    LPSTARTUPINFOW lpStartupInfo,
    DWORD dwCreationFlags,
    BOOL bInheritHandles,
    DWORD dwSubsystem,
    PVOID pAppCompatData,
    DWORD cbAppCompatData
    );

LPWSTR
BaseComputeProcessDllPath(
    LPCWSTR AppName,
    LPVOID Environment
    );

LPWSTR
BaseComputeProcessSearchPath(
    VOID
    );

extern PCLDR_DATA_TABLE_ENTRY BasepExeLdrEntry;

VOID
BasepLocateExeLdrEntry(
    IN PCLDR_DATA_TABLE_ENTRY Entry,
    IN PVOID Context,
    IN OUT BOOLEAN *StopEnumeration
    );

FORCEINLINE
VOID
BasepCheckExeLdrEntry(
    VOID
    )
{
    if (! BasepExeLdrEntry) {
        LdrEnumerateLoadedModules(0,
                                  &BasepLocateExeLdrEntry,
                                  NtCurrentPeb()->ImageBaseAddress);
    }
}

LPCWSTR
BasepEndOfDirName(
    IN LPCWSTR FileName
    );

DWORD
BaseDebugAttachThread(
    LPVOID ThreadParameter
    );

HANDLE
BaseFindFirstDevice(
    PCUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

PUNICODE_STRING
BaseIsThisAConsoleName(
    PCUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    );


typedef ULONG (FAR WINAPI *CSRREMOTEPROCPROC)(HANDLE, CLIENT_ID *);

#if DBG
VOID
BaseHeapBreakPoint( VOID );
#endif

ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    );

//
// Data structure for CopyFileEx context
//

typedef struct _COPYFILE_CONTEXT {
    LARGE_INTEGER TotalFileSize;
    LARGE_INTEGER TotalBytesTransferred;
    DWORD dwStreamNumber;
    LPBOOL lpCancel;
    LPVOID lpData;
    LPPROGRESS_ROUTINE lpProgressRoutine;
} COPYFILE_CONTEXT, *LPCOPYFILE_CONTEXT;

//
// Data structure for tracking restart state
//

typedef struct _RESTART_STATE {
    CSHORT Type;
    CSHORT Size;
    DWORD NumberOfStreams;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER WriteTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER LastKnownGoodOffset;
    DWORD CurrentStream;
    DWORD Checksum;
} RESTART_STATE, *PRESTART_STATE, *LPRESTART_STATE;

#define SUCCESS_RETURNED_STATE 2

DWORD
BaseCopyStream(
    LPCWSTR lpExistingFileName,
    HANDLE hSourceFile,
    ACCESS_MASK SourceFileAccess OPTIONAL,
    LPCWSTR lpNewFileName,
    HANDLE hTargetFile OPTIONAL,
    LARGE_INTEGER *lpFileSize,
    LPDWORD lpCopyFlags,
    LPHANDLE lpDestFile,
    LPDWORD lpCopySize,
    LPCOPYFILE_CONTEXT *lpCopyFileContext,
    LPRESTART_STATE lpRestartState OPTIONAL,
    BOOL OpenFileAsReparsePoint,
    DWORD dwReparseTag,
    PDWORD DestFileFsAttributes
    );

BOOL
BasepCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags,
    DWORD dwPrivCopyFlags,
    LPHANDLE phSource OPTIONAL,
    LPHANDLE phDest OPTIONAL
    );

VOID
BaseMarkFileForDelete(
    HANDLE File,
    DWORD FileAttributes
    );


PVOID
BasepMapModuleHandle(
    IN HMODULE hModule,
    IN BOOLEAN bResourcesOnly
    );

ULONG_PTR
BaseDllMapResourceIdA(
    PCSTR lpId
    );

ULONG_PTR
BaseDllMapResourceIdW(
    PCWSTR lpId
    );

VOID
BaseDllFreeResourceId(
    ULONG_PTR Id
    );

//
// Data structures and interfaces used by dllini.c
//

typedef struct _INIFILE_CACHE {
    struct _INIFILE_CACHE *Next;
    ULONG EnvironmentUpdateCount;
    UNICODE_STRING NtFileName;
    PINIFILE_MAPPING_FILENAME FileMapping;
    HANDLE FileHandle;
    BOOLEAN WriteAccess;
    BOOLEAN UnicodeFile;
    BOOLEAN LockedFile;
    ULONG EndOfFile;
    PVOID BaseAddress;
    SIZE_T CommitSize;
    SIZE_T RegionSize;
    ULONG UpdateOffset;
    ULONG UpdateEndOffset;
    ULONG DirectoryInformationLength;
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
} INIFILE_CACHE, *PINIFILE_CACHE;

typedef enum _INIFILE_OPERATION {
    FlushProfiles,
    ReadKeyValue,
    WriteKeyValue,
    DeleteKey,
    ReadKeyNames,
    ReadSectionNames,
    ReadSection,
    WriteSection,
    DeleteSection,
    RefreshIniFileMapping
} INIFILE_OPERATION;

typedef struct _INIFILE_PARAMETERS {
    INIFILE_OPERATION Operation;
    BOOLEAN WriteOperation;
    BOOLEAN Unicode;
    BOOLEAN ValueBufferAllocated;
    PINIFILE_MAPPING_FILENAME IniFileNameMapping;
    PINIFILE_CACHE IniFile;
    UNICODE_STRING BaseFileName;
    UNICODE_STRING FileName;
    UNICODE_STRING NtFileName;
    ANSI_STRING ApplicationName;
    ANSI_STRING VariableName;
    UNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableNameU;
    BOOLEAN MultiValueStrings;
    union {
        //
        // This structure filled in for write operations
        //
        struct {
            LPSTR ValueBuffer;
            ULONG ValueLength;
            PWSTR ValueBufferU;
            ULONG ValueLengthU;
        };
        //
        // This structure filled in for read operations
        //
        struct {
            ULONG ResultChars;
            ULONG ResultMaxChars;
            LPSTR ResultBuffer;
            PWSTR ResultBufferU;
        };
    };


    //
    // Remaining fields only valid when parsing an on disk .INI file mapped into
    // memory.
    //

    PVOID TextCurrent;
    PVOID TextStart;
    PVOID TextEnd;

    ANSI_STRING SectionName;
    ANSI_STRING KeywordName;
    ANSI_STRING KeywordValue;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PANSI_STRING AnsiKeywordValue;
    UNICODE_STRING SectionNameU;
    UNICODE_STRING KeywordNameU;
    UNICODE_STRING KeywordValueU;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PUNICODE_STRING UnicodeKeywordValue;
} INIFILE_PARAMETERS, *PINIFILE_PARAMETERS;

NTSTATUS
BaseDllInitializeIniFileMappings(
    PBASE_STATIC_SERVER_DATA StaticServerData
    );

NTSTATUS
BasepAcquirePrivilege(
    ULONG Privilege,
    PVOID *ReturnedState
    );

NTSTATUS
BasepAcquirePrivilegeEx(
    ULONG Privilege,
    PVOID *ReturnedState
    );

VOID
BasepReleasePrivilege(
    PVOID StatePointer
    );

NTSTATUS
NTAPI
BaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    PVOID Parameter,
    HANDLE * ThreadHandle
    );

NTSTATUS
NTAPI
BaseExitThreadPoolThread(
    NTSTATUS Status
    );

//
// Function for returning the volume name from a reparse point.
//

BOOL
BasepGetVolumeNameFromReparsePoint(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength,
    PBOOL ResultOfOpen
    );


#if defined(_WIN64) || defined(BUILD_WOW6432)

//
// COM+ Support routines
//

NTSTATUS
BasepIsComplusILImage(
    IN HANDLE SectionImageHandle,
    IN PSECTION_IMAGE_INFORMATION SectionImageInformation,
    OUT BOOLEAN *IsComplusILImage
    );

#endif


//
// Definitions for memory handles used by Local/GlobalAlloc functions
//

typedef struct _BASE_HANDLE_TABLE_ENTRY {
    USHORT Flags;
    USHORT LockCount;
    union {
        PVOID Object;                               // Allocated handle
        ULONG Size;                                 // Handle to discarded obj.
    };
} BASE_HANDLE_TABLE_ENTRY, *PBASE_HANDLE_TABLE_ENTRY;

#define BASE_HANDLE_MOVEABLE    (USHORT)0x0002
#define BASE_HANDLE_DISCARDABLE (USHORT)0x0004
#define BASE_HANDLE_DISCARDED   (USHORT)0x0008
#define BASE_HANDLE_SHARED      (USHORT)0x8000

//
// Handles are 32-bit pointers to the u.Object field of a
// BASE_HANDLE_TABLE_ENTRY.  Since this field is 4 bytes into the
// structure and the structures are always on 8 byte boundaries, we can
// test the 0x4 bit to see if it is a handle.
//
// In Sundown, these handles are 64-bit pointers to the u.Object field
// which is 8 bytes into the structure.  Therefore, we should test the
// 0x8 bit to see if it is a handle.
//
//on sundown
//     #define BASE_HANDLE_MARK_BIT (ULONG_PTR)0x00000008
//on 32 bit systems
//     #define BASE_HANDLE_MARK_BIT (ULONG_PTR)0x00000004
//

#define BASE_HANDLE_MARK_BIT (ULONG_PTR)FIELD_OFFSET(BASE_HANDLE_TABLE_ENTRY,Object)
#define BASE_HEAP_FLAG_MOVEABLE  HEAP_SETTABLE_USER_FLAG1
#define BASE_HEAP_FLAG_DDESHARE  HEAP_SETTABLE_USER_FLAG2


ULONG BaseDllTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseDllTag, t ))

#define TMP_TAG 0
#define BACKUP_TAG 1
#define INI_TAG 2
#define FIND_TAG 3
#define GMEM_TAG 4
#define LMEM_TAG 5
#define ENV_TAG 6
#define RES_TAG 7
#define VDM_TAG 8


#include <vdmapi.h>
#include "vdm.h"
#include "basevdm.h"

#include "stdlib.h"     // for atol
#include "stdio.h"     // for atol

#include <objidl.h>         //  needs nturtl.h
#include <propset.h>        //  needs objidl.h
#include <tsappcmp.h>

//
// Hydra function for supporting beeps on remote sessions
//
typedef HANDLE (WINAPI * PWINSTATIONBEEPOPEN)(ULONG);
HANDLE WINAPI
_WinStationBeepOpen(
    ULONG SessionId
    );
PWINSTATIONBEEPOPEN pWinStationBeepOpen;

//
//  Private functions for communication with CSR.
//
VOID
CsrBasepSoundSentryNotification(
    ULONG VideoMode
    );

NTSTATUS
CsrBaseClientConnectToServer(
    PWSTR szSessionDir,
    PHANDLE phMutant,
    PBOOLEAN pServerProcess
    );

NTSTATUS
CsrBasepRefreshIniFileMapping(
    PUNICODE_STRING BaseFileName
    );

NTSTATUS
CsrBasepDefineDosDevice(
    DWORD dwFlags,
    PUNICODE_STRING pDeviceName,
    PUNICODE_STRING pTargetPath
    );

UINT
CsrBasepGetTempFile(
    VOID
    );

NTSTATUS
CsrBasepCreateProcess(
    PBASE_CREATEPROCESS_MSG a
    );

VOID
CsrBasepExitProcess(
    UINT uExitCode
    );

NTSTATUS
CsrBasepSetProcessShutdownParam(
    DWORD dwLevel,
    DWORD dwFlags
    );

NTSTATUS
CsrBasepGetProcessShutdownParam(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );

NTSTATUS
CsrBasepSetTermsrvAppInstallMode(
    BOOL bState
    );

NTSTATUS
CsrBasepSetClientTimeZoneInformation(
    IN PBASE_SET_TERMSRVCLIENTTIMEZONE c
    );

NTSTATUS
CsrBasepCreateThread(
    HANDLE ThreadHandle,
    CLIENT_ID ClientId
    );

//
// This should be merged with BasepCreateActCtx, its only caller.
//
#define BASEP_CREATE_ACTCTX_FLAG_NO_ADMIN_OVERRIDE 0x00000001
NTSTATUS
BasepCreateActCtx(
    ULONG           Flags,
    IN PCACTCTXW    ActParams,
    OUT PVOID*      ActivationContextData
    );

NTSTATUS
CsrBasepCreateActCtx(
    IN PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message
    );

#if defined(BUILD_WOW6432)
#include "ntwow64b.h"
#endif

BOOL TermsrvSyncUserIniFile(PINIFILE_PARAMETERS a);

BOOL TermsrvLogInstallIniFile(PINIFILE_PARAMETERS a);

PTERMSRVFORMATOBJECTNAME gpTermsrvFormatObjectName;

PTERMSRVGETCOMPUTERNAME  gpTermsrvGetComputerName;

PTERMSRVADJUSTPHYMEMLIMITS gpTermsrvAdjustPhyMemLimits;

PTERMSRVGETWINDOWSDIRECTORYA gpTermsrvGetWindowsDirectoryA;

PTERMSRVGETWINDOWSDIRECTORYW gpTermsrvGetWindowsDirectoryW;

PTERMSRVCONVERTSYSROOTTOUSERDIR gpTermsrvConvertSysRootToUserDir;

PTERMSRVBUILDINIFILENAME gpTermsrvBuildIniFileName;

PTERMSRVCORINIFILE gpTermsrvCORIniFile;

PTERMSRVUPDATEALLUSERMENU gpTermsrvUpdateAllUserMenu;

PGETTERMSRCOMPATFLAGS gpGetTermsrCompatFlags;

PTERMSRVBUILDSYSINIPATH gpTermsrvBuildSysIniPath;

PTERMSRVCOPYINIFILE gpTermsrvCopyIniFile;

PTERMSRVGETSTRING gpTermsrvGetString;

PTERMSRVLOGINSTALLINIFILE gpTermsrvLogInstallIniFile;

//
//  For periodic timers that fire APCs set when a non-default activation context is active
//  we leak this structure.
//

#define BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK (0x00000001)

typedef struct _BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK {
    DWORD Flags;
    PVOID CallbackFunction;
    PVOID CallbackContext;
    PACTIVATION_CONTEXT ActivationContext;
} BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK, *PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK;

#define BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK (0x00000001)
#define BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT (0x00000002)

NTSTATUS
BasepAllocateActivationContextActivationBlock(
    IN DWORD Flags,
    IN PVOID CallbackFunction,
    IN PVOID CallbackContext,
    OUT PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK *ActivationBlock
    );

VOID
BasepFreeActivationContextActivationBlock(
    IN PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock
    );

VOID
WINAPI
BasepActivationContextActivationIoCompletion(
    IN PVOID ApcContext, // actually PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

VOID
CALLBACK
BasepTimerAPCProc(
    IN PVOID ApcContext, // actually PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK
    IN ULONG TimerLowValue,
    IN LONG TimerHighValue
    );

#define BASE_FILE_PATH_ISOLATION_ALLOCATE_PATH (0x00000001)

NTSTATUS
BasepApplyFilePathIsolationRedirection(
    IN DWORD Flags,
    IN PCUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING FullyQualifiedPath
    );

#define SXS_POLICY_SUFFIX       L".Config"
#define SXS_MANIFEST_SUFFIX     L".Manifest"
extern const UNICODE_STRING SxsPolicySuffix;

typedef struct _SXS_CONSTANT_WIN32_NT_PATH_PAIR
{
    PCUNICODE_STRING Win32;
    PCUNICODE_STRING Nt;
} SXS_CONSTANT_WIN32_NT_PATH_PAIR;
typedef       SXS_CONSTANT_WIN32_NT_PATH_PAIR*  PSXS_CONSTANT_WIN32_NT_PATH_PAIR;
typedef CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR* PCSXS_CONSTANT_WIN32_NT_PATH_PAIR;

typedef struct _SXS_WIN32_NT_PATH_PAIR
{
    PRTL_UNICODE_STRING_BUFFER   Win32;
    PRTL_UNICODE_STRING_BUFFER   Nt;
} SXS_WIN32_NT_PATH_PAIR;
typedef       SXS_WIN32_NT_PATH_PAIR*  PSXS_WIN32_NT_PATH_PAIR;
typedef CONST SXS_WIN32_NT_PATH_PAIR* PCSXS_WIN32_NT_PATH_PAIR;

NTSTATUS
BasepSxsCreateResourceStream(
    IN ULONG                  LdrCreateOutOfProcessImageFlags,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES Handles,
    IN ULONG_PTR              MappedResourceName,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

NTSTATUS
BasepSxsCreateFileStream(
    IN ACCESS_MASK            AccessMask,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES Handles,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

// Pass the address of this to force policy to be empty.
// It doesn't have a special address, just the right values.
extern const SXS_OVERRIDE_STREAM SxsForceEmptyPolicy;

VOID
BasepSxsOverrideStreamToMessageStream(
    IN  PCSXS_OVERRIDE_STREAM OverrideStream,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

#define BASEP_SXS_CREATESTREAMS_FLAG_LIKE_CREATEPROCESS 0x00000001

NTSTATUS
BasepSxsCreateStreams(
    IN ULONG                                Flags,
    IN ULONG                                LdrCreateOutOfProcessImageFlags,
    IN ACCESS_MASK                          AccessMask,
    IN PCSXS_OVERRIDE_STREAM                OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM                OverridePolicy OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestFilePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestImagePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestImageHandles,
// If none of the optional parameters are passed, then you could have directly
// called a simpler function.
    IN ULONG_PTR                            MappedManifestResourceName OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    PolicyPathPair OPTIONAL,
    IN OUT PBASE_MSG_SXS_HANDLES            PolicyHandles OPTIONAL,
    OUT PULONG                              MessageFlags,
    OUT PBASE_MSG_SXS_STREAM                ManifestMessageStream,
    OUT PBASE_MSG_SXS_STREAM                PolicyMessageStream  OPTIONAL
    );

BOOL
BasepSxsIsStatusFileNotFoundEtc(
    NTSTATUS Status
    );

BOOL
BasepSxsIsStatusResourceNotFound(
    NTSTATUS Status
    );

NTSTATUS
BasepSxsCreateProcessCsrMessage(
    IN PCSXS_OVERRIDE_STREAM             OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM             OverridePolicy   OPTIONAL,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      ManifestFilePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR ManifestImagePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestImageHandles,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      PolicyPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         PolicyHandles,
    IN OUT PRTL_UNICODE_STRING_BUFFER    Win32AssemblyDirectoryBuffer,
    OUT PBASE_SXS_CREATEPROCESS_MSG      Message
    );

NTSTATUS
BasepSxsGetProcessImageBaseAddress(
    HANDLE Process,
    PVOID* ImageBaseAddress
    );

VOID
NTAPI
BasepSxsActivationContextNotification(
    IN ULONG NotificationType,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN const VOID *ActivationContextData,
    IN PVOID NotificationContext,
    IN PVOID NotificationData,
    IN OUT PBOOLEAN DisableNotification
    );

VOID
BasepSxsDbgPrintMessageStream(
    PCSTR Function,
    PCSTR StreamName,
    PBASE_MSG_SXS_STREAM MessageStream
    );

extern const UNICODE_STRING SxsManifestSuffix;
extern const UNICODE_STRING SxsPolicySuffix;

VOID
BasepSxsCloseHandles(
    IN PCBASE_MSG_SXS_HANDLES Handles
    );

extern const WCHAR AdvapiDllString[];

//
// These functions implement apphelp cache functionality (ahcache.c)
//

//
// Routines in ahcache.c
//


BOOL
WINAPI
BaseCheckAppcompatCache(
    LPCWSTR pwszPath,
    HANDLE  hFile,
    PVOID   pEnvironment,
    DWORD*  dwReason
    );

//
// function that we call from winlogon
//

BOOL
WINAPI
BaseInitAppcompatCacheSupport(
    VOID
    );

VOID
WINAPI
BaseCleanupAppcompatCache(
    VOID
    );

BOOL
WINAPI
BaseCleanupAppcompatCacheSupport(
    BOOL bWrite
    );


NTSTATUS
NTAPI
BasepProbeForDllManifest(
    IN PVOID DllBase,
    IN PCWSTR FullDllPath,
    OUT PVOID *ActivationContext
    );

#define BASEP_GET_MODULE_HANDLE_EX_NO_LOCK                    (0x00000001)
BOOL
BasepGetModuleHandleExW(
    IN DWORD        dwPrivateFlags,
    IN DWORD        dwPublicFlags,
    IN LPCWSTR      lpModuleName,
    OUT HMODULE*    phModule
    );

#define BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR    1
#define BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS  2
#define BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE 3
ULONG
BasepGetModuleHandleExParameterValidation(
    IN DWORD        dwFlags,
    IN CONST VOID*  lpModuleName,
    OUT HMODULE*    phModule
    );

#define BASEP_GET_TEMP_PATH_PRESERVE_TEB         (0x00000001)
DWORD
BasepGetTempPathW(
    ULONG  Flags,
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

#endif // _BASEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\beep.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    This module contains the Win32 Beep APIs

Author:

    Steve Wood (stevewo)  5-Oct-1991

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include <ntddbeep.h>
#include "conapi.h"

#define IsActiveConsoleSession() (BOOLEAN)(USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)

/*
 * Forward declaration
 */

VOID NotifySoundSentry(VOID);

BOOL
APIENTRY
Beep(
    DWORD dwFreq,
    DWORD dwDuration
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    BEEP_SET_PARAMETERS BeepParameters;
    HANDLE hBeepDevice, hTSBeepDevice;

    if ( IsTerminalServer() ) {

        if ( !pWinStationBeepOpen ) {
            HMODULE hwinsta = NULL;
            /*
             *  Get handle to winsta.dll
             */
            if ( (hwinsta = LoadLibraryW( L"WINSTA" )) != NULL ) {

                pWinStationBeepOpen   = (PWINSTATIONBEEPOPEN)
                    GetProcAddress( hwinsta, "_WinStationBeepOpen" );
            }
        }

        hTSBeepDevice = NULL;

        if ( pWinStationBeepOpen )
            hTSBeepDevice = (*pWinStationBeepOpen)( -1 ); //Current Session
    }

    if ( IsTerminalServer() && !IsActiveConsoleSession() ) {

        hBeepDevice = hTSBeepDevice;

        if ( hBeepDevice == NULL )
            Status = STATUS_ACCESS_DENIED;
        else
            Status = STATUS_SUCCESS;
    }
    else {

        RtlInitUnicodeString( &NameString, DD_BEEP_DEVICE_NAME_U );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &NameString,
                                    0,
                                    NULL,
                                    NULL
                                  );
        Status = NtCreateFile( &hBeepDevice,
                               FILE_READ_DATA | FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,
                               0,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN_IF,
                               0,
                               NULL,
                               0L
                             );
    }
    if (!NT_SUCCESS( Status )) {
        if ( IsTerminalServer() && hTSBeepDevice ) {
            NtClose( hTSBeepDevice );
        }
        BaseSetLastNTError( Status );
        return( FALSE );
        }

    //
    // 0,0 is a special case used to turn off a beep.  Otherwise
    // validate the dwFreq parameter to be in range.
    //

    if ((dwFreq != 0 || dwDuration != 0) &&
        (dwFreq < (ULONG)0x25 || dwFreq > (ULONG)0x7FFF)
       ) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else {
        BeepParameters.Frequency = dwFreq;
        BeepParameters.Duration = dwDuration;

        Status = NtDeviceIoControlFile( hBeepDevice,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_BEEP_SET,
                                        &BeepParameters,
                                        sizeof( BeepParameters ),
                                        NULL,
                                        0
                                      );
        }

    if ( IsTerminalServer() && IsActiveConsoleSession() && hTSBeepDevice ) {

        //
        // It's the console and since we got a beep device, it's being shadowed.
        // So let's do it one more time for the shadow client.
        //
        if ( NT_SUCCESS(Status) ) {
             NtDeviceIoControlFile( hTSBeepDevice,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatus,
                                    IOCTL_BEEP_SET,
                                    &BeepParameters,
                                    sizeof( BeepParameters ),
                                    NULL,
                                    0
                                  );
        }

        NtClose( hTSBeepDevice );
    }

    
    NotifySoundSentry();

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        NtClose( hBeepDevice );
        return( FALSE );
        }
    else {
        //
        // Beep device is asynchronous, so sleep for duration
        // to allow this beep to complete.
        //

        if (dwDuration != (DWORD)-1 && (dwFreq != 0 || dwDuration != 0)) {
            SleepEx( dwDuration, TRUE );
            }

        NtClose( hBeepDevice );
        return( TRUE );
        }
}


VOID
NotifySoundSentry(VOID)
{

#if defined(BUILD_WOW6432)
    ULONG VideoMode;

    if (!GetConsoleDisplayMode(&VideoMode)) {
        VideoMode = 0;
    }

    //
    // SoundSentry is currently only supported for Windows mode - no
    // full screen support.
    //
     
    if (VideoMode == 0) {    
        CsrBasepSoundSentryNotification(VideoMode);
    }
#else
    BASE_API_MSG m;
    PBASE_SOUNDSENTRY_NOTIFICATION_MSG e = &m.u.SoundSentryNotification;

    if (!GetConsoleDisplayMode(&e->VideoMode)) {
        e->VideoMode = 0;
    }
    //
    // SoundSentry is currently only supported for Windows mode - no
    // full screen support.
    //
    if (e->VideoMode == 0) {
        CsrClientCallServer((PCSR_API_MSG)&m,
                            NULL,
                            CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                 BasepSoundSentryNotification ),
                            sizeof( *e )
                            );
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\blddcb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blddcb.c

Abstract:

    This module implements Win32 comm api buildcommdcb

Author:

    Anthony V. Ercolano (tonye) 10-March-1992

    Actually this code was generously donated by
    ramonsa.  It is basically the code used for
    the mode command.

Revision History:

--*/

#include <basedll.h>

typedef struct _PARSE_CONTEXT {
    PSTR CharIndex;
    PSTR AdvanceIndex;
    PSTR MatchBegin;
    PSTR MatchEnd;
    } PARSE_CONTEXT,*PPARSE_CONTEXT;

static
BOOL
BuildDcb (
    LPCSTR L,
    LPDCB Dcb,
    LPCOMMTIMEOUTS To
    );

static
BOOL
Match(
    PPARSE_CONTEXT C,
    PSTR Pattern
    );

static
VOID
Advance(
    PPARSE_CONTEXT C
    );

static
DWORD
GetNumber(
    PPARSE_CONTEXT C
    );

static
BOOL
ConvertBaudRate (
    DWORD BaudIn,
    PDWORD BaudRate
    );

static
BOOL
ConvertDataBits (
    DWORD DataBitsIn,
    PBYTE DataBitsOut
    );

static
BOOL
ConvertStopBits (
    DWORD StopBitsIn,
    PBYTE StopBits
    );

static
BOOL
ConvertParity (
    CHAR ParityIn,
    PBYTE Parity
    );

static
BOOL
ConvertDtrControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE DtrControl
    );

static
BOOL
ConvertRtsControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE RtsControl
    );

static
VOID
IgnoreDeviceName(
    IN PPARSE_CONTEXT C
    );

static
NTSTATUS
DeviceNameCompare(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );


BOOL
BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.
    It also sets the timeouts if specified.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

    lpCommTimeouts - It "TO" included, it will set the timeouts.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL AnsiBool;

    RtlInitUnicodeString(
        &Unicode,
        lpDef
        );

    Status = RtlUnicodeStringToAnsiString(
                 &Ansi,
                 &Unicode,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError(Status);
        return FALSE;

    }

    AnsiBool = BuildCommDCBAndTimeoutsA(
                   (LPCSTR)Ansi.Buffer,
                   lpDCB,
                   lpCommTimeouts
                   );

    RtlFreeAnsiString(&Ansi);
    return AnsiBool;

}

BOOL
BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.
    It can also set the timeout value.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

    lpCommTimeouts - If TO included in string then timeouts are also set.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    if (!BuildDcb(
             lpDef,
             lpDCB,
             lpCommTimeouts
             )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    } else {

        return TRUE;

    }

}

BOOL
BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;
    BOOL AnsiBool;

    RtlInitUnicodeString(
        &Unicode,
        lpDef
        );

    Status = RtlUnicodeStringToAnsiString(
                 &Ansi,
                 &Unicode,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError(Status);
        return FALSE;

    }

    AnsiBool = BuildCommDCBA(
                   (LPCSTR)Ansi.Buffer,
                   lpDCB
                   );

    RtlFreeAnsiString(&Ansi);
    return AnsiBool;

}

BOOL
BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function translates the definition string specified by the
    lpDef parameter into appropriate device-control block codes and
    places these codes into the block pointed to by the lpDCB parameter.

Arguments:

    lpDef - Points to a null terminated character string that specifies
            the device control information for the device.

    lpDCB -  Points to the DCB data structure that is to receive the
             translated string..  The structure defines the control
             settings for the serial communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    COMMTIMEOUTS JunkTimeouts;

    if (!BuildDcb(
             lpDef,
             lpDCB,
             &JunkTimeouts
             )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    } else {

        return TRUE;

    }

}

static
BOOL
BuildDcb (
    LPCSTR L,
    LPDCB Dcb,
    LPCOMMTIMEOUTS To
    )

/*++

Routine Description:


Arguments:

    L - A pointer to the string to convert to a DCB.
    Dcb - The dcb to fill in.

Return Value:

    FALSE if the string has some error, TRUE otherwise.

--*/

{

    BOOL        SetBaud         =   FALSE;
    BOOL        SetDataBits     =   FALSE;
    BOOL        SetStopBits     =   FALSE;
    BOOL        SetParity       =   FALSE;
    BOOL        SetRetry        =   FALSE;
    BOOL        SetTimeOut      =   FALSE;
    BOOL        SetXon          =   FALSE;
    BOOL        SetOdsr         =   FALSE;
    BOOL        SetIdsr         =   FALSE;
    BOOL        SetOcts         =   FALSE;
    BOOL        SetDtrControl   =   FALSE;
    BOOL        SetRtsControl   =   FALSE;

    DWORD       Baud;
    BYTE        DataBits;
    BYTE        StopBits;
    BYTE        Parity;
    BOOL        TimeOut;
    BOOL        Xon;
    BOOL        Odsr;
    BOOL        Idsr;
    BOOL        Octs;
    BYTE        DtrControl;
    BYTE        RtsControl;
    PARSE_CONTEXT C = {0};

    C.CharIndex = C.AdvanceIndex = (PSTR)L;

    //
    // This following call will query all of the *current* serial
    // provider names.  If it finds that the argurment string
    // contains the name (with an optional :) it will simply
    // advance past it.
    //

    IgnoreDeviceName(&C);

    if ( Match(&C, "#" ) ) {

        //
        //   Old syntax, where parameter are positional and comma-delimited.
        //
        //   We will use the following automata for parsing the input
        //   (eoi = end of input):
        //
        //           eoi
        //    [Baud]------------->[End]
        //      |            ^
        //      |,           |eoi
        //      v            |
        //     [a]-----------+
        //      |            ^
        //      | @          |eoi
        //      +-->[Parity]-+
        //      |     |      ^
        //      |     |,     |
        //      |<----+      |
        //      |            |
        //      |,           |eoi
        //      |            |
        //      v            |
        //     [b]-----------+
        //      |            ^
        //      | #          |eoi
        //      +-->[Data]---+
        //      |     |      ^
        //      |     |,     |
        //      |<----+      |
        //      |            |
        //      |,           |eoi
        //      v            |
        //     [c]-----------+
        //      |            ^
        //      | #          |eoi
        //      +-->[Stop]---+
        //

        //
        // Assume xon=off
        //

        SetXon      = TRUE;
        SetOdsr     = TRUE;
        SetOcts     = TRUE;
        SetDtrControl = TRUE;
        SetRtsControl = TRUE;
        Xon         = FALSE;
        Odsr        = FALSE;
        Octs        = FALSE;
        DtrControl = DTR_CONTROL_ENABLE;
        RtsControl = RTS_CONTROL_ENABLE;

        if (!ConvertBaudRate( GetNumber(&C), &Baud )) {
            return FALSE;
        }
        SetBaud = TRUE;
        Advance(&C);

        //
        //    A:
        //
        if ( !Match(&C, "," ) ) {
            goto Eoi;
        }
        Advance(&C);

        if ( !Match(&C, "," ) && Match(&C, "@" ) ) {

            //
            //    Parity
            //
            if (!ConvertParity( *C.MatchBegin,&Parity )) {
                return FALSE;
            }
            SetParity = TRUE;
            Advance(&C);
        }

        //
        //    B:
        //
        if ( !Match(&C, "," )) {
            goto Eoi;
        }
        Advance(&C);

        if ( Match(&C, "#" )) {

            //
            //    Data bits
            //
            if (!ConvertDataBits( GetNumber(&C),&DataBits )) {
                return FALSE;
            }
            SetDataBits = TRUE;
            Advance(&C);
        }

        //
        //    C:
        //
        if ( !Match(&C, "," )) {
            goto Eoi;
        }
        Advance(&C);

        if ( Match(&C, "1.5" ) ) {
            StopBits = ONE5STOPBITS;
            SetStopBits = TRUE;
            Advance(&C);
        } else if ( Match(&C, "#" ) ) {
            if (!ConvertStopBits( GetNumber(&C),&StopBits)) {
                return FALSE;
            }
            SetStopBits = TRUE;
            Advance(&C);
        }

        if ( !Match(&C, "," )) {
            goto Eoi;
        }

        Advance(&C);

        if ( Match(&C, "x" ) ) {

            //
            //  XON=ON
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = TRUE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_CONTROL_ENABLE;
            RtsControl = RTS_CONTROL_ENABLE;
            Advance(&C);

        } else if ( Match(&C, "p" ) ) {

            //
            //  Permanent retry - Hardware handshaking
            //

            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = TRUE;
            Octs        = TRUE;
            DtrControl = DTR_CONTROL_HANDSHAKE;
            RtsControl = RTS_CONTROL_HANDSHAKE;
            Advance(&C);

        } else {

            //
            //  XON=OFF
            //
            SetXon      = TRUE;
            SetOdsr     = TRUE;
            SetOcts     = TRUE;
            SetDtrControl = TRUE;
            SetRtsControl = TRUE;
            Xon         = FALSE;
            Odsr        = FALSE;
            Octs        = FALSE;
            DtrControl = DTR_CONTROL_ENABLE;
            RtsControl = RTS_CONTROL_ENABLE;
        }

Eoi:
        if ( *C.CharIndex != '\0' ) {

            //
            //    Error
            //
            return FALSE;

        }

    } else {

        //
        // New Form
        //

        while ( *C.CharIndex != '\0' ) {

            if ( Match(&C, "BAUD=#" ) ) {
                //
                //  BAUD=
                //
                if ( !ConvertBaudRate(GetNumber(&C), &Baud ) ) {
                    return FALSE;
                }
                SetBaud     = TRUE;
                Advance(&C);

            } else if ( Match(&C, "PARITY=@"   ) ) {
                //
                //  PARITY=
                //
                if ( !ConvertParity( *C.MatchBegin, &Parity ) ) {
                    return FALSE;
                }
                SetParity   = TRUE;
                Advance(&C);

            } else if ( Match(&C, "DATA=#" ) ) {
                //
                //  DATA=
                //
                if ( !ConvertDataBits(GetNumber(&C), &DataBits ) ) {
                    return FALSE;
                }
                SetDataBits = TRUE;
                Advance(&C);

            } else if ( Match(&C, "STOP=1.5" ) ) {
                //
                //  STOP=1.5
                //
                StopBits    =  ONE5STOPBITS;
                SetStopBits = TRUE;
                Advance(&C);

            } else if ( Match(&C, "STOP=#" ) ) {
                //
                //  STOP=
                //
                if ( !ConvertStopBits(GetNumber(&C), &StopBits ) ) {
                    return FALSE;
                }
                SetStopBits = TRUE;
                Advance(&C);

            } else if ( Match(&C, "TO=ON" ) ) {
                //
                //  TO=ON
                //
                SetTimeOut  =   TRUE;
                TimeOut     =   TRUE;
                Advance(&C);

            } else if ( Match(&C, "TO=OFF" ) ) {
                //
                //  TO=ON
                //
                SetTimeOut  =   TRUE;
                TimeOut     =   FALSE;
                Advance(&C);

            } else if ( Match(&C, "XON=ON" ) ) {
                //
                //  XON=ON
                //
                SetXon      = TRUE;
                Xon         = TRUE;
                Advance(&C);

            } else if ( Match(&C, "XON=OFF" ) ) {
                //
                //  XON=OFF
                //
                SetXon      = TRUE;
                Xon         = FALSE;
                Advance(&C);

            } else if ( Match(&C, "ODSR=ON" ) ) {
                //
                //  ODSR=ON
                //
                SetOdsr     = TRUE;
                Odsr        = TRUE;
                Advance(&C);

            } else if ( Match(&C, "ODSR=OFF" ) ) {
                //
                //  ODSR=OFF
                //
                SetOdsr     = TRUE;
                Odsr        = FALSE;
                Advance(&C);

            } else if ( Match(&C, "IDSR=ON" ) ) {
                //
                //  IDSR=ON
                //
                SetIdsr = TRUE;
                Idsr    = TRUE;
                Advance(&C);

            } else if ( Match(&C, "IDSR=OFF" ) ) {
                //
                //  IDSR=OFF
                //
                SetIdsr = TRUE;
                Idsr    = FALSE;
                Advance(&C);

            } else if ( Match(&C, "OCTS=ON" ) ) {
                //
                //  OCS=ON
                //
                SetOcts     = TRUE;
                Octs        = TRUE;
                Advance(&C);

            } else if ( Match(&C, "OCTS=OFF" ) ) {
                //
                //  OCS=OFF
                //
                SetOcts     = TRUE;
                Octs        = FALSE;
                Advance(&C);

            } else if ( Match(&C, "DTR=*"   ) ) {
                //
                //  DTR=
                //
                if ( !ConvertDtrControl(C.MatchBegin, C.MatchEnd, &DtrControl ) ) {
                    return FALSE;
                }
                SetDtrControl   = TRUE;
                Advance(&C);

            } else if ( Match(&C, "RTS=*"   ) ) {
                //
                //  RTS=
                //
                if ( !ConvertRtsControl(C.MatchBegin, C.MatchEnd, &RtsControl ) ) {
                    return FALSE;
                }
                SetRtsControl   = TRUE;
                Advance(&C);

            } else {

                return FALSE;
            }
        }

    }

    if ( SetBaud ) {
        Dcb->BaudRate = Baud;
    }

    if ( SetDataBits ) {
        Dcb->ByteSize = DataBits;
    }

    if ( SetStopBits ) {
        Dcb->StopBits = StopBits;
    } else if ( SetBaud && (Baud == 110) ) {
        Dcb->StopBits = TWOSTOPBITS;
    } else {
        Dcb->StopBits = ONESTOPBIT;
    }

    if ( SetParity ) {
        Dcb->Parity = Parity;
    }

    if ( SetXon ) {
        if ( Xon ) {
            Dcb->fInX   = TRUE;
            Dcb->fOutX  = TRUE;
        } else {
            Dcb->fInX   = FALSE;
            Dcb->fOutX  = FALSE;
        }
    }

    if ( SetOcts ) {

        if ( Octs ) {
            Dcb->fOutxCtsFlow = TRUE;
        } else {
            Dcb->fOutxCtsFlow = FALSE;
        }
    }


    if ( SetOdsr ) {
        if ( Odsr ) {
            Dcb->fOutxDsrFlow = TRUE;
        } else {
            Dcb->fOutxDsrFlow = FALSE;
        }
    }

    if ( SetIdsr ) {
        if ( Idsr ) {
            Dcb->fDsrSensitivity = TRUE;
        } else {
            Dcb->fDsrSensitivity = FALSE;
        }
    }

    if ( SetDtrControl ) {
        Dcb->fDtrControl = DtrControl;
    }

    if ( SetRtsControl ) {
        Dcb->fRtsControl = RtsControl;
    }

    if ( SetTimeOut ) {
        if (TimeOut) {
            To->ReadIntervalTimeout = 0;
            To->ReadTotalTimeoutMultiplier = 0;
            To->ReadTotalTimeoutConstant = 0;
            To->WriteTotalTimeoutMultiplier = 0;
            To->WriteTotalTimeoutConstant = 60000;
        } else {
            To->ReadIntervalTimeout = 0;
            To->ReadTotalTimeoutMultiplier = 0;
            To->ReadTotalTimeoutConstant = 0;
            To->WriteTotalTimeoutMultiplier = 0;
            To->WriteTotalTimeoutConstant = 0;
        }
    }



    return TRUE;
}

static
BOOL
Match(
    PPARSE_CONTEXT C,
    PSTR Pattern
    )

/*++

Routine Description:

    This function matches a pattern against whatever
    is in the command line at the current position.

    Note that this does not advance our current position
    within the command line.

    If the pattern has a magic character, then the
    variables C->MatchBegin and C->MatchEnd delimit the
    substring of the command line that matched that
    magic character.

Arguments:

    C - The parse context.
    Pattern - Supplies pointer to the pattern to match

Return Value:

    BOOLEAN - TRUE if the pattern matched, FALSE otherwise

Notes:

--*/

{

    PSTR    CmdIndex;       //  Index within command line
    PSTR    PatternIndex;   //  Index within pattern
    CHAR    PatternChar;    //  Character in pattern
    CHAR    CmdChar;        //  Character in command line;

    CmdIndex        = C->CharIndex;
    PatternIndex    = Pattern;

    while ( (PatternChar = *PatternIndex) != '\0' ) {

        switch ( PatternChar ) {

        case '#':

            //
            //    Match a number
            //
            C->MatchBegin = CmdIndex;
            C->MatchEnd   = C->MatchBegin;

            //
            //    Get all consecutive digits
            //
            while ( ((CmdChar = *C->MatchEnd) != '\0') &&
                    isdigit( (char)CmdChar ) ) {
                C->MatchEnd++;
            }
            C->MatchEnd--;

            if ( C->MatchBegin > C->MatchEnd ) {
                //
                //    No number
                //
                return FALSE;
            }

            CmdIndex = C->MatchEnd + 1;
            PatternIndex++;

            break;


        case '@':

            //
            //    Match one character
            //
            if ( *CmdIndex == '\0' ) {
                return FALSE;
            }

            C->MatchBegin = C->MatchEnd = CmdIndex;
            CmdIndex++;
            PatternIndex++;

            break;


        case '*':

            //
            //    Match everything up to next blank (or end of input)
            //
            C->MatchBegin    = CmdIndex;
            C->MatchEnd    = C->MatchBegin;

            while ( ( (CmdChar = *C->MatchEnd ) != '\0' )  &&
                    ( CmdChar !=  ' ' ) ) {

                C->MatchEnd++;
            }
            C->MatchEnd--;

            CmdIndex = C->MatchEnd+1;
            PatternIndex++;

            break;

        case '[':

            //
            //    Optional sequence
            //
            PatternIndex++;

            PatternChar = *PatternIndex;
            CmdChar     = *CmdIndex;

            //
            //    If the first charcter in the input does not match the
            //    first character in the optional sequence, we just
            //    skip the optional sequence.
            //
            if ( ( CmdChar == '\0' ) ||
                 ( CmdChar == ' ')             ||
                 ( toupper(CmdChar) != toupper(PatternChar) ) ) {

                while ( PatternChar != ']' ) {
                    PatternIndex++;
                    PatternChar = *PatternIndex;
                }
                PatternIndex++;

            } else {

                //
                //    Since the first character in the sequence matched, now
                //    everything must match.
                //
                while ( PatternChar != ']' ) {

                    if ( toupper(PatternChar) != toupper(CmdChar) ) {
                        return FALSE;
                    }
                    CmdIndex++;
                    PatternIndex++;
                    CmdChar = *CmdIndex;
                    PatternChar = *PatternIndex;
                }

                PatternIndex++;
            }

            break;

        default:

            //
            //    Both characters must match
            //
            CmdChar = *CmdIndex;

            if ( ( CmdChar == '\0' ) ||
                 ( toupper(CmdChar) != toupper(PatternChar) ) ) {

                return FALSE;

            }

            CmdIndex++;
            PatternIndex++;

            break;

        }
    }

    C->AdvanceIndex = CmdIndex;

    return TRUE;

}

static
VOID
Advance(
    PPARSE_CONTEXT C
    )

/*++

Routine Description:

    Advances our pointers to the beginning of the next lexeme

Arguments:

    C - The parse context.

Return Value:

    None


--*/

{

    C->CharIndex = C->AdvanceIndex;

    //
    //    Skip blank space
    //
    if ( *C->CharIndex  == ' ' ) {

        while ( *C->CharIndex  == ' ' ) {

            C->CharIndex++;
        }

    }
}

static
DWORD
GetNumber(
    PPARSE_CONTEXT C
    )

/*++

Routine Description:

    Converts the substring delimited by C->MatchBegin and C->MatchEnd into
    a number.

Arguments:

    C - The parse context

Return Value:

    ULONG - The matched string converted to a number


--*/

{
    DWORD   Number;
    CHAR    c;
    PSTR    p = C->MatchEnd+1;

    c = *p;
//    *p = '\0';
    //intf( "Making number: %s\n", C->MatchBegin );
    Number = atol( C->MatchBegin );
//    *p  = c;

    return Number;

}

static
BOOL
ConvertBaudRate (
    DWORD BaudIn,
    PDWORD BaudRate
    )

/*++

Routine Description:

    Validates a baud rate given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    BaudIn - Supplies the baud rate given by the user
    BaudRate - if returning TRUE then the baud rate to use.

Return Value:

    If a valid baud rate then returns TRUE, otherwise FALSE.

--*/

{
    switch ( BaudIn ) {

    case 11:
    case 110:
        *BaudRate = 110;
        break;

    case 15:
    case 150:
        *BaudRate = 150;
        break;

    case 30:
    case 300:
        *BaudRate = 300;
        break;

    case 60:
    case 600:
        *BaudRate = 600;
        break;

    case 12:
    case 1200:
        *BaudRate = 1200;
        break;

    case 24:
    case 2400:
        *BaudRate = 2400;
        break;

    case 48:
    case 4800:
        *BaudRate = 4800;
        break;

    case 96:
    case 9600:
        *BaudRate = 9600;
        break;

    case 19:
    case 19200:
        *BaudRate = 19200;
        break;

    default:

        *BaudRate = BaudIn;

    }

    return TRUE;
}

static
BOOL
ConvertDataBits (
    DWORD DataBitsIn,
    PBYTE DataBitsOut
    )

/*++

Routine Description:

    Validates the number of data bits given as an argument to the program,
    and converts  it to something that the COMM_DEVICE understands.

Arguments:

    DataBitsIn - Supplies the number given by the user
    DataBitsOut - if returning TRUE, then the number of data bits.

Return Value:

    If a valid data bits then TRUE, otherwise FALSE.

--*/

{

    if ( ( DataBitsIn != 5 ) &&
         ( DataBitsIn != 6 ) &&
         ( DataBitsIn != 7 ) &&
         ( DataBitsIn != 8 ) ) {

        return FALSE;

    }

    *DataBitsOut = (BYTE)DataBitsIn;

    return TRUE;

}

static
BOOL
ConvertStopBits (
    DWORD StopBitsIn,
    PBYTE StopBits
    )

/*++

Routine Description:

    Validates a number of stop bits given as an argument to the program,
    and converts it to something that the COMM_DEVICE understands.

Arguments:

    StopBitsIn - Supplies the number given by the user
    StopBits - If returning true then a valid stop bits setting.

Return Value:

    If a valid stop bits setting then TRUE, otherwise false.

--*/

{

    switch ( StopBitsIn ) {

    case 1:
        *StopBits = ONESTOPBIT;
        break;

    case 2:
        *StopBits = TWOSTOPBITS;
        break;

    default:
        return FALSE;

    }

    return TRUE;

}

static
BOOL
ConvertParity (
    CHAR ParityIn,
    PBYTE Parity
    )

/*++

Routine Description:

    Validates a parity given as an argument to the program, and converts
    it to something that the COMM_DEVICE understands.

Arguments:

    ParityIn - Supplies the baud rate given by the user
    Parity - The valid parity if return true.

Return Value:

    If a valid parity setting then TRUE otherwise false.

--*/

{

    //
    //    Set the correct parity value depending on the character.
    //
    switch ( tolower(ParityIn) ) {

    case 'n':
        *Parity = NOPARITY;
        break;

    case 'o':
        *Parity = ODDPARITY;
        break;

    case 'e':
        *Parity = EVENPARITY;
        break;

    case 'm':
        *Parity = MARKPARITY;
        break;

    case 's':
        *Parity = SPACEPARITY;
        break;

    default:
        return FALSE;

    }

    return TRUE;
}

static
BOOL
ConvertDtrControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE DtrControl
    )

/*++

Routine Description:

    Validates a DTR control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    IdxBegin - Supplies Index of first character
    IdxEnd - Supplies Index of last character
    DtrControl - If returning true, the valid dtr setting.

Return Value:

    DTR_CONTROL -   The DTR control value


--*/

{

    PSTR    p;

    p = IdxBegin;
    if ( (tolower(*p)  == 'o' ) &&
         p++                    &&
         (tolower(*p)  == 'n' ) &&
         (IdxEnd == p)) {


        *DtrControl = DTR_CONTROL_ENABLE;
        return TRUE;

    }

    p = IdxBegin;
    if ( (tolower(*p) == 'o')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         (IdxEnd == p ) ) {

        *DtrControl =  DTR_CONTROL_DISABLE;
        return TRUE;
    }

    p = IdxBegin;
    if ( (tolower(*p) == 'h')   &&
         p++                    &&
         (tolower(*p++) == 's') &&
         (IdxEnd == p ) ) {

        *DtrControl =  DTR_CONTROL_HANDSHAKE;
        return TRUE;
    }

    return FALSE;
}

static
BOOL
ConvertRtsControl (
    PSTR IdxBegin,
    PSTR IdxEnd,
    PBYTE RtsControl
    )

/*++

Routine Description:

    Validates a RTS control value given as an argument to the
    program, and converts it to something that the COMM_DEVICE
    understands.

Arguments:

    IdxBegin - Supplies Index of first character
    IdxEnd - Supplies Index of last character
    RtsControl - If returning true, the valid rts setting.

Return Value:

    RTS_CONTROL -   The RTS control value

--*/

{

    PSTR    p;
    p = IdxBegin;
    if ( (tolower(*p)  == 'o' ) &&
         p++                    &&
         (tolower(*p)  == 'n' ) &&
         (IdxEnd == p)) {


        *RtsControl = RTS_CONTROL_ENABLE;
        return TRUE;

    }

    p = IdxBegin;
    if ( (tolower(*p) == 'o')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         p++                    &&
         (tolower(*p) == 'f')   &&
         (IdxEnd == p ) ) {

        *RtsControl =  RTS_CONTROL_DISABLE;
        return TRUE;
    }

    p = IdxBegin;
    if ( (tolower(*p) == 'h')   &&
         p++                    &&
         (tolower(*p++) == 's') &&
         (IdxEnd == p ) ) {

        *RtsControl =  RTS_CONTROL_HANDSHAKE;
        return TRUE;
    }

    p = IdxBegin;
    if ( (tolower(*p) == 't')   &&
         p++                    &&
         (tolower(*p++) == 'g') &&
         (IdxEnd == p ) ) {

        *RtsControl =  RTS_CONTROL_TOGGLE;
        return TRUE;
    }

    return FALSE;

}

static
NTSTATUS
DeviceNameCompare(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

{

    PPARSE_CONTEXT C = EntryContext;
    UNICODE_STRING uniName;
    ANSI_STRING ansiName;

    RtlInitUnicodeString(
        &uniName,
        ValueData
        );

    if (!NT_SUCCESS(RtlUnicodeStringToAnsiString(
                        &ansiName,
                        &uniName,
                        TRUE
                        ))) {

        //
        // Oh well, couldn't form the name.  Just get out.
        //
        return STATUS_SUCCESS;

    }

    //
    // See if we got a name match.
    //

    if (Match(C,ansiName.Buffer)) {

        //
        // Ok, got a name match, advance past it.
        //

        Advance(C);

        //
        // See if they've got the optional : following the
        // device name.
        //

        if (Match(C,":")) {

            //
            // Go past it.
            //

            Advance(C);

        }

    }
    RtlFreeAnsiString(&ansiName);
    return STATUS_SUCCESS;

}

static
VOID
IgnoreDeviceName(
    IN PPARSE_CONTEXT C
    )

{

    RTL_QUERY_REGISTRY_TABLE qTable[2] = {0};

    //
    // Build the query table.
    //

    qTable[0].QueryRoutine = DeviceNameCompare;
    qTable[0].EntryContext = C;

    RtlQueryRegistryValues(
        RTL_REGISTRY_DEVICEMAP,
        L"SERIALCOMM",
        &qTable[0],
        NULL,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\bnd.c ===
//
// Program to test boundry conditions of APIs which take a string buffer.
// Conditions tested are strlen-1, strlen, and strlen+1
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <wchar.h>
//
// Define these to match your machine.  If these are not set properly, its
// very likely the tests will pass when they didn't deserve to. 
//
                                      // List of all logical drives

#define LOGICAL_DRIVES "a:\\\0c:\\\0"
#define LOGICAL_DRIVES_W L"a:\\\0c:\\\0"
#define LEN_LOGICAL_DRIVES 8
#define SYSTEM_DIR  "c:\\winnt\\system32"  // Where is system dir
#define SYSTEM_DIR_W  L"c:\\winnt\\system32"  // Where is system dir
#define WINDOWS_DIR "c:\\winnt"          // Where is windows dir
#define WINDOWS_DIR_W L"c:\\winnt"          // Where is windows dir
#define TEMP_DIRA   "c:\\tmp"         // For GetTempPath, env var tmp or temp
#define TEMP_DIR_WA   L"c:\\tmp"         // For GetTempPath, env var tmp or temp
#define TEMP_DIRB   "c:\\tmp\\"         // For GetTempPath, env var tmp or temp
#define TEMP_DIR_WB   L"c:\\tmp\\"         // For GetTempPath, env var tmp or temp
#define TEMP_DIRC   "c:\\"         // For GetTempPath, env var tmp or temp
#define TEMP_DIR_WC   L"c:\\"         // For GetTempPath, env var tmp or temp
#define VOLUME_NAME "MARKLTST433"        // Name of volume where c: partition is
#define VOLUME_NAME_W L"MARKLTST433"        // Name of volume where c: partition is
#define FILE_SYSTEM_NAME "FAT"        // Name of file system on c: partition
#define FILE_SYSTEM_NAME_W L"FAT"        // Name of file system on c: partition
                                      // { FAT, HPFS, NTFS }

//
// Global vars, constants and prototypes
//

#define SIGNATURE 0xf
#define SIGNATURE_W 0xaaff
#define SIZE_BUFF 128

void init_buff();
void init_buffw();
void check(DWORD retcode, DWORD size_passed, int expected_ret,BOOL shouldxfer);
void checkw(DWORD retcode, DWORD size_passed, int expected_ret,BOOL shouldxfer);

char buff[SIZE_BUFF], *cur_test;
wchar_t buffw[SIZE_BUFF];
LPSTR exp_val;
LPWSTR exp_valw;

//
// main
//

void _cdecl main(void)
{
    int   exp_len;
    int   wexp_len;
    LPSTR lpJunk;
    LPWSTR lpwJunk;
    BOOL  bRet;

    //
    // GetSystemDirectory
    //

    cur_test = "GetSystemDirectory";
    exp_len  = strlen(SYSTEM_DIR);
    exp_val = SYSTEM_DIR;
    exp_valw = SYSTEM_DIR_W;

    printf("\nGetSystemDirectory: Expected string is <%s>\n", SYSTEM_DIR);

    init_buff();
    check(GetSystemDirectory(buff, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetSystemDirectory(buff, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetSystemDirectory(buff, exp_len+1), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetSystemDirectoryW(buffw, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetSystemDirectoryW(buffw, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetSystemDirectoryW(buffw, exp_len+1), exp_len+1, exp_len,TRUE);

    //
    // GetWindowsDirectory
    //

    cur_test = "GetWindowsDirectory";
    exp_len  = strlen(WINDOWS_DIR);
    exp_val = WINDOWS_DIR;
    exp_valw = WINDOWS_DIR_W;

    printf("\nGetWindowsDirectory: Expected string is <%s>\n", WINDOWS_DIR);

    init_buff();
    check(GetWindowsDirectory(buff, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetWindowsDirectory(buff, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetWindowsDirectory(buff, exp_len+1), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetWindowsDirectoryW(buffw, exp_len-1), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetWindowsDirectoryW(buffw, exp_len),   exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetWindowsDirectoryW(buffw, exp_len+1), exp_len+1, exp_len,TRUE);

    //
    // GetLogicalDriveStrings 
    //

    cur_test = "GetLogicalDriveStrings";
    exp_len  = LEN_LOGICAL_DRIVES;
    exp_val = LOGICAL_DRIVES;
    exp_valw = LOGICAL_DRIVES_W;

    printf("\nGetLogicalDriveStrings: Expected string is <%s>\n",
           LOGICAL_DRIVES);

    init_buff();
    check(GetLogicalDriveStrings(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetLogicalDriveStrings(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetLogicalDriveStrings(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetLogicalDriveStringsW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetLogicalDriveStringsW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetLogicalDriveStringsW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    //
    // GetVolumeInformation: Be sure that does not stomp on VolumeName buffer,
    // and be sure it returns FALSE when the volume name would not fit into
    // the provided buffer
    //

    cur_test = "GetVolumeInformation 1";
    exp_len  = strlen(VOLUME_NAME);
    exp_val = VOLUME_NAME;
    exp_valw = VOLUME_NAME_W;

    printf("\nGetVolumeInformation 1: Expected string is <%s>\n", VOLUME_NAME);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                buff,      // volume name buffer
                                exp_len-1,
                                NULL, NULL, NULL, NULL, 0);

    check(bRet, exp_len-1, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                buff,      // volume name buffer
                                exp_len,
                                NULL, NULL, NULL, NULL, 0);

    check(bRet, exp_len, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                buff,      // volume name buffer
                                exp_len+1,
                                NULL, NULL, NULL, NULL, 0);
    check(bRet, exp_len+1, TRUE,TRUE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                buffw,      // volume name buffer
                                exp_len-1,
                                NULL, NULL, NULL, NULL, 0);

    checkw(bRet, exp_len-1, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                buffw,      // volume name buffer
                                exp_len,
                                NULL, NULL, NULL, NULL, 0);

    checkw(bRet, exp_len, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                buffw,      // volume name buffer
                                exp_len+1,
                                NULL, NULL, NULL, NULL, 0);
    checkw(bRet, exp_len+1, TRUE,TRUE);

    //
    // GetVolumeInformation: Be sure that does not stomp on the File system
    // name buffer this time, and be sure returns FALSE when not enough room.
    //

    cur_test = "GetVolumeInformation 2";
    exp_len  = strlen(FILE_SYSTEM_NAME);
    exp_val = FILE_SYSTEM_NAME;
    exp_valw = FILE_SYSTEM_NAME_W;

    printf("\nGetVolumeInformation 2: Expected string is <%s>\n",
            FILE_SYSTEM_NAME);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buff,      // file system name buffer, ex: FAT
                                exp_len-1);

    check(bRet, exp_len-1, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buff,      // file system name buffer, ex: FAT
                                exp_len);

    check(bRet, exp_len, FALSE,FALSE);

    init_buff();
    bRet = GetVolumeInformation("c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buff,      // file system name buffer, ex: FAT
                                exp_len+1);

    check(bRet, exp_len+1, TRUE,TRUE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buffw,      // file system name buffer, ex: FAT
                                exp_len-1);

    checkw(bRet, exp_len-1, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buffw,      // file system name buffer, ex: FAT
                                exp_len);

    checkw(bRet, exp_len, FALSE,FALSE);

    init_buffw();
    bRet = GetVolumeInformationW(L"c:\\",
                                NULL, 0, NULL, NULL, NULL,
                                buffw,      // file system name buffer, ex: FAT
                                exp_len+1);

    checkw(bRet, exp_len+1, TRUE,TRUE);

    //
    // GetEnvironmentVariable: set variable JUNK=junk and check
    //

    cur_test = "GetEnvironmentVariable";
    exp_val = "junk";
    exp_valw = L"junk";

    printf("\nGetEnvironmentVariable: Expected string is <%s>\n", "junk");

    if ( ! SetEnvironmentVariable("JUNK", "junk") ) {
        printf("Error setting environment variable\n");
        exit(1);
    }

    init_buff();
    check(GetEnvironmentVariable("JUNK", buff, 3), 3, 5,FALSE);
    init_buff();
    check(GetEnvironmentVariable("JUNK", buff, 4), 4, 5,FALSE);
    init_buff();
    check(GetEnvironmentVariable("JUNK", buff, 5), 5, 4,TRUE);

    init_buffw();
    checkw(GetEnvironmentVariableW(L"JUNK", buffw, 3), 3, 5,FALSE);
    init_buffw();
    checkw(GetEnvironmentVariableW(L"JUNK", buffw, 4), 4, 5,FALSE);
    init_buffw();
    checkw(GetEnvironmentVariableW(L"JUNK", buffw, 5), 5, 4,TRUE);


    //
    // GetCurrentDirectory: set to c:\ and check
    //

    cur_test = "GetCurrentDirectory";
    exp_val = "c:\\winnt";
    exp_valw = L"c:\\winnt";
    exp_len = strlen(exp_val);

    printf("\nGetCurrentDirectory: Expected string is <%s>\n", "c:\\winnt");

    if ( ! SetCurrentDirectory("c:\\winnt") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    init_buff();
    check(GetCurrentDirectory(exp_len-1, buff), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len, buff), exp_len, exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len-1, buffw), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len, buffw), exp_len, exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    cur_test = "GetCurrentDirectory";
    exp_val = "c:\\";
    exp_valw = L"c:\\";
    exp_len = strlen(exp_val);

    printf("\nGetCurrentDirectory: Expected string is <%s>\n", "c:\\");

    if ( ! SetCurrentDirectory("c:\\") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    init_buff();
    check(GetCurrentDirectory(exp_len-1, buff), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len, buff), exp_len, exp_len+1,FALSE);
    init_buff();
    check(GetCurrentDirectory(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len-1, buffw), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len, buffw), exp_len, exp_len+1,FALSE);
    init_buffw();
    checkw(GetCurrentDirectoryW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);


    //
    // GetFullPathName: this assumes that the current directory is c:\, which
    // was set earlier as part of the GetCurrentDirectory test.  c:\junk.txt
    // is a total of 11 chars.
    //

    cur_test = "GetFullPathName";
    exp_val = "c:\\junk.txt";
    exp_valw = L"c:\\junk.txt";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName(exp_val, exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(exp_val, exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(exp_val, exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(exp_valw, exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(exp_valw, exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(exp_valw, exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    cur_test = "GetFullPathName";
    exp_val = "\\\\.\\lpt1";
    exp_valw = L"\\\\.\\lpt1";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName("lpt1", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("lpt1", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("lpt1", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(L"lpt1", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"lpt1", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"lpt1", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    if ( ! SetCurrentDirectory("c:\\winnt\\dump") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    cur_test = "GetFullPathName";
    exp_val = "c:\\winnt\\dump";
    exp_valw = L"c:\\winnt\\dump";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName(".", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    if ( ! SetCurrentDirectory("c:\\winnt") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    cur_test = "GetFullPathName";
    exp_val = "c:\\winnt\\dump";
    exp_valw = L"c:\\winnt\\dump";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName("c:dump", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("c:dump", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName("c:dump", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);
    init_buffw();
    checkw(GetFullPathNameW(L"c:dump", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"c:dump", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L"c:dump", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);

    if ( ! SetCurrentDirectory("c:\\") ) {
        printf("Error setting cur dir\n");
        exit(1);
    }

    cur_test = "GetFullPathName";
    exp_val = "c:\\";
    exp_valw = L"c:\\";
    exp_len  = strlen(exp_val);

    printf("\nGetFullPathName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetFullPathName(".", exp_len-1, buff, &lpJunk), exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len, buff, &lpJunk), exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetFullPathName(".", exp_len+1, buff, &lpJunk), exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len-1, buffw, &lpwJunk), exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len, buffw, &lpwJunk), exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetFullPathNameW(L".", exp_len+1, buffw, &lpwJunk), exp_len+1,exp_len,TRUE);


    //
    // GetTempPath
    //

    cur_test = "GetTempPath";
    exp_len  = strlen(TEMP_DIRB);
    exp_val = TEMP_DIRB;
    exp_valw = TEMP_DIR_WB;
    if ( ! SetEnvironmentVariable("TMP", TEMP_DIRA)) {
        printf("Error setting tmp environment variable\n");
        exit(1);
    }

    printf("\nGetTempPath: Expected string is <%s>\n", TEMP_DIRB);

    init_buff();
    check(GetTempPath(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetTempPathW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    cur_test = "GetTempPath";
    exp_len  = strlen(TEMP_DIRB);
    exp_val = TEMP_DIRB;
    exp_valw = TEMP_DIR_WB;
    if ( ! SetEnvironmentVariable("TMP", TEMP_DIRB)) {
        printf("Error setting tmp environment variable\n");
        exit(1);
    }

    printf("\nGetTempPath: Expected string is <%s>\n", TEMP_DIRB);

    init_buff();
    check(GetTempPath(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetTempPathW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);

    cur_test = "GetTempPath";
    exp_len  = strlen(TEMP_DIRC);
    exp_val = TEMP_DIRC;
    exp_valw = TEMP_DIR_WC;
    if ( ! SetEnvironmentVariable("TMP", TEMP_DIRC)) {
        printf("Error setting tmp environment variable\n");
        exit(1);
    }

    printf("\nGetTempPath: Expected string is <%s>\n", TEMP_DIRC);

    init_buff();
    check(GetTempPath(exp_len-1, buff), exp_len-1, exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len,   buff), exp_len,   exp_len+1,FALSE);
    init_buff();
    check(GetTempPath(exp_len+1, buff), exp_len+1, exp_len,TRUE);

    init_buffw();
    checkw(GetTempPathW(exp_len-1, buffw), exp_len-1, exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len,   buffw), exp_len,   exp_len+1,FALSE);
    init_buffw();
    checkw(GetTempPathW(exp_len+1, buffw), exp_len+1, exp_len,TRUE);


    cur_test = "SearchPath";
    exp_len  = strlen("c:\\winnt\\system32\\kernel32.dll");
    exp_val = "c:\\winnt\\system32\\kernel32.dll";
    exp_valw = L"c:\\winnt\\system32\\kernel32.dll";

    printf("\nSearchPath: Expected string is <%s>\n", exp_val);

    init_buff();
    check(SearchPath(NULL,"kernel32",".dll",exp_len-1,buff,&lpJunk),exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(SearchPath(NULL,"kernel32",".dll",exp_len,buff,&lpJunk),exp_len,exp_len+1,FALSE);
    init_buff();
    check(SearchPath(NULL,"kernel32",".dll",exp_len+1,buff,&lpJunk),exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(SearchPathW(NULL,L"kernel32",L".dll",exp_len-1,buffw,&lpwJunk),exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(SearchPathW(NULL,L"kernel32",L".dll",exp_len,buffw,&lpwJunk),exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(SearchPathW(NULL,L"kernel32",L".dll",exp_len+1,buffw,&lpwJunk),exp_len+1,exp_len,TRUE);

    cur_test = "GetModuleFileName";
    exp_len  = strlen("c:\\winnt\\system32\\bnd.exe");
    exp_val = "c:\\winnt\\system32\\bnd.exe";
    exp_valw = L"c:\\winnt\\system32\\bnd.exe";

    printf("\nGetModuleFileName: Expected string is <%s>\n", exp_val);

    init_buff();
    check(GetModuleFileName(NULL,buff,exp_len-1),exp_len-1,exp_len+1,FALSE);
    init_buff();
    check(GetModuleFileName(NULL,buff,exp_len),exp_len,exp_len+1,FALSE);
    init_buff();
    check(GetModuleFileName(NULL,buff,exp_len+1),exp_len+1,exp_len,TRUE);

    init_buffw();
    checkw(GetModuleFileNameW(NULL,buffw,exp_len-1),exp_len-1,exp_len+1,FALSE);
    init_buffw();
    checkw(GetModuleFileNameW(NULL,buffw,exp_len),exp_len,exp_len+1,FALSE);
    init_buffw();
    checkw(GetModuleFileNameW(NULL,buffw,exp_len+1),exp_len+1,exp_len,TRUE);


}

//
// Function to init the global buffer to the SIGNATURE
//

void init_buff()
{
    int i;

    for ( i=0; i<SIZE_BUFF; i++ )
        buff[i] = SIGNATURE;

    buff[SIZE_BUFF-1] = '\0'; // to ensure its null-terminated somewhere
                              // (for debugging)
}

void init_buffw()
{
    int i;

    for ( i=0; i<SIZE_BUFF; i++ )
        buffw[i] = SIGNATURE_W;

    buffw[SIZE_BUFF-1] = 0;

}

//
// Function to check whether the API wrote past the end of the buffer, and
// whether it returned what was expected
//
// It assumes that the global vars cur_test is set and buff was used
//

void check(DWORD retcode, DWORD size_passed, int expected_ret, BOOL shouldxfer)
{

    int i;

    if ( buff[size_passed] != SIGNATURE ) {
        printf("\nFAILURE: %s wrote past end of buffer, when passed %d\n",
                cur_test, size_passed);
        return;
    }

    if ( retcode != (DWORD)expected_ret ) {
        printf("\nFAILURE: %s returned %d, expected %d, when passed %d\n",
               cur_test, retcode, expected_ret, size_passed);
        return;
    }

    if ( shouldxfer ) {
        for (i=0;i<expected_ret;i++){
            if ( toupper(buff[i]) != toupper(exp_val[i]) ) {
                printf("\nFAILURE: %s mismatch at %d",cur_test, i);
                return;
            }
        }
    }
    printf("\nPASSED:  %s when passed %d\n", cur_test, size_passed);
}


void checkw(DWORD retcode, DWORD size_passed, int expected_ret,BOOL shouldxfer)
{
    int i;
    if ( buffw[size_passed] != SIGNATURE_W ) {
        printf("\nFAILURE: %s wrote past end of buffer, when passed %d\n",
                cur_test, size_passed);
        return;
    }

    if ( retcode != (DWORD)expected_ret ) {
        printf("\nFAILURE: %s returned %d, expected %d, when passed %d\n",
               cur_test, retcode, expected_ret, size_passed);
        return;
    }

    if (shouldxfer) {
        for (i=0;i<expected_ret;i++){
            if ( towupper(buffw[i]) != towupper(exp_valw[i]) ) {
                printf("\nFAILURE: %s mismatch at %d",cur_test, i);
                return;
            }
        }
    }
    printf("\nPASSED:  %s when passed %d\n", cur_test, size_passed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\compname.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    COMPNAME.H

Abstract:

    Contains the common data structures for the Get/SetComputerName API

Author:

    Dan Hinsley  (DanHi)   16-Apr-1992

Revision History:

--*/

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\Current_Control_Set\\Services\\ComputerName"

#define NON_VOLATILE_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\Current_Control_Set\\Services\\ComputerName\\ComputerName"

#define VOLATILE_COMPUTERNAME L"ActiveComputerName"
#define NON_VOLATILE_COMPUTERNAME L"ComputerName"
#define COMPUTERNAME_VALUE_NAME L"ComputerName"
#define CLASS_STRING L"Network ComputerName"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\compstrs.c ===
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>

int main(int argc, char *argv[ ])
{

    BOOL b;
    DWORD FsFlags;
    LPSTR lp;
    HANDLE hMod;
    UINT w;
    CHAR FileName[MAX_PATH];
    HANDLE hFile;
    DWORD Nbytes;
    DWORD FileSize;
    WORD State;
    DWORD Length;
    DWORD wrap;


    b = GetVolumeInformation(NULL,NULL,0,NULL,NULL,&FsFlags,NULL,0);

    if ( !b ) {
        printf("compstrs: Failure getting volumeinformation %d\n",GetLastError());
        return 0;
        }

    if ( !(FsFlags & FS_FILE_COMPRESSION) ) {
        printf("compstrs: File system does not support per-file compression %x\n",FsFlags);
        return 0;
        }

    //
    // Get a temp file
    //

    w = GetTempFileName(".","cstr",0,FileName);
    if ( !w ) {
        printf("compstrs: unable to get temp file name\n");
        return 0;
        }

    //
    // Create the tempfile
    //

    hFile = CreateFile(
                FileName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("compstrs: failure creating %s %d\n",FileName,GetLastError());
        return 0;
        }

    //
    // Write the file that we want to compress. It is a copy of kernel32 and ntdll
    //

    hMod = GetModuleHandle("kernel32");
    if ( !hMod ) {
        printf("compstrs: failure getting handle to kernel32.dll\n");
        CloseHandle(hFile);
        DeleteFile(FileName);
        return 0;
        }

    lp = (LPSTR)hMod;

    b = TRUE;
    FileSize = 0;
    while(b) {
        b = WriteFile(hFile,lp,512, &Nbytes, NULL);
        if ( b ) {
            FileSize += Nbytes;
            lp += Nbytes;
            }
        }

    hMod = GetModuleHandle("ntdll");
    if ( !hMod ) {
        printf("compstrs: failure getting handle to ntdll\n");
        CloseHandle(hFile);
        DeleteFile(FileName);
        return 0;
        }

    lp = (LPSTR)hMod;

    b = TRUE;
    while(b) {
        b = WriteFile(hFile,lp,512, &Nbytes, NULL);
        if ( b ) {
            FileSize += Nbytes;
            lp += Nbytes;
            }
        }

    wrap = 0;
    while(1) {

        //
        // compress and de-compress this file forever
        //

        State = 1;

        b = DeviceIoControl(
                hFile,
                FSCTL_SET_COMPRESSION,
                &State,
                sizeof(WORD),
                NULL,
                0,
                &Length,
                NULL
                );
        if ( !b ) {
            printf("compstrs: compress failed %d\n",GetLastError());
            wrap = 0;
            }
        else {
            FlushFileBuffers(hFile);
            printf("C");
            wrap++;
            }

        Sleep(500);

        //
        // Decompress
        //

        State = 0;

        b = DeviceIoControl(
                hFile,
                FSCTL_SET_COMPRESSION,
                &State,
                sizeof(WORD),
                NULL,
                0,
                &Length,
                NULL
                );
        if ( !b ) {
            printf("compstrs: uncompress failed %d\n",GetLastError());
            wrap = 0;
            }
        else {
            FlushFileBuffers(hFile);
            printf("U");
            wrap++;
            }

        if ( wrap > 50 ) {
            printf("\n");
            wrap = 0;
            }
    }

    CloseHandle(hFile);
    DeleteFile(FileName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\compname.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    COMPNAME.C

Abstract:

    This module contains the GetComputerName and SetComputerName APIs.
    Also: DnsHostnameToComputerName
	  AddLocalAlternateComputerName
	  RemoveLocalAlternateComputerName
	  SetLocalPrimaryComputerName
	  EnumerateLocalComputerNames

Author:

    Dan Hinsley (DanHi)    2-Apr-1992


Revision History:

    Greg Johnson (gregjohn)  13-Feb-2001
    
Notes:

    Currently there is no way to enumerate the list of Alternate Netbios
    names.  Presumably this will be fixed in a future release (Blackcomb?).
    The flags parameter to all the *Local* API's is for this use.

--*/

#include <basedll.h>

#include <dnsapi.h>

typedef DNS_STATUS
(WINAPI DNS_VALIDATE_NAME_FN)(
    IN LPCWSTR Name,
    IN DNS_NAME_FORMAT Format
    );
//
//

#define REASONABLE_LENGTH 128

#define COMPUTERNAME_ROOT \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName"

#define NON_VOLATILE_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define VOLATILE_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
    
#define ALT_COMPUTERNAME_NODE \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters"

#define VOLATILE_COMPUTERNAME L"ActiveComputerName"
#define NON_VOLATILE_COMPUTERNAME L"ComputerName"
#define COMPUTERNAME_VALUE_NAME L"ComputerName"
#define COMPUTERNAME_OPTIONAL_NAME L"OptionalNames"
#define CLASS_STRING L"Network ComputerName"

#define TCPIP_POLICY_ROOT \
        L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\System\\DNSclient"

#define TCPIP_POLICY_DOMAINNAME \
        L"PrimaryDnsSuffix"

#define TCPIP_ROOT \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters"

#define TCPIP_HOSTNAME \
        L"Hostname"
	
#define TCPIP_NV_HOSTNAME \
        L"NV Hostname"

#define TCPIP_DOMAINNAME \
        L"Domain"

#define TCPIP_NV_DOMAINNAME \
        L"NV Domain"
	
#define DNSCACHE_ROOT \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters"
	
#define DNS_ALT_HOSTNAME \
        L"AlternateComputerNames"

//
// Allow the cluster guys to override the returned
// names with their own virtual names
//

const PWSTR ClusterNameVars[] = {
                L"_CLUSTER_NETWORK_NAME_",
                L"_CLUSTER_NETWORK_HOSTNAME_",
                L"_CLUSTER_NETWORK_DOMAIN_",
                L"_CLUSTER_NETWORK_FQDN_"
                };

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0       L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Combinations of the above
//

#define ILLEGAL_NAME_CHARS_STR  L"\"/\\[]:|<>+=;,?" CTRL_CHARS_STR

WCHAR DnsApiDllString[] = L"DNSAPI.DLL";

#define DNS_HOSTNAME 0
#define DNS_DOMAINNAME 1

DWORD
BaseMultiByteToWideCharWithAlloc(
    LPCSTR   lpBuffer,
    LPWSTR * ppBufferW
    )
/*++

Routine Description:

  Converts Ansi strings to Unicode strings and allocs it's own space.


Arguments:

  lpBuffer - Ansi to convert
  ppBufferW - Unicode result

Return Value:

  ERROR_SUCCESS, or various failures

--*/
{
    ULONG cchBuffer = 0;
    BOOL fSuccess = TRUE;

    if (lpBuffer==NULL) {
        *ppBufferW=NULL;
	return ERROR_SUCCESS;
    }

    cchBuffer = strlen(lpBuffer);
    
    // get enough space to cover the string and a trailing null
    *ppBufferW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchBuffer + 1) * sizeof(WCHAR));
    if (*ppBufferW==NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    fSuccess = MultiByteToWideChar(CP_ACP, 
			      0,
			      lpBuffer,
			      (cchBuffer+1)*sizeof(CHAR),
			      *ppBufferW,
			      cchBuffer+1
			      );
    if (fSuccess) {
	return ERROR_SUCCESS;
    }
    else {
	return GetLastError();
    }
}

DWORD
BaseWideCharToMultiByteWithAlloc(
    LPCWSTR lpBuffer,
    LPSTR * ppBufferA
    )
/*++

Routine Description:

  Converts Unicode strings to Ansi strings and allocs it's own space.


Arguments:

  lpBuffer - Unicode to convert
  ppBufferA - Ansi result

Return Value:

  ERROR_SUCCESS, or various failures

--*/
{
    ULONG cchBuffer = 0;
    DWORD err = ERROR_SUCCESS;

    cchBuffer = wcslen(lpBuffer);
    *ppBufferA = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchBuffer + 1) * sizeof(CHAR));
    if (*ppBufferA==NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    err = WideCharToMultiByte(CP_ACP, 
			      0,
			      lpBuffer,
			      cchBuffer+1,
			      *ppBufferA,
			      (cchBuffer+1)*sizeof(CHAR),
			      NULL,
			      NULL
			      );
    if (err!=0) {
	return ERROR_SUCCESS;
    }
    else {
	return GetLastError();
    }
}

VOID
BaseConvertCharFree(
    VOID * lpBuffer
    )
/*++

Routine Description:

  Frees space Convert functions.


Arguments:

  lpBuffer - Buffer to free

Return Value:

    None!

--*/
{
    if (lpBuffer!=NULL) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpBuffer);
    }
}

BOOL
BaseValidateFlags(
    ULONG ulFlags
    )
/*++

Routine Description:

  Validates unused flags.  For now the flags parameter of 
    AddLocalAlternateComputerName*
    RemoveLocalAlternateComputerName*
    EnumerateLocalAlternateComputerName*
    SetLocalPrimaryComputerName*
  are all reserved and should be 0.  In subsequent releases
  this function should change to check for a mask of valid
  flags.   

Arguments:

  ulFlags - 

Return Value:

    BOOL

--*/
{
    if (ulFlags!=0) {
	return FALSE;
    }
    return TRUE;
}

BOOL
BaseValidateNetbiosName(
    IN LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Checks that the input is an acceptable Netbios name.

Arguments:

    lpComputerName - name to validate  

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG cchComputerName;
    ULONG AnsiComputerNameLength;

    cchComputerName = wcslen(lpComputerName);

    //
    // The name length limitation should be based on ANSI. (LanMan compatibility)
    // 

    NtStatus = RtlUnicodeToMultiByteSize(&AnsiComputerNameLength,
                                         (LPWSTR)lpComputerName,
                                         cchComputerName * sizeof(WCHAR));

    if ((!NT_SUCCESS(NtStatus)) ||
        (AnsiComputerNameLength == 0 )||(AnsiComputerNameLength > MAX_COMPUTERNAME_LENGTH)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for illegal characters; return an error if one is found
    //

    if (wcscspn(lpComputerName, ILLEGAL_NAME_CHARS_STR) < cchComputerName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for leading or trailing spaces
    //

    if (lpComputerName[0] == L' ' ||
        lpComputerName[cchComputerName-1] == L' ') {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);

    }

    return(TRUE);
}

BOOL
BaseValidateDnsNames(
    LPCWSTR lpDnsHostname
    )
/*++

Routine Description:

    Checks that the inputted name is an acceptable Dns hostname.


Arguments:

    lpDnsHostName - name to validate  

Return Value:

    BOOL, GetLastError

--*/
{

    HANDLE DnsApi ;
    DNS_VALIDATE_NAME_FN * DnsValidateNameFn ;
    DNS_STATUS DnsStatus ;

    DnsApi = LoadLibraryW(DnsApiDllString);

    if ( !DnsApi ) {
	SetLastError(ERROR_DLL_NOT_FOUND);
	return FALSE ;
    }

    DnsValidateNameFn = (DNS_VALIDATE_NAME_FN *) GetProcAddress( DnsApi, "DnsValidateName_W" );

    if ( !DnsValidateNameFn )
    {
        FreeLibrary( DnsApi );
	SetLastError(ERROR_INVALID_DLL);
        return FALSE ;
    }

    DnsStatus = DnsValidateNameFn( lpDnsHostname, DnsNameHostnameLabel );

    FreeLibrary( DnsApi );

    if ( ( DnsStatus == 0 ) ||
         ( DnsStatus == DNS_ERROR_NON_RFC_NAME ) )
    {
	return TRUE;
    }
    else
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
}

DWORD 
BasepGetMultiValueAddr(
    IN LPWSTR       lpMultiValue,
    IN DWORD        dwIndex,
    OUT LPWSTR *    ppFound,
    OUT LPDWORD     pcchIndex
    )
/*++

Routine Description:

    Given an index into a Multivalued register (string), return
    the string at that index (not a copy), and it's char count location in the 
    full multivalued string

Arguments:

    lpMultiValue - the register string (returned from NtQueryKey)
    dwIndex - the index of which string to return
    ppFound - the string found (if found) - user shouldn't free
    pcchIndex - the location in lpMultiValue (in characters) of ppFound

Return Value:

    ERROR (ERROR_NOT_FOUND if not found)

--*/
{
    DWORD i = 0;
    DWORD err = ERROR_SUCCESS;
    DWORD cchTempIndex = 0;

    // lpMultiValue is a concatenated string of (non-null)strings, null terminated
    for (i=0; (i<dwIndex) && (lpMultiValue[0] != L'\0'); i++) {
	cchTempIndex += wcslen(lpMultiValue) + 1;
	lpMultiValue += wcslen(lpMultiValue) + 1;
    }
    
    // if we found the correct index, it's in lpMultiValue
    if (lpMultiValue[0]!=L'\0') {
	*ppFound = lpMultiValue;
	*pcchIndex = cchTempIndex;
	err = ERROR_SUCCESS; 
    }
    else {
	err = ERROR_NOT_FOUND;
    }

    return err;
}

DWORD 
BaseGetMultiValueIndex(
    IN LPWSTR   lpMultiValue,
    IN LPCWSTR  lpValue,
    OUT DWORD * pcchIndex
    )
/*++

Routine Description:

    Given a Multivalued register (string), and lpValue, return
    the index of lpValue in lpMultiValue (ie, the 0th string, the 1st, etc).

Arguments:

    lpMultiValue -  the register string (returned from NtQueryKey)
    lpValue - the string for which to search
    pcchIndex - the index of the string matched (if found)

Return Value:

    ERROR (ERROR_NOT_FOUND if not found)

--*/
{
    LPWSTR lpFound = NULL;
    DWORD cchFoundIndex = 0;
    DWORD i = 0;
    DWORD err = ERROR_SUCCESS;
    BOOL fFound = FALSE;
   
    while ((err==ERROR_SUCCESS) && !fFound) {
	err = BasepGetMultiValueAddr(lpMultiValue,
				   i,
				   &lpFound,
				   &cchFoundIndex);
	if (err == ERROR_SUCCESS) { 
	    if ((wcslen(lpFound)==wcslen(lpValue)) && (!_memicmp(lpFound,lpValue, wcslen(lpValue)*sizeof(WCHAR)))) {
		fFound = TRUE;
		*pcchIndex = i;
	    }
	}
	i++;
    }
    return err;
}

DWORD 
BaseRemoveMultiValue(
    IN OUT LPWSTR    lpMultiValue,
    IN DWORD         dwIndex,
    IN OUT LPDWORD   pcchMultiValue
    )
/*++

Routine Description:

    Given a multivalued registry value, and an index, it removes the string
    located at that index.

Arguments:

    lpMultiValue - the register string (returned from NtQueryKey)
    dwIndex - the index of which string to remove
    pcchMultiValue - number of chars in lpMultiValue (before and after)

Return Value:

    ERRORS

--*/
{
    DWORD err = ERROR_SUCCESS;
    LPWSTR lpRest = NULL;
    LPWSTR lpFound = NULL;
    DWORD dwIndexFound = 0;
    DWORD dwIndexRest = 0;

    err = BasepGetMultiValueAddr(lpMultiValue,
			       dwIndex,
			       &lpFound,
			       &dwIndexFound);
    if (err==ERROR_SUCCESS) {
	// lpFound is a pointer to a string
	// inside of lpMultiValue, to delete it,
	// copy the rest of the string down
	err = BasepGetMultiValueAddr(lpMultiValue,
				   dwIndex+1,
				   &lpRest,
				   &dwIndexRest);
	if (err == ERROR_SUCCESS) {
	    // copy everything down

	    memmove(lpFound,lpRest,(*pcchMultiValue - dwIndexRest)*sizeof(WCHAR));
	    *pcchMultiValue = *pcchMultiValue - (dwIndexRest-dwIndexFound);
	    lpMultiValue[*pcchMultiValue] = L'\0';
	}
	else if (err == ERROR_NOT_FOUND) {
	    // string to remove is last string, simply write an extra null to orphan the string 
	    *pcchMultiValue = *pcchMultiValue - (wcslen(lpFound) +1);
	    lpMultiValue[*pcchMultiValue] = L'\0';
	    err = ERROR_SUCCESS;
	} 
    }
    return err;
}

DWORD 
BaseAddMultiValue(
    IN OUT LPWSTR    lpMultiValue,
    IN LPCWSTR       lpValue,
    IN DWORD         cchMultiValue
    )
/*++

Routine Description:

    Given a multivalued registry value, add another value.

Arguments:

    lpMultiValue - the multivalued string (must be big enough to 
		    hold current values + lpValue plus extra NULL
    lpValue - the value to add
    cchMultiValue - the count of characters USED in lpMultivalue
                    (not counting final null)

Return Value:

    ERRORS

--*/
{
    memcpy(lpMultiValue + cchMultiValue, lpValue, (wcslen(lpValue)+1)*sizeof(WCHAR));
    lpMultiValue[cchMultiValue + wcslen(lpValue) + 1] = L'\0';

    return ERROR_SUCCESS;
}

NTSTATUS
BasepGetNameFromReg(
    PCWSTR Path,
    PCWSTR Value,
    PWSTR Buffer,
    PDWORD Length
    )
/*++

Routine Description:

  This routine gets a string from the value at the specified registry key.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to retrieve

  Buffer - Buffer to return the value

  Length - size of the buffer in characters

Return Value:

  STATUS_SUCCESS, or various failures

--*/

{
    NTSTATUS Status ;
    HANDLE Key ;
    OBJECT_ATTRIBUTES ObjA ;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;


    BYTE ValueBuffer[ REASONABLE_LENGTH ];
    PKEY_VALUE_FULL_INFORMATION pKeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    BOOLEAN FreeBuffer = FALSE ;
    DWORD ValueLength;
    PWCHAR pTerminator;

    //
    // Open the node for the Subkey
    //

    RtlInitUnicodeString(&KeyName, Path );

    InitializeObjectAttributes(&ObjA,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    Status = NtOpenKey(&Key, KEY_READ, &ObjA );

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString( &ValueName, Value );

        Status = NtQueryValueKey(Key,
                                   &ValueName,
                                   KeyValueFullInformation,
                                   pKeyValueInformation,
                                   REASONABLE_LENGTH ,
                                   &ValueLength);

        if ( Status == STATUS_BUFFER_OVERFLOW )
        {
            pKeyValueInformation = RtlAllocateHeap( RtlProcessHeap(),
                                                    0,
                                                    ValueLength );

            if ( pKeyValueInformation )
            {
                FreeBuffer = TRUE ;

                Status = NtQueryValueKey( Key,
                                          &ValueName,
                                          KeyValueFullInformation,
                                          pKeyValueInformation,
                                          ValueLength,
                                          &ValueLength );

            }
        }

        if ( NT_SUCCESS(Status) ) {

            //
            // If the user's buffer is big enough, move it in
            // First see if it's null terminated.  If it is, pretend like
            // it's not.
            //

            pTerminator = (PWCHAR)((PBYTE) pKeyValueInformation +
                pKeyValueInformation->DataOffset +
                pKeyValueInformation->DataLength);
            pTerminator--;

            if (*pTerminator == L'\0') {
               pKeyValueInformation->DataLength -= sizeof(WCHAR);
            }

            if ( ( *Length >= pKeyValueInformation->DataLength/sizeof(WCHAR) + 1) &&
                 ( Buffer != NULL ) ) {
               //
               // This isn't guaranteed to be NULL terminated, make it so
               //
                    RtlCopyMemory(Buffer,
                        (LPWSTR)((PBYTE) pKeyValueInformation +
                        pKeyValueInformation->DataOffset),
                        pKeyValueInformation->DataLength);

                    pTerminator = (PWCHAR) ((PBYTE) Buffer +
                        pKeyValueInformation->DataLength);
                    *pTerminator = L'\0';

                    //
                    // Return the number of characters to the caller
                    //

                    *Length = pKeyValueInformation->DataLength / sizeof(WCHAR) ;

            }
            else {
                Status = STATUS_BUFFER_OVERFLOW;
                *Length = pKeyValueInformation->DataLength/sizeof(WCHAR) + 1;
            }

        }

        NtClose( Key );
    }

    if ( FreeBuffer )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInformation );
    }

    return Status ;

}

NTSTATUS
BaseSetNameInReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

  This routine sets a string in the value at the registry key.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to set

  Buffer - Buffer to set

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    ULONG ValueLength;

    //
    // Open the ComputerName\ComputerName node
    //

    RtlInitUnicodeString(&KeyName, Path);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ | KEY_WRITE, &ObjectAttributes);

    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus ;
    }

    //
    // Update the value under this key
    //

    RtlInitUnicodeString(&ValueName, Value);

    ValueLength = (wcslen( Buffer ) + 1) * sizeof(WCHAR);

    NtStatus = NtSetValueKey(hKey,
                             &ValueName,
                             0,
			     REG_SZ,
                             (LPWSTR) Buffer,
                             ValueLength);

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtFlushKey( hKey );
    }

    NtClose(hKey);

    return NtStatus ;
}


NTSTATUS
BaseSetMultiNameInReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer,
    DWORD  BufferSize
    )
/*++

Routine Description:

  This routine sets a string in the value at the specified multivalued registry key.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to set

  Buffer - Buffer to set

  BufferSize - Size of the buffer in characters
	       This is needed since there can be
	       many nulls in the buffer which we
	       want to write

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
   
    //
    // Open the ComputerName\ComputerName node
    //

    RtlInitUnicodeString(&KeyName, Path);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtCreateKey(&hKey, 
			   KEY_READ | KEY_WRITE, 
			   &ObjectAttributes,
			   0,
			   NULL,
			   0,
			   NULL);

    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus ;
    }

    //
    // Update the value under this key
    //

    RtlInitUnicodeString(&ValueName, Value);

    NtStatus = NtSetValueKey(hKey,
                             &ValueName,
                             0,
                             REG_MULTI_SZ,
                             (LPWSTR) Buffer,
                             BufferSize);

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtFlushKey( hKey );
    }

    NtClose(hKey);

    return NtStatus ;
}

NTSTATUS
BaseCreateMultiValue(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

  Create a multivalued registry value and initialize it with Buffer.


Arguments:

  Path - Path to the registry key

  Value - Name of the value to set

  Buffer - Buffer to set

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpMultiValue = NULL;

    lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG ( TMP_TAG ), (wcslen(Buffer)+2)*sizeof(WCHAR));
    if (lpMultiValue==NULL) {
	NtStatus = STATUS_NO_MEMORY;
    }
    else { 
	memcpy(lpMultiValue, Buffer, wcslen(Buffer)*sizeof(WCHAR));
	lpMultiValue[wcslen(Buffer)] = L'\0';
	lpMultiValue[wcslen(Buffer)+1] = L'\0';
	NtStatus = BaseSetMultiNameInReg(Path,
					 Value,
					 lpMultiValue,
					 (wcslen(Buffer)+2)*sizeof(WCHAR));
	RtlFreeHeap(RtlProcessHeap(), 0, lpMultiValue);
    }
    return NtStatus;
}

NTSTATUS
BaseAddMultiNameInReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

  This routine adds a string to the values at the specified multivalued registry key.
  If the value already exists in the key, it does nothing.

Arguments:

  Path - Path to the registry key

  Value - Name of the value

  Buffer - Buffer to add

Return Value:

  STATUS_SUCCESS, or various failures

--*/
{
    
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpMultiValue = NULL;
    ULONG  cchMultiValue = 0;
    DWORD dwIndex = 0;
    DWORD err = ERROR_SUCCESS;

    NtStatus = BasepGetNameFromReg(Path,
				   Value,
				   lpMultiValue,
				   &cchMultiValue);

    if ( NtStatus==STATUS_NOT_FOUND || NtStatus==STATUS_OBJECT_NAME_NOT_FOUND) {
	// create it, then we are done
	NtStatus = BaseCreateMultiValue(Path,Value,Buffer);
	return NtStatus;
    } else if ( NtStatus==STATUS_BUFFER_OVERFLOW ) {
	lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchMultiValue+2+wcslen(Buffer))*sizeof(WCHAR));
	if (lpMultiValue==NULL) {
	    NtStatus = STATUS_NO_MEMORY;
	}
	else {
	    NtStatus = BasepGetNameFromReg(Path,
					   Value,
					   lpMultiValue,
					   &cchMultiValue);
	}
    } 

    if (NT_SUCCESS( NtStatus)) {
	// does it already exist in this structure?  
	err = BaseGetMultiValueIndex(lpMultiValue,
				     Buffer, &dwIndex);

	// if err==ERROR_SUCCESS, then the above function found the string already in the value.
	// don't add a duplicate
	if (err!=ERROR_SUCCESS) {

	    err = BaseAddMultiValue(lpMultiValue, Buffer, cchMultiValue);
	       
	    if (err == ERROR_SUCCESS) {
		NtStatus = BaseSetMultiNameInReg(Path, Value, lpMultiValue, (cchMultiValue+2+wcslen(Buffer))*sizeof(WCHAR));
	    }
	}
    }

    if (lpMultiValue) {
	RtlFreeHeap( RtlProcessHeap(), 0, lpMultiValue);
    }
    return NtStatus ;

}


NTSTATUS
BaseRemoveMultiNameFromReg(
    PCWSTR Path,
    PCWSTR Value,
    PCWSTR Buffer
    )
/*++

Routine Description:

    Removes a name from a multivalued registry.  If the value exists more than once in the
    list, removes them all.  

Arguments:
 
  Path - Path to the registry key

  Value - Name of the value

  Buffer - Buffer to remove

Return Value:

    ERRORS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD err = ERROR_SUCCESS;
    DWORD dwIndex = 0;
    LPWSTR lpMultiValue = NULL;
    ULONG  cchNames = 0;
    BOOL fNameRemoved = FALSE;

    NtStatus = BasepGetNameFromReg(Path,
				   Value,
				   lpMultiValue,
				   &cchNames);

    if (NtStatus==STATUS_BUFFER_OVERFLOW) {
	lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchNames) * sizeof(WCHAR));
	if (lpMultiValue==NULL) {
	    NtStatus = STATUS_NO_MEMORY;
	}
	else { 
	    NtStatus = BasepGetNameFromReg(Path,
					   Value,
					   lpMultiValue,
					   &cchNames);
	    err = RtlNtStatusToDosError(NtStatus);
	    if (err == ERROR_SUCCESS) {
		// search for and remove all values in structure 
		while (err==ERROR_SUCCESS) { 
		    err = BaseGetMultiValueIndex(lpMultiValue,
						 Buffer,
						 &dwIndex);
		    if (err == ERROR_SUCCESS) {
			err = BaseRemoveMultiValue(lpMultiValue,
						   dwIndex,
						   &cchNames);
			fNameRemoved = TRUE;
		    }
		}
		// if we removed a name, write it to the registry...
		if (fNameRemoved) {
		    NtStatus = BaseSetMultiNameInReg(
			Path,
			Value,
			lpMultiValue,
			(cchNames+1)*sizeof(WCHAR));  
		} 
		else {
		    // Nothing to remove! ERRROR
		    NtStatus = STATUS_NOT_FOUND;
		    
		}
	    }
	    RtlFreeHeap(RtlProcessHeap(), 0, lpMultiValue);
	}
    }
    return NtStatus;
}

BOOL
BaseSetNetbiosName(
    IN LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Sets the computer's net bios name  

Arguments:
 
  lpComputerName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus ;

    //
    // Validate that the supplied computername is valid (not too long,
    // no incorrect characters, no leading or trailing spaces)
    //

    if (!BaseValidateNetbiosName(lpComputerName)) {
	return(FALSE);
    }

    //
    // Open the ComputerName\ComputerName node
    //

    NtStatus = BaseSetNameInReg( NON_VOLATILE_COMPUTERNAME_NODE,
                                 COMPUTERNAME_VALUE_NAME,
                                 lpComputerName );

    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );

        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseSetDnsName(
    LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Sets the computer's Dns hostname  

Arguments:
 
  lpComputerName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{

    UNICODE_STRING NewComputerName ;
    UNICODE_STRING DnsName ;
    NTSTATUS Status ;
    BOOL Return ;
    HANDLE DnsApi ;
    DNS_VALIDATE_NAME_FN * DnsValidateNameFn ;
    DNS_STATUS DnsStatus ;

    DnsApi = LoadLibraryW(DnsApiDllString);

    if ( !DnsApi )
    {
        return FALSE ;
    }

    DnsValidateNameFn = (DNS_VALIDATE_NAME_FN *) GetProcAddress( DnsApi, "DnsValidateName_W" );

    if ( !DnsValidateNameFn )
    {
        FreeLibrary( DnsApi );

        return FALSE ;
    }

    DnsStatus = DnsValidateNameFn( lpComputerName, DnsNameHostnameLabel );

    FreeLibrary( DnsApi );

    if ( ( DnsStatus == 0 ) ||
         ( DnsStatus == DNS_ERROR_NON_RFC_NAME ) )
    {
        Status = BaseSetNameInReg( TCPIP_ROOT,
                                   TCPIP_NV_HOSTNAME,
                                   lpComputerName );
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        RtlInitUnicodeString( &DnsName, lpComputerName );

        Status = RtlDnsHostNameToComputerName( &NewComputerName,
                                               &DnsName,
                                               TRUE );

        if ( NT_SUCCESS( Status ) )
        {
            Return = BaseSetNetbiosName( NewComputerName.Buffer );

            RtlFreeUnicodeString( &NewComputerName );

            if ( !Return )
            {
                //
                // What?  Rollback?
                //

                return FALSE ;
            }

            return TRUE ;
        }
    }

    BaseSetLastNTError( Status ) ;

    return FALSE ;
}

BOOL
BaseSetDnsDomain(
    LPCWSTR lpName
    )
/*++

Routine Description:

    Sets the computer's Dns domain name  

Arguments:
 
  lpName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS Status ;
    HANDLE DnsApi ;
    DNS_VALIDATE_NAME_FN * DnsValidateNameFn ;
    DNS_STATUS DnsStatus ;

    //
    // Special case the empty string, which is legal, but not according to dnsapi
    //

    if ( *lpName )
    {
        DnsApi = LoadLibraryW(DnsApiDllString);

        if ( !DnsApi )
        {
            return FALSE ;
        }

        DnsValidateNameFn = (DNS_VALIDATE_NAME_FN *) GetProcAddress( DnsApi, "DnsValidateName_W" );

        if ( !DnsValidateNameFn )
        {
            FreeLibrary( DnsApi );

            return FALSE ;
        }

        DnsStatus = DnsValidateNameFn( lpName, DnsNameDomain );

        FreeLibrary( DnsApi );
    }
    else
    {
        DnsStatus = 0 ;
    }

    //
    // If the name is good, then keep it.
    //


    if ( ( DnsStatus == 0 ) ||
         ( DnsStatus == DNS_ERROR_NON_RFC_NAME ) )
    {
        Status = BaseSetNameInReg(
                        TCPIP_ROOT,
                        TCPIP_NV_DOMAINNAME,
                        lpName );
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER ;
    }



    if ( !NT_SUCCESS( Status ) )
    {
        BaseSetLastNTError( Status );

        return FALSE ;
    }
    return TRUE ;

}

BOOL
BaseSetAltNetBiosName(
    IN LPCWSTR lpComputerName
    )
/*++

Routine Description:

    Sets the computer's alternate net bios name  

Arguments:
 
  lpComputerName - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (!BaseValidateNetbiosName(lpComputerName)) {
	BaseSetLastNTError( STATUS_INVALID_PARAMETER );
	return(FALSE);
    }

    NtStatus = BaseAddMultiNameInReg( 
	ALT_COMPUTERNAME_NODE,
	COMPUTERNAME_OPTIONAL_NAME,
	lpComputerName );

    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseSetAltDnsFQHostname(
    IN LPCWSTR lpDnsFQHostname
    )
/*++

Routine Description:

    Sets the computer's alternate fully qualified Dns name  

Arguments:
 
  lpDnsFQHostname - name to set

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = BaseAddMultiNameInReg(
	DNSCACHE_ROOT,
	DNS_ALT_HOSTNAME,  
	lpDnsFQHostname);

    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseIsAltDnsFQHostname(
    LPCWSTR lpAltDnsFQHostname
    )
/*++

Routine Description:

    Verifies if lpAltDnsFQHostname is a previosly defined
    alternate dns name  

Arguments:
 
  lpDnsFQHostname - name to check

Return Value:

    TRUE if verifiably in use, FALSE otherwise, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpNames = NULL;
    ULONG cchNames = 0;
    BOOL fFound = FALSE;
    DWORD dwIndex = 0;
    DWORD err = ERROR_SUCCESS;

    NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT,
				   DNS_ALT_HOSTNAME,
				   lpNames,
				   &cchNames);

    if (NtStatus==STATUS_BUFFER_OVERFLOW) {
	lpNames = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchNames) * sizeof(WCHAR));
	if (lpNames!=NULL) { 
	    NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT,
					   DNS_ALT_HOSTNAME,
					   lpNames,
					   &cchNames);
	    err = RtlNtStatusToDosError(NtStatus);
	    if (err == ERROR_SUCCESS) {

		err = BaseGetMultiValueIndex(lpNames,
					     lpAltDnsFQHostname,
					     &dwIndex);
		fFound = err==ERROR_SUCCESS; 
	    }
	    RtlFreeHeap( RtlProcessHeap(), 0, lpNames);
	}
    }
    return fFound;
}

BOOL
BaseRemoveAltNetBiosName(
    IN LPCWSTR lpAltComputerName
    )
/*++

Routine Description:

    Removes an alternate net bios name  

Arguments:
 
    lpAltComputerName - name to remove

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = BaseRemoveMultiNameFromReg ( ALT_COMPUTERNAME_NODE,
					    COMPUTERNAME_OPTIONAL_NAME,
					    lpAltComputerName );
    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

BOOL
BaseRemoveAltDnsFQHostname(
    IN LPCWSTR lpAltDnsFQHostname
    )
/*++

Routine Description:

    Removes an alternate Dns hostname  

Arguments:
 
    lpAltDnsFqHostname - name to remove

Return Value:

    BOOL, GetLastError()

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = BaseRemoveMultiNameFromReg ( DNSCACHE_ROOT,
					 DNS_ALT_HOSTNAME,
					 lpAltDnsFQHostname );
    
    if ( !NT_SUCCESS( NtStatus ))
    {
        BaseSetLastNTError( NtStatus );
        return FALSE ;
    }

    return TRUE ;
}

DWORD
BaseEnumAltDnsFQHostnames(
    OUT LPWSTR lpAltDnsFQHostnames,
    IN OUT LPDWORD nSize
    )

/*++

Routine Description:

   Wrapper for BasepGetNameFromReg to return ERRORS, instead of STATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    status = BasepGetNameFromReg(
	DNSCACHE_ROOT,
	DNS_ALT_HOSTNAME,  
	lpAltDnsFQHostnames,
	nSize);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
	if ((lpAltDnsFQHostnames!=NULL) && (*nSize>0)) {
	    lpAltDnsFQHostnames[0]=L'\0';
	    *nSize=0;
	    status=STATUS_SUCCESS;
	}
	else {
	    *nSize=1;
	    status=STATUS_BUFFER_OVERFLOW;
	} 
    }

    return RtlNtStatusToDosError(status);
}

LPWSTR
BaseParseDnsName(
    IN LPCWSTR lpDnsName,
    IN ULONG NamePart
    )
/*++

Routine Description:

  Given a dns name, parse out either the hostname or the domain name. 

Arguments:

    lpDnsName - a dns name, of the form hostname.domain - domain name optional
    NamePart - DNS_HOSTNAME or DNS_DOMAINNAME
    
Return Value:

    String requested

--*/
{

    DWORD cchCharIndex = 0;
    ULONG cchName = 0;
    LPWSTR lpName = NULL;

    if (lpDnsName==NULL) {
	return NULL;
    }
    
    cchCharIndex = wcscspn(lpDnsName, L".");

    if (NamePart==DNS_HOSTNAME) {
	cchName = cchCharIndex;
    }
    else {
	if (cchCharIndex==wcslen(lpDnsName)) {
	    // no period found, 
	    cchName = 0;
	}
	else {
	    cchName =  wcslen(lpDnsName)-(cchCharIndex+1);
	}
    }

    lpName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (cchName + 1)*sizeof(WCHAR));
    if (lpName==NULL) {
	return NULL; 
    }

    // copy the correct part into the structure
    if (NamePart==DNS_HOSTNAME) {
	wcsncpy(lpName, lpDnsName, cchName);
    }
    else {
	wcsncpy(lpName, (LPWSTR)(lpDnsName + cchCharIndex + 1), cchName); 
    }
    lpName[cchName] = L'\0';

    return lpName;
}

BOOL
BaseIsNetBiosNameInUse(
    LPWSTR lpCompName
    )
/*++

Routine Description:

  Verify whether lpCompName is being used by any alternate DNS names 
  (ie whether any existing alternate DNS names map to lpCompName with 
  DnsHostnameToComputerNameW) 

Arguments:

    lpCompName - net bios name to verify
    
Return Value:

    FALSE if verifiably is not being used, true otherwise, GetLastError()    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpMultiValue = NULL;
    ULONG cchMultiValue = 0;
    LPWSTR lpAltDnsFQHostname = NULL;
    ULONG cchAltDnsHostname = 0;
    DWORD dwIndex = 0;
    LPWSTR lpAltCompName = NULL;
    ULONG cchAltCompName = 0;
    DWORD err = ERROR_SUCCESS;
    BOOL fInUse = FALSE;
    BOOL fIsNetBiosNameInUse = TRUE;

    NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT, 
			DNS_ALT_HOSTNAME, 
			lpMultiValue, 
			&cchMultiValue);
    err = RtlNtStatusToDosError(NtStatus);
    if (err==ERROR_MORE_DATA) {
	lpMultiValue = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchMultiValue * sizeof(WCHAR));
	if (lpMultiValue==NULL) {
	    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	    return TRUE;
	}
	NtStatus = BasepGetNameFromReg(DNSCACHE_ROOT,
				       DNS_ALT_HOSTNAME,
				       lpMultiValue,
				       &cchMultiValue);
	err=RtlNtStatusToDosError(NtStatus);
    }
    if (err == ERROR_SUCCESS) {
	dwIndex = 0;
	while (err == ERROR_SUCCESS) { 
	    err = BasepGetMultiValueAddr(lpMultiValue,
				       dwIndex,
				       &lpAltDnsFQHostname,
				       &cchAltDnsHostname);

	    // get net bios names
	    if (err == ERROR_SUCCESS) {
		if (!DnsHostnameToComputerNameW(lpAltDnsFQHostname,
						      lpAltCompName,
						      &cchAltCompName)) {
		    err = GetLastError();
		    if (err==ERROR_MORE_DATA) {
			// DnsHostNameToComputerNameW bug
			cchAltCompName += 1;
			// DnsHostNameToComputerNameW bug

			lpAltCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchAltCompName*sizeof(WCHAR));
			if (lpAltCompName==NULL) {
			    err = ERROR_NOT_ENOUGH_MEMORY;
			}
			else {
			    if (!DnsHostnameToComputerNameW(lpAltDnsFQHostname, lpAltCompName, &cchAltCompName)) {
				err = GetLastError();
			    } else {
				err = ERROR_SUCCESS;
			    }
			}
		    }  
		}
		if (err==ERROR_SUCCESS) {
		    if (!_wcsicmp(lpAltCompName, lpCompName)) {
			fInUse = TRUE;
		    }
		}
	    }
	    dwIndex++;
	}
	
	// exits the above while loop when err==ERROR_NOT_FOUND, whether found or not
	if (err==ERROR_NOT_FOUND) {
	    fIsNetBiosNameInUse = fInUse;
	    err = ERROR_SUCCESS;
	}
	else {
	    // error, default to in use
	    fIsNetBiosNameInUse = TRUE;
	}
    }

    if (lpMultiValue) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpMultiValue);
    }
    if (lpAltCompName) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpAltCompName);
    }
    return fIsNetBiosNameInUse;
}

//
// Worker routine
//

NTSTATUS
GetNameFromValue(
    HANDLE hKey,
    LPWSTR SubKeyName,
    LPWSTR ValueValue,
    LPDWORD nSize
    )

/*++

Routine Description:

  This returns the value of "ComputerName" value entry under the subkey
  SubKeyName relative to hKey.  This is used to get the value of the
  ActiveComputerName or ComputerName values.


Arguments:

    hKey       - handle to the Key the SubKey exists under

    SubKeyName - name of the subkey to look for the value under

    ValueValue - where the value of the value entry will be returned

    nSize      - pointer to the size (in characters) of the ValueValue buffer

Return Value:


--*/
{

#define VALUE_BUFFER_SIZE (sizeof(KEY_VALUE_FULL_INFORMATION) + \
    (sizeof( COMPUTERNAME_VALUE_NAME ) + MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR))

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hSubKey;
    BYTE ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_FULL_INFORMATION pKeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    DWORD ValueLength;
    PWCHAR pTerminator;

    //
    // Open the node for the Subkey
    //

    RtlInitUnicodeString(&KeyName, SubKeyName);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              hKey,
                              NULL
                              );

    NtStatus = NtOpenKey(&hSubKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(NtStatus)) {

        RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);

        NtStatus = NtQueryValueKey(hSubKey,
                                   &ValueName,
                                   KeyValueFullInformation,
                                   pKeyValueInformation,
                                   VALUE_BUFFER_SIZE,
                                   &ValueLength);

        NtClose(hSubKey);

        if (NT_SUCCESS(NtStatus) && 
            (pKeyValueInformation->DataLength > 0 )) {

            //
            // If the user's buffer is big enough, move it in
            // First see if it's null terminated.  If it is, pretend like
            // it's not.
            //

            pTerminator = (PWCHAR)((PBYTE) pKeyValueInformation +
                pKeyValueInformation->DataOffset +
                pKeyValueInformation->DataLength);
            pTerminator--;

            if (*pTerminator == L'\0') {
               pKeyValueInformation->DataLength -= sizeof(WCHAR);
            }

            if (*nSize >= pKeyValueInformation->DataLength/sizeof(WCHAR) + 1) {
               //
               // This isn't guaranteed to be NULL terminated, make it so
               //
                    RtlCopyMemory(ValueValue,
                        (LPWSTR)((PBYTE) pKeyValueInformation +
                        pKeyValueInformation->DataOffset),
                        pKeyValueInformation->DataLength);

                    pTerminator = (PWCHAR) ((PBYTE) ValueValue +
                        pKeyValueInformation->DataLength);
                    *pTerminator = L'\0';

                    //
                    // Return the number of characters to the caller
                    //

                    *nSize = wcslen(ValueValue);
            }
            else {
                NtStatus = STATUS_BUFFER_OVERFLOW;
                *nSize = pKeyValueInformation->DataLength/sizeof(WCHAR) + 1;
            }

        }
        else {
            //
            // If the value has been deleted (zero length data),
            // return object not found.
            //

            if ( NT_SUCCESS( NtStatus ) )
            {
                NtStatus = STATUS_OBJECT_NAME_NOT_FOUND ;
            }
        }
    }

    return(NtStatus);
}


//
// UNICODE APIs
//

BOOL
WINAPI
GetComputerNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

  This returns the active computername.  This is the computername when the
  system was last booted.  If this is changed (via SetComputerName) it does
  not take effect until the next system boot.


Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH + 1 to allow
        sufficient room in the buffer for the computer name.  The length
        of the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING Class;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    HANDLE hNewKey = NULL;
    ULONG Disposition;
    ULONG ValueLength;
    BOOL ReturnValue;
    DWORD Status;
    DWORD errcode;

    //
    // First check to see if the cluster computername variable is set.
    // If so, this overrides the actual computername to fool the application
    // into working when its network name and computer name are different.
    //

    ValueLength = GetEnvironmentVariableW(L"_CLUSTER_NETWORK_NAME_",
                                          lpBuffer,
                                          *nSize);
    if (ValueLength != 0) {
        //
        // The environment variable exists, return it directly but make sure
        // we honor return semantics
        //
        ReturnValue = ( *nSize >= ValueLength ? TRUE : FALSE );
        if ( !ReturnValue ) {
            SetLastError( ERROR_BUFFER_OVERFLOW );
        }
        *nSize = ValueLength;
        return(ReturnValue);
    }


    if ( (gpTermsrvGetComputerName) &&
            ((errcode =  gpTermsrvGetComputerName(lpBuffer, nSize)) != ERROR_RETRY) ) {

        if (errcode == ERROR_BUFFER_OVERFLOW ) {
            ReturnValue = FALSE;
            goto Cleanup;

        } else {
            goto GoodReturn;
        }

    }

    //
    // Open the Computer node, both computername keys are relative
    // to this node.
    //

    RtlInitUnicodeString(&KeyName, COMPUTERNAME_ROOT);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // This should never happen!  This key should have been created
        // at setup, and protected by an ACL so that only the ADMIN could
        // write to it.  Generate an event, and return a NULL computername.
        //

        // NTRAID#NTBUG9-174986-2000/08/31-DavePr Log event or do alert or something.

        //
        // Return a NULL computername
        //

        if (ARGUMENT_PRESENT(lpBuffer))
        {
            lpBuffer[0] = L'\0';
        }
        *nSize = 0;
        goto GoodReturn;
    }

    if (!NT_SUCCESS(NtStatus)) {

        //
        // Some other error, return it to the caller
        //

        goto ErrorReturn;
    }

    //
    // Try to get the name from the volatile key
    //

    NtStatus = GetNameFromValue(hKey, VOLATILE_COMPUTERNAME, lpBuffer,
        nSize);

    //
    // The user's buffer wasn't big enough, just return the error.
    //

    if(NtStatus == STATUS_BUFFER_OVERFLOW) {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        ReturnValue = FALSE;
        goto Cleanup;
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // The volatile copy is already there, just return it
        //

        goto GoodReturn;
    }

    //
    // The volatile key isn't there, try for the non-volatile one
    //

    NtStatus = GetNameFromValue(hKey, NON_VOLATILE_COMPUTERNAME, lpBuffer,
        nSize);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // This should never happen!  This value should have been created
        // at setup, and protected by an ACL so that only the ADMIN could
        // write to it.  Generate an event, and return an error to the
        // caller
        //

        // NTRAID#NTBUG9-174986-2000/08/31-DavePr Log event or do alert or something.

        //
        // Return a NULL computername
        //

        lpBuffer[0] = L'\0';
        *nSize = 0;
        goto GoodReturn;
    }

    if (!NT_SUCCESS(NtStatus)) {

        //
        // Some other error, return it to the caller
        //

        goto ErrorReturn;
    }

    //
    // Now create the volatile key to "lock this in" until the next boot
    //

    RtlInitUnicodeString(&Class, CLASS_STRING);

    //
    // Turn KeyName into a UNICODE_STRING
    //

    RtlInitUnicodeString(&KeyName, VOLATILE_COMPUTERNAME);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              hKey,
                              NULL
                              );

    //
    // Now create the key
    //

    NtStatus = NtCreateKey(&hNewKey,
                         KEY_WRITE | KEY_READ,
                         &ObjectAttributes,
                         0,
                         &Class,
                         REG_OPTION_VOLATILE,
                         &Disposition);

    if (Disposition == REG_OPENED_EXISTING_KEY) {

        //
        // Someone beat us to this, just get the value they put there
        //

        NtStatus = GetNameFromValue(hKey, VOLATILE_COMPUTERNAME, lpBuffer,
           nSize);

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // This should never happen!  It just told me it existed
            //

            NtStatus = STATUS_UNSUCCESSFUL;
            goto ErrorReturn;
        }
    }

    //
    // Create the value under this key
    //

    RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);
    ValueLength = (wcslen(lpBuffer) + 1) * sizeof(WCHAR);
    NtStatus = NtSetValueKey(hNewKey,
                             &ValueName,
                             0,
                             REG_SZ,
                             lpBuffer,
                             ValueLength);

    if (!NT_SUCCESS(NtStatus)) {

        goto ErrorReturn;
    }

    goto GoodReturn;

ErrorReturn:

    //
    // An error was encountered, convert the status and return
    //

    BaseSetLastNTError(NtStatus);
    ReturnValue = FALSE;
    goto Cleanup;

GoodReturn:

    //
    // Everything went ok, update nSize with the length of the buffer and
    // return
    //

    *nSize = wcslen(lpBuffer);
    ReturnValue = TRUE;
    goto Cleanup;

Cleanup:

    if (hKey) {
        NtClose(hKey);
    }

    if (hNewKey) {
        NtClose(hNewKey);
    }

    return(ReturnValue);
}



BOOL
WINAPI
SetComputerNameW (
    LPCWSTR lpComputerName
    )

/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKey = NULL;
    ULONG ValueLength;
    ULONG ComputerNameLength;
    ULONG AnsiComputerNameLength;

    //
    // Validate that the supplied computername is valid (not too long,
    // no incorrect characters, no leading or trailing spaces)
    //

    ComputerNameLength = wcslen(lpComputerName);

    //
    // The name length limitation should be based on ANSI. (LanMan compatibility)
    //

    NtStatus = RtlUnicodeToMultiByteSize(&AnsiComputerNameLength,
                                         (LPWSTR)lpComputerName,
                                         ComputerNameLength * sizeof(WCHAR));

    if ((!NT_SUCCESS(NtStatus)) ||
        (AnsiComputerNameLength == 0 )||(AnsiComputerNameLength > MAX_COMPUTERNAME_LENGTH)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for illegal characters; return an error if one is found
    //

    if (wcscspn(lpComputerName, ILLEGAL_NAME_CHARS_STR) < ComputerNameLength) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Check for leading or trailing spaces
    //

    if (lpComputerName[0] == L' ' ||
        lpComputerName[ComputerNameLength-1] == L' ') {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);

    }
    //
    // Open the ComputerName\ComputerName node
    //

    RtlInitUnicodeString(&KeyName, NON_VOLATILE_COMPUTERNAME_NODE);

    InitializeObjectAttributes(&ObjectAttributes,
                              &KeyName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    NtStatus = NtOpenKey(&hKey, KEY_READ | KEY_WRITE, &ObjectAttributes);

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // This should never happen!  This key should have been created
        // at setup, and protected by an ACL so that only the ADMIN could
        // write to it.  Generate an event, and return a NULL computername.
        //

        // NTRAID#NTBUG9-174986-2000/08/31-DavePr Log event or do alert or something.
        // (One alternative for this instance would be to actually create the missing
        // entry here -- but we'd have to be sure to get the right ACLs etc, etc.

        SetLastError(ERROR_GEN_FAILURE);
        return(FALSE);
    }

    //
    // Update the value under this key
    //

    RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);
    ValueLength = (wcslen(lpComputerName) + 1) * sizeof(WCHAR);
    NtStatus = NtSetValueKey(hKey,
                             &ValueName,
                             0,
                             REG_SZ,
                             (LPWSTR)lpComputerName,
                             ValueLength);

    if (!NT_SUCCESS(NtStatus)) {

        BaseSetLastNTError(NtStatus);
        NtClose(hKey);
        return(FALSE);
    }

    NtFlushKey(hKey);
    NtClose(hKey);
    return(TRUE);

}

BOOL
WINAPI
GetComputerNameExW(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )

/*++

Routine Description:

  This returns the active computername in a particular format.  This is the
  computername when the system was last booted.  If this is changed (via
  SetComputerName) it does not take effect until the next system boot.


Arguments:

    NameType - Possible name formats to return the computer name in:

        ComputerNameNetBIOS - netbios name (compatible with GetComputerName)
        ComputerNameDnsHostname - DNS host name
        ComputerNameDnsDomain - DNS Domain name
        ComputerNameDnsFullyQualified - DNS Fully Qualified (hostname.dnsdomain)

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH + 1 to allow
        sufficient room in the buffer for the computer name.  The length
        of the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    NTSTATUS Status ;
    DWORD ValueLength ;
    DWORD HostLength ;
    DWORD DomainLength ;
    BOOL DontSetReturn = FALSE ;
    COMPUTER_NAME_FORMAT HostNameFormat, DomainNameFormat ;


    if ( NameType >= ComputerNameMax )
    {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE ;
    }

    if ((nSize==NULL) || ((lpBuffer==NULL) && (*nSize>0))) {
	SetLastError(ERROR_INVALID_PARAMETER);
	return(FALSE);
    }

    //
    // For general names, allow clusters to override the physical name:
    //

    if ( (NameType >= ComputerNameNetBIOS) &&
         (NameType <= ComputerNameDnsFullyQualified ) )
    {
        ValueLength = GetEnvironmentVariableW(
                            ClusterNameVars[ NameType ],
                            lpBuffer,
                            *nSize );

        if ( ValueLength )
        {
            BOOL ReturnValue;
            //
            // ValueLength is the length+NULL of the env. string regardless of
            // how much was copied (gregjohn 1/30/01 note:  this isn't the behaivor
	    // of the rest of the function, which returns length+NULL on failure
	    // and length on success). Indicate how many characters are in the string
            // and if the user's buffer wasn't big enough, return FALSE
            // 
            ReturnValue = ( *nSize >= ValueLength ? TRUE : FALSE );
            if ( !ReturnValue ) {
                SetLastError( ERROR_MORE_DATA );
            }
            *nSize = ValueLength ;
            return ReturnValue;
        }
    }

    if ( lpBuffer && (*nSize > 0) )
    {
        lpBuffer[0] = L'\0';
    }

    switch ( NameType )
    {
        case ComputerNameNetBIOS:
        case ComputerNamePhysicalNetBIOS:
            Status = BasepGetNameFromReg(
                        VOLATILE_COMPUTERNAME_NODE,
                        COMPUTERNAME_VALUE_NAME,
                        lpBuffer,
                        nSize );
     
            if ( !NT_SUCCESS( Status ) )
            {
                if ( Status != STATUS_BUFFER_OVERFLOW )
                {
                    //
                    // Hmm, the value (or key) is missing.  Try the non-volatile
                    // one.
                    //

                    Status = BasepGetNameFromReg(
                                NON_VOLATILE_COMPUTERNAME_NODE,
                                COMPUTERNAME_VALUE_NAME,
                                lpBuffer,
                                nSize );


                }
            }

            break;

        case ComputerNameDnsHostname:
        case ComputerNamePhysicalDnsHostname:
            Status = BasepGetNameFromReg(
                        TCPIP_ROOT,
                        TCPIP_HOSTNAME,
                        lpBuffer,
                        nSize );

            break;

        case ComputerNameDnsDomain:
        case ComputerNamePhysicalDnsDomain:

	    //
	    //  Allow policy to override the domain name from the
	    //  tcpip key.
	    //

	    Status = BasepGetNameFromReg(
		TCPIP_POLICY_ROOT,
		TCPIP_POLICY_DOMAINNAME,
		lpBuffer,
		nSize );

	    //
            // If no policy read from the tcpip key.
            //

            if ( !NT_SUCCESS( Status ) )
            {
                Status = BasepGetNameFromReg(
                            TCPIP_ROOT,
                            TCPIP_DOMAINNAME,
                            lpBuffer,
                            nSize );
            }

            break;

        case ComputerNameDnsFullyQualified:
        case ComputerNamePhysicalDnsFullyQualified:

            //
            // This is the tricky case.  We have to construct the name from
            // the two components for the caller.
            //

            //
            // In general, don't set the last status, since we'll end up using
            // the other calls to handle that for us.
            //

            DontSetReturn = TRUE ;

            Status = STATUS_UNSUCCESSFUL ;

            if ( lpBuffer == NULL )
            {
                //
                // If this is just the computation call, quickly do the
                // two components
                //

                HostLength = DomainLength = 0 ;

                GetComputerNameExW( ComputerNameDnsHostname, NULL, &HostLength );

		if ( GetLastError() == ERROR_MORE_DATA )
                {
                    GetComputerNameExW( ComputerNameDnsDomain, NULL, &DomainLength );

                    if ( GetLastError() == ERROR_MORE_DATA )
                    {
                        //
                        // Simply add.  Note that since both account for a
                        // null terminator, the '.' that goes between them is
                        // covered.
                        //

                        *nSize = HostLength + DomainLength ;

                        Status = STATUS_BUFFER_OVERFLOW ;

                        DontSetReturn = FALSE ;
                    }
                }
            }
            else
            {
                HostLength = *nSize ;

                if ( GetComputerNameExW( ComputerNameDnsHostname,
                                         lpBuffer,
                                         &HostLength ) )
                {
                    
                    HostLength += 1; // Add in the zero character (or . depending on perspective)
                    lpBuffer[ HostLength - 1 ] = L'.';

                    DomainLength = *nSize - HostLength ;

                    if (GetComputerNameExW( ComputerNameDnsDomain,
                                            &lpBuffer[ HostLength ],
                                            &DomainLength ) )
                    {
                        Status = STATUS_SUCCESS ;

                        if ( DomainLength == 0 )
                        {
                            lpBuffer[ HostLength - 1 ] = L'\0';
                            HostLength-- ;
                        }
                        else if ( ( DomainLength == 1 ) && 
                                  ( lpBuffer[ HostLength ] == L'.' ) )
                        {
                            //
                            // Legally, the domain name can be a single
                            // dot '.', indicating that this host is part
                            // of the root domain.  An odd case, to be sure, 
                            // but needs to be handled.  Since we've already
                            // stuck a dot separator in the result string,
                            // get rid of this one, and adjust the values
                            // accordingly.
                            //
                            lpBuffer[ HostLength ] = L'\0' ;
                            DomainLength = 0 ;
                        }

                        *nSize = HostLength + DomainLength ;

                        DontSetReturn = TRUE ;
                    }
                    else if ( GetLastError() == ERROR_MORE_DATA )
                    {
                        //
                        // Simply add.  Note that since both account for a
                        // null terminator, the '.' that goes between them is
                        // covered.
                        //

                        *nSize = HostLength + DomainLength ;

                        Status = STATUS_BUFFER_OVERFLOW ;

                        DontSetReturn = FALSE ;
                    }
                    else
                    {
                        //
                        // Other error from trying to get the DNS Domain name.
                        // Let the error from the call trickle back.
                        //

                        *nSize = 0 ;

                        Status = STATUS_UNSUCCESSFUL ;

                        DontSetReturn = TRUE ;
                    }

                }
                else if ( GetLastError() == ERROR_MORE_DATA )
                {
                    DomainLength = 0;
                    GetComputerNameExW( ComputerNameDnsDomain, NULL, &DomainLength );

                    if ( GetLastError() == ERROR_MORE_DATA )
                    {
                        //
                        // Simply add.  Note that since both account for a
                        // null terminator, the '.' that goes between them is
                        // covered.
                        //

                        *nSize = HostLength + DomainLength ;

                        Status = STATUS_BUFFER_OVERFLOW ;

                        DontSetReturn = FALSE ;
                    }
                }
                else
                {

                    //
                    // Other error from trying to get the DNS Hostname.
                    // Let the error from the call trickle back.
                    //

                    *nSize = 0 ;

                    Status = STATUS_UNSUCCESSFUL ;

                    DontSetReturn = TRUE ;
                }
            }


            break;



    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( !DontSetReturn )
        {
            BaseSetLastNTError( Status );
        }
        return FALSE ;
    }

    return TRUE ;
}

BOOL
WINAPI
SetComputerNameExW(
    IN COMPUTER_NAME_FORMAT NameType,
    IN LPCWSTR lpBuffer
    )

/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    NameType - Name to set for the system

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{
    ULONG Length ;

    //
    // Validate name:
    //

    if ( !lpBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE ;
    }

    Length = wcslen( lpBuffer );

    if ( Length )
    {
        if ( ( lpBuffer[0] == L' ') ||
             ( lpBuffer[ Length - 1 ] == L' ' ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;
        }

    }

    if (wcscspn(lpBuffer, ILLEGAL_NAME_CHARS_STR) < Length) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch ( NameType )
    {
        case ComputerNamePhysicalNetBIOS:
            return BaseSetNetbiosName( lpBuffer );

        case ComputerNamePhysicalDnsHostname:
            return BaseSetDnsName( lpBuffer );

        case ComputerNamePhysicalDnsDomain:
            return BaseSetDnsDomain( lpBuffer );

        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;

    }

}





//
// ANSI APIs
//

BOOL
WINAPI
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

  This returns the active computername.  This is the computername when the
  system was last booted.  If this is changed (via SetComputerName) it does
  not take effect until the next system boot.


Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH to allow
        sufficient room in the buffer for the computer name.  The length of
        the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{

    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer;
    ULONG AnsiSize;
    ULONG UnicodeSize;

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *nSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = lpBuffer;

    //
    // Call the UNICODE version to do the work
    //

    UnicodeSize = *nSize ;

    if (!GetComputerNameW(UnicodeBuffer, &UnicodeSize)) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Find out the required size of the ANSI buffer and validate it against
    // the passed in buffer size
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    AnsiSize = RtlUnicodeStringToAnsiSize(&UnicodeString);
    if (AnsiSize > *nSize) {

        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);

        BaseSetLastNTError( STATUS_BUFFER_OVERFLOW );

        *nSize = AnsiSize + 1 ;

        return(FALSE);
    }


    //
    // Now convert back to ANSI for the caller
    //

    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

    *nSize = AnsiString.Length;
    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);

}



BOOL
WINAPI
SetComputerNameA (
    LPCSTR lpComputerName
    )

/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{

    NTSTATUS NtStatus;
    BOOL ReturnValue;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    ULONG ComputerNameLength;

    //
    // Validate that the supplied computername is valid (not too long,
    // no incorrect characters, no leading or trailing spaces)
    //

    ComputerNameLength = strlen(lpComputerName);
    if ((ComputerNameLength == 0 )||(ComputerNameLength > MAX_COMPUTERNAME_LENGTH)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString(&AnsiString, lpComputerName);
    NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
        TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    ReturnValue = SetComputerNameW((LPCWSTR)UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);
}

BOOL
WINAPI
GetComputerNameExA(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
/*++

Routine Description:

  This returns the active computername in a particular format.  This is the
  computername when the system was last booted.  If this is changed (via
  SetComputerName) it does not take effect until the next system boot.


Arguments:

    NameType - Possible name formats to return the computer name in:

        ComputerNameNetBIOS - netbios name (compatible with GetComputerName)
        ComputerNameDnsHostname - DNS host name
        ComputerNameDnsDomain - DNS Domain name
        ComputerNameDnsFullyQualified - DNS Fully Qualified (hostname.dnsdomain)

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the computer name.

    nSize - Specifies the maximum size (in characters) of the buffer.  This
        value should be set to at least MAX_COMPUTERNAME_LENGTH + 1 to allow
        sufficient room in the buffer for the computer name.  The length
        of the string is returned in nSize.

Return Value:

    TRUE on success, FALSE on failure.


--*/
{
    LPWSTR UnicodeBuffer;

    //
    // Validate Input
    // 

    if ((nSize==NULL) || ((lpBuffer==NULL) && (*nSize>0))) {
	SetLastError(ERROR_INVALID_PARAMETER);
	return(FALSE);
    }

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
   
    //
    // Call the UNICODE version to do the work
    //

    if ( !GetComputerNameExW(NameType, UnicodeBuffer, nSize) ) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    // Note:  Since we passed the above if statement, 
    // GetComputerNameExW succeeded, and set *nSize to the number of
    // characters in the string (like wcslen).  We need to convert
    // all these characters and the trailing NULL, so inc *nSize for
    // the conversion call.
    //

    WideCharToMultiByte(CP_ACP,
			0,
			UnicodeBuffer,
			*nSize+1,
			lpBuffer,
			(*nSize+1) * sizeof(CHAR), 
			NULL, 
			NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);


}

BOOL
WINAPI
SetComputerNameExA(
    IN COMPUTER_NAME_FORMAT NameType,
    IN LPCSTR lpBuffer
    )
/*++

Routine Description:

  This sets what the computername will be when the system is next booted.  This
  does not effect the active computername for the remainder of this boot, nor
  what is returned by GetComputerName before the next system boot.


Arguments:

    NameType - Name to set for the system

    lpComputerName - points to the buffer that is contains the
        null-terminated character string containing the computer name.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{
    NTSTATUS NtStatus;
    BOOL ReturnValue;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;


    RtlInitAnsiString(&AnsiString, lpBuffer);
    NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString,
        TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    ReturnValue = SetComputerNameExW(NameType, (LPCWSTR)UnicodeString.Buffer );
    RtlFreeUnicodeString(&UnicodeString);
    return(ReturnValue);
}

DWORD
WINAPI
AddLocalAlternateComputerNameW(
    LPCWSTR lpDnsFQHostname,
    ULONG   ulFlags
    )
/*++

Routine Description:

    This sets an alternate computer name for the computer to begin to
    respond to.  


Arguments:

    lpDnsFQHostname - The alternate name to add (in ComputerNameDnsFullyQualified Format)

    ulFlags - TBD

Return Value:

    Returns ERROR

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    DWORD err = ERROR_SUCCESS;
    LPWSTR lpNetBiosCompName = NULL;
    ULONG ulNetBiosCompNameSize = 0;
    LPWSTR lpHostname = BaseParseDnsName(lpDnsFQHostname,DNS_HOSTNAME);

    //
    // validate input
    //

    if ((lpDnsFQHostname==NULL) || (!BaseValidateFlags(ulFlags)) || (!BaseValidateDnsNames(lpHostname))) {
	if (lpHostname) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpHostname);
	}
	return ERROR_INVALID_PARAMETER;
    }

    // get write lock?

    status = BaseAddMultiNameInReg(
	DNSCACHE_ROOT,
	DNS_ALT_HOSTNAME,  
	lpDnsFQHostname);

    err = RtlNtStatusToDosError(status);
    
    if (err==ERROR_SUCCESS) {
	// get NetBios name (use DNSHostNameToComputerNameW) and add that to reg for OptionalNames
	if (!DnsHostnameToComputerNameW(
	    lpDnsFQHostname,
	    NULL,
	    &ulNetBiosCompNameSize)) {
	    err = GetLastError(); 
	}

	if (err==ERROR_MORE_DATA) {
	    // bug in DNSHostname, returns a size 1 character too small	(forgets null) 
	    // update when bug is fixed...
	    ulNetBiosCompNameSize += 1;
	    lpNetBiosCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), ulNetBiosCompNameSize * sizeof(WCHAR));
	    if (lpNetBiosCompName==NULL) {  
		err = ERROR_NOT_ENOUGH_MEMORY;
	    }
	    else {  
		if (!DnsHostnameToComputerNameW(lpDnsFQHostname, 
						lpNetBiosCompName,
						&ulNetBiosCompNameSize)) {
		    err = GetLastError();
		}
		else {
		    if (!BaseSetAltNetBiosName(lpNetBiosCompName)) {
			err = GetLastError();
		    }
		}
		RtlFreeHeap(RtlProcessHeap(), 0, lpNetBiosCompName);
	    }
	}

	if (err!=ERROR_SUCCESS) {
	    // remove multi name in reg
	    // rollback?
	}
    }
    if (lpHostname) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpHostname);
    }
    // release write lock?
    return RtlNtStatusToDosError(status);
}

DWORD
WINAPI
AddLocalAlternateComputerNameA(
    LPCSTR lpDnsFQHostname,
    ULONG  ulFlags
    )
{

    LPWSTR lpDnsFQHostnameW = NULL;
    DWORD err = ERROR_SUCCESS;

    if (lpDnsFQHostname==NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    err = BaseMultiByteToWideCharWithAlloc(lpDnsFQHostname, &lpDnsFQHostnameW);

    if (err==ERROR_SUCCESS) {
	err = AddLocalAlternateComputerNameW(lpDnsFQHostnameW, ulFlags);
    }

    BaseConvertCharFree((VOID *)lpDnsFQHostnameW);
    return err;
}

DWORD
WINAPI
RemoveLocalAlternateComputerNameW(
    LPCWSTR lpAltDnsFQHostname,
    ULONG ulFlags
    )
/*++

Routine Description:

    Remove an alternate computer name.  


Arguments:

    lpAltDnsFQHostname - The alternate name to remove(in ComputerNameDnsFullyQualified Format)

    ulFlags - TBD

Return Value:

    Returns ERROR

--*/
{
    DWORD err = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR lpAltNetBiosCompName = NULL;
    ULONG cchAltNetBiosCompName = 0;

    if ((!BaseValidateFlags(ulFlags)) || (lpAltDnsFQHostname==NULL)) {
	return ERROR_INVALID_PARAMETER;
    }    
    
    // aquire a write lock?

    NtStatus = BaseRemoveMultiNameFromReg(DNSCACHE_ROOT, DNS_ALT_HOSTNAME, lpAltDnsFQHostname);
    err = RtlNtStatusToDosError(NtStatus);

    if (err==ERROR_SUCCESS) {
	if (!DnsHostnameToComputerNameW(
	    lpAltDnsFQHostname,
	    NULL,
	    &cchAltNetBiosCompName)) {
	    err = GetLastError(); 
	}
	if (err==ERROR_MORE_DATA) {
	    // bug in DNSHostname, returns a size 1 character too small	(forgets null)
	    cchAltNetBiosCompName += 1;
	    lpAltNetBiosCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchAltNetBiosCompName * sizeof(WCHAR));
	    if (lpAltNetBiosCompName==NULL) {  
		err = ERROR_NOT_ENOUGH_MEMORY;
	    }
	    else {  
		err = ERROR_SUCCESS;
		if (!DnsHostnameToComputerNameW(lpAltDnsFQHostname, 
						lpAltNetBiosCompName,
						&cchAltNetBiosCompName)) {
		    err = GetLastError();  
		} else if (BaseIsNetBiosNameInUse(lpAltNetBiosCompName)) {
		    // do nothing, this name is still being used by another AltDnsHostname ...  
		} else if (!BaseRemoveAltNetBiosName(lpAltNetBiosCompName)) {
		    err = GetLastError();
		}  
		RtlFreeHeap(RtlProcessHeap(), 0, lpAltNetBiosCompName);
	    } 
	}
    }

    // release write lock?

    return err;
}

DWORD 
WINAPI
RemoveLocalAlternateComputerNameA(
    LPCSTR lpAltDnsFQHostname,
    ULONG  ulFlags
    )
{
    LPWSTR lpAltDnsFQHostnameW = NULL;
    DWORD err = ERROR_SUCCESS;

    if (lpAltDnsFQHostname==NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    err = BaseMultiByteToWideCharWithAlloc(lpAltDnsFQHostname, &lpAltDnsFQHostnameW);

    if (err==ERROR_SUCCESS) {
	err = RemoveLocalAlternateComputerNameW(lpAltDnsFQHostnameW, ulFlags);
    }

    BaseConvertCharFree((VOID *)lpAltDnsFQHostnameW);
    return err;
}

DWORD
WINAPI
SetLocalPrimaryComputerNameW(
    LPCWSTR lpAltDnsFQHostname,
    ULONG   ulFlags
    )
/*++

Routine Description:

    Set the computer name to the inputed altCompName


Arguments:

    lpAltDnsFQHostname - The name to set the computer to (in ComputerNameDnsFullyQualified Format)

    ulFlags - TBD

Return Value:

    Returns ERROR

--*/
{

    DWORD err = ERROR_SUCCESS;
    ULONG cchNetBiosName = 0;
    LPWSTR lpNetBiosName = NULL;
    ULONG cchCompName = 0;
    LPWSTR lpCompName = NULL;
    LPWSTR lpHostname = BaseParseDnsName(lpAltDnsFQHostname, DNS_HOSTNAME);
    LPWSTR lpDomainName = BaseParseDnsName(lpAltDnsFQHostname, DNS_DOMAINNAME);
  
    if ((lpAltDnsFQHostname==NULL) || (!BaseValidateFlags(ulFlags))) {
	return ERROR_INVALID_PARAMETER;
    }
     
    // aquire a write lock?

    // check to see that the given name is a valid alternate dns hostname
    if (!BaseIsAltDnsFQHostname(lpAltDnsFQHostname)) {
	if (lpHostname) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpHostname);
	}
	if (lpDomainName) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpDomainName);
	}
	return ERROR_INVALID_PARAMETER;
    }
    
    // get the current net bios name and add it to the alternate names
    if (!GetComputerNameExW(ComputerNamePhysicalNetBIOS, NULL, &cchNetBiosName)) {
	err = GetLastError();
    }
    if (err==ERROR_MORE_DATA) {
	lpNetBiosName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchNetBiosName*sizeof(WCHAR));
	if (lpNetBiosName==NULL) {
	    err = ERROR_NOT_ENOUGH_MEMORY;
	}
	else if (!GetComputerNameExW(ComputerNamePhysicalNetBIOS, lpNetBiosName, &cchNetBiosName)) {
		err = GetLastError();
	}
	else if (!BaseSetAltNetBiosName(lpNetBiosName)) {
	    err = GetLastError();
	} 
	else {
	    err = ERROR_SUCCESS;
	}
	if (lpNetBiosName) {
	    RtlFreeHeap(RtlProcessHeap(), 0, lpNetBiosName);
	}
    }

    if (err==ERROR_SUCCESS) {
	// add the physical dnsname to the list of alternate hostnames...
	
	if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, NULL, &cchCompName)) {
	    err = GetLastError();
	}
	if (err==ERROR_MORE_DATA) {
	    lpCompName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cchCompName*sizeof(WCHAR));
	    if (lpCompName==NULL) {
		err = ERROR_NOT_ENOUGH_MEMORY;
	    }
	    else if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, lpCompName, &cchCompName)) {
		err = GetLastError(); 
	    }
	    else if (!BaseSetAltDnsFQHostname(lpCompName)) {
		err = GetLastError(); 
	    }
	    else {
		err = ERROR_SUCCESS;
	    }
	    if (lpCompName) {
		RtlFreeHeap(RtlProcessHeap(), 0, lpCompName);
	    }
	}
    }
 
    // set the new physical dns hostname
    if (err==ERROR_SUCCESS) { 
	if (!SetComputerNameExW(ComputerNamePhysicalDnsHostname, lpHostname)) {
	    err = GetLastError();
	} 
    }

    if (err==ERROR_SUCCESS) { 
	if (!SetComputerNameExW(ComputerNamePhysicalDnsDomain, lpDomainName)) {
	    err = GetLastError();
	} 
    }

    // remove the alternate name (now primary) from the alternate lists
    if (err==ERROR_SUCCESS) {
	err = RemoveLocalAlternateComputerNameW(lpAltDnsFQHostname, 0);
    }

    if (lpHostname) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpHostname);
    }
    if (lpDomainName) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpDomainName);
    }
    // release write lock?

    return err;
    
}

DWORD
WINAPI
SetLocalPrimaryComputerNameA(
    LPCSTR lpAltDnsFQHostname,
    ULONG  ulFlags
    )
{
    LPWSTR lpAltDnsFQHostnameW = NULL;
    DWORD err = ERROR_SUCCESS;

    if (lpAltDnsFQHostname==NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    err = BaseMultiByteToWideCharWithAlloc(lpAltDnsFQHostname, &lpAltDnsFQHostnameW);
    if (err == ERROR_SUCCESS) {
	err = SetLocalPrimaryComputerNameW(lpAltDnsFQHostnameW, ulFlags);
    }
    BaseConvertCharFree((VOID *)lpAltDnsFQHostnameW);

    return err;
}

DWORD
WINAPI
EnumerateLocalComputerNamesW(
    COMPUTER_NAME_TYPE       NameType,
    ULONG                    ulFlags,
    LPWSTR                   lpDnsFQHostnames,
    LPDWORD                  nSize    
    )
/*++

Routine Description: 

    Returns the value of the computer's names requested.
    

Arguments:

    NameType - Which of the computer's names are requested
	PrimaryComputerName - Similar to GetComputerEx(ComputerNamePhysicalNetBios, ...
	AlternateComputerNames - All known alt names
	AllComputerNames - All of the above
	
    ulFlags - TBD
    
    lpBuffer - Buffer to hold returned names concatenated together, and trailed with a NULL
    
    nSize - Size of buffer to hold returned names.

Return Value:

    Returns ERROR

--*/
{
    DWORD err = ERROR_SUCCESS;
    DWORD SizePrimary = 0;
    DWORD SizeAlternate = 0;
    LPWSTR lpTempCompNames = NULL;

    if ((!BaseValidateFlags(ulFlags)) || (NameType>=ComputerNameTypeMax) || (NameType<PrimaryComputerName)) { 
	return ERROR_INVALID_PARAMETER;
    }

    // get read lock?
    switch(NameType) {
    case PrimaryComputerName:  
	if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, lpDnsFQHostnames, nSize)) {
	    err = GetLastError();
	}
	break;
    case AlternateComputerNames:
	if ((nSize==NULL) || ((lpDnsFQHostnames==NULL) && (*nSize>0))) {
	    err = ERROR_INVALID_PARAMETER;
	}
	else {
	    err = BaseEnumAltDnsFQHostnames(lpDnsFQHostnames, nSize);
	}
	break;
    case AllComputerNames:
	if ((nSize==NULL) || ((lpDnsFQHostnames==NULL) && (*nSize>0))) {
	    err = ERROR_INVALID_PARAMETER;
	}
	else {
	    SizePrimary = *nSize;
	    lpTempCompNames = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
	    if (lpTempCompNames==NULL) {
		err = ERROR_NOT_ENOUGH_MEMORY;
		break;
	    }
	    // Get primary name
	    if (!GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, lpTempCompNames, &SizePrimary)) {
		err = GetLastError();
	    }

	    // on success, holds the number of characters copied into lpTempCompNames NOT counting NULL
	    // on failure, holds the space needed to copy in, (num characters PLUS NULL)
	    if (err==ERROR_SUCCESS) { 
		SizeAlternate = *nSize - (SizePrimary + 1); 
		err = BaseEnumAltDnsFQHostnames(lpTempCompNames+SizePrimary+1, &SizeAlternate);  
		*nSize = SizePrimary + 1 + SizeAlternate;
		if (err==ERROR_SUCCESS) { 
		    memcpy(lpDnsFQHostnames, lpTempCompNames, (*nSize+1)*sizeof(WCHAR));
		}  
	    }
	    else if (err==ERROR_MORE_DATA) {
		// return total size required
		SizeAlternate = 0;
		err = BaseEnumAltDnsFQHostnames(NULL, &SizeAlternate);
		if (err==ERROR_SUCCESS) {
		    // no alt names exist, keep ERROR_MORE_DATA to return to client
		    err = ERROR_MORE_DATA;
		}
		*nSize = SizePrimary + SizeAlternate;
	    }
	    RtlFreeHeap(RtlProcessHeap(), 0, lpTempCompNames); 
	}
	break;
    default:
	err = ERROR_INVALID_PARAMETER;
	break;
    }
    // release read lock?
    return err;
}

DWORD
WINAPI
EnumerateLocalComputerNamesA(
    COMPUTER_NAME_TYPE      NameType,
    ULONG                   ulFlags,
    LPSTR                   lpDnsFQHostnames,
    LPDWORD                 nSize
    )
{
    DWORD err = ERROR_SUCCESS;
    LPWSTR lpDnsFQHostnamesW = NULL;
    
    //
    // Validate Input
    // 

    if ((nSize==NULL) || ((lpDnsFQHostnames==NULL) && (*nSize>0))) {
	return ERROR_INVALID_PARAMETER;
    }
    
    if (lpDnsFQHostnames!=NULL) {
	lpDnsFQHostnamesW = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), *nSize * sizeof(WCHAR));
	if (lpDnsFQHostnamesW==NULL) {
	    err = ERROR_NOT_ENOUGH_MEMORY;
	}
    }

    if (err==ERROR_SUCCESS) {
	err = EnumerateLocalComputerNamesW(NameType, ulFlags, lpDnsFQHostnamesW, nSize);
    }

    if (err==ERROR_SUCCESS) {
	if (!WideCharToMultiByte(CP_ACP, 0, lpDnsFQHostnamesW, *nSize+1,
				 lpDnsFQHostnames, (*nSize+1)* sizeof(CHAR), NULL, NULL)) {
	    err = GetLastError();
	}
    }

    if (lpDnsFQHostnamesW) {
	RtlFreeHeap(RtlProcessHeap(), 0, lpDnsFQHostnamesW);
    }
    return err;

}

BOOL
WINAPI
DnsHostnameToComputerNameW(
    IN LPCWSTR Hostname,
    OUT LPWSTR ComputerName,
    IN OUT LPDWORD nSize)
/*++

Routine Description:

    This routine will convert a DNS Hostname to a Win32 Computer Name.

Arguments:

    Hostname - DNS Hostname (any length)

    ComputerName - Win32 Computer Name (max length of MAX_COMPUTERNAME_LENGTH)

    nSize - On input, size of the buffer pointed to by ComputerName.  On output,
            size of the Computer Name, in characters.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/

{
    WCHAR CompName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD Size = MAX_COMPUTERNAME_LENGTH + 1 ;
    UNICODE_STRING CompName_U ;
    UNICODE_STRING Hostname_U ;
    NTSTATUS Status ;
    BOOL Ret ;

    CompName[0] = L'\0';
    CompName_U.Buffer = CompName ;
    CompName_U.Length = 0 ;
    CompName_U.MaximumLength = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof( WCHAR );

    RtlInitUnicodeString( &Hostname_U, Hostname );

    Status = RtlDnsHostNameToComputerName( &CompName_U,
                                           &Hostname_U,
                                           FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        if ( *nSize >= CompName_U.Length / sizeof(WCHAR) + 1 )
        {
            RtlCopyMemory( ComputerName,
                           CompName_U.Buffer,
                           CompName_U.Length );

            ComputerName[ CompName_U.Length / sizeof( WCHAR ) ] = L'\0';

            Ret = TRUE ;
        }
        else
        {
            BaseSetLastNTError( STATUS_BUFFER_OVERFLOW );
            Ret = FALSE ;
        }

        //
        // returns the count of characters
        //

        *nSize = CompName_U.Length / sizeof( WCHAR );
    }
    else
    {
        BaseSetLastNTError( Status );

        Ret = FALSE ;
    }

    return Ret ;

}

BOOL
WINAPI
DnsHostnameToComputerNameA(
    IN LPCSTR Hostname,
    OUT LPSTR ComputerName,
    IN OUT LPDWORD nSize)
/*++

Routine Description:

    This routine will convert a DNS Hostname to a Win32 Computer Name.

Arguments:

    Hostname - DNS Hostname (any length)

    ComputerName - Win32 Computer Name (max length of MAX_COMPUTERNAME_LENGTH)

    nSize - On input, size of the buffer pointed to by ComputerName.  On output,
            size of the Computer Name, in characters.

Return Value:

    Returns TRUE on success, FALSE on failure.


--*/
{
    WCHAR CompName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD Size = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL Ret ;
    UNICODE_STRING CompName_U ;
    UNICODE_STRING Hostname_U ;
    NTSTATUS Status ;
    ANSI_STRING CompName_A ;


    Status = RtlCreateUnicodeStringFromAsciiz( &Hostname_U,
                                               Hostname );

    if ( NT_SUCCESS( Status ) )
    {
        CompName[0] = L'\0';
        CompName_U.Buffer = CompName ;
        CompName_U.Length = 0 ;
        CompName_U.MaximumLength = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof( WCHAR );

        Status = RtlDnsHostNameToComputerName( &CompName_U,
                                               &Hostname_U,
                                               FALSE );

        if ( NT_SUCCESS( Status ) )
        {
            CompName_A.Buffer = ComputerName ;
            CompName_A.Length = 0 ;
            CompName_A.MaximumLength = (USHORT) *nSize ;

            Status = RtlUnicodeStringToAnsiString( &CompName_A, &CompName_U, FALSE );

            if ( NT_SUCCESS( Status ) )
            {
                *nSize = CompName_A.Length ;
            }

        }

    }

    if ( !NT_SUCCESS( Status ) )
    {
        BaseSetLastNTError( Status );
        return FALSE ;
    }

    return TRUE ;

}





#include "dfsfsctl.h"
DWORD
BasepGetComputerNameFromNtPath (
    PUNICODE_STRING NtPathName,
    HANDLE hFile,
    LPWSTR lpBuffer,
    LPDWORD nSize
    )

/*++

Routine Description:

  Look at a path and determine the computer name of the host machine.
  In the future, we should remove this code, and add the capbility to query
  handles for their computer name.

  The name can only be obtained for NetBios paths - if the path is IP or DNS
  an error is returned.  (If the NetBios name has a "." in it, it will
  cause an error because it will be misinterpreted as a DNS path.  This case
  becomes less and less likely as the NT5 UI doesn't allow such computer names.)
  For DFS paths, the leaf server's name is returned, as long as it wasn't
  joined to its parent with an IP or DNS path name.

Arguments:

  NtPathName - points to a unicode string with the path to query.
  lpBuffer - points to buffer receives the computer name
  nSize - points to dword with the size of the input buffer, and the length
    (in characters, not including the null terminator) of the computer name
    on output.

Return Value:

    A Win32 error code.

--*/
{
    ULONG cbComputer = 0;
    DWORD dwError = ERROR_BAD_PATHNAME;
    ULONG AvailableLength = 0;
    PWCHAR PathCharacter = NULL;
    BOOL CheckForDfs = TRUE;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR FileNameInfoBuffer[MAX_PATH+sizeof(FILE_NAME_INFORMATION)];
    PFILE_NAME_INFORMATION FileNameInfo = (PFILE_NAME_INFORMATION)FileNameInfoBuffer;
    WCHAR DfsServerPathName[ MAX_PATH + 1 ];
    WCHAR DosDevice[3] = { L"A:" };
    WCHAR DosDeviceMapping[ MAX_PATH + 1 ];


    UNICODE_STRING UnicodeComputerName;

    const UNICODE_STRING NtUncPathNamePrefix = { 16, 18, L"\\??\\UNC\\"};
    const ULONG cchNtUncPathNamePrefix = 8;

    const UNICODE_STRING NtDrivePathNamePrefix = { 8, 10, L"\\??\\" };
    const ULONG cchNtDrivePathNamePrefix = 4;

    RtlInitUnicodeString( &UnicodeComputerName, NULL );

    // Is this a UNC path?

    if( RtlPrefixString( (PSTRING)&NtUncPathNamePrefix, (PSTRING)NtPathName, TRUE )) {

        // Make sure there's some more to this path than just the prefix
        if( NtPathName->Length <= NtUncPathNamePrefix.Length )
            goto Exit;

        // It appears to be a valid UNC path.  Point to the beginning of the computer
        // name, and calculate how much room is left in NtPathName after that.

        UnicodeComputerName.Buffer = &NtPathName->Buffer[ NtUncPathNamePrefix.Length/sizeof(WCHAR) ];
        AvailableLength = NtPathName->Length - NtUncPathNamePrefix.Length;

    }

    // If it's not a UNC path, then is it a drive-letter path?

    else if( RtlPrefixString( (PSTRING)&NtDrivePathNamePrefix, (PSTRING)NtPathName, TRUE )
             &&
             NtPathName->Buffer[ cchNtDrivePathNamePrefix + 1 ] == L':' ) {

        // It's a drive letter path, but it could still be local or remote

        static const WCHAR RedirectorMappingPrefix[] = { L"\\Device\\LanmanRedirector\\;" };
        static const WCHAR LocalVolumeMappingPrefix[] = { L"\\Device\\Harddisk" };
        static const WCHAR CDRomMappingPrefix[] = { L"\\Device\\CdRom" };
        static const WCHAR FloppyMappingPrefix[] = { L"\\Device\\Floppy" };
        static const WCHAR DfsMappingPrefix[] = { L"\\Device\\WinDfs\\" };

        // Get the correct, upper-cased, drive letter into DosDevice.

        DosDevice[0] = NtPathName->Buffer[ cchNtDrivePathNamePrefix ];
        if( L'a' <= DosDevice[0] && DosDevice[0] <= L'z' )
            DosDevice[0] = L'A' + (DosDevice[0] - L'a');

        // Map the drive letter to its symbolic link under \??.  E.g., say C:, D: & R:
        // are local/DFS/rdr drives, respectively.  You would then see something like:
        //
        //   C: => \Device\Volume1
        //   D: => \Device\WinDfs\G
        //   R: => \Device\LanmanRedirector\;R:0\scratch\scratch

        if( !QueryDosDeviceW( DosDevice, DosDeviceMapping, sizeof(DosDeviceMapping)/sizeof(DosDeviceMapping[0]) )) {
            dwError = GetLastError();
            goto Exit;
        }

        // Now that we have the DosDeviceMapping, we can check ... Is this a rdr drive?

        if( // Does it begin with "\Device\LanmanRedirector\;" ?
            DosDeviceMapping == wcsstr( DosDeviceMapping, RedirectorMappingPrefix )
            &&
            // Are the next letters the correct drive letter, a colon, and a whack?
            ( DosDevice[0] == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) - 1 ]
              &&
              L':' == DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) ]
              &&
              (UnicodeComputerName.Buffer = wcschr(&DosDeviceMapping[ sizeof(RedirectorMappingPrefix)/sizeof(WCHAR) + 1 ], L'\\'))
            )) {

            // We have a valid rdr drive.  Point to the beginning of the computer
            // name, and calculate how much room is availble in DosDeviceMapping after that.

            UnicodeComputerName.Buffer += 1;
            AvailableLength = sizeof(DosDeviceMapping) - sizeof(DosDeviceMapping[0]) * (ULONG)(UnicodeComputerName.Buffer - DosDeviceMapping);

            // We know now that it's not a DFS path
            CheckForDfs = FALSE;

        }

        // If it's not a rdr drive, then maybe it's a local volume, floppy, or cdrom

        else if( DosDeviceMapping == wcsstr( DosDeviceMapping, LocalVolumeMappingPrefix )
                 ||
                 DosDeviceMapping == wcsstr( DosDeviceMapping, CDRomMappingPrefix )
                 ||
                 DosDeviceMapping == wcsstr( DosDeviceMapping, FloppyMappingPrefix ) ) {

            // We have a local drive, so just return the local computer name.

            CheckForDfs = FALSE;

            if( !GetComputerNameW( lpBuffer, nSize))
                dwError = GetLastError();
            else
                dwError = ERROR_SUCCESS;
            goto Exit;
        }

        // Finally, check to see if it's a DFS drive

        else if( DosDeviceMapping == wcsstr( DosDeviceMapping, DfsMappingPrefix )) {

            // Get the full UNC name of this DFS path.  Later, we'll call the DFS
            // driver to find out what the actual server name is.

            NtStatus = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        FileNameInfo,
                        sizeof(FileNameInfoBuffer),
                        FileNameInformation
                        );
            if( !NT_SUCCESS(NtStatus) ) {
                dwError = RtlNtStatusToDosError(NtStatus);
                goto Exit;
            }

            UnicodeComputerName.Buffer = FileNameInfo->FileName + 1;
            AvailableLength = FileNameInfo->FileNameLength;
        }

        // Otherwise, it's not a rdr, dfs, or local drive, so there's nothing we can do.

        else
            goto Exit;

    }   // else if( RtlPrefixString( (PSTRING)&NtDrivePathNamePrefix, (PSTRING)NtPathName, TRUE ) ...

    else {
        dwError = ERROR_BAD_PATHNAME;
        goto Exit;
    }


    // If we couldn't determine above if whether or not this is a DFS path, let the
    // DFS driver decide now.

    if( CheckForDfs && INVALID_HANDLE_VALUE != hFile ) {

        HANDLE hDFS = INVALID_HANDLE_VALUE;
        UNICODE_STRING DfsDriverName;
        OBJECT_ATTRIBUTES ObjectAttributes;

        WCHAR *DfsPathName = UnicodeComputerName.Buffer - 1;    // Back up to the whack
        ULONG DfsPathNameLength = AvailableLength + sizeof(WCHAR);

        // Open the DFS driver

        RtlInitUnicodeString( &DfsDriverName, DFS_DRIVER_NAME );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &DfsDriverName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                );

        NtStatus = NtCreateFile(
                        &hDFS,
                        SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                    );

        if( !NT_SUCCESS(NtStatus) ) {
            dwError = RtlNtStatusToDosError(NtStatus);
            goto Exit;
        }

        // Query DFS's cache for the server name.  The name is guaranteed to
        // remain in the cache as long as the file is open.

        if( L'\\' != DfsPathName[0] ) {
            NtClose(hDFS);
            dwError = ERROR_BAD_PATHNAME;
            goto Exit;
        }

        NtStatus = NtFsControlFile(
                        hDFS,
                        NULL,       // Event,
                        NULL,       // ApcRoutine,
                        NULL,       // ApcContext,
                        &IoStatusBlock,
                        FSCTL_DFS_GET_SERVER_NAME,
                        DfsPathName,
                        DfsPathNameLength,
                        DfsServerPathName,
                        sizeof(DfsServerPathName)
                    );
        NtClose( hDFS );

        // STATUS_OBJECT_NAME_NOT_FOUND means that it's not a DFS path
        if( !NT_SUCCESS(NtStatus) ) {
            if( STATUS_OBJECT_NAME_NOT_FOUND != NtStatus  ) {
                dwError = RtlNtStatusToDosError(NtStatus);
                goto Exit;
            }
        }
        else if( L'\0' != DfsServerPathName[0] ) {

            // The previous DFS call returns the server-specific path to the file in UNC form.
            // Point UnicodeComputerName to just past the two whacks.

            AvailableLength = wcslen(DfsServerPathName) * sizeof(WCHAR);
            if( 3*sizeof(WCHAR) > AvailableLength
                ||
                L'\\' != DfsServerPathName[0]
                ||
                L'\\' != DfsServerPathName[1] )
            {
                dwError = ERROR_BAD_PATHNAME;
                goto Exit;
            }

            UnicodeComputerName.Buffer = DfsServerPathName + 2;
            AvailableLength -= 2 * sizeof(WCHAR);
        }
    }

    // If we get here, then the computer name\share is pointed to by UnicodeComputerName.Buffer.
    // But the Length is currently zero, so we search for the whack that separates
    // the computer name from the share, and set the Length to include just the computer name.

    PathCharacter = UnicodeComputerName.Buffer;

    while( ( (ULONG) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer) < AvailableLength)
           &&
           *PathCharacter != L'\\' ) {

        // If we found a '.', we fail because this is probably a DNS or IP name.
        if( L'.' == *PathCharacter ) {
            dwError = ERROR_BAD_PATHNAME;
            goto Exit;
        }

        PathCharacter++;
    }

    // Set the computer name length

    UnicodeComputerName.Length = UnicodeComputerName.MaximumLength
        = (USHORT) ((PCHAR)PathCharacter - (PCHAR)UnicodeComputerName.Buffer);

    // Fail if the computer name exceeded the length of the input NtPathName,
    // or if the length exceeds that allowed.

    if( UnicodeComputerName.Length >= AvailableLength
        ||
        UnicodeComputerName.Length > MAX_COMPUTERNAME_LENGTH*sizeof(WCHAR) ) {
        goto Exit;
    }

    // Copy the computer name into the caller's buffer, as long as there's enough
    // room for the name & a terminating '\0'.

    if( UnicodeComputerName.Length + sizeof(WCHAR) > *nSize * sizeof(WCHAR) ) {
        dwError = ERROR_BUFFER_OVERFLOW;
        goto Exit;
    }

    RtlCopyMemory( lpBuffer, UnicodeComputerName.Buffer, UnicodeComputerName.Length );
    *nSize = UnicodeComputerName.Length / sizeof(WCHAR);
    lpBuffer[ *nSize ] = L'\0';

    dwError = ERROR_SUCCESS;


Exit:

    return( dwError );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\comm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    comm.c

Abstract:

    This module implements Win32 comm APIs

Author:

    Anthony V. Ercolano (tonye) 25-April-1991

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include "ntddser.h"
#include "cfgmgr32.h"

WCHAR CfgmgrDllString[] = L"cfgmgr32.dll";

typedef struct _LOCALMATCHSTR {
    DWORD FoundIt;
    LPCWSTR FriendlyName;
    } LOCALMATCHSTR,*PLOCALMATCHSTR;


static
NTSTATUS
GetConfigDialogName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

{

    PUNICODE_STRING dllToLoad = Context;
    if (ValueType != REG_SZ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Allocate heap to hold the unicode string.  We know
    // that the string is zero terminated.  Allocate that
    // much.  Set the maximum size and size to
    // sizeof(WCHAR) - ValueLength.
    //

    RtlInitUnicodeString(
        dllToLoad,
        NULL
        );

    dllToLoad->Buffer = RtlAllocateHeap(
                            RtlProcessHeap(),
                            MAKE_TAG( TMP_TAG ),
                            ValueLength
                            );

    if (!dllToLoad->Buffer) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlMoveMemory(
        dllToLoad->Buffer,
        ValueData,
        ValueLength
        );

    dllToLoad->Length = (USHORT)(ValueLength - (sizeof(WCHAR)));
    dllToLoad->MaximumLength = (USHORT)ValueLength;

    return STATUS_SUCCESS;
}

static
NTSTATUS
GetFriendlyMatchComm(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

{

    UNICODE_STRING s1;
    UNICODE_STRING s2;
    PLOCALMATCHSTR localMatch = Context;

    RtlInitUnicodeString(
        &s1,
        localMatch->FriendlyName
        );
    RtlInitUnicodeString(
        &s2,
        ValueData
        );

    if (RtlEqualUnicodeString(
            &s1,
            &s2,
            TRUE
            )) {

        localMatch->FoundIt = TRUE;

    }

    return STATUS_SUCCESS;
}

VOID
GetFriendlyUi(
    LPCWSTR FriendlyName,
    PUNICODE_STRING DllToInvoke
    )

{

    RTL_QUERY_REGISTRY_TABLE paramTable[2] = {0};
    LOCALMATCHSTR localMatch = {0,FriendlyName};
    HINSTANCE libHandle;


    paramTable[0].QueryRoutine = GetFriendlyMatchComm;
    paramTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    //
    // First things first.  Load the cfg manager library.
    //

    libHandle = LoadLibraryW(CfgmgrDllString);

    if (libHandle) {

        FARPROC getSize;
        FARPROC getList;
        FARPROC locateDevNode;
        FARPROC openDevKey;

        try {
            getSize = GetProcAddress(
                          libHandle,
                          "CM_Get_Device_ID_List_SizeW"
                          );

            getList = GetProcAddress(
                          libHandle,
                          "CM_Get_Device_ID_ListW"
                          );

            locateDevNode = GetProcAddress(
                                libHandle,
                                "CM_Locate_DevNodeW"
                                );

            openDevKey = GetProcAddress(
                             libHandle,
                             "CM_Open_DevNode_Key"
                             );

            if (getSize && getList && locateDevNode && openDevKey) {

                PWCHAR bufferForList = NULL;
                DWORD sizeOfBuffer;

                //
                // Find how much memory for the buffer.
                //

                if (getSize(
                        &sizeOfBuffer,
                        L"MODEM",
                        CM_GETIDLIST_FILTER_SERVICE
                        ) == CR_SUCCESS) {

                    //
                    // Allocate 2 extra wchar.
                    //

                    bufferForList = RtlAllocateHeap(
                                        RtlProcessHeap(),
                                        MAKE_TAG( TMP_TAG ),
                                        (sizeOfBuffer*sizeof(WCHAR))
                                         +(sizeof(WCHAR)*2)
                                        );

                    if (bufferForList) {

                        PWCHAR currentId;

                        try {

                            if (getList(
                                    L"modem",
                                    bufferForList,
                                    sizeOfBuffer,
                                    CM_GETIDLIST_FILTER_SERVICE
                                    ) == CR_SUCCESS) {

                                for (
                                    currentId = bufferForList;
                                    *currentId;
                                    currentId += wcslen(currentId)+1
                                    ) {

                                    DWORD devInst = 0;

                                    if (locateDevNode(
                                            &devInst,
                                            currentId,
                                            CM_LOCATE_DEVINST_NORMAL
                                            ) == CR_SUCCESS) {

                                        HANDLE handleToDev;

                                        if (openDevKey(
                                                devInst,
                                                KEY_ALL_ACCESS,
                                                0,
                                                RegDisposition_OpenAlways,
                                                &handleToDev,
                                                CM_REGISTRY_SOFTWARE
                                                ) == CR_SUCCESS) {

                                            NTSTATUS statusOfQuery;

                                            localMatch.FoundIt = 0;
                                            paramTable[0].Name =
                                                L"FriendlyName";

                                            //
                                            // We now have an open
                                            // handle to a dev node.
                                            //
                                            // Check to see if it's
                                            // friendly name matches ours.
                                            //

                                            if (!NT_SUCCESS(
                                                     RtlQueryRegistryValues(
                                                         RTL_REGISTRY_HANDLE,
                                                         handleToDev,
                                                         &paramTable[0],
                                                         &localMatch,
                                                         NULL
                                                         )
                                                     )) {

                                                CloseHandle(handleToDev);
                                                continue;

                                            }

                                            if (!localMatch.FoundIt) {

                                                CloseHandle(handleToDev);
                                                continue;

                                            }

                                            //
                                            // The names match.  Now look
                                            // for the config dll name.
                                            //

                                            paramTable[0].QueryRoutine =
                                                GetConfigDialogName;
                                            paramTable[0].Name =
                                                L"ConfigDialog";
                                            statusOfQuery =
                                                RtlQueryRegistryValues(
                                                    RTL_REGISTRY_HANDLE,
                                                    handleToDev,
                                                    &paramTable[0],
                                                    DllToInvoke,
                                                    NULL
                                                    );

                                            paramTable[0].QueryRoutine =
                                                GetFriendlyMatchComm;

                                            if (!NT_SUCCESS(statusOfQuery)) {

                                                //
                                                // We had a bad status
                                                // back from getting the dll
                                                // name we should have gotten.
                                                //
                                                // There is no point in
                                                // looking for anymore
                                                //

                                                BaseSetLastNTError(
                                                    statusOfQuery
                                                    );
                                                CloseHandle(handleToDev);
                                                return;

                                            }

                                            //
                                            // We know that we are dealing
                                            // with a local registry here.
                                            // we just call closehandle.
                                            //

                                            CloseHandle(handleToDev);

                                            if (DllToInvoke->Buffer) {

                                                //
                                                // We have found a dll for
                                                // the friendly name.  Just
                                                // leave.  The finally
                                                // handlers will clean up
                                                // our allocations.
                                                //

                                                return;

                                            }

                                        }

                                    }

                                }

                            }


                        } finally {

                            //
                            // Free the idlist memory.
                            //

                            RtlFreeHeap(
                                RtlProcessHeap(),
                                0,
                                bufferForList
                                );

                        }

                    }

                }

            }

        } finally {

            FreeLibrary(libHandle);

        }

    }

    if (!DllToInvoke->Buffer) {

        //
        // Couldn't find the friendly name in the enum tree.
        // See if the value is a valid comm port name.  If
        // it is, default return serialui.dll
        //

        paramTable[0].Name = NULL;
        RtlQueryRegistryValues(
            RTL_REGISTRY_DEVICEMAP,
            L"SERIALCOMM",
            paramTable,
            &localMatch,
            NULL
            );

        if (localMatch.FoundIt) {

            ANSI_STRING ansiString;

            RtlInitAnsiString(
                &ansiString,
                "serialui.dll"
                );

            DllToInvoke->Buffer = RtlAllocateHeap(
                                      RtlProcessHeap(),
                                      MAKE_TAG( TMP_TAG ),
                                      (ansiString.Length+2)*sizeof(WCHAR)
                                      );

            if (!DllToInvoke->Buffer) {

                BaseSetLastNTError(STATUS_INSUFFICIENT_RESOURCES);
                return;

            }

            DllToInvoke->Length = 0;
            DllToInvoke->MaximumLength = (ansiString.Length+1)*sizeof(WCHAR);

            RtlAnsiStringToUnicodeString(
                DllToInvoke,
                &ansiString,
                FALSE
                );
            *(DllToInvoke->Buffer+ansiString.Length) = 0;

        } else {

            SetLastError(ERROR_INVALID_PARAMETER);

        }

    }

}


BOOL
CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    )

{


    UNICODE_STRING dllName = {0};
    BOOL boolToReturn = TRUE;
    HINSTANCE libInstance = 0;
    DWORD statOfCall = 0;


    //
    // Given the "friendly name" get the name of the dll to load.
    //

    GetFriendlyUi(
        lpszName,
        &dllName
        );

    try {

        if (dllName.Buffer) {

            //
            // Got the new library name.  Try to load it.
            //

            libInstance = LoadLibraryW(dllName.Buffer);

            if (libInstance) {

                FARPROC procToCall;

                //
                // Got the lib.  Get the proc address we need.
                //

                procToCall = GetProcAddress(
                                 libInstance,
                                 "drvCommConfigDialogW"
                                 );

                statOfCall = (DWORD)procToCall(
                                 lpszName,
                                 hWnd,
                                 lpCC
                                 );

            } else {

                boolToReturn = FALSE;

            }

        } else {

            //
            // Assume that an appropriate error has been set.
            //

            boolToReturn = FALSE;

        }


    } finally {

        if (dllName.Buffer) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                dllName.Buffer
                );

        }

        if (libInstance) {

            FreeLibrary(libInstance);

        }

        if (statOfCall) {

            SetLastError(statOfCall);
            boolToReturn = FALSE;

        }

    }

    return boolToReturn;


}

BOOL
CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    )

{

    PWCHAR unicodeName;
    UNICODE_STRING tmpString;
    ANSI_STRING ansiString;
    BOOL uniBool;

    RtlInitAnsiString(
        &ansiString,
        lpszName
        );

    unicodeName = RtlAllocateHeap(
                      RtlProcessHeap(),
                      MAKE_TAG( TMP_TAG ),
                      (ansiString.Length+2)*sizeof(WCHAR)
                      );

    if (!unicodeName) {

        BaseSetLastNTError(STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;

    }

    tmpString.Length = 0;
    tmpString.MaximumLength = (ansiString.Length+1)*sizeof(WCHAR);
    tmpString.Buffer = unicodeName;

    RtlAnsiStringToUnicodeString(
        &tmpString,
        &ansiString,
        FALSE
        );
    *(unicodeName+ansiString.Length) = 0;

    try {

        uniBool = CommConfigDialogW(
                      unicodeName,
                      hWnd,
                      lpCC
                      );


    } finally {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            unicodeName
            );

    }

    return uniBool;

}

BOOL
GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    )
{

    UNICODE_STRING dllName = {0};
    BOOL boolToReturn = TRUE;
    HINSTANCE libInstance = 0;
    DWORD statOfCall = 0;


    //
    // Given the "friendly name" get the name of the dll to load.
    //

    GetFriendlyUi(
        lpszName,
        &dllName
        );

    try {

        if (dllName.Buffer) {

            //
            // Got the new library name.  Try to load it.
            //

            libInstance = LoadLibraryW(dllName.Buffer);

            if (libInstance) {

                FARPROC procToCall;

                //
                // Got the lib.  Get the proc address we need.
                //

                procToCall = GetProcAddress(
                                 libInstance,
                                 "drvGetDefaultCommConfigW"
                                 );

                statOfCall = (DWORD)procToCall(
                                 lpszName,
                                 lpCC,
                                 lpdwSize
                                 );

            } else {

                boolToReturn = FALSE;

            }

        } else {

            //
            // Assume that an appropriate error has been set.
            //

            boolToReturn = FALSE;

        }


    } finally {

        if (dllName.Buffer) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                dllName.Buffer
                );

        }

        if (libInstance) {

            FreeLibrary(libInstance);

        }

        if (statOfCall) {

            SetLastError(statOfCall);
            boolToReturn = FALSE;

        }

    }

    return boolToReturn;

}

BOOL
GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    )
{

    PWCHAR unicodeName;
    UNICODE_STRING tmpString;
    ANSI_STRING ansiString;
    BOOL uniBool;

    RtlInitAnsiString(
        &ansiString,
        lpszName
        );

    unicodeName = RtlAllocateHeap(
                      RtlProcessHeap(),
                      MAKE_TAG( TMP_TAG ),
                      (ansiString.Length+2)*sizeof(WCHAR)
                      );

    if (!unicodeName) {

        BaseSetLastNTError(STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;

    }

    tmpString.Length = 0;
    tmpString.MaximumLength = (ansiString.Length+1)*sizeof(WCHAR);
    tmpString.Buffer = unicodeName;

    RtlAnsiStringToUnicodeString(
        &tmpString,
        &ansiString,
        FALSE
        );
    *(unicodeName+ansiString.Length) = 0;

    try {

        uniBool = GetDefaultCommConfigW(
                      unicodeName,
                      lpCC,
                      lpdwSize
                      );

    } finally {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            unicodeName
            );

    }

    return uniBool;

}

BOOL
SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    )
{

    UNICODE_STRING dllName = {0};
    BOOL boolToReturn = TRUE;
    HINSTANCE libInstance = 0;
    DWORD statOfCall = 0;


    //
    // Given the "friendly name" get the name of the dll to load.
    //

    GetFriendlyUi(
        lpszName,
        &dllName
        );

    try {

        if (dllName.Buffer) {

            //
            // Got the new library name.  Try to load it.
            //

            libInstance = LoadLibraryW(dllName.Buffer);

            if (libInstance) {

                FARPROC procToCall;

                //
                // Got the lib.  Get the proc address we need.
                //

                procToCall = GetProcAddress(
                                 libInstance,
                                 "drvSetDefaultCommConfigW"
                                 );

                statOfCall = (DWORD)procToCall(
                                 lpszName,
                                 lpCC,
                                 dwSize
                                 );

            } else {

                boolToReturn = FALSE;

            }

        } else {

            //
            // Assume that an appropriate error has been set.
            //

            boolToReturn = FALSE;

        }


    } finally {

        if (dllName.Buffer) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                dllName.Buffer
                );

        }

        if (libInstance) {

            FreeLibrary(libInstance);

        }

        if (statOfCall) {

            SetLastError(statOfCall);
            boolToReturn = FALSE;

        }

    }
    return boolToReturn;
}

BOOL
SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    )
{

    PWCHAR unicodeName;
    UNICODE_STRING tmpString;
    ANSI_STRING ansiString;
    BOOL uniBool = TRUE;

    RtlInitAnsiString(
        &ansiString,
        lpszName
        );

    unicodeName = RtlAllocateHeap(
                      RtlProcessHeap(),
                      MAKE_TAG( TMP_TAG ),
                      (ansiString.Length+2)*sizeof(WCHAR)
                      );

    if (!unicodeName) {

        BaseSetLastNTError(STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;

    }

    tmpString.Length = 0;
    tmpString.MaximumLength = (ansiString.Length+1)*sizeof(WCHAR);
    tmpString.Buffer = unicodeName;

    RtlAnsiStringToUnicodeString(
        &tmpString,
        &ansiString,
        FALSE
        );
    *(unicodeName+ansiString.Length) = 0;

    try {

        uniBool = SetDefaultCommConfigW(
                      unicodeName,
                      lpCC,
                      dwSize
                      );

    } finally {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            unicodeName
            );

    }

    return uniBool;

}

BOOL
ClearCommBreak(
    HANDLE hFile
    )

/*++

Routine Description:

    The function restores character transmission and places the transmission
    line in a nonbreak state.

Arguments:

    hFile - Specifies the communication device to be adjusted.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    return EscapeCommFunction(hFile,CLRBREAK);

}

BOOL
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    )

/*++

Routine Description:

    In case of a communications error, such as a buffer overrun or
    framing error, the communications software will abort all
    read and write operations on the communication port.  No further
    read or write operations will be accepted until this function
    is called.

Arguments:

    hFile - Specifies the communication device to be adjusted.

    lpErrors - Points to the DWORD that is to receive the mask of the
               error that occured.

    lpStat - Points to the COMMSTAT structure that is to receive
             the device status.  The structure contains information
             about the communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_STATUS LocalStat;

    RtlZeroMemory(&LocalStat, sizeof(SERIAL_STATUS));

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_COMMSTATUS,
                 NULL,
                 0,
                 &LocalStat,
                 sizeof(LocalStat)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (lpStat) {

        //
        // All is well up to this point.  Translate the NT values
        // into win32 values.
        //

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_CTS) {

            lpStat->fCtsHold = TRUE;

        } else {

            lpStat->fCtsHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DSR) {

            lpStat->fDsrHold = TRUE;

        } else {

            lpStat->fDsrHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DCD) {

            lpStat->fRlsdHold = TRUE;

        } else {

            lpStat->fRlsdHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_XON) {

            lpStat->fXoffHold = TRUE;

        } else {

            lpStat->fXoffHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_XOFF_SENT) {

            lpStat->fXoffSent = TRUE;

        } else {

            lpStat->fXoffSent = FALSE;

        }

        lpStat->fEof = LocalStat.EofReceived;
        lpStat->fTxim = LocalStat.WaitForImmediate;
        lpStat->cbInQue = LocalStat.AmountInInQueue;
        lpStat->cbOutQue = LocalStat.AmountInOutQueue;

    }

    if (lpErrors) {

        *lpErrors = 0;

        if (LocalStat.Errors & SERIAL_ERROR_BREAK) {

            *lpErrors = *lpErrors | CE_BREAK;

        }

        if (LocalStat.Errors & SERIAL_ERROR_FRAMING) {

            *lpErrors = *lpErrors | CE_FRAME;

        }

        if (LocalStat.Errors & SERIAL_ERROR_OVERRUN) {

            *lpErrors = *lpErrors | CE_OVERRUN;

        }

        if (LocalStat.Errors & SERIAL_ERROR_QUEUEOVERRUN) {

            *lpErrors = *lpErrors | CE_RXOVER;

        }

        if (LocalStat.Errors & SERIAL_ERROR_PARITY) {

            *lpErrors = *lpErrors | CE_RXPARITY;

        }

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    )

/*++

Routine Description:

    The communication device is not initialized until SetupComm is
    called.  This function allocates space for receive and transmit
    queues.  These queues are used by the interrupt-driven transmit/
    receive software and are internal to the provider.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwInQueue - Specifies the recommended size of the provider's
                internal receive queue in bytes.  This value must be
                even.  A value of -1 indicates that the default should
                be used.

    dwOutQueue - Specifies the recommended size of the provider's
                 internal transmit queue in bytes.  This value must be
                 even.  A value of -1 indicates that the default should
                 be used.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;

    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_QUEUE_SIZE NewSizes = {0};

    //
    // Make sure that the sizes are even.
    //

    if (dwOutQueue != ((DWORD)-1)) {

        if (((dwOutQueue/2)*2) != dwOutQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    if (dwInQueue != ((DWORD)-1)) {

        if (((dwInQueue/2)*2) != dwInQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    NewSizes.InSize = dwInQueue;
    NewSizes.OutSize = dwOutQueue;


    if (!(SyncEvent = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_SET_QUEUE_SIZE,
                 &NewSizes,
                 sizeof(SERIAL_QUEUE_SIZE),
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    )

/*++

Routine Description:

    This function directs the communication-device specified by the
    hFile parameter to carry out the extended function specified by
    the dwFunc parameter.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwFunc - Specifies the function code of the extended function.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    ULONG ControlCode;
    HANDLE Event;

    switch (dwFunc) {

        case SETXOFF: {
            ControlCode = IOCTL_SERIAL_SET_XOFF;
            break;
        }

        case SETXON: {
            ControlCode = IOCTL_SERIAL_SET_XON;
            break;
        }

        case SETRTS: {
            ControlCode = IOCTL_SERIAL_SET_RTS;
            break;
        }

        case CLRRTS: {
            ControlCode = IOCTL_SERIAL_CLR_RTS;
            break;
        }

        case SETDTR: {
            ControlCode = IOCTL_SERIAL_SET_DTR;
            break;
        }

        case CLRDTR: {
            ControlCode = IOCTL_SERIAL_CLR_DTR;
            break;
        }

        case RESETDEV: {
            ControlCode = IOCTL_SERIAL_RESET_DEVICE;
            break;
        }

        case SETBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_ON;
            break;
        }

        case CLRBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_OFF;
            break;
        }
        default: {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;


        }
    }


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 Event,
                 NULL,
                 NULL,
                 &Iosb,
                 ControlCode,
                 NULL,
                 0,
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( Event, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(Event);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(Event);
    return TRUE;

}

BOOL
GetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    )
{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    ULONG configLength;
    HANDLE Event;
    DWORD olddwSize = *lpdwSize;


    //
    // Ask the device how big the device config structure is.
    //

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hCommDev,
                 Event,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_CONFIG_SIZE,
                 NULL,
                 0,
                 &configLength,
                 sizeof(configLength)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( Event, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        configLength = 0;

    }

    if (!configLength) {

        //
        // The size needed is simply the size of the comm config structure.
        //

        CloseHandle(Event);
        if (!ARGUMENT_PRESENT(lpdwSize)) {

            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;

        } else {

            *lpdwSize = sizeof(COMMCONFIG);

            if (ARGUMENT_PRESENT(lpCC)) {

                //
                // Fill in the random fields.
                //

                lpCC->dwSize = sizeof(COMMCONFIG);
                lpCC->wVersion = 1;
                lpCC->wReserved = 0;
                lpCC->dwProviderSubType = PST_RS232;
                lpCC->dwProviderOffset = 0;
                lpCC->dwProviderSize = 0;
                lpCC->wcProviderData[0] = 0;

                return GetCommState(
                           hCommDev,
                           &lpCC->dcb
                           );

            } else {

                return TRUE;

            }

        }

    } else {

        if (!ARGUMENT_PRESENT(lpdwSize)) {

            CloseHandle(Event);
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;

        } else {

            if (*lpdwSize < sizeof(COMMCONFIG)) {

                CloseHandle(Event);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                *lpdwSize = configLength;
                return FALSE;

            } else {

                if (ARGUMENT_PRESENT(lpCC)) {

                    lpCC->wVersion = 1;
                    lpCC->dwProviderSubType = PST_MODEM;

                    if (*lpdwSize < configLength) {

                        lpCC->dwProviderOffset = 0;
                        lpCC->dwProviderSize = 0;
                        lpCC->wcProviderData[0] = 0;
                        *lpdwSize = sizeof(COMMCONFIG);
                        CloseHandle(Event);

                        return GetCommState(
                                   hCommDev,
                                   &lpCC->dcb
                                   );

                    } else {

                        *lpdwSize = configLength;

                        //
                        // Call down to the lower level serial provider
                        // if there is a passed comm config.  Assume
                        // that the buffer is as large as it needs to be.
                        // Parameter validation will insure that we
                        // can write to at least that much.
                        //

                        Status = NtDeviceIoControlFile(
                                     hCommDev,
                                     Event,
                                     NULL,
                                     NULL,
                                     &Iosb,
                                     IOCTL_SERIAL_GET_COMMCONFIG,
                                     NULL,
                                     0,
                                     lpCC,
                                     configLength
                                     );

                        if ( Status == STATUS_PENDING) {

                            // Operation must complete before return & IoStatusBlock destroyed

                            Status = NtWaitForSingleObject( Event, FALSE, NULL );
                            if ( NT_SUCCESS(Status)) {

                                Status = Iosb.Status;

                            }
                        }

                        if (NT_ERROR(Status)) {

                            CloseHandle(Event);
                            BaseSetLastNTError(Status);
                            return FALSE;

                        }

                        //
                        // Got the config stuff, get the comm state too.
                        //

                        CloseHandle(Event);
                        return GetCommState(
                                   hCommDev,
                                   &lpCC->dcb
                                   );

                    }

                } else {


                    *lpdwSize = configLength;
                    CloseHandle(Event);
                    return TRUE;

                }

            }

        }

    }

}

BOOL
GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    )

/*++

Routine Description:


    This function retrieves the value of the event mask for the handle
    hFile. The mask is not cleared

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpEvtMask - Points to a DWORD which is to receive the mask of events
                which are currently enabled.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;

    //
    // First we do an assert to make sure that the
    // values in the win header files are the same
    // as the nt serial interface, and that the
    // size of the win32 wait mask is the same size
    // as the nt wait mask.
    //

    ASSERT((SERIAL_EV_RXCHAR   == EV_RXCHAR  ) &&
           (SERIAL_EV_RXFLAG   == EV_RXFLAG  ) &&
           (SERIAL_EV_TXEMPTY  == EV_TXEMPTY ) &&
           (SERIAL_EV_CTS      == EV_CTS     ) &&
           (SERIAL_EV_DSR      == EV_DSR     ) &&
           (SERIAL_EV_RLSD     == EV_RLSD    ) &&
           (SERIAL_EV_BREAK    == EV_BREAK   ) &&
           (SERIAL_EV_ERR      == EV_ERR     ) &&
           (SERIAL_EV_RING     == EV_RING    ) &&
           (SERIAL_EV_PERR     == EV_PERR    ) &&
           (SERIAL_EV_RX80FULL == EV_RX80FULL) &&
           (SERIAL_EV_EVENT1   == EV_EVENT1  ) &&
           (SERIAL_EV_EVENT2   == EV_EVENT2  ) &&
           (sizeof(ULONG) == sizeof(DWORD)));

    //
    // All is well, get the mask from the driver.
    //

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_WAIT_MASK,
                 NULL,
                 0,
                 lpEvtMask,
                 sizeof(ULONG)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    )

/*++

Routine Description:

    This routine returns the most current value of the modem
    status registers non-delta values.


Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpEvtMask - Points to a DWORD which is to receive the mask of
                non-delta values in the modem status register.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_MODEMSTATUS,
                 NULL,
                 0,
                 lpModemStat,
                 sizeof(DWORD)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    )

/*++

Routine Description:

    This function fills the ubffer pointed to by lpCommProp with the
    communications properties associated with the communications device
    specified by the hFile.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpCommProp - Points to the COMMPROP data structure that is to
                 receive the communications properties structure.  This
                 structure defines certain properties of the communications
                 device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    DWORD bufferLength;

    //
    // Make sure that the windows defines and the nt defines are
    // still in sync.
    //

    ASSERT((SERIAL_PCF_DTRDSR        == PCF_DTRDSR) &&
           (SERIAL_PCF_RTSCTS        == PCF_RTSCTS) &&
           (SERIAL_PCF_CD            == PCF_RLSD) &&
           (SERIAL_PCF_PARITY_CHECK  == PCF_PARITY_CHECK) &&
           (SERIAL_PCF_XONXOFF       == PCF_XONXOFF) &&
           (SERIAL_PCF_SETXCHAR      == PCF_SETXCHAR) &&
           (SERIAL_PCF_TOTALTIMEOUTS == PCF_TOTALTIMEOUTS) &&
           (SERIAL_PCF_INTTIMEOUTS   == PCF_INTTIMEOUTS) &&
           (SERIAL_PCF_SPECIALCHARS  == PCF_SPECIALCHARS) &&
           (SERIAL_PCF_16BITMODE     == PCF_16BITMODE) &&
           (SERIAL_SP_PARITY         == SP_PARITY) &&
           (SERIAL_SP_BAUD           == SP_BAUD) &&
           (SERIAL_SP_DATABITS       == SP_DATABITS) &&
           (SERIAL_SP_STOPBITS       == SP_STOPBITS) &&
           (SERIAL_SP_HANDSHAKING    == SP_HANDSHAKING) &&
           (SERIAL_SP_PARITY_CHECK   == SP_PARITY_CHECK) &&
           (SERIAL_SP_CARRIER_DETECT == SP_RLSD) &&
           (SERIAL_BAUD_075          == BAUD_075) &&
           (SERIAL_BAUD_110          == BAUD_110) &&
           (SERIAL_BAUD_134_5        == BAUD_134_5) &&
           (SERIAL_BAUD_150          == BAUD_150) &&
           (SERIAL_BAUD_300          == BAUD_300) &&
           (SERIAL_BAUD_600          == BAUD_600) &&
           (SERIAL_BAUD_1200         == BAUD_1200) &&
           (SERIAL_BAUD_1800         == BAUD_1800) &&
           (SERIAL_BAUD_2400         == BAUD_2400) &&
           (SERIAL_BAUD_4800         == BAUD_4800) &&
           (SERIAL_BAUD_7200         == BAUD_7200) &&
           (SERIAL_BAUD_9600         == BAUD_9600) &&
           (SERIAL_BAUD_14400        == BAUD_14400) &&
           (SERIAL_BAUD_19200        == BAUD_19200) &&
           (SERIAL_BAUD_38400        == BAUD_38400) &&
           (SERIAL_BAUD_56K          == BAUD_56K) &&
           (SERIAL_BAUD_57600        == BAUD_57600) &&
           (SERIAL_BAUD_115200       == BAUD_115200) &&
           (SERIAL_BAUD_USER         == BAUD_USER) &&
           (SERIAL_DATABITS_5        == DATABITS_5) &&
           (SERIAL_DATABITS_6        == DATABITS_6) &&
           (SERIAL_DATABITS_7        == DATABITS_7) &&
           (SERIAL_DATABITS_8        == DATABITS_8) &&
           (SERIAL_DATABITS_16       == DATABITS_16) &&
           (SERIAL_DATABITS_16X      == DATABITS_16X) &&
           (SERIAL_STOPBITS_10       == STOPBITS_10) &&
           (SERIAL_STOPBITS_15       == STOPBITS_15) &&
           (SERIAL_STOPBITS_20       == STOPBITS_20) &&
           (SERIAL_PARITY_NONE       == PARITY_NONE) &&
           (SERIAL_PARITY_ODD        == PARITY_ODD) &&
           (SERIAL_PARITY_EVEN       == PARITY_EVEN) &&
           (SERIAL_PARITY_MARK       == PARITY_MARK) &&
           (SERIAL_PARITY_SPACE      == PARITY_SPACE));
    ASSERT((SERIAL_SP_UNSPECIFIED    == PST_UNSPECIFIED) &&
           (SERIAL_SP_RS232          == PST_RS232) &&
           (SERIAL_SP_PARALLEL       == PST_PARALLELPORT) &&
           (SERIAL_SP_RS422          == PST_RS422) &&
           (SERIAL_SP_RS423          == PST_RS423) &&
           (SERIAL_SP_RS449          == PST_RS449) &&
           (SERIAL_SP_FAX            == PST_FAX) &&
           (SERIAL_SP_SCANNER        == PST_SCANNER) &&
           (SERIAL_SP_BRIDGE         == PST_NETWORK_BRIDGE) &&
           (SERIAL_SP_LAT            == PST_LAT) &&
           (SERIAL_SP_TELNET         == PST_TCPIP_TELNET) &&
           (SERIAL_SP_X25            == PST_X25));

    ASSERT(sizeof(SERIAL_COMMPROP) == sizeof(COMMPROP));
    //
    // Get the total length of what to pass down.  If the
    // application indicates that there is provider specific data
    // (by setting dwProvSpec1 to COMMPROP_INITIAILIZED) then
    // use what's at the start of the commprop.
    //

    bufferLength = sizeof(COMMPROP);

    if (lpCommProp->dwProvSpec1 == COMMPROP_INITIALIZED) {

        bufferLength = lpCommProp->wPacketLength;

    }

    //
    // Zero out the commprop.  This might create an access violation
    // if it isn't big enough.  Which is ok, since we would rather
    // get it before we create the sync event.
    //

    RtlZeroMemory(lpCommProp, bufferLength);

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_PROPERTIES,
                 NULL,
                 0,
                 lpCommProp,
                 bufferLength
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function fills the buffer pointed to by the lpDCB parameter with
    the device control block of the communication device specified by hFile
    parameter.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpDCB - Points to the DCB data structure that is to receive the current
            device control block.  The structure defines the control settings
            for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    //
    // Make sure the windows mapping is the same as the NT mapping.
    //

    ASSERT((ONESTOPBIT == STOP_BIT_1) &&
           (ONE5STOPBITS == STOP_BITS_1_5) &&
           (TWOSTOPBITS == STOP_BITS_2));

    ASSERT((NOPARITY == NO_PARITY) &&
           (ODDPARITY == ODD_PARITY) &&
           (EVENPARITY == EVEN_PARITY) &&
           (MARKPARITY == MARK_PARITY) &&
           (SPACEPARITY == SPACE_PARITY));

    //
    // Zero out the dcb.  This might create an access violation
    // if it isn't big enough.  Which is ok, since we would rather
    // get it before we create the sync event.
    //

    RtlZeroMemory(lpDCB, sizeof(DCB));

    lpDCB->DCBlength = sizeof(DCB);
    lpDCB->fBinary = TRUE;

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_BAUD_RATE,
                 NULL,
                 0,
                 &LocalBaud,
                 sizeof(LocalBaud)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->BaudRate = LocalBaud.BaudRate;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_LINE_CONTROL,
                 NULL,
                 0,
                 &LineControl,
                 sizeof(LineControl)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->Parity = LineControl.Parity;
    lpDCB->ByteSize = LineControl.WordLength;
    lpDCB->StopBits = LineControl.StopBits;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_CHARS,
                 NULL,
                 0,
                 &Chars,
                 sizeof(Chars)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->XonChar = Chars.XonChar;
    lpDCB->XoffChar = Chars.XoffChar;
    lpDCB->ErrorChar = Chars.ErrorChar;
    lpDCB->EofChar = Chars.EofChar;
    lpDCB->EvtChar = Chars.EventChar;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_HANDFLOW,
                 NULL,
                 0,
                 &HandFlow,
                 sizeof(HandFlow)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {

        lpDCB->fOutxCtsFlow = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) {

        lpDCB->fOutxDsrFlow = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) {

        lpDCB->fOutX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) {

        lpDCB->fInX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_NULL_STRIPPING) {

        lpDCB->fNull = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_ERROR_CHAR) {

        lpDCB->fErrorChar = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_XOFF_CONTINUE) {

        lpDCB->fTXContinueOnXoff = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) {

        lpDCB->fAbortOnError = TRUE;

    }

    switch (HandFlow.FlowReplace & SERIAL_RTS_MASK) {
        case 0:
            lpDCB->fRtsControl = RTS_CONTROL_DISABLE;
            break;
        case SERIAL_RTS_CONTROL:
            lpDCB->fRtsControl = RTS_CONTROL_ENABLE;
            break;
        case SERIAL_RTS_HANDSHAKE:
            lpDCB->fRtsControl = RTS_CONTROL_HANDSHAKE;
            break;
        case SERIAL_TRANSMIT_TOGGLE:
            lpDCB->fRtsControl = RTS_CONTROL_TOGGLE;
            break;
    }

    switch (HandFlow.ControlHandShake & SERIAL_DTR_MASK) {
        case 0:
            lpDCB->fDtrControl = DTR_CONTROL_DISABLE;
            break;
        case SERIAL_DTR_CONTROL:
            lpDCB->fDtrControl = DTR_CONTROL_ENABLE;
            break;
        case SERIAL_DTR_HANDSHAKE:
            lpDCB->fDtrControl = DTR_CONTROL_HANDSHAKE;
            break;
    }

    lpDCB->fDsrSensitivity =
        (HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY)?(TRUE):(FALSE);
    lpDCB->XonLim = (WORD)HandFlow.XonLimit;
    lpDCB->XoffLim = (WORD)HandFlow.XoffLimit;

    CloseHandle(SyncEvent);
    return TRUE;
}

BOOL
GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function returns the timeout characteristics for all read and
    write operations on the handle specified by hFile.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpCommTimeouts - Points to a structure which is to receive the
                     current communications timeouts.


Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_TIMEOUTS To;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {


        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_GET_TIMEOUTS,
                     NULL,
                     0,
                     &To,
                     sizeof(To)
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS( Status )) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            BaseSetLastNTError(Status);
            CloseHandle(Event);
            return FALSE;

        }

        CloseHandle(Event);

        //
        // Everything went ok.  Move the value from the Nt records
        // to the windows record.
        //

        lpCommTimeouts->ReadIntervalTimeout = To.ReadIntervalTimeout;
        lpCommTimeouts->ReadTotalTimeoutMultiplier = To.ReadTotalTimeoutMultiplier;
        lpCommTimeouts->ReadTotalTimeoutConstant = To.ReadTotalTimeoutConstant;
        lpCommTimeouts->WriteTotalTimeoutMultiplier = To.WriteTotalTimeoutMultiplier;
        lpCommTimeouts->WriteTotalTimeoutConstant = To.WriteTotalTimeoutConstant;

        return TRUE;

    }

}

BOOL
PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    This function is used to purge all characters from the transmit
    or receive queues of the communication device specified by the
    hFile parameter.  The dwFlags parameter specifies what function
    is to be performed.

Arguments:

    hFile - Specifies the communication device to be purged.
            The CreateFile function returns this value.

    dwFlags - Bit mask defining actions to be taken.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_PURGE,
                     &dwFlags,
                     sizeof(ULONG),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS( Status )) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }


}

BOOL
SetCommBreak(
    HANDLE hFile
    )

/*++

Routine Description:

    The function suspends character transmission and places the transmission
    line in a break state until the break condition is cleared..

Arguments:

    hFile - Specifies the communication device to be suspended.
            The CreateFile function returns this value.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    return EscapeCommFunction(hFile,SETBREAK);

}

BOOL
SetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    )

{


    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;
    LPCOMMCONFIG comConf = lpCC;

    if (lpCC->dwProviderOffset) {

        if (!(Event = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

            return FALSE;

        }

        //
        //
        // Call the driver to set the config structure.
        //

        Status = NtDeviceIoControlFile(
                     hCommDev,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_COMMCONFIG,
                     lpCC,
                     dwSize,
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }
        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);

    }

    return SetCommState(
               hCommDev,
               &comConf->dcb
               );
}

BOOL
SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    )

/*++

Routine Description:

    The function enables the event mask of the communication device
    specified by the hFile parameter.  The bits of the nEvtMask parameter
    define which events are to be enabled.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwEvtMask - Specifies which events are to enabled.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    //
    // First we do an assert to make sure that the
    // values in the win header files are the same
    // as the nt serial interface and the the size
    // mask that serial expects is the same as the
    // size that win32 expects.
    //

    ASSERT((SERIAL_EV_RXCHAR   == EV_RXCHAR  ) &&
           (SERIAL_EV_RXFLAG   == EV_RXFLAG  ) &&
           (SERIAL_EV_TXEMPTY  == EV_TXEMPTY ) &&
           (SERIAL_EV_CTS      == EV_CTS     ) &&
           (SERIAL_EV_DSR      == EV_DSR     ) &&
           (SERIAL_EV_RLSD     == EV_RLSD    ) &&
           (SERIAL_EV_BREAK    == EV_BREAK   ) &&
           (SERIAL_EV_ERR      == EV_ERR     ) &&
           (SERIAL_EV_RING     == EV_RING    ) &&
           (SERIAL_EV_PERR     == EV_PERR    ) &&
           (SERIAL_EV_RX80FULL == EV_RX80FULL) &&
           (SERIAL_EV_EVENT1   == EV_EVENT1  ) &&
           (SERIAL_EV_EVENT2   == EV_EVENT2  ) &&
           (sizeof(DWORD) == sizeof(ULONG)));


    //
    // Make sure that the users mask doesn't contain any values
    // we don't support.
    //

    if (dwEvtMask & (~(EV_RXCHAR   |
                       EV_RXFLAG   |
                       EV_TXEMPTY  |
                       EV_CTS      |
                       EV_DSR      |
                       EV_RLSD     |
                       EV_BREAK    |
                       EV_ERR      |
                       EV_RING     |
                       EV_PERR     |
                       EV_RX80FULL |
                       EV_EVENT1   |
                       EV_EVENT2))) {

        SetLastError(ERROR_INVALID_DATA);
        return FALSE;

    }


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {


        //
        // All is well, send the mask to the driver.
        //

        ULONG LocalMask = dwEvtMask;

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_WAIT_MASK,
                     &LocalMask,
                     sizeof(ULONG),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS( Status )) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    The SetCommState function sets a communication device to the state
    specified in the lpDCB parameter.  The device is identified by the
    hFile parameter.  This function reinitializes all hardwae and controls
    as specified byt the lpDCB, but does not empty the transmit or
    receive queues.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpDCB - Points to a DCB structure that contains the desired
            communications setting for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow = {0};
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Keep a copy of what the DCB was like before we started
    // changing things.  If some error occurs we can use
    // it to restore the old setup.
    //
    DCB OldDcb;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.  While it would be very
    // strange to be setting the comm state while IO is active
    // we need to make sure we don't compound the problem by
    // returning before this API's IO is actually finished.  This
    // can happen because the file handle is set on the completion
    // of any IO.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    if (GetCommState(
            hFile,
            &OldDcb
            )) {

        //
        // Try to set the baud rate.  If we fail here, we just return
        // because we never actually got to set anything.
        //

        if (!(SyncEvent = CreateEvent(
                              NULL,
                              TRUE,
                              FALSE,
                              NULL
                              ))) {

            return FALSE;

        }

        LocalBaud.BaudRate = lpDCB->BaudRate;
        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_BAUD_RATE,
                     &LocalBaud,
                     sizeof(LocalBaud),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        LineControl.StopBits = lpDCB->StopBits;
        LineControl.Parity = lpDCB->Parity;
        LineControl.WordLength = lpDCB->ByteSize;
        LocalBaud.BaudRate = lpDCB->BaudRate;
        Chars.XonChar   = lpDCB->XonChar;
        Chars.XoffChar  = lpDCB->XoffChar;
        Chars.ErrorChar = lpDCB->ErrorChar;
        Chars.BreakChar = lpDCB->ErrorChar;
        Chars.EofChar   = lpDCB->EofChar;
        Chars.EventChar = lpDCB->EvtChar;

        HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
        switch (lpDCB->fRtsControl) {
            case RTS_CONTROL_DISABLE:
                break;
            case RTS_CONTROL_ENABLE:
                HandFlow.FlowReplace |= SERIAL_RTS_CONTROL;
                break;
            case RTS_CONTROL_HANDSHAKE:
                HandFlow.FlowReplace |= SERIAL_RTS_HANDSHAKE;
                break;
            case RTS_CONTROL_TOGGLE:
                HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        HandFlow.ControlHandShake &= ~SERIAL_DTR_MASK;
        switch (lpDCB->fDtrControl) {
            case DTR_CONTROL_DISABLE:
                break;
            case DTR_CONTROL_ENABLE:
                HandFlow.ControlHandShake |= SERIAL_DTR_CONTROL;
                break;
            case DTR_CONTROL_HANDSHAKE:
                HandFlow.ControlHandShake |= SERIAL_DTR_HANDSHAKE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        if (lpDCB->fDsrSensitivity) {

            HandFlow.ControlHandShake |= SERIAL_DSR_SENSITIVITY;

        }

        if (lpDCB->fOutxCtsFlow) {

            HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;

        }

        if (lpDCB->fOutxDsrFlow) {

            HandFlow.ControlHandShake |= SERIAL_DSR_HANDSHAKE;

        }

        if (lpDCB->fOutX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_TRANSMIT;

        }

        if (lpDCB->fInX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_RECEIVE;

        }

        if (lpDCB->fNull) {

            HandFlow.FlowReplace |= SERIAL_NULL_STRIPPING;

        }

        if (lpDCB->fErrorChar) {

            HandFlow.FlowReplace |= SERIAL_ERROR_CHAR;
        }

        if (lpDCB->fTXContinueOnXoff) {

            HandFlow.FlowReplace |= SERIAL_XOFF_CONTINUE;

        }

        if (lpDCB->fAbortOnError) {

            HandFlow.ControlHandShake |= SERIAL_ERROR_ABORT;

        }

        //
        // For win95 compatiblity, if we are setting with
        // xxx_control_XXXXXXX then set the modem status line
        // to that state.
        //

        if (lpDCB->fRtsControl == RTS_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETRTS
                );

        } else if (lpDCB->fRtsControl == RTS_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRRTS
                );

        }
        if (lpDCB->fDtrControl == DTR_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETDTR
                );

        } else if (lpDCB->fDtrControl == DTR_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRDTR
                );

        }




        HandFlow.XonLimit = lpDCB->XonLim;
        HandFlow.XoffLimit = lpDCB->XoffLim;


        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_LINE_CONTROL,
                     &LineControl,
                     sizeof(LineControl),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_CHARS,
                     &Chars,
                     sizeof(Chars),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_HANDFLOW,
                     &HandFlow,
                     sizeof(HandFlow),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }
        CloseHandle(SyncEvent);
        return TRUE;

    }

    return FALSE;

}

BOOL
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function establishes the timeout characteristics for all
    read and write operations on the handle specified by hFile.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpCommTimeouts - Points to a structure containing timeout parameters.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_TIMEOUTS To;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    To.ReadIntervalTimeout = lpCommTimeouts->ReadIntervalTimeout;
    To.ReadTotalTimeoutMultiplier = lpCommTimeouts->ReadTotalTimeoutMultiplier;
    To.ReadTotalTimeoutConstant = lpCommTimeouts->ReadTotalTimeoutConstant;
    To.WriteTotalTimeoutMultiplier = lpCommTimeouts->WriteTotalTimeoutMultiplier;
    To.WriteTotalTimeoutConstant = lpCommTimeouts->WriteTotalTimeoutConstant;


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_TIMEOUTS,
                     &To,
                     sizeof(To),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
TransmitCommChar(
    HANDLE hFile,
    char cChar
    )

/*++

Routine Description:

    The function marks the character specified by the cChar parameter
    for immediate transmission, by placing it at the head of the transmit
    queue.

Arguments:

    hFile - Specifies the communication device to send the character.
            The CreateFile function returns this value.

    cChar - Specifies the character to be placed in the recieve queue.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_IMMEDIATE_CHAR,
                     &cChar,
                     sizeof(UCHAR),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function will wait until any of the events occur that were
    provided as the nEvtMask parameter to SetcommMask.  If while waiting
    the event mask is changed (via another call to SetCommMask), the
    function will return immediately.  The function will fill the EvtMask
    pointed to by the lpEvtMask parameter with the reasons that the
    wait was satisfied.

Arguments:

    hFile - Specifies the communication device to be waited on.
            The CreateFile function returns this value.

    lpEvtMask - Points to a mask that will receive the reason that
                the wait was satisfied.

    lpOverLapped - An optional overlapped handle.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;

    if (ARGUMENT_PRESENT(lpOverlapped)) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtDeviceIoControlFile(
                     hFile,
                     lpOverlapped->hEvent,
                     NULL,
                     (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                     (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                     IOCTL_SERIAL_WAIT_ON_MASK,
                     NULL,
                     0,
                     lpEvtMask,
                     sizeof(ULONG)
                     );

        if (!NT_ERROR(Status) && (Status != STATUS_PENDING)) {

            return TRUE;

        } else {

            BaseSetLastNTError(Status);
            return FALSE;

        }

    } else {

        IO_STATUS_BLOCK Iosb;
        HANDLE Event;

        if (!(Event = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

            return FALSE;

        } else {

            Status = NtDeviceIoControlFile(
                         hFile,
                         Event,
                         NULL,
                         NULL,
                         &Iosb,
                         IOCTL_SERIAL_WAIT_ON_MASK,
                         NULL,
                         0,
                         lpEvtMask,
                         sizeof(ULONG)
                         );

            if ( Status == STATUS_PENDING) {

                //
                // Operation must complete before return &
                // IoStatusBlock destroyed

                Status = NtWaitForSingleObject( Event, FALSE, NULL );
                if ( NT_SUCCESS(Status)) {

                    Status = Iosb.Status;

                }

            }

            CloseHandle(Event);

            if (NT_ERROR(Status)) {

                BaseSetLastNTError(Status);
                return FALSE;

            }

            return TRUE;

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\count.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    int i=0;
    SMALL_RECT Window;

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 10;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );


    while ( TRUE ) {
        printf("%d\n",++i);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\constrs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

VOID
NewProcess()
{

    SMALL_RECT Window;

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 15;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );
    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO	StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL Success;
    DWORD st;
    DWORD ProcessCount;
    SMALL_RECT Window;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    GetStartupInfo(&StartupInfo);
    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 15;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );


    while ( TRUE ) {

        Success = CreateProcess(
                        NULL,
                        "constrs +",
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_CONSOLE,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInfo
                        );

        if (Success) {
            ProcessCount++;
            printf("Process %d Created\n",ProcessCount);
            st = WaitForSingleObject(ProcessInfo.hProcess,-1);
            (st == 0);
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\copylz.c ===
/*
** copylz.c - CopyLZFile() and buffer management functions.
**
** Author:  DavidDi
**
** This module is compiled twice - once with LZA_DLL defined for the Windows
** DLL, and once without LZDLL defined for static DOS library.
*/


// Headers
///////////

#include <basedll.h>
#define LZA_DLL
#include "lz_common.h"
#include "lz_buffers.h"
#include "lz_header.h"

#include "lzpriv.h"


/*
** int  APIENTRY LZStart(void);
**
** If the global buffers are not already initialized, allocates buffers in
** preparation for calls to CopyLZFile().  Increments the global buffer lock
** count.  Sets the global buffers' base pointers and lengths.
**
** Arguments:  void
**
** Returns:    int - TRUE if successful.  LZERROR_GLOBALLOC if unsuccessful.
**
** Globals:    none
*/

INT  APIENTRY LZStart(VOID)
{
   return(TRUE);
}


/*
** VOID  APIENTRY LZDone(void);
**
** If any of the global buffers have not already been freed, frees them and
** resets the buffers' base array pointers to NULL.  Decrements the global
** buffer lock count.
**
** Arguments:  void
**
** Returns:    VOID
**
** Globals:    none
*/
VOID  APIENTRY LZDone(VOID)
{
   return;
}

/*
** CopyLZFile()
**
** Alias for LZCopy(). Originally, LZCopy() and
** CopyLZFile() were intended for different purposes, but they were confused
** and misused so much they were made identical.
*/
LONG APIENTRY CopyLZFile(HFILE doshSource, HFILE doshDest)
{
   return(LZCopy(doshSource, doshDest));
}

/*
** LZCopy()
**
** Expand a compressed file, or copy an uncompressed file.
**
** Arguments:  doshSource - source DOS file handle
**             doshDest   - destination DOS file handle
**
** Returns:    LONG - Number of bytes written if copy was successful.
**                    One of the LZERROR_ codes if unsuccessful.
**
** Globals:    none
*/
LONG  APIENTRY LZCopy(HFILE doshSource, HFILE doshDest)
{
   INT f;
   LONG lRetVal;
   PLZINFO pLZI;

   // If it's a compressed file handle, translate to a DOS handle.
   if (doshSource >= LZ_TABLE_BIAS)
   {
      LZFile *lpLZ;       // pointer to LZFile struct
      HANDLE hLZFile;         // handle to LZFile struct

      if ((hLZFile = rghLZFileTable[doshSource - LZ_TABLE_BIAS]) == NULL)
      {
         return(LZERROR_BADINHANDLE);
      }

      if ((lpLZ = (LZFile *)GlobalLock(hLZFile)) == NULL)
      {
         return(LZERROR_GLOBLOCK);
      }

      doshSource = lpLZ->dosh;
      doshDest = ConvertDosFHToWin32(doshDest);

      GlobalUnlock(hLZFile);
   }
   else {
      doshDest   = ConvertDosFHToWin32(doshDest);
      doshSource = ConvertDosFHToWin32(doshSource);
   }

   // Initialize buffers
   pLZI = InitGlobalBuffersEx();

   if (!pLZI) {
      return(LZERROR_GLOBALLOC);
   }

   ResetBuffers();

   // Expand / copy file.
   if ((f = ExpandOrCopyFile(doshSource, doshDest, pLZI)) != TRUE) {
      // Expansion / copy failed.
      lRetVal = (LONG)f;
   } else {
      // Expansion / copy successful - return number of bytes written.
      lRetVal = pLZI->cblOutSize;
   }

   // Free global buffers.
   FreeGlobalBuffers(pLZI);

   return(lRetVal);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrbinit.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrbinit.c

Abstract:

    This module implements functions that are used during Win32 base initialization to
    communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBaseClientConnectToServer(
    PWSTR szSessionDir,
    PHANDLE phMutant,
    PBOOLEAN pServerProcess
    )
{

#if defined(BUILD_WOW6432)
   return NtWow64CsrBaseClientConnectToServer(szSessionDir,
                                              phMutant,
                                              pServerProcess
                                              );
#else

    NTSTATUS Status;
    ULONG SizeMutant;
    SizeMutant = sizeof(HANDLE);

    Status = CsrClientConnectToServer( szSessionDir,
                                       BASESRV_SERVERDLL_INDEX,
                                       phMutant,
                                       &SizeMutant,
                                       pServerProcess
                                     );


    return Status;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrbeep.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrbeep.c

Abstract:

    This module implements functions that are used by the Win32 Beep APIs to communicate
    with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

VOID
CsrBasepSoundSentryNotification(
    ULONG VideoMode
    )
{

#if defined(BUILD_WOW6432)
    
    NtWow64CsrBasepSoundSentryNotification(VideoMode);

#else

    BASE_API_MSG m;
    PBASE_SOUNDSENTRY_NOTIFICATION_MSG e = &m.u.SoundSentryNotification;

    e->VideoMode = VideoMode;

    CsrClientCallServer((PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                             BasepSoundSentryNotification ),
                        sizeof( *e )
                       );
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\compsup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    compsup.c

Abstract:

    This module implements COM+ support routines to detect COM+ images.

Author:

    Samer Arafeh (samera) 23-Oct-2000

Revision History:

--*/

#include "basedll.h"
#include <wow64t.h>


BOOL
SetComPlusPackageInstallStatus(
    ULONG ComPlusPackage
    )

/*++

Routine Description:

    This function updates the COM+ package status on the system.
    

Arguments:

    ComPlusPackage - Com+ package value to update.

Return Value:

    BOOL.

--*/

{
    NTSTATUS NtStatus;

    if (ComPlusPackage & COMPLUS_INSTALL_FLAGS_INVALID)
    {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    NtStatus = NtSetSystemInformation(
                   SystemComPlusPackage,
                   &ComPlusPackage,
                   sizeof (ULONG)
                   );

    if (!NT_SUCCESS (NtStatus))
    {
        BaseSetLastNTError (NtStatus);
        return FALSE;
    }

    return TRUE;
}


ULONG
GetComPlusPackageInstallStatus(
    VOID
    )

/*++

Routine Description:

    This function reads the COM+ package status on the system.    

Arguments:

    None.
    
Return Value:

    ULONG representing the COM+ package value.

--*/

{
    NTSTATUS NtStatus;
    ULONG ComPlusPackage;


    ComPlusPackage = USER_SHARED_DATA->ComPlusPackage;

    if (ComPlusPackage == (ULONG)-1)
    {
        //
        // If this is the first call ever, let's get the information from
        // the kernel.
        //

        NtQuerySystemInformation(
            SystemComPlusPackage,
            &ComPlusPackage,
            sizeof (ULONG),
            NULL
            );
    }

    return ComPlusPackage;
}


#if defined(_WIN64) || defined(BUILD_WOW6432)

NTSTATUS
BasepIsComplusILImage(
    IN HANDLE SectionImageHandle,
    IN PSECTION_IMAGE_INFORMATION SectionImageInformation,
    OUT BOOLEAN *IsComplusILImage
    )

/*++

Routine Description:

    This function is called each time a COM+ image is about to be launched. It checks
    to see if the image is an ILONLY image or not.
    

Arguments:

    ImageSection - Open handle to the image section to examine.

    SectionImageInformation - Address of SECTION_IMAGE_INFORMATION for the image.

    IsComplusILImage - Out boolean. TRUE if SectionImageHandle corresponds to an IL only 
        COM+ image, otherwise FALSE.

Return Value:

    NTSTATUS

--*/

{
    PVOID ViewBase;
    SIZE_T ViewSize;
    ULONG EntrySize;
    PIMAGE_COR20_HEADER Cor20Header;
    PIMAGE_NT_HEADERS NtImageHeader;
    ULONG ComPlusPackage64;
#if defined(BUILD_WOW6432)
    ULONG   NativePageSize = Wow64GetSystemNativePageSize();
#else
    #define NativePageSize  BASE_SYSINFO.PageSize
#endif
    NTSTATUS NtStatus = STATUS_SUCCESS;

    

    
    *IsComplusILImage = FALSE;


    //
    // Let's map in the image and look inside the headers
    //

    ViewSize = 0;
    ViewBase = NULL;
    NtStatus = NtMapViewOfSection (
                   SectionImageHandle,
                   NtCurrentProcess(),
                   &ViewBase,
                   0L,
                   0L,
                   NULL,
                   &ViewSize,
                   ViewShare,
                   0L,
                   PAGE_READONLY
                   );

    if (NT_SUCCESS (NtStatus)) 
    {

        //
        // Examine the image
        //

        try 
        {
            NtImageHeader = RtlImageNtHeader (ViewBase);

            if (NtImageHeader != NULL)
            {
                if (NtImageHeader->OptionalHeader.SectionAlignment < NativePageSize)
                {
                    ViewBase = LDR_VIEW_TO_DATAFILE (ViewBase);
                }

                Cor20Header = RtlImageDirectoryEntryToData (
                                  ViewBase,
                                  TRUE,
                                  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                  &EntrySize
                                  );

                if ((Cor20Header != NULL) && (EntrySize != 0))
                {
                    if ((Cor20Header->Flags & (COMIMAGE_FLAGS_32BITREQUIRED | COMIMAGE_FLAGS_ILONLY)) == 
                            COMIMAGE_FLAGS_ILONLY)
                    {
                        ComPlusPackage64 = GetComPlusPackageInstallStatus ();
                          
                        if ((ComPlusPackage64 & COMPLUS_ENABLE_64BIT) != 0)
                        {
                            *IsComplusILImage = TRUE;
                        }
                    }
                }

                ViewBase = LDR_DATAFILE_TO_VIEW (ViewBase);
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            NtStatus = GetExceptionCode();
        }

        //
        // Unmap the section from memory
        //

        NtUnmapViewOfSection (
            NtCurrentProcess(),
            ViewBase
            );
    }

    return NtStatus;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrpathm.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrpathm.c

Abstract:

    This module implements functions that are used by the Win32 path functions
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

UINT
CsrBasepGetTempFile(
    VOID
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepGetTempFile();
#else   
    
    BASE_API_MSG m;
    PBASE_GETTEMPFILE_MSG a = &m.u.GetTempFile;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepGetTempFile
                                            ),
                         sizeof( *a )
                      );
    
    return (UINT)m.ReturnValue;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrdlini.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrdlini.c

Abstract:

    This module implements functions that are used by the Win32 Initialization
    File APIs to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepRefreshIniFileMapping(
    PUNICODE_STRING BaseFileName
    )
{       
    
#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepRefreshIniFileMapping(BaseFileName); 
#else

    NTSTATUS Status;

    BASE_API_MSG m;
    PBASE_REFRESHINIFILEMAPPING_MSG ap = &m.u.RefreshIniFileMapping;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CaptureBuffer = NULL;

    if (BaseFileName->Length > (MAX_PATH * sizeof( WCHAR ))) {
        return STATUS_INVALID_PARAMETER;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              BaseFileName->MaximumLength
                                            );
    if (CaptureBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    CsrCaptureMessageString( CaptureBuffer,
                             (PCHAR)BaseFileName->Buffer,
                             BaseFileName->Length,
                             BaseFileName->MaximumLength,
                             (PSTRING)&ap->IniFileName
                          );

   CsrClientCallServer( (PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                             BasepRefreshIniFileMapping
                                           ),
                        sizeof( *ap )
                     );

   Status = (NTSTATUS)m.ReturnValue;

   CsrFreeCaptureBuffer( CaptureBuffer );
   return Status;

#endif
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrdosdv.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrdosdv.c

Abstract:

    This module implements functions that are used by the DefineDosDevice API
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepDefineDosDevice(
    DWORD dwFlags,
    PUNICODE_STRING pDeviceName,
    PUNICODE_STRING pTargetPath
    )
{

#if defined(BUILD_WOW6432)
   return NtWow64CsrBasepDefineDosDevice(dwFlags,
                                         pDeviceName,
                                         pTargetPath
                                         );
#else

    BASE_API_MSG m;
    PBASE_DEFINEDOSDEVICE_MSG a = &m.u.DefineDosDeviceApi;
    PCSR_CAPTURE_HEADER p;
    ULONG PointerCount, n;   
 
    if (0 == pTargetPath->MaximumLength) {
       PointerCount = 1;
       n = pDeviceName->MaximumLength;
    } 
    else {
       PointerCount = 2;
       n = pDeviceName->MaximumLength + pTargetPath->MaximumLength;
    }

    p = CsrAllocateCaptureBuffer( PointerCount, n );
    if (p == NULL) {
        return STATUS_NO_MEMORY;
    }

    a->Flags = dwFlags;
    a->DeviceName.MaximumLength =
        (USHORT)CsrAllocateMessagePointer( p,
                                           pDeviceName->MaximumLength,
                                           (PVOID *)&a->DeviceName.Buffer
                                         );
    RtlUpcaseUnicodeString( &a->DeviceName, pDeviceName, FALSE );
    if (pTargetPath->Length != 0) {
        a->TargetPath.MaximumLength =
            (USHORT)CsrAllocateMessagePointer( p,
                                               pTargetPath->MaximumLength,
                                               (PVOID *)&a->TargetPath.Buffer
                                             );
        RtlCopyUnicodeString( &a->TargetPath, pTargetPath );
    }
    else {
        RtlInitUnicodeString( &a->TargetPath, NULL );
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         p,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepDefineDosDevice
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( p );

    return m.ReturnValue;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrpro.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrpro.c

Abstract:

    This module implements functions that are used by the Win32 Process Object APIs
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepCreateProcess(
    PBASE_CREATEPROCESS_MSG a
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepCreateProcess(a);
#else
    NTSTATUS Status;
    BASE_API_MSG m;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

    m.u.CreateProcess = *a;
    if (m.u.CreateProcess.Sxs.Flags != 0)
    {
        const PUNICODE_STRING StringsToCapture[] =
        {
            &m.u.CreateProcess.Sxs.Manifest.Path,
            &m.u.CreateProcess.Sxs.Policy.Path,
            &m.u.CreateProcess.Sxs.AssemblyDirectory
        };

        Status =
            CsrCaptureMessageMultiUnicodeStringsInPlace(
                &CaptureBuffer,
                RTL_NUMBER_OF(StringsToCapture),
                StringsToCapture
                );
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepCreateProcess
                                            ),
                         sizeof( m.u.CreateProcess )
                       );
    
    if ( CaptureBuffer )
        CsrFreeCaptureBuffer( CaptureBuffer );

    Status = (NTSTATUS)m.ReturnValue;

Exit:
    return Status;
#endif

}

VOID
CsrBasepExitProcess(
    UINT uExitCode
    )
{

#if defined(BUILD_WOW6432)
   NtWow64CsrBasepExitProcess(uExitCode);
   return;
#else

    BASE_API_MSG m;
    PBASE_EXITPROCESS_MSG a = &m.u.ExitProcess;

    a->uExitCode = uExitCode;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepExitProcess
                                            ),
                         sizeof( *a )
                       );
#endif
}


NTSTATUS
CsrBasepSetProcessShutdownParam(
    DWORD dwLevel,
    DWORD dwFlags
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepSetProcessShutdownParam(dwLevel,
                                                  dwFlags);
#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    a->ShutdownLevel = dwLevel;
    a->ShutdownFlags = dwFlags;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepSetProcessShutdownParam),
            sizeof(*a));   

    return m.ReturnValue;

#endif
}

NTSTATUS
CsrBasepGetProcessShutdownParam(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    )
{

#if defined(BUILD_WOW6432)
   return NtWow64CsrBasepGetProcessShutdownParam(lpdwLevel,
                                                 lpdwFlags);
#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepSetProcessShutdownParam),
            sizeof(*a));   

    *lpdwLevel = a->ShutdownLevel;
    *lpdwFlags = a->ShutdownFlags;

    return m.ReturnValue;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrsxs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrsxs.c

Abstract:

    This module implements functions that are used by the Side-by-Side
    Win32 APIs.

Author:

    Samer Arafeh (samera)     20-May-2000

Revision History:

    Jay Krell (a-JayK) June, July 2000
        factored/merged with sxs.c, source code duplication eliminated
        moved file opening out of csrss.exe to client process
--*/

#include "basedll.h"
#include <sxstypes.h>
#include <limits.h>

typedef void * POINTER_32 PVOID32;

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_LANG_NOT_FOUND  \
                                    || (x) == STATUS_SXS_CANT_GEN_ACTCTX      \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

VOID
BasepSxsDbgPrintMessageStream(
    PCSTR Function,
    PCSTR StreamName,
    PBASE_MSG_SXS_STREAM MessageStream
    )
{
    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s() %s {\n"
        "SXS:    FileType:%s\n"
        "SXS:    PathType:%s\n"
        "SXS:    Path:%wZ\n"
        "SXS:    FileHandle:%p\n"
        "SXS:    HandleType:%s\n"
        "SXS:    Handle:%p\n"
        "SXS:    Offset:0x%I64x\n"
        "SXS:    Size:0x%Ix\n"
        "SXS: }\n",
        Function,
        StreamName,
        (MessageStream->FileType == BASE_MSG_FILETYPE_NONE ? "None" :
         MessageStream->FileType == BASE_MSG_FILETYPE_XML ? "Xml" :
         MessageStream->FileType == BASE_MSG_FILETYPE_PRECOMPILED_XML ? "PrecompiledXml" : "Unknown"),

        (MessageStream->PathType == BASE_MSG_PATHTYPE_NONE     ? "None" :
         MessageStream->PathType == BASE_MSG_PATHTYPE_FILE     ? "File" :
         MessageStream->PathType == BASE_MSG_PATHTYPE_URL      ? "Url"  :
         MessageStream->PathType == BASE_MSG_PATHTYPE_OVERRIDE ? "Override" : "Unknown"),

        &MessageStream->Path,

        MessageStream->FileHandle,

        (MessageStream->HandleType == BASE_MSG_HANDLETYPE_NONE ? "None" :
         MessageStream->HandleType == BASE_MSG_HANDLETYPE_PROCESS ? "Process" :
         MessageStream->HandleType == BASE_MSG_HANDLETYPE_CLIENT_PROCESS ? "ClientProcess" :
         MessageStream->HandleType == BASE_MSG_HANDLETYPE_SECTION ? "Section" : "Unknown"),

        MessageStream->Handle,
        MessageStream->Offset,
        MessageStream->Size));
}


NTSTATUS
CsrBasepCreateActCtx(
    IN PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message
    )
{
    NTSTATUS Status;
#if defined(BUILD_WOW6432)
    Status = NtWow64CsrBasepCreateActCtx(Message);
#else
    BASE_API_MSG m;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

	//
	// BUILD_WOW64 means we are 64bit code in a 32bit process "between" csrss and a 32bit client.
	// We are in the static thunk library linked into wow64.dll.
	//
	// Neither native x86 nor native ia64 code needs to worry about the pointer sizes here.
	//
#if defined(BUILD_WOW64)
    PVOID    ActivationContextDataLocal64 = NULL;
    PVOID32* ActivationContextDataOut32 = NULL;
#endif

#if DBG
    KdPrintEx((
        DPFLTR_SXS_ID,
        DPFLTR_TRACE_LEVEL,
        "SXS: %s() Message {\n"
        "SXS:   Flags:(%s | %s | %s)\n"
        "SXS:   ProcessorArchitecture:%lx\n"
        "SXS:   LangId:%lx\n"
        "SXS:   AssemblyDirectory:%wZ\n"
        "SXS:   TextualAssemblyIdentity:%wZ\n"
        "SXS: }\n",
        __FUNCTION__,
        (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) ? "MANIFEST_PRESENT" : "0",
        (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) ? "POLICY_PRESENT" : "0",
        (Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) ? "TEXTUAL_ASSEMBLY_IDENTITY_PRESENT" : "0",
        Message->ProcessorArchitecture,
        Message->LangId,
        &Message->AssemblyDirectory,
        &Message->TextualAssemblyIdentity
        ));

    if (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) {
        BasepSxsDbgPrintMessageStream(__FUNCTION__, "Manifest", &Message->Manifest);
    }
    if (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) {
        BasepSxsDbgPrintMessageStream(__FUNCTION__, "Policy", &Message->Policy);
    }
#endif

    m.u.SxsCreateActivationContext = *Message;
    
    {
        const PUNICODE_STRING StringsToCapture[] = 
        {
            &m.u.SxsCreateActivationContext.Manifest.Path,
            ( Message->Flags & BASE_MSG_SXS_POLICY_PRESENT )
                ? &m.u.SxsCreateActivationContext.Policy.Path
                : NULL,
            &m.u.SxsCreateActivationContext.AssemblyDirectory,
            ( Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT )
                ? &m.u.SxsCreateActivationContext.TextualAssemblyIdentity
                : NULL
        };


        Status = CsrCaptureMessageMultiUnicodeStringsInPlace(
            &CaptureBuffer,
            RTL_NUMBER_OF(StringsToCapture),
            StringsToCapture
            );

        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() CsrCaptureMessageMultiUnicodeStringsInPlace failed\n", __FUNCTION__);
            goto Exit;
        }
    }

#if defined(BUILD_WOW64)
    if (m.u.SxsCreateActivationContext.ActivationContextData != NULL) {
        ActivationContextDataOut32 = (PVOID32*)m.u.SxsCreateActivationContext.ActivationContextData;
        m.u.SxsCreateActivationContext.ActivationContextData = (PVOID*)&ActivationContextDataLocal64;
    }
#endif

    Status = CsrClientCallServer((PCSR_API_MSG) &m,
                                   CaptureBuffer,
                                   CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX, 
                                                       BasepSxsCreateActivationContext),
                                   sizeof(*Message));

#if defined(BUILD_WOW64)
    if ((m.u.SxsCreateActivationContext.ActivationContextData != NULL) &&
        (ActivationContextDataOut32 != NULL)) {
        *ActivationContextDataOut32 = (PVOID32) ActivationContextDataLocal64;
    }
#endif

Exit:
    if ( CaptureBuffer != NULL )
        CsrFreeCaptureBuffer(CaptureBuffer);
    

#endif
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrterm.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrterm.c

Abstract:

    This module implements functions that are used by the Terminal server support functions
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/

#include "basedll.h"

NTSTATUS
CsrBasepSetTermsrvAppInstallMode(
    BOOL bState
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepSetTermsrvAppInstallMode(bState);
#else

    BASE_API_MSG m;
    PBASE_SET_TERMSRVAPPINSTALLMODE c = &m.u.SetTermsrvAppInstallMode;

    c->bState = bState;
    return  CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvAppInstallMode),
                                 sizeof( *c ));
#endif

}


NTSTATUS
CsrBasepSetClientTimeZoneInformation(
    IN PBASE_SET_TERMSRVCLIENTTIMEZONE c
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepSetClientTimeZoneInformation(c);
#else

    BASE_API_MSG m;
    
    RtlCopyMemory(&m.u.SetTermsrvClientTimeZone, c, sizeof(*c));
    
    return  CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvClientTimeZone),
                                 sizeof( *c ));
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\csrthrd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    csrthrd.c

Abstract:

    This module implements functions that are used by the Win32 Thread Object APIs
    to communicate with csrss.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

--*/
#include "basedll.h"

NTSTATUS
CsrBasepCreateThread(
    HANDLE ThreadHandle,
    CLIENT_ID ClientId
    )
{

#if defined(BUILD_WOW6432)
    return NtWow64CsrBasepCreateThread(ThreadHandle,
                                       ClientId);
#else

    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = &m.u.CreateThread;

    a->ThreadHandle = ThreadHandle;
    a->ClientId = ClientId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepCreateThread
                                            ),
                         sizeof( *a )
                       );

    return m.ReturnValue;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\datetime.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    datetime.c

Abstract:

    This module implements Win32 time of day functions

Author:

    Mark Lucovsky (markl) 08-Oct-1990

Revision History:

--*/

#include "basedll.h"

#define IsActiveConsoleSession() (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)


ULONG 
CalcClientTimeZoneIdAndBias(
     IN CONST TIME_ZONE_INFORMATION *ptzi,
     OUT KSYSTEM_TIME *pBias);


VOID
WINAPI
GetLocalTime(
    LPSYSTEMTIME lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be returned using
    GetLocalTime.

Arguments:

    lpLocalTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER Bias;
    TIME_FIELDS TimeFields;
    
    volatile KSYSTEM_TIME *pRealBias;
        
    if(!IsActiveConsoleSession() && 
        BaseStaticServerData->TermsrvClientTimeZoneId!=TIME_ZONE_ID_INVALID) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }
    
    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    LocalTime.QuadPart = SystemTime.QuadPart - Bias.QuadPart;

    RtlTimeToTimeFields(&LocalTime,&TimeFields);

    lpLocalTime->wYear         = TimeFields.Year        ;
    lpLocalTime->wMonth        = TimeFields.Month       ;
    lpLocalTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpLocalTime->wDay          = TimeFields.Day         ;
    lpLocalTime->wHour         = TimeFields.Hour        ;
    lpLocalTime->wMinute       = TimeFields.Minute      ;
    lpLocalTime->wSecond       = TimeFields.Second      ;
    lpLocalTime->wMilliseconds = TimeFields.Milliseconds;
}

VOID
WINAPI
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    The current system date and time (UTC based) can be returned using
    GetSystemTime.

Arguments:

    lpSystemTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    RtlTimeToTimeFields(&SystemTime,&TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;
}

VOID
WINAPI
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    )

/*++

Routine Description:

    The current system date and time (UTC based) can be returned using
    GetSystemTimeAsFileTime.

Arguments:

    lpSystemTimeAsFileTime - Returns the current system date and time formatted as
        a FILETIME structure

Return Value:

    None.

--*/

{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    lpSystemTimeAsFileTime->dwLowDateTime = SystemTime.LowPart;
    lpSystemTimeAsFileTime->dwHighDateTime = SystemTime.HighPart;
}

BOOL
WINAPI
SetSystemTime(
    CONST SYSTEMTIME *lpSystemTime
    )

/*++

Routine Description:

    The current UTC based system date and time can be set using
    SetSystemTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;

    ReturnValue = TRUE;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&SystemTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {
        Status = BasepAcquirePrivilegeEx( SE_SYSTEMTIME_PRIVILEGE, &State );
        if ( NT_SUCCESS(Status) ) {
            Status = NtSetSystemTime(&SystemTime,NULL);
            BasepReleasePrivilege( State );
            }
        if ( !NT_SUCCESS(Status) ) {
            ReturnValue = FALSE;
            }
        }

    if ( !ReturnValue ) {
        BaseSetLastNTError(Status);
        }

    return ReturnValue;
}

BOOL
WINAPI
SetLocalTime(
    CONST SYSTEMTIME *lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be set using
    SetLocalTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;
    LARGE_INTEGER Bias;

    volatile KSYSTEM_TIME *pRealBias;
    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    
    if(!IsActiveConsoleSession() && 
        BaseStaticServerData->TermsrvClientTimeZoneId!=TIME_ZONE_ID_INVALID) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    ReturnValue = TRUE;

    TimeFields.Year         = lpLocalTime->wYear        ;
    TimeFields.Month        = lpLocalTime->wMonth       ;
    TimeFields.Day          = lpLocalTime->wDay         ;
    TimeFields.Hour         = lpLocalTime->wHour        ;
    TimeFields.Minute       = lpLocalTime->wMinute      ;
    TimeFields.Second       = lpLocalTime->wSecond      ;
    TimeFields.Milliseconds = lpLocalTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&LocalTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {

        SystemTime.QuadPart = LocalTime.QuadPart + Bias.QuadPart;
        Status = BasepAcquirePrivilegeEx( SE_SYSTEMTIME_PRIVILEGE, &State );
        if ( NT_SUCCESS(Status) ) {
            Status = NtSetSystemTime(&SystemTime,NULL);
            BasepReleasePrivilege( State );
            if ( !NT_SUCCESS(Status) ) {
                ReturnValue = FALSE;
                }
            }
        else {
            ReturnValue = FALSE;
            }
        }

    if ( !ReturnValue ) {
        BaseSetLastNTError(Status);
        }

    return ReturnValue;
}


DWORD
GetTickCount(
    VOID
    )

/*++

Routine Description:

    Win32 systems implement a free-running millisecond counter.  The
    value of this counter can be read using GetTickCount.

Arguments:

    None.

Return Value:

    This function returns the number of milliseconds that have elapsed
    since the system was started. If the system has been running for
    a long time, it is possible that the count will repeat. The value of
    the counter is accurate within 55 milliseconds.

--*/

{
    return (DWORD)NtGetTickCount();
}


BOOL
APIENTRY
FileTimeToSystemTime(
    CONST FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    This functions converts a 64-bit file time value to a time in system
    time format.

Arguments:

    lpFileTime - Supplies the 64-bit file time to convert to the system
        date and time format.

    lpSystemTime - Returns the converted value of the 64-bit file time.

Return Value:

    TRUE - The 64-bit file time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER FileTime;
    TIME_FIELDS TimeFields;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    if ( FileTime.QuadPart < 0 ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    RtlTimeToTimeFields(&FileTime, &TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;

    return TRUE;
}


BOOL
APIENTRY
SystemTimeToFileTime(
    CONST SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a system time value into a 64-bit file time.

Arguments:

    lpSystemTime - Supplies the time that is to be converted into
        the 64-bit file time format.  The wDayOfWeek field is ignored.

    lpFileTime - Returns the 64-bit file time representation of
        lpSystemTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
    else {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
}

BOOL
WINAPI
FileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    )

/*++

Routine Description:

    This functions converts a UTC based file time to a local file time.

Arguments:

    lpFileTime - Supplies the UTC based file time that is to be
        converted into a local file time

    lpLocalFileTime - Returns the 64-bit local file time representation of
        lpFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    volatile KSYSTEM_TIME *pRealBias;
    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    
    if(!IsActiveConsoleSession() && 
        BaseStaticServerData->TermsrvClientTimeZoneId!=TIME_ZONE_ID_INVALID) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    LocalFileTime.QuadPart = FileTime.QuadPart - Bias.QuadPart;

    lpLocalFileTime->dwLowDateTime = LocalFileTime.LowPart;
    lpLocalFileTime->dwHighDateTime = LocalFileTime.HighPart;

    return TRUE;
}

BOOL
WINAPI
LocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a local file time to a UTC based file time.

Arguments:

    lpLocalFileTime - Supplies the local file time that is to be
        converted into a UTC based file time

    lpFileTime - Returns the 64-bit UTC based file time representation of
        lpLocalFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    volatile KSYSTEM_TIME *pRealBias;
    //
    // Read time zone bias from shared region.
    // If it's terminal server session use client bias.
    
    if(!IsActiveConsoleSession() && 
        BaseStaticServerData->TermsrvClientTimeZoneId!=TIME_ZONE_ID_INVALID) {
        pRealBias=&(BaseStaticServerData->ktTermsrvClientBias);
    } else {
        pRealBias=&(USER_SHARED_DATA->TimeZoneBias);
    }

    do {
        Bias.HighPart = pRealBias->High1Time;
        Bias.LowPart = pRealBias->LowPart;
    } while (Bias.HighPart != pRealBias->High2Time);

    LocalFileTime.LowPart = lpLocalFileTime->dwLowDateTime;
    LocalFileTime.HighPart = lpLocalFileTime->dwHighDateTime;

    FileTime.QuadPart = LocalFileTime.QuadPart + Bias.QuadPart;

    lpFileTime->dwLowDateTime = FileTime.LowPart;
    lpFileTime->dwHighDateTime = FileTime.HighPart;

    return TRUE;
}


#define AlmostTwoSeconds (2*1000*1000*10 - 1)

BOOL
APIENTRY
FileTimeToDosDateTime(
    CONST FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    )

/*++

Routine Description:

    This function converts a 64-bit file time into DOS date and time value
    which is represented as two 16-bit unsigned integers.

    Since the DOS date format can only represent dates between 1/1/80 and
    12/31/2107, this conversion can fail if the input file time is outside
    of this range.

Arguments:

    lpFileTime - Supplies the 64-bit file time to convert to DOS date and
        time format.

    lpFatDate - Returns the 16-bit DOS representation of date.

    lpFatTime - Returns the 16-bit DOS representation of time.

Return Value:

    TRUE - The file time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    FileTime.QuadPart = FileTime.QuadPart + (LONGLONG)AlmostTwoSeconds;

    if ( FileTime.QuadPart < 0 ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    RtlTimeToTimeFields(&FileTime, &TimeFields);

    if (TimeFields.Year < 1980 || TimeFields.Year > 2107) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }

    *lpFatDate = (WORD)( ((USHORT)(TimeFields.Year-(CSHORT)1980) << 9) |
                         ((USHORT)TimeFields.Month << 5) |
                         (USHORT)TimeFields.Day
                       );

    *lpFatTime = (WORD)( ((USHORT)TimeFields.Hour << 11) |
                         ((USHORT)TimeFields.Minute << 5) |
                         ((USHORT)TimeFields.Second >> 1)
                       );

    return TRUE;
}


BOOL
APIENTRY
DosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This function converts a DOS date and time value, which is
    represented as two 16-bit unsigned integers, into a 64-bit file
    time.

Arguments:

    lpFatDate - Supplies the 16-bit DOS representation of date.

    lpFatTime - Supplies the 16-bit DOS representation of time.

    lpFileTime - Returns the 64-bit file time converted from the DOS
        date and time format.

Return Value:

    TRUE - The Dos date and time were successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = (CSHORT)((wFatDate & 0xFE00) >> 9)+(CSHORT)1980;
    TimeFields.Month        = (CSHORT)((wFatDate & 0x01E0) >> 5);
    TimeFields.Day          = (CSHORT)((wFatDate & 0x001F) >> 0);
    TimeFields.Hour         = (CSHORT)((wFatTime & 0xF800) >> 11);
    TimeFields.Minute       = (CSHORT)((wFatTime & 0x07E0) >>  5);
    TimeFields.Second       = (CSHORT)((wFatTime & 0x001F) << 1);
    TimeFields.Milliseconds = 0;

    if (RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
}

LONG
APIENTRY
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    )

/*++

Routine Description:

    This function compares two 64-bit file times.

Arguments:

    lpFileTime1 - pointer to a 64-bit file time.

    lpFileTime2 - pointer to a 64-bit file time.

Return Value:

    -1 - *lpFileTime1 <  *lpFileTime2

     0 - *lpFileTime1 == *lpFileTime2

    +1 - *lpFileTime1 >  *lpFileTime2

--*/

{
    ULARGE_INTEGER FileTime1;
    ULARGE_INTEGER FileTime2;

    FileTime1.LowPart = lpFileTime1->dwLowDateTime;
    FileTime1.HighPart = lpFileTime1->dwHighDateTime;
    FileTime2.LowPart = lpFileTime2->dwLowDateTime;
    FileTime2.HighPart = lpFileTime2->dwHighDateTime;
    if (FileTime1.QuadPart < FileTime2.QuadPart) {
        return( -1 );
        }
    else
    if (FileTime1.QuadPart > FileTime2.QuadPart) {
        return( 1 );
        }
    else {
        return( 0 );
        }
}

DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to get the current timezone
    parameters These parameters control the Universal time to Local time
    translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    The return value of this function is the systems best guess of
    the current time zone parameters. This is one of:

        - Unknown

        - Standard Time

        - Daylight Savings Time

    If SetTimeZoneInformation was called without the transition date
    information, Unknown is returned, but the currect bias is used for
    local time translation.  Otherwise, the system will correctly pick
    either daylight savings time or standard time.

    The information returned by this API is identical to the information
    stored in the last successful call to SetTimeZoneInformation.  The
    exception is the Bias field returns the current Bias value in

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TIME_ZONE_ID_UNKNOWN - The system can not determine the current
        timezone.  This is usually due to a previous call to
        SetTimeZoneInformation where only the Bias was supplied and no
        transition dates were supplied.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    0xffffffff - The operation failed.  Extended error status is
        available using GetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    //
    // get the timezone data from the system
    // If it's terminal server session use client time zone

    if(!IsActiveConsoleSession() && 
        BaseStaticServerData->TermsrvClientTimeZoneId!=TIME_ZONE_ID_INVALID) {

        *lpTimeZoneInformation = BaseStaticServerData->tziTermsrvClientTimeZone;
        return BaseStaticServerData->TermsrvClientTimeZoneId;

    } else {

        Status = NtQuerySystemInformation(
                    SystemCurrentTimeZoneInformation,
                    &tzi,
                    sizeof(tzi),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return 0xffffffff;
            }


        lpTimeZoneInformation->Bias         = tzi.Bias;
        lpTimeZoneInformation->StandardBias = tzi.StandardBias;
        lpTimeZoneInformation->DaylightBias = tzi.DaylightBias;

        RtlMoveMemory(&lpTimeZoneInformation->StandardName,&tzi.StandardName,sizeof(tzi.StandardName));
        RtlMoveMemory(&lpTimeZoneInformation->DaylightName,&tzi.DaylightName,sizeof(tzi.DaylightName));

        lpTimeZoneInformation->StandardDate.wYear         = tzi.StandardStart.Year        ;
        lpTimeZoneInformation->StandardDate.wMonth        = tzi.StandardStart.Month       ;
        lpTimeZoneInformation->StandardDate.wDayOfWeek    = tzi.StandardStart.Weekday     ;
        lpTimeZoneInformation->StandardDate.wDay          = tzi.StandardStart.Day         ;
        lpTimeZoneInformation->StandardDate.wHour         = tzi.StandardStart.Hour        ;
        lpTimeZoneInformation->StandardDate.wMinute       = tzi.StandardStart.Minute      ;
        lpTimeZoneInformation->StandardDate.wSecond       = tzi.StandardStart.Second      ;
        lpTimeZoneInformation->StandardDate.wMilliseconds = tzi.StandardStart.Milliseconds;

        lpTimeZoneInformation->DaylightDate.wYear         = tzi.DaylightStart.Year        ;
        lpTimeZoneInformation->DaylightDate.wMonth        = tzi.DaylightStart.Month       ;
        lpTimeZoneInformation->DaylightDate.wDayOfWeek    = tzi.DaylightStart.Weekday     ;
        lpTimeZoneInformation->DaylightDate.wDay          = tzi.DaylightStart.Day         ;
        lpTimeZoneInformation->DaylightDate.wHour         = tzi.DaylightStart.Hour        ;
        lpTimeZoneInformation->DaylightDate.wMinute       = tzi.DaylightStart.Minute      ;
        lpTimeZoneInformation->DaylightDate.wSecond       = tzi.DaylightStart.Second      ;
        lpTimeZoneInformation->DaylightDate.wMilliseconds = tzi.DaylightStart.Milliseconds;

        return USER_SHARED_DATA->TimeZoneId;
    }
}

BOOL
WINAPI
SetTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to set timezone parameters into
    their system.  These parameters control the Universal time to Local
    time translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    This API allows the caller to program the current time zone bias,
    and optionally set up the system to automatically sense daylight
    savings time and standard time transitions.

    The timezone bias information is controlled by the
    TIME_ZONE_INFORMATION structure.

    Bias - Supplies the current bias in minutes for local time
        translation on this machine where LocalTime + Bias = UTC.  This
        is a required filed of this structure.

    StandardName - Supplies an optional abbreviation string associated
        with standard time on this system.  This string is uniterpreted
        and is supplied and used only by callers of this API and of
        GetTimeZoneInformation.

    StandardDate - Supplies an optional date and time (UTC) that
        describes the transition into standard time.  A value of 0 in
        the wMonth field tells the system that StandardDate is not
        specified.  If this field is specified, then DaylightDate must
        also be specified.  Additionally, local time translations done
        during the StandardTime range will be done relative to the
        supplied StandardBias value (added to Bias).

        This field supports two date formats. Absolute form specifies and
        exact date and time when standard time begins. In this form, the
        wYear, wMonth, wDay, wHour, wMinute, wSecond, and wMilliseconds
        of the SYSTEMTIME structure are used to specify an exact date.

        Day-in-month time is specified by setting wYear to 0, setting
        wDayOfWeek to an appropriate weekday, and using wDay in the
        range of 1-5 to select the correct day in the month.  Using this
        notation, the first sunday in april may be specified as can be
        the last thursday in october (5 is equal to "the last").

    StandardBias - Supplies an optional bias value to be used during
        local time translations that occur during Standard Time. This
        field is ignored if StandardDate is not supplied.
         This bias value
        is added to the Bias field to form the Bias used during standard
        time. In most time zones, the value of this field is zero.

    DaylightName - Supplies an optional abbreviation string associated
        with daylight savings time on this system.  This string is
        uniterpreted and is supplied and used only by callers of this
        API and of GetTimeZoneInformation.

    DaylightDate - Supplies an optional date and time (UTC) that
        describes the transition into daylight savings time.  A value of
        0 in the wMonth field tells the system that DaylightDate is not
        specified.  If this field is specified, then StandardDate must
        also be specified.  Additionally, local time translations done
        during the DaylightTime range will be done relative to the
        supplied DaylightBias value (added to Bias). The same dat formats
        supported by StandardDate are supported ib DaylightDate.

    DaylightBias - Supplies an optional bias value to be used during
        local time translations that occur during Daylight Savings Time.
        This field is ignored if DaylightDate is not supplied.  This
        bias value is added to the Bias field to form the Bias used
        during daylight time.  In most time zones, the value of this
        field is -60.

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;
    
    if(!IsActiveConsoleSession()) {

        return SetClientTimeZoneInformation(lpTimeZoneInformation);

    } else {

        tzi.Bias            = lpTimeZoneInformation->Bias;
        tzi.StandardBias    = lpTimeZoneInformation->StandardBias;
        tzi.DaylightBias    = lpTimeZoneInformation->DaylightBias;

        RtlMoveMemory(&tzi.StandardName,&lpTimeZoneInformation->StandardName,sizeof(tzi.StandardName));
        RtlMoveMemory(&tzi.DaylightName,&lpTimeZoneInformation->DaylightName,sizeof(tzi.DaylightName));

        tzi.StandardStart.Year         = lpTimeZoneInformation->StandardDate.wYear        ;
        tzi.StandardStart.Month        = lpTimeZoneInformation->StandardDate.wMonth       ;
        tzi.StandardStart.Weekday      = lpTimeZoneInformation->StandardDate.wDayOfWeek   ;
        tzi.StandardStart.Day          = lpTimeZoneInformation->StandardDate.wDay         ;
        tzi.StandardStart.Hour         = lpTimeZoneInformation->StandardDate.wHour        ;
        tzi.StandardStart.Minute       = lpTimeZoneInformation->StandardDate.wMinute      ;
        tzi.StandardStart.Second       = lpTimeZoneInformation->StandardDate.wSecond      ;
        tzi.StandardStart.Milliseconds = lpTimeZoneInformation->StandardDate.wMilliseconds;

        tzi.DaylightStart.Year         = lpTimeZoneInformation->DaylightDate.wYear        ;
        tzi.DaylightStart.Month        = lpTimeZoneInformation->DaylightDate.wMonth       ;
        tzi.DaylightStart.Weekday      = lpTimeZoneInformation->DaylightDate.wDayOfWeek   ;
        tzi.DaylightStart.Day          = lpTimeZoneInformation->DaylightDate.wDay         ;
        tzi.DaylightStart.Hour         = lpTimeZoneInformation->DaylightDate.wHour        ;
        tzi.DaylightStart.Minute       = lpTimeZoneInformation->DaylightDate.wMinute      ;
        tzi.DaylightStart.Second       = lpTimeZoneInformation->DaylightDate.wSecond      ;
        tzi.DaylightStart.Milliseconds = lpTimeZoneInformation->DaylightDate.wMilliseconds;

        Status = RtlSetTimeZoneInformation( &tzi );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        //
        // Refresh the system's concept of time
        //

        NtSetSystemTime(NULL,NULL);
    

        return TRUE;
    }
}

BOOL
WINAPI
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL  lpTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to support algorithms that want to synchronize
    the time of day (reported via GetSystemTime and GetLocalTime) with
    another time source using a programmed clock adjustment over a
    period of time.

    To facilitate this, the system computes the time of day by adding a
    value to a time of day counter at a periodic interval.  This API
    allows the caller to obtain the periodic interval (clock interrupt
    rate), and the amount added to the time of day with each interrupt.

    A boolean value is also returned which indicates whether or not this
    time adjustment algorithm is even being used.  A value of TRUE
    indicates that adjustment is not being used.  If this is the case,
    the system may attempt to keep the time of day clock in sync using
    its own internal mechanisms.  This may cause time of day to
    periodicly "jump" to the "correct time".


Arguments:

    lpTimeAdjustment - Returns the number of 100ns units added to the
        time of day counter at each clock interrupt.

    lpTimeIncrement - Returns the clock interrupt rate in 100ns units.

    lpTimeAdjustmentDisabled - Returns an indicator which specifies
        whether or not time adjustment is inabled.  A value of TRUE
        indicates that periodic adjustment is disabled
        (*lpTimeAdjustment == *lpTimeIncrement), AND that the system is
        free to serialize time of day using any mechanism it wants.
        This may cause periodic time jumps as the system serializes time
        of day to the "correct time".  A value of false indicates that
        programmed time adjustment is being used to serialize the time
        of day, and that the system will not interfere with this scheme
        and will not attempt to synchronize time of day on its own.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/
{
    NTSTATUS Status;
    SYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;
    Status = NtQuerySystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        b = FALSE;
        }
    else {
        *lpTimeAdjustment = TimeAdjust.TimeAdjustment;
        *lpTimeIncrement = TimeAdjust.TimeIncrement;
        *lpTimeAdjustmentDisabled = TimeAdjust.Enable;
        b = TRUE;
        }

    return b;
}

BOOL
WINAPI
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL  bTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to tell the system the parameters it should
    use to periodicaly synchronize time of day with some other source.

    This API supports two modes of operation.

    In the first mode, bTimeAdjustmentDisabled is set to FALSE.  At each
    clock interrupt, the value of dwTimeAdjustment is added to the time
    of day.  The clock interrupt rate may be obtained using
    GetSystemTimeAdjustment, and looking at the returned value of
    lpTimeIncrement.

    In the second mode, bTimeAdjustmentDisabled is set to TRUE.  At each
    clock interrupt, the clock interrupt rate is added to the time of
    day.  The system may also periodically refresh the time of day using
    other internal algorithms.  These may produce "jumps" in time.

    The application must have system-time privilege (the
    SE_SYSTEMTIME_NAME privilege) for this function to succeed.  This
    privilege is disabled by default.  Use the AdjustTokenPrivileges
    function to enable the privilege and again to disable it after the
    time adjustment has been set.

Arguments:

    dwTimeAdjustment - Supplies the value (in 100ns units) that is to be
        added to the time of day at each clock interrupt.

    bTimeAdjustmentDisabled - Supplies a flag which specifies the time
        adjustment mode that the system is to use.  A value of TRUE
        indicates the the system should synchronize time of day using
        its own internal mechanisms.  When this is the case, the value
        of dwTimeAdjustment is ignored.  A value of FALSE indicates that
        the application is in control, and that the value specified by
        dwTimeAdjustment is to be added to the time of day at each clock
        interrupt.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/

{
    NTSTATUS Status;
    SYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;

    b = TRUE;
    TimeAdjust.TimeAdjustment = dwTimeAdjustment;
    TimeAdjust.Enable = (BOOLEAN)bTimeAdjustmentDisabled;
    Status = NtSetSystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        b = FALSE;
        }

    return b;
}

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    LARGE_INTEGER CurrentUniversalTime;
    LARGE_INTEGER ComputedLocalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
            }
        Tzi = &TziData;
        }
    else {
        Tzi = lpTimeZoneInformation;
        }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input universal time to NT style time
    //
    if ( !SystemTimeToFileTime(lpUniversalTime,(LPFILETIME)&CurrentUniversalTime) ) {
        return FALSE;
        }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(tzi.StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(tzi.DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart ) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            }

        //
        // At this point, we know our current timezone and the
        // Universal time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

        }
    else {
        TimeZoneBias = NewTimeZoneBias;
        }

    ComputedLocalTime.QuadPart = CurrentUniversalTime.QuadPart - TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedLocalTime,lpLocalTime) ) {
        return FALSE;
        }

    return TRUE;
}

BOOL
WINAPI
TzSpecificLocalTimeToSystemTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpLocalTime,
    LPSYSTEMTIME lpUniversalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER CurrentLocalTime;
    LARGE_INTEGER ComputedUniversalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
            }
        Tzi = &TziData;
    }
    else {
        Tzi = lpTimeZoneInformation;
    }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input local time to NT style time
    //
    if ( !SystemTimeToFileTime(lpLocalTime,(LPFILETIME)&CurrentLocalTime) ) {
        return FALSE;
    }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentLocalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
        }

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentLocalTime,
                TRUE
                ) ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
        }


        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( DaylightTime.QuadPart < StandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentLocalTime.QuadPart >= DaylightTime.QuadPart) &&
                 (CurrentLocalTime.QuadPart <  StandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
            }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }
        }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentLocalTime.QuadPart >= StandardTime.QuadPart ) &&
                 (CurrentLocalTime.QuadPart <  DaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
            }
        }

        //
        // At this point, we know our current timezone and the
        // local time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

    }
    else {
        TimeZoneBias = NewTimeZoneBias;
    }

    ComputedUniversalTime.QuadPart = CurrentLocalTime.QuadPart + TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedUniversalTime,lpUniversalTime) ) {
        return FALSE;
    } 

    return TRUE;
}

BOOL 
WINAPI 
SetClientTimeZoneInformation(
     IN CONST TIME_ZONE_INFORMATION *ptzi
     )
/*++

Routine Description:

    Sets information in global structures used 
    to calculate local time in TS session.    

Arguments:

    IN CONST TIME_ZONE_INFORMATION *ptzi 

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.
        Client time zone information may become invalid during this call
        In this case we will use time zone information from server

--*/

{
    NTSTATUS Status;
    
    BASE_API_MSG m;
    PBASE_SET_TERMSRVCLIENTTIMEZONE c = &m.u.SetTermsrvClientTimeZone;
    
    c->fFirstChunk=TRUE; //this meanes that this is only first portion of data
                         //we have to cut it ito two pieces because of
                         //message size restrictions (100 bytes)   
    c->Bias=ptzi->Bias;
    RtlMoveMemory(&c->Name,&ptzi->StandardName,sizeof(ptzi->StandardName));
    c->Date=ptzi->StandardDate;
    c->Bias1=ptzi->StandardBias;
    
#if defined(BUILD_WOW6432)
    Status = CsrBasepSetClientTimeZoneInformation(c);
#else
    Status = CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvClientTimeZone),
                                 sizeof( *c ));
#endif

    if ( !NT_SUCCESS( Status ) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return( FALSE );
    }
    
    c->fFirstChunk=FALSE; //this is a second and last portion of data
    RtlMoveMemory(&c->Name,&ptzi->DaylightName,sizeof(ptzi->DaylightName));
    c->Date=ptzi->DaylightDate;
    c->Bias1=ptzi->DaylightBias;
    c->TimeZoneId=CalcClientTimeZoneIdAndBias(ptzi,&c->RealBias);

#if defined(BUILD_WOW6432)
    Status = CsrBasepSetClientTimeZoneInformation(c);
#else
    Status = CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                                     BasepSetTermsrvClientTimeZone),
                                 sizeof( *c ));
#endif


    if ( !NT_SUCCESS( Status ) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return( FALSE );
    }

    return( TRUE );
}


ULONG 
CalcClientTimeZoneIdAndBias(
     IN CONST TIME_ZONE_INFORMATION *ptzi,
     OUT KSYSTEM_TIME *pBias)
/*++

Routine Description:

    Calculates current bias and time zone ID.    

Arguments:

    IN CONST TIME_ZONE_INFORMATION *ptzi - time zone for which to calculate bias
    OUT KSYSTEM_TIME *pBias - current bias

Return Value:

    TIME_ZONE_ID_UNKNOWN - daylight saving time is not used in the 
        current time zone.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    TIME_ZONE_ID_INVALID - The operation failed.  Extended error status is
        available using GetLastError.

--*/
{
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    SYSTEMTIME CurrentSystemTime;
    LARGE_INTEGER CurrentUniversalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;
    TIME_FIELDS StandardStart,DaylightStart;

    NewTimeZoneBias.QuadPart = Int32x32To64(ptzi->Bias*60, 10000000);

    
    
    //
    // Now see if we have stored cutover times
    //
    if ( ptzi->StandardDate.wMonth && ptzi->DaylightDate.wMonth ) {
        
        GetSystemTime(&CurrentSystemTime);
        SystemTimeToFileTime(&CurrentSystemTime,(LPFILETIME)&CurrentUniversalTime);

        StandardStart.Year         = ptzi->StandardDate.wYear        ;
        StandardStart.Month        = ptzi->StandardDate.wMonth       ;
        StandardStart.Weekday      = ptzi->StandardDate.wDayOfWeek   ;
        StandardStart.Day          = ptzi->StandardDate.wDay         ;
        StandardStart.Hour         = ptzi->StandardDate.wHour        ;
        StandardStart.Minute       = ptzi->StandardDate.wMinute      ;
        StandardStart.Second       = ptzi->StandardDate.wSecond      ;
        StandardStart.Milliseconds = ptzi->StandardDate.wMilliseconds;

        DaylightStart.Year         = ptzi->DaylightDate.wYear        ;
        DaylightStart.Month        = ptzi->DaylightDate.wMonth       ;
        DaylightStart.Weekday      = ptzi->DaylightDate.wDayOfWeek   ;
        DaylightStart.Day          = ptzi->DaylightDate.wDay         ;
        DaylightStart.Hour         = ptzi->DaylightDate.wHour        ;
        DaylightStart.Minute       = ptzi->DaylightDate.wMinute      ;
        DaylightStart.Second       = ptzi->DaylightDate.wSecond      ;
        DaylightStart.Milliseconds = ptzi->DaylightDate.wMilliseconds;

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if((!RtlCutoverTimeToSystemTime(&StandardStart,&StandardTime,
                &CurrentUniversalTime,TRUE)) || 
                (!RtlCutoverTimeToSystemTime(&DaylightStart,&DaylightTime,
                &CurrentUniversalTime,TRUE))) {

            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return TIME_ZONE_ID_INVALID;

        }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;

            } else {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }

        } else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart ) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;

            } else {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;

            }
        }

        //
        // At this point, we know our current timezone and the
        // Universal time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                ptzi->DaylightBias*60 :
                                ptzi->StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

    } else {

        TimeZoneBias = NewTimeZoneBias;
        CurrentTimeZoneId=TIME_ZONE_ID_UNKNOWN;
    }

 
    pBias->LowPart=(ULONG)(TimeZoneBias.LowPart);
    pBias->High1Time=pBias->High2Time=(LONG)(TimeZoneBias.HighPart);

    return CurrentTimeZoneId;
}

/*
//These 2 functions will be needed for new timedate.cpl
DWORD
WINAPI
GetServerTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;
    
    
    //
    // get the timezone data from the system
    //

    Status = NtQuerySystemInformation(
                SystemCurrentTimeZoneInformation,
                &tzi,
                sizeof(tzi),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0xffffffff;
        }

    lpTimeZoneInformation->Bias         = tzi.Bias;
    lpTimeZoneInformation->StandardBias = tzi.StandardBias;
    lpTimeZoneInformation->DaylightBias = tzi.DaylightBias;
    RtlMoveMemory(&lpTimeZoneInformation->StandardName,&tzi.StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&lpTimeZoneInformation->DaylightName,&tzi.DaylightName,sizeof(tzi.DaylightName));

    lpTimeZoneInformation->StandardDate.wYear         = tzi.StandardStart.Year        ;
    lpTimeZoneInformation->StandardDate.wMonth        = tzi.StandardStart.Month       ;
    lpTimeZoneInformation->StandardDate.wDayOfWeek    = tzi.StandardStart.Weekday     ;
    lpTimeZoneInformation->StandardDate.wDay          = tzi.StandardStart.Day         ;
    lpTimeZoneInformation->StandardDate.wHour         = tzi.StandardStart.Hour        ;
    lpTimeZoneInformation->StandardDate.wMinute       = tzi.StandardStart.Minute      ;
    lpTimeZoneInformation->StandardDate.wSecond       = tzi.StandardStart.Second      ;
    lpTimeZoneInformation->StandardDate.wMilliseconds = tzi.StandardStart.Milliseconds;

    lpTimeZoneInformation->DaylightDate.wYear         = tzi.DaylightStart.Year        ;
    lpTimeZoneInformation->DaylightDate.wMonth        = tzi.DaylightStart.Month       ;
    lpTimeZoneInformation->DaylightDate.wDayOfWeek    = tzi.DaylightStart.Weekday     ;
    lpTimeZoneInformation->DaylightDate.wDay          = tzi.DaylightStart.Day         ;
    lpTimeZoneInformation->DaylightDate.wHour         = tzi.DaylightStart.Hour        ;
    lpTimeZoneInformation->DaylightDate.wMinute       = tzi.DaylightStart.Minute      ;
    lpTimeZoneInformation->DaylightDate.wSecond       = tzi.DaylightStart.Second      ;
    lpTimeZoneInformation->DaylightDate.wMilliseconds = tzi.DaylightStart.Milliseconds;

    return USER_SHARED_DATA->TimeZoneId;
 
}

BOOL
WINAPI
SetServerTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    )
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    tzi.Bias            = lpTimeZoneInformation->Bias;
    tzi.StandardBias    = lpTimeZoneInformation->StandardBias;
    tzi.DaylightBias    = lpTimeZoneInformation->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&lpTimeZoneInformation->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&lpTimeZoneInformation->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = lpTimeZoneInformation->StandardDate.wYear        ;
    tzi.StandardStart.Month        = lpTimeZoneInformation->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = lpTimeZoneInformation->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = lpTimeZoneInformation->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = lpTimeZoneInformation->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = lpTimeZoneInformation->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = lpTimeZoneInformation->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = lpTimeZoneInformation->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = lpTimeZoneInformation->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = lpTimeZoneInformation->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = lpTimeZoneInformation->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = lpTimeZoneInformation->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = lpTimeZoneInformation->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = lpTimeZoneInformation->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = lpTimeZoneInformation->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = lpTimeZoneInformation->DaylightDate.wMilliseconds;

    Status = RtlSetTimeZoneInformation( &tzi );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    //
    // Refresh the system's concept of time
    //

    NtSetSystemTime(NULL,NULL);

    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\curdir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    curdir.c

Abstract:

    Current directory support

Author:

    Mark Lucovsky (markl) 10-Oct-1990

Revision History:

--*/

#include "basedll.h"

BOOL
CheckForSameCurdir(
    PUNICODE_STRING PathName
    )
{
    PCURDIR CurDir;
    UNICODE_STRING CurrentDir;
    BOOL rv;


    CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);

    if (CurDir->DosPath.Length > 6 ) {
        if ( (CurDir->DosPath.Length-2) != PathName->Length ) {
            return FALSE;
            }
        }
    else {
        if ( CurDir->DosPath.Length != PathName->Length ) {
            return FALSE;
            }
        }

    RtlAcquirePebLock();

    CurrentDir = CurDir->DosPath;
    if ( CurrentDir.Length > 6 ) {
        CurrentDir.Length -= 2;
        }
    rv = FALSE;

    if ( RtlEqualUnicodeString(&CurrentDir,PathName,TRUE) ) {
        rv = TRUE;
        }
    RtlReleasePebLock();

    return rv;
}


DWORD
APIENTRY
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    ANSI thunk to GetFullPathNameW

--*/

{

    NTSTATUS Status;
    ULONG UnicodeLength;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeResult;
    ANSI_STRING AnsiResult;
    PWSTR Ubuff;
    PWSTR FilePart;
    PWSTR *FilePartPtr;
    INT PrefixLength = 0;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
    } else {
        FilePartPtr = NULL;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &UnicodeString, lpFileName )) {
        return 0;
    }

    Ubuff = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (MAX_PATH<<1) + sizeof(UNICODE_NULL));
    if ( !Ubuff ) {
        RtlFreeUnicodeString(&UnicodeString);
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
    }

    UnicodeLength = RtlGetFullPathName_U(
                        UnicodeString.Buffer,
                        (MAX_PATH<<1),
                        Ubuff,
                        FilePartPtr
                        );

    //
    // UnicodeLength contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to get
    // the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS environment,
    // it's definitely WRONG.
    //
    if ( UnicodeLength <= MAX_PATH * sizeof (WCHAR) ) {

        Status = RtlUnicodeToMultiByteSize(&UnicodeLength, Ubuff, UnicodeLength);
        //
        // At this point, UnicodeLength variable contains
        // Ansi based byte length.
        //
        if ( NT_SUCCESS(Status) ) {
            if ( UnicodeLength && ARGUMENT_PRESENT(lpFilePart) && FilePart != NULL ) {
                INT UnicodePrefixLength;

                UnicodePrefixLength = (INT)(FilePart - Ubuff) * sizeof(WCHAR);
                Status = RtlUnicodeToMultiByteSize( &PrefixLength,
                                                    Ubuff,
                                                    UnicodePrefixLength );
                //
                // At this point, PrefixLength variable contains
                // Ansi based byte length.
                //
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    UnicodeLength = 0;
                }
            }
        } else {
            BaseSetLastNTError(Status);
            UnicodeLength = 0;
        }
    } else {
        //
        // we exceed the MAX_PATH limit. we should log the error and
        // return zero. however US code returns the byte count of
        // buffer required and doesn't log any error.
        //
        UnicodeLength = 0;
    }
    if ( UnicodeLength && UnicodeLength < nBufferLength ) {
        RtlInitUnicodeString(&UnicodeResult,Ubuff);
        Status = BasepUnicodeStringTo8BitString(&AnsiResult,&UnicodeResult,TRUE);
        if ( NT_SUCCESS(Status) ) {
            RtlMoveMemory(lpBuffer,AnsiResult.Buffer,UnicodeLength+1);
            RtlFreeAnsiString(&AnsiResult);

            if ( ARGUMENT_PRESENT(lpFilePart) ) {
                if ( FilePart == NULL ) {
                    *lpFilePart = NULL;
                } else {
                    *lpFilePart = lpBuffer + PrefixLength;
                }
            }
        } else {
            BaseSetLastNTError(Status);
            UnicodeLength = 0;
        }
    } else {
        if ( UnicodeLength ) {
            UnicodeLength++;
        }
    }
    RtlFreeUnicodeString(&UnicodeString);
    RtlFreeHeap(RtlProcessHeap(), 0,Ubuff);

    return (DWORD)UnicodeLength;
}

DWORD
APIENTRY
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to return the fully qualified path name
    corresponding to the specified file name.

    This function is used to return a fully qualified pathname
    corresponding to the specified filename.  It does this by merging
    the current drive and directory together with the specified file
    name.  In addition to this, it calculates the address of the file
    name portion of the fully qualified pathname.

Arguments:

    lpFileName - Supplies the file name of the file whose fully
        qualified pathname is to be returned.

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        specified file.

    lpFilePart - Returns the address of the last component of the fully
        qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    return (DWORD) RtlGetFullPathName_U(
                        lpFileName,
                        nBufferLength*2,
                        lpBuffer,
                        lpFilePart
                        )/2;
}


DWORD
APIENTRY
GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )

/*++

Routine Description:

   ANSI thunk to GetCurrentDirectoryW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    DWORD ReturnValue;
    ULONG cbAnsiString;

    if ( nBufferLength > MAXUSHORT ) {
        nBufferLength = MAXUSHORT-2;
        }

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    Unicode->Length = (USHORT)RtlGetCurrentDirectory_U(
                                    Unicode->MaximumLength,
                                    Unicode->Buffer
                                    );

    //
    // Unicode->Length contains the byte count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.
    //
    Status = RtlUnicodeToMultiByteSize( &cbAnsiString, Unicode->Buffer, Unicode->Length );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = 0;
        }
    else {
        if ( nBufferLength > (DWORD)(cbAnsiString ) ) {
            AnsiString.Buffer = lpBuffer;
            AnsiString.MaximumLength = (USHORT)(nBufferLength+1);
            Status = BasepUnicodeStringTo8BitString(&AnsiString,Unicode,FALSE);

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = 0;
                }
            else {
                ReturnValue = AnsiString.Length;
                }
            }
        else {
            // The return value is the size of the buffer required to hold the
            // pathname (including the terminating null character).

                ReturnValue = cbAnsiString + 1;
            }
        }
    return ReturnValue;
}

DWORD
APIENTRY
GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )

/*++

Routine Description:

    The current directory for a process can be retreived using
    GetCurrentDirectory.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is to
        receive the current directory string.

    lpBuffer - Returns the current directory string for the current
        process.  The string is a null terminated string and specifies
        the absolute path to the current directory.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    return (DWORD)RtlGetCurrentDirectory_U(nBufferLength*2,lpBuffer)/2;
}


BOOL
APIENTRY
SetCurrentDirectoryA(
    LPCSTR lpPathName
    )

/*++

Routine Description:

    ANSI thunk to SetCurrentDirectoryW

--*/

{

    NTSTATUS Status;
    PUNICODE_STRING Unicode;
    BOOL rv;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return FALSE;
    }

    if ( !CheckForSameCurdir(Unicode) ) {

        Status = RtlSetCurrentDirectory_U(Unicode);

        if ( !NT_SUCCESS(Status) ) {

            //
            // claris works 5.0 has a bug where it doesn't strip leading/trailing
            // quotes properly. It ends up calling SetCurrentDirectoryA with a
            // leading quote, and WinExec with a trailing quote. This error path
            // logic will compensate for the leading quote problem
            //
            if ( Unicode->Buffer[0] == L'"' && Unicode->Length > 2 ) {

                Unicode = Basep8BitStringToStaticUnicodeString( lpPathName+1 );
                if (Unicode == NULL) {
                    return FALSE;
                    }
                Status = RtlSetCurrentDirectory_U(Unicode);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    rv = FALSE;
                    }
                else {
                    rv = TRUE;
                    }
                }
            else {
                BaseSetLastNTError(Status);
                rv = FALSE;
                }
        } else {
            rv = TRUE;
        }
    } else {
        rv = TRUE;
    }

    return rv;

}

BOOL
APIENTRY
SetCurrentDirectoryW(
    LPCWSTR lpPathName
    )

/*++

Routine Description:

    The current directory for a process is changed using
    SetCurrentDirectory.

    Each process has a single current directory.  A current directory is
    made up of type parts.

        - A disk designator either which is either a drive letter followed
          by a colon, or a UNC servername/sharename "\\servername\sharename".

        - A directory on the disk designator.

    For APIs that manipulate files, the file names may be relative to
    the current directory.  A filename is relative to the entire current
    directory if it does not begin with a disk designator or a path name
    separator.  If the file name begins with a path name separator, then
    it is relative to the disk designator of the current directory.  If
    a file name begins with a disk designator, than it is a fully
    qualified absolute path name.


    The value of lpPathName supplies the current directory.  The value
    of lpPathName, may be a relative path name as described above, or a
    fully qualified absolute path name.  In either case, the fully
    qualified absolute path name of the specified directory is
    calculated and is stored as the current directory.

Arguments:

    lpPathName - Supplies the pathname of the directory that is to be
        made the current directory.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    BOOL rv;

    RtlInitUnicodeString(&UnicodeString,lpPathName);

    if ( !CheckForSameCurdir(&UnicodeString) ) {

        Status = RtlSetCurrentDirectory_U(&UnicodeString);

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }
        }
    else {
        rv = TRUE;
        }
    return rv;
}



DWORD
APIENTRY
GetLogicalDrives(
    VOID
    )
{
    NTSTATUS Status;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfo.Query,
                                        sizeof( ProcessDeviceMapInfo.Query ),
                                        NULL
                                      );
    if (NT_SUCCESS (Status)) {
        if (ProcessDeviceMapInfo.Query.DriveMap == 0) {
            SetLastError(NO_ERROR);
        }
        return ProcessDeviceMapInfo.Query.DriveMap;
    } else {
        BaseSetLastNTError(Status);
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\debug.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements Win32 Debug APIs

Author:

    Mark Lucovsky (markl) 06-Feb-1991

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#define TmpHandleHead ((PTMPHANDLES *) (&NtCurrentTeb()->DbgSsReserved[0]))
//
// This structure is used to preserve the strange mechanisms used by win2k and nt4 to close the handles to open processes,
// threads and main image file.
//
typedef struct _TMPHANDLES {
    struct _TMPHANDLES *Next;
    HANDLE Thread;
    HANDLE Process;
    DWORD dwProcessId;
    DWORD dwThreadId;
    BOOLEAN DeletePending;
} TMPHANDLES, *PTMPHANDLES;

VOID
SaveThreadHandle (
    DWORD dwProcessId,
    DWORD dwThreadId,
    HANDLE HandleToThread)
/*++

Routine Description:

    This function saves away a handle to a thread in a thread specific list so we can close it later when the thread
    termination message is continued.

Arguments:

    dwProcessId    - Process ID of threads process
    dwThreadId     - Thread ID of thread handle
    HandleToThread - Handle to be closed later

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp;

    Tmp = RtlAllocateHeap (RtlProcessHeap(), 0, sizeof (TMPHANDLES));
    if (Tmp != NULL) {
        Tmp->Thread = HandleToThread;
        Tmp->Process = NULL;
        Tmp->dwProcessId = dwProcessId;
        Tmp->dwThreadId = dwThreadId;
        Tmp->DeletePending = FALSE;
        Tmp->Next = *TmpHandleHead;
        *TmpHandleHead = Tmp;
    }
}

VOID
SaveProcessHandle (
    DWORD dwProcessId,
    HANDLE HandleToProcess
    )
/*++

Routine Description:

    This function saves away a handle to a process and file in a thread specific list so we can close it later
    when the process termination message is continued.

Arguments:

    dwProcessId     - Process ID of threads process
    HandleToProcess - Handle to be closed later
    HandleToFile    - Handle to be closed later

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp;

    Tmp = RtlAllocateHeap (RtlProcessHeap(), 0, sizeof (TMPHANDLES));
    if (Tmp != NULL) {
        Tmp->Process = HandleToProcess;
        Tmp->Thread = NULL;
        Tmp->dwProcessId = dwProcessId;
        Tmp->dwThreadId = 0;
        Tmp->DeletePending = FALSE;
        Tmp->Next = *TmpHandleHead;
        *TmpHandleHead = Tmp;
    }
}

VOID
MarkThreadHandle (
    DWORD dwThreadId
    )
/*++

Routine Description:

    This function marks a saved thread handle so that the next time this thread is continued we close
    its handle

Arguments:

    dwThreadId     - Thread ID of thread handle

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp;

    Tmp = *TmpHandleHead;

    while (Tmp != NULL) {
        if (Tmp->dwThreadId == dwThreadId) {
            Tmp->DeletePending = TRUE;
            break;
        }
        Tmp = Tmp->Next;
    }
}

VOID
MarkProcessHandle (
    DWORD dwProcessId
    )
{
    PTMPHANDLES Tmp;

    Tmp = *TmpHandleHead;

    while (Tmp != NULL) {
        if (Tmp->dwProcessId == dwProcessId && Tmp->dwThreadId == 0) {
            Tmp->DeletePending = TRUE;
            break;
        }
        Tmp = Tmp->Next;
    }
}

VOID 
RemoveHandles (
    DWORD dwThreadId,
    DWORD dwProcessId
    )
/*++

Routine Description:

    This function closes marked handles for this process and thread id

Arguments:

    dwProcessId    - Process ID of threads process
    dwThreadId     - Thread ID of thread handle

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp, *Last;

    Last = TmpHandleHead;

    Tmp = *Last;
    while (Tmp != NULL) {
        if (Tmp->DeletePending) {
            if (Tmp->dwProcessId == dwProcessId || Tmp->dwThreadId == dwThreadId) {
                if (Tmp->Thread != NULL) {
                    CloseHandle (Tmp->Thread);
                }
                if (Tmp->Process != NULL) {
                    CloseHandle (Tmp->Process);
                }
                *Last = Tmp->Next;
                RtlFreeHeap (RtlProcessHeap(), 0, Tmp);
                Tmp = *Last;
                continue;
            }
        }
        Last = &Tmp->Next;
        Tmp = Tmp->Next;
    }
}

VOID
CloseAllProcessHandles (
    DWORD dwProcessId
    )
/*++

Routine Description:

    This function closes all saved handles when we stop debugging a single process

Arguments:

    dwProcessId    - Process ID of threads process

Return Value:

    None.

--*/
{
    PTMPHANDLES Tmp, *Last;

    Last = TmpHandleHead;

    Tmp = *Last;
    while (Tmp != NULL) {
        if (Tmp->dwProcessId == dwProcessId) {
            if (Tmp->Thread != NULL) {
                CloseHandle (Tmp->Thread);
            }
            if (Tmp->Process != NULL) {
                CloseHandle (Tmp->Process);
            }
            *Last = Tmp->Next;
            RtlFreeHeap (RtlProcessHeap(), 0, Tmp);
            Tmp = *Last;
            continue;
        }
        Last = &Tmp->Next;
        Tmp = Tmp->Next;
    }

}


BOOL
APIENTRY
IsDebuggerPresent(
    VOID
    )

/*++

Routine Description:

    This function returns TRUE if the current process is being debugged
    and FALSE if not.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return NtCurrentPeb()->BeingDebugged;
}

BOOL
APIENTRY
CheckRemoteDebuggerPresent(
    IN HANDLE hProcess,
    OUT PBOOL pbDebuggerPresent
    )

/*++

Routine Description:

    This function determines whether the remote process is being debugged.

Arguments:

    hProcess - handle to the process
    pbDebuggerPresent - supplies a buffer to receive the result of the check
        TRUE  - remote process is being debugged
        FALSE - remote process is not being debugged

Return Value:

    TRUE  - The function succeeded.
    FALSE - The function fail.  Extended error status is available using
            GetLastError.

--*/

{
    HANDLE hDebugPort;
    NTSTATUS Status;

    if( (hProcess == NULL) || (pbDebuggerPresent == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessDebugPort,
                (PVOID)(&hDebugPort),
                sizeof(hDebugPort),
                NULL
                );

    if( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    *pbDebuggerPresent = (hDebugPort != NULL);

    return TRUE;
}


//#ifdef i386
//#pragma optimize("",off)
//#endif // i386
VOID
APIENTRY
DebugBreak(
    VOID
    )

/*++

Routine Description:

    This function causes a breakpoint exception to occur in the caller.
    This allows the calling thread to signal the debugger forcing it to
    take some action.  If the process is not being debugged, the
    standard exception search logic is invoked.  In most cases, this
    will cause the calling process to terminate (due to an unhandled
    breakpoint exception).

Arguments:

    None.

Return Value:

    None.

--*/

{
    DbgBreakPoint();
}
//#ifdef i386
//#pragma optimize("",on)
//#endif // i386

VOID
APIENTRY
OutputDebugStringW(
    LPCWSTR lpOutputString
    )

/*++

Routine Description:

    UNICODE thunk to OutputDebugStringA

--*/

{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    RtlInitUnicodeString(&UnicodeString,lpOutputString);
    Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if ( !NT_SUCCESS(Status) ) {
        AnsiString.Buffer = "";
        }
    OutputDebugStringA(AnsiString.Buffer);
    if ( NT_SUCCESS(Status) ) {
        RtlFreeAnsiString(&AnsiString);
        }
}


#define DBWIN_TIMEOUT   10000
HANDLE CreateDBWinMutex(VOID) {

    SECURITY_ATTRIBUTES SecurityAttributes;
    SECURITY_DESCRIPTOR sd;
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidEveryone = NULL;
    PACL pAcl = NULL;
    DWORD cbAcl, aceIndex;
    HANDLE h = NULL;
    DWORD i;
    //
    // Get the system sid
    //

    Status = RtlAllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                   0, 0, 0, 0, 0, 0, 0, &psidSystem);
    if (!NT_SUCCESS(Status))
        goto Exit;


    //
    // Get the Admin sid
    //

    Status = RtlAllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                       DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                       0, 0, 0, 0, &psidAdmin);

    if (!NT_SUCCESS(Status))
        goto Exit;


    //
    // Get the World sid
    //

    Status = RtlAllocateAndInitializeSid(&authWorld, 1, SECURITY_WORLD_RID,
                      0, 0, 0, 0, 0, 0, 0, &psidEveryone);

    if (!NT_SUCCESS(Status))
          goto Exit;


    //
    // Allocate space for the ACL
    //

    cbAcl = sizeof(ACL) +
            3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
            RtlLengthSid(psidSystem) +
            RtlLengthSid(psidAdmin) +
            RtlLengthSid(psidEveryone);

    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }

    Status = RtlCreateAcl(pAcl, cbAcl, ACL_REVISION);
    if (!NT_SUCCESS(Status))
        goto Exit;


    //
    // Add Aces.
    //

    Status = RtlAddAccessAllowedAce(pAcl, ACL_REVISION, READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE, psidEveryone);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = RtlAddAccessAllowedAce(pAcl, ACL_REVISION, MUTEX_ALL_ACCESS, psidSystem);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = RtlAddAccessAllowedAce(pAcl, ACL_REVISION, MUTEX_ALL_ACCESS, psidAdmin);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status))
       goto Exit;

    Status = RtlSetDaclSecurityDescriptor(&sd, TRUE, pAcl, FALSE);
    if (!NT_SUCCESS(Status))
       goto Exit;


    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.bInheritHandle = TRUE;
    SecurityAttributes.lpSecurityDescriptor = &sd;

    i = 0;
    while (1) {
        h = OpenMutex (READ_CONTROL | SYNCHRONIZE | MUTEX_MODIFY_STATE,
                       TRUE,
                       "DBWinMutex");
        if (h != NULL) {
            break;
        }
        h = CreateMutex(&SecurityAttributes, FALSE, "DBWinMutex");
        if (h != NULL || GetLastError () != ERROR_ACCESS_DENIED || i++ > 100) {
            break;
        }
    }
Exit:
    if (psidSystem) {
        RtlFreeSid(psidSystem);
    }

    if (psidAdmin) {
        RtlFreeSid(psidAdmin);
    }

    if (psidEveryone) {
        RtlFreeSid(psidEveryone);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }
    return h;
}


VOID
APIENTRY
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )

/*++

Routine Description:

    This function allows an application to send a string to its debugger
    for display.  If the application is not being debugged, but the
    system debugger is active, the system debugger displays the string.
    Otherwise, this function has no effect.

Arguments:

    lpOutputString - Supplies the address of the debug string to be sent
        to the debugger.

Return Value:

    None.

--*/

{
    ULONG_PTR ExceptionArguments[2];

    //
    // Raise an exception. If APP is being debugged, the debugger
    // will catch and handle this. Otherwise, kernel debugger is
    // called.
    //

    try {
        ExceptionArguments[0]=strlen(lpOutputString)+1;
        ExceptionArguments[1]=(ULONG_PTR)lpOutputString;
        RaiseException(DBG_PRINTEXCEPTION_C,0,2,ExceptionArguments);
        }
    except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // We caught the debug exception, so there's no user-mode
        // debugger.  If there is a DBWIN running, send the string
        // to it.  If not, use DbgPrint to send it to the kernel
        // debugger.  DbgPrint can only handle 511 characters at a
        // time, so force-feed it.
        //

        char   szBuf[512];
        size_t cchRemaining;
        LPCSTR pszRemainingOutput;

        HANDLE SharedFile = NULL;
        LPSTR SharedMem = NULL;
        HANDLE AckEvent = NULL;
        HANDLE ReadyEvent = NULL;

        static HANDLE DBWinMutex = NULL;
        static BOOLEAN CantGetMutex = FALSE;

        //
        // look for DBWIN.
        //

        if (!DBWinMutex && !CantGetMutex) {
            DBWinMutex = CreateDBWinMutex();
            if (!DBWinMutex)
                CantGetMutex = TRUE;
        }

        if (DBWinMutex) {

            WaitForSingleObject(DBWinMutex, INFINITE);

            SharedFile = OpenFileMapping(FILE_MAP_WRITE, FALSE, "DBWIN_BUFFER");

            if (SharedFile) {

                SharedMem = MapViewOfFile( SharedFile,
                                        FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, 0);
                if (SharedMem) {

                    AckEvent = OpenEvent(SYNCHRONIZE, FALSE,
                                                         "DBWIN_BUFFER_READY");
                    if (AckEvent) {
                        ReadyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE,
                                                           "DBWIN_DATA_READY");
                        }
                    }
                }

            if (!ReadyEvent) {
                ReleaseMutex(DBWinMutex);
                }

            }

        try {
            pszRemainingOutput = lpOutputString;
            cchRemaining = strlen(pszRemainingOutput);

            while (cchRemaining > 0) {
                int used;

                if (ReadyEvent && WaitForSingleObject(AckEvent, DBWIN_TIMEOUT)
                                                            == WAIT_OBJECT_0) {

                    *((DWORD *)SharedMem) = GetCurrentProcessId();

                    used = (int)((cchRemaining < 4095 - sizeof(DWORD)) ?
                                         cchRemaining : (4095 - sizeof(DWORD)));

                    RtlCopyMemory(SharedMem+sizeof(DWORD),
                                  pszRemainingOutput,
                                  used);
                    SharedMem[used+sizeof(DWORD)] = 0;
                    SetEvent(ReadyEvent);

                    }
                else {
                    used = (int)((cchRemaining < sizeof(szBuf) - 1) ?
                                           cchRemaining : (int)(sizeof(szBuf) - 1));

                    RtlCopyMemory(szBuf, pszRemainingOutput, used);
                    szBuf[used] = 0;
                    DbgPrint("%s", szBuf);
                    }

                pszRemainingOutput += used;
                cchRemaining       -= used;

                }
            }
        except(STATUS_ACCESS_VIOLATION == GetExceptionCode()) {
            DbgPrint("\nOutputDebugString faulted during output\n");
            }

        if (AckEvent) {
            CloseHandle(AckEvent);
            }
        if (SharedMem) {
            UnmapViewOfFile(SharedMem);
            }
        if (SharedFile) {
            CloseHandle(SharedFile);
            }
        if (ReadyEvent) {
            CloseHandle(ReadyEvent);
            ReleaseMutex(DBWinMutex);
            }

        }

}

BOOL
APIENTRY
WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A debugger waits for a debug event to occur in one of its debuggees
    using WaitForDebugEvent:

    Upon successful completion of this API, the lpDebugEvent structure
    contains the relevant information of the debug event.

Arguments:

    lpDebugEvent - Receives information specifying the type of debug
        event that occured.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test for debug
        events A timeout value of -1 specifies an infinite timeout
        period.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed (or timed out).  Extended error
        status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    DBGUI_WAIT_STATE_CHANGE StateChange;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;


    pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);

again:
    Status = DbgUiWaitStateChange(&StateChange,pTimeOut);
    if ( Status == STATUS_ALERTED || Status == STATUS_USER_APC) {
        goto again;
        }
    if ( !NT_SUCCESS(Status) && Status != DBG_UNABLE_TO_PROVIDE_HANDLE ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( Status == STATUS_TIMEOUT ) {
        SetLastError(ERROR_SEM_TIMEOUT);
        return FALSE;
        }
    Status = DbgUiConvertStateChangeStructure  (&StateChange, lpDebugEvent);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    switch (lpDebugEvent->dwDebugEventCode) {

    case CREATE_THREAD_DEBUG_EVENT :
        //
        // Save away thread handle for later cleanup.
        //
        SaveThreadHandle (lpDebugEvent->dwProcessId,
                          lpDebugEvent->dwThreadId,
                          lpDebugEvent->u.CreateThread.hThread);
        break;

    case CREATE_PROCESS_DEBUG_EVENT :

        SaveProcessHandle (lpDebugEvent->dwProcessId,
                           lpDebugEvent->u.CreateProcessInfo.hProcess);

        SaveThreadHandle (lpDebugEvent->dwProcessId,
                          lpDebugEvent->dwThreadId,
                          lpDebugEvent->u.CreateProcessInfo.hThread);

        break;

    case EXIT_THREAD_DEBUG_EVENT :

        MarkThreadHandle (lpDebugEvent->dwThreadId);

        break;

    case EXIT_PROCESS_DEBUG_EVENT :

        MarkThreadHandle (lpDebugEvent->dwThreadId);
        MarkProcessHandle (lpDebugEvent->dwProcessId);

        break;

    case OUTPUT_DEBUG_STRING_EVENT :
    case RIP_EVENT :
    case EXCEPTION_DEBUG_EVENT :
        break;

    case LOAD_DLL_DEBUG_EVENT :
        break;

    case UNLOAD_DLL_DEBUG_EVENT :
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL
APIENTRY
ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    )

/*++

Routine Description:

    A debugger can continue a thread that previously reported a debug
    event using ContinueDebugEvent.

    Upon successful completion of this API, the specified thread is
    continued.  Depending on the debug event previously reported by the
    thread certain side effects occur.

    If the continued thread previously reported an exit thread debug
    event, the handle that the debugger has to the thread is closed.

    If the continued thread previously reported an exit process debug
    event, the handles that the debugger has to the thread and to the
    process are closed.

Arguments:

    dwProcessId - Supplies the process id of the process to continue. The
        combination of process id and thread id must identify a thread that
        has previously reported a debug event.

    dwThreadId - Supplies the thread id of the thread to continue. The
        combination of process id and thread id must identify a thread that
        has previously reported a debug event.

    dwContinueStatus - Supplies the continuation status for the thread
        reporting the debug event.

        dwContinueStatus Values:

            DBG_CONTINUE - If the thread being continued had
                previously reported an exception event, continuing with
                this value causes all exception processing to stop and
                the thread continues execution.  For any other debug
                event, this continuation status simply allows the thread
                to continue execution.

            DBG_EXCEPTION_NOT_HANDLED - If the thread being continued
                had previously reported an exception event, continuing
                with this value causes exception processing to continue.
                If this is a first chance exception event, then
                structured exception handler search/dispatch logic is
                invoked.  Otherwise, the process is terminated.  For any
                other debug event, this continuation status simply
                allows the thread to continue execution.

            DBG_TERMINATE_THREAD - After all continue side effects are
                processed, this continuation status causes the thread to
                jump to a call to ExitThread.  The exit code is the
                value DBG_TERMINATE_THREAD.

            DBG_TERMINATE_PROCESS - After all continue side effects are
                processed, this continuation status causes the thread to
                jump to a call to ExitProcess.  The exit code is the
                value DBG_TERMINATE_PROCESS.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    CLIENT_ID ClientId;

    ClientId.UniqueProcess = (HANDLE)LongToHandle(dwProcessId);
    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);


    Status = DbgUiContinue(&ClientId,(NTSTATUS)dwContinueStatus);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    RemoveHandles (dwThreadId, dwProcessId);

    return TRUE;
}

HANDLE
ProcessIdToHandle (
    IN DWORD dwProcessId
    )
{
    OBJECT_ATTRIBUTES oa;
    HANDLE Process;
    CLIENT_ID ClientId;
    NTSTATUS Status;

    if (dwProcessId == -1) {
        ClientId.UniqueProcess = CsrGetProcessId ();
    } else {
        ClientId.UniqueProcess = LongToHandle(dwProcessId);
    }
    ClientId.UniqueThread = NULL;

    InitializeObjectAttributes (&oa, NULL, 0, NULL, NULL);

    Status = NtOpenProcess (&Process,
                            PROCESS_SET_PORT|PROCESS_CREATE_THREAD|PROCESS_QUERY_INFORMATION|PROCESS_VM_OPERATION|
                                PROCESS_VM_WRITE|PROCESS_VM_READ,
                            &oa,
                            &ClientId);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        Process = NULL;
    }
    return Process;
}

BOOL
APIENTRY
DebugActiveProcess(
    DWORD dwProcessId
    )

/*++

Routine Description:

    This API allows a debugger to attach to an active process and debug
    the process.  The debugger specifies the process that it wants to
    debug through the process id of the target process.  The debugger
    gets debug access to the process as if it had created the process
    with the DEBUG_ONLY_THIS_PROCESS creation flag.

    The debugger must have approriate access to the calling process such
    that it can open the process for PROCESS_ALL_ACCESS.  For Dos/Win32
    this never fails (the process id just has to be a valid process id).
    For NT/Win32 this check can fail if the target process was created
    with a security descriptor that denies the debugger approriate
    access.

    Once the process id check has been made and the system determines
    that a valid debug attachment is being made, this call returns
    success to the debugger.  The debugger is then expected to wait for
    debug events.  The system will suspend all threads in the process
    and feed the debugger debug events representing the current state of
    the process.

    The system will feed the debugger a single create process debug
    event representing the process specified by dwProcessId.  The
    lpStartAddress field of the create process debug event is NULL.  For
    each thread currently part of the process, the system will send a
    create thread debug event.  The lpStartAddress field of the create
    thread debug event is NULL.  For each DLL currently loaded into the
    address space of the target process, the system will send a LoadDll
    debug event.  The system will arrange for the first thread in the
    process to execute a breakpoint instruction after it is resumed.
    Continuing this thread causes the thread to return to whatever it
    was doing prior to the debug attach.

    After all of this has been done, the system resumes all threads within
    the process. When the first thread in the process resumes, it will
    execute a breakpoint instruction causing an exception debug event
    to be sent to the debugger.

    All future debug events are sent to the debugger using the normal
    mechanism and rules.


Arguments:

    dwProcessId - Supplies the process id of a process the caller
        wants to debug.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE Process;
    NTSTATUS Status, Status1;


    //
    // Connect to dbgss as a user interface
    //

    Status = DbgUiConnectToDbg ();
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }


    //
    // Convert the process ID to a handle
    //
    Process = ProcessIdToHandle (dwProcessId);
    if (Process == NULL) {
        return FALSE;
    }


    Status = DbgUiDebugActiveProcess (Process);

    if (!NT_SUCCESS (Status))  {
        Status1 = NtClose (Process);
        ASSERT (NT_SUCCESS (Status1));
        BaseSetLastNTError (Status);
        return FALSE;
    }

    Status1 = NtClose (Process);
    ASSERT (NT_SUCCESS (Status1));

    return TRUE;
}

BOOL
APIENTRY
DebugActiveProcessStop(
    DWORD dwProcessId
    )

/*++

Routine Description:



Arguments:

    dwProcessId - Supplies the process id of a process the caller
        wants to stop debugging.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE Process, Thread;
    NTSTATUS Status;
    NTSTATUS Status1;
    DWORD ThreadId;

    Process = ProcessIdToHandle (dwProcessId);
    if (Process == NULL) {
        return FALSE;
    }
    //
    // Tell dbgss we have finished with this process.
    //

    CloseAllProcessHandles (dwProcessId);
    Status = DbgUiStopDebugging (Process);

    Status1 = NtClose (Process);

    ASSERT (NT_SUCCESS (Status1));

    if (!NT_SUCCESS(Status)) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
DebugBreakProcess (
    IN HANDLE Process
    )
/*++

Routine Description:

    This functions creates a thread inside the target process that issues a break.

Arguments:

    Process - Handle to process

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = DbgUiIssueRemoteBreakin (Process);
    if (NT_SUCCESS (Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError (Status);
        return FALSE;
    }
}

BOOL
APIENTRY
DebugSetProcessKillOnExit (
    IN BOOL KillOnExit
    )
/*++

Routine Description:

    This functions sets the action to be performed when the debugging thread dies

Arguments:

    KillOnExit - TRUE: Kill debugged processes on exit, FALSE: Detatch on debug exit

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    HANDLE DebugHandle;
    ULONG Flags;
    NTSTATUS Status;

    DebugHandle = DbgUiGetThreadDebugObject ();
    if (DebugHandle == NULL) {
        BaseSetLastNTError (STATUS_INVALID_HANDLE);
        return FALSE;
    }

    if (KillOnExit) {
        Flags = DEBUG_KILL_ON_CLOSE;
    } else {
        Flags = 0;
    }

    Status = NtSetInformationDebugObject (DebugHandle,
                                          DebugObjectFlags,
                                          &Flags,
                                          sizeof (Flags),
                                          NULL);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }
    return TRUE;
}

BOOL
APIENTRY
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    )

/*++

Routine Description:

    This function is used to return a descriptor table entry for the
    specified thread corresponding to the specified selector.

    This API is only functional on x86 based systems. For non x86 based
    systems. A value of FALSE is returned.

    This API is used by a debugger so that it can convert segment
    relative addresses to linear virtual address (since this is the only
    format supported by ReadProcessMemory and WriteProcessMemory.

Arguments:

    hThread - Supplies a handle to the thread that contains the
        specified selector.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    dwSelector - Supplies the selector value to lookup.  The selector
        value may be a global selector or a local selector.

    lpSelectorEntry - If the specified selector is contained withing the
        threads descriptor tables, this parameter returns the selector
        entry corresponding to the specified selector value.  This data
        can be used to compute the linear base address that segment
        relative addresses refer to.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
#if defined(i386)

    DESCRIPTOR_TABLE_ENTRY DescriptorEntry;
    NTSTATUS Status;

    DescriptorEntry.Selector = dwSelector;
    Status = NtQueryInformationThread(
                hThread,
                ThreadDescriptorTableEntry,
                &DescriptorEntry,
                sizeof(DescriptorEntry),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    *lpSelectorEntry = DescriptorEntry.Descriptor;
    return TRUE;

#else
    BaseSetLastNTError(STATUS_NOT_SUPPORTED);
    return FALSE;
#endif // i386

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\dir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements Win32 Directory functions.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include "mountmgr.h"

BOOL
APIENTRY
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateDirectoryW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return FALSE;
    }
        
    return ( CreateDirectoryW((LPCWSTR)Unicode->Buffer,lpSecurityAttributes) );
}

BOOL
APIENTRY
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A directory can be created using CreateDirectory.

    This API causes a directory with the specified pathname to be
    created.  If the underlying file system supports security on files
    and directories, then the SecurityDescriptor argument is applied to
    the new directory.

    This call is similar to DOS (int 21h, function 39h) and OS/2's
    DosCreateDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be created.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new directory.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpPathName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    //
    // dont create a directory unless there is room in the directory for
    // at least an 8.3 name. This way everyone will be able to delete all
    // files in the directory by using del *.* which expands to path+\*.*
    //

    if ( FileName.Length > ((MAX_PATH-12)<<1) ) {
        DWORD L;
        LPWSTR lp;

        if ( !(lpPathName[0] == '\\' && lpPathName[1] == '\\' &&
               lpPathName[2] == '?' && lpPathName[3] == '\\') ) {
            L = GetFullPathNameW(lpPathName,0,NULL,&lp);
            if ( !L || L+12 > MAX_PATH ) {
                RtlFreeHeap(RtlProcessHeap(), 0,FileName.Buffer);
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
                }
            }
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

    Status = NtCreateFile(
                &Handle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_CREATE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                NULL,
                0L
                );

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        NtClose(Handle);
        return TRUE;
        }
    else {
        if ( RtlIsDosDeviceName_U((LPWSTR)lpPathName) ) {
            Status = STATUS_NOT_A_DIRECTORY;
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    ANSI thunk to CreateDirectoryFromTemplateW

--*/

{
    PUNICODE_STRING StaticUnicode;
    UNICODE_STRING DynamicUnicode;
    BOOL b;

    StaticUnicode = Basep8BitStringToStaticUnicodeString( lpTemplateDirectory );
    if (StaticUnicode == NULL) {
        return FALSE;
    }
        
    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicode, lpNewDirectory )) {
        return FALSE;
    }
    
    b = CreateDirectoryExW(
            (LPCWSTR)StaticUnicode->Buffer,
            (LPCWSTR)DynamicUnicode.Buffer,
            lpSecurityAttributes
            );
    
    RtlFreeUnicodeString(&DynamicUnicode);
    
    return b;
}

BOOL
APIENTRY
CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A directory can be created using CreateDirectoryEx, retaining the
    attributes of the original directory file.

    This API causes a directory with the specified pathname to be
    created.  If the underlying file system supports security on files
    and directories, then the SecurityDescriptor argument is applied to
    the new directory.  The other attributes of the template directory are
    retained when creating the new directory.

    If the original directory is a volume mount point then the new directory
    is also a volume mount point to the same volume as the original one.

Arguments:

    lpTemplateDirectory - Supplies the pathname of the directory to be used as
        a template when creating the new directory.

    lpPathName - Supplies the pathname of the directory to be created.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new directory.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE SourceFile;
    HANDLE DestFile;
    UNICODE_STRING PathName;
    UNICODE_STRING TargetName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    BOOLEAN IsNameGrafting = FALSE;
    UNICODE_STRING VolumeName;
    UNICODE_STRING MountPoint;
    PWCHAR VolumeMountPoint = NULL;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreePathBuffer;
    PVOID FreeTargetBuffer;
    UNICODE_STRING StreamName;
    WCHAR FileName[MAXIMUM_FILENAME_LENGTH+1];
    HANDLE StreamHandle;
    HANDLE OutputStream;
    PFILE_STREAM_INFORMATION StreamInfo;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    PFILE_STREAM_INFORMATION StreamInfoBase;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    FILE_EA_INFORMATION EaInfo;
    FILE_BASIC_INFORMATION BasicInfo;
    ULONG EaSize;
    ULONG StreamInfoSize;
    ULONG CopySize;
    ULONG i;
    ULONG DesiredAccess = 0;
    DWORD Options;
    DWORD b;
    LPCOPYFILE_CONTEXT CopyFileContext = NULL;

    //
    // Process the input template directory name and then open the directory
    // file, ensuring that it really is a directory.
    //

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpTemplateDirectory,
                            &PathName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreePathBuffer = PathName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        PathName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &SourceFile,
                 FILE_LIST_DIRECTORY | FILE_READ_EA | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
           //   
           // Re-open not inhibiting the reparse behavior.
           //

           Status = NtOpenFile(
                        &SourceFile,
                        FILE_LIST_DIRECTORY | FILE_READ_EA | FILE_READ_ATTRIBUTES,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                        );

           if ( !NT_SUCCESS(Status) ) {
               RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
               BaseSetLastNTError(Status);
               return FALSE;
               }
           }
        else {
           RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
           BaseSetLastNTError(Status);
           return FALSE;
           }
        }
    else { 
        //
        // See whether we have a name grafting operation.
        //

        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

        Status = NtQueryInformationFile(
                     SourceFile,
                     &IoStatusBlock,
                     (PVOID)&BasicInfo,
                     sizeof(BasicInfo),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
            CloseHandle(SourceFile);
            BaseSetLastNTError(Status);
            return FALSE;
            }

        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
            Status = NtQueryInformationFile(
                         SourceFile,
                         &IoStatusBlock,
                         (PVOID)&FileTagInformation,
                         sizeof(FileTagInformation),
                         FileAttributeTagInformation
                         );

            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
                CloseHandle(SourceFile);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            if ( FileTagInformation.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {
                //   
                // Close and re-open not inhibiting the reparse behavior.
                //

                CloseHandle(SourceFile);

                Status = NtOpenFile(
                             &SourceFile,
                             FILE_LIST_DIRECTORY | FILE_READ_EA | FILE_READ_ATTRIBUTES,
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                             );

                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            else {
                IsNameGrafting = TRUE;                
            }
        }
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpNewDirectory,
                            &TargetName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
        NtClose(SourceFile);
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeTargetBuffer = TargetName.Buffer;

    //
    // Verify that the source and target are different.
    //

    if ( RtlEqualUnicodeString(&PathName, &TargetName, TRUE) ) {
        //
        // Do nothing. Source and target are the same.
        //

        RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
        NtClose(SourceFile);
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreePathBuffer);

    //
    // Do not create a directory unless there is room in the directory for
    // at least an 8.3 name. This way everyone will be able to delete all
    // files in the directory by using del *.* which expands to path+\*.*
    //

    if ( TargetName.Length > ((MAX_PATH-12)<<1) ) {
        DWORD L;
        LPWSTR lp;
        if ( !(lpNewDirectory[0] == '\\' && lpNewDirectory[1] == '\\' &&
               lpNewDirectory[2] == '?' && lpNewDirectory[3] == '\\') ) {
            L = GetFullPathNameW(lpNewDirectory,0,NULL,&lp);
            if ( !L || L+12 > MAX_PATH ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
                CloseHandle(SourceFile);
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
                }
            }
        }

    if ( RelativeName.RelativeName.Length ) {
        TargetName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    EaBuffer = NULL;
    EaSize = 0;

    Status = NtQueryInformationFile(
                 SourceFile,
                 &IoStatusBlock,
                 &EaInfo,
                 sizeof(EaInfo),
                 FileEaInformation
                 );

    if ( !NT_SUCCESS(Status) ) {
        RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
        CloseHandle(SourceFile);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {
        EaSize = EaInfo.EaSize;
        do {
            EaSize *= 2;
            EaBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
            if ( !EaBuffer ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
                CloseHandle(SourceFile);
                BaseSetLastNTError(STATUS_NO_MEMORY);
                return FALSE;
                }

            Status = NtQueryEaFile(
                         SourceFile,
                         &IoStatusBlock,
                         EaBuffer,
                         EaSize,
                         FALSE,
                         (PVOID)NULL,
                         0,
                         (PULONG)NULL,
                         TRUE
                         );

            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);
                EaBuffer = NULL;
                IoStatusBlock.Information = 0;
                }
            } while ( Status == STATUS_BUFFER_OVERFLOW ||
                      Status == STATUS_BUFFER_TOO_SMALL );
        EaSize = (ULONG)IoStatusBlock.Information;
        }

    //
    // Open/create the destination directory.
    //

    InitializeObjectAttributes(
        &Obja,
        &TargetName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

    DesiredAccess = FILE_LIST_DIRECTORY | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE;
    if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        //
        // To set the reparse point at the target one needs FILE_WRITE_DATA.
        //

        DesiredAccess |= FILE_WRITE_DATA;
    }

    //
    // Clear the reparse attribute before creating the target. Only the
    // name grafting use of reparse points is preserved at this level.
    // Open first inhibiting the reparse behavior.
    //
    
    BasicInfo.FileAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;

    Status = NtCreateFile(
                 &DestFile,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 NULL,
                 BasicInfo.FileAttributes,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT,
                 EaBuffer,
                 EaSize
                 );

    if ( !NT_SUCCESS(Status) ) {    
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( (Status == STATUS_INVALID_PARAMETER) ||
             (Status == STATUS_ACCESS_DENIED) ) {
            //
            // Either the FS does not support reparse points or we do not have enough
            // access to the target.
            //

            if ( IsNameGrafting ) {
                //
                // We need to return error, as the target cannot be opened correctly.
                //

                RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);
                if ( EaBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);
                    }
                CloseHandle(SourceFile);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            Status = NtCreateFile(
                         &DestFile,
                         FILE_LIST_DIRECTORY | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         NULL,
                         BasicInfo.FileAttributes,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_CREATE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                         EaBuffer,
                         EaSize
                         );                        
            }
        }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeTargetBuffer);

    if ( EaBuffer ) {
        RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);
        }

    if ( !NT_SUCCESS(Status) ) {
        NtClose(SourceFile);
        if ( RtlIsDosDeviceName_U((LPWSTR)lpNewDirectory) ) {
            Status = STATUS_NOT_A_DIRECTORY;
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    else {
        if ( IsNameGrafting ) {
           
            PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
            PUCHAR ReparseBuffer = NULL;

            //
            // Allocate the buffer to get/set the reparse point.
            //

            ReparseBuffer = RtlAllocateHeap(
                                RtlProcessHeap(), 
                                MAKE_TAG( TMP_TAG ), 
                                MAXIMUM_REPARSE_DATA_BUFFER_SIZE);

            if ( ReparseBuffer == NULL) {
                NtClose(SourceFile);
                NtClose(DestFile);
                BaseSetLastNTError(STATUS_NO_MEMORY);
                //
                // Notice that we leave behind the target directory.
                //
                return FALSE;
            }

            //
            // Get the data in the reparse point.
            //

            Status = NtFsControlFile(
                         SourceFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_GET_REPARSE_POINT,
                         NULL,                                //  Input buffer
                         0,                                   //  Input buffer length
                         ReparseBuffer,                       //  Output buffer
                         MAXIMUM_REPARSE_DATA_BUFFER_SIZE     //  Output buffer length
                         );

            if ( !NT_SUCCESS( Status ) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
                NtClose(SourceFile);
                NtClose(DestFile);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            //
            // Defensive sanity check. The reparse buffer should be name grafting.
            //

            ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;

            if ( ReparseBufferHeader->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {
                RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
                NtClose(SourceFile);
                NtClose(DestFile);
                BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
                return FALSE;
                }

            //
            // Finish up the creation of the target directory.
            //

            VolumeName.Length = VolumeName.MaximumLength =
                ReparseBufferHeader->MountPointReparseBuffer.SubstituteNameLength;
            VolumeName.Buffer = (PWCHAR)
                ((PCHAR) ReparseBufferHeader->MountPointReparseBuffer.PathBuffer +
                         ReparseBufferHeader->MountPointReparseBuffer.SubstituteNameOffset);

            if (MOUNTMGR_IS_NT_VOLUME_NAME_WB(&VolumeName)) {
                //
                // Set the volume mount point and be done.
                //
                // SetVolumeMountPoint requires the mount point name
                // to have a trailing backslash.
                //                
                
                RtlInitUnicodeString(&MountPoint, lpNewDirectory);
                VolumeMountPoint = RtlAllocateHeap(RtlProcessHeap(),
                                                   MAKE_TAG(TMP_TAG),
                                                   MountPoint.Length +
                                                   2*sizeof(WCHAR));
                if (!VolumeMountPoint) {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        b = FALSE;
                    }
                else {

                    RtlCopyMemory(VolumeMountPoint, MountPoint.Buffer,
                                  MountPoint.Length);
                    VolumeMountPoint[MountPoint.Length/sizeof(WCHAR)] = 0;

                    if (MountPoint.Buffer[MountPoint.Length/sizeof(WCHAR) - 1] != '\\') {
                        VolumeMountPoint[MountPoint.Length/sizeof(WCHAR)] = '\\';
                        VolumeMountPoint[MountPoint.Length/sizeof(WCHAR) + 1] = 0;
                    }
                        
                    //
                    // The volume name should be like "\\?\Volume{guid}\"
                    //

                    VolumeName.Buffer[1] = '\\';
                    
                    b = SetVolumeMountPointW(
                            VolumeMountPoint, 
                            VolumeName.Buffer
                            );

                    RtlFreeHeap(RtlProcessHeap(), 0, VolumeMountPoint);
                    VolumeName.Buffer[1] = '?';
                    }
                }                
            else {
                //
                // Copy the directory junction and be done.
                //

                b = TRUE;
                Status = NtFsControlFile(
                             DestFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_SET_REPARSE_POINT,
                             ReparseBuffer,
                             FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                             NULL,                //  Output buffer
                             0                    //  Output buffer length
                             );                  
                }

            // 
            // Free the buffer.
            //

            RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);

            //
            // Close all files and return appropriatelly.
            //

            NtClose(SourceFile);
            NtClose(DestFile);

            if ( !b ) {
                //
                // No need to set the last error as SetVolumeMountPointW has done it. 
                //
                return FALSE;
                }
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            
            return TRUE;

            //
            // The source directory was a name grafting directory.
            // No data streams are copied.
            //
            }

        //
        // Attempt to determine whether or not this file has any alternate
        // data streams associated with it.  If it does, attempt to copy each
        // to the output file.  If any copy fails, simply drop the error on
        // the floor, and continue.
        //

        StreamInfoSize = 4096;
        CopySize = 4096;
        do {
            StreamInfoBase = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), StreamInfoSize);
            if ( !StreamInfoBase ) {
                BaseMarkFileForDelete(DestFile, BasicInfo.FileAttributes);
                BaseSetLastNTError(STATUS_NO_MEMORY);
                b = FALSE;
                break;
                }
            Status = NtQueryInformationFile(
                         SourceFile,
                         &IoStatusBlock,
                         (PVOID) StreamInfoBase,
                         StreamInfoSize,
                         FileStreamInformation
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                StreamInfoBase = NULL;
                StreamInfoSize *= 2;
                }
            } while ( Status == STATUS_BUFFER_OVERFLOW ||
                      Status == STATUS_BUFFER_TOO_SMALL );

        //
        // Directories do not always have a stream
        //

        if ( NT_SUCCESS(Status) && IoStatusBlock.Information ) {
            StreamInfo = StreamInfoBase;

            for (;;) {

                DWORD DestFileFsAttributes = 0;

                //
                // Build a string descriptor for the name of the stream.
                //

                StreamName.Buffer = &StreamInfo->StreamName[0];
                StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                StreamName.MaximumLength = StreamName.Length;

                //
                // Open the source stream.
                //

                InitializeObjectAttributes(
                    &Obja,
                    &StreamName,
                    0,
                    SourceFile,
                    NULL
                    );
                Status = NtCreateFile(
                             &StreamHandle,
                             GENERIC_READ | SYNCHRONIZE,
                             &Obja,
                             &IoStatusBlock,
                             NULL,
                             0,
                             FILE_SHARE_READ,
                             FILE_OPEN,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             NULL,
                             0
                             );
                if ( NT_SUCCESS(Status) ) {
                    for ( i = 0; i < (ULONG) StreamName.Length >> 1; i++ ) {
                        FileName[i] = StreamName.Buffer[i];
                        }
                    FileName[i] = L'\0';
                    OutputStream = (HANDLE)NULL;
                    Options = 0;
                    b = BaseCopyStream(
                            NULL,
                            StreamHandle,
                            GENERIC_READ | SYNCHRONIZE,
                            FileName,
                            DestFile,
                            &StreamInfo->StreamSize,
                            &Options,
                            &OutputStream,
                            &CopySize,
                            &CopyFileContext,
                            (LPRESTART_STATE)NULL,
                            (BOOL)FALSE,
                            (DWORD)0,
                            &DestFileFsAttributes
                            );
                    NtClose(StreamHandle);
                    if ( OutputStream ) {
                        NtClose(OutputStream);
                        }
                    }

                if ( StreamInfo->NextEntryOffset ) {
                    StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
                    }
                else {
                    break;
                    }

                }
            }
        if ( StreamInfoBase ) {
            RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
            }
        b = TRUE;
        }
    NtClose(SourceFile);
    if ( DestFile ) {
        NtClose(DestFile);
        }
    return b;
}

BOOL
APIENTRY
RemoveDirectoryA(
    LPCSTR lpPathName
    )

/*++

Routine Description:

    ANSI thunk to RemoveDirectoryW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return FALSE;
    }
        
    return ( RemoveDirectoryW((LPCWSTR)Unicode->Buffer) );
}

BOOL
APIENTRY
RemoveDirectoryW(
    LPCWSTR lpPathName
    )

/*++

Routine Description:

    An existing directory can be removed using RemoveDirectory.

    This API causes a directory with the specified pathname to be
    deleted.  The directory must be empty before this call can succeed.

    This call is similar to DOS (int 21h, function 3Ah) and OS/2's
    DosDeleteDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be removed.
        The path must specify an empty directory to which the caller has
        delete access.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    BOOLEAN IsNameGrafting = FALSE;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    PREPARSE_DATA_BUFFER reparse;
    BOOL b;
    DWORD bytes;
    UNICODE_STRING mountName;
    PWCHAR volumeMountPoint;


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpPathName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );
                      
    //
    // Open the directory for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &Handle,
                 DELETE | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //   
            // Re-open not inhibiting the reparse behavior and not needing to read the attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        //
        // If we found a reparse point that is not a name grafting operation,
        // either a symbolic link or a mount point, we re-open without 
        // inhibiting the reparse behavior.
        //

        Status = NtQueryInformationFile(
                     Handle,
                     &IoStatusBlock,
                     (PVOID) &FileTagInformation,
                     sizeof(FileTagInformation),
                     FileAttributeTagInformation
                     );
        
        if ( !NT_SUCCESS(Status) ) {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                 (Status != STATUS_INVALID_PARAMETER) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if ( NT_SUCCESS(Status) &&
            (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ) {
            if ( FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {

                //
                // If this is a volume mount point then fail with
                // "directory not empty".
                //

                reparse = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                          MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
                if (!reparse) {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    NtClose(Handle);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                    }

                b = DeviceIoControl(Handle, FSCTL_GET_REPARSE_POINT, NULL, 0,
                                    reparse, MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
                                    &bytes, NULL);

                if (b) {

                    mountName.Length = mountName.MaximumLength =
                        reparse->MountPointReparseBuffer.SubstituteNameLength;
                    mountName.Buffer = (PWCHAR)
                        ((PCHAR) reparse->MountPointReparseBuffer.PathBuffer +
                         reparse->MountPointReparseBuffer.SubstituteNameOffset);

                    if (MOUNTMGR_IS_VOLUME_NAME(&mountName)) {

                        RtlInitUnicodeString(&mountName, lpPathName);
                        volumeMountPoint = RtlAllocateHeap(RtlProcessHeap(),
                                                           MAKE_TAG(TMP_TAG),
                                                           mountName.Length +
                                                           2*sizeof(WCHAR));
                        if (!volumeMountPoint) {
                            RtlFreeHeap(RtlProcessHeap(), 0, reparse);
                            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                            NtClose(Handle);
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            return FALSE;
                            }

                        RtlCopyMemory(volumeMountPoint, mountName.Buffer,
                                      mountName.Length);
                        volumeMountPoint[mountName.Length/sizeof(WCHAR)] = 0;

                        if (mountName.Buffer[mountName.Length/sizeof(WCHAR) - 1] != '\\') {
                            volumeMountPoint[mountName.Length/sizeof(WCHAR)] = '\\';
                            volumeMountPoint[mountName.Length/sizeof(WCHAR) + 1] = 0;
                        }

                        DeleteVolumeMountPointW(volumeMountPoint);

                        RtlFreeHeap(RtlProcessHeap(), 0, volumeMountPoint);
                        }
                    }

                RtlFreeHeap(RtlProcessHeap(), 0, reparse);
                IsNameGrafting = TRUE;
                }
            }
        
        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
             !IsNameGrafting) {
            //
            // Re-open without inhibiting the reparse behavior and not needing to 
            // read the attributes.
            //
  
            NtClose(Handle);
            Status = NtOpenFile(
                         &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if ( Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED ) {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(
                                 &Handle,
                                 DELETE | SYNCHRONIZE,
                                 &Obja,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                                 );
                    }

                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &Disposition,
                sizeof(Disposition),
                FileDispositionInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\filemap.c ===
/*++

Copyright (c) 1990,1991 Microsoft Corporation

Module Name:

    filemap.c

Abstract:

    This module implements Win32 mapped file APIs

Author:

    Mark Lucovsky (markl) 15-Feb-1991

Revision History:

--*/

#include "basedll.h"
HANDLE
APIENTRY
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateFileMappingW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateFileMappingW(
                hFile,
                lpFileMappingAttributes,
                flProtect,
                dwMaximumSizeHigh,
                dwMaximumSizeLow,
                NameBuffer
                );
}

HANDLE
APIENTRY
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
/*++

Routine Description:

    A file mapping object can be created using CreateFileMapping

    Creating a file mapping object creates the potential for mapping a
    view of the file into an address space.  File mapping objects may be
    shared either through process creation or handle duplication.
    Having a handle to a file mapping object allows for mapping of the
    file.  It does not mean that the file is actually mapped.

    A file mapping object has a maximum size.  This is used to size the
    file.  A file may not grow beyond the size specified in the mapping
    object.  While not required, it is recommended that when opening a
    file that you intend to map, the file should be opened for exclusive
    access.  Win32 does not require that a mapped file and a file
    accessed via the IO primitives (ReadFile/WriteFile) are coherent.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for file
    mapping objects:

      - FILE_MAP_WRITE - Write map access to the file mapping object is
            desired.  This allows a writable view of the file to be
            mapped.  Note that if flProtect does not include
            PAGE_READWRITE, this access type does not allow writing the
            mapped file.

      - FILE_MAP_READ - Read map access to the file mapping object is
            desired.  This allows a readablee view of the file to be
            mapped.

      - FILE_MAP_ALL_ACCESS - This set of access flags specifies all of
            the possible access flags for a file mapping object.

Arguments:

    hFile - Supplies an open handle to a file that a mapping object is
        to be created for.  The file must be opened with an access mode
        that is compatible with the specified pretection flags. A value
        of INVALID_HANDLE_VALUE specifies that the mapping object is
        backed by the system paging file.  If this is the case, a size
        must be specified.

    lpFileMappingAttributes - An optional parameter that may be used to
        specify the attributes of the new file mapping object.  If the
        parameter is not specified, then the file mapping object is
        created without a security descriptor, and the resulting handle
        is not inherited on process creation:

    flProtect - The protection desired for mapping object when the file
        is mapped.

        flProtect Values

        PAGE_READONLY - Read access to the committed region of pages is
            allowed.  An attempt to write or execute the committed
            region results in an access violation.  The specified hFile
            must have been created with GENERIC_READ access.

        PAGE_READWRITE - Read and write access to the committed region
            of pages is allowed.  The specified hFile must have been
            created with GENERIC_READ and GENERIC_WRITE access.

        PAGE_WRITECOPY - Read and copy on write access to the committed
            region of pages is allowed.  The specified hFile must have been
            created with GENERIC_READ access.

    dwMaximumSizeHigh - Supplies the high order 32-bits of the maximum
        size of the file mapping object.

    dwMaximumSizeLow - Supplies the low order 32-bits of the maximum
        size of the file mapping object.  A value of zero along with a
        value of zero in dwMaximumSizeHigh indicates that the size of
        the file mapping object is equal to the current size of the file
        specified by hFile.

    lpName - Supplies the name ofthe file mapping object.

Return Value:

    NON-NULL - Returns a handle to the new file mapping object.  The
        handle has full access to the new file mapping object and may be
        used in any API that requires a handle to a file mapping object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE Section;
    NTSTATUS Status;
    LARGE_INTEGER SectionSizeData;
    PLARGE_INTEGER SectionSize;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    ACCESS_MASK DesiredAccess;
    UNICODE_STRING ObjectName;
    ULONG AllocationAttributes;
    PWCHAR pstrNewObjName = NULL;

    DesiredAccess = STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ;
    AllocationAttributes = flProtect & (SEC_FILE | SEC_IMAGE | SEC_RESERVE | SEC_COMMIT | SEC_NOCACHE);
    flProtect ^= AllocationAttributes;
    if (AllocationAttributes == 0) {
        AllocationAttributes = SEC_COMMIT;
        }

    if ( flProtect == PAGE_READWRITE ) {
        DesiredAccess |= (SECTION_MAP_READ | SECTION_MAP_WRITE);
        }
    else
    if ( flProtect != PAGE_READONLY && flProtect != PAGE_WRITECOPY ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
        }

    if ( ARGUMENT_PRESENT(lpName) ) {
        if (gpTermsrvFormatObjectName && 
            (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {
    
            RtlInitUnicodeString(&ObjectName,pstrNewObjName);
    
        } else {
    
            RtlInitUnicodeString(&ObjectName,lpName);
        }

        pObja = BaseFormatObjectAttributes(&Obja,lpFileMappingAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpFileMappingAttributes,NULL);
        }

    if ( dwMaximumSizeLow || dwMaximumSizeHigh ) {
        SectionSize = &SectionSizeData;
        SectionSize->LowPart = dwMaximumSizeLow;
        SectionSize->HighPart = dwMaximumSizeHigh;
        }
    else {
        SectionSize = NULL;
        }

    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = NULL;
        if ( !SectionSize ) {
            SetLastError(ERROR_INVALID_PARAMETER);
            if (pstrNewObjName) {
                RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
            }
            return NULL;
            }
        }

    Status = NtCreateSection(
                &Section,
                DesiredAccess,
                pObja,
                SectionSize,
                flProtect,
                AllocationAttributes,
                hFile
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return Section = NULL;
        }
    else {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        }
    return Section;
}

HANDLE
APIENTRY
OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenFileMappingW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenFileMappingW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;
    PWCHAR pstrNewObjName = NULL;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    if (gpTermsrvFormatObjectName && 
        (pstrNewObjName = gpTermsrvFormatObjectName(lpName))) {

        RtlInitUnicodeString(&ObjectName,pstrNewObjName);

    } else {

        RtlInitUnicodeString(&ObjectName,lpName);
    }

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    if ( dwDesiredAccess == FILE_MAP_COPY ) {
        dwDesiredAccess = FILE_MAP_READ;
        }

    Status = NtOpenSection(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }
    
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


LPVOID
APIENTRY
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
    )

/*++

Routine Description:

    A view of a file may be mapped into the address space of the calling
    process using MapViewOfFile.

    Mapping a file object makes the specified portion of the file
    visible in the address space of the calling process.  The return
    address is a pointer to memory that when addressed causes data
    within the file to be accessed.

    Mapping a view of a file has some simple coherency rules:

      - Multiple views on a file are coherent if they are derived from
        the same file mapping object.  If a process opens a file,
        creates a mapping object, duplicates the object to another
        process...  If both processes map a view of the file, they will
        both see a coherent view of the file's data...  they will
        effectively be viewing shared memory backed by the file.

      - If multiple mapping objects exist for the same file, then views
        derived from the different mapping objects are not garunteed to
        be coherent.

      - A mapped view on a file is not garunteed to be coherent with a
        file being accessed via ReadFile or WriteFile.

Arguments:

    hFileMappingObject - Supplies an open handle to a file mapping object
        that is to be mapped into the callers address space.

    dwDesiredAccess - Specifies the access that is requested to the file
        mapping object. This determines the page protection of the pages
        mapped by the file.

        dwDesiredAccess Values:

        FILE_MAP_WRITE - Read/write access is desired.  The mapping
            object must have been created with PAGE_READWRITE
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_WRITE access. A read/write view of the file will
            be mapped.

        FILE_MAP_READ - Read access is desired.  The mapping object must
            have been created with PAGE_READWRITE or PAGE_READ
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_READ access.  A read only view of the file
            will be mapped.

    dwFileOffsetHigh - Supplies the high order 32-bits of the file
        offset where mapping is to begin.

    dwFileOffsetLow - Supplies the low order 32-bits of the file offset
        where mapping is to begin. The combination of the high and low
        offsets must specify a 64Kb aligned offset within the file. It
        is an error if this is not the case.

    dwNumberOfBytesToMap - Supplies the number of bytes of the file to map.
        A value of zero specifies that the entire file is to be mapped.

Return Value:

    NON-NULL - Returns the address of where the file is mapped.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return MapViewOfFileEx(
            hFileMappingObject,
            dwDesiredAccess,
            dwFileOffsetHigh,
            dwFileOffsetLow,
            dwNumberOfBytesToMap,
            NULL
            );
}

LPVOID
APIENTRY
MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    )

/*++

Routine Description:

    A view of a file may be mapped into the address space of the calling
    process using MapViewOfFileEx.

    Mapping a file object makes the specified portion of the file
    visible in the address space of the calling process.  The return
    address is a pointer to memory that when addressed causes data
    within the file to be accessed. This API allows the caller to
    supply the system with a suggested mapping address. The system
    will round this address down to the nearest 64k boundry and attempt
    to map the file at thet address. If there is not enough address space
    at that address, this call will fail.

    Mapping a view of a file has some simple coherency rules:

      - Multiple views on a file are coherent if they are derived from
        the same file mapping object.  If a process opens a file,
        creates a mapping object, duplicates the object to another
        process...  If both processes map a view of the file, they will
        both see a coherent view of the file's data...  they will
        effectively be viewing shared memory backed by the file.

      - If multiple mapping objects exist for the same file, then views
        derived from the different mapping objects are not garunteed to
        be coherent.

      - A mapped view on a file is not garunteed to be coherent with a
        file being accessed via ReadFile or WriteFile.

Arguments:

    hFileMappingObject - Supplies an open handle to a file mapping object
        that is to be mapped into the callers address space.

    dwDesiredAccess - Specifies the access that is requested to the file
        mapping object. This determines the page protection of the pages
        mapped by the file.

        dwDesiredAccess Values:

        FILE_MAP_WRITE - Read/write access is desired.  The mapping
            object must have been created with PAGE_READWRITE
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_WRITE access. A read/write view of the file will
            be mapped.

        FILE_MAP_READ - Read access is desired.  The mapping object must
            have been created with PAGE_READWRITE or PAGE_READ
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_READ access.  A read only view of the file
            will be mapped.

    dwFileOffsetHigh - Supplies the high order 32-bits of the file
        offset where mapping is to begin.

    dwFileOffsetLow - Supplies the low order 32-bits of the file offset
        where mapping is to begin. The combination of the high and low
        offsets must specify a 64Kb aligned offset within the file. It
        is an error if this is not the case.

    dwNumberOfBytesToMap - Supplies the number of bytes of the file to map.
        A value of zero specifies that the entire file is to be mapped.

    lpBaseAddress - Supplies the base address of where in the processes
        address space the mapping is to begin at.  The address is
        rounded down to the nearest 64k boundry by the system.  A value
        of NULL for this parameter operates exactly the same as
        MapViewOfFile...  The system picks the mapping base address
        without any hint from the caller.

Return Value:

    NON-NULL - Returns the address of where the file is mapped.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    PVOID ViewBase;
    ULONG Protect;

    SectionOffset.LowPart = dwFileOffsetLow;
    SectionOffset.HighPart = dwFileOffsetHigh;
    ViewSize = dwNumberOfBytesToMap;
    ViewBase = lpBaseAddress;

    if ( dwDesiredAccess == FILE_MAP_COPY ) {
        Protect = PAGE_WRITECOPY;
        }
    else
    if ( dwDesiredAccess & FILE_MAP_WRITE ) {
        Protect = PAGE_READWRITE;
        }
    else if ( dwDesiredAccess & FILE_MAP_READ ) {
        Protect = PAGE_READONLY;
        }
    else {
        Protect = PAGE_NOACCESS;
        }

    Status = NtMapViewOfSection(
                hFileMappingObject,
                NtCurrentProcess(),
                &ViewBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                Protect
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return ViewBase;
}


BOOL
APIENTRY
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    SIZE_T dwNumberOfBytesToFlush
    )

/*++

Routine Description:

    A byte range within a mapped view of a file can be flushed to disk
    using FlushViewOfFile.

    A byte range within a mapped view of a file can be flushed to disk
    using FlushViewOfFile.

    Flushing a range of a mapped view causes any dirty pages within that
    range to be written to disk.  This operation automatically happens
    whenever a view is unmapped (either explicitly or as a result of
    process termination).


Arguments:

    lpBaseAddress - Supplies the base address of a set of bytes that are
        to be flushed to the on disk representation of the mapped file.

    dwNumberOfBytesToFlush - Supplies the number of bytes to flush.

Return Value:

    TRUE - The operation was successful.  All dirty pages within the
        specified range are stored in the on-disk representation of the
        mapped file.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    IO_STATUS_BLOCK IoStatus;

    BaseAddress = (PVOID)lpBaseAddress;
    RegionSize = dwNumberOfBytesToFlush;

    Status = NtFlushVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &RegionSize,
                &IoStatus
                );
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_NOT_MAPPED_DATA ) {
            return TRUE;
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
APIENTRY
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    )

/*++

Routine Description:

    A previously mapped view of a file may be unmapped from the callers
    address space using UnmapViewOfFile.

Arguments:

    lpBaseAddress - Supplies the base address of a previously mapped
        view of a file that is to be unmapped.  This value must be
        identical to the value returned by a previous call to
        MapViewOfFile.

Return Value:

    TRUE - The operation was successful.  All dirty pages within the
        specified range are stored in the on-disk representation of the
        mapped file.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtUnmapViewOfSection(NtCurrentProcess(),(PVOID)lpBaseAddress);

    if ( !NT_SUCCESS(Status) ) {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {

            //
            // Unlock any pages that were locked with MmSecureVirtualMemory.
            // This is useful for SANs.
            //

            if (RtlFlushSecureMemoryCache((PVOID)lpBaseAddress, 0)) {
                Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                              (PVOID)lpBaseAddress
                                            );

                if (NT_SUCCESS( Status )) {
                    return( TRUE );
                    }
                }
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\dllatom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    atom.c

Abstract:

    This module contains the Win32 Atom Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

typedef ATOM *PATOM;

BOOL
InternalGetIntAtom(
    PUNICODE_STRING UnicodeAtomName,
    PATOM Atom
    );

ATOM
InternalAddAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    );

ATOM
InternalFindAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    );

ATOM
InternalDeleteAtom(
    BOOLEAN UseLocalAtomTable,
    ATOM nAtom
    );

UINT
InternalGetAtomName(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    ATOM nAtom,
    LPSTR AtomName,
    DWORD nSize
    );


ATOM
GlobalAddAtomA(
    LPCSTR lpString
    )
{
    return( InternalAddAtom( FALSE, FALSE, lpString ) );
}

ATOM
GlobalFindAtomA(
    LPCSTR lpString
    )
{
    return( InternalFindAtom( FALSE, FALSE, lpString) );
}

ATOM
GlobalDeleteAtom(
    ATOM nAtom
    )
{
    return( InternalDeleteAtom( FALSE, nAtom ) );
}

UINT
GlobalGetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( FALSE, FALSE, nAtom, lpBuffer, (DWORD)nSize ) );
}

ATOM
APIENTRY
GlobalAddAtomW(
    LPCWSTR lpString
    )
{
    return( InternalAddAtom( FALSE, TRUE, (LPSTR)lpString ) );
}

ATOM
APIENTRY
GlobalFindAtomW(
    LPCWSTR lpString
    )
{
    return( InternalFindAtom( FALSE, TRUE, (LPSTR)lpString) );
}

UINT
APIENTRY
GlobalGetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( FALSE, TRUE, nAtom, (LPSTR)lpBuffer, (DWORD)nSize ) );
}

PVOID BaseLocalAtomTable;

BOOL
APIENTRY
InitAtomTable(
    DWORD nSize
    )
{
    if (nSize < 4 || nSize > 511) {
        nSize = 37;
        }

    return RtlCreateAtomTable( nSize, &BaseLocalAtomTable ) == STATUS_SUCCESS;
}

ATOM
AddAtomA(
    LPCSTR lpString
    )
{
    return( InternalAddAtom( TRUE, FALSE, lpString ) );
}

ATOM
FindAtomA(
    LPCSTR lpString
    )
{
    return( InternalFindAtom( TRUE, FALSE, lpString ) );
}

ATOM
DeleteAtom(
    ATOM nAtom
    )
{
    return( InternalDeleteAtom( TRUE, nAtom ) );
}

UINT
GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( TRUE, FALSE, nAtom, lpBuffer, (DWORD)nSize ) );
}

ATOM
APIENTRY
AddAtomW(
    LPCWSTR lpString
    )
{
    return( InternalAddAtom( TRUE, TRUE, (LPSTR)lpString ) );
}

ATOM
APIENTRY
FindAtomW(
    LPCWSTR lpString
    )
{
    return( InternalFindAtom( TRUE, TRUE, (LPSTR)lpString ) );
}

UINT
APIENTRY
GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    )
{
    return( InternalGetAtomName( TRUE, TRUE, nAtom, (LPSTR)lpBuffer, (DWORD)nSize ) );
}

PVOID
InternalInitAtomTable( void )
{
    NTSTATUS Status;

    if (BaseLocalAtomTable == NULL) {
        Status = RtlCreateAtomTable( 0, &BaseLocalAtomTable );
        }

    return BaseLocalAtomTable;
}

ATOM
InternalAddAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING UnicodeAtomName;
    ATOM Atom;

    if ( (ULONG_PTR)AtomName <= 0xFFFF ) {
        Atom = (ATOM)PtrToShort((PVOID)AtomName);
        if (Atom >= MAXINTATOM) {
            BaseSetLastNTError( STATUS_INVALID_PARAMETER );
            return( INVALID_ATOM );
            }
        else {
            return( (ATOM)Atom );
            }
        }
    else {
        try {
            if (IsUnicodeAtomName) {
                UnicodeAtomName = &UnicodeString;
                RtlInitUnicodeString( UnicodeAtomName, (PWSTR)AtomName );
                Status = STATUS_SUCCESS;
                }
            else {
                RtlInitAnsiString( &AnsiString, AtomName );
                if (AnsiString.MaximumLength > STATIC_UNICODE_BUFFER_LENGTH) {
                    UnicodeAtomName = &UnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, TRUE );
                    }
                else {
                    UnicodeAtomName = &NtCurrentTeb()->StaticUnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, FALSE );
                    }
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            }

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            return( INVALID_ATOM );
            }
        }

    Atom = INVALID_ATOM;
    try {
        if (UseLocalAtomTable) {
            Status = RtlAddAtomToAtomTable( InternalInitAtomTable(),
                                            UnicodeAtomName->Buffer,
                                            &Atom
                                          );
            }
        else {
            Status = NtAddAtom( UnicodeAtomName->Buffer,
                                UnicodeAtomName->Length,
                                &Atom
                              );
            }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Atom = INVALID_ATOM;
            }
        }
    finally {
        if (!IsUnicodeAtomName && UnicodeAtomName == &UnicodeString) {
            RtlFreeUnicodeString( UnicodeAtomName );
            }
        }

    return( (ATOM)Atom );
}

ATOM
InternalFindAtom(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    LPCSTR AtomName
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING UnicodeAtomName;
    ATOM Atom;

    if ( (ULONG_PTR)AtomName <= 0xFFFF ) {
        Atom = (ATOM)PtrToShort((PVOID)AtomName);
        if (Atom >= MAXINTATOM) {
            BaseSetLastNTError( STATUS_INVALID_PARAMETER );
            return( INVALID_ATOM );
            }
        else {
            return( (ATOM)Atom );
            }
        }
    else {
        try {
            if (IsUnicodeAtomName) {
                UnicodeAtomName = &UnicodeString;
                RtlInitUnicodeString( UnicodeAtomName, (PWSTR)AtomName );
                Status = STATUS_SUCCESS;
                }
            else {
                RtlInitAnsiString( &AnsiString, AtomName );
                if (AnsiString.MaximumLength > STATIC_UNICODE_BUFFER_LENGTH) {
                    UnicodeAtomName = &UnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, TRUE );
                    }
                else {
                    UnicodeAtomName = &NtCurrentTeb()->StaticUnicodeString;
                    Status = RtlAnsiStringToUnicodeString( UnicodeAtomName, &AnsiString, FALSE );
                    }
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            }

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            return( INVALID_ATOM );
            }
        }

    Atom =  INVALID_ATOM;
    try {
        if (UseLocalAtomTable) {
            Status = RtlLookupAtomInAtomTable( InternalInitAtomTable(),
                                               UnicodeAtomName->Buffer,
                                               &Atom
                                             );
            }
        else {
            if (UnicodeAtomName->Length == 0) {
                SetLastError( ERROR_INVALID_NAME );
                leave;
                }

            Status = NtFindAtom( UnicodeAtomName->Buffer,
                                 UnicodeAtomName->Length,
                                 &Atom
                               );
            }
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Atom =  INVALID_ATOM;
            leave;
            }
        }
    finally {
        if (!IsUnicodeAtomName && UnicodeAtomName == &UnicodeString) {
            RtlFreeUnicodeString( UnicodeAtomName );
            }
        }


    return( (ATOM)Atom );
}

ATOM
InternalDeleteAtom(
    BOOLEAN UseLocalAtomTable,
    ATOM nAtom
    )
{
    NTSTATUS Status;

    if (nAtom >= MAXINTATOM) {
        if (UseLocalAtomTable) {
            Status = RtlDeleteAtomFromAtomTable( InternalInitAtomTable(), nAtom );
            }
        else {
            Status = NtDeleteAtom( nAtom );
            }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return( INVALID_ATOM );
            }
        }

    return( 0 );
}


UINT
InternalGetAtomName(
    BOOLEAN UseLocalAtomTable,
    BOOLEAN IsUnicodeAtomName,
    ATOM nAtom,
    LPSTR AtomName,
    DWORD nSize
    )
{
    NTSTATUS Status;
    PVOID FreeBuffer = NULL;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PWSTR UnicodeAtomName;
    ULONG AtomInfoLength, AtomNameLength;
    DWORD ReturnValue;
    PATOM_BASIC_INFORMATION AtomInfo;

    //
    // Trim nSize so that it will not overflow the 16-bit unicode string
    // maximum length field. This prevents people that call us with a >=32KB
    // query buffer from stubbing their toes when they call the Ansi version
    // of the GetAtomName API
    //

    if (!IsUnicodeAtomName && nSize > 0x7000) {
        nSize = 0x7000;
        }

    if (nSize == 0) {
        BaseSetLastNTError( STATUS_BUFFER_OVERFLOW );
        return( 0 );
        }

    if (UseLocalAtomTable) {
        if (IsUnicodeAtomName) {
            UnicodeAtomName = (PWSTR)AtomName;
            }
        else {
            FreeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          nSize * sizeof( WCHAR )
                                        );
            if (FreeBuffer == NULL) {
                BaseSetLastNTError( STATUS_NO_MEMORY );
                return( 0 );
                }

            UnicodeAtomName = (PWSTR)FreeBuffer;
            }

        AtomNameLength = nSize * sizeof( WCHAR );
        Status = RtlQueryAtomInAtomTable( InternalInitAtomTable(),
                                          nAtom,
                                          NULL,
                                          NULL,
                                          UnicodeAtomName,
                                          &AtomNameLength
                                        );
        }
    else {
        AtomInfoLength = sizeof( *AtomInfo ) + (nSize * sizeof( WCHAR ));
        FreeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                      MAKE_TAG( TMP_TAG ),
                                      AtomInfoLength
                                    );
        if (FreeBuffer == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            return( 0 );
            }
        AtomInfo = (PATOM_BASIC_INFORMATION)FreeBuffer;

        Status = NtQueryInformationAtom( nAtom,
                                         AtomBasicInformation,
                                         AtomInfo,
                                         AtomInfoLength,
                                         &AtomInfoLength
                                       );
        if (NT_SUCCESS( Status )) {
            AtomNameLength = (ULONG)AtomInfo->NameLength;
            UnicodeAtomName = AtomInfo->Name;
            }
        }

    if (NT_SUCCESS( Status )) {
        if (IsUnicodeAtomName) {
            ReturnValue = AtomNameLength / sizeof( WCHAR );
            if (UnicodeAtomName != (PWSTR)AtomName) {
                RtlMoveMemory( AtomName, UnicodeAtomName, AtomNameLength );
                }
            if (ReturnValue < nSize) {
                *((PWSTR)AtomName + ReturnValue) = UNICODE_NULL;
                }
            }
        else {
            UnicodeString.Buffer = UnicodeAtomName;
            UnicodeString.Length = (USHORT)AtomNameLength;
            UnicodeString.MaximumLength = (USHORT)(UnicodeString.Length + sizeof( UNICODE_NULL ));
            AnsiString.Buffer = AtomName;
            AnsiString.Length = 0;
            AnsiString.MaximumLength = (USHORT)nSize;
            Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
            if (NT_SUCCESS( Status )) {
                ReturnValue = AnsiString.Length;
                }
            }
        }

    if (FreeBuffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
        }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( 0 );
        }
    else {
        return( ReturnValue );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\dosdev.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dosdev.c

Abstract:

    This file contains the implementation of the DefineDosDevice API

Author:

    Steve Wood (stevewo) 13-Dec-1992

Revision History:

--*/

#include "basedll.h"

#define USHORT_MAX      ((USHORT)(-1))
#define DWORD_MAX       ((DWORD)(-1))
#define CH_COUNT_MAX    ( DWORD_MAX / sizeof( WCHAR ) ) 

BOOL
WINAPI
DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    )
{
    NTSTATUS Status;
    BOOL Result;
    ANSI_STRING AnsiString;
    PUNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
    PCWSTR lpDeviceNameW;
    PCWSTR lpTargetPathW;

    RtlInitAnsiString( &AnsiString, lpDeviceName );
    DeviceName = &NtCurrentTeb()->StaticUnicodeString;
    Status = RtlAnsiStringToUnicodeString( DeviceName, &AnsiString, FALSE );
    if (!NT_SUCCESS( Status )) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError( ERROR_FILENAME_EXCED_RANGE );
            }
        else {
            BaseSetLastNTError( Status );
            }
        return FALSE;
        }
    else {
        lpDeviceNameW = DeviceName->Buffer;
        }

    if (ARGUMENT_PRESENT( lpTargetPath )) {
        RtlInitAnsiString( &AnsiString, lpTargetPath );
        Status = RtlAnsiStringToUnicodeString( &TargetPath, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return FALSE;
            }
        else {
            lpTargetPathW = TargetPath.Buffer;
            }
        }
    else {
        lpTargetPathW = NULL;
        }

    Result = DefineDosDeviceW( dwFlags,
                               lpDeviceNameW,
                               lpTargetPathW
                             );

    if (lpTargetPathW != NULL) {
        RtlFreeUnicodeString( &TargetPath );
        }

    return Result;
}


typedef
long
(WINAPI *PBROADCASTSYSTEMMESSAGEW)( DWORD, LPDWORD, UINT, WPARAM, LPARAM );



BOOL
WINAPI
DefineDosDeviceW(
    DWORD dwFlags,
    PCWSTR lpDeviceName,
    PCWSTR lpTargetPath
    )

/*++

Routine Description:

    This function provides the capability to define new DOS device names or
    redefine or delete existing DOS device names.  DOS Device names are stored
    as symbolic links in the NT object name space.  The code that converts
    a DOS path into a corresponding NT path uses these symbolic links to
    handle mapping of DOS devices and drive letters.  This API provides a
    mechanism for a Win32 Application to modify the symbolic links used
    to implement the DOS Device namespace.  Use the QueryDosDevice API
    to query the current mapping for a DOS device name.

Arguments:

    dwFlags - Supplies additional flags that control the creation
        of the DOS device.

        dwFlags Flags:

        DDD_PUSH_POP_DEFINITION - If lpTargetPath is not NULL, then push
            the new target path in front of any existing target path.
            If lpTargetPath is NULL, then delete the existing target path
            and pop the most recent one pushed.  If nothing left to pop
            then the device name will be deleted.

        DDD_RAW_TARGET_PATH - Do not convert the lpTargetPath string from
            a DOS path to an NT path, but take it as is.

    lpDeviceName - Points to the DOS device name being defined, redefined or deleted.
        It must NOT have a trailing colon unless it is a drive letter being defined,
        redefined or deleted.

    lpTargetPath - Points to the DOS path that will implement this device.  If the
        ADD_RAW_TARGET_PATH flag is specified, then this parameter points to an
        NT path string.  If this parameter is NULL, then the device name is being
        deleted or restored if the ADD_PUSH_POP_DEFINITION flag is specified.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_DEFINEDOSDEVICE_MSG a = (PBASE_DEFINEDOSDEVICE_MSG)&m.u.DefineDosDeviceApi;
    PCSR_CAPTURE_HEADER p;
    ULONG PointerCount, n;
#endif
    UNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
    DWORD iDrive;
    DEV_BROADCAST_VOLUME dbv;
    DWORD dwRec = BSM_APPLICATIONS;
    BOOLEAN LuidDevMapsEnabled = BaseStaticServerData->LUIDDeviceMapsEnabled;

#if defined(BUILD_WOW6432)
    NTSTATUS Status;
#endif

    if (dwFlags & ~(DDD_RAW_TARGET_PATH |
                    DDD_REMOVE_DEFINITION |
                    DDD_EXACT_MATCH_ON_REMOVE |
                    DDD_NO_BROADCAST_SYSTEM |
                    DDD_LUID_BROADCAST_DRIVE
                   ) ||
        ((dwFlags & DDD_EXACT_MATCH_ON_REMOVE) &&
         (!(dwFlags & DDD_REMOVE_DEFINITION))
        ) ||
        ((!ARGUMENT_PRESENT( lpTargetPath )) &&
         (!(dwFlags & (DDD_REMOVE_DEFINITION | DDD_LUID_BROADCAST_DRIVE)))
        ) ||
        ((dwFlags & DDD_LUID_BROADCAST_DRIVE) &&
         ((!ARGUMENT_PRESENT( lpDeviceName )) ||
          ARGUMENT_PRESENT( lpTargetPath ) ||
          (dwFlags & (DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE | DDD_NO_BROADCAST_SYSTEM)) ||
          (LuidDevMapsEnabled == FALSE)
         )
        )
       ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    RtlInitUnicodeString( &DeviceName, lpDeviceName );
#if !defined(BUILD_WOW6432)
    PointerCount = 1;
    n = DeviceName.MaximumLength;
#endif
    if (ARGUMENT_PRESENT( lpTargetPath )) {
        if (!(dwFlags & DDD_RAW_TARGET_PATH)) {
            if (!RtlDosPathNameToNtPathName_U( lpTargetPath,
                                               &TargetPath,
                                               NULL,
                                               NULL
                                             )
               ) {
                BaseSetLastNTError( STATUS_OBJECT_NAME_INVALID );
                return FALSE;
                }
            }
        else {
            RtlInitUnicodeString( &TargetPath, lpTargetPath );
            }
#if !defined(BUILD_WOW6432)
        PointerCount += 1;
        n += TargetPath.MaximumLength;
#endif
        }
    else {
        RtlInitUnicodeString( &TargetPath, NULL );
        }

#if defined(BUILD_WOW6432)    
    Status = CsrBasepDefineDosDevice(dwFlags, &DeviceName, &TargetPath); 

    if (TargetPath.Length != 0 && !(dwFlags & DDD_RAW_TARGET_PATH)) {
        RtlFreeUnicodeString( &TargetPath );
    }
#else
    p = CsrAllocateCaptureBuffer( PointerCount, n );
    if (p == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    a->Flags = dwFlags;
    a->DeviceName.MaximumLength =
        (USHORT)CsrAllocateMessagePointer( p,
                                           DeviceName.MaximumLength,
                                           (PVOID *)&a->DeviceName.Buffer
                                         );
    RtlUpcaseUnicodeString( &a->DeviceName, &DeviceName, FALSE );
    if (TargetPath.Length != 0) {
        a->TargetPath.MaximumLength =
            (USHORT)CsrAllocateMessagePointer( p,
                                               TargetPath.MaximumLength,
                                               (PVOID *)&a->TargetPath.Buffer
                                             );
        RtlCopyUnicodeString( &a->TargetPath, &TargetPath );
        if (!(dwFlags & DDD_RAW_TARGET_PATH)) {
            RtlFreeUnicodeString( &TargetPath );
            }
        }
    else {
        RtlInitUnicodeString( &a->TargetPath, NULL );
        }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         p,
                         CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                              BasepDefineDosDevice
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( p );
#endif

#if defined(BUILD_WOW6432)
    if (NT_SUCCESS( Status )) {
#else
    if (NT_SUCCESS( (NTSTATUS)m.ReturnValue )) {
#endif
        HMODULE hUser32Dll;
        PBROADCASTSYSTEMMESSAGEW pBroadCastSystemMessageW;


        if (!(dwFlags & DDD_NO_BROADCAST_SYSTEM) &&
            DeviceName.Length == (2 * sizeof( WCHAR )) &&
            DeviceName.Buffer[ 1 ] == L':' &&
            (iDrive = RtlUpcaseUnicodeChar( DeviceName.Buffer[ 0 ] ) - L'A') < 26 &&
            LuidDevMapsEnabled == FALSE
           ) {
            dbv.dbcv_size       = sizeof( dbv );
            dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;
            dbv.dbcv_reserved   = 0;
            dbv.dbcv_unitmask   = (1 << iDrive);
            dbv.dbcv_flags      = DBTF_NET;

            hUser32Dll = LoadLibraryW( L"USER32.DLL" );

            if (hUser32Dll != NULL) {
                pBroadCastSystemMessageW = (PBROADCASTSYSTEMMESSAGEW)
                    GetProcAddress( hUser32Dll, "BroadcastSystemMessageW" );

                // broadcast to all windows!
                if (pBroadCastSystemMessageW != NULL) {
                    (*pBroadCastSystemMessageW)( BSF_FORCEIFHUNG |
                                                    BSF_NOHANG |
                                                    BSF_NOTIMEOUTIFNOTHUNG,
                                                 &dwRec,
                                                 WM_DEVICECHANGE,
                                                  (WPARAM)((dwFlags & DDD_REMOVE_DEFINITION) ?
                                                                    DBT_DEVICEREMOVECOMPLETE :
                                                                    DBT_DEVICEARRIVAL
                                                         ),
                                                 (LPARAM)(DEV_BROADCAST_HDR *)&dbv
                                               );
                    }
                }
                FreeLibrary (hUser32Dll);
            }

        return TRUE;
        }
    else {
#if defined(BUILD_WOW6432)
        BaseSetLastNTError( Status );
#else
        BaseSetLastNTError( (NTSTATUS)m.ReturnValue );
#endif
        return FALSE;
        }
}

NTSTATUS
IsGlobalDeviceMap(
    IN HANDLE hDirObject,
    OUT PBOOLEAN pbGlobalDeviceMap
    )

/*++

Routine Description:

    Determine whether a directory object is the global device map

Arguments:

    hDirObject - Supplies a handle to the directory object.

    pbGlobalDeviceMap - Points to a variable that will receive the result of
                        "Is this directory object the global device map?"
                        TRUE - directory object is the global device map
                        FALSE - directory object is not the global device map

Return Value:

    STATUS_SUCCESS - operations successful, did not encounter any errors,
                     the result in pbGlobalDeviceMap is only valid for this
                     status code

    STATUS_INVALID_PARAMETER - pbGlobalDeviceMap or hDirObject is NULL

    STATUS_NO_MEMORY - could not allocate memory to read the directory object's
                       name

    STATUS_INFO_LENGTH_MISMATCH - did not allocate enough memory for the
                                  directory object's name

    STATUS_UNSUCCESSFUL - an unexpected error encountered

--*/
{
    UNICODE_STRING ObjectName;
    UNICODE_STRING GlobalDeviceMapName;
    PWSTR NameBuffer = NULL;
    ULONG ReturnedLength;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if( ( pbGlobalDeviceMap == NULL ) || ( hDirObject == NULL ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    try {
        ObjectName.Length = 0;
        ObjectName.MaximumLength = 0;
        ObjectName.Buffer = NULL;
        ReturnedLength = 0;

        //
        // Determine the length of the directory object's name
        //
        Status = NtQueryObject( hDirObject,
                                ObjectNameInformation,
                                (PVOID) &ObjectName,
                                0,
                                &ReturnedLength
                              );

        if( !NT_SUCCESS( Status ) && (Status != STATUS_INFO_LENGTH_MISMATCH) ) {
            leave;
        }

        //
        // allocate memory for the directory object's name
        //
        NameBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                      MAKE_TAG( TMP_TAG ),
                                      ReturnedLength
                                    );

        if( NameBuffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            leave;
        }

        //
        // get the full name of the directory object
        //
        Status = NtQueryObject( hDirObject,
                                ObjectNameInformation,
                                NameBuffer,
                                ReturnedLength,
                                &ReturnedLength
                              );

        if( !NT_SUCCESS( Status )) {
            leave;
        }

        RtlInitUnicodeString ( &GlobalDeviceMapName, L"\\GLOBAL??" );

        //
        // Check if the directory object is the global device map
        //
        *pbGlobalDeviceMap = RtlEqualUnicodeString( &GlobalDeviceMapName,
                                                    (PUNICODE_STRING)NameBuffer,
                                                    FALSE);

        Status = STATUS_SUCCESS;
    }
    finally {
        if( NameBuffer != NULL ) {
            RtlFreeHeap( RtlProcessHeap(), 0, NameBuffer );
            NameBuffer = NULL;
        }
    }
    return ( Status );
}

DWORD
FindSymbolicLinkEntry(
    IN PWSTR lpKey,
    IN PWSTR lpBuffer,
    IN ULONG nElements,
    OUT PBOOLEAN pbResult
    )
/*++

Routine Description:

    Determine whether a symbolic link's name exists in a buffer of symbolic
    link names.

Arguments:

    lpKey - Points to the symbolic link's name to search for

    lpBuffer - contains symbolic link names, where names are separated by a
                UNICODE_NULL

    nElements - the number of name elements to search

    pbResult - Points to a variable that will receive the result of
                        "Does symbolic link name exist in the buffer?"
                        TRUE - symbolic link name found in the buffer
                        FALSE - symbolic link name not found in the buffer

Return Value:

    NO_ERROR - operations successful, did not encounter any errors,
                     the result in pbResult is only valid for this status code

    ERROR_INVALID_PARAMETER - lpKey, lpBuffer, or pbResult is a NULL pointer

--*/
{
    ULONG i = 0;

    //
    // Check for invalid parameters
    //
    if( (lpKey == NULL) || (lpBuffer == NULL) || (pbResult == NULL) ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Assume the symbolic link's name is not in the buffer
    //
    *pbResult = FALSE;

    //
    // Search for the number of names specified
    //
    while( i < nElements ) {
        if( !wcscmp( lpKey, lpBuffer ) ) {
            //
            // Found the name, can stop searching & pass back the result
            //
            *pbResult = TRUE;
            break;
        }

        i++;

        //
        // Get the next name
        //
        while (*lpBuffer++);
    }
    return( NO_ERROR );
}

DWORD
WINAPI
QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    )
{
    NTSTATUS Status;
    DWORD Result;
    ANSI_STRING AnsiString;
    PUNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
    PCWSTR lpDeviceNameW;
    PWSTR lpTargetPathW;

    if (ARGUMENT_PRESENT( lpDeviceName )) {
        RtlInitAnsiString( &AnsiString, lpDeviceName );
        DeviceName = &NtCurrentTeb()->StaticUnicodeString;
        Status = RtlAnsiStringToUnicodeString( DeviceName, &AnsiString, FALSE );
        if (!NT_SUCCESS( Status )) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError( ERROR_FILENAME_EXCED_RANGE );
                }
            else {
                BaseSetLastNTError( Status );
                }
            return FALSE;
            }
        else {
            lpDeviceNameW = DeviceName->Buffer;
            }
        }
    else {
        lpDeviceNameW = NULL;
        }

    lpTargetPathW = RtlAllocateHeap( RtlProcessHeap(),
                                     MAKE_TAG( TMP_TAG ),
                                     ucchMax * sizeof( WCHAR )
                                   );
    if (lpTargetPathW == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
        }

    Result = QueryDosDeviceW( lpDeviceNameW,
                              lpTargetPathW,
                              ucchMax
                            );

    if (Result != 0) {
        TargetPath.Buffer = lpTargetPathW;
        TargetPath.Length = (USHORT)(Result * sizeof( WCHAR ));
        TargetPath.MaximumLength = (USHORT)(TargetPath.Length + 1);

        AnsiString.Buffer = lpTargetPath;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = (USHORT)ucchMax;

        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &TargetPath,
                                               FALSE
                                             );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Result = 0;
            }
        }

    RtlFreeHeap( RtlProcessHeap(), 0, lpTargetPathW );
    return Result;
}


DWORD
WINAPI
QueryDosDeviceW(
    PCWSTR lpDeviceName,
    PWSTR lpTargetPath,
    DWORD ucchMax
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle = NULL;
    HANDLE LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan;
    UCHAR DirInfoBuffer[ 512 ];
    CLONG Count = 0;
    ULONG Context = 0;
    ULONG ReturnedLength;
    DWORD ucchName, ucchReturned;
    BOOLEAN ScanGlobalDeviceMap = FALSE;
    ULONG nElements = 0;
    BOOLEAN DuplicateEntry;
    PWSTR lpBuffer = lpTargetPath;
    DWORD Result, BufferSize;

    RtlInitUnicodeString( &UnicodeString, L"\\??" );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return 0;
    }

    ucchReturned = 0;
    try {
        if (ARGUMENT_PRESENT( lpDeviceName )) {
            RtlInitUnicodeString( &UnicodeString, lpDeviceName );
            InitializeObjectAttributes( &Attributes,
                                        &UnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        DirectoryHandle,
                                        NULL
                                      );
            Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes
                                             );
            if (NT_SUCCESS( Status )) {
                UnicodeString.Buffer = lpTargetPath;
                UnicodeString.Length = 0;

                //
                // Check for possible overflow of a DWORD
                //
                if (ucchMax > CH_COUNT_MAX) {
                    BufferSize = DWORD_MAX;
                } else {
                    BufferSize = ucchMax * sizeof( WCHAR );
                }

                //
                // Check for possible overflow of a USHORT
                //
                if (BufferSize > (DWORD)(USHORT_MAX)) {
                    UnicodeString.MaximumLength = USHORT_MAX;
                } else {
                    UnicodeString.MaximumLength = (USHORT)(BufferSize);
                }

                ReturnedLength = 0;
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &UnicodeString,
                                                    &ReturnedLength
                                                  );
                NtClose( LinkHandle );
                if (NT_SUCCESS( Status )) {
                    ucchReturned = ReturnedLength / sizeof( WCHAR );

                    if ( ( (ucchReturned == 0) ||
                           ( (ucchReturned > 0) &&
                             (lpTargetPath[ ucchReturned - 1 ] != UNICODE_NULL)
                           )
                         ) &&
                         (ucchReturned < ucchMax)
                       ) {

                        lpTargetPath[ ucchReturned ] = UNICODE_NULL;
                        ucchReturned++;
                    }

                    if (ucchReturned < ucchMax) {
                        lpTargetPath[ ucchReturned++ ] = UNICODE_NULL;
                    } else {
                        ucchReturned = 0;
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }
                }
            }
        } else {
            //
            // Dump all the symbolic links in the device map's directory
            // With LUID device maps enabled, we must search two directories
            // because the LUID device map is transparent on top of the
            // global device map
            //

            if (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) {
                BOOLEAN GlobalDeviceMap = TRUE;

                //
                // Determine if directory is the global directory
                //
                Status = IsGlobalDeviceMap( DirectoryHandle,
                                            &GlobalDeviceMap );

                //
                // if !global, set second directory search flag
                //
                if( (NT_SUCCESS( Status )) &&
                    (GlobalDeviceMap == FALSE) ) {
                    ScanGlobalDeviceMap = TRUE;
                }
            }

            nElements = 0;
            RestartScan = TRUE;
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;
            while (TRUE) {
                Status = NtQueryDirectoryObject( DirectoryHandle,
                                                 (PVOID)DirInfo,
                                                 sizeof( DirInfoBuffer ),
                                                 TRUE,
                                                 RestartScan,
                                                 &Context,
                                                 &ReturnedLength
                                               );

                //
                //  Check the status of the operation.
                //

                if (!NT_SUCCESS( Status )) {
                    if (Status == STATUS_NO_MORE_ENTRIES) {
                        Status = STATUS_SUCCESS;
                    }

                    break;
                }

                if (!wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" )) {
                    ucchName = DirInfo->Name.Length / sizeof( WCHAR );
                    if ((ucchReturned + ucchName + 1 + 1) > ucchMax) {
                        ucchReturned = 0;
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    RtlMoveMemory( lpTargetPath,
                                   DirInfo->Name.Buffer,
                                   DirInfo->Name.Length
                                 );
                    lpTargetPath += ucchName;
                    *lpTargetPath++ = UNICODE_NULL;
                    ucchReturned += ucchName + 1;
                    nElements++;
                }

                RestartScan = FALSE;
            }

            if ( (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) &&
                 (NT_SUCCESS( Status )) &&
                 ScanGlobalDeviceMap == TRUE) {
                //
                // need to perform a second scan for the
                // global device map because the first scan only
                // searches the LUID device map
                //

                //
                // close DirectoryHandle, set to NULL
                //
                if( DirectoryHandle != NULL ) {
                    NtClose( DirectoryHandle );
                    DirectoryHandle = NULL;
                }

                //
                // open the global device map
                //
                RtlInitUnicodeString( &UnicodeString, L"\\GLOBAL??" );

                InitializeObjectAttributes( &Attributes,
                                            &UnicodeString,
                                            OBJ_CASE_INSENSITIVE,
                                            NULL,
                                            NULL
                                          );
                Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                DIRECTORY_QUERY,
                                                &Attributes
                                              );

                if (!NT_SUCCESS( Status )) {
                    DirectoryHandle = NULL;
                    leave;
                }

                //
                // perform the second scan
                // scan the global device map
                //
                RestartScan = TRUE;
                while (TRUE) {
                    Status = NtQueryDirectoryObject( DirectoryHandle,
                                                     (PVOID)DirInfo,
                                                     sizeof( DirInfoBuffer ),
                                                     TRUE,
                                                     RestartScan,
                                                     &Context,
                                                     &ReturnedLength
                                                   );

                    //
                    //  Check the status of the operation.
                    //

                    if (!NT_SUCCESS( Status )) {
                        if (Status == STATUS_NO_MORE_ENTRIES) {
                            Status = STATUS_SUCCESS;
                        }

                        break;
                    }

                    if (!wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" )) {
                        Result = FindSymbolicLinkEntry(
                                                DirInfo->Name.Buffer,
                                                lpBuffer,
                                                nElements,
                                                &DuplicateEntry);

                        if ((Result == NO_ERROR) && (DuplicateEntry == FALSE)) {
                            ucchName = DirInfo->Name.Length / sizeof( WCHAR );
                            if ((ucchReturned + ucchName + 1 + 1) > ucchMax) {
                                ucchReturned = 0;
                                Status = STATUS_BUFFER_TOO_SMALL;
                                break;
                            }
                            RtlMoveMemory( lpTargetPath,
                                           DirInfo->Name.Buffer,
                                           DirInfo->Name.Length
                                         );
                            lpTargetPath += ucchName;
                            *lpTargetPath++ = UNICODE_NULL;
                            ucchReturned += ucchName + 1;
                        }
                    }

                    RestartScan = FALSE;
                }

            }

            if (NT_SUCCESS( Status )) {
                *lpTargetPath++ = UNICODE_NULL;
                ucchReturned++;
            }
        }
    } finally {
        if( DirectoryHandle != NULL ) {
            NtClose( DirectoryHandle );
        }
    }

    if (!NT_SUCCESS( Status )) {
        ucchReturned = 0;
        BaseSetLastNTError( Status );
    }

    return ucchReturned;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\dllini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllprof.c

Abstract:

    This module contains the client side of the Win32 Initialization
    File APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include <limits.h>

#if DBG
BOOLEAN BaseDllDumpIniCalls;
#endif

PINIFILE_MAPPING BaseDllIniFileMapping;
PINIFILE_CACHE BaseDllIniFileCache;
UNICODE_STRING BaseDllIniUserKeyPath;
UNICODE_STRING BaseDllIniSoftwareKeyPath;
ULONG LockFileKey = 1;

struct {
    PINIFILE_MAPPING_TARGET MappingTarget;
    ULONG MappingFlags;
    BOOLEAN WriteAccess;
    UNICODE_STRING RegistryPath;
    HANDLE RegistryKey;
    CRITICAL_SECTION Lock;
} BaseDllRegistryCache;


NTSTATUS
BaseDllInitializeIniFileMappings(
                                PBASE_STATIC_SERVER_DATA StaticServerData
                                )
{

    BaseDllIniFileMapping = (PINIFILE_MAPPING)StaticServerData->IniFileMapping;
    BaseDllIniFileCache = NULL;

#if DBG

    BaseDllDumpIniCalls = FALSE;

#endif

    // BaseDllDumpIniCalls = TRUE;
    RtlInitUnicodeString( &BaseDllIniUserKeyPath, NULL );
    RtlInitUnicodeString( &BaseDllIniSoftwareKeyPath, L"\\Registry\\Machine\\Software" );

    RtlZeroMemory( &BaseDllRegistryCache, sizeof( BaseDllRegistryCache ) );
    BaseDllRegistryCache.RegistryKey = INVALID_HANDLE_VALUE;
    InitializeCriticalSection(&BaseDllRegistryCache.Lock);
    return STATUS_SUCCESS;
}

NTSTATUS
BaseDllReadWriteIniFile(
                       IN BOOLEAN Unicode,
                       IN BOOLEAN WriteOperation,
                       IN BOOLEAN SectionOperation,
                       IN PVOID FileName OPTIONAL,
                       IN PVOID ApplicationName OPTIONAL,
                       IN PVOID VariableName OPTIONAL,
                       IN OUT PVOID VariableValue OPTIONAL,
                       IN OUT PULONG VariableValueLength OPTIONAL
                       );

DWORD
WINAPI
GetPrivateProfileSectionNamesA(
                              LPSTR lpszReturnBuffer,
                              DWORD nSize,
                              LPCSTR lpFileName
                              )
{
    return GetPrivateProfileStringA( NULL,
                                     NULL,
                                     NULL,
                                     lpszReturnBuffer,
                                     nSize,
                                     lpFileName
                                   );
}

DWORD
WINAPI
GetPrivateProfileSectionNamesW(
                              LPWSTR lpszReturnBuffer,
                              DWORD nSize,
                              LPCWSTR lpFileName
                              )
{
    return GetPrivateProfileStringW( NULL,
                                     NULL,
                                     NULL,
                                     lpszReturnBuffer,
                                     nSize,
                                     lpFileName
                                   );
}

#define NibbleToChar(x) (N2C[x])
#define CharToNibble(x) ((x)>='0'&&(x)<='9' ? (x)-'0' : ((10+(x)-'A')&0x000f))
char N2C[] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
};

BOOL
WINAPI
GetPrivateProfileStructA(
                        LPCSTR lpszSection,
                        LPCSTR lpszKey,
                        LPVOID lpStruct,
                        UINT uSizeStruct,
                        LPCSTR szFile
                        )
{
    UCHAR szBuf[256];
    LPSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BYTE checksum;
    BOOL Result;

    if ((INT_MAX - 5) < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    nLen = uSizeStruct*2 + 10;

    if (nLen > sizeof( szBuf )) {
        lpFreeBuffer = (LPSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (LPSTR)szBuf;
    }

    Result = FALSE;
    nLen = GetPrivateProfileStringA( lpszSection,
                                     lpszKey,
                                     NULL,
                                     lpBuf,
                                     nLen,
                                     szFile
                                   );

    if (nLen == uSizeStruct*2+2) {
        /* Room for the one byte check sum */
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            BYTE cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                } else {
                    SetLastError( ERROR_INVALID_DATA );
                }

                break;
            }

            checksum += bStruct;
            *((LPBYTE)lpStruct)++ = bStruct;
        }
    } else {
        SetLastError( ERROR_BAD_LENGTH );
    }

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
GetPrivateProfileStructW(
                        LPCWSTR lpszSection,
                        LPCWSTR lpszKey,
                        LPVOID   lpStruct,
                        UINT     uSizeStruct,
                        LPCWSTR szFile
                        )
{
    WCHAR szBuf[256];
    PWSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BYTE checksum;
    BOOL Result;

    nLen = uSizeStruct*2 + 10;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ((nLen * sizeof( WCHAR )) > sizeof( szBuf )) {
        lpFreeBuffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen * sizeof( WCHAR )
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (PWSTR)szBuf;
    }

    Result = FALSE;
    nLen = GetPrivateProfileStringW( lpszSection,
                                     lpszKey,
                                     NULL,
                                     lpBuf,
                                     nLen,
                                     szFile
                                   );

    if (nLen == uSizeStruct*2+2) {
        /* Room for the one byte check sum */
        uSizeStruct+=1;
        checksum = 0;
        for (lpBufTemp=lpBuf; uSizeStruct!=0; --uSizeStruct) {
            BYTE bStruct;
            WCHAR cTemp;

            cTemp = *lpBufTemp++;
            bStruct = (BYTE)CharToNibble(cTemp);
            cTemp = *lpBufTemp++;
            bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

            if (uSizeStruct == 1) {
                if (checksum == bStruct) {
                    Result = TRUE;
                } else {
                    SetLastError( ERROR_INVALID_DATA );
                }

                break;
            }

            checksum += bStruct;
            *((LPBYTE)lpStruct)++ = bStruct;
        }
    } else {
        SetLastError( ERROR_BAD_LENGTH );
    }

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
WritePrivateProfileStructA(
                          LPCSTR lpszSection,
                          LPCSTR lpszKey,
                          LPVOID   lpStruct,
                          UINT     uSizeStruct,
                          LPCSTR szFile
                          )
{
    UCHAR szBuf[256];
    LPSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BOOL Result;
    BYTE checksum;

    if (lpStruct == NULL) {
        return WritePrivateProfileStringA( lpszSection,
                                           lpszKey,
                                           NULL,
                                           szFile
                                         );
    }


    nLen = uSizeStruct*2 + 3;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (nLen > sizeof( szBuf )) {
        lpFreeBuffer = (LPSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (LPSTR)szBuf;
    }

    checksum = 0;
    for (lpBufTemp=lpBuf; uSizeStruct != 0; --uSizeStruct) {
        BYTE bStruct;

        bStruct = *((LPBYTE)lpStruct)++;
        checksum = checksum + bStruct;

        *lpBufTemp++ = NibbleToChar((bStruct>>4)&0x000f);
        *lpBufTemp++ = NibbleToChar(bStruct&0x000f);
    }
    *lpBufTemp++ = NibbleToChar((checksum>>4)&0x000f);
    *lpBufTemp++ = NibbleToChar(checksum&0x000f);
    *lpBufTemp = '\0';

    Result = WritePrivateProfileStringA( lpszSection,
                                         lpszKey,
                                         lpBuf,
                                         szFile
                                       );

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

BOOL
WINAPI
WritePrivateProfileStructW(
                          LPCWSTR lpszSection,
                          LPCWSTR lpszKey,
                          LPVOID   lpStruct,
                          UINT     uSizeStruct,
                          LPCWSTR szFile
                          )
{
    WCHAR szBuf[256];
    PWSTR lpBuf, lpBufTemp, lpFreeBuffer;
    UINT nLen;
    BOOL Result;
    BYTE checksum;

    if (lpStruct == NULL) {
        return WritePrivateProfileStringW( lpszSection,
                                           lpszKey,
                                           NULL,
                                           szFile
                                         );
    }


    nLen = uSizeStruct*2 + 3;
    if (nLen < uSizeStruct) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ((nLen * sizeof( WCHAR )) > sizeof( szBuf )) {
        lpFreeBuffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(),
                                               0,
                                               nLen * sizeof( WCHAR )
                                             );
        if (!lpFreeBuffer) {
            return FALSE;
        }
        lpBuf = lpFreeBuffer;
    } else {
        lpFreeBuffer = NULL;
        lpBuf = (PWSTR)szBuf;
    }

    checksum = 0;
    for (lpBufTemp=lpBuf; uSizeStruct != 0; --uSizeStruct) {
        BYTE bStruct;

        bStruct = *((LPBYTE)lpStruct)++;
        checksum = checksum + bStruct;

        *lpBufTemp++ = (WCHAR)NibbleToChar((bStruct>>4)&0x000f);
        *lpBufTemp++ = (WCHAR)NibbleToChar(bStruct&0x000f);
    }
    *lpBufTemp++ = (WCHAR)NibbleToChar((checksum>>4)&0x000f);
    *lpBufTemp++ = (WCHAR)NibbleToChar(checksum&0x000f);
    *lpBufTemp = L'\0';

    Result = WritePrivateProfileStringW( lpszSection,
                                         lpszKey,
                                         lpBuf,
                                         szFile
                                       );

    if (lpFreeBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, lpFreeBuffer );
    }

    return Result;
}

UINT
GetProfileIntA(
              LPCSTR lpAppName,
              LPCSTR lpKeyName,
              INT nDefault
              )
{
    return( GetPrivateProfileIntA( lpAppName,
                                   lpKeyName,
                                   nDefault,
                                   NULL
                                 )
          );
}

DWORD
GetProfileStringA(
                 LPCSTR lpAppName,
                 LPCSTR lpKeyName,
                 LPCSTR lpDefault,
                 LPSTR lpReturnedString,
                 DWORD nSize
                 )
{
    return( GetPrivateProfileStringA( lpAppName,
                                      lpKeyName,
                                      lpDefault,
                                      lpReturnedString,
                                      nSize,
                                      NULL
                                    )
          );
}

BOOL
WriteProfileStringA(
                   LPCSTR lpAppName,
                   LPCSTR lpKeyName,
                   LPCSTR lpString
                   )
{
    return( WritePrivateProfileStringA( lpAppName,
                                        lpKeyName,
                                        lpString,
                                        NULL
                                      )
          );
}

DWORD
GetProfileSectionA(
                  LPCSTR lpAppName,
                  LPSTR lpReturnedString,
                  DWORD nSize
                  )
{
    return( GetPrivateProfileSectionA( lpAppName,
                                       lpReturnedString,
                                       nSize,
                                       NULL
                                     )
          );
}

BOOL
WriteProfileSectionA(
                    LPCSTR lpAppName,
                    LPCSTR lpString
                    )
{
    return( WritePrivateProfileSectionA( lpAppName,
                                         lpString,
                                         NULL
                                       )
          );
}

UINT
APIENTRY
GetProfileIntW(
              LPCWSTR lpAppName,
              LPCWSTR lpKeyName,
              INT nDefault
              )
{
    return( GetPrivateProfileIntW( lpAppName,
                                   lpKeyName,
                                   nDefault,
                                   NULL
                                 )
          );
}

DWORD
APIENTRY
GetProfileStringW(
                 LPCWSTR lpAppName,
                 LPCWSTR lpKeyName,
                 LPCWSTR lpDefault,
                 LPWSTR lpReturnedString,
                 DWORD nSize
                 )
{
    return( GetPrivateProfileStringW( lpAppName,
                                      lpKeyName,
                                      lpDefault,
                                      lpReturnedString,
                                      nSize,
                                      NULL
                                    )
          );
}

BOOL
APIENTRY
WriteProfileStringW(
                   LPCWSTR lpAppName,
                   LPCWSTR lpKeyName,
                   LPCWSTR lpString
                   )
{
    return( WritePrivateProfileStringW( lpAppName,
                                        lpKeyName,
                                        lpString,
                                        NULL
                                      )
          );
}

DWORD
APIENTRY
GetProfileSectionW(
                  LPCWSTR lpAppName,
                  LPWSTR lpReturnedString,
                  DWORD nSize
                  )
{
    return( GetPrivateProfileSectionW( lpAppName,
                                       lpReturnedString,
                                       nSize,
                                       NULL
                                     )
          );
}

BOOL
APIENTRY
WriteProfileSectionW(
                    LPCWSTR lpAppName,
                    LPCWSTR lpString
                    )
{
    return( WritePrivateProfileSectionW( lpAppName,
                                         lpString,
                                         NULL
                                       )
          );
}


UINT
GetPrivateProfileIntA(
                     LPCSTR lpAppName,
                     LPCSTR lpKeyName,
                     INT nDefault,
                     LPCSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    UCHAR ValueBuffer[ 256 ];
    ULONG cb;

    ReturnValue = 0;
    cb = GetPrivateProfileStringA( lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ),
                                   lpFileName
                                 );
    if (cb == 0) {
        ReturnValue = nDefault;
    } else {
        Status = RtlCharToInteger( ValueBuffer, 0, &ReturnValue );
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
        } else {
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}

DWORD
GetPrivateProfileStringA(
                        LPCSTR lpAppName,
                        LPCSTR lpKeyName,
                        LPCSTR lpDefault,
                        LPSTR lpReturnedString,
                        DWORD nSize,
                        LPCSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = "";
    }

    n = nSize;
    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = '\0';
                //
                // GetPrivateProfileString(): don't leave 1st byte of double byte char alone
                //
                lpReturnedString[ n ] = '\0';
                if ( n > 0 ) {
                    LPSTR pc = lpReturnedString;
                    LPSTR pcEnd = lpReturnedString + n - 1;
                    //
                    // if the last character is the 1st byte of
                    // double byte character, erase it.
                    //
                    while ( pc <= pcEnd ) {
                        pc += IsDBCSLeadByte( *pc ) ? 2 : 1;
                    }
                    if ( (pc - pcEnd ) == 2 ) {
                        *pcEnd = '\0';
                    }
                }

                return ( n );
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = strlen( lpDefault );
        while (n > 0 && lpDefault[n-1] == ' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        strncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = '\0';
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = '\0';
    }

    return( n );
}


BOOL
WritePrivateProfileStringA(
                          LPCSTR lpAppName,
                          LPCSTR lpKeyName,
                          LPCSTR lpString,
                          LPCSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}

DWORD
GetPrivateProfileSectionA(
                         LPCSTR lpAppName,
                         LPSTR lpReturnedString,
                         DWORD nSize,
                         LPCSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = '\0';
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = '\0';
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = '\0';
    }

    return( n );
}

BOOL
WritePrivateProfileSectionA(
                           LPCSTR lpAppName,
                           LPCSTR lpString,
                           LPCSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( FALSE,    // Unicode,
                                      TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      RTL_CONST_CAST(PVOID)(lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}


UINT
APIENTRY
GetPrivateProfileIntW(
                     LPCWSTR lpAppName,
                     LPCWSTR lpKeyName,
                     INT nDefault,
                     LPCWSTR lpFileName
                     )
{
    NTSTATUS Status;
    ULONG ReturnValue;
    WCHAR ValueBuffer[ 256 ];
    UNICODE_STRING Value;
    ANSI_STRING AnsiString;
    ULONG cb;

    ReturnValue = 0;
    cb = GetPrivateProfileStringW( lpAppName,
                                   lpKeyName,
                                   NULL,
                                   ValueBuffer,
                                   sizeof( ValueBuffer ) / sizeof( WCHAR ),
                                   lpFileName
                                 );
    if (cb == 0) {
        ReturnValue = nDefault;
    } else {
        Value.Buffer = ValueBuffer;
        Value.Length = (USHORT)(cb * sizeof( WCHAR ));
        Value.MaximumLength = (USHORT)((cb + 1) * sizeof( WCHAR ));
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &Value,
                                               TRUE
                                             );
        if (NT_SUCCESS( Status )) {
            Status = RtlCharToInteger( AnsiString.Buffer, 0, &ReturnValue );
            RtlFreeAnsiString( &AnsiString );
        }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
        } else {
            SetLastError( NO_ERROR );
        }
    }

    return ReturnValue;
}

DWORD
APIENTRY
GetPrivateProfileStringW(
                        LPCWSTR lpAppName,
                        LPCWSTR lpKeyName,
                        LPCWSTR lpDefault,
                        LPWSTR lpReturnedString,
                        DWORD nSize,
                        LPCWSTR lpFileName
                        )
{
    NTSTATUS Status;
    ULONG n;

    if (lpDefault == NULL) {
        lpDefault = L"";
    }

    n = nSize;
    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      FALSE,    // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (!lpAppName || !lpKeyName) {
            if (nSize >= 2) {
                n = nSize - 2;
                lpReturnedString[ n+1 ] = UNICODE_NULL;
            } else {
                n = 0;
            }
        } else {
            if (nSize >= 1) {
                n = nSize - 1;
            } else {
                n = 0;
            }
        }
    } else {
        n = wcslen( lpDefault );
        while (n > 0 && lpDefault[n-1] == L' ') {
            n -= 1;
        }

        if (n >= nSize) {
            n = nSize;
        }

        wcsncpy( lpReturnedString, lpDefault, n );
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}

BOOL
APIENTRY
WritePrivateProfileStringW(
                          LPCWSTR lpAppName,
                          LPCWSTR lpKeyName,
                          LPCWSTR lpString,
                          LPCWSTR lpFileName
                          )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      TRUE,     // WriteOperation
                                      FALSE,    // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName),
                                      RTL_CONST_CAST(PVOID)(lpKeyName == NULL ? NULL : lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}

DWORD
APIENTRY
GetPrivateProfileSectionW(
                         LPCWSTR lpAppName,
                         LPWSTR lpReturnedString,
                         DWORD nSize,
                         LPCWSTR lpFileName
                         )
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      FALSE,    // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      lpReturnedString,
                                      &n
                                    );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (NT_SUCCESS( Status )) {
            SetLastError( NO_ERROR );
            n--;
        } else
            if (nSize >= 2) {
            n = nSize - 2;
            lpReturnedString[ n+1 ] = UNICODE_NULL;
        } else {
            n = 0;
        }
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        n = 0;
    }

    if (n < nSize) {
        lpReturnedString[ n ] = UNICODE_NULL;
    } else
        if (nSize > 0) {
        lpReturnedString[ nSize-1 ] = UNICODE_NULL;
    }

    return( n );
}


BOOL
APIENTRY
WritePrivateProfileSectionW(
                           LPCWSTR lpAppName,
                           LPCWSTR lpString,
                           LPCWSTR lpFileName
                           )
{
    NTSTATUS Status;

    Status = BaseDllReadWriteIniFile( TRUE,     // Unicode,
                                      TRUE,     // WriteOperation
                                      TRUE,     // SectionOperation
                                      RTL_CONST_CAST(PVOID)(lpFileName),
                                      RTL_CONST_CAST(PVOID)(lpAppName),
                                      NULL,
                                      RTL_CONST_CAST(PVOID)(lpString),
                                      NULL
                                    );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        if (Status == STATUS_INVALID_IMAGE_FORMAT) {
            SetLastError( ERROR_INVALID_DATA );
        } else {
            BaseSetLastNTError( Status );
        }
        return( FALSE );
    }
}


VOID
BaseDllFlushRegistryCache( VOID );

BOOL
CloseProfileUserMapping( VOID )
{
    BaseDllFlushRegistryCache();
    if (BaseDllIniUserKeyPath.Buffer != NULL) {
        RtlFreeUnicodeString( &BaseDllIniUserKeyPath );
        RtlInitUnicodeString( &BaseDllIniUserKeyPath, NULL );
        return TRUE;
    } else {
        return TRUE;
    }
}


BOOL
OpenProfileUserMapping( VOID )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Key;

    BaseDllFlushRegistryCache();
    if (BaseDllIniUserKeyPath.Length == 0) {
        Status = RtlFormatCurrentUserKeyPath( &BaseDllIniUserKeyPath );
        if (NT_SUCCESS( Status )) {
            InitializeObjectAttributes( &ObjectAttributes,
                                        &BaseDllIniUserKeyPath,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );
            Status = NtOpenKey( &Key,
                                GENERIC_READ,
                                &ObjectAttributes
                              );

            if (NT_SUCCESS( Status )) {
                NtClose( Key );
            } else {
                RtlFreeUnicodeString( &BaseDllIniUserKeyPath );
                RtlInitUnicodeString( &BaseDllIniUserKeyPath, NULL );
            }
        }

        if (!NT_SUCCESS( Status )) {
            if (!RtlCreateUnicodeString( &BaseDllIniUserKeyPath, L"\\REGISTRY\\USER\\.DEFAULT" )) {
                return FALSE;
            }
        }
    }

    return TRUE;
}

#if DBG
char *xOperationNames[] = {
    "FlushProfiles",
    "ReadKeyValue",
    "WriteKeyValue",
    "DeleteKey",
    "ReadKeyNames",
    "ReadSectionNames",
    "ReadSection",
    "WriteSection",
    "DeleteSection",
    "RefreshIniFileMapping"
};
#endif

NTSTATUS
BaseDllCaptureIniFileParameters(
                               BOOLEAN UnicodeParameters,
                               INIFILE_OPERATION Operation,
                               BOOLEAN WriteOperation,
                               BOOLEAN MultiValueStrings,
                               PVOID FileName,
                               PVOID ApplicationName,
                               PVOID VariableName,
                               PVOID VariableValue,
                               PULONG ResultMaxChars OPTIONAL,
                               PINIFILE_PARAMETERS *ReturnedParameterBlock
                               );


NTSTATUS
BaseDllReadWriteIniFileViaMapping(
                                 IN PINIFILE_PARAMETERS a
                                 );

NTSTATUS
BaseDllReadWriteIniFileOnDisk(
                             IN PINIFILE_PARAMETERS a
                             );

NTSTATUS
BaseDllOpenIniFileOnDisk(
                        IN PINIFILE_PARAMETERS a
                        );

NTSTATUS
BaseDllCloseIniFileOnDisk(
                         IN PINIFILE_PARAMETERS a
                         );

NTSTATUS
BaseDllAppendNullToResultBuffer(
                               IN PINIFILE_PARAMETERS a
                               );

NTSTATUS
BaseDllAppendStringToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOLEAN IncludeNull
                                 );

NTSTATUS
BaseDllAppendBufferToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PBYTE Buffer OPTIONAL,
                                 IN PWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOLEAN IncludeNull
                                 );

NTSTATUS
BaseDllReadWriteIniFile(
                       IN BOOLEAN Unicode,
                       IN BOOLEAN WriteOperation,
                       IN BOOLEAN SectionOperation,
                       IN PVOID FileName OPTIONAL,
                       IN PVOID ApplicationName OPTIONAL,
                       IN PVOID VariableName OPTIONAL,
                       IN OUT PVOID VariableValue OPTIONAL,
                       IN OUT PULONG VariableValueLength OPTIONAL
                       )
{
    BOOLEAN MultiValueStrings;
    INIFILE_OPERATION Operation;
    PINIFILE_PARAMETERS a;
    NTSTATUS Status;

    if (SectionOperation) {
        VariableName = NULL;
    }

    MultiValueStrings = FALSE;
    if (WriteOperation) {
        if (ARGUMENT_PRESENT( ApplicationName )) {
            if (ARGUMENT_PRESENT( VariableName )) {
                if (ARGUMENT_PRESENT( VariableValue )) {
                    Operation = WriteKeyValue;
                } else {
                    Operation = DeleteKey;
                }
            } else {
                if (ARGUMENT_PRESENT( VariableValue )) {
                    Operation = WriteSection;
                    MultiValueStrings = TRUE;
                } else {
                    Operation = DeleteSection;
                }
            }
        } else {
#if DBG
            if (ARGUMENT_PRESENT( VariableName ) ||
                ARGUMENT_PRESENT( VariableValue )
               ) {
                return STATUS_INVALID_PARAMETER;
            } else
#endif
                if (ARGUMENT_PRESENT( FileName )) {
                Operation = RefreshIniFileMapping;
            } else {
                Operation = FlushProfiles;
            }
        }
    } else {
        if (ARGUMENT_PRESENT( ApplicationName )) {
            if (!ARGUMENT_PRESENT( VariableValue )) {
                return STATUS_INVALID_PARAMETER;
            } else
                if (ARGUMENT_PRESENT( VariableName )) {
                Operation = ReadKeyValue;
            } else
                if (SectionOperation) {
                Operation = ReadSection;
                MultiValueStrings = TRUE;
            } else {
                Operation = ReadKeyNames;
                MultiValueStrings = TRUE;
            }
        } else
            if (SectionOperation || !ARGUMENT_PRESENT( VariableValue )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            VariableName = NULL;
            Operation = ReadSectionNames;
            MultiValueStrings = TRUE;
        }
    }

#if DBG
    if (WriteOperation) {
        ASSERT( Operation == WriteKeyValue || Operation == WriteSection || Operation == DeleteKey || Operation == DeleteSection || Operation == FlushProfiles || Operation == RefreshIniFileMapping );
    } else {
        ASSERT( Operation == ReadKeyValue || Operation == ReadKeyNames || Operation == ReadSectionNames || Operation == ReadSection );
    }
#endif

    Status = BaseDllCaptureIniFileParameters( Unicode,
                                              Operation,
                                              WriteOperation,
                                              MultiValueStrings,
                                              FileName,
                                              ApplicationName,
                                              VariableName,
                                              VariableValue,
                                              VariableValueLength,
                                              &a
                                            );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

#if DBG
    if (BaseDllDumpIniCalls) {
        DbgPrint( "BASEDLL: called with profile operation\n" );
        DbgPrint( "    Operation: %s  Write: %u\n", xOperationNames[ a->Operation ], a->WriteOperation );
        DbgPrint( "    BaseFileName: %wZ\n", &a->BaseFileName );
        DbgPrint( "    IniFileNameMapping: %08x\n", a->IniFileNameMapping );
        DbgPrint( "    FileName: %wZ\n", &a->FileName );
        DbgPrint( "    NtFileName: %wZ\n", &a->NtFileName );
        DbgPrint( "    ApplicationName: %wZ (%Z)\n", &a->ApplicationNameU, &a->ApplicationName );
        DbgPrint( "    VariableName: %wZ (%Z)\n", &a->VariableNameU, &a->VariableName );
        if (a->WriteOperation) {
            DbgPrint( "    VariableValue: %ws (%s)\n", a->ValueBufferU, a->ValueBuffer );
        }
    }
#endif // DBG

    if (a->Operation == RefreshIniFileMapping) {

#if defined(BUILD_WOW6432)
        Status = CsrBasepRefreshIniFileMapping(&a->BaseFileName);
#else
        BASE_API_MSG m;
        PBASE_REFRESHINIFILEMAPPING_MSG ap = &m.u.RefreshIniFileMapping;
        PCSR_CAPTURE_HEADER CaptureBuffer;

        CaptureBuffer = NULL;
        if (a->BaseFileName.Length > (MAX_PATH * sizeof( WCHAR ))) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      a->BaseFileName.MaximumLength
                                                    );
            if (CaptureBuffer == NULL) {
                Status = STATUS_NO_MEMORY;
            } else {
                CsrCaptureMessageString( CaptureBuffer,
                                         (PCHAR)a->BaseFileName.Buffer,
                                         a->BaseFileName.Length,
                                         a->BaseFileName.MaximumLength,
                                         (PSTRING)&ap->IniFileName
                                       );
                Status = STATUS_SUCCESS;
            }
        }

        if (NT_SUCCESS( Status )) {
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 CaptureBuffer,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepRefreshIniFileMapping
                                                    ),
                                 sizeof( *ap )
                               );

            Status = (NTSTATUS)m.ReturnValue;
        }

        CsrFreeCaptureBuffer( CaptureBuffer );
#endif
    } else
        if (a->IniFileNameMapping != NULL) {
        Status = BaseDllReadWriteIniFileViaMapping( a );
#if DBG
        if (BaseDllDumpIniCalls) {
            if (NT_SUCCESS( Status ) ||
                Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_MORE_PROCESSING_REQUIRED
               ) {
                if (!a->WriteOperation) {
                    if (a->Unicode) {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from registry - '%.*ws' (%u)\n", a->ResultChars, a->ResultBufferU, a->ResultChars );
                        } else {
                            PWSTR s;

                            DbgPrint( "BASEDLL: Return multi-value from registry: (%u)\n", a->ResultChars );
                            s = a->ResultBufferU;
                            s[ a->ResultChars ] = UNICODE_NULL;
                            while (*s) {
                                DbgPrint( "    %ws\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    } else {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from registry - '%.*s' (%u)\n", a->ResultChars, a->ResultBuffer, a->ResultChars );
                        } else {
                            PBYTE s;

                            DbgPrint( "BASEDLL: Return multi-value from registry: (%u)\n", a->ResultChars );
                            s = a->ResultBuffer;
                            s[ a->ResultChars ] = '\0';
                            while (*s) {
                                DbgPrint( "    (%s)\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    }
                } else {
                    DbgPrint( "BASEDLL: Returning success for above write operation\n" );
                }

                if (Status == STATUS_BUFFER_OVERFLOW) {
                    DbgPrint( "    *** above result partial as buffer too small.\n" );
                } else
                    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                    DbgPrint( "    *** above result partial and will now look on disk.\n" );
                }
            } else {
                DbgPrint( "BASEDLL: Profile operation %s failed: Status == %x\n", xOperationNames[ a->Operation ], Status );
            }

            if (a->ValueBufferAllocated) {
                if (a->Unicode) {
                    PWSTR s;

                    DbgPrint( "BASEDLL: Remaining Variables to write to disk:\n" );
                    s = a->ValueBufferU;
                    while (*s) {
                        DbgPrint( "    %ws\n", s );
                        while (*s++) {
                        }
                    }
                } else {
                    PBYTE s;

                    DbgPrint( "BASEDLL: Remaining Variables to write to disk:\n" );
                    s = a->ValueBuffer;
                    while (*s) {
                        DbgPrint( "    (%s)\n", s );
                        while (*s++) {
                        }
                    }

                }
            }
        }
#endif // DBG
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        Status = BaseDllReadWriteIniFileOnDisk( a );
#if DBG
        if (BaseDllDumpIniCalls) {
            if (NT_SUCCESS( Status ) ||
                Status == STATUS_BUFFER_OVERFLOW
               ) {
                if (!a->WriteOperation) {
                    if (a->Unicode) {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from disk - '%.*ws' (%u)\n", a->ResultChars, a->ResultBufferU, a->ResultChars );
                        } else {
                            PWSTR s;

                            DbgPrint( "BASEDLL: Return multi-value from disk: (%u)\n", a->ResultChars );
                            s = a->ResultBufferU;
                            s[ a->ResultChars ] = UNICODE_NULL;
                            while (*s) {
                                DbgPrint( "    %ws\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    } else {
                        if (a->Operation == ReadKeyValue) {
                            DbgPrint( "BASEDLL: Returning value from disk - '%.*s' (%u)\n", a->ResultChars, a->ResultBuffer, a->ResultChars );
                        } else {
                            PBYTE s;

                            DbgPrint( "BASEDLL: Return multi-value from disk: (%u)\n", a->ResultChars );
                            s = a->ResultBuffer;
                            s[ a->ResultChars ] = '\0';
                            while (*s) {
                                DbgPrint( "    (%s)\n", s );
                                while (*s++) {
                                }
                            }
                        }
                    }

                    if (Status == STATUS_BUFFER_OVERFLOW) {
                        DbgPrint( "    *** above result partial as buffer too small.\n" );
                    }
                } else {
                    DbgPrint( "BASEDLL: Returning success for above write operation.\n" );
                }
            } else {
                DbgPrint( "BASEDLL: Profile operation %s failed: Status == %x\n", xOperationNames[ a->Operation ], Status );
            }
        }
#endif // DBG
    }

    if (BaseRunningInServerProcess || a->Operation == FlushProfiles) {
        BaseDllFlushRegistryCache();
    }

    if (NT_SUCCESS( Status )) {
        if (a->Operation == ReadSectionNames ||
            a->Operation == ReadKeyNames ||
            a->Operation == ReadSection
           ) {
            BaseDllAppendNullToResultBuffer( a );
        }
    }

    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (a->WriteOperation) {
            BaseIniFileUpdateCount++;
        } else
            if (ARGUMENT_PRESENT( VariableValueLength )) {
            *VariableValueLength = a->ResultChars;
        }
    }

    if (a->ValueBufferAllocated) {
        if (a->Unicode) {
            RtlFreeHeap( RtlProcessHeap(), 0, a->ValueBufferU );
        } else {
            RtlFreeHeap( RtlProcessHeap(), 0, a->ValueBuffer );
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, a );

    return Status;
}


ULONG
BaseDllIniFileNameLength(
                        IN BOOLEAN Unicode,
                        IN PVOID *Name
                        );

NTSTATUS
BaseDllFindIniFileNameMapping(
                             IN PUNICODE_STRING FileName,
                             IN PUNICODE_STRING BaseFileName,
                             OUT PINIFILE_MAPPING_FILENAME *ReturnedFileNameMapping
                             );

BOOLEAN
BaseDllGetApplicationName(
                         IN PINIFILE_PARAMETERS a,
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         );

BOOLEAN
BaseDllGetVariableName(
                      IN PINIFILE_PARAMETERS a,
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      );

BOOLEAN
BaseDllGetVariableValue(
                       IN PINIFILE_PARAMETERS a,
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT PWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       );

NTSTATUS
BaseDllCaptureIniFileParameters(
                               BOOLEAN Unicode,
                               INIFILE_OPERATION Operation,
                               BOOLEAN WriteOperation,
                               BOOLEAN MultiValueStrings,
                               PVOID FileName OPTIONAL,
                               PVOID ApplicationName OPTIONAL,
                               PVOID VariableName OPTIONAL,
                               PVOID VariableValue OPTIONAL,
                               PULONG ResultMaxChars OPTIONAL,
                               PINIFILE_PARAMETERS *ReturnedParameterBlock
                               )
{
    NTSTATUS Status;
    PBYTE s;
    PWSTR p, p1;
    ULONG TotalSize,
    CharSize,
    NtFileNameLength,
    FileNameLength,
    ApplicationNameLength,
    VariableNameLength,
    VariableValueLength;
    ANSI_STRING AnsiString;
    PINIFILE_PARAMETERS a;

    if (ARGUMENT_PRESENT( FileName )) {
        if (Unicode) {
            FileNameLength = wcslen( FileName );
        } else {
            FileNameLength = strlen( FileName );
        }
    } else {
        FileNameLength = 0;
    }

    if (ARGUMENT_PRESENT( ApplicationName )) {
        ApplicationNameLength = BaseDllIniFileNameLength( Unicode, &ApplicationName );
    } else {
        ApplicationNameLength = 0;
        VariableName = NULL;
    }

    if (ARGUMENT_PRESENT( VariableName )) {
        VariableNameLength = BaseDllIniFileNameLength( Unicode, &VariableName );
    } else {
        VariableNameLength = 0;
    }

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (ARGUMENT_PRESENT( ResultMaxChars )) {
            VariableValueLength = 0;
        } else {
            if (!MultiValueStrings) {
                if (Unicode) {
                    VariableValueLength = wcslen( VariableValue );
                } else {
                    VariableValueLength = strlen( VariableValue );
                }
            } else {
                if (Unicode) {
                    p = (PWSTR)VariableValue;
                    while (*p) {
                        while (*p++) {
                            ;
                        }
                    }

                    VariableValueLength = (ULONG)(p - (PWSTR)VariableValue);
                } else {
                    s = (PBYTE)VariableValue;
                    while (*s) {
                        while (*s++) {
                            ;
                        }
                    }

                    VariableValueLength = (ULONG)(s - (PBYTE)VariableValue);
                }
            }
        }
    } else {
        VariableValueLength = 0;
    }

    NtFileNameLength = RtlGetLongestNtPathLength() * sizeof( WCHAR );
    TotalSize = sizeof( *a ) + NtFileNameLength;
    if (!Unicode) {
        TotalSize += (FileNameLength + 1 ) * sizeof( WCHAR );
    }

    // We have to allocate enough buffer for DBCS string.
    CharSize = (Unicode ? sizeof(WORD) : sizeof( WCHAR ));
    TotalSize += (ApplicationNameLength + 1 +
                  VariableNameLength + 1 +
                  VariableValueLength + 1
                 ) * CharSize;
    a = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), TotalSize );
    if (a == NULL) {
        KdPrint(( "BASE: Unable to allocate IniFile parameter buffer of %u bytes\n", TotalSize ));
        return STATUS_NO_MEMORY;
    }

    a->Operation = Operation;
    a->WriteOperation = WriteOperation;
    a->Unicode = Unicode;
    a->IniFile = NULL;
    a->ValueBufferAllocated = FALSE;
    a->MultiValueStrings = MultiValueStrings;

    p = (PWSTR)(a + 1);
    a->NtFileName.Buffer = p;
    a->NtFileName.Length = 0;
    a->NtFileName.MaximumLength = (USHORT)NtFileNameLength;
    p = (PWSTR)((PCHAR)p + NtFileNameLength);

    if (ARGUMENT_PRESENT( FileName )) {
        a->FileName.MaximumLength = (USHORT)((FileNameLength + 1) * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->FileName.Length = (USHORT)(FileNameLength * sizeof( WCHAR ));
            a->FileName.Buffer = FileName;
        } else {
            AnsiString.Buffer = FileName;
            AnsiString.Length = (USHORT)FileNameLength;
            AnsiString.MaximumLength = (USHORT)(AnsiString.Length + 1);
            a->FileName.Buffer = p;
            a->FileName.Length = 0;
            p += FileNameLength + 1;
            Status = Basep8BitStringToUnicodeString( &a->FileName, &AnsiString, FALSE );
            if (!NT_SUCCESS( Status )) {
                RtlFreeHeap( RtlProcessHeap(), 0, a );
                return Status;
            }
        }

        a->BaseFileName.Length = 0;
        p1 = a->FileName.Buffer + FileNameLength;
        if (FileNameLength != 0) {
            while (--p1 > a->FileName.Buffer) {
                if (*p1 == OBJ_NAME_PATH_SEPARATOR ||
                    *p1 == L'/' ||
                    *p1 == L':'
                    ) {
                    p1++;
                    break;
                }
            }
        }

        a->BaseFileName.Buffer = p1;
        a->BaseFileName.Length = (USHORT)((FileNameLength - (p1 - a->FileName.Buffer)) * sizeof( WCHAR ));
        a->BaseFileName.MaximumLength = (USHORT)(a->BaseFileName.Length + sizeof( UNICODE_NULL ));
        BaseDllFindIniFileNameMapping( &a->FileName,
                                       &a->BaseFileName,
                                       &a->IniFileNameMapping
                                     );
    } else {
        RtlInitUnicodeString( &a->FileName, L"win.ini" );
        a->BaseFileName = a->FileName;
        a->IniFileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->WinIniFileMapping;
    }

    if (ARGUMENT_PRESENT( ApplicationName )) {
        // We have to keep enough buffer for DBCS string.
        a->ApplicationName.MaximumLength = (USHORT)((ApplicationNameLength * sizeof(WORD)) + 1);
        a->ApplicationNameU.MaximumLength = (USHORT)(a->ApplicationName.MaximumLength * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->ApplicationNameU.Buffer = ApplicationName;
            a->ApplicationNameU.Length = (USHORT)(ApplicationNameLength * sizeof( UNICODE_NULL ));
            a->ApplicationName.Buffer = (PBYTE)p;
            a->ApplicationName.Length = 0;
            p = (PWSTR)((PCHAR)p + (ApplicationNameLength * sizeof(WORD)) + 1);
        } else {
            a->ApplicationName.Buffer = ApplicationName;
            a->ApplicationName.Length = (USHORT)ApplicationNameLength;
            a->ApplicationNameU.Buffer = p;
            a->ApplicationNameU.Length = 0;
            p += ApplicationNameLength + 1;
        }
    } else {
        RtlInitAnsiString( &a->ApplicationName, NULL );
        RtlInitUnicodeString( &a->ApplicationNameU, NULL );
    }

    if (ARGUMENT_PRESENT( VariableName )) {
        // We have to keep enough buffer for DBCS string.
        a->VariableName.MaximumLength = (USHORT)((VariableNameLength *sizeof(WORD)) + 1);
        a->VariableNameU.MaximumLength = (USHORT)(a->VariableName.MaximumLength * sizeof( UNICODE_NULL ));
        if (Unicode) {
            a->VariableNameU.Buffer = VariableName;
            a->VariableNameU.Length = (USHORT)(VariableNameLength * sizeof( UNICODE_NULL ));
            a->VariableName.Buffer = (PBYTE)p;
            a->VariableName.Length = 0;
            p = (PWSTR)((PCHAR)p + (VariableNameLength * sizeof(WORD)) + 1);
        } else {
            a->VariableName.Buffer = VariableName;
            a->VariableName.Length = (USHORT)VariableNameLength;
            a->VariableNameU.Buffer = p;
            a->VariableNameU.Length = 0;
            p += VariableNameLength + 1;
        }
    } else {
        RtlInitAnsiString( &a->VariableName, NULL );
        RtlInitUnicodeString( &a->VariableNameU, NULL );
    }

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (a->WriteOperation) {
            if (Unicode) {
                a->ValueBufferU = VariableValue;
                a->ValueLengthU = VariableValueLength * sizeof( WCHAR );
                *(PBYTE)p = '\0';
                a->ValueBuffer = (PBYTE)p;
                a->ValueLength = 0;
            } else {
                a->ValueBuffer = VariableValue;
                a->ValueLength = VariableValueLength;
                *p = UNICODE_NULL;
                a->ValueBufferU = p;
                a->ValueLengthU = 0;
            }
        } else {
            if (ARGUMENT_PRESENT( ResultMaxChars )) {
                a->ResultMaxChars = *ResultMaxChars;
            } else {
                a->ResultMaxChars = 0;
            }
            a->ResultChars = 0;
            if (Unicode) {
                a->ResultBufferU = VariableValue;
                a->ResultBuffer = NULL;
            } else {
                a->ResultBuffer = VariableValue;
                a->ResultBufferU = NULL;
            }
        }
    } else {
        if (a->WriteOperation) {
            a->ValueBuffer = NULL;
            a->ValueLength = 0;
            a->ValueBufferU = NULL;
            a->ValueLengthU = 0;
        } else {
            a->ResultMaxChars = 0;
            a->ResultChars = 0;
            a->ResultBufferU = NULL;
            a->ResultBuffer = NULL;
        }
    }

    *ReturnedParameterBlock = a;
    return STATUS_SUCCESS;
}


BOOLEAN
BaseDllGetApplicationName(
                         IN PINIFILE_PARAMETERS a,
                         OUT PANSI_STRING *ApplicationName OPTIONAL,
                         OUT PUNICODE_STRING *ApplicationNameU OPTIONAL
                         )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( ApplicationName )) {
        if (a->ApplicationName.Length == 0) {
            Status = RtlUnicodeStringToAnsiString( &a->ApplicationName, &a->ApplicationNameU, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", &a->ApplicationNameU, Status ));
                return FALSE;
            }
        }

        *ApplicationName = &a->ApplicationName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( ApplicationNameU )) {
        if (a->ApplicationNameU.Length == 0) {
            Status = RtlAnsiStringToUnicodeString( &a->ApplicationNameU, &a->ApplicationName, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", &a->ApplicationName, Status ));
                return FALSE;

            }
        }
        *ApplicationNameU = &a->ApplicationNameU;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
BaseDllGetVariableName(
                      IN PINIFILE_PARAMETERS a,
                      OUT PANSI_STRING *VariableName OPTIONAL,
                      OUT PUNICODE_STRING *VariableNameU OPTIONAL
                      )
{
    NTSTATUS Status;

    if (ARGUMENT_PRESENT( VariableName )) {
        if (a->VariableName.Length == 0) {
            Status = RtlUnicodeStringToAnsiString( &a->VariableName, &a->VariableNameU, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", &a->VariableNameU, Status ));
                return FALSE;
            }
        }

        *VariableName = &a->VariableName;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableNameU )) {
        if (a->VariableNameU.Length == 0) {
            Status = RtlAnsiStringToUnicodeString( &a->VariableNameU, &a->VariableName, FALSE );
            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %Z failed (%08x)\n", &a->VariableName, Status ));
                return FALSE;

            }
        }
        *VariableNameU = &a->VariableNameU;
        return TRUE;
    }

    return FALSE;
}

BOOLEAN
BaseDllGetVariableValue(
                       IN PINIFILE_PARAMETERS a,
                       OUT PBYTE *VariableValue OPTIONAL,
                       OUT PWSTR *VariableValueU OPTIONAL,
                       OUT PULONG VariableValueLength
                       )
{
    NTSTATUS Status;
    ULONG Index;

    if (ARGUMENT_PRESENT( VariableValue )) {
        if (a->ValueLength == 0) {
            if (a->ValueBufferU == NULL || a->ValueLengthU == 0) {
                *VariableValue = "";
                *VariableValueLength = 1;
                return TRUE;
            }

            a->ValueLength = a->ValueLengthU;
            Status = RtlUnicodeToMultiByteN( a->ValueBuffer,
                                             a->ValueLength,
                                             &Index,
                                             a->ValueBufferU,
                                             a->ValueLengthU
                                           );

            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: UnicodeToAnsi of %.*ws failed (%08x)\n",
                          a->ValueLengthU / sizeof( WCHAR ), a->ValueBufferU, Status
                        ));
                return FALSE;
            }

            // Set real converted size
            a->ValueLength = Index;
            a->ValueBuffer[ Index ] = '\0';       // Null terminate converted value
        } else {
            Index = a->ValueLength;
        }

        *VariableValue = a->ValueBuffer;
        *VariableValueLength = Index + 1;
        return TRUE;
    }

    if (ARGUMENT_PRESENT( VariableValueU )) {
        if (a->ValueLengthU == 0) {
            if (a->ValueBuffer == NULL || a->ValueLength == 0) {
                *VariableValueU = L"";
                *VariableValueLength = sizeof( UNICODE_NULL );
                return TRUE;
            }

            a->ValueLengthU = a->ValueLength * sizeof( WCHAR );
            Status = RtlMultiByteToUnicodeN( a->ValueBufferU,
                                             a->ValueLengthU,
                                             &Index,
                                             a->ValueBuffer,
                                             a->ValueLength
                                           );


            if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: AnsiToUnicode of %.*s failed (%08x)\n",
                          a->ValueLength, a->ValueBuffer, Status
                        ));
                return FALSE;
            }

            Index = Index / sizeof( WCHAR );
            a->ValueBufferU[ Index ] = UNICODE_NULL;    // Null terminate converted value
        } else {
            Index = a->ValueLengthU / sizeof( WCHAR );
        }

        *VariableValueU = a->ValueBufferU;
        *VariableValueLength = (Index + 1) * sizeof( WCHAR );
        return TRUE;
    }

    return FALSE;
}


NTSTATUS
BaseDllAppendNullToResultBuffer(
                               IN PINIFILE_PARAMETERS a
                               )
{
    return BaseDllAppendBufferToResultBuffer( a,
                                              NULL,
                                              NULL,
                                              0,
                                              TRUE
                                            );
}

NTSTATUS
BaseDllAppendStringToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PANSI_STRING String OPTIONAL,
                                 IN PUNICODE_STRING StringU OPTIONAL,
                                 IN BOOLEAN IncludeNull
                                 )
{
    if (ARGUMENT_PRESENT( String )) {
        if (ARGUMENT_PRESENT( StringU )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            return BaseDllAppendBufferToResultBuffer( a,
                                                      String->Buffer,
                                                      NULL,
                                                      String->Length,
                                                      IncludeNull
                                                    );
        }
    } else
        if (ARGUMENT_PRESENT( StringU )) {
        if (ARGUMENT_PRESENT( String )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            return BaseDllAppendBufferToResultBuffer( a,
                                                      NULL,
                                                      StringU->Buffer,
                                                      StringU->Length / sizeof( WCHAR ),
                                                      IncludeNull
                                                    );
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS
BaseDllAppendBufferToResultBuffer(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PBYTE Buffer OPTIONAL,
                                 IN PWSTR BufferU OPTIONAL,
                                 IN ULONG Chars,
                                 IN BOOLEAN IncludeNull
                                 )
{
    NTSTATUS Status, OverflowStatus;
    ULONG Index;

    OverflowStatus = STATUS_SUCCESS;
    if (ARGUMENT_PRESENT( Buffer )) {
        if (ARGUMENT_PRESENT( BufferU )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            ULONG CharsMbcs = Chars;
            //
            // In this point, Chars does not contains proper value for Unicode.
            // because. Chars was computed based on DBCS string length,
            // This is correct, sources string is DBCS, then
            // if the source is not DBCS. we just adjust it here.
            //
            if (a->Unicode) {
                Status = RtlMultiByteToUnicodeSize(&Chars,Buffer,Chars);
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: AnsiToUnicodeSize of %.*s failed (%08x)\n", Chars, Buffer, Status ));
                    return Status;
                }
                Chars /= sizeof(WCHAR);
            }
            if (a->ResultChars + Chars >= a->ResultMaxChars) {
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = a->ResultMaxChars - a->ResultChars;
                if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars) {
                if (a->Unicode) {
                    Status = RtlMultiByteToUnicodeN( a->ResultBufferU + a->ResultChars,
                                                     Chars * sizeof( WCHAR ),
                                                     &Index,
                                                     Buffer,
                                                     CharsMbcs
                                                   );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: AnsiToUnicode of %.*s failed (%08x)\n", Chars, Buffer, Status ));
                        return Status;
                    }
                } else {
                    memcpy( a->ResultBuffer + a->ResultChars, Buffer, Chars );
                }

                a->ResultChars += Chars;
            }
        }
    } else
        if (ARGUMENT_PRESENT( BufferU )) {
        if (ARGUMENT_PRESENT( Buffer )) {
            return STATUS_INVALID_PARAMETER;
        } else {
            ULONG CharsUnicode = Chars;
            //
            // In this point, Chars does not contains proper value for DBCS.
            // because. Chars was computed by just devide Unicode string length
            // by two. This is correct, sources string is Unicode, then
            // if the source is not Unicode. we just adjust it here.
            //
            if (!(a->Unicode)) {
                Status = RtlUnicodeToMultiByteSize(&Chars,BufferU,Chars * sizeof(WCHAR));
                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: UnicodeToAnsiSize of %.*ws failed (%08x)\n", Chars, BufferU, Status ));
                    return Status;
                }
            }
            if (a->ResultChars + Chars >= a->ResultMaxChars) {
                OverflowStatus = STATUS_BUFFER_OVERFLOW;
                Chars = a->ResultMaxChars - a->ResultChars;
                if (Chars) {
                    Chars -= 1;
                }
            }

            if (Chars) {
                if (a->Unicode) {
                    memcpy( a->ResultBufferU + a->ResultChars, BufferU, Chars * sizeof( WCHAR ) );
                } else {
                    Status = RtlUnicodeToMultiByteN( a->ResultBuffer + a->ResultChars,
                                                     Chars,
                                                     &Index,
                                                     BufferU,
                                                     CharsUnicode * sizeof( WCHAR )
                                                   );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: UnicodeToAnsi of %.*ws failed (%08x)\n", Chars, BufferU, Status ));
                        return Status;
                    }
                }

                a->ResultChars += Chars;
            }
        }
    }

    if (IncludeNull) {
        if (a->ResultChars + 1 >= a->ResultMaxChars) {
            return STATUS_BUFFER_OVERFLOW;
        }

        if (a->Unicode) {
            a->ResultBufferU[ a->ResultChars ] = UNICODE_NULL;
        } else {
            a->ResultBuffer[ a->ResultChars ] = '\0';
        }

        a->ResultChars += 1;
    }

    return OverflowStatus;
}


ULONG
BaseDllIniFileNameLength(
                        IN BOOLEAN Unicode,
                        IN PVOID *Name
                        )
{
    if (Unicode) {
        PWSTR p;

        p = *Name;
        while (*p == L' ') {
            p++;
        }
        *Name = p;
        while (*p != UNICODE_NULL) {
            p++;
        }

        if (p > (PWSTR)*Name) {
            while (*--p == L' ') {
            }
            p++;
        }

        return (ULONG)(p - (PWSTR)*Name);
    } else {
        PCH p;

        p = *Name;
        while (*p == ' ') {
            p++;
        }
        *Name = p;
        while (*p != '\0') {
            p++;
        }

        if (p > (PCH)*Name) {
            while (*--p == ' ') {
            }
            p++;
        }

        return (ULONG)(p - (PCH)*Name);
    }
}



NTSTATUS
BaseDllFindIniFileNameMapping(
                             IN PUNICODE_STRING FileName,
                             IN PUNICODE_STRING BaseFileName,
                             OUT PINIFILE_MAPPING_FILENAME *ReturnedFileNameMapping
                             )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_FILENAME FileNameMapping;
    UNICODE_STRING WinIniString;
    WCHAR TermSrvWindowsPath[MAX_PATH+1];
    UNICODE_STRING TermsrvWindowsDir;


    Status = STATUS_OBJECT_NAME_NOT_FOUND;
    RtlInitUnicodeString(&WinIniString, L"win.ini");

    //
    // Only look in mapping if
    //   Unqualified name was specified OR
    //   Path specified exactly matches the name of the Windows directory OR
    //   Filename is not win.ini (special hack for Windows Sound System, which
    //      expects GetPrivateProfileString on C:\SNDSYS\WIN.INI to return the
    //      data from the file, not the registry)
    //

    if (gpTermsrvGetWindowsDirectoryW) {

        if (gpTermsrvGetWindowsDirectoryW (TermSrvWindowsPath,MAX_PATH)) {

            RtlInitUnicodeString(&TermsrvWindowsDir,TermSrvWindowsPath);

        } else {

            RtlInitUnicodeString(&TermsrvWindowsDir,L"");

        }
    }


    if ((FileName->Buffer == BaseFileName->Buffer) ||
        RtlPrefixUnicodeString( &BaseWindowsDirectory, FileName, TRUE ) ||
        (!RtlEqualUnicodeString( BaseFileName, &WinIniString, TRUE )) ||
        // Also check for in per user's windows directory
        (IsTerminalServer() && RtlPrefixUnicodeString( &TermsrvWindowsDir, FileName, TRUE ))) {

        FileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->FileNames;
        while (FileNameMapping != NULL) {

            BASE_READ_REMOTE_STR_TEMP(TempStr);

            if (RtlEqualUnicodeString( BaseFileName,
                                       BASE_READ_REMOTE_STR(FileNameMapping->Name, TempStr),
                                       TRUE )) {
                Status = STATUS_SUCCESS;
                break;
            }

            FileNameMapping = (PINIFILE_MAPPING_FILENAME)FileNameMapping->Next;
        }

        if (FileNameMapping == NULL) {
            FileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->DefaultFileNameMapping;
        }

        *ReturnedFileNameMapping = FileNameMapping;
    } else {
        *ReturnedFileNameMapping = NULL;
    }

    return Status;
}


NTSTATUS
BaseDllOpenMappingTarget(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping,
                        IN PUNICODE_STRING ApplicationName OPTIONAL,
                        IN BOOLEAN WriteAccess,
                        OUT PHANDLE Key
                        );

PINIFILE_MAPPING_APPNAME
BaseDllFindAppNameMapping(
                         IN PINIFILE_MAPPING_FILENAME FileNameMapping,
                         IN PUNICODE_STRING ApplicationName
                         );

PINIFILE_MAPPING_VARNAME
BaseDllFindVarNameMapping(
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PUNICODE_STRING VariableName
                         );

NTSTATUS
BaseDllReadApplicationNames(
                           IN PINIFILE_PARAMETERS a
                           );

NTSTATUS
BaseDllCheckKeyNotEmpty(
                       IN HANDLE Key,
                       IN PUNICODE_STRING SubKeyName
                       );

NTSTATUS
BaseDllReadVariableNames(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping
                        );

NTSTATUS
BaseDllReadVariableValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        );

NTSTATUS
BaseDllReadApplicationVariables(
                               IN PINIFILE_PARAMETERS a,
                               IN PINIFILE_MAPPING_APPNAME AppNameMapping
                               );

NTSTATUS
BaseDllDeleteApplicationVariables(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                 );

NTSTATUS
BaseDllWriteApplicationVariables(
                                IN PINIFILE_PARAMETERS a,
                                IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                );

NTSTATUS
BaseDllWriteVariableValue(
                         IN PINIFILE_PARAMETERS a,
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                         IN PUNICODE_STRING VariableName OPTIONAL
                         );

NTSTATUS
BaseDllReadWriteIniFileViaMapping(
                                 IN PINIFILE_PARAMETERS a
                                 )
{
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PUNICODE_STRING ApplicationNameU;

    if (a->Operation == FlushProfiles) {
        return STATUS_SUCCESS;
    } else
        if (a->Operation == ReadSectionNames) {
        return BaseDllReadApplicationNames( a );
    } else
        if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    AppNameMapping = BaseDllFindAppNameMapping( a->IniFileNameMapping, ApplicationNameU );
    if (AppNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else
        if (a->Operation == ReadKeyValue) {
        return BaseDllReadVariableValue( a, AppNameMapping, NULL, NULL );
    } else
        if (a->Operation == ReadKeyNames) {
        return BaseDllReadVariableNames( a, AppNameMapping );
    } else
        if (a->Operation == ReadSection) {
        return BaseDllReadApplicationVariables( a, AppNameMapping );
    } else
        if (a->Operation == WriteKeyValue || a->Operation == DeleteKey) {
        return BaseDllWriteVariableValue( a, AppNameMapping, NULL, NULL );
    } else
        if (a->Operation == WriteSection || a->Operation == DeleteSection) {
        return BaseDllWriteApplicationVariables( a, AppNameMapping );
    }

    return STATUS_INVALID_PARAMETER;
}

VOID
BaseDllFlushRegistryCache( VOID )
{
    RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);

    BaseDllRegistryCache.MappingTarget = NULL;
    BaseDllRegistryCache.MappingFlags = 0;

    if (BaseDllRegistryCache.RegistryPath.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, BaseDllRegistryCache.RegistryPath.Buffer );
        RtlZeroMemory( &BaseDllRegistryCache.RegistryPath,
                       sizeof( BaseDllRegistryCache.RegistryPath )
                     );
    }

    if (BaseDllRegistryCache.RegistryKey != INVALID_HANDLE_VALUE) {
        NtClose( BaseDllRegistryCache.RegistryKey );
        BaseDllRegistryCache.RegistryKey = INVALID_HANDLE_VALUE;
    }

    RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);

    return;
}

NTSTATUS
BaseDllOpenMappingTarget(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping,
                        IN PUNICODE_STRING ApplicationName OPTIONAL,
                        IN BOOLEAN WriteAccess,
                        OUT PHANDLE Key
                        )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_TARGET MappingTarget;
    ULONG MappingFlags;
    BOOLEAN AppendApplicationName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG CreateDisposition;
    PUNICODE_STRING RegistryPathPrefix;
    UNICODE_STRING RegistryPath;
    KEY_BASIC_INFORMATION KeyBasicInfo;
    ULONG ResultLength;
    ULONG n;
    BOOLEAN OperationRetried = FALSE;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    *Key = INVALID_HANDLE_VALUE;
    MappingTarget = (PINIFILE_MAPPING_TARGET)VarNameMapping->MappingTarget;
    MappingFlags = VarNameMapping->MappingFlags & (INIFILE_MAPPING_APPEND_BASE_NAME |
                                                   INIFILE_MAPPING_APPEND_APPLICATION_NAME |
                                                   INIFILE_MAPPING_SOFTWARE_RELATIVE |
                                                   INIFILE_MAPPING_USER_RELATIVE
                                                  );
    if (MappingTarget == NULL || MappingTarget->RegistryPath.Length == 0) {
        return STATUS_SUCCESS;
    }

    if (ARGUMENT_PRESENT( ApplicationName ) &&
        (MappingFlags & INIFILE_MAPPING_APPEND_APPLICATION_NAME)
       ) {
        AppendApplicationName = TRUE;
    } else {
        AppendApplicationName = FALSE;
    }

    if (MappingFlags & INIFILE_MAPPING_USER_RELATIVE) {
        if (!BaseRunningInServerProcess && BaseDllIniUserKeyPath.Length == 0) {
            OpenProfileUserMapping();
        }

        if (BaseDllIniUserKeyPath.Length == 0) {
            KdPrint(( "BASE: Attempt to access user profile specific portion of .INI file.\n" ));
            KdPrint(( "      when there is no current user defined.\n" ));
            KdPrint(( "      Path: %wZ\n",
                      &MappingTarget->RegistryPath
                    ));
            return STATUS_ACCESS_DENIED;
        }

        RegistryPathPrefix = &BaseDllIniUserKeyPath;
    } else
        if (MappingFlags & INIFILE_MAPPING_SOFTWARE_RELATIVE) {
        RegistryPathPrefix = &BaseDllIniSoftwareKeyPath;
    } else {
        RegistryPathPrefix = NULL;
    }

    if (RegistryPathPrefix != NULL) {
        n = RegistryPathPrefix->Length + sizeof( WCHAR );
    } else {
        n = 0;
    }

    n += sizeof( WCHAR ) + MappingTarget->RegistryPath.Length;
    if (MappingFlags & INIFILE_MAPPING_APPEND_BASE_NAME) {
        n += sizeof( WCHAR ) + a->BaseFileName.Length;
    }

    if (AppendApplicationName) {
        n += sizeof( WCHAR ) + ApplicationName->Length;
    }
    n += sizeof( UNICODE_NULL );

    RegistryPath.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, n );
    if (RegistryPath.Buffer == NULL) {

        KdPrint(( "BASE: Unable to allocate registry path buffer of %u bytes\n", n ));
        return STATUS_NO_MEMORY;
    }
    RegistryPath.Length = 0;
    RegistryPath.MaximumLength = (USHORT)n;

    if (RegistryPathPrefix != NULL) {
        RtlAppendUnicodeStringToString( &RegistryPath, RegistryPathPrefix );
        RtlAppendUnicodeToString( &RegistryPath, L"\\" );
    }

    RtlAppendUnicodeStringToString( &RegistryPath,
                                    BASE_READ_REMOTE_STR(MappingTarget->RegistryPath, TempStr)
                                  );

    if (MappingFlags & INIFILE_MAPPING_APPEND_BASE_NAME) {
        RtlAppendUnicodeToString( &RegistryPath, L"\\" );
        RtlAppendUnicodeStringToString( &RegistryPath, &a->BaseFileName );
    }
    if (AppendApplicationName) {
        RtlAppendUnicodeToString( &RegistryPath, L"\\" );
        RtlAppendUnicodeStringToString( &RegistryPath, ApplicationName );
    }

    RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);
    if (BaseDllRegistryCache.RegistryKey != INVALID_HANDLE_VALUE &&
        BaseDllRegistryCache.MappingTarget == MappingTarget &&
        BaseDllRegistryCache.MappingFlags == MappingFlags &&
        BaseDllRegistryCache.WriteAccess == WriteAccess &&
        RtlEqualUnicodeString( &BaseDllRegistryCache.RegistryPath, &RegistryPath, TRUE )
       ) {
        Status = NtQueryKey( BaseDllRegistryCache.RegistryKey,
                             KeyBasicInformation,
                             &KeyBasicInfo,
                             sizeof( KeyBasicInfo ),
                             &ResultLength
                           );
        if (Status != STATUS_KEY_DELETED) {
            RtlFreeHeap( RtlProcessHeap(), 0, RegistryPath.Buffer );
            *Key = BaseDllRegistryCache.RegistryKey;
            RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
            return STATUS_SUCCESS;
        }
    }
    RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
    BaseDllFlushRegistryCache();

    InitializeObjectAttributes( &ObjectAttributes,
                                &RegistryPath,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                NULL
                              );

    if (WriteAccess) {
        repeatoperation:

        Status = NtCreateKey( Key,
                              STANDARD_RIGHTS_WRITE |
                              KEY_QUERY_VALUE |
                              KEY_ENUMERATE_SUB_KEYS |
                              KEY_SET_VALUE |
                              KEY_CREATE_SUB_KEY,
                              &ObjectAttributes,
                              0,
                              NULL,
                              0,
                              &CreateDisposition
                            );
        //
        // There are cases where dorks delete the virtual ini file in the
        // registry. To handle this, if we get object path not found, attempt
        // to create the containing key and then repeat the operation
        //

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND && OperationRetried == FALSE ) {

            NTSTATUS RetryStatus;
            OBJECT_ATTRIBUTES RetryObjectAttributes;
            ULONG RetryCreateDisposition;
            UNICODE_STRING RetryRegistryPath;
            HANDLE RetryKey;

            RetryRegistryPath = RegistryPath;
            while ( RetryRegistryPath.Buffer[RetryRegistryPath.Length>>1] != (WCHAR)'\\' ) {
                RetryRegistryPath.Length -= sizeof(WCHAR);
            }

            InitializeObjectAttributes( &RetryObjectAttributes,
                                        &RetryRegistryPath,
                                        OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                        NULL,
                                        NULL
                                      );
            RetryStatus = NtCreateKey( &RetryKey,
                                       STANDARD_RIGHTS_WRITE |
                                       KEY_QUERY_VALUE |
                                       KEY_ENUMERATE_SUB_KEYS |
                                       KEY_SET_VALUE |
                                       KEY_CREATE_SUB_KEY,
                                       &RetryObjectAttributes,
                                       0,
                                       NULL,
                                       0,
                                       &RetryCreateDisposition
                                     );
            if ( NT_SUCCESS(RetryStatus) ) {
                NtClose(RetryKey);
                OperationRetried = TRUE;
                goto repeatoperation;
            }
        }
    } else {
        Status = NtOpenKey( Key,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
    }


    if (NT_SUCCESS( Status )) {
#if DBG
        if (BaseDllDumpIniCalls) {
            KdPrint(( "BASEDLL: Opened %wZ\n", &RegistryPath ));
        }
#endif

        RtlEnterCriticalSection(&BaseDllRegistryCache.Lock);
        BaseDllRegistryCache.MappingTarget = MappingTarget;
        BaseDllRegistryCache.MappingFlags = MappingFlags;
        BaseDllRegistryCache.WriteAccess = WriteAccess;
        BaseDllRegistryCache.RegistryPath = RegistryPath;
        BaseDllRegistryCache.RegistryKey = *Key;
        RtlLeaveCriticalSection(&BaseDllRegistryCache.Lock);
    } else {
#if DBG
        if (BaseDllDumpIniCalls || WriteAccess || Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            DbgPrint( "BASEDLL: Failed to open %wZ for %s - Status == %lx\n",
                      &RegistryPath,
                      WriteAccess ? "write" : "read",
                      Status
                    );
        }
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, RegistryPath.Buffer );
    }

    return Status;
}


PINIFILE_MAPPING_APPNAME
BaseDllFindAppNameMapping(
                         IN PINIFILE_MAPPING_FILENAME FileNameMapping,
                         IN PUNICODE_STRING ApplicationName
                         )
{
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->ApplicationNames;
    while (AppNameMapping != NULL) {

        if (RtlEqualUnicodeString( BASE_READ_REMOTE_STR(AppNameMapping->Name, TempStr),
                                   ApplicationName,
                                   TRUE )) {
            return AppNameMapping;
        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
    }

    return (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
}


PINIFILE_MAPPING_VARNAME
BaseDllFindVarNameMapping(
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PUNICODE_STRING VariableName
                         )
{

    PINIFILE_MAPPING_VARNAME VarNameMapping;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {

        if (RtlEqualUnicodeString( BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr),
                                   VariableName,
                                   TRUE )) {
            return VarNameMapping;
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    return (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
}


NTSTATUS
BaseDllReadApplicationNames(
                           IN PINIFILE_PARAMETERS a
                           )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    HANDLE Key;
    WCHAR Buffer[ 256 ];
    PKEY_BASIC_INFORMATION KeyInformation;
    ULONG SubKeyIndex;
    ULONG ResultLength;
    UNICODE_STRING SubKeyName;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    AppNameMapping = (PINIFILE_MAPPING_APPNAME)a->IniFileNameMapping->ApplicationNames;
    while (AppNameMapping != NULL) {

        Status = BaseDllAppendStringToResultBuffer( a,
                                                    NULL,
                                                    BASE_READ_REMOTE_STR(AppNameMapping->Name,TempStr),
                                                    TRUE
                                                  );

        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
    }

    AppNameMapping = (PINIFILE_MAPPING_APPNAME)a->IniFileNameMapping->DefaultAppNameMapping;
    if (AppNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping,
                                       NULL,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        Status = NtEnumerateKey( Key,
                                 SubKeyIndex,
                                 KeyBasicInformation,
                                 KeyInformation,
                                 sizeof( Buffer ),
                                 &ResultLength
                               );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        }

        if (NT_SUCCESS( Status )) {
            SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
            SubKeyName.Length = (USHORT)KeyInformation->NameLength;
            SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;
            Status = BaseDllCheckKeyNotEmpty( Key,
                                              &SubKeyName
                                            );

            if (NT_SUCCESS( Status ) ) {
                Status = BaseDllAppendStringToResultBuffer( a, NULL, &SubKeyName, TRUE );
            } else
                if (Status != STATUS_NO_MORE_ENTRIES) {
                break;
            } else {
                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS( Status )) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllCheckKeyNotEmpty(
                       IN HANDLE Key,
                       IN PUNICODE_STRING SubKeyName
                       )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SubKey;
    KEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    InitializeObjectAttributes( &ObjectAttributes,
                                SubKeyName,
                                OBJ_CASE_INSENSITIVE,
                                Key,
                                NULL
                              );
    Status = NtOpenKey( &SubKey,
                        GENERIC_READ,
                        &ObjectAttributes
                      );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    Status = NtEnumerateValueKey( SubKey,
                                  0,
                                  KeyValueBasicInformation,
                                  &KeyValueInformation,
                                  sizeof( KeyValueInformation ),
                                  &ResultLength
                                );


    if (Status == STATUS_BUFFER_OVERFLOW) {
        Status = STATUS_SUCCESS;
    }

    NtClose( SubKey );

    return Status;
}

NTSTATUS
BaseDllReadVariableNames(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping
                        )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    PUNICODE_STRING ApplicationNameU;
    WCHAR Buffer[ 256 ];
    PKEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ValueIndex;
    ULONG ResultLength;
    UNICODE_STRING VariableName;
    HANDLE Key;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {

        Status = BaseDllAppendStringToResultBuffer( a,
                                                    NULL,
                                                    BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr),
                                                    TRUE
                                                  );

        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = NtEnumerateValueKey( Key,
                                      ValueIndex,
                                      KeyValueBasicInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        } else
            if (!NT_SUCCESS( Status )) {
            return Status;
        }

        VariableName.Buffer = KeyValueInformation->Name;
        VariableName.Length = (USHORT)KeyValueInformation->NameLength;
        VariableName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
        Status = BaseDllAppendStringToResultBuffer( a, NULL, &VariableName, TRUE );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllReadVariableValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                        IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    PUNICODE_STRING ApplicationNameU;
    KEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    PKEY_VALUE_PARTIAL_INFORMATION p;
    ULONG ResultLength;
    UNICODE_STRING Value;
    BOOLEAN OutputVariableName;
    UNICODE_STRING EqualSign;
    PWSTR s;
    HANDLE Key;

    if (ARGUMENT_PRESENT( VariableName )) {
        RtlInitUnicodeString( &EqualSign, L"=" );
        OutputVariableName = TRUE;
    } else {
        if (!BaseDllGetVariableName( a, NULL, &VariableName )) {
            return STATUS_INVALID_PARAMETER;
        }

        OutputVariableName = FALSE;
    }

    if (!ARGUMENT_PRESENT( VarNameMapping )) {
        VarNameMapping = BaseDllFindVarNameMapping( AppNameMapping, VariableName );
    }

    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    Status = NtQueryValueKey( Key,
                              VariableName,
                              KeyValuePartialInformation,
                              &KeyValueInformation,
                              sizeof( KeyValueInformation ),
                              &ResultLength
                            );
    if (!NT_SUCCESS( Status )) {
        if (Status != STATUS_BUFFER_OVERFLOW) {
            return Status;
        }

        p = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), ResultLength );
        if (p == NULL) {
            return STATUS_NO_MEMORY;
        }

        Status = NtQueryValueKey( Key,
                                  VariableName,
                                  KeyValuePartialInformation,
                                  p,
                                  ResultLength,
                                  &ResultLength
                                );
    } else {
        p = &KeyValueInformation;
    }

    if (NT_SUCCESS( Status )) {
        if (p->Type == REG_SZ) {
            if (OutputVariableName) {
                Status = BaseDllAppendStringToResultBuffer( a, NULL, VariableName, FALSE );
                if (NT_SUCCESS( Status )) {
                    Status = BaseDllAppendStringToResultBuffer( a, NULL, &EqualSign, FALSE );
                }
            }

            if (NT_SUCCESS( Status )) {
                Value.Buffer = (PWSTR)&p->Data[ 0 ];
                if (p->DataLength < sizeof( UNICODE_NULL )) {
                    Value.Length = 0;
                } else {
                    Value.Length = (USHORT)(p->DataLength - sizeof( UNICODE_NULL ));
                }
                Value.MaximumLength = (USHORT)(p->DataLength);
                s = (PWSTR)Value.Buffer;
                if (a->Operation == ReadKeyValue &&
                    Value.Length >= (2 * sizeof( WCHAR )) &&
                    (s[ 0 ] == s[ (Value.Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
                    (s[ 0 ] == L'"' || s[ 0 ] == L'\'')
                   ) {
                    Value.Buffer += 1;
                    Value.Length -= (2 * sizeof( WCHAR ));
                    Value.MaximumLength -= (2 * sizeof( WCHAR ));
                }

                Status = BaseDllAppendStringToResultBuffer( a, NULL, &Value, TRUE );
            }
        } else {
            KdPrint(( "BASE: Registry value %wZ not REG_SZ type (%u)\n", VariableName, p->Type ));
            Status = STATUS_OBJECT_TYPE_MISMATCH;
        }
    }


    if (p != &KeyValueInformation) {
        RtlFreeHeap( RtlProcessHeap(), 0, p );
    }

    return Status;
}


NTSTATUS
BaseDllReadApplicationVariables(
                               IN PINIFILE_PARAMETERS a,
                               IN PINIFILE_MAPPING_APPNAME AppNameMapping
                               )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    PUNICODE_STRING ApplicationNameU;
    WCHAR Buffer[ 256 ];
    PKEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ValueIndex;
    ULONG ResultLength;
    UNICODE_STRING VariableName;
    HANDLE Key;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {
        if (VarNameMapping->Name.Length != 0) {

            Status = BaseDllReadVariableValue( a,
                                               AppNameMapping,
                                               VarNameMapping,
                                               BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr)
                                             );

            if (!NT_SUCCESS( Status )) {
                if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
                    Status == STATUS_OBJECT_TYPE_MISMATCH
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    return Status;
                }
            }
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       FALSE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = NtEnumerateValueKey( Key,
                                      ValueIndex,
                                      KeyValueBasicInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        } else
            if (!NT_SUCCESS( Status )) {
            return Status;
        }

        VariableName.Buffer = KeyValueInformation->Name;
        VariableName.Length = (USHORT)KeyValueInformation->NameLength;
        VariableName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
        Status = BaseDllReadVariableValue( a, AppNameMapping, NULL, &VariableName );

        if (!NT_SUCCESS( Status ) &&
            Status != STATUS_OBJECT_NAME_NOT_FOUND &&
            Status != STATUS_OBJECT_TYPE_MISMATCH
           ) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
BaseDllDeleteApplicationVariables(
                                 IN PINIFILE_PARAMETERS a,
                                 IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                 )
{
    NTSTATUS Status;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    WCHAR Buffer[ 256 ];
    HANDLE Key;
    PKEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    PUNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableName;
    BASE_READ_REMOTE_STR_TEMP(TempStr);

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
    while (VarNameMapping != NULL) {
        if (VarNameMapping->Name.Length != 0) {

            Status = BaseDllWriteVariableValue( a,
                                                AppNameMapping,
                                                VarNameMapping,
                                                BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr)
                                              );

            if (!NT_SUCCESS( Status )) {
                if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                    return Status;
                }
            }
        }

        VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
    }

    VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       TRUE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    do {
        //
        // Enumerate the 0th key.  Since we are deleting as we go
        // this will always be a new key until we are out of entries.
        //
        Status = NtEnumerateValueKey( Key,
                                      0,
                                      KeyValueBasicInformation,
                                      KeyValueInformation,
                                      sizeof( Buffer ),
                                      &ResultLength
                                    );

        if (NT_SUCCESS( Status )) {
    
            VariableName.Buffer = KeyValueInformation->Name;
            VariableName.Length = (USHORT)KeyValueInformation->NameLength;
            VariableName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
            Status = NtDeleteValueKey( Key,
                                       &VariableName
                                     );
            //
            // If we couldn't find VariableName, then somebody must be deleting
            // at the same time we are and beat us to it, so we just ignore the error.
            //
    
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                Status = STATUS_SUCCESS;
            }
        }

    } while (NT_SUCCESS( Status ));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    //
    // We can't delete key, as if there are handles open to it,
    // future attempts to recreate it will fail.
    //
    // Status = NtDeleteKey( Key );
    //

    BaseDllFlushRegistryCache();

    return Status;
}


NTSTATUS
BaseDllWriteApplicationVariables(
                                IN PINIFILE_PARAMETERS a,
                                IN PINIFILE_MAPPING_APPNAME AppNameMapping
                                )
{
    NTSTATUS Status;
    ULONG n;
    PVOID SaveValueBuffer, NewValueBuffer, CurrentValueBuffer, CurrentVariableStart, FreeBuffer;
    ULONG SaveValueLength, NewValueLength, CurrentValueLength, CurrentVariableLength;

    if (a->Operation == DeleteSection) {
        return BaseDllDeleteApplicationVariables( a, AppNameMapping );
    }

    if (a->ValueBuffer != NULL && a->ValueLength != 0) {
        SaveValueBuffer = a->ValueBuffer;
        SaveValueLength = a->ValueLength;
    } else
        if (a->ValueBufferU != NULL && a->ValueLengthU != 0) {
        SaveValueBuffer = a->ValueBufferU;
        SaveValueLength = a->ValueLengthU;
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    NewValueBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), SaveValueLength );
    if (NewValueBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    FreeBuffer = NULL;
    try {
        RtlMoveMemory( NewValueBuffer, SaveValueBuffer, NewValueLength = SaveValueLength );
        CurrentValueBuffer = NewValueBuffer;
        CurrentValueLength = NewValueLength;
        NewValueLength = 0;
        while (CurrentValueLength) {
            if (a->Unicode) {
                PWSTR s, s1;

                s = CurrentValueBuffer;
                n = CurrentValueLength / sizeof( WCHAR );
                while (n && *s != UNICODE_NULL && *s <= L' ') {
                    n--;
                    s++;
                }
                if (!n || *s == UNICODE_NULL) {

                    break;
                }

                CurrentVariableStart = s;
                a->VariableNameU.Buffer = s;
                while (n && *s != L'=') {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                s1 = s++;
                n--;
                while (s1 > a->VariableNameU.Buffer) {
                    if (s1[-1] > L' ') {
                        break;
                    }
                    s1 -= 1;
                }
                a->VariableNameU.Length = (USHORT)((PCHAR)s1 - (PCHAR)a->VariableNameU.Buffer);
                if (a->VariableNameU.Length == 0) {
                    break;
                }
                a->VariableNameU.MaximumLength = a->VariableNameU.Length + sizeof( UNICODE_NULL );
                while (n && *s == L' ') {
                    n--;
                    s++;
                }

                a->ValueBufferU = s;
                while (n && *s != UNICODE_NULL) {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                a->ValueLengthU = (USHORT)((PCHAR)s - (PCHAR)a->ValueBufferU);
                n--;
                s++;
                CurrentVariableLength = (ULONG)((PCHAR)s - (PCHAR)CurrentVariableStart);
                CurrentValueBuffer = s;
                CurrentValueLength = n * sizeof( WCHAR );
            } else {
                PBYTE s, s1;

                s = CurrentValueBuffer;
                n = CurrentValueLength;
                while (n && *s != '\0' && *s <= ' ') {
                    n--;
                    s++;
                }
                if (!n || *s == '\0') {

                    break;
                }

                CurrentVariableStart = s;
                a->VariableName.Buffer = s;
                while (n && *s != '=') {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                s1 = s++;
                n--;
                while (s1 > a->VariableName.Buffer) {
                    if (s1[-1] > ' ') {
                        break;
                    }
                    s1 -= 1;
                }
                a->VariableName.Length = (USHORT)(s1 - a->VariableName.Buffer);
                if (a->VariableName.Length == 0) {
                    break;
                }
                a->VariableName.MaximumLength = a->VariableName.Length + 1;
                while (n && *s == ' ') {
                    n--;
                    s++;
                }

                a->ValueBuffer = s;
                while (n && *s != '\0') {
                    n--;
                    s++;
                }
                if (!n) {
                    break;
                }

                a->ValueLength = (USHORT)(s - a->ValueBuffer);
                n--;
                s++;
                CurrentVariableLength = (ULONG)(s - (PCHAR)CurrentVariableStart);
                CurrentValueBuffer = s;
                CurrentValueLength = n;

                a->VariableNameU.MaximumLength = a->VariableName.MaximumLength * sizeof( WCHAR );
                a->VariableNameU.Length = 0;
                FreeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                              MAKE_TAG( TMP_TAG ),
                                              a->VariableNameU.MaximumLength +
                                              ((a->ValueLength+1) * sizeof( WCHAR ))
                                            );
                if (FreeBuffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                a->VariableNameU.Buffer = FreeBuffer;
                a->ValueBufferU = (PWSTR)((PCHAR)FreeBuffer + a->VariableNameU.MaximumLength );
            }

            Status = BaseDllWriteVariableValue( a, AppNameMapping, NULL, NULL );
            if (FreeBuffer != NULL) {
                RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
                FreeBuffer = NULL;
                RtlInitUnicodeString( &a->VariableNameU, NULL );
                a->ValueBufferU = NULL;
                a->ValueLengthU = 0;
            }

            if (!NT_SUCCESS( Status )) {
                if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                    break;
                } else {
                    RtlMoveMemory( (PCHAR)NewValueBuffer + NewValueLength,
                                   CurrentVariableStart,
                                   CurrentVariableLength
                                 );
                    NewValueLength += CurrentVariableLength;
                    Status = STATUS_SUCCESS;
                }
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if (NewValueLength) {
        a->ValueBufferAllocated = TRUE;
        if (a->Unicode) {
            a->ValueBufferU = NewValueBuffer;
            a->ValueLengthU = NewValueLength;
        } else {
            a->ValueBuffer = NewValueBuffer;
            a->ValueLength = NewValueLength;
        }
    } else {
        RtlFreeHeap( RtlProcessHeap(), 0, NewValueBuffer );
    }

    return Status;
}


NTSTATUS
BaseDllWriteVariableValue(
                         IN PINIFILE_PARAMETERS a,
                         IN PINIFILE_MAPPING_APPNAME AppNameMapping,
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping OPTIONAL,
                         IN PUNICODE_STRING VariableName OPTIONAL
                         )
{
    NTSTATUS Status;
    PUNICODE_STRING ApplicationNameU;
    PWSTR VariableValueU;
    ULONG VariableValueLength;
    HANDLE Key;
    KEY_VALUE_BASIC_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    if (!ARGUMENT_PRESENT( VariableName )) {
        if (!BaseDllGetVariableName( a, NULL, &VariableName )) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (!ARGUMENT_PRESENT( VarNameMapping )) {
        VarNameMapping = BaseDllFindVarNameMapping( AppNameMapping, VariableName );
    }

    if (VarNameMapping == NULL) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (!BaseDllGetApplicationName( a, NULL, &ApplicationNameU )) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = BaseDllOpenMappingTarget( a,
                                       VarNameMapping,
                                       ApplicationNameU,
                                       TRUE,
                                       &Key
                                     );
    if (!NT_SUCCESS( Status ) || Key == INVALID_HANDLE_VALUE) {
        return Status;
    }

    Status = NtQueryValueKey( Key,
                              VariableName,
                              KeyValueBasicInformation,
                              &KeyValueInformation,
                              sizeof( KeyValueInformation ),
                              &ResultLength
                            );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_OVERFLOW) {
        if (KeyValueInformation.Type != REG_SZ) {
            return STATUS_OBJECT_TYPE_MISMATCH;
        }
    }

    if (a->Operation == WriteKeyValue || a->Operation == WriteSection) {
        if (!BaseDllGetVariableValue( a, NULL, &VariableValueU, &VariableValueLength )) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = NtSetValueKey( Key,
                                    VariableName,
                                    0,
                                    REG_SZ,
                                    VariableValueU,
                                    VariableValueLength
                                  );
        }
    } else {
        Status = NtDeleteValueKey( Key,
                                   VariableName
                                 );
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
    }

    if (NT_SUCCESS( Status ) && (VarNameMapping->MappingFlags & INIFILE_MAPPING_WRITE_TO_INIFILE_TOO)) {
#if 0
        DbgPrint( "BASEDLL: WriteToProfileToo for [%wZ] %wZ . %wZ\n",
                  &a->FileName,
                  ApplicationNameU,
                  VariableName
                );
#endif
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        return Status;
    }
}



NTSTATUS
BaseDllReadSectionNames(
                       IN PINIFILE_PARAMETERS a
                       );

NTSTATUS
BaseDllReadKeywordNames(
                       IN PINIFILE_PARAMETERS a
                       );

NTSTATUS
BaseDllReadKeywordValue(
                       IN PINIFILE_PARAMETERS a
                       );

NTSTATUS
BaseDllReadSection(
                  IN PINIFILE_PARAMETERS a
                  );

NTSTATUS
BaseDllWriteSection(
                   IN PINIFILE_PARAMETERS a
                   );

NTSTATUS
BaseDllWriteKeywordValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        );


#define BYTE_ORDER_MARK           0xFEFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE

NTSTATUS
BaseDllReadWriteIniFileOnDisk(
                             IN PINIFILE_PARAMETERS a
                             )
{
    NTSTATUS Status;
    ULONG PartialResultChars;

    if (!a->WriteOperation) {
        PartialResultChars = a->ResultChars;
    }

    Status = BaseDllOpenIniFileOnDisk( a );
    if (NT_SUCCESS( Status )) {
        try {
            a->TextEnd = (PCHAR)a->IniFile->BaseAddress + a->IniFile->EndOfFile;
            a->TextCurrent = a->IniFile->BaseAddress;
            if (a->IniFile->UnicodeFile &&
                ((*(PWCHAR)a->TextCurrent == BYTE_ORDER_MARK) ||
                 (*(PWCHAR)a->TextCurrent == REVERSE_BYTE_ORDER_MARK)))
            {
                // Skip past the BOM.
                ((PWCHAR)a->TextCurrent)++;
            }

            if (a->Operation == ReadSectionNames) {
                Status = BaseDllReadSectionNames( a );
            } else
                if (a->Operation == ReadKeyValue) {
                Status = BaseDllReadKeywordValue( a );
            } else
                if (a->Operation == ReadKeyNames) {
                Status = BaseDllReadKeywordNames( a );
            } else
                if (a->Operation == ReadSection) {
                Status = BaseDllReadSection( a );
            } else
                if (a->Operation == WriteKeyValue || a->Operation == DeleteKey) {
                Status = BaseDllWriteKeywordValue( a, NULL );
            } else
                if (a->Operation == WriteSection || a->Operation == DeleteSection) {
                Status = BaseDllWriteSection( a );
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        finally {
            NTSTATUS CloseStatus;
            CloseStatus = BaseDllCloseIniFileOnDisk( a );
            if (NT_SUCCESS( Status )) {
                Status = CloseStatus;
            }
        }
    }

    if (IsTerminalServer()) {
        // The entry they were looking for wasn't found, see if we need to sync
        // up the ini file
        if (!NT_SUCCESS(Status) && ((a->Operation == ReadSectionNames) ||
                                    (a->Operation == ReadKeyValue) ||
                                    (a->Operation == ReadKeyNames) ||
                                    (a->Operation == ReadSection))) {

            // Sync up the ini file (if necessary), if we updated it, retry the
            // original request
            if (TermsrvSyncUserIniFile(a)) {
                BaseDllReadWriteIniFileOnDisk(a);
            }
        } else if (NT_SUCCESS(Status) && ((a->Operation == WriteKeyValue) ||
                                          (a->Operation == DeleteKey) ||
                                          (a->Operation == WriteSection) ||
                                          (a->Operation == DeleteSection)) &&
                                          TermsrvAppInstallMode()) {
            // Update log of installed files
            if (gpTermsrvLogInstallIniFile) {
                gpTermsrvLogInstallIniFile(&a->NtFileName);
            }
        }
    }


    if (Status == STATUS_OBJECT_NAME_NOT_FOUND &&
        !a->WriteOperation &&
        PartialResultChars != 0
       ) {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
BaseDllOpenIniFileOnDisk(
                        IN PINIFILE_PARAMETERS a
                        )
{
    NTSTATUS Status;
    UNICODE_STRING FullFileName;
    ULONG n;
    PWSTR FilePart;
    PINIFILE_CACHE IniFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset, Length;

    a->NtFileName.Length = 0;
    if ((a->FileName.Length > sizeof( WCHAR ) &&
         a->FileName.Buffer[ 1 ] == L':'
        ) ||
        (a->FileName.Length != 0 &&
         wcscspn( a->FileName.Buffer, L"\\/" ) != (a->FileName.Length / sizeof( WCHAR ))
        )
       ) {
        n = GetFullPathNameW( a->FileName.Buffer,
                              a->NtFileName.MaximumLength / sizeof( WCHAR ),
                              a->NtFileName.Buffer,
                              &FilePart
                            );
        if (n > a->NtFileName.MaximumLength) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            a->NtFileName.Length = (USHORT)(n * sizeof( WCHAR ));
            Status = STATUS_SUCCESS;
        }

        /*
         * If the base windows directory was specified,
         * redirect to user's directory
         */
        if (gpTermsrvConvertSysRootToUserDir) {
            gpTermsrvConvertSysRootToUserDir( &a->NtFileName, &BaseWindowsDirectory );
        }

    } else {
        //
        // get user based ini file
        //
        if (!gpTermsrvBuildIniFileName ||
             !(NT_SUCCESS(Status = gpTermsrvBuildIniFileName( &a->NtFileName, &a->BaseFileName )))) {

            RtlCopyUnicodeString( &a->NtFileName,
                                  &BaseWindowsDirectory
                                );
            Status = RtlAppendUnicodeToString( &a->NtFileName,
                                               L"\\"
                                             );
            if (NT_SUCCESS( Status )) {
                Status = RtlAppendUnicodeStringToString( &a->NtFileName,
                                                         &a->BaseFileName
                                                       );
            }
        }
    }

    IniFile = NULL;
    if (NT_SUCCESS( Status )) {
        if (RtlDosPathNameToNtPathName_U( a->NtFileName.Buffer,
                                          &FullFileName,
                                          &FilePart,
                                          NULL
                                        )
           ) {
            RtlCopyUnicodeString( &a->NtFileName, &FullFileName );
            RtlFreeUnicodeString( &FullFileName );

            IniFile = RtlAllocateHeap( RtlProcessHeap(),
                                       MAKE_TAG( INI_TAG ) | HEAP_ZERO_MEMORY,
                                       sizeof( *IniFile ) + a->NtFileName.MaximumLength
                                     );
            if (IniFile == NULL) {
                return STATUS_NO_MEMORY;
            }
            IniFile->NtFileName.Buffer = (PWSTR)(IniFile + 1);
            IniFile->NtFileName.MaximumLength = a->NtFileName.MaximumLength;
            RtlCopyUnicodeString( &IniFile->NtFileName, &a->NtFileName );
            IniFile->FileMapping = a->IniFileNameMapping;
            IniFile->WriteAccess = a->WriteOperation;

            if (gpTermsrvCORIniFile) {
                /*
                 * We call a function who handles copy on reference INI files
                 * before attempting the open.
                 */


                gpTermsrvCORIniFile( &IniFile->NtFileName );

            }


            InitializeObjectAttributes( &ObjectAttributes,
                                        &IniFile->NtFileName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );
            if (IniFile->WriteAccess) {
                Status = NtCreateFile( &IniFile->FileHandle,
                                       SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                       &ObjectAttributes,
                                       &IoStatusBlock,
                                       0,
                                       FILE_ATTRIBUTE_NORMAL,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                       FILE_OPEN_IF,
                                       FILE_SYNCHRONOUS_IO_NONALERT |
                                       FILE_NON_DIRECTORY_FILE,
                                       NULL,
                                       0
                                     );
            } else {
                Status = NtOpenFile( &IniFile->FileHandle,
                                     SYNCHRONIZE | GENERIC_READ,
                                     &ObjectAttributes,
                                     &IoStatusBlock,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                     FILE_SYNCHRONOUS_IO_NONALERT |
                                     FILE_NON_DIRECTORY_FILE
                                   );
            }

#if DBG
            if (!NT_SUCCESS( Status )) {
                if (BaseDllDumpIniCalls) {
                    KdPrint(( "BASEDLL: Unable to open %wZ - Status == %x\n", &a->NtFileName, Status ));
                }
            }
#endif // DBG
        } else {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
    }

    if (NT_SUCCESS( Status )) {
        IniFile->LockedFile = FALSE;
        ByteOffset.QuadPart = 0;
        Length.QuadPart = -1;
        Status = NtLockFile( IniFile->FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             &ByteOffset,
                             &Length,
                             LockFileKey,
                             FALSE,
                             IniFile->WriteAccess
                           );
        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NOT_SUPPORTED) {
                //
                // Go naked on downlevel servers since they can't do anything useful
                // to help.
                //

                Status = STATUS_SUCCESS;
            }
        } else {
            IniFile->LockedFile = TRUE;
        }

        if (NT_SUCCESS( Status )) {
            Status = NtQueryInformationFile( IniFile->FileHandle,
                                             &IoStatusBlock,
                                             &IniFile->StandardInformation,
                                             sizeof( IniFile->StandardInformation ),
                                             FileStandardInformation
                                           );
            if (Status == STATUS_BUFFER_OVERFLOW) {
                Status = STATUS_SUCCESS;
            } else
                if (!NT_SUCCESS( Status )) {
                KdPrint(( "BASEDLL: Unable to QueryInformation for %wZ - Status == %x\n", &a->NtFileName, Status ));
            }
        }
    }

    if (!NT_SUCCESS( Status )) {
#if DBG
        if (BaseDllDumpIniCalls) {
            KdPrint(( "BASEDLL: Open of %wZ failed - Status == %x\n",
                      &IniFile->NtFileName,
                      Status
                    ));
        }
#endif // DBG

        if (IniFile != NULL) {
            if (IniFile->LockedFile) {
                ByteOffset.QuadPart = 0;
                Length.QuadPart = -1;
                NtUnlockFile( IniFile->FileHandle,
                              &IoStatusBlock,
                              &ByteOffset,
                              &Length,
                              LockFileKey
                            );
            }

            NtClose( IniFile->FileHandle );
            RtlFreeHeap( RtlProcessHeap(), 0, IniFile );
        }

        return Status;
    }

    IniFile->EndOfFile = IniFile->StandardInformation.EndOfFile.LowPart;
    IniFile->CommitSize = IniFile->EndOfFile + (4 * (IniFile->UnicodeFile ? sizeof( WCHAR ) : 1));
    IniFile->RegionSize = IniFile->CommitSize + 0x100000; // Room for 256KB of growth
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      &IniFile->BaseAddress,
                                      0,
                                      &IniFile->RegionSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &IniFile->BaseAddress,
                                          0,
                                          &IniFile->CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (NT_SUCCESS( Status )) {
            Status = NtReadFile( IniFile->FileHandle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 IniFile->BaseAddress,
                                 IniFile->EndOfFile,
                                 NULL,
                                 &LockFileKey
                               );
            if (NT_SUCCESS( Status ) && IoStatusBlock.Information != IniFile->EndOfFile) {
                Status = STATUS_END_OF_FILE;
            }
        }
    }

    if (NT_SUCCESS( Status )) {
        // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
        INT iResult = ~0x0;
        IniFile->UpdateOffset = 0xFFFFFFFF;
        IniFile->UpdateEndOffset = 0;
        IniFile->UnicodeFile = RtlIsTextUnicode( IniFile->BaseAddress, IniFile->EndOfFile, &iResult );
        if (IniFile->UnicodeFile) {
            PWSTR Src;

            Src = (PWSTR)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            while (Src > (PWSTR)IniFile->BaseAddress && Src[ -1 ] <= L' ') {
                if (Src[-1] == L'\r' || Src[-1] == L'\n') {
                    break;
                }

                IniFile->EndOfFile -= sizeof( WCHAR );
                Src -= 1;
            }

            Src = (PWSTR)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            if (Src > (PWSTR)IniFile->BaseAddress) {
                if (Src[-1] != L'\n') {
                    *Src++ = L'\r';
                    *Src++ = L'\n';
                    IniFile->UpdateOffset = IniFile->EndOfFile;
                    IniFile->UpdateEndOffset = IniFile->UpdateOffset + 2 * sizeof( WCHAR );
                    IniFile->EndOfFile = IniFile->UpdateEndOffset;
                }
            }
        } else {
            PBYTE Src;

            Src = (PBYTE)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            while (Src > (PBYTE)IniFile->BaseAddress && Src[ -1 ] <= ' ') {
                if (Src[-1] == '\r' || Src[-1] == '\n') {
                    break;
                }

                IniFile->EndOfFile -= 1;
                Src -= 1;
            }

            Src = (PBYTE)((PCHAR)IniFile->BaseAddress + IniFile->EndOfFile);
            if (Src > (PBYTE)IniFile->BaseAddress) {
                if (Src[-1] != '\n') {
                    *Src++ = '\r';
                    *Src++ = '\n';
                    IniFile->UpdateOffset = IniFile->EndOfFile;
                    IniFile->UpdateEndOffset = IniFile->UpdateOffset + 2;
                    IniFile->EndOfFile = IniFile->UpdateEndOffset;
                }
            }
        }

        a->IniFile = IniFile;
    } else {
        KdPrint(( "BASEDLL: Read of %wZ failed - Status == %x\n",
                  &IniFile->NtFileName,
                  Status
                ));

        if (IniFile->LockedFile) {
            ByteOffset.QuadPart = 0;
            Length.QuadPart = -1;
            NtUnlockFile( IniFile->FileHandle,
                          &IoStatusBlock,
                          &ByteOffset,
                          &Length,
                          LockFileKey
                        );
        }

        NtClose( IniFile->FileHandle );

        RtlFreeHeap( RtlProcessHeap(), 0, IniFile );
    }

    return Status;
}


NTSTATUS
BaseDllCloseIniFileOnDisk(
                         IN PINIFILE_PARAMETERS a
                         )
{
    PINIFILE_CACHE IniFile;
    NTSTATUS Status;
    NTSTATUS CloseStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG UpdateLength;
    LARGE_INTEGER ByteOffset, Length;

    Status = STATUS_SUCCESS;
    IniFile = a->IniFile;
    if (IniFile != NULL) {
        ASSERT( IniFile->FileHandle != NULL );
        if (IniFile->BaseAddress != NULL) {
            if (IniFile->UpdateOffset != 0xFFFFFFFF && IniFile->WriteAccess) {
                ByteOffset.HighPart = 0;
                ByteOffset.LowPart = IniFile->UpdateOffset;
                UpdateLength = IniFile->UpdateEndOffset - IniFile->UpdateOffset;
                Status = NtWriteFile( IniFile->FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      (PCHAR)(IniFile->BaseAddress) + IniFile->UpdateOffset,
                                      UpdateLength,
                                      &ByteOffset,
                                      &LockFileKey
                                    );
                if (NT_SUCCESS( Status )) {
                    if (IoStatusBlock.Information != UpdateLength) {
                        Status = STATUS_DISK_FULL;
                    } else {
                        Length.QuadPart = IniFile->EndOfFile;
                        Status = NtSetInformationFile( IniFile->FileHandle,
                                                       &IoStatusBlock,
                                                       &Length,
                                                       sizeof( Length ),
                                                       FileEndOfFileInformation
                                                     );
                    }
                }

                if (!NT_SUCCESS( Status )) {
                    KdPrint(( "BASEDLL: Unable to write changes for %wZ to disk - Status == %x\n",
                              &IniFile->NtFileName,
                              Status
                            ));
                }
            }

            NtFreeVirtualMemory( NtCurrentProcess(),
                                 &IniFile->BaseAddress,
                                 &IniFile->RegionSize,
                                 MEM_RELEASE
                               );
            IniFile->BaseAddress = NULL;
            IniFile->CommitSize = 0;
            IniFile->RegionSize = 0;
        }

        if (IniFile->LockedFile) {
            ByteOffset.QuadPart = 0;
            Length.QuadPart = -1;
            NtUnlockFile( IniFile->FileHandle,
                          &IoStatusBlock,
                          &ByteOffset,
                          &Length,
                          HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)
                        );
        }

        CloseStatus = NtClose( IniFile->FileHandle );
        if (NT_SUCCESS( Status )) {
            Status = CloseStatus;
        }
        IniFile->FileHandle = NULL;

        RtlFreeHeap( RtlProcessHeap(), 0, IniFile );
    }

    return Status;
}


#define STOP_AT_SECTION 1
#define STOP_AT_KEYWORD 2
#define STOP_AT_NONSECTION 3

NTSTATUS
BaseDllFindSection(
                  IN PINIFILE_PARAMETERS a
                  );

NTSTATUS
BaseDllFindKeyword(
                  IN PINIFILE_PARAMETERS a
                  );

NTSTATUS
BaseDllAdvanceTextPointer(
                         IN PINIFILE_PARAMETERS a,
                         IN ULONG StopAt
                         );

NTSTATUS
BaseDllReadSectionNames(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;
    while (NT_SUCCESS( Status )) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiSectionName,
                                                        a->UnicodeSectionName,
                                                        TRUE
                                                      );
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllReadKeywordNames(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    while (NT_SUCCESS( Status )) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES) {
            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiKeywordName,
                                                        a->UnicodeKeywordName,
                                                        TRUE
                                                      );
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllReadKeywordValue(
                       IN PINIFILE_PARAMETERS a
                       )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = BaseDllFindKeyword( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src;

        Src = (PWSTR)a->UnicodeKeywordValue->Buffer;
        while (*Src <= L' ' && a->UnicodeKeywordValue->Length) {
            Src += 1;
            a->UnicodeKeywordValue->Buffer = Src;
            a->UnicodeKeywordValue->Length -= sizeof( WCHAR );
            a->UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
        }

        if (a->UnicodeKeywordValue->Length >= (2 * sizeof( WCHAR )) &&
            (Src[ 0 ] == Src[ (a->UnicodeKeywordValue->Length - sizeof( WCHAR )) / sizeof( WCHAR ) ]) &&
            (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
           ) {
            a->UnicodeKeywordValue->Buffer += 1;
            a->UnicodeKeywordValue->Length -= (2 * sizeof( WCHAR ));
            a->UnicodeKeywordValue->MaximumLength -= (2 * sizeof( WCHAR ));
        }
    } else {
        PBYTE Src;

        Src = (PBYTE)a->AnsiKeywordValue->Buffer;
        while (*Src <= ' ' && a->AnsiKeywordValue->Length) {
            Src += 1;
            a->AnsiKeywordValue->Buffer = Src;
            a->AnsiKeywordValue->Length -= sizeof( UCHAR );
            a->AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
        }

        if (a->AnsiKeywordValue->Length >= (2 * sizeof( UCHAR )) &&
            (Src[ 0 ] == Src[ (a->AnsiKeywordValue->Length - sizeof( UCHAR )) / sizeof( UCHAR ) ]) &&
            (Src[ 0 ] == '"' || Src[ 0 ] == '\'')
           ) {
            a->AnsiKeywordValue->Buffer += 1;
            a->AnsiKeywordValue->Length -= (2 * sizeof( UCHAR ));
            a->AnsiKeywordValue->MaximumLength -= (2 * sizeof( UCHAR ));
        }
    }

    return BaseDllAppendStringToResultBuffer( a,
                                              a->AnsiKeywordValue,
                                              a->UnicodeKeywordValue,
                                              TRUE
                                            );
}


NTSTATUS
BaseDllReadSection(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;

    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_NONSECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            if (a->AnsiKeywordName || a->UnicodeKeywordName) {
                Status = BaseDllAppendStringToResultBuffer( a,
                                                            a->AnsiKeywordName,
                                                            a->UnicodeKeywordName,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }

                Status = BaseDllAppendBufferToResultBuffer( a,
                                                            a->Unicode ? NULL : "=",
                                                            a->Unicode ? L"=" : NULL,
                                                            1,
                                                            FALSE
                                                          );
                if (!NT_SUCCESS( Status )) {
                    return Status;
                }
            }

            if (a->IniFile->UnicodeFile) {
                PWSTR Src;

                Src = (PWSTR)a->UnicodeKeywordValue->Buffer;
                while (*Src <= L' ' && a->UnicodeKeywordValue->Length) {
                    Src += 1;
                    a->UnicodeKeywordValue->Buffer = Src;
                    a->UnicodeKeywordValue->Length -= sizeof( WCHAR );
                    a->UnicodeKeywordValue->MaximumLength -= sizeof( WCHAR );
                }
            } else {
                PBYTE Src;

                Src = (PBYTE)a->AnsiKeywordValue->Buffer;
                while (*Src <= ' ' && a->AnsiKeywordValue->Length) {
                    Src += 1;
                    a->AnsiKeywordValue->Buffer = Src;
                    a->AnsiKeywordValue->Length -= sizeof( UCHAR );
                    a->AnsiKeywordValue->MaximumLength -= sizeof( UCHAR );
                }
            }

            Status = BaseDllAppendStringToResultBuffer( a,
                                                        a->AnsiKeywordValue,
                                                        a->UnicodeKeywordValue,
                                                        TRUE
                                                      );
            if (!NT_SUCCESS( Status )) {
                return Status;
            }
        } else {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            break;
        }
    }

    return Status;
}


NTSTATUS
BaseDllModifyMappedFile(
                       IN PINIFILE_PARAMETERS a,
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       );


NTSTATUS
BaseDllWriteSection(
                   IN PINIFILE_PARAMETERS a
                   )
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    PVOID InsertBuffer;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    PBYTE AnsiKeywordValue, s;
    PWSTR UnicodeKeywordValue, w;
    ULONG ValueLength, SizeToRemove;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteSection) {
            return STATUS_SUCCESS;
        }

        AddressInFile = a->TextEnd;
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        } else {
            if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
        SizeToRemove = 0;
    } else {
        if (a->Operation == DeleteSection) {
            AddressInFile = a->TextStart;
        } else {
            AddressInFile = a->TextCurrent;
        }
        while (TRUE) {
            //
            // For delete operations need to iterate all lines in section,
            // not just those that have an = on them. Otherwise sections like
            // [foo]
            // a
            // b = c
            // d
            //
            // don't get deleted properly.
            //
            Status = BaseDllAdvanceTextPointer(
                                              a,
                                              (a->Operation == DeleteSection) ? STOP_AT_NONSECTION : STOP_AT_KEYWORD
                                              );

            if (Status == STATUS_MORE_ENTRIES) {
            } else
                if (Status == STATUS_NO_MORE_ENTRIES) {
                SizeToRemove = (ULONG)((PCHAR)a->TextCurrent - (PCHAR)AddressInFile);
                break;
            } else {
                return Status;
            }
        }

        InsertSectionName = FALSE;
    }

    if (a->Operation == DeleteSection) {
        InsertBuffer = NULL;
    } else {
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetVariableValue( a, NULL, &UnicodeKeywordValue, &ValueLength )) {
                return STATUS_INVALID_PARAMETER;
            }
            ValueLength -= sizeof( WCHAR );

            //
            // Add in size of value, + \r\n for each line
            //

            w = UnicodeKeywordValue;
            InsertAmount += ValueLength;
            while (*w) {
                while (*w++) {
                }
                InsertAmount += (2-1) * sizeof( WCHAR );    // Subtract out NULL byte already in ValueLength
            }
        } else {
            if (!BaseDllGetVariableValue( a, &AnsiKeywordValue, NULL, &ValueLength )) {
                return STATUS_INVALID_PARAMETER;
            }
            ValueLength -= sizeof( UCHAR );

            //
            // Add in size of value, + \r\n for each line
            //

            s = AnsiKeywordValue;
            InsertAmount += ValueLength;
            while (*s) {
                while (*s++) {
                }
                InsertAmount += 2 - 1;      // Subtract out NULL byte already in ValueLength
            }
        }

        InsertBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), InsertAmount + sizeof( UNICODE_NULL ) );
        if (InsertBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }

        if (a->IniFile->UnicodeFile) {
            PWSTR Src, Dst;

            Dst = InsertBuffer;
            if (InsertSectionName) {
                *Dst++ = L'[';
                Src = UnicodeSectionName->Buffer;
                n = UnicodeSectionName->Length / sizeof( WCHAR );
                while (n--) {
                    *Dst++ = *Src++;
                }
                *Dst++ = L']';
                *Dst++ = L'\r';
                *Dst++ = L'\n';
            }

            Src = UnicodeKeywordValue;
            while (*Src) {
                while (*Dst = *Src++) {
                    Dst += 1;
                }

                *Dst++ = L'\r';
                *Dst++ = L'\n';
            }
        } else {
            PBYTE Src, Dst;

            Dst = InsertBuffer;
            if (InsertSectionName) {
                *Dst++ = '[';
                Src = AnsiSectionName->Buffer;
                n = AnsiSectionName->Length;
                while (n--) {
                    *Dst++ = *Src++;
                }
                *Dst++ = ']';
                *Dst++ = '\r';
                *Dst++ = '\n';
            }

            Src = AnsiKeywordValue;
            while (*Src) {
                while (*Dst = *Src++) {
                    Dst += 1;
                }

                *Dst++ = '\r';
                *Dst++ = '\n';
            }
        }
    }

    Status = BaseDllModifyMappedFile( a,
                                      AddressInFile,
                                      SizeToRemove,
                                      InsertBuffer,
                                      InsertAmount
                                    );
    RtlFreeHeap( RtlProcessHeap(), 0, InsertBuffer );
    return Status;
}

NTSTATUS
BaseDllCalculateDeleteLength(
                            IN PINIFILE_PARAMETERS a
                            )
{
    ULONG DeleteLength;

    if (a->IniFile->UnicodeFile) {
        DeleteLength = (ULONG)((PCHAR)a->TextCurrent -
                               (PCHAR)a->UnicodeKeywordName->Buffer);
    } else {
        DeleteLength = (ULONG)((PCHAR)a->TextCurrent -
                               a->AnsiKeywordName->Buffer);
    }

    return DeleteLength;
}

NTSTATUS
BaseDllWriteKeywordValue(
                        IN PINIFILE_PARAMETERS a,
                        IN PUNICODE_STRING VariableName OPTIONAL
                        )
{
    NTSTATUS Status;
    BOOLEAN InsertSectionName;
    BOOLEAN InsertKeywordName;
    PVOID InsertBuffer;
    ULONG InsertAmount, n;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PBYTE AnsiKeywordValue;
    PWSTR UnicodeKeywordValue;
    ULONG ValueLength;
    ULONG DeleteLength;
    PVOID AddressInFile;

    InsertAmount = 0;
    Status = BaseDllFindSection( a );
    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteKey) {
            return STATUS_SUCCESS;
        }

        AddressInFile = a->TextEnd;
        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeSectionName->Length;
        } else {
            if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of [SectionName]\r\n
            //

            InsertAmount += (1 + 1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiSectionName->Length;
        }

        InsertSectionName = TRUE;
    } else {
        InsertSectionName = FALSE;
        Status = BaseDllFindKeyword( a );
    }

    if (!NT_SUCCESS( Status )) {
        if (a->Operation == DeleteKey) {
            return STATUS_SUCCESS;
        }

        if (!InsertSectionName) {
            AddressInFile = a->TextCurrent;
        }

        if (a->IniFile->UnicodeFile) {
            if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( WCHAR );
            InsertAmount += UnicodeKeywordName->Length;
        } else {
            if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Add in size of Keyword=\r\n
            //

            InsertAmount += (1 + 2) * sizeof( UCHAR );
            InsertAmount += AnsiKeywordName->Length;
        }

        InsertKeywordName = TRUE;
    } else {
        if (a->IniFile->UnicodeFile) {
            if (a->Operation == DeleteKey) {
                DeleteLength = BaseDllCalculateDeleteLength( a );
                return BaseDllModifyMappedFile( a,
                                                a->UnicodeKeywordName->Buffer,
                                                DeleteLength,
                                                NULL,
                                                0
                                              );
            } else {
                AddressInFile = a->UnicodeKeywordValue->Buffer;
            }
        } else {
            if (a->Operation == DeleteKey) {
                DeleteLength = BaseDllCalculateDeleteLength( a );
                return BaseDllModifyMappedFile( a,
                                                a->AnsiKeywordName->Buffer,
                                                DeleteLength,
                                                NULL,
                                                0
                                              );
            } else {
                AddressInFile = a->AnsiKeywordValue->Buffer;
            }
        }
        InsertKeywordName = FALSE;
    }

    if (a->IniFile->UnicodeFile) {
        if (!BaseDllGetVariableValue( a, NULL, &UnicodeKeywordValue, &ValueLength )) {
            return STATUS_INVALID_PARAMETER;
        }
        ValueLength -= sizeof( WCHAR );

        if (InsertAmount == 0) {
            return BaseDllModifyMappedFile( a,
                                            a->UnicodeKeywordValue->Buffer,
                                            a->UnicodeKeywordValue->Length,
                                            UnicodeKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    } else {
        if (!BaseDllGetVariableValue( a, &AnsiKeywordValue, NULL, &ValueLength )) {
            return STATUS_INVALID_PARAMETER;
        }
        ValueLength -= sizeof( UCHAR );

        if (InsertAmount == 0) {
            return BaseDllModifyMappedFile( a,
                                            a->AnsiKeywordValue->Buffer,
                                            a->AnsiKeywordValue->Length,
                                            AnsiKeywordValue,
                                            ValueLength
                                          );
        }

        //
        // Add in size of value
        //

        InsertAmount += ValueLength;
    }

    InsertBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), InsertAmount  + sizeof( UNICODE_NULL ) );
    if (InsertBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src, Dst;

        Dst = InsertBuffer;
        if (InsertSectionName) {
            *Dst++ = L'[';
            Src = UnicodeSectionName->Buffer;
            n = UnicodeSectionName->Length / sizeof( WCHAR );
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = L']';
            *Dst++ = L'\r';
            *Dst++ = L'\n';
        }

        if (InsertKeywordName) {
            Src = UnicodeKeywordName->Buffer;
            n = UnicodeKeywordName->Length / sizeof( WCHAR );
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = L'=';
        }

        Src = UnicodeKeywordValue;
        n = ValueLength / sizeof( WCHAR );
        while (n--) {
            *Dst++ = *Src++;
        }

        if (InsertKeywordName) {
            *Dst++ = L'\r';
            *Dst++ = L'\n';
        }
    } else {
        PBYTE Src, Dst;

        Dst = InsertBuffer;
        if (InsertSectionName) {
            *Dst++ = '[';
            Src = AnsiSectionName->Buffer;
            n = AnsiSectionName->Length;
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = ']';
            *Dst++ = '\r';
            *Dst++ = '\n';
        }

        if (InsertKeywordName) {
            Src = AnsiKeywordName->Buffer;
            n = AnsiKeywordName->Length;
            while (n--) {
                *Dst++ = *Src++;
            }
            *Dst++ = '=';
        }

        Src = AnsiKeywordValue;
        n = ValueLength;
        while (n--) {
            *Dst++ = *Src++;
        }

        if (InsertKeywordName) {
            *Dst++ = '\r';
            *Dst++ = '\n';
        }
    }

    Status = BaseDllModifyMappedFile( a,
                                      AddressInFile,
                                      0,
                                      InsertBuffer,
                                      InsertAmount
                                    );
    RtlFreeHeap( RtlProcessHeap(), 0, InsertBuffer );
    return Status;
}


NTSTATUS
BaseDllFindSection(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;
    PANSI_STRING AnsiSectionName;
    PUNICODE_STRING UnicodeSectionName;
    BOOL FreeAnsiBuffer;

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_SECTION );
        if (Status == STATUS_MORE_ENTRIES) {
            FreeAnsiBuffer = FALSE;
            if (a->AnsiSectionName) {
                // Ansi ini file -- get the ansi parm
                if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL )) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                // Unicode ini file
                if (a->Unicode) {
                    // Unicode parm - we just need the unicode section name...
                    if (!BaseDllGetApplicationName( a, NULL, &UnicodeSectionName )) {
                        return STATUS_INVALID_PARAMETER;
                    }
                } else {
                    // ansi parm - convert the unicode section name to ansi
                    if (!BaseDllGetApplicationName( a, &AnsiSectionName, NULL ))
                        return STATUS_INVALID_PARAMETER;

                    a->AnsiSectionName = &a->SectionName;
                    Status = RtlUnicodeStringToAnsiString( a->AnsiSectionName,
                                                           a->UnicodeSectionName,
                                                           TRUE
                                                         );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", a->UnicodeSectionName, Status ));
                        return Status;
                    }

                    FreeAnsiBuffer = TRUE;
                }
            }

            if (a->AnsiSectionName == NULL && a->Unicode) {
                if (RtlEqualUnicodeString( UnicodeSectionName,
                                           a->UnicodeSectionName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiSectionName, a->AnsiSectionName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (FreeAnsiBuffer) {
                RtlFreeAnsiString( a->AnsiSectionName );
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS
BaseDllFindKeyword(
                  IN PINIFILE_PARAMETERS a
                  )
{
    NTSTATUS Status;
    PANSI_STRING AnsiKeywordName;
    PUNICODE_STRING UnicodeKeywordName;
    BOOL FreeAnsiBuffer;

    while (TRUE) {
        Status = BaseDllAdvanceTextPointer( a, STOP_AT_KEYWORD );
        if (Status == STATUS_MORE_ENTRIES) {
            FreeAnsiBuffer = FALSE;

            // Here's the deal.  We don't want to compare in Unicode
            // unless both the ini and the input parm are Unicode,
            // because we want to avoid the round-trip problem (we
            // lose data when we convert Unicode -> Ansi (on disk) ->
            // Unicode; since we don't get back the original Unicode
            // string, lookups of previously stored data fail -- bug
            // 426754).  So if both are Unicode, great! -- use Unicode.
            // Otherwise, use ansi for everything.

            if (a->AnsiKeywordName) {
                // Ansi ini file -- get the ansi parm
                if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                // Unicode ini
                if (a->Unicode) {
                    // Unicode parm - great, get the Unicode parm.
                    if (!BaseDllGetVariableName( a, NULL, &UnicodeKeywordName )) {
                        return STATUS_INVALID_PARAMETER;
                    }
                } else {
                    // Ansi parm - convert the unicode ini keyword to ansi.
                    if (!BaseDllGetVariableName( a, &AnsiKeywordName, NULL )) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    a->AnsiKeywordName = &a->KeywordName;
                    Status = RtlUnicodeStringToAnsiString( a->AnsiKeywordName,
                                                           a->UnicodeKeywordName,
                                                           TRUE
                                                         );
                    if (!NT_SUCCESS( Status )) {
                        KdPrint(( "BASEDLL: UnicodeToAnsi of %wZ failed (%08x)\n", a->UnicodeKeywordName, Status ));
                        return Status;
                    }

                    FreeAnsiBuffer = TRUE;
                }
            }

            if (a->AnsiKeywordName == NULL && a->Unicode) {
                if (RtlEqualUnicodeString( UnicodeKeywordName,
                                           a->UnicodeKeywordName,
                                           TRUE
                                         )
                   ) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            } else {
                if (RtlEqualString( AnsiKeywordName, a->AnsiKeywordName, TRUE )) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_MORE_ENTRIES;
                }
            }

            if (FreeAnsiBuffer) {
                RtlFreeAnsiString( a->AnsiKeywordName );
            }

            if (Status != STATUS_MORE_ENTRIES) {
                return Status;
            }
        } else {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }
}

NTSTATUS
BaseDllAdvanceTextPointer(
                         IN PINIFILE_PARAMETERS a,
                         IN ULONG StopAt
                         )
{
    BOOLEAN AllowNoEquals;

    if (StopAt == STOP_AT_NONSECTION) {
        StopAt = STOP_AT_KEYWORD;
        AllowNoEquals = TRUE;
    } else {
        AllowNoEquals = FALSE;
    }

    if (a->IniFile->UnicodeFile) {
        PWSTR Src, EndOfLine, EqualSign, EndOfFile;
        PWSTR Name, EndOfName, Value, EndOfValue;

#define INI_TEXT(quote) L##quote

        Src = a->TextCurrent;
        EndOfFile = a->TextEnd;
        while (Src < EndOfFile) {
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' ')) {
                Src++;
            }

            if (Src >= EndOfFile) {
                a->TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            a->TextStart = Src;
            while (EndOfLine < EndOfFile) {
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('=')) {
                    EqualSign = ++EndOfLine;
                } else
                    if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n')) {
                    if (*EndOfLine == INI_TEXT('\r')) {
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                } else {
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';')) {
                if (*Src == INI_TEXT('[')) {
                    Name = Src + 1;
                    while (Name < EndOfLine && *Name <= INI_TEXT(' ')) {
                        Name++;
                    }
                    EndOfName = Name;
                    while (EndOfName < EndOfLine && *EndOfName != INI_TEXT(']')) {
                        EndOfName++;
                    }

                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                        EndOfName--;
                    }
                    a->SectionNameU.Buffer = Name;
                    a->SectionNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    a->SectionNameU.MaximumLength = a->SectionNameU.Length;
                    a->AnsiSectionName = NULL;
                    a->UnicodeSectionName = &a->SectionNameU;
                    if (StopAt == STOP_AT_SECTION) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    } else
                        if (StopAt == STOP_AT_KEYWORD) {
                        return STATUS_NO_MORE_ENTRIES;
                    }
                } else
                    if (AllowNoEquals || (EqualSign != NULL) ) {

                    if (EqualSign != NULL) {
                        Name = Src;
                        EndOfName = EqualSign - 1;
                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                            EndOfName--;
                        }

                        a->KeywordNameU.Buffer = Name;
                        a->KeywordNameU.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        a->KeywordNameU.MaximumLength = a->KeywordNameU.Length;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = &a->KeywordNameU;

                        Value = EqualSign;
                    } else {
                        Value = Src;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' ')) {
                        EndOfValue--;
                    }
                    a->KeywordValueU.Buffer = Value;
                    a->KeywordValueU.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    a->KeywordValueU.MaximumLength = a->KeywordValueU.Length;
                    a->AnsiKeywordValue = NULL;
                    a->UnicodeKeywordValue = &a->KeywordValueU;
                    if (StopAt == STOP_AT_KEYWORD) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    } else {
        PBYTE Src, EndOfLine, EqualSign, EndOfFile;
        PBYTE Name, EndOfName, Value, EndOfValue;

#undef INI_TEXT
#define INI_TEXT(quote) quote

        Src = a->TextCurrent;
        EndOfFile = a->TextEnd;
        while (Src < EndOfFile) {
            //
            // Find first non-blank character on a line.  Skip blank lines
            //

            while (Src < EndOfFile && *Src <= INI_TEXT(' ')) {
                Src++;
            }

            if (Src >= EndOfFile) {
                a->TextCurrent = Src;
                break;
            }

            EndOfLine = Src;
            EqualSign = NULL;
            a->TextStart = Src;
            while (EndOfLine < EndOfFile) {
                if (EqualSign == NULL && *EndOfLine == INI_TEXT('=')) {
                    EqualSign = ++EndOfLine;
                } else
                    if (*EndOfLine == INI_TEXT('\r') || *EndOfLine == INI_TEXT('\n')) {
                    if (*EndOfLine == INI_TEXT('\r')) {
                        EndOfLine++;
                    }

                    if (*EndOfLine == INI_TEXT('\n')) {
                        EndOfLine++;
                    }

                    break;
                } else {
                    EndOfLine++;
                }
            }

            if (*Src != INI_TEXT(';')) {
                if (*Src == INI_TEXT('[')) {
                    Name = Src + 1;
                    while (Name < EndOfLine && *Name <= INI_TEXT(' ')) {
                        Name++;
                    }
                    EndOfName = Name;
                    while (EndOfName < EndOfLine) {
                        if (*EndOfName == INI_TEXT(']')) {
                            break;
                        }
                        if (IsDBCSLeadByte(*EndOfName)) {
                            EndOfName++;
                        }
                        EndOfName++;
                    }
                    while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                        EndOfName--;
                    }
                    a->SectionName.Buffer = Name;
                    a->SectionName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                    a->SectionName.MaximumLength = a->SectionName.Length;
                    a->AnsiSectionName = &a->SectionName;
                    a->UnicodeSectionName = NULL;
                    if (StopAt == STOP_AT_SECTION) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    } else
                        if (StopAt == STOP_AT_KEYWORD) {
                        return STATUS_NO_MORE_ENTRIES;
                    }
                } else
                    if (AllowNoEquals || (EqualSign != NULL)) {

                    if (EqualSign != NULL) {
                        Name = Src;
                        EndOfName = EqualSign - 1;
                        while (EndOfName > Name && EndOfName[ -1 ] <= INI_TEXT(' ')) {
                            EndOfName--;
                        }

                        a->KeywordName.Buffer = Name;
                        a->KeywordName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Name);
                        a->KeywordName.MaximumLength = a->KeywordName.Length;
                        a->AnsiKeywordName = &a->KeywordName;
                        a->UnicodeKeywordName = NULL;

                        Value = EqualSign;
                    } else {
                        Value = Src;
                        a->AnsiKeywordName = NULL;
                        a->UnicodeKeywordName = NULL;
                    }

                    EndOfValue = EndOfLine;
                    while (EndOfValue > Value && EndOfValue[ -1 ] <= INI_TEXT(' ')) {
                        EndOfValue--;
                    }
                    a->KeywordValue.Buffer = Value;
                    a->KeywordValue.Length = (USHORT)((PCHAR)EndOfValue - (PCHAR)Value);
                    a->KeywordValue.MaximumLength = a->KeywordValue.Length;
                    a->AnsiKeywordValue = &a->KeywordValue;
                    a->UnicodeKeywordValue = NULL;
                    if (StopAt == STOP_AT_KEYWORD) {
                        a->TextCurrent = EndOfLine;
                        return STATUS_MORE_ENTRIES;
                    }
                }
            }

            Src = EndOfLine;
        }
    }

    return STATUS_NO_MORE_ENTRIES;
}


NTSTATUS
BaseDllModifyMappedFile(
                       IN PINIFILE_PARAMETERS a,
                       IN PVOID AddressInFile,
                       IN ULONG SizeToRemove,
                       IN PVOID InsertBuffer,
                       IN ULONG InsertAmount
                       )
{
    NTSTATUS Status;
    ULONG NewEndOfFile, UpdateOffset, UpdateLength;

    NewEndOfFile = a->IniFile->EndOfFile - SizeToRemove + InsertAmount;
    if (NewEndOfFile > a->IniFile->CommitSize) {
        if (NewEndOfFile > a->IniFile->RegionSize) {
            return STATUS_BUFFER_OVERFLOW;
        }

        a->IniFile->CommitSize = NewEndOfFile;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &a->IniFile->BaseAddress,
                                          0,
                                          &a->IniFile->CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            KdPrint(( "BASEDLL: Unable to allocate memory to grow %wZ - Status == %x\n",
                      &a->IniFile->NtFileName,
                      Status
                    ));

            return Status;
        }

        a->IniFile->EndOfFile = NewEndOfFile;
    }

    UpdateOffset = (ULONG)((PCHAR)AddressInFile - (PCHAR)(a->IniFile->BaseAddress)),
                   UpdateLength = (ULONG)((PCHAR)a->TextEnd - (PCHAR)AddressInFile) + InsertAmount - SizeToRemove;
    //
    // Are we deleting more than we are inserting?
    //
    if (SizeToRemove > InsertAmount) {
        //
        // Yes copy over insert string.
        //
        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );

        //
        // Delete remaining text after insertion string by moving it
        // up
        //

        RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount,
                       (PCHAR)AddressInFile + SizeToRemove,
                       UpdateLength - InsertAmount
                     );
    } else
        if (InsertAmount > 0) {
        //
        // Are we deleting less than we are inserting?
        //
        if (SizeToRemove < InsertAmount) {
            //
            // Move text down to make room for insertion
            //

            RtlMoveMemory( (PCHAR)AddressInFile + InsertAmount - SizeToRemove,
                           (PCHAR)AddressInFile,
                           UpdateLength - InsertAmount + SizeToRemove
                         );
        } else {
            //
            // Deleting and inserting same amount, update just that text as
            // no shifting was done.
            //

            UpdateLength = InsertAmount;
        }

        //
        // Copy over insert string
        //

        RtlMoveMemory( AddressInFile, InsertBuffer, InsertAmount );
    } else {
        //
        // Nothing to change, as InsertAmount and SizeToRemove are zero
        //
        return STATUS_SUCCESS;
    }

    if (a->IniFile->EndOfFile != NewEndOfFile) {
        a->IniFile->EndOfFile = NewEndOfFile;
    }

    if (UpdateOffset < a->IniFile->UpdateOffset) {
        a->IniFile->UpdateOffset = UpdateOffset;
    }

    if ((UpdateOffset + UpdateLength) > a->IniFile->UpdateEndOffset) {
        a->IniFile->UpdateEndOffset = UpdateOffset + UpdateLength;
    }

    return STATUS_SUCCESS;
}


VOID
BaseDllCheckInitFromIniFile(
                           IN DWORD Flags,
                           IN ULONG MappingFlags,
                           IN PUNICODE_STRING FileName,
                           IN PUNICODE_STRING ApplicationName,
                           IN PUNICODE_STRING KeyName,
                           IN OUT PWSTR *Buffer,
                           IN OUT PULONG Size
                           );

BOOL
QueryWin31IniFilesMappedToRegistry(
                                  IN DWORD Flags,
                                  OUT PWSTR Buffer,
                                  IN DWORD cchBuffer,
                                  OUT LPDWORD cchUsed
                                  )
{
    BOOL Result;
    PINIFILE_MAPPING_FILENAME FileNameMapping;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PINIFILE_MAPPING_VARNAME VarNameMapping;
    UNICODE_STRING NullString;

    ULONG Size;

    *cchUsed = 0;
    RtlInitUnicodeString( &NullString, NULL );
    Result = TRUE;
    Size = cchBuffer * sizeof( WCHAR );

    FileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->DefaultFileNameMapping;
    if (FileNameMapping != NULL) {
        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
        VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
        BaseDllCheckInitFromIniFile( Flags,
                                     VarNameMapping->MappingFlags,
                                     &NullString,
                                     &NullString,
                                     &NullString,
                                     &Buffer,
                                     &Size
                                   );

    }

    FileNameMapping = (PINIFILE_MAPPING_FILENAME)BaseDllIniFileMapping->FileNames;
    while (FileNameMapping) {
        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;

        if (AppNameMapping != NULL) {

            BASE_READ_REMOTE_STR_TEMP(TempStr);

            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;

            BaseDllCheckInitFromIniFile( Flags,
                                         VarNameMapping->MappingFlags,
                                         BASE_READ_REMOTE_STR(FileNameMapping->Name,TempStr),
                                         &NullString,
                                         &NullString,
                                         &Buffer,
                                         &Size
                                       );

        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->ApplicationNames;
        while (AppNameMapping) {
            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;

            if (VarNameMapping != NULL) {

                BASE_READ_REMOTE_STR_TEMP(TempStr1);
                BASE_READ_REMOTE_STR_TEMP(TempStr2);

                BaseDllCheckInitFromIniFile( Flags,
                                             VarNameMapping->MappingFlags,
                                             BASE_READ_REMOTE_STR(FileNameMapping->Name, TempStr1),
                                             BASE_READ_REMOTE_STR(AppNameMapping->Name, TempStr2),
                                             &NullString,
                                             &Buffer,
                                             &Size
                                           );

            }

            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
            while (VarNameMapping) {

                BASE_READ_REMOTE_STR_TEMP(TempStr1);
                BASE_READ_REMOTE_STR_TEMP(TempStr2);
                BASE_READ_REMOTE_STR_TEMP(TempStr3);

                BaseDllCheckInitFromIniFile( Flags,
                                             VarNameMapping->MappingFlags,
                                             BASE_READ_REMOTE_STR(FileNameMapping->Name,TempStr1),
                                             BASE_READ_REMOTE_STR(AppNameMapping->Name,TempStr2),
                                             BASE_READ_REMOTE_STR(VarNameMapping->Name,TempStr3),
                                             &Buffer,
                                             &Size
                                           );

                VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
            }

            AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
        }

        FileNameMapping = (PINIFILE_MAPPING_FILENAME)FileNameMapping->Next;
    }

    if (Result) {
        *cchUsed = (((cchBuffer * sizeof( WCHAR )) - Size) / sizeof( WCHAR )) + 1;
    }

    return Result;
}

VOID
BaseDllCheckInitFromIniFile(
                           IN DWORD Flags,
                           IN ULONG MappingFlags,
                           IN PUNICODE_STRING FileName,
                           IN PUNICODE_STRING ApplicationName,
                           IN PUNICODE_STRING KeyName,
                           IN OUT PWSTR *Buffer,
                           IN OUT PULONG Size
                           )
{
    PWSTR s;
    ULONG cb;

    if (MappingFlags & INIFILE_MAPPING_INIT_FROM_INIFILE) {
        cb = FileName->Length + sizeof( UNICODE_NULL ) +
             ApplicationName->Length + sizeof( UNICODE_NULL ) +
             KeyName->Length + sizeof( UNICODE_NULL );

        if (MappingFlags & INIFILE_MAPPING_USER_RELATIVE) {
            if (!(Flags & WIN31_INIFILES_MAPPED_TO_USER)) {
                return;
            }
        } else
            if (!(Flags & WIN31_INIFILES_MAPPED_TO_SYSTEM)) {
            return;
        }

        if ((cb+sizeof( UNICODE_NULL )) < *Size) {
            *Size = *Size - cb;
            s = *Buffer;

            if (FileName->Length) {
                RtlMoveMemory( s, FileName->Buffer, FileName->Length );
                s = (PWSTR)((PCHAR)s + FileName->Length);
            }
            *s++ = UNICODE_NULL;

            if (ApplicationName->Length) {
                RtlMoveMemory( s, ApplicationName->Buffer, ApplicationName->Length );
                s = (PWSTR)((PCHAR)s + ApplicationName->Length);
            }
            *s++ = UNICODE_NULL;

            if (KeyName->Length) {
                RtlMoveMemory( s, KeyName->Buffer, KeyName->Length );
                s = (PWSTR)((PCHAR)s + KeyName->Length);
            }
            *s++ = UNICODE_NULL;

            *s = UNICODE_NULL;
            *Buffer = s;
        }
    }

    return;
}


#if DBG

VOID
BaseDllDumpIniFileMappings(
                          PINIFILE_MAPPING IniFileMapping
                          );

VOID
BaseDllPrintMappingTarget(
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping
                         );

VOID
BaseDllDumpIniFileMappings(
                          PINIFILE_MAPPING IniFileMapping
                          )
{
    PINIFILE_MAPPING_FILENAME FileNameMapping;
    PINIFILE_MAPPING_APPNAME AppNameMapping;
    PINIFILE_MAPPING_VARNAME VarNameMapping;

    DbgPrint( "IniFileMapping\n" );
    FileNameMapping = (PINIFILE_MAPPING_FILENAME)IniFileMapping->DefaultFileNameMapping;
    if (FileNameMapping != NULL) {
        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
        VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
        DbgPrint( "    " );
        BaseDllPrintMappingTarget( VarNameMapping );
    }

    FileNameMapping = (PINIFILE_MAPPING_FILENAME)IniFileMapping->FileNames;
    while (FileNameMapping) {
        BASE_READ_REMOTE_STR_TEMP(TempStr);

        DbgPrint( "    %wZ\n",
                  BASE_READ_REMOTE_STR(FileNameMapping->Name,TempStr)
                );

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->DefaultAppNameMapping;
        if (AppNameMapping != NULL) {
            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
            DbgPrint( "        " );
            BaseDllPrintMappingTarget( VarNameMapping );
        }

        AppNameMapping = (PINIFILE_MAPPING_APPNAME)FileNameMapping->ApplicationNames;
        while (AppNameMapping) {
            BASE_READ_REMOTE_STR_TEMP(TempStr);

            DbgPrint( "        %wZ\n",
                      BASE_READ_REMOTE_STR(AppNameMapping->Name,TempStr)
                    );

            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
            if (VarNameMapping != NULL) {
                DbgPrint( "            " );
                BaseDllPrintMappingTarget( VarNameMapping );
            }

            VarNameMapping = (PINIFILE_MAPPING_VARNAME)AppNameMapping->VariableNames;
            while (VarNameMapping) {
                BASE_READ_REMOTE_STR_TEMP(TempStr);

                DbgPrint( "            %wZ ",
                          BASE_READ_REMOTE_STR(VarNameMapping->Name, TempStr) );

                BaseDllPrintMappingTarget( VarNameMapping );
                VarNameMapping = (PINIFILE_MAPPING_VARNAME)VarNameMapping->Next;
            }

            AppNameMapping = (PINIFILE_MAPPING_APPNAME)AppNameMapping->Next;
        }

        FileNameMapping = (PINIFILE_MAPPING_FILENAME)FileNameMapping->Next;
    }

    return;
}


VOID
BaseDllPrintMappingTarget(
                         IN PINIFILE_MAPPING_VARNAME VarNameMapping
                         )
{
    DbgPrint( "= " );

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_WRITE_TO_INIFILE_TOO) {
        DbgPrint( "!" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_INIT_FROM_INIFILE) {
        DbgPrint( "#" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_READ_FROM_REGISTRY_ONLY) {
        DbgPrint( "@" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_USER_RELATIVE) {
        DbgPrint( "USR:" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_SOFTWARE_RELATIVE) {
        DbgPrint( "SYS:" );
    }

    if (VarNameMapping->MappingTarget) {
        BASE_READ_REMOTE_STR_TEMP(TempStr);

        DbgPrint( "%wZ",
                  BASE_READ_REMOTE_STR((((PINIFILE_MAPPING_TARGET)(VarNameMapping->MappingTarget))->RegistryPath), TempStr)
                );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_APPEND_BASE_NAME) {
        DbgPrint( " (Append Base Name)" );
    }

    if (VarNameMapping->MappingFlags &INIFILE_MAPPING_APPEND_APPLICATION_NAME) {
        DbgPrint( " (Append App Name)" );
    }

    DbgPrint( "\n" );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\filehops.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filehops.c

Abstract:

    This module implements Win32 file handle APIs

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/

#include "basedll.h"

HANDLE
WINAPI
GetStdHandle(
    DWORD nStdHandle
    )
{
    PPEB Peb;
    HANDLE rv;


    Peb = NtCurrentPeb();
    switch( nStdHandle ) {
        case STD_INPUT_HANDLE:
            rv = Peb->ProcessParameters->StandardInput;
            break;

        case STD_OUTPUT_HANDLE:
            rv = Peb->ProcessParameters->StandardOutput;
            break;

        case STD_ERROR_HANDLE:
            rv = Peb->ProcessParameters->StandardError;
            break;
        default:
            rv = INVALID_HANDLE_VALUE;
            break;
    }
    if ( rv == INVALID_HANDLE_VALUE ) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        }
    return rv;
}

BOOL
WINAPI
SetStdHandle(
    DWORD nStdHandle,
    HANDLE hHandle
    )
{
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( nStdHandle ) {
        case STD_INPUT_HANDLE:
            Peb->ProcessParameters->StandardInput = hHandle;
            break;

        case STD_OUTPUT_HANDLE:
            Peb->ProcessParameters->StandardOutput = hHandle;
            break;

        case STD_ERROR_HANDLE:
            Peb->ProcessParameters->StandardError = hHandle;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_HANDLE);
            return FALSE;
    }

    return( TRUE );
}

DWORD
WINAPI
GetFileType(
    HANDLE hFile
    )

/*++

Routine Description:

    GetFileType is used to determine the file type of the specified file.

Arguments:

    hFile - Supplies an open handle to a file whose type is to be
        determined

Return Value:

    FILE_TYPE_UNKNOWN - The type of the specified file is unknown.

    FILE_TYPE_DISK - The specified file is a disk file.

    FILE_TYPE_CHAR - The specified file is a character file (LPT,
        console...)

    FILE_TYPE_PIPE - The specified file is a pipe (either a named pipe or
        a pipe created by CreatePipe).

--*/

{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:
            hFile = Peb->ProcessParameters->StandardInput;
            break;
        case STD_OUTPUT_HANDLE:
            hFile = Peb->ProcessParameters->StandardOutput;
            break;
        case STD_ERROR_HANDLE:
            hFile = Peb->ProcessParameters->StandardError;
            break;
    }

    if (CONSOLE_HANDLE(hFile) && VerifyConsoleIoHandle(hFile)) {
        return( FILE_TYPE_CHAR );
    }

    if (hFile == NULL) {
        BaseSetLastNTError( STATUS_INVALID_HANDLE );
        return( FILE_TYPE_UNKNOWN );    
    }

    //
    // If handle cannot be a real kernel handle we will fail
    // the call instead of calling with a bogus value NtQuery.
    //

    if (((ULONG_PTR)hFile & 0x01)) {

        BaseSetLastNTError( STATUS_INVALID_HANDLE );
        return( FILE_TYPE_UNKNOWN );
    }

    Status = NtQueryVolumeInformationFile( hFile,
                                           &IoStatusBlock,
                                           &DeviceInformation,
                                           sizeof( DeviceInformation ),
                                           FileFsDeviceInformation
                                         );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FILE_TYPE_UNKNOWN );
    }

    switch( DeviceInformation.DeviceType ) {

    case FILE_DEVICE_SCREEN:
    case FILE_DEVICE_KEYBOARD:
    case FILE_DEVICE_MOUSE:
    case FILE_DEVICE_PARALLEL_PORT:
    case FILE_DEVICE_PRINTER:
    case FILE_DEVICE_SERIAL_PORT:
    case FILE_DEVICE_MODEM:
    case FILE_DEVICE_SOUND:
    case FILE_DEVICE_NULL:
        return( FILE_TYPE_CHAR );

    case FILE_DEVICE_CD_ROM:
    case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
    case FILE_DEVICE_CONTROLLER:
    case FILE_DEVICE_DATALINK:
    case FILE_DEVICE_DFS:
    case FILE_DEVICE_DISK:
    case FILE_DEVICE_DISK_FILE_SYSTEM:
    case FILE_DEVICE_VIRTUAL_DISK:
        return( FILE_TYPE_DISK );

    case FILE_DEVICE_NAMED_PIPE:
        return( FILE_TYPE_PIPE );

    case FILE_DEVICE_NETWORK:
    case FILE_DEVICE_NETWORK_FILE_SYSTEM:
    case FILE_DEVICE_PHYSICAL_NETCARD:
    case FILE_DEVICE_TAPE:
    case FILE_DEVICE_TAPE_FILE_SYSTEM:
    case FILE_DEVICE_TRANSPORT:
        // FIX, FIX - how to handle tapes, network devices, etc.

    case FILE_DEVICE_UNKNOWN:
    default:
        SetLastError( NO_ERROR );
        return( FILE_TYPE_UNKNOWN );
    }
}

BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be read from a file using ReadFile.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;
    DWORD InputMode;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hFile)) {
        if (ReadConsoleA(hFile,
                        lpBuffer,
                        nNumberOfBytesToRead,
                        lpNumberOfBytesRead,
                        lpOverlapped
                       )
           ) {
            Status = STATUS_SUCCESS;
            if (!GetConsoleMode( hFile, &InputMode )) {
                InputMode = 0;
                }

            if (InputMode & ENABLE_PROCESSED_INPUT) {
                try {
                    if (*(PCHAR)lpBuffer == 0x1A) {
                        *lpNumberOfBytesRead = 0;
                        }
                    }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    Status = GetExceptionCode();
                    }
                }

            if (NT_SUCCESS(Status)) {
                return TRUE;
                }
            else {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            return FALSE;
            }
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                try {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                lpBuffer,
                nNumberOfBytesToRead,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFile.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpNumberOfBytesWritten - Returns the number of bytes written by this
        call. Before doing any work or error processing, the API sets this
        to zero.


    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFile will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hFile)) {
        return WriteConsoleA(hFile,
                            (LPVOID)lpBuffer,
                            nNumberOfBytesToWrite,
                            lpNumberOfBytesWritten,
                            lpOverlapped
                           );
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                try {
                    *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesWritten = 0;
                    }
                }
            return TRUE;
            }
        else  {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
SetEndOfFile(
    HANDLE hFile
    )

/*++

Routine Description:

    The end of file position of an open file can be set to the current
    file pointer using SetEndOfFile.

    This API is used to set the end of file position of a file to the
    same value as the current file pointer.  This has the effect of
    truncating or extending a file.  This functionality is similar to
    DOS (int 21h, function 40H with CX=0).

Arguments:

    hFile - Supplies an open handle to a file that is to be extended or
        truncated.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_END_OF_FILE_INFORMATION EndOfFile;
    FILE_ALLOCATION_INFORMATION Allocation;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Get the current position of the file pointer
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the end of file based on the current file position
    //

    EndOfFile.EndOfFile = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &EndOfFile,
                sizeof(EndOfFile),
                FileEndOfFileInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the allocation based on the current file size
    //

    Allocation.AllocationSize = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &Allocation,
                sizeof(Allocation),
                FileAllocationInformation
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WINAPI
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    lDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpDistanceToMoveHigh - An optional parameter that if specified
        supplies the high order 32-bits of the 64-bit distance to move.
        If the value of this parameter is NULL, this API can only
        operate on files whose maximum size is (2**32)-2.  If this
        parameter is specified, than the maximum file size is (2**64)-2.
        This value also returns the high order 32-bits of the new value
        of the file pointer.  If this value, and the return value
        are 0xffffffff, then an error is indicated.

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    Not -1 - Returns the low order 32-bits of the new value of the file
        pointer.

    0xffffffff - If the value of lpDistanceToMoveHigh was NULL, then The
        operation failed.  Extended error status is available using
        GetLastError.  Otherwise, this is the low order 32-bits of the
        new value of the file pointer.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return (DWORD)-1;
        }

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return (DWORD)-1;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // then 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return (DWORD)-1;
        }
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (DWORD)-1;
        }


    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            SetLastError(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        BaseSetLastNTError(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (DWORD)-1;
        }
}


BOOL
WINAPI
SetFilePointerEx(
    HANDLE hFile,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER lpNewFilePointer,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    liDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpNewFilePointer - An optional parameter that if specified returns
        the new file pointer

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed. Extended error status is available using
        GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }
    Large = liDistanceToMove;

    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
            break;
        }

    //
    // If the resulting file position is negative fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return FALSE;
        }


    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpNewFilePointer)){
            *lpNewFilePointer = CurrentPosition.CurrentByteOffset;
            }
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



BOOL
WINAPI
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    )

/*++

Routine Description:


Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    BY_HANDLE_FILE_INFORMATION LocalFileInformation;
    FILE_ALL_INFORMATION FileInformation;
    FILE_FS_VOLUME_INFORMATION VolumeInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatusBlock,
                &VolumeInfo,
                sizeof(VolumeInfo),
                FileFsVolumeInformation
                );
    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwVolumeSerialNumber = VolumeInfo.VolumeSerialNumber;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &FileInformation,
                sizeof(FileInformation),
                FileAllInformation
                );

    //
    // we really plan for buffer overflow
    //

    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwFileAttributes = FileInformation.BasicInformation.FileAttributes;
        LocalFileInformation.ftCreationTime = *(LPFILETIME)&FileInformation.BasicInformation.CreationTime;
        LocalFileInformation.ftLastAccessTime = *(LPFILETIME)&FileInformation.BasicInformation.LastAccessTime;
        LocalFileInformation.ftLastWriteTime = *(LPFILETIME)&FileInformation.BasicInformation.LastWriteTime;
        LocalFileInformation.nFileSizeHigh = FileInformation.StandardInformation.EndOfFile.HighPart;
        LocalFileInformation.nFileSizeLow = FileInformation.StandardInformation.EndOfFile.LowPart;
        LocalFileInformation.nNumberOfLinks = FileInformation.StandardInformation.NumberOfLinks;
        LocalFileInformation.nFileIndexHigh = FileInformation.InternalInformation.IndexNumber.HighPart;
        LocalFileInformation.nFileIndexLow = FileInformation.InternalInformation.IndexNumber.LowPart;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    *lpFileInformation = LocalFileInformation;
    return TRUE;
}

BOOL
APIENTRY
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be read using GetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastAccessTime - An optional parameter that if specified points to
        the location to return the date and time the file was last accessed.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastWriteTime - An optional parameter that if specified points to
        the location to return the date and time the file was last written.
        A file system must support this time and thus a valid value will
        always be returned for this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Get the attributes
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT( lpCreationTime )) {
            *lpCreationTime = *(LPFILETIME)&BasicInfo.CreationTime;
            }

        if (ARGUMENT_PRESENT( lpLastAccessTime )) {
            *lpLastAccessTime = *(LPFILETIME)&BasicInfo.LastAccessTime;
            }

        if (ARGUMENT_PRESENT( lpLastWriteTime )) {
            *lpLastWriteTime = *(LPFILETIME)&BasicInfo.LastWriteTime;
            }
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
SetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be modified using SetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be written.  The file handle must have been created
        with GENERIC_WRITE access to the file.

    lpCreationTime - An optional parameter, that if specified supplies
        the new creation time for the file.  Some file system's do not
        support this time value, so this parameter may be ignored.

    lpLastAccessTime - An optional parameter, that if specified supplies
        the new last access time for the file.  Some file system's do
        not support this time value, so this parameter may be ignored.

    lpLastWriteTime - An optional parameter, that if specified supplies
        the new last write time for the file.  A file system must support
        this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Zero all the time values we can set.
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
        }

    //
    // Set the requested times.
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
FlushFileBuffers(
    HANDLE hFile
    )

/*++

Routine Description:

    Buffered data may be flushed out to the file using the
    FlushFileBuffers service.

    The FlushFileBuffers service causes all buffered data to be written
    to the specified file.

Arguments:

    hFile - Supplies an open handle to a file whose buffers are to be
        flushed.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hFile)) {
        return( FlushConsoleInputBuffer( hFile ) );
        }

    Status = NtFlushBuffersFile(hFile,&IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
LockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh
    )

/*++

Routine Description:

    A byte range within an open file may be locked for exclusive access
    using LockFile.

    Locking a region of a file is used to aquire exclusive access to the
    specified region of the file.  File locks are not inherited by the
    new process during process creation.

    Locking a portion of a file denies all other processes both read and
    write access to the specified region of the file.  Locking a region
    that goes beyond the current end-of-file position is not an error.

    Locks may not overlap an existing locked region of the file.

    For DOS based systems running share.exe the lock semantics work as
    described above.  Without share.exe, all attempts to lock or unlock
    a file will fail.

Arguments:

    hFile - Supplies an open handle to a file that is to have a range of
        bytes locked for exclusive access.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwFileOffsetLow - Supplies the low order 32-bits of the starting
        byte offset of the file where the lock should begin.

    dwFileOffsetHigh - Supplies the high order 32-bits of the starting
        byte offset of the file where the lock should begin.

    nNumberOfBytesToLockLow - Supplies the low order 32-bits of the length
        of the byte range to be locked.

    nNumberOfBytesToLockHigh - Supplies the high order 32-bits of the length
        of the byte range to be locked.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;
    IO_STATUS_BLOCK IoStatusBlock;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    ByteOffset.LowPart = dwFileOffsetLow;
    ByteOffset.HighPart = dwFileOffsetHigh;

    Length.LowPart = nNumberOfBytesToLockLow;
    Length.HighPart = nNumberOfBytesToLockHigh;

    Status = NtLockFile( hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         &ByteOffset,
                         &Length,
                         0,
                         TRUE,
                         TRUE
                       );

    if (Status == STATUS_PENDING) {

        Status = NtWaitForSingleObject( hFile, FALSE, NULL );
        if (NT_SUCCESS( Status )) {
            Status = IoStatusBlock.Status;
            }
        }

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
WINAPI
LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    A byte range within an open file may be locked for shared or
    exclusive access using LockFileEx.

    Locking a region of a file is used to aquire shared or exclusive
    access to the specified region of the file.  File locks are not
    inherited by the new process during process creation.

    Locking a portion of a file for exclusive access denies all other
    processes both read and write access to the specified region of the
    file.  Locking a region that goes beyond the current end-of-file
    position is not an error.

    Locking a portion of a file for shared access denies all other
    processes write access to the specified region of the file, but
    allows other processes to read the locked region.

    If requesting an exclusive lock for a file that is already locked
    shared or exclusively by other threads, then this call will wait
    until the lock is granted unless the LOCKFILE_FAIL_IMMEDIATELY
    flag is specified.

    Locks may not overlap an existing locked region of the file.

Arguments:

    hFile - Supplies an open handle to a file that is to have a range of
        bytes locked for exclusive access.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwFlags - Supplies flag bits that modify the behavior of this function.

        LOCKFILE_FAIL_IMMEDIATELY - if set, then this function will return
            immediately if it is unable to acquire the requested lock.
            Otherwise it will wait.

        LOCKFILE_EXCLUSIVE_LOCK - if set, then this function requests an
            exclusive lock, otherwise it requested a shared lock.

    dwReserved - Reserved parameter that must be zero.

    nNumberOfBytesToLockLow - Supplies the low order 32-bits of the length
        of the byte range to be locked.

    nNumberOfBytesToLockHigh - Supplies the high order 32-bits of the length
        of the byte range to be locked.

    lpOverlapped - Required pointer to an OVERLAPPED structure to be
        used with the request.  It contains the file offset of the
        beginning of the lock range.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if (dwReserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    ByteOffset.LowPart = lpOverlapped->Offset;
    ByteOffset.HighPart = lpOverlapped->OffsetHigh;

    Length.LowPart = nNumberOfBytesToLockLow;
    Length.HighPart = nNumberOfBytesToLockHigh;
    lpOverlapped->Internal = (DWORD)STATUS_PENDING;

    Status = NtLockFile( hFile,
                         lpOverlapped->hEvent,
                         NULL,
                         (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                         (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                         &ByteOffset,
                         &Length,
                         0,
                         (BOOLEAN)((dwFlags & LOCKFILE_FAIL_IMMEDIATELY) ? TRUE : FALSE),
                         (BOOLEAN)((dwFlags & LOCKFILE_EXCLUSIVE_LOCK) ? TRUE : FALSE)
                       );

    if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
WINAPI
UnlockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh
    )

/*++

Routine Description:

    A previously locked byte range within an open file may be Unlocked
    using UnlockFile.

    Unlocking a region of a file is used release a previously aquired
    lock on a file.  The region to unlock must exactly correspond to an
    existing locked region.  Two adjacent regions of a file can not be
    locked seperately and then be unlocked using a single region that
    spans both locked regions.

    If a process terminates with a portion of a file locked, or closes a
    file that has outstanding locks, the behavior is not specified.

    For DOS based systems running share.exe the lock semantics work as
    described above.  Without share.exe, all attempts to lock or unlock
    a file will fail.

Arguments:

    hFile - Supplies an open handle to a file that is to have an
        existing locked region unlocked.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwFileOffsetLow - Supplies the low order 32-bits of an existing
        locked region to be unlocked.

    dwFileOffsetHigh - Supplies the high order 32-bits of an existing
        locked region to be unlocked.

    nNumberOfBytesToUnlockLow - Supplies the low order 32-bits of the
        length of the byte range to be unlocked.

    nNumberOfBytesToUnlockHigh - Supplies the high order 32-bits of the
        length of the byte range to be unlocked.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL bResult;
    OVERLAPPED Overlapped;
    NTSTATUS Status;

    Overlapped.Offset = dwFileOffsetLow;
    Overlapped.OffsetHigh = dwFileOffsetHigh;
    bResult = UnlockFileEx( hFile,
                            0,
                            nNumberOfBytesToUnlockLow,
                            nNumberOfBytesToUnlockHigh,
                            &Overlapped
                          );
    if (!bResult && GetLastError() == ERROR_IO_PENDING) {
        Status = NtWaitForSingleObject( hFile, FALSE, NULL );
        if (NT_SUCCESS( Status )) {
            Status = (NTSTATUS)Overlapped.Internal;
            }

        if ( NT_SUCCESS(Status) ) {
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        return bResult;
        }
}



BOOL
WINAPI
UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    A previously locked byte range within an open file may be Unlocked
    using UnlockFile.

    Unlocking a region of a file is used release a previously aquired
    lock on a file.  The region to unlock must exactly correspond to an
    existing locked region.  Two adjacent regions of a file can not be
    locked seperately and then be unlocked using a single region that
    spans both locked regions.

    If a process terminates with a portion of a file locked, or closes a
    file that has outstanding locks, the behavior is not specified.

Arguments:

    hFile - Supplies an open handle to a file that is to have an
        existing locked region unlocked.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwReserved - Reserved parameter that must be zero.

    nNumberOfBytesToUnlockLow - Supplies the low order 32-bits of the
        length of the byte range to be unlocked.

    nNumberOfBytesToUnlockHigh - Supplies the high order 32-bits of the
        length of the byte range to be unlocked.

    lpOverlapped - Required pointer to an OVERLAPPED structure to be
        used with the request.  It contains the file offset of the
        beginning of the lock range.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if (dwReserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    ByteOffset.LowPart = lpOverlapped->Offset;
    ByteOffset.HighPart = lpOverlapped->OffsetHigh;

    Length.LowPart = nNumberOfBytesToUnlockLow;
    Length.HighPart = nNumberOfBytesToUnlockHigh;

    Status = NtUnlockFile(
                hFile,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                &ByteOffset,
                &Length,
                0
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

UINT
WINAPI
SetHandleCount(
    UINT uNumber
    )

/*++

Routine Description:

    This function changes the number of file handles available to a
    process.  For DOS based Win32, the default maximum number of file
    handles available to a process is 20.  For NT/Win32 systems, this
    API has no effect.

Arguments:

    uNumber - Specifies the number of file handles needed by the
        application.  The maximum is 255.

Return Value:

    The return value specifies the number of file handles actually
    available to the application.  It may be less than the number
    specified by the wNumber parameter.

--*/

{
    return uNumber;
}

DWORD
WINAPI
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

    The return value contains the low order 32-bits of the file's size.
    The optional lpFileSizeHigh returns the high order 32-bits of the
    file's size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSizeHigh - An optional parameter, that if specified, returns
        the high order 64-bits of the file's size.


Return Value:

    Not -1 - Returns the low order 32-bits of the specified file's size.


    0xffffffff - If the value of size of the file cannot be determined,
        or an invalid handle or handle with inappropriate access, or a
        handle to a non-file is specified, this error is returned.  If
        the file's size (low 32-bits) is -1, then this value is
        returned, and GetLastError() will return 0.  Extended error
        status is available using GetLastError.


--*/

{
    BOOL b;
    LARGE_INTEGER Li;

    b = GetFileSizeEx(hFile,&Li);

    if ( b ) {

        if ( ARGUMENT_PRESENT(lpFileSizeHigh) ) {
            *lpFileSizeHigh = (DWORD)Li.HighPart;
            }
        if (Li.LowPart == -1 ) {
            SetLastError(0);
            }
        }
    else {
        Li.LowPart = -1;
        }

    return Li.LowPart;
}

BOOL
WINAPI
GetFileSizeEx(
    HANDLE hFile,
    PLARGE_INTEGER lpFileSize
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSize - Returns the files size


Return Value:

    TRUE - The operation was successful


    FALSE - The operation failed. Extended error
        status is available using GetLastError.


--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        *lpFileSize = StandardInfo.EndOfFile;
        return TRUE;
        }
}

VOID
WINAPI
BasepIoCompletion(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )


/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/

{
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock;
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    DWORD dwErrorCode;
    DWORD dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    PACTIVATION_CONTEXT ActivationContext = NULL;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
    } else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (DWORD)IoStatusBlock->Information;
    }

    ActivationBlock = (PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK) ApcContext;
    ActivationContext = ActivationBlock->ActivationContext;
    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE) ActivationBlock->CallbackFunction;
    lpOverlapped = (LPOVERLAPPED) CONTAINING_RECORD(IoStatusBlock, OVERLAPPED, Internal);

    if (!(ActivationBlock->Flags & BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK))
        BasepFreeActivationContextActivationBlock(ActivationBlock);

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
    __try {
        (*CompletionRoutine)(dwErrorCode, dwNumberOfBytesTransfered, lpOverlapped);
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }

    Reserved;
}

VOID
WINAPI
BasepIoCompletionSimple(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )


/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/

{
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    DWORD dwErrorCode;
    DWORD dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;

    dwErrorCode = 0;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
        }
    else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (DWORD)IoStatusBlock->Information;
        }

    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE)ApcContext;
    lpOverlapped = (LPOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,OVERLAPPED,Internal);

    (CompletionRoutine)(dwErrorCode,dwNumberOfBytesTransfered,lpOverlapped);

    Reserved;
}

BOOL
WINAPI
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be read from a file using ReadFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the read is to begin from.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.  If this call fails because the
    thread issued a read beyond the end of file, GetLastError will
    return a value of ERROR_HANDLE_EOF.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.  The file must have been created with the
        FILE_FLAG_OVERLAPPED flag.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the read from.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;
    PIO_APC_ROUTINE IoApcRoutine = &BasepIoCompletionSimple;
    PVOID ApcContext = lpCompletionRoutine;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    // If there's an APC routine to call we need to allocate a little chunk of heap
    // to pass the activation context to the APC callback.
    if (lpCompletionRoutine != NULL) {
        Status = BasepAllocateActivationContextActivationBlock(
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT,
            lpCompletionRoutine,
            lpOverlapped,
            &ActivationBlock);
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        // If there's nothing to do, call the simpler one that doesn't try to do activation context stuff
        if (ActivationBlock != NULL) {
            IoApcRoutine = &BasepIoCompletion;
            ApcContext = ActivationBlock;
        }
    }

    Status = NtReadFile(
                hFile,
                NULL,
                IoApcRoutine,
                ApcContext,
                (PIO_STATUS_BLOCK) &lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );
    if ( NT_ERROR(Status) ) {
        if (ActivationBlock != NULL)
            BasepFreeActivationContextActivationBlock(ActivationBlock);
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the write is to begin.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the write to.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;
    PIO_APC_ROUTINE IoApcRoutine = &BasepIoCompletionSimple;
    PVOID ApcContext = lpCompletionRoutine;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    // If there's an APC routine to call we may need to allocate a little chunk of heap
    // to pass to the APC callback.
    //
    // we'll replace the parameters to the common NtWriteFile call below so that
    // the control flow is obvious.
    //
    if (lpCompletionRoutine != NULL) {
        Status = BasepAllocateActivationContextActivationBlock(
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT,
            lpCompletionRoutine,
            lpOverlapped,
            &ActivationBlock);
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        // If there's nothing to do, call the simpler one that doesn't try to do activation context stuff
        if (ActivationBlock != NULL) {
            IoApcRoutine = &BasepIoCompletion;
            ApcContext = ActivationBlock;
        }
    }

    Status = NtWriteFile(
                hFile,
                NULL,
                IoApcRoutine,
                ApcContext,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (LPVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );
    if ( NT_ERROR(Status) ) {
        if (ActivationBlock != NULL) {
            BasepFreeActivationContextActivationBlock(ActivationBlock);
        }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            try {
                *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                *lpBytesReturned = 0;
                }
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
CancelIo(
    HANDLE hFile
    )

/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Simply cancel the I/O for the specified file.
    //

    Status = NtCancelIoFile(hFile, &IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }

}

BOOL
WINAPI
ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Data can be read from a file using ReadFileScatter.  The data
    is then scatter to specified buffer segements.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the file.

    lpReserved - Reserved for now.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LPDWORD lpNumberOfBytesRead = NULL;

    if ( ARGUMENT_PRESENT(lpReserved) ||
         !ARGUMENT_PRESENT( lpOverlapped )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

        }

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFileScatter(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                try {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFileScatter(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToRead,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileGather.  The data can
    be in multple file segement buffers.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary. The number of
        entries in the array must be equal to nNumberOfBytesToRead /
        PAGE_SIZE.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpReserved - Unused for now.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFileGather will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LPDWORD lpNumberOfBytesWritten = NULL;

    if ( ARGUMENT_PRESENT(lpReserved) ||
         !ARGUMENT_PRESENT( lpOverlapped )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

        }

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFileGather(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                try {
                    *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesWritten = 0;
                    }
                }
            return TRUE;
            }
        else  {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFileGather(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToWrite,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
APIENTRY
SetFileValidData(
    IN HANDLE hFile,
    IN LONGLONG ValidDataLength
    )

/*++

Routine Description:

    SetFileValidData is used to set the valid data length for the given file.

Arguments:

    hFile - Supplies an open handle to a file whose type valid data
        length is to be set

    ValidDataLength - Supplies the desired valid data length

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_VALID_DATA_LENGTH_INFORMATION ValidDataInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
    }

    ValidDataInfo.ValidDataLength.QuadPart = ValidDataLength;

    Status = NtSetInformationFile(
        hFile,
        &IoStatusBlock,
        &ValidDataInfo,
        sizeof(FILE_VALID_DATA_LENGTH_INFORMATION),
        FileValidDataLengthInformation
        );
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
SetFileShortNameW(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    )

/*++

Routine Description:

    SetFileShortNameW is used to set the short name for the given file.

Arguments:

    hFile - Supplies an open handle to a file whose short name is to be changed

    lpShortName - Supplies the desired short name

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAME_INFORMATION FileNameInfo;
    DWORD FileNameInfoSize;
    DWORD FileInformationClass;


    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(lpShortName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    FileNameInfoSize = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) + ((wcslen(lpShortName)+1)*sizeof(WCHAR));
    FileNameInfo = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG(TMP_TAG), FileNameInfoSize );
    if (!FileNameInfo) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    FileNameInfo->FileNameLength = wcslen(lpShortName) * sizeof(WCHAR);
    wcscpy( FileNameInfo->FileName, lpShortName );

    Status = NtSetInformationFile(
        hFile,
        &IoStatusBlock,
        FileNameInfo,
        FileNameInfoSize,
        FileShortNameInformation
        );

    RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    FileInformationClass = FileShortNameInformation;

    if ((FileInformationClass == FileEndOfFileInformation) ||
         (FileInformationClass == FileAllocationInformation) ||
         (FileInformationClass == FilePositionInformation))
    {
        return FALSE;
    }



    return TRUE;
}


BOOL
APIENTRY
SetFileShortNameA(
    IN HANDLE hFile,
    IN LPCSTR lpShortName
    )

/*++

Routine Description:

    SetFileShortNameW is used to set the short name for the given file.

Arguments:

    hFile - Supplies an open handle to a file whose short name is to be changed

    lpShortName - Supplies the desired short name

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpShortName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( SetFileShortNameW(
                hFile,
                (LPCWSTR)Unicode->Buffer
                )
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\filefind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filefind.c

Abstract:

    This module implements Win32 FindFirst/FindNext

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

VOID
WINAPI
BasepIoCompletion(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

VOID
WINAPI
BasepIoCompletionSimple(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

#define FIND_BUFFER_SIZE 4096

PFINDFILE_HANDLE
BasepInitializeFindFileHandle(
    IN HANDLE DirectoryHandle
    )
{
    PFINDFILE_HANDLE FindFileHandle;

    FindFileHandle = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( FIND_TAG ), sizeof(*FindFileHandle));
    if ( FindFileHandle ) {
        FindFileHandle->DirectoryHandle = DirectoryHandle;
        FindFileHandle->FindBufferBase = NULL;
        FindFileHandle->FindBufferNext = NULL;
        FindFileHandle->FindBufferLength = 0;
        FindFileHandle->FindBufferValidLength = 0;
        if ( !NT_SUCCESS(RtlInitializeCriticalSection(&FindFileHandle->FindBufferLock)) ){
            RtlFreeHeap(RtlProcessHeap(), 0,FindFileHandle);
            FindFileHandle = NULL;
            }
        }
    return FindFileHandle;
}

HANDLE
APIENTRY
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    ANSI thunk to FindFirstFileW

--*/

{
    HANDLE ReturnValue;
    PUNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;
    ANSI_STRING AnsiString;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }
        
    ReturnValue = FindFirstFileExW(
                    (LPCWSTR)Unicode->Buffer,
                    FindExInfoStandard,
                    &FindFileData,
                    FindExSearchNameMatch,
                    NULL,
                    0
                    );

    if ( ReturnValue == INVALID_HANDLE_VALUE ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG_PTR)&FindFileData.cFileName[0] - (ULONG_PTR)&FindFileData
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileData->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileData->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        FindClose(ReturnValue);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }
    return ReturnValue;
}

HANDLE
APIENTRY
FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFile.

    This API is provided to open a find file handle and return
    information about the first file whose name match the specified
    pattern.  Once established, the find file handle can be used to
    search for other files that match the same pattern.  When the find
    file handle is no longer needed, it should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Eh), and OS/2's
    DosFindFirst.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file:

        WIN32_FIND_DATA Structure:

        DWORD dwFileAttributes - Returns the file attributes of the found
            file.

        FILETIME ftCreationTime - Returns the time that the file was created.
            A value of 0,0 specifies that the file system containing the
            file does not support this time field.

        FILETIME ftLastAccessTime - Returns the time that the file was last
            accessed.  A value of 0,0 specifies that the file system
            containing the file does not support this time field.

        FILETIME ftLastWriteTime - Returns the time that the file was last
            written.  A file systems support this time field.

        DWORD nFileSizeHigh - Returns the high order 32 bits of the
            file's size.

        DWORD nFileSizeLow - Returns the low order 32-bits of the file's
            size in bytes.

        UCHAR cFileName[MAX_PATH] - Returns the null terminated name of
            the file.

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FindFirstFileExW(
                lpFileName,
                FindExInfoStandard,
                lpFindFileData,
                FindExSearchNameMatch,
                NULL,
                0
                );
}



BOOL
APIENTRY
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )

/*++

Routine Description:

    ANSI thunk to FindFileDataW

--*/

{

    BOOL ReturnValue;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;

    ReturnValue = FindNextFileW(hFindFile,&FindFileData);
    if ( !ReturnValue ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG_PTR)&FindFileData.cFileName[0] - (ULONG_PTR)&FindFileData
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileData->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileData->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return ReturnValue;
}

BOOL
APIENTRY
FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    Once a successful call has been made to FindFirstFile, subsequent
    matching files can be located using FindNextFile.

    This API is used to continue a file search from a previous call to
    FindFirstFile.  This API returns successfully with the next file
    that matches the search pattern established in the original
    FindFirstFile call.  If no file match can be found NO_MORE_FILES is
    returned.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Fh), and OS/2's
    DosFindNext.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFINDFILE_HANDLE FindFileHandle;
    BOOL ReturnValue;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;

    if ( hFindFile == BASE_FIND_FIRST_DEVICE_HANDLE ) {
        BaseSetLastNTError(STATUS_NO_MORE_FILES);
        return FALSE;
        }

    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }

    ReturnValue = TRUE;
    FindFileHandle = (PFINDFILE_HANDLE)hFindFile;
    RtlEnterCriticalSection(&FindFileHandle->FindBufferLock);
    try {

        //
        // If we haven't called find next yet, then
        // allocate the find buffer.
        //

        if ( !FindFileHandle->FindBufferBase ) {
            FindFileHandle->FindBufferBase = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( FIND_TAG ), FIND_BUFFER_SIZE);
            if (FindFileHandle->FindBufferBase) {
                FindFileHandle->FindBufferNext = FindFileHandle->FindBufferBase;
                FindFileHandle->FindBufferLength = FIND_BUFFER_SIZE;
                FindFileHandle->FindBufferValidLength = 0;
                }
            else {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ReturnValue = FALSE;
                goto leavefinally;
                }
            }

        //
        // Test to see if there is no data in the find file buffer
        //

        DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)FindFileHandle->FindBufferNext;
        if ( FindFileHandle->FindBufferBase == (PVOID)DirectoryInfo ) {

            Status = NtQueryDirectoryFile(
                        FindFileHandle->DirectoryHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        DirectoryInfo,
                        FindFileHandle->FindBufferLength,
                        FileBothDirectoryInformation,
                        FALSE,
                        NULL,
                        FALSE
                        );

            //
            //  ***** Do a kludge hack fix for now *****
            //
            //  Forget about the last, partial, entry.
            //

            if ( Status == STATUS_BUFFER_OVERFLOW ) {

                PULONG Ptr;
                PULONG PriorPtr;

                Ptr = (PULONG)DirectoryInfo;
                PriorPtr = NULL;

                while ( *Ptr != 0 ) {

                    PriorPtr = Ptr;
                    Ptr += (*Ptr / sizeof(ULONG));
                }

                if (PriorPtr != NULL) { *PriorPtr = 0; }
                Status = STATUS_SUCCESS;
            }

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = FALSE;
                goto leavefinally;
                }
            }

        if ( DirectoryInfo->NextEntryOffset ) {
            FindFileHandle->FindBufferNext = (PVOID)(
                (PUCHAR)DirectoryInfo + DirectoryInfo->NextEntryOffset);
            }
        else {
            FindFileHandle->FindBufferNext = FindFileHandle->FindBufferBase;
            }

        //
        // Attributes are composed of the attributes returned by NT.
        //

        lpFindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
        lpFindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
        lpFindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
        lpFindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
        lpFindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
        lpFindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

        RtlMoveMemory( lpFindFileData->cFileName,
                       DirectoryInfo->FileName,
                       DirectoryInfo->FileNameLength );

        lpFindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

        RtlMoveMemory( lpFindFileData->cAlternateFileName,
                       DirectoryInfo->ShortName,
                       DirectoryInfo->ShortNameLength );

        lpFindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

        //
        // For NTFS reparse points we return the reparse point data tag in dwReserved0.
        //

        if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
            lpFindFileData->dwReserved0 = DirectoryInfo->EaSize;
            }

leavefinally:;
        }
    finally{
        RtlLeaveCriticalSection(&FindFileHandle->FindBufferLock);
        }
    return ReturnValue;
}

BOOL
FindClose(
    HANDLE hFindFile
    )

/*++

Routine Description:

    A find file context created by FindFirstFile can be closed using
    FindClose.

    This API is used to inform the system that a find file handle
    created by FindFirstFile is no longer needed.  On systems that
    maintain internal state for each find file context, this API informs
    the system that this state no longer needs to be maintained.

    Once this call has been made, the hFindFile may not be used in a
    subsequent call to either FindNextFile or FindClose.

    This API has no DOS counterpart, but is similar to OS/2's
    DosFindClose.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile that is no longer needed.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PFINDFILE_HANDLE FindFileHandle;
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;

    if ( hFindFile == BASE_FIND_FIRST_DEVICE_HANDLE ) {
        return TRUE;
        }

    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }

    try {

        FindFileHandle = (PFINDFILE_HANDLE)hFindFile;
        RtlEnterCriticalSection(&FindFileHandle->FindBufferLock);
        DirectoryHandle = FindFileHandle->DirectoryHandle;
        FindBufferBase = FindFileHandle->FindBufferBase;
        FindFileHandle->DirectoryHandle = INVALID_HANDLE_VALUE;
        FindFileHandle->FindBufferBase = NULL;
        RtlLeaveCriticalSection(&FindFileHandle->FindBufferLock);

        Status = NtClose(DirectoryHandle);
        if ( NT_SUCCESS(Status) ) {
            if (FindBufferBase) {
                RtlFreeHeap(RtlProcessHeap(), 0,FindBufferBase);
                }
            RtlDeleteCriticalSection(&FindFileHandle->FindBufferLock);
            RtlFreeHeap(RtlProcessHeap(), 0,FindFileHandle);
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        BaseSetLastNTError(GetExceptionCode());
        return FALSE;
        }
    return FALSE;
}

HANDLE
WINAPI
FindFirstFileExA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    )
{
    HANDLE ReturnValue;
    PUNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WIN32_FIND_DATAW FindFileData;
    LPWIN32_FIND_DATAA lpFindFileDataA;
    ANSI_STRING AnsiString;

    //
    // this code assumes that only FindExInfoStandard is supperted by ExW version
    // when more info levels are added, the W->A translation code needs to be modified
    //

    lpFindFileDataA = (LPWIN32_FIND_DATAA)lpFindFileData;
    
    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }
        
    ReturnValue = FindFirstFileExW(
                    (LPCWSTR)Unicode->Buffer,
                    fInfoLevelId,
                    (LPVOID)&FindFileData,
                    fSearchOp,
                    lpSearchFilter,
                    dwAdditionalFlags
                    );

    if ( ReturnValue == INVALID_HANDLE_VALUE ) {
        return ReturnValue;
        }
    RtlMoveMemory(
        lpFindFileData,
        &FindFileData,
        (ULONG_PTR)&FindFileData.cFileName[0] - (ULONG_PTR)&FindFileData
        );
    RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cFileName);
    AnsiString.Buffer = lpFindFileDataA->cFileName;
    AnsiString.MaximumLength = MAX_PATH;
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString,(PWSTR)FindFileData.cAlternateFileName);
        AnsiString.Buffer = lpFindFileDataA->cAlternateFileName;
        AnsiString.MaximumLength = 14;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        FindClose(ReturnValue);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }
    return ReturnValue;

}

HANDLE
WINAPI
FindFirstFileExW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFileEx.

    This API is provided to open a find file handle and return
    information about the first file whose name matchs the specified
    pattern.  If the fSearchOp is FindExSearchNameMatch, then that is
    the extent of the filtering, and lpSearchFilter MUST be NULL.
    Otherwise, additional subfiltering is done depending on this value.

        FindExSearchLimitToDirectories - If this search op is specified,
            then lpSearchFilter MUST be NULL.  For each file that
            matches the specified filename, and that is a directory, and
            entry for that file is returned.

            If the underlying file/io system does not support this type
            of filtering, the API will fail with ERROR_NOT_SUPPORTED,
            and the application will have to perform its own filtering
            by calling this API with FindExSearchNameMatch.

        FindExSearchLimitToDevices - If this search op is specified, the
            lpFileName MUST be *, and FIND_FIRST_EX_CASE_SENSITIVE
            must NOT be specified.  Only device names are returned.
            Device names are generally accessible through
            \\.\name-of-device naming.

    The data returned by this API is dependent on the fInfoLevelId.

        FindExInfoStandard - The lpFindFileData pointer is the standard
            LPWIN32_FIND_DATA structure.

        At this time, no other information levels are supported


    Once established, the find file handle can be used to search for
    other files that match the same pattern with the same filtering
    being performed.  When the find file handle is no longer needed, it
    should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFileEx.

    This API is a complete superset of existing FindFirstFile. FindFirstFile
    could be coded as the following macro:

#define FindFirstFile(a,b)
    FindFirstFileEx((a),FindExInfoStandard,(b),FindExSearchNameMatch,NULL,0);


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    fInfoLevelId - Supplies the info level of the returned data.

    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

    fSearchOp - Specified the type of filtering to perform above and
        beyond simple wildcard matching.

    lpSearchFilter - If the specified fSearchOp needs structured search
        information, this pointer points to the search criteria.  At
        this point in time, both search ops do not require extended
        search information, so this pointer is NULL.

    dwAdditionalFlags - Supplies additional flag values that control the
        search.  A flag value of FIND_FIRST_EX_CASE_SENSITIVE can be
        used to cause case sensitive searches to occur.  The default is
        case insensitive.

Return Value:

    Not -1 - Returns a find first handle that can be used in a
        subsequent call to FindNextFileEx or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

#define FIND_FIRST_EX_INVALID_FLAGS (~FIND_FIRST_EX_CASE_SENSITIVE)
    HANDLE hFindFile;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
        } Buffer;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    UNICODE_STRING UnicodeInput;
    PFINDFILE_HANDLE FindFileHandle;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    BOOLEAN StrippedTrailingSlash;

    //
    // check parameters
    //

    if ( fInfoLevelId >= FindExInfoMaxInfoLevel ||
         fSearchOp >= FindExSearchLimitToDevices ||
        dwAdditionalFlags & FIND_FIRST_EX_INVALID_FLAGS ) {
        SetLastError(fSearchOp == FindExSearchLimitToDevices ? ERROR_NOT_SUPPORTED : ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
        }

    FindFileData = (LPWIN32_FIND_DATAW)lpFindFileData;

    RtlInitUnicodeString(&UnicodeInput,lpFileName);

    //
    // Bogus code to workaround ~* problem
    //

    if ( UnicodeInput.Buffer[(UnicodeInput.Length>>1)-1] == (WCHAR)'.' ) {
        EndsInDot = TRUE;
        }
    else {
        EndsInDot = FALSE;
        }


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
    } else {
        FileName.Length = 0;
        }

    FileName.MaximumLength = FileName.Length;
    if ( RelativeName.RelativeName.Length &&
         RelativeName.RelativeName.Buffer != (PUCHAR)FileName.Buffer ) {

        if (FileName.Buffer) {
            PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)RelativeName.RelativeName.Buffer);
            PathName.MaximumLength = PathName.Length;
            PathName.Buffer = (PWSTR)RelativeName.RelativeName.Buffer;
            }

        }
    else {
        RelativeName.ContainingDirectory = NULL;

        if (FileName.Buffer) {
            PathName.Length = (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
            PathName.MaximumLength = PathName.Length;
            }
        }
    if ( PathName.Buffer[(PathName.Length>>1)-2] != (WCHAR)':' &&
         PathName.Buffer[(PathName.Length>>1)-1] != (WCHAR)'\\'   ) {

        PathName.Length -= sizeof(UNICODE_NULL);
        StrippedTrailingSlash = TRUE;
        }
    else {
        StrippedTrailingSlash = FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        dwAdditionalFlags & FIND_FIRST_EX_CASE_SENSITIVE ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(
                &hFindFile,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( (Status == STATUS_INVALID_PARAMETER ||
          Status == STATUS_NOT_A_DIRECTORY) && StrippedTrailingSlash ) {
        //
        // open of a pnp style path failed, so try putting back the trailing slash
        //
        PathName.Length += sizeof(UNICODE_NULL);
        Status = NtOpenFile(
                    &hFindFile,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );
        PathName.Length -= sizeof(UNICODE_NULL);
        }

    if ( !NT_SUCCESS(Status) ) {
        ULONG DeviceNameData;
        UNICODE_STRING DeviceName;

        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

        //
        // The full path does not refer to a directory. This could
        // be a device. Check for a device name.
        //

        if ( DeviceNameData = RtlIsDosDeviceName_U(UnicodeInput.Buffer) ) {
            DeviceName.Length = (USHORT)(DeviceNameData & 0xffff);
            DeviceName.MaximumLength = (USHORT)(DeviceNameData & 0xffff);
            DeviceName.Buffer = (PWSTR)
                ((PUCHAR)UnicodeInput.Buffer + (DeviceNameData >> 16));
            return BaseFindFirstDevice(&DeviceName,FindFileData);
            }

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    //
    // Get an entry
    //

    //
    // If there is no file part, but we are not looking at a device,
    // then bail.
    //

    if ( !FileName.Length ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        NtClose(hFindFile);
        SetLastError(ERROR_FILE_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    DirectoryInfo = &Buffer.DirInfo;

    //
    //  Special case *.* to * since it is so common.  Otherwise transmogrify
    //  the input name according to the following rules:
    //
    //  - Change all ? to DOS_QM
    //  - Change all . followed by ? or * to DOS_DOT
    //  - Change all * followed by a . into DOS_STAR
    //
    //  These transmogrifications are all done in place.
    //

    if ( (FileName.Length == 6) &&
         (RtlCompareMemory(FileName.Buffer, L"*.*", 6) == 6) ) {

        FileName.Length = 2;

    } else {

        ULONG Index;
        WCHAR *NameChar;

        for ( Index = 0, NameChar = FileName.Buffer;
              Index < FileName.Length/sizeof(WCHAR);
              Index += 1, NameChar += 1) {

            if (Index && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar - 1) = DOS_STAR;
            }

            if ((*NameChar == L'?') || (*NameChar == L'*')) {

                if (*NameChar == L'?') { *NameChar = DOS_QM; }

                if (Index && *(NameChar-1) == L'.') { *(NameChar-1) = DOS_DOT; }
            }
        }

        if (EndsInDot && *(NameChar - 1) == L'*') { *(NameChar-1) = DOS_STAR; }
    }

    Status = NtQueryDirectoryFile(
                hFindFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                DirectoryInfo,
                sizeof(Buffer),
                FileBothDirectoryInformation,
                TRUE,
                &FileName,
                FALSE
                );

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        NtClose(hFindFile);
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlMoveMemory( FindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlMoveMemory( FindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    //
    // For NTFS reparse points we return the reparse point data tag in dwReserved0.
    //

    if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        FindFileData->dwReserved0 = DirectoryInfo->EaSize;
        }

    FindFileHandle = BasepInitializeFindFileHandle(hFindFile);
    if ( !FindFileHandle ) {
        NtClose(hFindFile);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
        }

    return (HANDLE)FindFileHandle;

}

HANDLE
BaseFindFirstDevice(
    PCUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )

/*++

Routine Description:

    This function is called when find first file encounters a device
    name. This function returns a successful psuedo file handle and
    fills in the find file data with all zeros and the devic name.

Arguments:

    FileName - Supplies the device name of the file to find.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    Always returns a static find file handle value of
    BASE_FIND_FIRST_DEVICE_HANDLE

--*/

{
    RtlZeroMemory(lpFindFileData,sizeof(*lpFindFileData));
    lpFindFileData->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;
    RtlMoveMemory(
        &lpFindFileData->cFileName[0],
        FileName->Buffer,
        FileName->MaximumLength
        );
    return BASE_FIND_FIRST_DEVICE_HANDLE;
}

HANDLE
APIENTRY
FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )

/*++

Routine Description:

    ANSI thunk to FindFirstChangeNotificationW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpPathName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }
    return ( FindFirstChangeNotificationW(
                (LPCWSTR)Unicode->Buffer,
                bWatchSubtree,
                dwNotifyFilter
                )
            );
}

//
// this is a hack... darrylh, please remove when NT supports null
// buffers to change notify
//

char staticchangebuff[sizeof(FILE_NOTIFY_INFORMATION) + 16];
IO_STATUS_BLOCK staticIoStatusBlock;

HANDLE
APIENTRY
FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )

/*++

Routine Description:

    This API is used to create a change notification handle and to set
    up the initial change notification filter conditions.

    If successful, this API returns a waitable notification handle.  A
    wait on a notification handle is successful when a change matching
    the filter conditions occurs in the directory or subtree being
    watched.

    Once a change notification object is created and the initial filter
    conditions are set, the appropriate directory or subtree is
    monitored by the system for changes that match the specified filter
    conditions.  When one of these changes occurs, a change notification
    wait is satisfied.  If a change occurs without an outstanding change
    notification request, it is remembered by the system and will
    satisfy the next change notification wait.

    Note that this means that after a call to
    FindFirstChangeNotification is made, the application should wait on
    the notification handle before making another call to
    FindNextChangeNotification.

Arguments:

    lpPathName - Supplies the pathname of the directory to be watched.
        This path must specify the pathname of a directory.

    bWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the directory tree rooted at the specified
        directory.  A value of FALSE causes the system to monitor only
        the specified directory.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a change notification
        wait.

        FILE_NOTIFY_CHANGE_FILENAME - Any file name changes that occur
            in a directory or subtree being watched will satisfy a
            change notification wait.  This includes renames, creations,
            and deletes.

        FILE_NOTIFY_CHANGE_DIRNAME - Any directory name changes that occur
            in a directory or subtree being watched will satisfy a
            change notification wait.  This includes directory creations
            and deletions.

        FILE_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a directory or subtree being watched will satisfy a
            change notification wait.

        FILE_NOTIFY_CHANGE_SIZE - Any file size changes that occur in a
            directory or subtree being watched will satisfy a change
            notification wait.  File sizes only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.

        FILE_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a directory or subtree being watched will satisfy a
            change notification wait.  Last write time change only cause
            a change when the on disk structure is updated.  For systems
            with extensive caching this may only occur when the system
            cache is sufficiently flushed.

        FILE_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a directory or subtree being watched will
            satisfy a change notification wait.

Return Value:

    Not -1 - Returns a find change notification handle.  The handle is a
        waitable handle.  A wait is satisfied when one of the filter
        conditions occur in a directory or subtree being monitored.  The
        handle may also be used in a subsequent call to
        FindNextChangeNotify and in FindCloseChangeNotify.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpPathName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    //
    // call change notify
    //

    Status = NtNotifyChangeDirectoryFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &staticIoStatusBlock,
                staticchangebuff,   // should be NULL
                sizeof(staticchangebuff),
                dwNotifyFilter,
                (BOOLEAN)bWatchSubtree
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        NtClose(Handle);
        Handle = INVALID_HANDLE_VALUE;
        }
    return Handle;
}

BOOL
APIENTRY
FindNextChangeNotification(
    HANDLE hChangeHandle
    )

/*++

Routine Description:

    This API is used to request that a change notification handle
    be signaled the next time the system dectects an appropriate
    change.

    If a change occurs prior to this call that would otherwise satisfy
    a change request, it is remembered by the system and will satisfy
    this request.

    Once a successful change notification request has been made, the
    application should wait on the change notification handle to
    pick up the change.

    If an application calls this API with a change request outstanding,

        .
        .
        FindNextChangeNotification(h);
        FindNextChangeNotification(h);
        WaitForSingleObject(h,-1);
        .
        .
    it may miss a change notification.

Arguments:

    hChangeHandle - Supplies a change notification handle created
        using FindFirstChangeNotification.

Return Value:

    TRUE - The change notification request was registered. A wait on the
        change handle should be issued to pick up the change notification.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOL ReturnValue;

    ReturnValue = TRUE;
    //
    // call change notify
    //

    Status = NtNotifyChangeDirectoryFile(
                hChangeHandle,
                NULL,
                NULL,
                NULL,
                &staticIoStatusBlock,
                staticchangebuff,           // should be NULL
                sizeof(staticchangebuff),
                FILE_NOTIFY_CHANGE_NAME,    // not needed bug workaround
                TRUE                        // not needed bug workaround
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }
    return ReturnValue;
}




BOOL
APIENTRY
FindCloseChangeNotification(
    HANDLE hChangeHandle
    )

/*++

Routine Description:

    This API is used close a change notification handle and to tell the
    system to stop monitoring changes on the notification handle.

Arguments:

    hChangeHandle - Supplies a change notification handle created
        using FindFirstChangeNotification.

Return Value:

    TRUE - The change notification handle was closed.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return CloseHandle(hChangeHandle);
}

BOOL
WINAPI
ReadDirectoryChangesW(
    HANDLE hDirectory,
    LPVOID lpBuffer,
    DWORD nBufferLength,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    This rountine allows you to read changes that occur in a directory
    or a tree rooted at the specified directory.  It is similar to the
    FindxxxChangeNotification family of APIs, but this API can return
    structured data describing the changes occuring within a directory.

    This API requires the caller to pass in an open directory handle to
    the directory that is to be read.  The handle must be opened with
    FILE_LIST_DIRECTORY acces.  GENERIC_READ includes this and may also
    be used.  The directory may be opened for overlapped access.  This
    technique should be used whenever you call this API asynchronously
    (by specifying and lpOverlapped value).  Opening a directory in
    Win32 is easy.  Use CreateFile, pass in the name of a directory, and
    make sure you specify FILE_FLAG_BACKUP_SEMANTICS.  This will allow
    you to open a directory.  This technique will not force a directory
    to be opened.  It simply allows you to open a directory.  Calling
    this API with a handle to a regular file will fail.

    The following code fragment illustrates how to open a directory using
    CreateFile.

        hDir = CreateFile(
                    DirName,
                    FILE_LIST_DIRECTORY,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS | (fASync ? FILE_FLAG_OVERLAPPED : 0),
                    NULL
                    );

    This API returns it's data in a structured format. The structure is defined by
    the FILE_NOTIFY_INFORMATION structure.

        typedef struct _FILE_NOTIFY_INFORMATION {
            DWORD NextEntryOffset;
            DWORD Action;
            DWORD FileNameLength;
            WCHAR FileName[1];
        } FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;

    The lpBuffer/nBufferLength parameters are used to describe the
    callers buffer to the system.  This API fills in the buffer either
    syncronously or asynchronously depending on how the directory is
    opened and the presence of the lpOverlapped parameter.

    Upon successful I/O completion, a formated buffer, and number of
    bytes transfered into the buffer is available to the caller.  If the
    number of bytes transfered is 0, this means that the system was
    unable to provide detailed information on all of the changes that
    occured in the directory or tree.  The application should manually
    compute this information by enumerating the directory or tree.
    Otherwise, structured data is returned to the caller.

    Each record contains:

        NextEntryOffest - This is the number of bytes to be skipped to get
            to the next record. A value of 0 indicates that this is the last
            record.

        Action - This is used to describe the type of change that occured:

            FILE_ACTION_ADDED - The file was added to the directory

            FILE_ACTION_REMOVED - The file was removed from the
                directory

            FILE_ACTION_MODIFIED - The file was modified (time change,
                attribute change...)

            FILE_ACTION_RENAMED_OLD_NAME - The file was renamed and this
                is the old name.

            FILE_ACTION_RENAMED_NEW_NAME - The file was renamed and this
                is the new name.

        FileNameLength - This is the length in bytes of the file name portion
            of this record. Note that the file name is NOT null terminated. This
            length does not include a trailing NULL.

        FileName - This variable length portion of the recorn contains a file name
            relative to the directory handle. The name is in the UNICODE character
            format and is NOT NULL terminated.

    The caller of this API can specify a filter that describes to sort
    of changes that should trigger a read completion on thie directory.
    The first call to this API on a directory establishes the filter to
    be used for that call and all subsequent calls.

    The caller can also tell the system to watch for changes in the
    directory, or the entire subtree under the directory.  Again, the
    first call to this API establishes this condition.

    This call can complete either synchronously or asynchronously.

    For synchronous completion, the directory should be opened without
    the FILE_FLAG_OVERLAPPED flag.  The I/O will complete when the
    callers buffer either fills up or overflows.  When this condition
    occurs, the caller may parse the returned buffer.  If the
    *lpBytesReturned value is 0, this means that the buffer was too
    small to hold all of the changes, and the caller will have to
    manually enumerate the directory or tree.

    For asynchronous completion, the directory should be opened with the
    FILE_FLAG_OVERLAPPED flag, and an lpOverlapped parameter must be
    specified.  I/O completion is returned to the caller via
    GetOverlappedResult(), GetQueuedCompletionStatus(), or via an I/O
    completion callback.

    To receive notification via GetOverlappedResult(), DO NOT specify an
    lpCompletionRoutine.  Set the hEvent field of the overlapped
    structure to an hEvent unique to this I/O operation. Pick up your I/O completion
    using GetOverlappedResult().

    To receive notification via GetQueuedCompletionSTatus(), DO NOT
    specify an lpCompletionRoutine.  Associate the directory handle with
    a completion port using CreateIoCompletionPort().  Pick up your I/O
    completion using GetQueuedCompletionStatus().  To disable a
    completion packet from being used on an associated directory, set
    the low order bit of the hEvent in the lpOverlapped structure and
    use GetOverlappedResult().

    To receive notification via an I/O completion callback, DO NOT
    associate the directory with a completion port.  Specify an
    lpCompletionRoutine.  This function will be called whenever an
    outstanding I/O completes while you are in an alertable wait.  If an
    I/O completes, but you are not waiting, the I/O notification stays
    pending and will occur when you wait.  Only the thread that issues
    the I/O is notified. The hEvent field of the overlapped structure is not
    used by the system and may be used by the caller.

Arguments:

    hDirectory - SUpplies an open handle to a directory to be watched.
        The directory must be opened with FILE_LIST_DIRECTORY access.

    lpBuffer - Supplies the address of a buffer that will be used to return the
        results of the read. The format of this buffer is described above.

    nBufferLength - Supplies the length of the buffer.

    bWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the directory tree rooted at the specified
        directory.  A value of FALSE causes the system to monitor only
        the specified directory.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a read.

        FILE_NOTIFY_CHANGE_FILENAME - Any file name changes that occur
            in a directory or subtree being watched will satisfy a read.
            This includes renames, creations, and deletes.

        FILE_NOTIFY_CHANGE_DIRNAME - Any directory name changes that
            occur in a directory or subtree being watched will satisfy a
            read.  This includes directory creations and deletions.

        FILE_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a directory or subtree being watched will satisfy a
            read.

        FILE_NOTIFY_CHANGE_SIZE - Any file size changes that occur in a
            directory or subtree being watched will satisfy a read.
            File sizes only cause a change when the on disk structure is
            updated.  For systems with extensive caching this may only
            occur when the system cache is sufficiently flushed.

        FILE_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a directory or subtree being watched will satisfy a
            read.  Last write time change only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.


        FILE_NOTIFY_CHANGE_LAST_ACCESS - Any last access time changes that
            occur in a directory or subtree being watched will satisfy a
            read.  Last access time change only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.


        FILE_NOTIFY_CHANGE_CREATION - Any creation time changes that
            occur in a directory or subtree being watched will satisfy a
            read.  Last creation time change only cause a change when the
            on disk structure is updated.  For systems with extensive
            caching this may only occur when the system cache is
            sufficiently flushed.

        FILE_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a directory or subtree being watched will
            satisfy a read.

    lpBytesReturned - For synchronous calls, this returns the number of
        bytes transfered into the buffer.  A successful call coupled
        with a value of 0 means that the buffer was too small, and the
        caller must manually enumerate the directory/tree.  For
        asynchronous calls, this value is undefined.  The system does
        not attempt to store anything here.  The caller must use an
        asynchronous notification technique to pick up I/O completion
        and number of bytes transfered.

    lpOverlapped - Supplies an overlapped structure to be used in
        conjunction with asynchronous I/O completion notification.  The
        offset fields of this structure are not used.  Using this on a
        directory that was not opened with FILE_FLAG_OVERLAPPED is
        undefined.


    lpCompletionRoutine - Supplies the address of a completion routine
        that is called when this I/O completes, AND the thread that
        issues the I/O enters an alertable wait.  The threads wait will
        be interrupted with a return code of WAIT_IO_COMPLETION, and
        this I/O completion routine will be called.  The routine is
        passed the error code of the operation, the number of bytes
        transfered, and the address of the lpOverlapped structure used
        in the call.  An error will occur if this parameter is specified
        on a directory handle that is associated with a completion port.

Return Value:

    TRUE - For synchronous calls, the operation succeeded.
        lpBytesReturned is the number of bytes transferred into your
        buffer.  A value of 0 means that your buffer was too small to
        hold all of the changes that occured and that you need to
        enumerate the directory yourself to see the changes.  For
        asyncronous calls, the operation was queued successfully.
        Results will be delivered using asynch I/O notification
        (GetOverlappedResult(), GetQueuedCompletionStatus(), or your
        completion callback routine).

    FALSE - An error occured. GetLastError() can be used to obtain detailed
        error status.

--*/

{
    NTSTATUS Status;
    BOOL ReturnValue;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Event;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;

    ReturnValue = TRUE;

    if ( ARGUMENT_PRESENT(lpOverlapped) ) {

        if ( ARGUMENT_PRESENT(lpCompletionRoutine) ) {

            //
            // completion is via APC routine
            //

            Event = NULL;

            Status = BasepAllocateActivationContextActivationBlock(
                BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK |
                BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT,
                lpCompletionRoutine,
                lpOverlapped,
                &ActivationBlock);
            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                return FALSE;
            }

            if (ActivationBlock != NULL) {
                ApcRoutine = &BasepIoCompletion;
                ApcContext = (PVOID) ActivationBlock;
            } else {
                ApcRoutine = &BasepIoCompletionSimple;
                ApcContext = lpCompletionRoutine;
            }
        } else {
            //
            // completion is via completion port or get overlapped result
            //

            Event = lpOverlapped->hEvent;
            ApcRoutine = NULL;
            ApcContext = (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped;
        }

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtNotifyChangeDirectoryFile(
                    hDirectory,
                    Event,
                    ApcRoutine,
                    ApcContext,
                    (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                    lpBuffer,
                    nBufferLength,
                    dwNotifyFilter,
                    (BOOLEAN)bWatchSubtree
                    );

        //
        // Anything other than an error means that I/O completion will
        // occur and caller only gets return data via completion mechanism
        //

        if ( NT_ERROR(Status) ) {
            if (ActivationBlock != NULL)
                BasepFreeActivationContextActivationBlock(ActivationBlock);

            BaseSetLastNTError(Status);
            ReturnValue = FALSE;
            }
        }
    else {
        Status = NtNotifyChangeDirectoryFile(
                    hDirectory,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    lpBuffer,
                    nBufferLength,
                    dwNotifyFilter,
                    (BOOLEAN)bWatchSubtree
                    );
        if ( Status == STATUS_PENDING) {

            //
            // Operation must complete before return & IoStatusBlock destroyed
            //

            Status = NtWaitForSingleObject( hDirectory, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }
        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)IoStatusBlock.Information;
            }
        else {
            BaseSetLastNTError(Status);
            ReturnValue = FALSE;
            }
        }

    return ReturnValue;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\error.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the Win32 error APIs.

Author:

    Mark Lucovsky (markl) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

DWORD g_dwLastErrorToBreakOn = ERROR_SUCCESS;

UINT
GetErrorMode()
{

    UINT PreviousMode;
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDefaultHardErrorMode,
                (PVOID) &PreviousMode,
                sizeof(PreviousMode),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    if (PreviousMode & 1) {
        PreviousMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        PreviousMode |= SEM_FAILCRITICALERRORS;
        }
    return PreviousMode;
}


UINT
SetErrorMode(
    UINT uMode
    )
{

    UINT PreviousMode;
    UINT NewMode;

    PreviousMode = GetErrorMode();

    NewMode = uMode;
    if (NewMode & SEM_FAILCRITICALERRORS ) {
        NewMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        NewMode |= SEM_FAILCRITICALERRORS;
        }

    //
    // Once SEM_NOALIGNMENTFAULTEXCEPT has been enabled for a given
    // process, it cannot be disabled via this API.
    //

    NewMode |= (PreviousMode & SEM_NOALIGNMENTFAULTEXCEPT);

    if ( NT_SUCCESS(NtSetInformationProcess(
                        NtCurrentProcess(),
                        ProcessDefaultHardErrorMode,
                        (PVOID) &NewMode,
                        sizeof(NewMode)
                        ) ) ){
        }

    return( PreviousMode );
}

DWORD
GetLastError(
    VOID
    )

/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/

{
    return (DWORD)NtCurrentTeb()->LastErrorValue;
}

VOID
SetLastError(
    DWORD dwErrCode
    )

/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).
    This function
    is not called by Win32 API function calls that are successful, so
    that if three Win32 API function calls are made, and the first one
    fails and the second two succeed, the error code and string stored
    by the first one are still available after the second two succeed.

    Applications can retrieve the values saved by this function using
    GetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    PTEB Teb = NtCurrentTeb();

    if ((g_dwLastErrorToBreakOn != ERROR_SUCCESS) &&
        (dwErrCode == g_dwLastErrorToBreakOn)) {
        DbgBreakPoint();
    }

    // make write breakpoints to this field more meaningful by only writing to it when
    // the value changes.
    if (Teb->LastErrorValue != dwErrCode) {
        Teb->LastErrorValue = dwErrCode;
    }
}

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

HANDLE
WINAPI
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    )

/*++

Routine Description:

    This function creates an I/O completion port.  Completion ports
    provide another mechanism that can be used to to recive I/O
    completion notification.

    Completion ports act as a queue.  The Win32 I/O system can be
    instructed to queue I/O completion notification packets to
    completion ports.  This API provides this mechanism.  If a file
    handle is created for overlapped I/O completion
    (FILE_FLAG_OVERLAPPED) , a completion port can be associated with
    the file handle.  When I/O operations are done on a file handle that
    has an associated completion port, the I/O system will queue a
    completion packet when the I/O operation completes.  The
    GetQueuedCompletionStatus is used to pick up these queued I/O
    completion packets.

    This API can be used to create a completion port and associate it
    with a file.  If you supply a completion port, it can be used to
    associate the specified file with the specified completion port.

Arguments:

    FileHandle - Supplies a handle to a file opened for overlapped I/O
        completion.  This file is associated with either the specified
        completion port, or a new completion port is created, and the
        file is associated with that port.  Once associated with a
        completion port, the file handle may not be used in ReadFileEx
        or WriteFileEx operations.  It is not advisable to share an
        associated file handle through either handle inheritence or
        through DuplicateHandle.  I/O operations done on these
        duplicates will also generate a completion notification.

    ExistingCompletionPort - If this parameter is specified, it supplies
        an existing completion port that is to be associated with the
        specified file handle.  Otherwise, a new completion port is
        created and associated with the specified file handle.

    CompletionKey - Supplies a per-file completion key that is part of
        every I/O completion packet for this file.

    NumberOfConcurrentThreads - This is the number of threads that are
        alowed to be concurrently active and can be used to avoid
        spurious context switches, e.g., context switches that would
        occur simply because of quantum end.  Up to the number of
        threads specified are allowed to execute concurrently.  If one
        of the threads enters a wait state, then another thread is
        allowed to procede.  There may be times when more then the
        specified number of threads are active, but this will be quickly
        throttled.  A value of 0 tells the system to allow the same
        number of threads as there are processors to run.

Return Value:

    Not NULL - Returns the completion port handle associated with the file.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    HANDLE Port;
    IO_STATUS_BLOCK IoSb;
    FILE_COMPLETION_INFORMATION CompletionInfo;

    Port = ExistingCompletionPort;
    if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
        Status = NtCreateIoCompletion (
                    &Port,
                    IO_COMPLETION_ALL_ACCESS,
                    NULL,
                    NumberOfConcurrentThreads
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return NULL;
            }
        }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CompletionInfo.Port = Port;
        CompletionInfo.Key = (PVOID)CompletionKey;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoSb,
                    &CompletionInfo,
                    sizeof(CompletionInfo),
                    FileCompletionInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
                NtClose(Port);
                }
            return NULL;
            }
        }
    else {

        //
        // file handle is INVALID_HANDLE_VALUE. Usually this is
        // used to create a new unassociated completion port.
        //
        // Special case here to see if existing completion port was
        // specified and fail if it is
        //

        if ( ARGUMENT_PRESENT(ExistingCompletionPort) ) {
            Port = NULL;
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }

    return Port;
}

BOOL
WINAPI
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function allows the caller to post an I/O completion packet to
    a completion port. This packet will satisfy an outstanding call to
    GetQueuedCompletionStatus and will provide that caller with the three values
    normally returned from that call.

Arguments:

    CompletionPort - Supplies a handle to a completion port that the caller wants to
        post a completion packet to.

    dwNumberOfBytesTransferred - Supplies the value that is to be
        returned through the lpNumberOfBytesTransfered parameter of the
        GetQueuedCompletionStatus API.

    dwCompletionKey - Supplies the value that is to be returned through
        the lpCompletionKey parameter of the GetQueuedCompletionStatus
        API.

    lpOverlapped - Supplies the value that is to be returned through the
        lpOverlapped parameter of the GetQueuedCompletionStatus API.

Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed, use GetLastError to get detailed error information

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtSetIoCompletion(
                CompletionPort,
                (PVOID)dwCompletionKey,
                (PVOID)lpOverlapped,
                STATUS_SUCCESS,
                dwNumberOfBytesTransferred
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



BOOL
WINAPI
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    This function waits for pending I/O operations associated with the
    specified completion port to complete.  Server applications may have
    several threads issuing this call on the same completion port.  As
    I/O operations complete, they are queued to this port.  If threads
    are actively waiting in this call, queued requests complete their
    call.

    This API returns a boolean value.

    A value of TRUE means that a pending I/O completed successfully.
    The the number of bytes transfered during the I/O, the completion
    key that indicates which file the I/O occured on, and the overlapped
    structure address used in the original I/O are all returned.

    A value of FALSE indicates one ow two things:

    If *lpOverlapped is NULL, no I/O operation was dequeued.  This
    typically means that an error occured while processing the
    parameters to this call, or that the CompletionPort handle has been
    closed or is otherwise invalid.  GetLastError() may be used to
    further isolate this.

    If *lpOverlapped is non-NULL, an I/O completion packet was dequeud,
    but the I/O operation resulted in an error.  GetLastError() can be
    used to further isolate the I/O error.  The the number of bytes
    transfered during the I/O, the completion key that indicates which
    file the I/O occured on, and the overlapped structure address used
    in the original I/O are all returned.

Arguments:

    CompletionPort - Supplies a handle to a completion port to wait on.

    lpNumberOfBytesTransferred - Returns the number of bytes transfered during the
        I/O operation whose completion is being reported.

    lpCompletionKey - Returns a completion key value specified during
        CreateIoCompletionPort.  This is a per-file key that can be used
        to tall the caller the file that an I/O operation completed on.

    lpOverlapped - Returns the address of the overlapped structure that
        was specified when the I/O was issued.  The following APIs may
        complete using completion ports.  This ONLY occurs if the file
        handle is associated with with a completion port AND an
        overlapped structure was passed to the API.

        LockFileEx
        WriteFile
        ReadFile
        DeviceIoControl
        WaitCommEvent
        ConnectNamedPipe
        TransactNamedPipe

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for an I/O completion
        packet.

Return Value:

    TRUE - An I/O operation completed successfully.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

    FALSE - If lpOverlapped is NULL, the operation failed and no I/O
        completion data is retured.  GetLastError() can be used to
        further isolate the cause of the error (bad parameters, invalid
        completion port handle).  Otherwise, a pending I/O operation
        completed, but it completed with an error.  GetLastError() can
        be used to further isolate the I/O error.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

--*/

{

    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;
    LPOVERLAPPED LocalOverlapped;
    BOOL rv;


    pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    Status = NtRemoveIoCompletion(
                CompletionPort,
                (PVOID *)lpCompletionKey,
                (PVOID *)&LocalOverlapped,
                &IoSb,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        *lpOverlapped = NULL;
        if ( Status == STATUS_TIMEOUT ) {
            SetLastError(WAIT_TIMEOUT);
            }
        else {
            BaseSetLastNTError(Status);
            }
        rv = FALSE;
        }
    else {
        *lpOverlapped = LocalOverlapped;

        *lpNumberOfBytesTransferred = (DWORD)IoSb.Information;

        if ( !NT_SUCCESS(IoSb.Status) ){
            BaseSetLastNTError( IoSb.Status );
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }
        }
    return rv;
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        BaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\firmware.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    firmware.c

Abstract:

    This module implements Win32 firmware access APIs

Author:

    Andrew Ritz (andrewr) 3-April-2001

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop


DWORD
WINAPI
GetFirmwareEnvironmentVariableA(
    IN LPCSTR lpName,
    IN LPCSTR lpGuid,
    OUT PVOID  pBuffer,
    IN DWORD nSize
    )

/*++

Routine Description:

    The value of a firmware environment variable may be retrieved by using
    this API.
    
    This API is just a wrapper for NtQuerySystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that is to receive the value of the
        specified variable name.

    nSize - Specifies the maximum number of bytes that can be stored in
        the buffer pointed to by pBuffer.

Return Value:

    The actual number of bytes stored in the memory pointed to by the
    pBuffer parameter.  The return value is zero if the variable name was not
    found in the firmware or if another failure occurred (Call GetLastError() 
    to get extended error information.)
    
--*/

{
    NTSTATUS Status;
    STRING Name,Guid;
    UNICODE_STRING UnicodeName,UnicodeGuid;
    DWORD RetVal;
    

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return ( 0 );
    }

    RtlInitString( &Guid, lpGuid );
    Status = RtlAnsiStringToUnicodeString( &UnicodeGuid, &Guid, TRUE );
    if (!NT_SUCCESS( Status )) {
        RtlFreeUnicodeString(&UnicodeName);
        BaseSetLastNTError( Status );
        return ( 0 );
    }

    RetVal = GetFirmwareEnvironmentVariableW( 
                                    UnicodeName.Buffer,
                                    UnicodeGuid.Buffer,
                                    pBuffer,
                                    nSize );
        
    RtlFreeUnicodeString(&UnicodeName);
    RtlFreeUnicodeString(&UnicodeGuid);

    return( RetVal );
    
}


DWORD
WINAPI
GetFirmwareEnvironmentVariableW(
    IN LPCWSTR lpName,
    IN LPCWSTR lpGuid,
    OUT PVOID  pBuffer,
    IN DWORD nSize
    )
/*++

Routine Description:

    The value of a firmware environment variable may be retrieved by using
    this API.
    
    This API is just a wrapper for NtQuerySystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that is to receive the value of the
        specified variable name.

    nSize - Specifies the maximum number of bytes that can be stored in
        the buffer pointed to by pBuffer.

Return Value:

    The actual number of bytes stored in the memory pointed to by the
    pBuffer parameter.  The return value is zero if the variable name was not
    found in the firmware or if another failure occurred (Call GetLastError() 
    to get extended error information.)
    
--*/
{
    UNICODE_STRING uStringName,GuidString;
    GUID  Guid;
    NTSTATUS Status;
    DWORD scratchSize;

    if (!lpName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    RtlInitUnicodeString(&uStringName, lpName);
    RtlInitUnicodeString(&GuidString, lpGuid);

    Status = RtlGUIDFromString(&GuidString, &Guid);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return 0;
    }
    
    scratchSize = nSize;
    Status = NtQuerySystemEnvironmentValueEx(
                                &uStringName,
                                &Guid,
                                pBuffer,
                                &scratchSize,
                                NULL); //bugbug need to give caller the attributes?

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return 0;
    }

    return scratchSize;

}


BOOL
WINAPI
SetFirmwareEnvironmentVariableA(
    IN LPCSTR lpName,
    IN LPCSTR lpGuid,
    IN PVOID  pBuffer,
    IN DWORD nSize
    )

/*++

Routine Description:

    The value of a firmware environment variable may be set by using
    this API.
    
    This API is just a wrapper for NtSetSystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that contains the data for the specified
       variable name.

    nSize - Specifies the number of bytes that are stored in
        the buffer pointed to by pBuffer.  Specifying 0 indicates that the 
        caller wants the deleted.

Return Value:

    TRUE indicates that the value was successfully set.  The return value is 
    FALSE if the variable name was not set. (Call GetLastError() to get 
    extended error information.)
    
--*/
{
    NTSTATUS Status;
    STRING Name,Guid;
    UNICODE_STRING UnicodeName,UnicodeGuid;
    BOOL RetVal;
    

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return(FALSE);
    }

    RtlInitString( &Guid, lpGuid );
    Status = RtlAnsiStringToUnicodeString( &UnicodeGuid, &Guid, TRUE );
    if (!NT_SUCCESS( Status )) {
        RtlFreeUnicodeString(&UnicodeName);
        BaseSetLastNTError( Status );
        return(FALSE);
    }

    RetVal = SetFirmwareEnvironmentVariableW( 
                                    UnicodeName.Buffer,
                                    UnicodeGuid.Buffer,
                                    pBuffer,
                                    nSize );
        
    RtlFreeUnicodeString(&UnicodeName);
    RtlFreeUnicodeString(&UnicodeGuid);

    return( RetVal );
    
}



BOOL
WINAPI
SetFirmwareEnvironmentVariableW(
    IN LPCWSTR lpName,
    IN LPCWSTR lpGuid,
    IN PVOID  pBuffer,
    IN DWORD nSize
    )
/*++

Routine Description:

    The value of a firmware environment variable may be set by using
    this API.
    
    This API is just a wrapper for NtSetSystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that contains the data for the specified
       variable name.

    nSize - Specifies the number of bytes that are stored in
        the buffer pointed to by pBuffer.  Specifying 0 indicates that the 
        caller wants the deleted.

Return Value:

    TRUE indicates that the value was successfully set.  The return value is 
    FALSE if the variable name was not set. (Call GetLastError() to get 
    extended error information.)
    
--*/
{
    UNICODE_STRING uStringName,GuidString;
    GUID  Guid;
    NTSTATUS Status;

    if (!lpName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitUnicodeString(&uStringName, lpName);
    RtlInitUnicodeString(&GuidString, lpGuid);

    Status = RtlGUIDFromString(&GuidString, &Guid);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }
    
    Status = NtSetSystemEnvironmentValueEx(
                                &uStringName,
                                &Guid,
                                pBuffer,
                                nSize,
                                VARIABLE_ATTRIBUTE_NON_VOLATILE); //bugbug need to give caller the ability to set attributes?

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\filemisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filemisc.c

Abstract:

    Misc file operations for Win32

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <basedll.h>


DWORD
BasepGetComputerNameFromNtPath (
    PUNICODE_STRING NtPathName,
    HANDLE hFile,
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

NTSTATUS
BasepMoveFileDelayed(
    IN PUNICODE_STRING OldFileName,
    IN PUNICODE_STRING NewFileName,
    IN ULONG Index,
    IN BOOL OkayToCreateNewValue
    );

BOOL
APIENTRY
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    ANSI thunk to SetFileAttributesW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( SetFileAttributesW(
                (LPCWSTR)Unicode->Buffer,
                dwFileAttributes
                )
            );
}


BOOL
APIENTRY
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    The attributes of a file can be set using SetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    dwFileAttributes - Specifies the file attributes to be set for the
        file.  Any combination of flags is acceptable except that all
        other flags override the normal file attribute,
        FILE_ATTRIBUTE_NORMAL.

        FileAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_ATTRIBUTE_ARCHIVE - The file should be marked so that it
            will be archived.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open the file without inhibiting the reparse behavior.
            //

            Status = NtOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );

            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Set the attributes
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_SET_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



DWORD
APIENTRY
GetFileAttributesA(
    LPCSTR lpFileName
    )

/*++

Routine Description:

    ANSI thunk to GetFileAttributesW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return (DWORD)-1;
    }

    return ( GetFileAttributesW((LPCWSTR)Unicode->Buffer) );
}

DWORD
APIENTRY
GetFileAttributesW(
    LPCWSTR lpFileName
    )

/*++

Routine Description:

    The attributes of a file can be obtained using GetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

Return Value:

    Not -1 - Returns the attributes of the specified file.  Valid
        returned attributes are:

        FILE_ATTRIBUTE_NORMAL - The file is a normal file.

        FILE_ATTRIBUTE_READONLY - The file is marked read-only.

        FILE_ATTRIBUTE_HIDDEN - The file is marked as hidden.

        FILE_ATTRIBUTE_SYSTEM - The file is marked as a system file.

        FILE_ATTRIBUTE_ARCHIVE - The file is marked for archive.

        FILE_ATTRIBUTE_DIRECTORY - The file is marked as a directory.

        FILE_ATTRIBUTE_REPARSE_POINT - The file is marked as a reparse point.

        FILE_ATTRIBUTE_VOLUME_LABEL - The file is marked as a volume lable.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_BASIC_INFORMATION BasicInfo;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return (DWORD)-1;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file
    //

    Status = NtQueryAttributesFile(
                 &Obja,
                 &BasicInfo
                 );
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        return BasicInfo.FileAttributes;
        }
    else {

        //
        // Check for a device name.
        //

        if ( RtlIsDosDeviceName_U((PWSTR)lpFileName) ) {
            return FILE_ATTRIBUTE_ARCHIVE;
            }
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
}

BOOL
APIENTRY
GetFileAttributesExA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    ANSI thunk to GetFileAttributesExW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( GetFileAttributesExW((LPCWSTR)Unicode->Buffer,fInfoLevelId,lpFileInformation) );
}

BOOL
APIENTRY
GetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    The main attributes of a file can be obtained using GetFileAttributesEx.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    fInfoLevelId - Supplies the info level indicating the information to be
        returned about the file.

    lpFileInformation - Supplies a buffer to receive the specified information
        about the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LPWIN32_FILE_ATTRIBUTE_DATA AttributeData;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    //
    // Check the parameters.  Note that for now there is only one info level,
    // so there's no special code here to determine what to do.
    //

    if ( fInfoLevelId >= GetFileExMaxInfoLevel || fInfoLevelId < GetFileExInfoStandard ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
DeleteFileA(
    LPCSTR lpFileName
    )

/*++

Routine Description:

    ANSI thunk to DeleteFileW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( DeleteFileW((LPCWSTR)Unicode->Buffer) );
}

BOOL
APIENTRY
DeleteFileW(
    LPCWSTR lpFileName
    )

/*++

    Routine Description:

    An existing file can be deleted using DeleteFile.

    This API provides the same functionality as DOS (int 21h, function 41H)
    and OS/2's DosDelete.

Arguments:

    lpFileName - Supplies the file name of the file to be deleted.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    BOOLEAN fIsSymbolicLink = FALSE;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );
    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            //
            // A second case of interest is when the caller does not have rights 
            // to read attributes yet it does have rights to delete the file.
            // In this case Status is to be STATUS_ACCESS_DENIED.
            //
            
            if ( Status != STATUS_ACCESS_DENIED ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            
            // 
            // Re-open inhibiting reparse point and not requiring read attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            //
            // If we are here, Handle is valid.
            //
            // Moreover, Handle is to a file for which the caller has DELETE right yet
            // does not have FILE_READ_ATTRIBUTES rights. 
            //
            // The underlying file may or not be a reparse point. 
            // As the caller does not have rights to read the attributes this code
            // will delete this file without giving the opportunity to the 
            // appropriate manager of these reparse points to clean-up its internal 
            // state at this time.
            //
            }
        }
    else {
        //
        // If we found a reparse point that is not a symbolic link, we re-open
        // without inhibiting the reparse behavior.
        //

        Status = NtQueryInformationFile(
                     Handle,
                     &IoStatusBlock,
                     (PVOID) &FileTagInformation,
                     sizeof(FileTagInformation),
                     FileAttributeTagInformation
                     );
        if ( !NT_SUCCESS(Status) ) {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                 (Status != STATUS_INVALID_PARAMETER) ) {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ) {
            if ( FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {
                fIsSymbolicLink = TRUE;
                }
            }

        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
             !fIsSymbolicLink) {
            //
            // Re-open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            NtClose(Handle);
            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if ( Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED ) {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(
                                 &Handle,
                                 (ACCESS_MASK)DELETE,
                                 &Obja,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                                 );
                    }

                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


//
//  Ascii versions that thunk to the common code
//

BOOL
APIENTRY
MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    return MoveFileWithProgressA( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  MOVEFILE_COPY_ALLOWED );
}

BOOL
APIENTRY
MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    )

{
    return MoveFileWithProgressA( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  dwFlags );
}


BOOL
APIENTRY
MoveFileWithProgressA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData OPTIONAL,
    DWORD dwFlags
    )

/*++

Routine Description:

    ANSI thunk to MoveFileWithProgressW

--*/

{

    UNICODE_STRING UnicodeOldFileName;
    UNICODE_STRING UnicodeNewFileName;
    BOOL ReturnValue;

    if ( !Basep8BitStringToDynamicUnicodeString(&UnicodeOldFileName, lpExistingFileName) ) {
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpNewFileName) ) {
        if ( !Basep8BitStringToDynamicUnicodeString(&UnicodeNewFileName, lpNewFileName) ) {
            RtlFreeUnicodeString(&UnicodeOldFileName);
            return FALSE;
            }
        }
    else {
        UnicodeNewFileName.Buffer = NULL;
        }

    ReturnValue =
        MoveFileWithProgressW( (LPCWSTR)UnicodeOldFileName.Buffer,
                               (LPCWSTR)UnicodeNewFileName.Buffer,
                               lpProgressRoutine,
                               lpData,
                               dwFlags
                               );

    RtlFreeUnicodeString(&UnicodeOldFileName);
    RtlFreeUnicodeString(&UnicodeNewFileName);

    return ReturnValue;
}

typedef struct _HELPER_CONTEXT {
    DWORD dwFlags;
    LPPROGRESS_ROUTINE lpProgressRoutine;
    LPVOID lpData;
} HELPER_CONTEXT, *PHELPER_CONTEXT;

DWORD
APIENTRY
BasepMoveFileCopyProgress(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE SourceFile,
    HANDLE DestinationFile,
    LPVOID lpData OPTIONAL
    )
/*++

Routine Description:

    Perform special actions when doing move-by-copy.

Arguments:

    TotalFileSize - total number of bytes being transferred

    TotalBytesTransferred - current progress through the file

    StreamSize - total number of bytes being transferred in this stream

    StreamBytesTransferred - current progress through this stream

    dwStreamNumber - ordinal number of stream

    dwCallbackReason - CopyFile's reason for calling us

    SourceFile - source handle of transfer

    DestinationFile - destination handle of transfer

    lpData - pointer to HELPER_CONTEXT constructed by MoveFileWithProgressW.


Return Value:

    PROGRESS_CONTINUE if no progress routine was specified, otherwise
        the return value from the progress routine specified to
        MoveFileWithProgress

--*/

{
    PHELPER_CONTEXT Context = (PHELPER_CONTEXT)lpData;

    //
    //  If we are finished with a stream and the caller
    //  specified WRITE_THROUGH then we make sure the file buffers
    //  actually made it out to disk.
    //

    if ((Context->dwFlags & MOVEFILE_WRITE_THROUGH) != 0
        && dwCallbackReason == CALLBACK_CHUNK_FINISHED
        && StreamBytesTransferred.QuadPart == StreamSize.QuadPart ) {

        FlushFileBuffers(DestinationFile);

    }


    //
    //  If a callback routine was specified, call through him
    //

    if (Context->lpProgressRoutine == NULL) {
        return PROGRESS_CONTINUE;
    }

    return (Context->lpProgressRoutine) (
                TotalFileSize,
                TotalBytesTransferred,
                StreamSize,
                StreamBytesTransferred,
                dwStreamNumber,
                dwCallbackReason,
                SourceFile,
                DestinationFile,
                Context->lpData );
}



NTSTATUS
BasepNotifyTrackingService( PHANDLE SourceFile,
                            POBJECT_ATTRIBUTES SourceFileObjAttributes,
                            HANDLE DestFile,
                            PUNICODE_STRING NewFileName
                            )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FILE_BASIC_INFORMATION BasicInformation;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG FileAttributes;
    ULONG cchComputerName;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD dwError;

    BYTE FTIBuffer[ sizeof(FILE_TRACKING_INFORMATION) + MAX_COMPUTERNAME_LENGTH + 1 ];
    PFILE_TRACKING_INFORMATION pfti = (PFILE_TRACKING_INFORMATION) &FTIBuffer[0];

    try
    {
        cchComputerName = MAX_COMPUTERNAME_LENGTH + 1;
        dwError = BasepGetComputerNameFromNtPath( NewFileName,
                                                  DestFile,
                                                  ComputerName,
                                                  &cchComputerName );

        if (ERROR_SUCCESS != dwError) {
            pfti->ObjectInformationLength = 0;
        } else {
            
            CHAR ComputerNameOemBuffer[ MAX_PATH ];
            OEM_STRING ComputerNameOemString = { 0,
                                                 sizeof(ComputerNameOemBuffer),
                                                 ComputerNameOemBuffer };
            UNICODE_STRING ComputerNameUnicodeString;

            RtlInitUnicodeString( &ComputerNameUnicodeString,
                                  ComputerName );


            Status = RtlUnicodeStringToOemString( &ComputerNameOemString,
                                                  &ComputerNameUnicodeString,
                                                  FALSE );  // Don't allocate
            if( !NT_SUCCESS(Status) ) {
                leave;
            }

            memcpy( pfti->ObjectInformation,
                    ComputerNameOemString.Buffer,
                    ComputerNameOemString.Length );
            pfti->ObjectInformation[ ComputerNameOemString.Length ] = '\0';
                
            // Fill in the rest of the fti buffer, and set the file information

            pfti->ObjectInformationLength = ComputerNameOemString.Length + 1;
        }

        pfti->DestinationFile = DestFile;

        Status = NtSetInformationFile(
                                     *SourceFile,
                                     &IoStatusBlock,
                                     pfti,
                                     sizeof( FTIBuffer ),
                                     FileTrackingInformation );

        //
        // Check to see if tracking failed because
        // the source has a read-only attribute set.
        //

        if (Status != STATUS_ACCESS_DENIED) {
            leave;
        }

        //
        // reopen the source file and reset the read-only attribute
        // so that we'll be able to open for write access.
        //

        CloseHandle(*SourceFile);

        Status = NtOpenFile(
                           SourceFile,
                           SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                           SourceFileObjAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_SYNCHRONOUS_IO_NONALERT
                           );

        if (!NT_SUCCESS(Status)) {
            *SourceFile = INVALID_HANDLE_VALUE;
            leave;
        }


        Status = NtQueryInformationFile(
                                       *SourceFile,
                                       &IoStatusBlock,
                                       &BasicInformation,
                                       sizeof(BasicInformation),
                                       FileBasicInformation );

        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        // Reset the r/o bit and write the attributes back.
        //

        FileAttributes = BasicInformation.FileAttributes;
        RtlZeroMemory(&BasicInformation, sizeof(BasicInformation));
        BasicInformation.FileAttributes = FileAttributes & ~FILE_ATTRIBUTE_READONLY;

        Status = NtSetInformationFile(
                                     *SourceFile,
                                     &IoStatusBlock,
                                     &BasicInformation,
                                     sizeof(BasicInformation),
                                     FileBasicInformation);

        if (!NT_SUCCESS(Status)) {

            //
            // If this fails, we can't track the file.
            //

            leave;
        }

        //
        // Now that the r/o bit is reset, reopen for write access and
        // retry the tracking notification.
        //

        else {
            HANDLE hSourceRw;

            Status = NtOpenFile(
                               &hSourceRw,
                               SYNCHRONIZE | GENERIC_WRITE,
                               SourceFileObjAttributes,
                               &IoStatusBlock,
                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                               FILE_SYNCHRONOUS_IO_NONALERT
                               );

            if (NT_SUCCESS(Status)) {
                NtClose(*SourceFile);
                *SourceFile = hSourceRw;

                //
                // Send the source machine a tracking notification.
                //

                Status = NtSetInformationFile( *SourceFile,
                                               &IoStatusBlock,
                                               pfti,
                                               sizeof( FTIBuffer ),
                                               FileTrackingInformation );
            }
        }


        if (!NT_SUCCESS(Status)) {

            //
            // Try to put back the r/o bit -- don't assign Status here
            // because we want to fail. If we crash here, we may leave
            // the r/o attribute clear when it should be set, but there's
            // not much we can do about it without a transaction.
            //

            BasicInformation.FileAttributes |= FILE_ATTRIBUTE_READONLY;
            NtSetInformationFile(
                                *SourceFile,
                                &IoStatusBlock,
                                &BasicInformation,
                                sizeof(BasicInformation),
                                FileBasicInformation);
        }
    }
    finally
    {
    }


    return( Status );

}





BOOL
APIENTRY
MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    return MoveFileWithProgressW( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  MOVEFILE_COPY_ALLOWED );
}

BOOL
APIENTRY
MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    )

{
    return MoveFileWithProgressW( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  dwFlags );
}

BOOL
APIENTRY
MoveFileWithProgressW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    DWORD dwFlags
    )

/*++

Routine Description:

    An existing file can be renamed using MoveFileWithProgressW.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        renamed.

    lpNewFileName - Supplies the new name for the existing file.  The new
        name must reside in the same file system/drive as the existing
        file and must not already exist.

    lpProgressRoutine - Supplies a callback routine that is notified.

    lpData - Supplies context data passed to the progress routine.

    dwFlags - Supplies optional flag bits to control the behavior of the
        rename.  The following bits are currently defined:

        MOVEFILE_REPLACE_EXISTING - if the new file name exists, replace
            it by renaming the old file name on top of the new file name.

        MOVEFILE_COPY_ALLOWED - if the new file name is on a different
            volume than the old file name, and causes the rename operation
            to fail, then setting this flag allows the MoveFileEx API
            call to simulate the rename with a call to CopyFile followed
            by a call to DeleteFile to the delete the old file if the
            CopyFile was successful.

        MOVEFILE_DELAY_UNTIL_REBOOT - dont actually do the rename now, but
            instead queue the rename so that it will happen the next time
            the system boots.  If this flag is set, then the lpNewFileName
            parameter may be NULL, in which case a delay DeleteFile of
            the old file name will occur the next time the system is
            booted.

            The delay rename/delete operations occur immediately after
            AUTOCHK is run, but prior to creating any paging files, so
            it can be used to delete paging files from previous boots
            before they are reused.

        MOVEFILE_WRITE_THROUGH - perform the rename operation in such a
            way that the file has actually been moved on the disk before
            the API returns to the caller.  Note that this flag causes a
            flush at the end of a copy operation (if one were allowed and
            necessary), and has no effect if the rename operation is
            delayed until the next reboot.

        MOVEFILE_CREATE_HARDLINK - create a hard link from the new file name to
            the existing file name.  May not be specified with
            MOVEFILE_DELAY_UNTIL_REBOOT

        MOVEFILE_FAIL_IF_NOT_TRACKABLE - fail the move request if the file cannot
            be tracked.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReplaceIfExists;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    UNICODE_STRING OldFileName;
    UNICODE_STRING NewFileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_RENAME_INFORMATION NewName;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    UNICODE_STRING RelativeOldName;
    ULONG OpenFlags;
    BOOLEAN b = FALSE;
    HELPER_CONTEXT Context;

    NewFileName.Buffer = NULL;
    OldFileName.Buffer = NULL;

    try {

        //
        // if the target is a device, do not allow the rename !
        //

        if ( lpNewFileName ) {
            if ( RtlIsDosDeviceName_U((PWSTR)lpNewFileName) ) {
                BaseSetLastNTError( STATUS_OBJECT_NAME_COLLISION );
                leave;
            }
        }

        ReplaceIfExists = (dwFlags & MOVEFILE_REPLACE_EXISTING) != 0;

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpExistingFileName,
                                &OldFileName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            BaseSetLastNTError( STATUS_OBJECT_PATH_NOT_FOUND );
            leave;
        }

        //
        //  Cannot perform delayed-move-by-creating-hardlink
        //

        if ((dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) != 0 &&
            (dwFlags & MOVEFILE_CREATE_HARDLINK) != 0) {
            BaseSetLastNTError( STATUS_INVALID_PARAMETER );
            leave;
        }

        //
        //  Get a handle to the source of the move.  We do this even for
        //  the delayed move in order to validate that we have delete
        //  access to the file.
        //

        if ( RelativeName.RelativeName.Length ) {
            RelativeOldName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        } else {
            RelativeOldName = OldFileName;
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
                                  &Obja,
                                  &RelativeOldName,
                                  OBJ_CASE_INSENSITIVE,
                                  RelativeName.ContainingDirectory,
                                  NULL
                                  );

        //
        //  Establish whether we are renaming a symbolic link or not by:
        //      (1) obtaining a handle to the local entity, and
        //      (2) finding whether a symbolic link was found.
        //
        //  Open the file for delete access inhibiting the reparse
        //  point behavior.
        //

        OpenFlags = FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_OPEN_FOR_BACKUP_INTENT  |
                    ((dwFlags & MOVEFILE_WRITE_THROUGH) ? FILE_WRITE_THROUGH : 0);

        Status = NtOpenFile( &Handle,
                             FILE_READ_ATTRIBUTES | DELETE | SYNCHRONIZE,
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN_REPARSE_POINT | OpenFlags
                             );


        if (!NT_SUCCESS( Status )) {

            //
            //  The Open may fail for a number of reasons.  If we're
            //  delaying the operation until reboot, it doesn't matter
            //  if we get a sharing violation or a non-existent file
            //  or a non-existent path.
            //

            if (((dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) != 0)
                && (Status == STATUS_SHARING_VIOLATION
                    || Status == STATUS_OBJECT_NAME_NOT_FOUND
                    || Status == STATUS_OBJECT_PATH_NOT_FOUND)) {

                Handle = INVALID_HANDLE_VALUE;

            } else {

                //
                //  Back level file systems may not support reparse points and thus not
                //  support symbolic links.
                //
                //  We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
                //

                if ( Status == STATUS_INVALID_PARAMETER ) {

                    //
                    //  Retry the open without reparse behaviour.  This should be compatible
                    //  with older file systems.
                    //

                    Status = NtOpenFile(
                                       &Handle,
                                       DELETE | SYNCHRONIZE,
                                       &Obja,
                                       &IoStatusBlock,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       OpenFlags
                                       );
                }

                if ( !NT_SUCCESS( Status ) ) {
                    BaseSetLastNTError( Status );
                    leave;
                }
            }
        } else {

            //
            //  The open succeeded. If we do not find a symbolic link or a mount point,
            //  re-open without inhibiting the reparse behavior.
            //

            Status = NtQueryInformationFile(
                                           Handle,
                                           &IoStatusBlock,
                                           (PVOID) &FileTagInformation,
                                           sizeof(FileTagInformation),
                                           FileAttributeTagInformation
                                           );

            if ( !NT_SUCCESS( Status ) ) {

                //
                //  Not all File Systems implement all information classes.
                //  The value STATUS_INVALID_PARAMETER is returned when a non-supported
                //  information class is requested to a back-level File System. As all the
                //  parameters to NtQueryInformationFile are correct, we can infer that
                //  we found a back-level system.
                //
                //  If FileAttributeTagInformation is not implemented, we assume that
                //  the file at hand is not a reparse point.
                //

                if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                     (Status != STATUS_INVALID_PARAMETER) ) {
                    BaseSetLastNTError( Status );
                    leave;
                }
            }

            if ( NT_SUCCESS(Status) &&
                 (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
                 FileTagInformation.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {

                //
                //  Open without inhibiting the reparse behavior and not needing to
                //  read the attributes.
                //

                NtClose( Handle );
                Handle = INVALID_HANDLE_VALUE;

                Status = NtOpenFile(
                                   &Handle,
                                   DELETE | SYNCHRONIZE,
                                   &Obja,
                                   &IoStatusBlock,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   OpenFlags
                                   );

                if ( !NT_SUCCESS( Status ) ) {
                    BaseSetLastNTError( Status );
                    leave;
                }
            }
        }

        if (!(dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) ||
            (lpNewFileName != NULL)) {
            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                                            lpNewFileName,
                                                            &NewFileName,
                                                            NULL,
                                                            NULL
                                                            );

            if ( !TranslationStatus ) {
                BaseSetLastNTError( STATUS_OBJECT_PATH_NOT_FOUND );
                leave;
            }

        } else {
            RtlInitUnicodeString( &NewFileName, NULL );
        }

        if (dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) {

            //
            // (typical stevewo hack, preserved for sentimental value)
            //
            // If ReplaceIfExists is TRUE, prepend an exclamation point
            // to the new filename in order to pass this bit of data
            // along to the session manager.
            //

            if (ReplaceIfExists && NewFileName.Length != 0) {
                PWSTR NewBuffer;

                NewBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                             MAKE_TAG( TMP_TAG ),
                                             NewFileName.Length + sizeof(WCHAR) );
                if (NewBuffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    leave;
                }

                NewBuffer[0] = L'!';
                CopyMemory(&NewBuffer[1], NewFileName.Buffer, NewFileName.Length);
                NewFileName.Length += sizeof(WCHAR);
                NewFileName.MaximumLength += sizeof(WCHAR);
                RtlFreeHeap(RtlProcessHeap(), 0, NewFileName.Buffer);
                NewFileName.Buffer = NewBuffer;
            }

            //
            // Check to see if the existing file is on a remote share. If it
            // is, flag the error rather than let the operation silently fail
            // because the delayed operations are done before the net is
            // available. Rather than open the file and do a hard core file type,
            // we just check for UNC in the file name. This isn't perfect, but it is
            // pretty good. Chances are we can not open and manipulate the file. That is
            // why the caller is using the delay until reboot option !
            //

            if ( RtlDetermineDosPathNameType_U(lpExistingFileName) == RtlPathTypeUncAbsolute ) {
                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // copy allowed is not permitted on delayed renames
            //

            else if ( dwFlags & MOVEFILE_COPY_ALLOWED ) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
	        Status = BasepMoveFileDelayed( &OldFileName,
					       &NewFileName,
					       2,
					       FALSE );
		if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
		    Status = BasepMoveFileDelayed( &OldFileName,
						   &NewFileName,
						   1,
						   TRUE );
		    if (Status == STATUS_INSUFFICIENT_RESOURCES) {
                        Status = BasepMoveFileDelayed( &OldFileName,
						       &NewFileName,
						       2,
						       TRUE );
		    }
		}
            }

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                leave;
            }

            b = TRUE;
            leave;
        }

        //
        //  We must to the real move now.
        //

        NewName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), NewFileName.Length+sizeof(*NewName));

        if (NewName == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            leave;
        }

        RtlMoveMemory( NewName->FileName, NewFileName.Buffer, NewFileName.Length );

        NewName->ReplaceIfExists = ReplaceIfExists;
        NewName->RootDirectory = NULL;
        NewName->FileNameLength = NewFileName.Length;

        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    NewName,
                    NewFileName.Length+sizeof(*NewName),
                    (dwFlags & MOVEFILE_CREATE_HARDLINK) ?
                        FileLinkInformation :
                        FileRenameInformation
                    );

        RtlFreeHeap(RtlProcessHeap(), 0, NewName);

        if (NT_SUCCESS( Status )) {
            b = TRUE;
            leave;
        }

        if (Status != STATUS_NOT_SAME_DEVICE || (dwFlags & MOVEFILE_COPY_ALLOWED) == 0) {
            BaseSetLastNTError( Status );
            leave;
        }

        NtClose( Handle );
        Handle = INVALID_HANDLE_VALUE;

        //
        //  Perform a copy/delete.  Handle link tracking.
        //

        {
            HANDLE hSource = INVALID_HANDLE_VALUE;
            HANDLE hDest = INVALID_HANDLE_VALUE;

            Context.dwFlags = dwFlags;
            Context.lpProgressRoutine = lpProgressRoutine;
            Context.lpData = lpData;

            b = (BOOLEAN)BasepCopyFileExW(
                            lpExistingFileName,
                            lpNewFileName,
                            BasepMoveFileCopyProgress,
                            &Context,
                            NULL,
                            (ReplaceIfExists ? 0 : COPY_FILE_FAIL_IF_EXISTS) | COPY_FILE_OPEN_SOURCE_FOR_WRITE,
                            0, // PrivCopyFile flags
                            &hSource,
                            &hDest
                            );

            if ( b && hSource != INVALID_HANDLE_VALUE && hDest != INVALID_HANDLE_VALUE) {

                //
                // attempt to do tracking
                //

                Status = BasepNotifyTrackingService( &hSource,
                                                     &Obja,
                                                     hDest,
                                                     &NewFileName );


                if ( !NT_SUCCESS(Status) &&
                    (dwFlags & MOVEFILE_FAIL_IF_NOT_TRACKABLE)) {

                    if (hDest != INVALID_HANDLE_VALUE)
                        CloseHandle( hDest );

                    hDest = INVALID_HANDLE_VALUE;
                    DeleteFileW( lpNewFileName );
                    b = FALSE;

                    BaseSetLastNTError( Status );

                }
            }

            if (hSource != INVALID_HANDLE_VALUE) {
                CloseHandle(hSource);
                hSource = INVALID_HANDLE_VALUE;
            }

            if (hDest != INVALID_HANDLE_VALUE) {
                CloseHandle(hDest);
                hDest = INVALID_HANDLE_VALUE;
            }

            //
            // the copy worked... Delete the source of the rename
            // if it fails, try a set attributes and then a delete
            //

            if (b && !DeleteFileW( lpExistingFileName ) ) {

                //
                // If the delete fails, we will return true, but possibly
                // leave the source dangling
                //

                SetFileAttributesW(lpExistingFileName,FILE_ATTRIBUTE_NORMAL);
                DeleteFileW( lpExistingFileName );
            }
        }

    } finally {
        if (Handle != INVALID_HANDLE_VALUE) {
            NtClose( Handle );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, OldFileName.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, NewFileName.Buffer );
    }

    return b;
}


NTSTATUS
BasepMoveFileDelayed(
    IN PUNICODE_STRING OldFileName,
    IN PUNICODE_STRING NewFileName,
    IN ULONG Index,
    IN BOOL OkayToCreateNewValue
    )

/*++

Routine Description:

    Appends the given delayed move file operation to the registry
    value that contains the list of move file operations to be
    performed on the next boot.

Arguments:

    OldFileName - Supplies the old file name

    NewFileName - Supplies the new file name

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    HANDLE KeyHandle;
    PWSTR ValueData, s;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    ULONG ValueLength = 1024;
    ULONG ReturnedLength;
    WCHAR ValueNameBuf[64];
    NTSTATUS Status;


    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

    if (Index == 1) {
        RtlInitUnicodeString( &ValueName, L"PendingFileRenameOperations" );
    } else {
        swprintf(ValueNameBuf,L"PendingFileRenameOperations%d",Index);
        RtlInitUnicodeString( &ValueName, ValueNameBuf );
    }

    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateKey( &KeyHandle,
                          GENERIC_READ | GENERIC_WRITE,
                          &Obja,
                          0,
                          NULL,
                          0,
                          NULL
                        );
    if ( Status == STATUS_ACCESS_DENIED ) {
        Status = NtCreateKey( &KeyHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &Obja,
                              0,
                              NULL,
                              REG_OPTION_BACKUP_RESTORE,
                              NULL
                            );
    }

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        ValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG(TMP_TAG),
                                    ValueLength + OldFileName->Length + sizeof(WCHAR) +
                                                  NewFileName->Length + 2*sizeof(WCHAR));

        if (ValueInfo == NULL) {
            NtClose(KeyHandle);
            return(STATUS_NO_MEMORY);
        }

        //
        // File rename operations are stored in the registry in a
        // single MULTI_SZ value. This allows the renames to be
        // performed in the same order that they were originally
        // requested. Each rename operation consists of a pair of
        // NULL-terminated strings.
        //

        Status = NtQueryValueKey(KeyHandle,
                                 &ValueName,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 ValueLength,
                                 &ReturnedLength);

        if (Status != STATUS_BUFFER_OVERFLOW) {
            break;
        }

        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = ReturnedLength;
        RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
    }

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND)
	&& OkayToCreateNewValue) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData = (PWSTR)ValueInfo;
    } else if (NT_SUCCESS(Status)) {
        //
        // A value already exists, append our two strings to the
        // MULTI_SZ.
        //
        ValueData = (PWSTR)(&ValueInfo->Data);
        s = (PWSTR)((PCHAR)ValueData + ValueInfo->DataLength) - 1;
    } else {
        NtClose(KeyHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
        return(Status);
    }

    CopyMemory(s, OldFileName->Buffer, OldFileName->Length);
    s += (OldFileName->Length/sizeof(WCHAR));
    *s++ = L'\0';

    CopyMemory(s, NewFileName->Buffer, NewFileName->Length);
    s += (NewFileName->Length/sizeof(WCHAR));
    *s++ = L'\0';
    *s++ = L'\0';

    Status = NtSetValueKey(KeyHandle,
                           &ValueName,
                           0,
                           REG_MULTI_SZ,
                           ValueData,
                           (ULONG)((s-ValueData)*sizeof(WCHAR)));
    NtClose(KeyHandle);
    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);

    return(Status);
}




NTSTATUS
BasepOpenFileForMove( IN     LPCWSTR lpFileName,
                      OUT    PUNICODE_STRING FileName,
                      OUT    PVOID *FileNameFreeBuffer,
                      OUT    PHANDLE Handle,
                      OUT    POBJECT_ATTRIBUTES Obja,
                      IN     ULONG DesiredAccess,
                      IN     ULONG ShareAccess,
                      IN     ULONG OpenOptions )
/*++

Routine Description:

    Opens a file such that it may be used in MoveFile or MoveFileIdentity.

Arguments:

    lpFileName - the file to open

    FileName - lpFileName translated to an NT path

    FileNameFreeBuffer - a buffer which needs to be freed when FileName
        is no longer in use

    Handle - Location in which to put the handle for the opened file.

    Obja - Object attributes used to open the file

    DesiredAccess - Access flags which must be set, in addition to
        FILE_READ_ATTRIBUTES and SYNCHRONIZE which may also be set.

    ShareAccess - Sharing flags which must be set, though additional
        flags may also be set.

    OpenOptions - FILE_OPEN_ flags which must be set, though
        FILE_OPEN_REPARSE_POINT, FILE_SYNCHRONOUS_IO_NONALERT, and
        FILE_OPEN_FOR_BACKUP_INTENT may also be set.


Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;

    try
    {

        FileName->Length = FileName->MaximumLength = 0;
        FileName->Buffer = NULL;
        *FileNameFreeBuffer = NULL;

        //
        //  Initialize the object attributes
        //

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpFileName,
                                FileName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            leave;
        }
        *FileNameFreeBuffer = FileName->Buffer;


        if ( RelativeName.RelativeName.Length ) {
            *FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        } else {
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
                                  Obja,
                                  FileName,
                                  OBJ_CASE_INSENSITIVE,
                                  RelativeName.ContainingDirectory,
                                  NULL
                                  );

        //
        //  Establish whether we are handling a symbolic link or not by:
        //      (1) obtaining a handle to the local entity, and
        //      (2) finding whether a symbolic link was found.
        //
        //  Open the file for delete access inhibiting the reparse
        //  point behavior.
        //

        OpenOptions |= (FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

        Status = NtOpenFile( Handle,
                             FILE_READ_ATTRIBUTES | SYNCHRONIZE | DesiredAccess,
                             Obja,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | ShareAccess,
                             FILE_OPEN_REPARSE_POINT | OpenOptions
                             );


        if (!NT_SUCCESS( Status )) {

            //
            //  Back level file systems may not support reparse points and thus not
            //  support symbolic links.
            //
            //  We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
            //

            if ( Status == STATUS_INVALID_PARAMETER ) {

                //
                //  Retry the open without reparse behaviour.  This should be compatible
                //  with older file systems.
                //

                Status = NtOpenFile(
                                   Handle,
                                   SYNCHRONIZE | DesiredAccess,
                                   Obja,
                                   &IoStatusBlock,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE | ShareAccess,
                                   OpenOptions
                                   );
            }

            if ( !NT_SUCCESS( Status ) ) {

                leave;
            }

        } else {

            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

            //
            //  The open succeeded. If we do not find a symbolic link or a mount point,
            //  re-open without inhibiting the reparse behavior.
            //

            Status = NtQueryInformationFile(
                                           *Handle,
                                           &IoStatusBlock,
                                           (PVOID) &FileTagInformation,
                                           sizeof(FileTagInformation),
                                           FileAttributeTagInformation
                                           );

            if ( !NT_SUCCESS( Status ) ) {

                //
                //  Not all File Systems implement all information classes.
                //  The value STATUS_INVALID_PARAMETER is returned when a non-supported
                //  information class is requested to a back-level File System. As all the
                //  parameters to NtQueryInformationFile are correct, we can infer that
                //  we found a back-level system.
                //
                //  If FileAttributeTagInformation is not implemented, we assume that
                //  the file at hand is not a reparse point.
                //

                if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                     (Status != STATUS_INVALID_PARAMETER) ) {

                    leave;
                }
            }

            if ( NT_SUCCESS(Status) &&
                 (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
                 FileTagInformation.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {

                //
                //  Open without inhibiting the reparse behavior and not needing to
                //  read the attributes.
                //

                NtClose( *Handle );
                *Handle = INVALID_HANDLE_VALUE;

                Status = NtOpenFile(
                                   Handle,
                                   SYNCHRONIZE | DesiredAccess,
                                   Obja,
                                   &IoStatusBlock,
                                   FILE_SHARE_DELETE | FILE_SHARE_READ | ShareAccess,
                                   OpenOptions
                                   );

                if ( !NT_SUCCESS( Status ) ) {

                    leave;
                }
            }
        }
    }
    finally
    {
    }

    return( Status );

}



BOOL
APIENTRY
PrivMoveFileIdentityW(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    )

/*++

Routine Description:

    Moves an identity from one file to another.  The identity is composed
    of the file's create date, and its object ID.  The Object ID isn't
    necessarily copied straight across; it's handled as if the actual
    file were being moved by MoveFileWithProgressW.

Arguments:

    lpOldFileName - Supplies the old file name

    lpNewFileName - Supplies the new file name

Return Value:

    TRUE if successful.  Otherwise the error can be found by calling GetLastError().

--*/

{   // MOVE_FILEIDentityW

    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusIgnored = STATUS_SUCCESS;
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    UNICODE_STRING SourceFileName = { 0, 0, NULL };
    PVOID SourceFileNameFreeBuffer = NULL;
    UNICODE_STRING DestFileName = { 0, 0, NULL };
    PVOID DestFileNameFreeBuffer = NULL;
    BOOL TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    OBJECT_ATTRIBUTES SourceObja;
    OBJECT_ATTRIBUTES DestObja;
    ULONG OpenFlags;
    FILE_DISPOSITION_INFORMATION DispositionInformation = { TRUE };
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION SourceBasicInfo;
    FILE_BASIC_INFORMATION DestBasicInfo;
    DWORD SourceFileAccess;
    DWORD DestFileAccess;

    try {

        // Open the source file.  It must be opened for write or the
        // FileTrackingInformation call will fail.

        SourceFileAccess = FILE_WRITE_DATA | FILE_READ_ATTRIBUTES;
        if( dwFlags & PRIVMOVE_FILEID_DELETE_OLD_FILE ) {
            SourceFileAccess |= DELETE;
        }

        while( TRUE ) {

            Status = BasepOpenFileForMove( lpOldFileName,
                                           &SourceFileName,
                                           &SourceFileNameFreeBuffer,
                                           &SourceFile,
                                           &SourceObja,
                                           SourceFileAccess,
                                           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           FILE_OPEN_NO_RECALL );
            if( NT_SUCCESS(Status) ) {
                break;
            } else {

                // We might be able to try again without requesting write access
                if( (SourceFileAccess & FILE_WRITE_DATA) &&
                    (dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS) ) {

                    // Try again without write access
                    SourceFileAccess &= ~FILE_WRITE_DATA;

                    if( NT_SUCCESS(StatusIgnored) ) {
                        StatusIgnored = Status;
                    }
                    Status = STATUS_SUCCESS;
                } else {
                    // Nothing we can do.
                    break;
                }
            }
        }

        if( !NT_SUCCESS(Status) ) {
            leave;
        }

        // Open the destination file

        DestFileAccess = FILE_WRITE_ATTRIBUTES;
        if( SourceFileAccess & FILE_WRITE_DATA )
            DestFileAccess |= FILE_WRITE_DATA;

        while( TRUE ) {

            Status = BasepOpenFileForMove( lpNewFileName,
                                           &DestFileName,
                                           &DestFileNameFreeBuffer,
                                           &DestFile,
                                           &DestObja,
                                           (SourceFileAccess & FILE_WRITE_DATA)
                                                ? FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA
                                                : FILE_WRITE_ATTRIBUTES,
                                           FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ,
                                           FILE_OPEN_NO_RECALL );

            if( NT_SUCCESS(Status) ) {
                break;
            } else {

                // We might be able to try again without requesting write access
                if( (DestFileAccess & FILE_WRITE_DATA) &&
                    (dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS) ) {

                    // Try again
                    DestFileAccess &= ~FILE_WRITE_DATA;

                    if( NT_SUCCESS(StatusIgnored) ) {
                        StatusIgnored = Status;
                    }
                    Status = STATUS_SUCCESS;

                } else {
                    // Nothing we can do.
                    break;
                }
            }
        }

        if( !NT_SUCCESS(Status) ) {
            leave;
        }

        // Copy the create date to the dest file

        Status = NtQueryInformationFile( SourceFile,
                                         &IoStatus,
                                         &SourceBasicInfo,
                                         sizeof(SourceBasicInfo),
                                         FileBasicInformation );
        if( NT_SUCCESS(Status) ) {

            RtlZeroMemory( &DestBasicInfo, sizeof(DestBasicInfo) );
            DestBasicInfo.CreationTime = SourceBasicInfo.CreationTime;

            Status = NtSetInformationFile( DestFile,
                                           &IoStatus,
                                           &DestBasicInfo,
                                           sizeof(DestBasicInfo),
                                           FileBasicInformation );
        }

        // If we had an error and can't ignore it, abort.
        if( !NT_SUCCESS(Status) ) {

            if( dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS ) {
                if( NT_SUCCESS(StatusIgnored) ) {
                    StatusIgnored = Status;
                }
                Status = STATUS_SUCCESS;
            }
            else {
                leave;
            }
        }

        // Transfer the tracking information to the dest file, but only if we
        // were able to get write access to both files.

        if( (DestFileAccess & FILE_WRITE_DATA) &&
            (SourceFileAccess & FILE_WRITE_DATA) ) {

            Status = BasepNotifyTrackingService( &SourceFile,
                                                 &SourceObja,
                                                 DestFile,
                                                 &DestFileName );
            if( !NT_SUCCESS(Status) ) {
                if( dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS ) {
                    if( NT_SUCCESS(StatusIgnored) ) {
                        StatusIgnored = Status;
                    }
                    Status = STATUS_SUCCESS;
                }
                else {
                    leave;
                }
            }
        }

    }
    finally
    {
        if( SourceFileNameFreeBuffer != NULL )
            RtlFreeHeap( RtlProcessHeap(), 0, SourceFileNameFreeBuffer );

        if( DestFileNameFreeBuffer != NULL )
            RtlFreeHeap( RtlProcessHeap(), 0, DestFileNameFreeBuffer );

    }

    // If requested, delete the source file.  DispositionInformation.DeleteFile
    // has already been initialized to TRUE.

    if( NT_SUCCESS(Status) && (dwFlags & PRIVMOVE_FILEID_DELETE_OLD_FILE) ) {

        Status = NtSetInformationFile(
            SourceFile,
            &IoStatus,
            &DispositionInformation,
            sizeof(DispositionInformation),
            FileDispositionInformation
            );
    }

    if( DestFile != INVALID_HANDLE_VALUE )
        NtClose( DestFile );

    if( SourceFile != INVALID_HANDLE_VALUE )
        NtClose( SourceFile );

    if( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
    }
    else if( !NT_SUCCESS(StatusIgnored) ) {
        BaseSetLastNTError(StatusIgnored);
    }

    return( NT_SUCCESS(Status) );

}





DWORD
WINAPI
GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    )
{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return (DWORD)-1;
    }

    return ( GetCompressedFileSizeW((LPCWSTR)Unicode->Buffer,lpFileSizeHigh) );
}

DWORD
WINAPI
GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_COMPRESSION_INFORMATION CompressionInfo;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    DWORD FileSizeLow;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return (DWORD)-1;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN_FOR_BACKUP_INTENT
                );
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }

    //
    // Get the compressed file size.
    //

    Status = NtQueryInformationFile(
                Handle,
                &IoStatusBlock,
                &CompressionInfo,
                sizeof(CompressionInfo),
                FileCompressionInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        FileSizeLow = GetFileSize(Handle,lpFileSizeHigh);
        NtClose(Handle);
        return FileSizeLow;
        }


    NtClose(Handle);
    if ( ARGUMENT_PRESENT(lpFileSizeHigh) ) {
        *lpFileSizeHigh = (DWORD)CompressionInfo.CompressedFileSize.HighPart;
        }
    if (CompressionInfo.CompressedFileSize.LowPart == -1 ) {
        SetLastError(0);
        }
    return CompressionInfo.CompressedFileSize.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\globcs.c ===
#include <stdio.h>
#include <windows.h>


//
// Global Critical Sections have two components. One piece is shared between all
// applications using the global lock. This portion will typically reside in some
// sort of shared memory
//
// The second piece is per-process. This contains a per-process handle to the shared
// critical section lock semaphore. The semaphore is itself shared, but each process
// may have a different handle value to the semaphore.
//
// Global critical sections are attached to by name. The application wishing to
// attach must know the name of the critical section (actually the name of the shared
// lock semaphore, and must know the address of the global portion of the critical
// section
//

typedef struct _GLOBAL_SHARED_CRITICAL_SECTION {
    LONG LockCount;
    LONG RecursionCount;
    DWORD OwningThread;
    DWORD Reserved;
} GLOBAL_SHARED_CRITICAL_SECTION, *PGLOBAL_SHARED_CRITICAL_SECTION;

typedef struct _GLOBAL_LOCAL_CRITICAL_SECTION {
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    HANDLE LockSemaphore;
    DWORD Reserved1;
    DWORD Reserved2;
} GLOBAL_LOCAL_CRITICAL_SECTION, *PGLOBAL_LOCAL_CRITICAL_SECTION;


BOOL
WINAPI
AttachToGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion,
    PGLOBAL_SHARED_CRITICAL_SECTION lpGlobalPortion,
    LPCSTR lpName
    )

/*++

Routine Description:

    This routine attaches to an existing global critical section, or creates and
    initializes the global critical section if it does not already exist.

Arguments:

    lpLocalPortion - Supplies the address of a per-app local portion of the global
        critical section.

    lpGlobalPortion - Supplies the address of the global shared portion of the
        critical section. If the critical section is new, the caller will initialize it.

    lpName - Supplies the name of the critical section.  If an existing
        critical section with this name already exists, then it is not
        reinitialized.  In this case, the caller simply attaches to it.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    HANDLE GlobalMutex;
    HANDLE LockSemaphore;
    BOOL rv;
    DWORD WaitResult;

    //
    // Serialize all global critical section initialization
    //

    GlobalMutex = CreateMutex(NULL,TRUE,"GlobalCsMutex");

    //
    // If the mutex create/open failed, then bail
    //

    if ( !GlobalMutex ) {
        return FALSE;
        }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        //
        // Since the mutex already existed, the request for ownership has no effect.
        // wait for the mutex
        //

        WaitResult = WaitForSingleObject(GlobalMutex,INFINITE);
        if ( WaitResult == WAIT_FAILED ) {
            CloseHandle(GlobalMutex);
            return FALSE;
            }
        }

    //
    // We now own the global critical section creation mutex. Create/Open the
    // named semaphore. If we are the creator, then initialize the critical
    // section. Otherwise just point to it. The global critical section creation
    // allows us to do this safely.
    //

    rv = FALSE;
    LockSemaphore = NULL;
    try {
        LockSemaphore = CreateSemaphore(NULL,0,MAXLONG-1,lpName);

        //
        // If the semaphore create/open failed, then bail
        //

        if ( !GlobalMutex ) {
            rv = FALSE;
            goto finallyexit;
            }

        //
        // See if we attached to the semaphore, or if we created it. If we created it,
        // then we need to init the global structure.
        //

        if ( GetLastError() != ERROR_ALREADY_EXISTS ) {

            //
            // We Created the semaphore, so init the global portion.
            //

            lpGlobalPortion->LockCount = -1;
            lpGlobalPortion->RecursionCount = 0;
            lpGlobalPortion->OwningThread = 0;
            lpGlobalPortion->Reserved = 0;
            }

        lpLocalPortion->LockSemaphore = LockSemaphore;
        LockSemaphore = NULL;
        lpLocalPortion->GlobalPortion = lpGlobalPortion;
        lpLocalPortion->Reserved1 = 0;
        lpLocalPortion->Reserved2 = 0;
        rv = TRUE;
finallyexit:;
        }
    finally {
        ReleaseMutex(GlobalMutex);
        CloseHandle(GlobalMutex);
        if ( LockSemaphore ) {
            CloseHandle(LockSemaphore);
            }
        }

    return rv;
}

BOOL
WINAPI
DetachFromGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    )

/*++

Routine Description:

    This routine detaches from an existing global critical section.

Arguments:

    lpLocalPortion - Supplies the address of a per-app local portion of the global
        critical section.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    HANDLE LockSemaphore;
    HANDLE GlobalMutex;
    DWORD WaitResult;
    BOOL rv;


    //
    // Serialize all global critical section initialization
    //

    GlobalMutex = CreateMutex(NULL,TRUE,"GlobalCsMutex");

    //
    // If the mutex create/open failed, then bail
    //

    if ( !GlobalMutex ) {
        return FALSE;
        }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        //
        // Since the mutex already existed, the request for ownership has no effect.
        // wait for the mutex
        //

        WaitResult = WaitForSingleObject(GlobalMutex,INFINITE);
        if ( WaitResult == WAIT_FAILED ) {
            CloseHandle(GlobalMutex);
            return FALSE;
            }
        }
    LockSemaphore = NULL;
    rv = FALSE;
    try {
        LockSemaphore = lpLocalPortion->LockSemaphore;
        ZeroMemory(lpLocalPortion,sizeof(*lpLocalPortion));
        rv = TRUE;
        }
    finally {
        if ( LockSemaphore ) {
            CloseHandle(LockSemaphore);
            }
        ReleaseMutex(GlobalMutex);
        CloseHandle(GlobalMutex);
        }
    return rv;
}

VOID
WINAPI
EnterGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    )
{
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    DWORD ThreadId;
    LONG IncResult;
    DWORD WaitResult;

    ThreadId = GetCurrentThreadId();
    GlobalPortion = lpLocalPortion->GlobalPortion;

    //
    // Increment the lock variable. On the transition to 0, the caller
    // becomes the absolute owner of the lock. Otherwise, the caller is
    // either recursing, or is going to have to wait
    //

    IncResult = InterlockedIncrement(&GlobalPortion->LockCount);
    if ( !IncResult ) {

        //
        // lock count went from 0 to 1, so the caller
        // is the owner of the lock
        //

        GlobalPortion->RecursionCount = 1;
        GlobalPortion->OwningThread = ThreadId;
        }
    else {

        //
        // If the caller is recursing, then increment the recursion count
        //

        if ( GlobalPortion->OwningThread == ThreadId ) {
            GlobalPortion->RecursionCount++;
            }
        else {
            WaitResult = WaitForSingleObject(lpLocalPortion->LockSemaphore,INFINITE);
            if ( WaitResult == WAIT_FAILED ) {
                RaiseException(GetLastError(),0,0,NULL);
                }
            GlobalPortion->RecursionCount = 1;
            GlobalPortion->OwningThread = ThreadId;
            }
        }
}

VOID
WINAPI
LeaveGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    )
{
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    LONG DecResult;

    GlobalPortion = lpLocalPortion->GlobalPortion;


    //
    // decrement the recursion count. If it is still non-zero, then
    // we are still the owner so don't do anything other than dec the lock
    // count
    //

    if (--GlobalPortion->RecursionCount) {
        InterlockedDecrement(&GlobalPortion->LockCount);
        }
    else {

        //
        // We are really leaving, so give up ownership and decrement the
        // lock count
        //

        GlobalPortion->OwningThread = 0;
        DecResult = InterlockedDecrement(&GlobalPortion->LockCount);

        //
        // Check to see if there are other waiters. If so, then wake up a waiter
        //

        if ( DecResult >= 0 ) {
            ReleaseSemaphore(lpLocalPortion->LockSemaphore,1,NULL);
            }

        }
}

GLOBAL_LOCAL_CRITICAL_SECTION LocalPortion;

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE hFileMap;
    LPVOID SharedMem;
    BOOL b;
    int i;
    DWORD Start,End;
    HANDLE Mutex1;

    //
    // open or create a shared file mapping object
    //

    hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,1024,"MyMem");

    if ( !hFileMap ) {
        printf("create file map failed\n");
        ExitProcess(1);
        }

    SharedMem = MapViewOfFile(hFileMap,FILE_MAP_WRITE,0,0,0);

    if ( !SharedMem ) {
        printf("map view failed\n");
        ExitProcess(1);
        }

    b = AttachToGlobalCriticalSection(&LocalPortion,SharedMem,"MyGlobalCs");

    if ( !b ) {
        printf("attach failed\n");
        ExitProcess(1);
        }

    if ( argc > 1 ) {

        for(i=0;i<30;i++){
            EnterGlobalCriticalSection(&LocalPortion);
            printf("Thread %x is in\n",GetCurrentThreadId());
            Sleep(500);
            LeaveGlobalCriticalSection(&LocalPortion);
            }
        }

    Start = GetTickCount();
    for(i=0;i<1000000;i++){
        EnterGlobalCriticalSection(&LocalPortion);
        LeaveGlobalCriticalSection(&LocalPortion);
        }
    End = GetTickCount();
    printf("Global CS Time %dms\n",End-Start);

    Mutex1 = CreateMutex(NULL,FALSE,NULL);
    Start = GetTickCount();
    for(i=0;i<100000;i++){
        WaitForSingleObject(Mutex1,INFINITE);
        ReleaseMutex(Mutex1);
        }
    End = GetTickCount();
    printf("Mutex Time     %dms\n",(End-Start)*10);

    DetachFromGlobalCriticalSection(&LocalPortion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\killer.c ===
#include <stdio.h>
#include <windows.h>


Spin()
{
    int i;
    for (i=0;1;i++) {
        Sleep(i*7500);
        }
}

void
main(void)
{
    DWORD ThreadId;
    HANDLE Thread;
    int i;
    int failcount;

    failcount = 0;
    for (i = 0;; i++) {
        Thread = CreateThread(NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)Spin,
                    NULL,
                    0,
                    &ThreadId
                    );
        if ( (i/50)*50 == i ) {
            printf("%d threads created\n", i);
            }

        if (!Thread) {
            failcount++;
            printf("%d threads created before %d failure\n", i,failcount);
            Sleep(5000);
            if ( failcount < 10 ) {
                i--;
                goto again;
                }
            break;
            }
        else {
            CloseHandle(Thread);
            }
again:;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\gmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    gmem.c

Abstract:

    This module contains the Win32 Global Memory Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include "winuserp.h"
#include "wowuserp.h"
#include <wow64t.h>

PFNWOWGLOBALFREEHOOK pfnWowGlobalFreeHook = NULL;

VOID
WINAPI
RegisterWowBaseHandlers(
PFNWOWGLOBALFREEHOOK pfn)
{
    pfnWowGlobalFreeHook = pfn;
}


#if i386
#pragma optimize("y",off)
#endif

HGLOBAL
WINAPI
GlobalAlloc(
    UINT uFlags,
    SIZE_T dwBytes
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE hMem;
    LPSTR p;
    ULONG Flags;

    if (uFlags & ~GMEM_VALID_FLAGS) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & GMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }

    if (!(uFlags & GMEM_MOVEABLE)) {
        if (uFlags & GMEM_DDESHARE) {
            Flags |= BASE_HEAP_FLAG_DDESHARE;
            }

        p = RtlAllocateHeap( BaseHeap,
                             MAKE_TAG( GMEM_TAG ) | Flags,
                             dwBytes ? dwBytes : 1
                           );

        if (p == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }

        return p;
        }

    p = NULL;
    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE | HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
    try {
        HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &BaseHeapHandleTable, NULL );
        if (HandleEntry == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            goto Fail;
            }

        hMem = (HANDLE)&HandleEntry->Object;
        if (dwBytes != 0) {
            p = (LPSTR)RtlAllocateHeap( BaseHeap, MAKE_TAG( GMEM_TAG ) | Flags, dwBytes );
            if (p == NULL) {
                HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                HandleEntry = NULL;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            else {
                RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                }
            }
Fail:   ;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (HandleEntry != NULL) {
        HandleEntry->Object = p;
        if (p != NULL) {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
            }
        else {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED | BASE_HANDLE_DISCARDED;
            }

        if (uFlags & GMEM_DISCARDABLE) {
            HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
            }

        if (uFlags & GMEM_MOVEABLE) {
            HandleEntry->Flags |= BASE_HANDLE_MOVEABLE;
            }

        if (uFlags & GMEM_DDESHARE) {
            HandleEntry->Flags |= BASE_HANDLE_SHARED;
            }

        p = (LPSTR)hMem;
        }

    return( (HANDLE)p );
}


HGLOBAL
WINAPI
GlobalReAlloc(
    HANDLE hMem,
    SIZE_T dwBytes,
    UINT uFlags
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE Handle;
    LPSTR p;
    ULONG Flags;

    if ((uFlags & ~(GMEM_VALID_FLAGS | GMEM_MODIFY)) ||
        ((uFlags & GMEM_DISCARDABLE) && !(uFlags & GMEM_MODIFY))
       ) {
#if DBG
        DbgPrint( "*** GlobalReAlloc( %lx ) - invalid flags\n", uFlags );
        BaseHeapBreakPoint();
#endif
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & GMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }
    if (!(uFlags & GMEM_MOVEABLE)) {
        Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
        }

    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE;
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalReAlloc( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                hMem = NULL;
                }
            else
            if (uFlags & GMEM_MODIFY) {
                if (uFlags & GMEM_DISCARDABLE) {
                    HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
                    }
                else {
                    HandleEntry->Flags &= ~BASE_HANDLE_DISCARDABLE;
                    }
                }
            else {
                p = HandleEntry->Object;
                if (dwBytes == 0) {
                    hMem = NULL;
                    if (p != NULL) {
                        if ((uFlags & GMEM_MOVEABLE) && HandleEntry->LockCount == 0) {
                            if (RtlFreeHeap( BaseHeap, Flags, p )) {
                                HandleEntry->Object = NULL;
                                HandleEntry->Flags |= BASE_HANDLE_DISCARDED;
                                hMem = (HANDLE)&HandleEntry->Object;
                                }
                            }
                        else {
#if DBG
                            DbgPrint( "*** GlobalReAlloc( %lx ) - failing with locked handle\n", &HandleEntry->Object );
                            BaseHeapBreakPoint();
#endif
                            }
                        }
                    else {
                        hMem = (HANDLE)&HandleEntry->Object;
                        }
                    }
                else {
                    Flags |= HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
                    if (p == NULL) {
                        p = RtlAllocateHeap( BaseHeap, MAKE_TAG( GMEM_TAG ) | Flags, dwBytes );
                        if (p != NULL) {
                            RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                            }
                        }
                    else {
                        if (!(uFlags & GMEM_MOVEABLE) &&
                            HandleEntry->LockCount != 0
                           ) {
                            Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
                            }
                        else {
                            Flags &= ~HEAP_REALLOC_IN_PLACE_ONLY;
                            }

                        p = RtlReAllocateHeap( BaseHeap, MAKE_TAG( GMEM_TAG ) | Flags, p, dwBytes );
                        }

                    if (p != NULL) {
                        HandleEntry->Object = p;
                        HandleEntry->Flags &= ~BASE_HANDLE_DISCARDED;
                        }
                    else {
                        hMem = NULL;
                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        }
                    }
                }
            }
        else
        if (uFlags & GMEM_MODIFY) {
            if (uFlags & GMEM_MOVEABLE) {
                Handle = hMem;
                if (RtlGetUserInfoHeap( BaseHeap, HEAP_NO_SERIALIZE, (PVOID)hMem, &Handle, NULL )) {
                    if (Handle == hMem || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                        HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &BaseHeapHandleTable,
                                                                                   NULL
                                                                                 );
                        if (HandleEntry == NULL) {
                            hMem = NULL;
                            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                            }
                        else {
                            dwBytes = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, hMem );
                            Flags |= HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
                            HandleEntry->Object = (PVOID)RtlAllocateHeap( BaseHeap,
                                                                            MAKE_TAG( GMEM_TAG ) | Flags,
                                                                            dwBytes
                                                                          );
                            if (HandleEntry->Object == NULL) {
                                HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
                                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                                hMem = NULL;
                                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                                }
                            else {
                                RtlMoveMemory( HandleEntry->Object, hMem, dwBytes );
                                RtlFreeHeap( BaseHeap, HEAP_NO_SERIALIZE, hMem );
                                hMem = (HANDLE)&HandleEntry->Object;
                                HandleEntry->LockCount = 0;
                                HandleEntry->Flags = RTL_HANDLE_ALLOCATED | BASE_HANDLE_MOVEABLE;
                                if (uFlags & GMEM_DISCARDABLE) {
                                    HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
                                    }

                                if ((ULONG_PTR)Handle & GMEM_DDESHARE) {
                                    HandleEntry->Flags |= BASE_HANDLE_SHARED;
                                    }

                                RtlSetUserValueHeap( BaseHeap,
                                                     HEAP_NO_SERIALIZE,
                                                     HandleEntry->Object,
                                                     hMem
                                                   );
                                }
                            }
                        }
                    }
                }
            }
        else {
            hMem = RtlReAllocateHeap( BaseHeap,
                                      MAKE_TAG( GMEM_TAG ) | Flags | HEAP_NO_SERIALIZE,
                                      (PVOID)hMem,
                                      dwBytes
                                    );
            if (hMem == NULL) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        hMem = NULL;
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( (LPSTR)hMem );
}

LPVOID
WINAPI
GlobalLock(
    HGLOBAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );
        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalLock( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
                p = HandleEntry->Object;
                if (p != NULL) {
                    if (HandleEntry->LockCount++ == GMEM_LOCKCOUNT) {
                        HandleEntry->LockCount--;
                        }
                    }
                else {
                    SetLastError( ERROR_DISCARDED );
                    }
                }

            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            p = NULL;
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );

        return( p );
        }
    else {
        if ( (ULONG_PTR)hMem >= SystemRangeStart ) {
            SetLastError( ERROR_INVALID_HANDLE );
            return NULL;
            }
        if (IsBadReadPtr( hMem, 1 )) {
            SetLastError( ERROR_INVALID_HANDLE );
            return NULL;
            }

        return( (LPSTR)hMem );
        }
}


HANDLE
WINAPI
GlobalHandle(
    LPCVOID pMem
    )
{
    HANDLE Handle;
    ULONG Flags;

    RtlLockHeap( BaseHeap );
    try {
        Handle = NULL;
        if (!RtlGetUserInfoHeap( BaseHeap, HEAP_NO_SERIALIZE, (LPVOID)pMem, &Handle, &Flags )) {
            SetLastError( ERROR_INVALID_HANDLE );
            }
        else
        if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
            Handle = (HANDLE)pMem;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( Handle );
}


BOOL
WINAPI
GlobalUnlock(
    HANDLE hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    BOOL Result;

    Result = TRUE;
    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );
        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                PVOID ImageBase;

                //
                // If passed address is NOT part of an image file, then display
                // a debug message.  This prevents apps that call GlobalUnlock
                // with the return value of LockResource from displaying the
                // message.
                //

                if (!RtlPcToFileHeader( (PVOID)hMem, &ImageBase)) {
                    DbgPrint( "*** GlobalUnlock( %lx ) - invalid handle\n", hMem );
                    BaseHeapBreakPoint();
                    }
#endif

                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->LockCount-- == 0) {
                HandleEntry->LockCount++;
                SetLastError( ERROR_NOT_LOCKED );
                Result = FALSE;
                }
            else
            if (HandleEntry->LockCount == 0) {
                SetLastError( NO_ERROR );
                Result = FALSE;
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );
        }

    return( Result );
}


SIZE_T
WINAPI
GlobalSize(
    HANDLE hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    PVOID Handle;
    ULONG Flags;
    SIZE_T dwSize;

    dwSize = MAXULONG_PTR;
    Flags = 0;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                dwSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, (PVOID)hMem );
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalSize( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                dwSize = HandleEntry->Size;
                }
            else {
                dwSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, HandleEntry->Object );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (dwSize == MAXULONG_PTR) {
        SetLastError( ERROR_INVALID_HANDLE );
        return 0;
        }
    else {
        return dwSize;
        }
}

UINT
WINAPI
GlobalFlags(
    HANDLE hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE Handle;
    ULONG Flags;
    UINT uFlags;

    uFlags = GMEM_INVALID_HANDLE;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            Flags = 0;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                uFlags = 0;
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
                uFlags = HandleEntry->LockCount & GMEM_LOCKCOUNT;
                if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                    uFlags |= GMEM_DISCARDED;
                    }

                if (HandleEntry->Flags & BASE_HANDLE_DISCARDABLE) {
                    uFlags |= GMEM_DISCARDABLE;
                    }

                if (HandleEntry->Flags & BASE_HANDLE_SHARED) {
                    uFlags |= GMEM_DDESHARE;
                    }
                }
            }

        if (uFlags == GMEM_INVALID_HANDLE) {
#if DBG
            DbgPrint( "*** GlobalFlags( %lx ) - invalid handle\n", hMem );
            BaseHeapBreakPoint();
#endif
            SetLastError( ERROR_INVALID_HANDLE );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( uFlags );
}


HGLOBAL
WINAPI
GlobalFree(
    HGLOBAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    try {
        if (pfnWowGlobalFreeHook != NULL) {
            if (!(*pfnWowGlobalFreeHook)(hMem)) {
                return NULL;
                }
            }

        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            if (RtlFreeHeap( BaseHeap, 0, (PVOID)hMem )) {
                return NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                return hMem;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        return hMem;
        }

    RtlLockHeap( BaseHeap );
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalFree( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
#if DBG
                if (HandleEntry->LockCount != 0) {
                    DbgPrint( "BASE: GlobalFree called with a locked object.\n" );
                    BaseHeapBreakPoint();
                    }
#endif
                p = HandleEntry->Object;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                if (p == NULL) {
                    hMem = NULL;
                    }
                }
            }
        else {
            p = (LPSTR)hMem;
            }

        if (p != NULL) {
            if (RtlFreeHeap( BaseHeap, HEAP_NO_SERIALIZE, p )) {
                hMem = NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( hMem );
}


SIZE_T
WINAPI
GlobalCompact(
    DWORD dwMinFree
    )
{
    return RtlCompactHeap( BaseHeap, 0 );
}

VOID
WINAPI
GlobalFix(
    HGLOBAL hMem
    )
{
    if (hMem != (HGLOBAL)-1) {
        GlobalLock( hMem );
        }
    return;
}


VOID
WINAPI
GlobalUnfix(
    HGLOBAL hMem
    )
{
    if (hMem != (HGLOBAL)-1) {
        GlobalUnlock( hMem );
        }
    return;
}

LPVOID
WINAPI
GlobalWire(
    HGLOBAL hMem
    )
{
    return GlobalLock( hMem );
}

BOOL
WINAPI
GlobalUnWire(
    HGLOBAL hMem
    )
{
    return GlobalUnlock( hMem );
}

VOID
WINAPI
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    )
{
    DWORD NumberOfPhysicalPages;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    VM_COUNTERS VmCounters;
    QUOTA_LIMITS QuotaLimits;
    NTSTATUS Status;
    PPEB Peb;
    PIMAGE_NT_HEADERS NtHeaders;
    DWORDLONG Memory64;

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    ASSERT(NT_SUCCESS(Status));

    lpBuffer->dwLength = sizeof( *lpBuffer );

    //
    // Capture the number of physical pages as it can change dynamically.
    // If it goes up or down in the middle of this routine, the results may
    // look strange (ie: available > total, etc), but it will quickly
    // right itself.
    //

    NumberOfPhysicalPages = USER_SHARED_DATA->NumberOfPhysicalPages;

#if defined(BUILD_WOW6432)

    //
    // Convert the number of physical pages from the native system to
    // the emulation system.
    //
    
    NumberOfPhysicalPages = NumberOfPhysicalPages * (Wow64GetSystemNativePageSize() / BASE_SYSINFO.PageSize);

#endif

    //
    // Determine the memory load.  < 100 available pages is 100
    // Otherwise load is ((TotalPhys - AvailPhys) * 100) / TotalPhys
    //

    if (PerfInfo.AvailablePages < 100) {
        lpBuffer->dwMemoryLoad = 100;
    }
    else {
        lpBuffer->dwMemoryLoad =
            ((DWORD)(NumberOfPhysicalPages - PerfInfo.AvailablePages) * 100) /
                NumberOfPhysicalPages;
    }

    //
    // Determine the physical memory sizes. 
    //

    Memory64 =  (DWORDLONG)NumberOfPhysicalPages * BASE_SYSINFO.PageSize;

    lpBuffer->dwTotalPhys = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    Memory64 = ((DWORDLONG)PerfInfo.AvailablePages * (DWORDLONG)BASE_SYSINFO.PageSize);

    lpBuffer->dwAvailPhys = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    if (gpTermsrvAdjustPhyMemLimits) {
        gpTermsrvAdjustPhyMemLimits(&(lpBuffer->dwTotalPhys),
                                    &(lpBuffer->dwAvailPhys),
                                    BASE_SYSINFO.PageSize);
    }
    
    //
    // Zero returned values in case the query process fails.
    //

    RtlZeroMemory (&QuotaLimits, sizeof (QUOTA_LIMITS));
    RtlZeroMemory (&VmCounters, sizeof (VM_COUNTERS));

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL );

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessVmCounters,
                                        &VmCounters,
                                        sizeof(VM_COUNTERS),
                                        NULL );
    //
    // Determine the total page file space with respect to this process.
    //

    Memory64 = __min(PerfInfo.CommitLimit, QuotaLimits.PagefileLimit);

    Memory64 *= BASE_SYSINFO.PageSize;

    lpBuffer->dwTotalPageFile = (SIZE_T)__min(Memory64, MAXULONG_PTR);

    //
    // Determine remaining page file space with respect to this process.
    //

    Memory64 = __min(PerfInfo.CommitLimit - PerfInfo.CommittedPages,
                     QuotaLimits.PagefileLimit - VmCounters.PagefileUsage);

    Memory64 *= BASE_SYSINFO.PageSize;

    lpBuffer->dwAvailPageFile = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    lpBuffer->dwTotalVirtual = (BASE_SYSINFO.MaximumUserModeAddress -
                                BASE_SYSINFO.MinimumUserModeAddress) + 1;

    lpBuffer->dwAvailVirtual = lpBuffer->dwTotalVirtual - VmCounters.VirtualSize;

#if !defined(_WIN64)

    //
    // Lie about available memory if application can't handle large (>2GB) addresses
    //

    Peb = NtCurrentPeb();
    NtHeaders = RtlImageNtHeader( Peb->ImageBaseAddress );

    if (NtHeaders && !(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)) {

        if (lpBuffer->dwTotalPhys > 0x7FFFFFFF) {
            lpBuffer->dwTotalPhys = 0x7FFFFFFF;
            }
        if (lpBuffer->dwAvailPhys > 0x7FFFFFFF) {
            lpBuffer->dwAvailPhys = 0x7FFFFFFF;
            }
        if (lpBuffer->dwTotalVirtual > 0x7FFFFFFF) {
            lpBuffer->dwTotalVirtual = 0x7FFFFFFF;
            }
        if (lpBuffer->dwAvailVirtual > 0x7FFFFFFF) {
            lpBuffer->dwAvailVirtual = 0x7FFFFFFF;
            }
        }
#endif

    return;
}


PVOID
WINAPI
VirtualAlloc(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{

    return VirtualAllocEx(
                NtCurrentProcess(),
                lpAddress,
                dwSize,
                flAllocationType,
                flProtect
                );

}

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    return VirtualFreeEx(NtCurrentProcess(),lpAddress,dwSize,dwFreeType);
}

PVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    NTSTATUS Status;

    if (lpAddress != NULL && (ULONG_PTR)lpAddress < BASE_SYSINFO.AllocationGranularity) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    try {
        Status = NtAllocateVirtualMemory( hProcess,
                                          &lpAddress,
                                          0,
                                          &dwSize,
                                          flAllocationType,
                                          flProtect
                                        );
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        }

    if (NT_SUCCESS( Status )) {
        return( lpAddress );
        }
    else {
        BaseSetLastNTError( Status );
        return( NULL );
        }
}

BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    NTSTATUS Status;


    if ( (dwFreeType & MEM_RELEASE ) && dwSize != 0 ) {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE;
        }

    Status = NtFreeVirtualMemory( hProcess,
                                  &lpAddress,
                                  &dwSize,
                                  dwFreeType
                                );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtFreeVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  dwFreeType
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }

        BaseSetLastNTError( Status );
        return( FALSE );
        }
}


BOOL
WINAPI
VirtualProtect(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{

    return VirtualProtectEx( NtCurrentProcess(),
                             lpAddress,
                             dwSize,
                             flNewProtect,
                             lpflOldProtect
                           );
}

BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{
    NTSTATUS Status;

    Status = NtProtectVirtualMemory( hProcess,
                                     &lpAddress,
                                     &dwSize,
                                     flNewProtect,
                                     lpflOldProtect
                                   );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtProtectVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  flNewProtect,
                                                  lpflOldProtect
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

SIZE_T
WINAPI
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    )
{

    return VirtualQueryEx( NtCurrentProcess(),
                           lpAddress,
                           (PMEMORY_BASIC_INFORMATION)lpBuffer,
                           dwLength
                         );
}

SIZE_T
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    )
{
    NTSTATUS Status;
    SIZE_T ReturnLength;

    Status = NtQueryVirtualMemory( hProcess,
                                   (LPVOID)lpAddress,
                                   MemoryBasicInformation,
                                   (PMEMORY_BASIC_INFORMATION)lpBuffer,
                                   dwLength,
                                   &ReturnLength
                                 );
    if (NT_SUCCESS( Status )) {
        return( ReturnLength );
        }
    else {
        BaseSetLastNTError( Status );
        return( 0 );
        }
}

BOOL
WINAPI
VirtualLock(
    LPVOID lpAddress,
    SIZE_T dwSize
    )

/*++

Routine Description:

    This API may be used to lock the specified range of the processes
    address space into memory.  This range is present whenever the
    application is running.  All pages covered by the range must be
    commited.  VirtialLock is in now way related to LocalLock or
    GlobalLock.  It does not perform a handle translation.  Its function
    is to lock memory in the "working set" of the calling process.

    Note that the specified range is used to compute the range of pages
    covered by the lock. A 2 byte lock that straddles a page boundry
    ends up locking both of the pages covered by the range. Also note
    that calls to VirtualLock do not nest.


Arguments:

    lpAddress - Supplies the base address of the region being locked.

    dwSize - Supplies the number of bytes being locked.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    BOOL ReturnValue;

    ReturnValue = TRUE;
    BaseAddress = lpAddress;
    RegionSize = dwSize;

    Status = NtLockVirtualMemory(
                NtCurrentProcess(),
                &lpAddress,
                &RegionSize,
                MAP_PROCESS
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }

    return ReturnValue;
}

BOOL
WINAPI
VirtualUnlock(
    LPVOID lpAddress,
    SIZE_T dwSize
    )

/*++

Routine Description:

    This API may be used to unlock the specified range of the processes
    address space from memory. This call is used to reveres the effects of
    a previous call to VirtualLock. The range specified need not match
    a range passed to a previous VirtualLock call, but it must specify
    a locked range" for this API to be successful.

    Note that the specified range is used to compute the range of pages
    covered by the unlock. A 2 byte unlock that straddles a page boundry
    ends up unlocking both of the pages covered by the range.

Arguments:

    lpAddress - Supplies the base address of the region being unlocked.

    dwSize - Supplies the number of bytes being unlocked.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    BOOL ReturnValue;

    ReturnValue = TRUE;
    BaseAddress = lpAddress;
    RegionSize = dwSize;

    Status = NtUnlockVirtualMemory(
                NtCurrentProcess(),
                &lpAddress,
                &RegionSize,
                MAP_PROCESS
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }

    return ReturnValue;
}

BOOL
WINAPI
FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    SIZE_T dwSize
    )

/*++

Routine Description:

    This function flushes the instruction cache for the specified process.

Arguments:

    hProcess - Supplies a handle to the process in which the instruction
        cache is to be flushed.

    lpBaseAddress - Supplies an optional pointer to base of the region that
        is flushed.

    dwSize - Supplies the length of the region that is flushed if the base
        address is specified.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    BOOL ReturnValue = TRUE;

    Status = NtFlushInstructionCache(
                hProcess,
                (LPVOID)lpBaseAddress,
                dwSize
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }

    return ReturnValue;
}

BOOL
WINAPI
AllocateUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtAllocateUserPhysicalPages( hProcess,
                                          NumberOfPages,
                                          PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

BOOL
WINAPI
FreeUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtFreeUserPhysicalPages( hProcess,
                                      NumberOfPages,
                                      PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

BOOL
WINAPI
MapUserPhysicalPages(
    PVOID VirtualAddress,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtMapUserPhysicalPages( VirtualAddress,
                                     NumberOfPages,
                                     PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

BOOL
WINAPI
MapUserPhysicalPagesScatter(
    PVOID *VirtualAddresses,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtMapUserPhysicalPagesScatter( VirtualAddresses,
                                            NumberOfPages,
                                            PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

BOOL
WINAPI
GlobalMemoryStatusEx(
    LPMEMORYSTATUSEX lpBuffer
    )
{
    DWORD NumberOfPhysicalPages;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    VM_COUNTERS VmCounters;
    QUOTA_LIMITS QuotaLimits;
    DWORDLONG AvailPageFile;
    DWORDLONG PhysicalMemory;
    NTSTATUS Status;
    DWORD Success;
    DWORDLONG address64;

    if (lpBuffer->dwLength != sizeof(*lpBuffer)) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    ASSERT(NT_SUCCESS(Status));

    //
    // Capture the number of physical pages as it can change dynamically.
    // If it goes up or down in the middle of this routine, the results may
    // look strange (ie: available > total, etc), but it will quickly
    // right itself.
    //

    NumberOfPhysicalPages = USER_SHARED_DATA->NumberOfPhysicalPages;

#if defined(BUILD_WOW6432)

    //
    // Convert the number of physical pages from the native system to
    // the emulation system.
    //
    
    NumberOfPhysicalPages = NumberOfPhysicalPages * (Wow64GetSystemNativePageSize() / BASE_SYSINFO.PageSize);

#endif

    PhysicalMemory =  (DWORDLONG)NumberOfPhysicalPages * BASE_SYSINFO.PageSize;

    //
    // Determine the memory load.  < 100 available pages is 100
    // Otherwise load is ((TotalPhys - AvailPhys) * 100) / TotalPhys
    //

    if (PerfInfo.AvailablePages < 100) {
        lpBuffer->dwMemoryLoad = 100;
        }
    else {
        lpBuffer->dwMemoryLoad =
            ((DWORD)(NumberOfPhysicalPages - PerfInfo.AvailablePages) * 100) /
                NumberOfPhysicalPages;
        }

    lpBuffer->ullTotalPhys = PhysicalMemory;

    PhysicalMemory = PerfInfo.AvailablePages;

    PhysicalMemory *= BASE_SYSINFO.PageSize;

    lpBuffer->ullAvailPhys = PhysicalMemory;

    //
    // Zero returned values in case the query process fails.
    //

    RtlZeroMemory (&QuotaLimits, sizeof (QUOTA_LIMITS));
    RtlZeroMemory (&VmCounters, sizeof (VM_COUNTERS));

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL );

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessVmCounters,
                                        &VmCounters,
                                        sizeof(VM_COUNTERS),
                                        NULL );
    //
    // Determine the total page file space with respect to this process.
    //

    lpBuffer->ullTotalPageFile = PerfInfo.CommitLimit;
    if (QuotaLimits.PagefileLimit < PerfInfo.CommitLimit) {
        lpBuffer->ullTotalPageFile = QuotaLimits.PagefileLimit;
    }

    lpBuffer->ullTotalPageFile *= BASE_SYSINFO.PageSize;

    //
    // Determine remaining page file space with respect to this process.
    //

    AvailPageFile = PerfInfo.CommitLimit - PerfInfo.CommittedPages;

    lpBuffer->ullAvailPageFile =
                    QuotaLimits.PagefileLimit - VmCounters.PagefileUsage;

    if ((ULONG)lpBuffer->ullAvailPageFile > (ULONG)AvailPageFile) {
        lpBuffer->ullAvailPageFile = AvailPageFile;
    }

    lpBuffer->ullAvailPageFile *= BASE_SYSINFO.PageSize;

    lpBuffer->ullTotalVirtual = (BASE_SYSINFO.MaximumUserModeAddress -
                               BASE_SYSINFO.MinimumUserModeAddress) + 1;

    lpBuffer->ullAvailVirtual = lpBuffer->ullTotalVirtual - VmCounters.VirtualSize;

    lpBuffer->ullAvailExtendedVirtual = 0;

    return TRUE;
}

WINBASEAPI
UINT
WINAPI
GetWriteWatch(
    DWORD dwFlags,	
    PVOID lpBaseAddress,
    SIZE_T dwRegionSize,
    PVOID *addresses,
    ULONG_PTR *count,
    LPDWORD granularity
    )
{
    NTSTATUS Status;

    Status = NtGetWriteWatch ( NtCurrentProcess(),
                               dwFlags,
                               lpBaseAddress,
                               dwRegionSize,
                               addresses,
                               count,
                               granularity
                               );

    //
    // Note these return codes are taken straight from Win9x.
    //

    if (NT_SUCCESS( Status )) {
        return( 0 );
        }
    else {
        BaseSetLastNTError( Status );
        return (UINT)-1;
        }
}

WINBASEAPI
UINT
WINAPI
ResetWriteWatch(
    LPVOID lpBaseAddress,
    SIZE_T dwRegionSize
    )
{
    NTSTATUS Status;

    Status = NtResetWriteWatch ( NtCurrentProcess(),
                                 lpBaseAddress,
                                 dwRegionSize
                                 );

    //
    // Note these return codes are taken straight from Win9x.
    //

    if (NT_SUCCESS( Status )) {
        return( 0 );
        }
    else {
        BaseSetLastNTError( Status );
        return (UINT)-1;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\fileopcr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fileopcr.c

Abstract:

    This module implements File open and Create APIs for Win32

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/


#include "basedll.h"
#include "mountmgr.h"
#include "aclapi.h"
#include "winefs.h"

WCHAR BasepDataAttributeType[] = DATA_ATTRIBUTE_NAME;

typedef BOOL (WINAPI *ENCRYPTFILEWPTR)(LPCWSTR);
typedef BOOL (WINAPI *DECRYPTFILEWPTR)(LPCWSTR, DWORD);

extern const WCHAR AdvapiDllString[] = L"advapi32.dll";

#define BASE_OF_SHARE_MASK 0x00000070
#define TWO56K ( 256 * 1024 )
ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    )
{
    DWORD ShareMode;

    if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_READ ) {
        ShareMode = FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_WRITE ) {
        ShareMode = FILE_SHARE_READ;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_NONE ) {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_EXCLUSIVE ) {
        ShareMode = 0;
        }
    else {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;
        }
    return ShareMode;
}


typedef DWORD (WINAPI DUPLICATEENCRYPTIONINFOFILE)(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName,
     IN DWORD dwCreationDistribution,
     IN DWORD dwAttributes,
     IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
     );

DUPLICATEENCRYPTIONINFOFILE LoadDuplicateEncryptionInfoFile;
DUPLICATEENCRYPTIONINFOFILE *pfnDuplicateEncryptionInfoFile = LoadDuplicateEncryptionInfoFile;

DWORD
WINAPI
LoadDuplicateEncryptionInfoFile(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName,
     IN DWORD dwCreationDistribution,
     IN DWORD dwAttributes,
     IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
     )
{
    DUPLICATEENCRYPTIONINFOFILE *pfnTemp;
    HANDLE Advapi32 = NULL;
    BOOL ReturnSuccess = FALSE;
    DWORD ErrorReturn = 0;

    Advapi32 = LoadLibraryW( AdvapiDllString );
    if( Advapi32 == NULL ) {
        return GetLastError();
    }

    pfnTemp = (DUPLICATEENCRYPTIONINFOFILE*)
              GetProcAddress( Advapi32, "DuplicateEncryptionInfoFile" );
    if( pfnTemp == NULL ) {
        return GetLastError();
    }

    pfnDuplicateEncryptionInfoFile = pfnTemp;
    return pfnDuplicateEncryptionInfoFile( SrcFileName,
                                           DstFileName, 
                                           dwCreationDistribution, 
                                           dwAttributes, 
                                           lpSecurityAttributes );

}




PUNICODE_STRING
BaseIsThisAConsoleName(
    PCUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    )
{
    PUNICODE_STRING FoundConsoleName;
    ULONG DeviceNameLength;
    ULONG DeviceNameOffset;
    UNICODE_STRING ConString;
    WCHAR sch,ech;

    FoundConsoleName = NULL;
    if ( FileNameString->Length ) {
        sch = FileNameString->Buffer[0];
        ech = FileNameString->Buffer[(FileNameString->Length-1)>>1];

        //
        // if CON, CONOUT$, CONIN$, \\.\CON...
        //
        //

        if ( sch == (WCHAR)'c' || sch == (WCHAR)'C' || sch == (WCHAR)'\\' ||
             ech == (WCHAR)'n' || ech == (WCHAR)'N' || ech == (WCHAR)':' || ech == (WCHAR)'$' ) {


            ConString = *FileNameString;

            DeviceNameLength = RtlIsDosDeviceName_U(ConString.Buffer);
            if ( DeviceNameLength ) {
                DeviceNameOffset = DeviceNameLength >> 16;
                DeviceNameLength &= 0x0000ffff;

                ConString.Buffer = (PWSTR)((PSZ)ConString.Buffer + DeviceNameOffset);
                ConString.Length = (USHORT)DeviceNameLength;
                ConString.MaximumLength = (USHORT)(DeviceNameLength + sizeof(UNICODE_NULL));
                }

            FoundConsoleName = NULL;
            try {

                if (RtlEqualUnicodeString(&ConString,&BaseConsoleInput,TRUE) ) {
                    FoundConsoleName = &BaseConsoleInput;
                    }
                else if (RtlEqualUnicodeString(&ConString,&BaseConsoleOutput,TRUE) ) {
                    FoundConsoleName = &BaseConsoleOutput;
                    }
                else if (RtlEqualUnicodeString(&ConString,&BaseConsoleGeneric,TRUE) ) {
                    if ((dwDesiredAccess & (GENERIC_READ|GENERIC_WRITE)) == GENERIC_READ) {
                        FoundConsoleName = &BaseConsoleInput;
                        }
                    else if ((dwDesiredAccess & (GENERIC_READ|GENERIC_WRITE)) == GENERIC_WRITE){
                        FoundConsoleName = &BaseConsoleOutput;
                        }
                    }
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                return NULL;
                }
            }
        }
    return FoundConsoleName;
}


DWORD
WINAPI
CopyReparsePoint(
    HANDLE hSourceFile,
    HANDLE hDestinationFile
    )

/*++

Routine Description:

    This is an internal routine that copies a reparse point.

Arguments:

    hSourceFile - Provides a handle to the source file.

    hDestinationFile - Provides a handle to the destination file.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
   NTSTATUS Status;
   IO_STATUS_BLOCK IoStatusBlock;
   PUCHAR ReparseBuffer;
   PREPARSE_DATA_BUFFER ReparseBufferHeader;

   //
   //  Allocate the buffer to set the reparse point.
   //

   ReparseBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
   if ( ReparseBuffer == NULL ) {
       BaseSetLastNTError(STATUS_NO_MEMORY);
       return FALSE;
   }

   //
   // Get the reparse point.
   //

   Status = NtFsControlFile(
                hSourceFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_GET_REPARSE_POINT,
                NULL,                                //  Input buffer
                0,                                   //  Input buffer length
                ReparseBuffer,                       //  Output buffer
                MAXIMUM_REPARSE_DATA_BUFFER_SIZE     //  Output buffer length
                );

   if ( !NT_SUCCESS( Status ) ) {
       RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
       BaseSetLastNTError(Status);
       return FALSE;
       }

   //
   // Decode the reparse point buffer.
   //

   ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;

   //
   // Set the reparse point.
   //

   Status = NtFsControlFile(
                hDestinationFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_SET_REPARSE_POINT,
                ReparseBuffer,
                FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                NULL,
                0
                );

   RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);

   if ( !NT_SUCCESS( Status ) ) {
       BaseSetLastNTError(Status);
       return FALSE;
       }

   return TRUE;
}


DWORD
WINAPI
CopyNameGraftNow(
    HANDLE hSourceFile,
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    ULONG CreateOptions,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    LPDWORD lpCopyFlags
    )

/*++

Routine Description:

    This is an internal routine that copies a name grafting file/directory preserving
    its characteristics.

Arguments:

    hSourceFile - Provides a handle to the source file.
    
    lpExistingFileName - Provides the name of the existing, source file.

    lpNewFileName - Provides a name for the target file/stream. This must not
        be a UNC path name.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    pbCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    lpCopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{   // CopyNameGraftNow

    NTSTATUS Status;
    DWORD ReturnValue = FALSE;
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    PUCHAR ReparseBuffer = NULL;
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    COPYFILE_CONTEXT CfContext;
    UNICODE_STRING      SourceFileName;
    UNICODE_STRING      DestFileName;
    PVOID               SourceFileNameBuffer = NULL;
    PVOID               DestFileNameBuffer = NULL;
    RTL_RELATIVE_NAME   DestRelativeName;
    BOOL TranslationStatus;
    BOOL b;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatus;

    //
    // Set up the context if appropriate.
    //

    RtlZeroMemory(&StandardInformation, sizeof(StandardInformation));
    if ( ARGUMENT_PRESENT(lpProgressRoutine) || ARGUMENT_PRESENT(pbCancel) ) {

        CfContext.TotalFileSize = StandardInformation.EndOfFile;
        CfContext.TotalBytesTransferred.QuadPart = 0;
        CfContext.dwStreamNumber = 0;
        CfContext.lpCancel = pbCancel;
        CfContext.lpData = lpData;
        CfContext.lpProgressRoutine = lpProgressRoutine;
    }

    //
    // Allocate the buffer to set the reparse point.
    //

    ReparseBuffer = RtlAllocateHeap( 
                        RtlProcessHeap(), 
                        MAKE_TAG( TMP_TAG ), 
                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE
                        );
    if ( ReparseBuffer == NULL) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return FALSE;
        }

    try {
        //
        // Translate both names.
        //

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpExistingFileName,
                                &SourceFileName,
                                NULL,
                                &DestRelativeName
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            DestFile = INVALID_HANDLE_VALUE;
            leave;
        }
        SourceFileNameBuffer = SourceFileName.Buffer;

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpNewFileName,
                                &DestFileName,
                                NULL,
                                &DestRelativeName
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            DestFile = INVALID_HANDLE_VALUE;
            leave;
        }
        DestFileNameBuffer = DestFileName.Buffer;
     
        //
        // Verify that the source and target are different.
        //
   
        if ( RtlEqualUnicodeString(&SourceFileName, &DestFileName, TRUE) ) {
            //
            // Do nothing. Source and target are the same.
            //
   
            DestFile = INVALID_HANDLE_VALUE;
            leave;
        }
   
        //
        // Open the destination.
        //

        if ( DestRelativeName.RelativeName.Length ) {
            DestFileName = *(PUNICODE_STRING)&DestRelativeName.RelativeName;
        }
        else {
            DestRelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
            &Obja,
            &DestFileName,
            OBJ_CASE_INSENSITIVE,
            DestRelativeName.ContainingDirectory,
            NULL
            );

        Status = NtCreateFile( &DestFile,
                               GENERIC_READ | GENERIC_WRITE,
                               &Obja,
                               &IoStatus,
                               NULL,
                               0,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OPEN_IF,
                               FILE_OPEN_REPARSE_POINT | CreateOptions,
                               NULL,
                               0 );
        if( !NT_SUCCESS(Status) ) {
            DestFile = INVALID_HANDLE_VALUE;
            BaseSetLastNTError(Status);
            leave;
        }
                        
        //
        // We now have the handle to the destination.
        // We get and set the corresponding reparse point.
        //

        Status = NtFsControlFile(
                     hSourceFile,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_GET_REPARSE_POINT,
                     NULL,                                //  Input buffer
                     0,                                   //  Input buffer length
                     ReparseBuffer,                       //  Output buffer
                     MAXIMUM_REPARSE_DATA_BUFFER_SIZE     //  Output buffer length
                     );

        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        //
        // Defensive sanity check. The reparse buffer should be name grafting.
        //

        ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
        if ( ReparseBufferHeader->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {
            BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
            leave;
        }

        //
        // Determine whether the sourse is a volume mount point.
        //

        if ( MOUNTMGR_IS_VOLUME_NAME(&SourceFileName) ) {
            //
            // Set the volume mount point and be done.
            //

            b = SetVolumeMountPointW(
                    lpNewFileName, 
                    ReparseBufferHeader->MountPointReparseBuffer.PathBuffer
                    );
            if ( !b ) {
                leave;
                }
            }
        else {
            //
            // Set the reparse point of type name junction.
            //
   
            Status = NtFsControlFile(
                         DestFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_SET_REPARSE_POINT,
                         ReparseBuffer,
                         FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                         NULL,
                         0
                         );
            }

        if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
             ((Status == STATUS_EAS_NOT_SUPPORTED) ||
              (Status == STATUS_IO_REPARSE_TAG_MISMATCH)) ) {
            //
            // In either of these error conditions, the correct behavior is to
            // first delete the destination file and then copy the name graft.
            //
            // Re-open the destination for the deletion without inhibiting the
            // reparse behavior.
            //

            BOOL DeleteStatus = FALSE;

            CloseHandle(DestFile);
            DestFile = INVALID_HANDLE_VALUE;

            DeleteStatus = DeleteFileW(
                               lpNewFileName
                               );

            if ( !DeleteStatus ) {
                leave;
                }

            //
            // Create the destination name graft. 
            // Notice that either a file or a directory may be created.
            //

            Status = NtCreateFile( &DestFile,
                                   GENERIC_READ | GENERIC_WRITE,
                                   &Obja,
                                   &IoStatus,
                                   NULL,
                                   0,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_CREATE,
                                   FILE_OPEN_REPARSE_POINT | CreateOptions,
                                   NULL,
                                   0 );
            if( !NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                leave;
            }

            //
            // Set the reparse point.
            //

            Status = NtFsControlFile(
                         DestFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_SET_REPARSE_POINT,
                         ReparseBuffer,
                         FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                         NULL,
                         0
                         );
        }   // if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ...

        //
        // Close the destination file and return appropriatelly.
        //

        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            leave;
            }

        //
        // The name graft was copied. Set the last write time for the file
        // so that it matches the input file.
        //

        Status = NtQueryInformationFile(
                     hSourceFile,
                     &IoStatusBlock,
                     (PVOID) &BasicInformation,
                     sizeof(BasicInformation),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        BasicInformation.CreationTime.QuadPart = 0;
        BasicInformation.LastAccessTime.QuadPart = 0;
        BasicInformation.FileAttributes = 0;

        //
        // If the time cannot be set for whatever reason, we still return
        // TRUE.
        //

        Status = NtSetInformationFile(
                     DestFile,
                     &IoStatusBlock,
                     &BasicInformation,
                     sizeof(BasicInformation),
                     FileBasicInformation
                     );

        if ( Status == STATUS_SHARING_VIOLATION ) {

            //
            // IBM PC Lan Program (and other MS-NET servers) return
            // STATUS_SHARING_VIOLATION if an application attempts to perform
            // an NtSetInformationFile on a file handle opened for GENERIC_READ
            // or GENERIC_WRITE.
            //
            // If we get a STATUS_SHARING_VIOLATION on this API we want to:
            //
            //   1) Close the handle to the destination
            //   2) Re-open the file for FILE_WRITE_ATTRIBUTES
            //   3) Re-try the operation.
            //

            CloseHandle(DestFile);

            //
            // Re-Open the destination file inhibiting the reparse behavior as
            // we know that it is a symbolic link.  Please note that we do this
            // using the CreateFileW API.  The CreateFileW API allows you to
            // pass NT native desired access flags, even though it is not
            // documented to work in this manner.
            //

            Status = NtCreateFile( &DestFile,
                                   FILE_WRITE_ATTRIBUTES,
                                   &Obja,
                                   &IoStatus,
                                   NULL,
                                   0,
                                   0,
                                   FILE_OPEN,
                                   FILE_OPEN_REPARSE_POINT | CreateOptions,
                                   NULL,
                                   0 );

            if ( NT_SUCCESS( Status )) {

                //
                // If the open succeeded, we update the file information on
                // the new file.
                //
                // Note that we ignore any errors from this point on.
                //

                Status = NtSetInformationFile(
                             DestFile,
                             &IoStatusBlock,
                             &BasicInformation,
                             sizeof(BasicInformation),
                             FileBasicInformation
                             );

            }
        }

        ReturnValue = TRUE;

    } finally {
        if( INVALID_HANDLE_VALUE != DestFile )
            CloseHandle( DestFile );
        RtlFreeHeap( RtlProcessHeap(), 0, SourceFileNameBuffer );
        RtlFreeHeap( RtlProcessHeap(), 0, DestFileNameBuffer );
        RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
    }

    return ReturnValue;
}


BOOL
WINAPI
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )

/*++

Routine Description:

    ANSI thunk to CopyFileW

--*/

{
    PUNICODE_STRING StaticUnicode;
    UNICODE_STRING DynamicUnicode;
    BOOL b;

    StaticUnicode = Basep8BitStringToStaticUnicodeString( lpExistingFileName );
    if (StaticUnicode == NULL) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicode, lpNewFileName )) {
        return FALSE;
    }

    b = CopyFileExW(
            (LPCWSTR)StaticUnicode->Buffer,
            (LPCWSTR)DynamicUnicode.Buffer,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );

    RtlFreeUnicodeString(&DynamicUnicode);

    return b;
}

BOOL
WINAPI
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )

/*++

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFile.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    bFailIfExists - Supplies a flag that indicates how this operation is
        to proceed if the specified new file already exists.  A value of
        TRUE specifies that this call is to fail.  A value of FALSE
        causes the call to the function to succeed whether or not the
        specified new file exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL b;

    b = CopyFileExW(
            lpExistingFileName,
            lpNewFileName,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );

    return b;
}

BOOL
WINAPI
CopyFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )

/*++

Routine Description:

    ANSI thunk to CopyFileExW

--*/

{
    PUNICODE_STRING StaticUnicode;
    UNICODE_STRING DynamicUnicode;
    BOOL b;

    StaticUnicode = Basep8BitStringToStaticUnicodeString( lpExistingFileName );
    if (StaticUnicode == NULL) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicode, lpNewFileName )) {
        return FALSE;
    }

    b = CopyFileExW(
            (LPCWSTR)StaticUnicode->Buffer,
            (LPCWSTR)DynamicUnicode.Buffer,
            lpProgressRoutine,
            lpData,
            pbCancel,
            dwCopyFlags
            );

    RtlFreeUnicodeString(&DynamicUnicode);

    return b;
}





#define COPY_FILE_VALID_FLAGS (COPY_FILE_FAIL_IF_EXISTS | \
                               COPY_FILE_RESTARTABLE    | \
                               COPY_FILE_OPEN_SOURCE_FOR_WRITE | \
                               COPY_FILE_ALLOW_DECRYPTED_DESTINATION)




NTSTATUS
BasepProcessNameGrafting( HANDLE SourceFile,
                          PBOOL IsNameGrafting,
                          PBOOL bCopyRawSourceFile,
                          PBOOL bOpenFilesAsReparsePoint,
                          PFILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation )
/*++

Routine Description:

    During CopyFile, check to see if the source is a symlink which
    requires special processing during copy.

Arguments:

    SourceFile - Handle for the source of the copy.

    IsNameGrafting - If true on return, the source file is grafted.

    bCopyRawSourceFile - If true on return, the source file needn't be
        reopened.  If false, the file should be reopened without the
        FILE_OPEN_REPARSE_POINT flag.

    bOpenFilesAsReparsePoint - If true on return, source/dest named
        streams should be opened/created with FILE_OPEN_REPARSE_POINT
        specified.

    FileTagInformation - Pointer to location to hold the results of
        NtQueryInformationFile(FileAttributeTagInformation).

Return Value:

    NTSTATUS

--*/


{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = NtQueryInformationFile(
                SourceFile,
                &IoStatus,
                (PVOID) FileTagInformation,
                sizeof(*FileTagInformation),
                FileAttributeTagInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        //  Not all File Systems implement all information classes.
        //  The value STATUS_INVALID_PARAMETER is returned when a non-supported
        //  information class is requested to a back-level File System. As all
        //  the parameters to NtQueryInformationFile are correct, we can infer
        //  in this case that we found a back-level system.
        //

        if ( (Status != STATUS_INVALID_PARAMETER) &&
             (Status != STATUS_NOT_IMPLEMENTED) ) {
            return( Status );
        }
        Status = STATUS_SUCCESS;

        //
        //  If FileAttributeTagInformation is not supported, we assume that
        //  the file at hand is not a reparse point nor a symbolic link.
        //  The copy of these files is the same as the raw copy of a file.
        //  The target file is opened without inhibiting the reparse point
        //  behavior.
        //

        *bCopyRawSourceFile = TRUE;
    } else {
       //
       //  The source file is opened and the file system supports the
       //  FileAttributeTagInformation information class.
       //

       if ( FileTagInformation->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
           //
           //  We have a reparse point at hand.
           //

           if ( FileTagInformation->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {
               //
               //  We found a name grafting operation.
               //

               *IsNameGrafting = TRUE;
           }

       } else {
           //
           //  We have a valid handle.
           //  The underlying file system supports reparse points.
           //  The source file is not a reparse point.
           //  This is the case of a normal file in NT 5.0.
           //  The SourceFile handle can be used for the copy. The copy of
           //  these files is the same as the raw copy of a reparse point.
           //  The target file is opened without inhibiting the reparse
           //  point behavior.
           //

           *bCopyRawSourceFile = TRUE;
       }
    }

    return( Status );
}



BOOL
BasepCopySecurityInformation( LPCWSTR lpExistingFileName,
                              HANDLE SourceFile,
                              ACCESS_MASK SourceFileAccess,
                              LPCWSTR lpNewFileName,
                              HANDLE DestFile,
                              ACCESS_MASK DestFileAccess,
                              SECURITY_INFORMATION SecurityInformation,
                              LPCOPYFILE_CONTEXT Context,
                              DWORD DestFileFsAttributes,
                              PBOOL Canceled );

BOOL
BasepCopyFileCallback( BOOL ContinueByDefault,
                       DWORD Win32ErrorOnStopOrCancel,
                       LPCOPYFILE_CONTEXT Context,
                       PLARGE_INTEGER StreamBytesCopied OPTIONAL,
                       DWORD CallbackReason,
                       HANDLE SourceFile,
                       HANDLE DestFile,
                       OPTIONAL PBOOL Canceled );



BOOL
BasepCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags,
    DWORD dwPrivCopyFlags,  // From PrivCopyFileExW
    LPHANDLE phSource,
    LPHANDLE phDest
    )
{
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    DWORD b = FALSE;
    BOOL IsNameGrafting = FALSE;
    BOOL bCopyRawSourceFile = FALSE;
    BOOL bOpenFilesAsReparsePoint = FALSE;
    ULONG CopySize;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    FILE_STANDARD_INFORMATION FileInformation;
    FILE_BASIC_INFORMATION BasicInformation;
    PFILE_STREAM_INFORMATION StreamInfo;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    UNICODE_STRING StreamName;
    HANDLE OutputStream;
    HANDLE StreamHandle;
    ULONG StreamInfoSize;
    COPYFILE_CONTEXT CfContext;
    LPCOPYFILE_CONTEXT CopyFileContext = NULL;
    RESTART_STATE RestartState;
    DWORD SourceFileAttributes = 0;
    DWORD FlagsAndAttributes = 0;
    DWORD FileFlagBackupSemantics = 0;
    DWORD DestFileFsAttributes = 0;
    DWORD SourceFileAccessDefault;
    DWORD SourceFileAccess = 0;
    DWORD SourceFileFlagsAndAttributes = 0;
    DWORD SourceFileSharing = 0;
    DWORD SourceFileSharingDefault = 0;
    BOOL  CheckedForNameGrafting = FALSE;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

    //
    // Ensure that only valid flags were passed.
    //

    if ( dwCopyFlags & ~COPY_FILE_VALID_FLAGS ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwPrivCopyFlags & ~PRIVCOPY_FILE_VALID_FLAGS ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    // Make sure the copy_file and privcopy_file flags don't overlap
    // in winbase.w.
    ASSERT( (PRIVCOPY_FILE_VALID_FLAGS & COPY_FILE_VALID_FLAGS) == 0 );
    dwCopyFlags |= dwPrivCopyFlags;

    try {

        //
        //  We first establish whether we are copying a reparse point:
        //  (1) obtain a handle inhibiting the reparse point behavior
        //  (2) establish whether a symbolic link was found
        //  (3) establish whether a reparse point that is not a symbolic link
        //      is to be copied in raw format or re-enabling the reparse point
        //      behavior
        //

        // Determine if backup-intent should be set.
        if( (PRIVCOPY_FILE_DIRECTORY|PRIVCOPY_FILE_BACKUP_SEMANTICS) & dwCopyFlags ) {
            FileFlagBackupSemantics = FILE_FLAG_BACKUP_SEMANTICS;
        }

        SourceFileAccessDefault = GENERIC_READ;
        SourceFileAccessDefault |= (dwCopyFlags & COPY_FILE_OPEN_SOURCE_FOR_WRITE) ? GENERIC_WRITE : 0;
        SourceFileAccessDefault |= (dwCopyFlags & PRIVCOPY_FILE_SACL) ? ACCESS_SYSTEM_SECURITY : 0;

        SourceFileFlagsAndAttributes = FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_SEQUENTIAL_SCAN | FileFlagBackupSemantics;
        CheckedForNameGrafting = FALSE;
        SourceFileSharingDefault = FILE_SHARE_READ;

retry_open_SourceFile:

        SourceFileAccess = SourceFileAccessDefault;
        SourceFileSharing = SourceFileSharingDefault;

        while( TRUE ) {

            SourceFile = CreateFileW(
                            lpExistingFileName,
                            SourceFileAccess,
                            SourceFileSharing,
                            NULL,
                            OPEN_EXISTING,
                            SourceFileFlagsAndAttributes,
                            NULL
                            );

            if ( SourceFile == INVALID_HANDLE_VALUE ) {

                // If we tried to get ACCESS_SYSTEM_SECURITY access, that
                // might cause an access or privilege error.
                if( ( GetLastError() == ERROR_PRIVILEGE_NOT_HELD
                      ||
                      GetLastError() == ERROR_ACCESS_DENIED
                    )
                    &&
                    (SourceFileAccess & ACCESS_SYSTEM_SECURITY) ) {

                    // Turn it off
                    SourceFileAccess &= ~ACCESS_SYSTEM_SECURITY;
                }


                // Maybe we should stop requesting write access (done for
                // COPYFILE_OPEN_SOURCE_FOR_WRITE
                else if( ( GetLastError() == ERROR_ACCESS_DENIED ||
                           GetLastError() == ERROR_SHARING_VIOLATION ) &&
                         (GENERIC_WRITE & SourceFileAccess) ) {

                    // Turn it off, but if originally requested,
                    // turn access_system_security back on.
                    SourceFileAccess &= ~GENERIC_WRITE;

                    if( SourceFileAccessDefault & ACCESS_SYSTEM_SECURITY ) {
                        SourceFileAccess |= ACCESS_SYSTEM_SECURITY;
                    }
                }

                // Try sharing for writing.
                else if( !(FILE_SHARE_WRITE & SourceFileSharing) ) {
                    // Add write-sharing
                    SourceFileSharing |= FILE_SHARE_WRITE;

                    // Start back over wrt the access flags
                    SourceFileAccess = SourceFileAccessDefault;
                }

                //
                //  There is the case when we still do not get the file opened and we
                //  do want to proceed with the copy. Pre NT 5.0 systems do not support
                //  FILE_FLAG_OPEN_REPARSE_POINT. If this happens, by initialization we
                //  have that:
                //        IsNameGrafting            is FALSE  and
                //        bCopyRawSourceFile        is FALSE  and
                //        bOpenFilesAsReparsePoint  is FALSE
                //

                else if( FILE_FLAG_OPEN_REPARSE_POINT & SourceFileFlagsAndAttributes ) {
                    // Turn off open-reparse
                    SourceFileFlagsAndAttributes &= ~FILE_FLAG_OPEN_REPARSE_POINT;

                    // Reset the access & sharing back to default
                    SourceFileAccess = SourceFileAccessDefault;
                    SourceFileSharing = SourceFileSharingDefault;
                }


                // Otherwise there's nothing more we can try.
                else {
                    leave;
                }


            }   // if ( SourceFile == INVALID_HANDLE_VALUE )

            // We've opened the source file.  If we haven't yet checked for
            // name grafting (symbolic links), do so now.

            else if( !CheckedForNameGrafting ) {

                CheckedForNameGrafting = TRUE;

                //
                //  Find out whether the file is a symbolic link and whether a reparse
                //  point can be copied with the reparse behavior inhibited.
                //

                Status = BasepProcessNameGrafting( SourceFile,
                                                   &IsNameGrafting,
                                                   &bCopyRawSourceFile,
                                                   &bOpenFilesAsReparsePoint,
                                                   &FileTagInformation );
                if( !NT_SUCCESS(Status) ) {
                    CloseHandle( SourceFile );
                    SourceFile = INVALID_HANDLE_VALUE;
                    BaseSetLastNTError(Status);
                    leave;
                }

                if ( IsNameGrafting ) {
                    //
                    //  Do now the copy of a name grafting file/directory.
                    //

                    Status = CopyNameGraftNow(
                                 SourceFile,
                                 lpExistingFileName,
                                 lpNewFileName,
                                 (PRIVCOPY_FILE_DIRECTORY & dwPrivCopyFlags)
                                     ? (FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT)
                                     : 0,
                                 lpProgressRoutine,
                                 lpData,
                                 pbCancel,
                                 &dwCopyFlags
                                 );

                    CloseHandle(SourceFile);
                    SourceFile = INVALID_HANDLE_VALUE;

                    if( !Status ) {
                        return FALSE;
                    }

                    return TRUE;

                }

                // If we're doing a raw copy, we can start doing the copy with this
                // SourceFile handle.

                if ( bCopyRawSourceFile ) {
                    break; // while( TRUE )
                }

                // Otherwise, we need to reopen without FILE_FLAG_OPEN_REPARSE_POINT;
                else {
                    // Turn off open-as-reparse
                    SourceFileFlagsAndAttributes &= ~FILE_FLAG_OPEN_REPARSE_POINT;

                    CloseHandle( SourceFile );
                    SourceFile = INVALID_HANDLE_VALUE;

                    // Since SourceFileAccess & SourceFileSharing are already set,
                    // the next CreateFile attempt should succeed.
                }

            }   // else if( !CheckedForNameGrafting )

            // Otherwise, we have the file open, and we're done checking for grafting
            else {
                break;
            }

        }   // while( TRUE )


        //
        //  Size the source file to determine how much data is to be copied
        //

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) &FileInformation,
                    sizeof(FileInformation),
                    FileStandardInformation
                    );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        //
        //  Get the timestamp info as well.
        //

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) &BasicInformation,
                    sizeof(BasicInformation),
                    FileBasicInformation
                    );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        SourceFileAttributes = BasicInformation.FileAttributes; // Cache for later use

        //
        // Set up the context if appropriate.
        //

        if ( ARGUMENT_PRESENT(lpProgressRoutine) || ARGUMENT_PRESENT(pbCancel) ) {

            CfContext.TotalFileSize = FileInformation.EndOfFile;
            CfContext.TotalBytesTransferred.QuadPart = 0;
            CfContext.dwStreamNumber = 0;
            CfContext.lpCancel = pbCancel;
            CfContext.lpData = lpData;
            CfContext.lpProgressRoutine = lpProgressRoutine;
            CopyFileContext = &CfContext;
        }

        //
        //  Obtain the full set of streams we have to copy.  Since the Io subsystem does
        //  not provide us a way to find out how much space this information will take,
        //  we must iterate the call, doubling the buffer size upon each failure.
        //
        //  If the underlying file system does not support stream enumeration, we end up
        //  with a NULL buffer.  This is acceptable since we have at least a default
        //  data stream.
        //
        //  We also allocate one more character than necessary since we use the returned
        //  stream names in place when calling BaseCopyStream and we must NUL-terminate
        //  the names
        //

        StreamInfoSize = 4096;
        do {
            StreamInfoBase = RtlAllocateHeap( RtlProcessHeap(),
                                              MAKE_TAG( TMP_TAG ),
                                              StreamInfoSize );

            if ( !StreamInfoBase ) {
                BaseSetLastNTError( STATUS_NO_MEMORY );
                leave;
            }

            Status = NtQueryInformationFile(
                        SourceFile,
                        &IoStatus,
                        (PVOID) StreamInfoBase,
                        StreamInfoSize - sizeof( WCHAR ),
                        FileStreamInformation
                        );

            if ( !NT_SUCCESS(Status) ) {
                //
                //  We failed the call.  Free up the previous buffer and set up
                //  for another pass with a buffer twice as large
                //

                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                StreamInfoBase = NULL;
                StreamInfoSize *= 2;
            }
            else if( IoStatus.Information == 0 ) {
                //
                // There are no streams (SourceFile must be a directory).
                //
                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                StreamInfoBase = NULL;
            }

        } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

        //
        //  If a progress routine or a restartable copy was requested, obtain the
        //  full size of the entire file, including its alternate data streams, etc.
        //

        if ( ARGUMENT_PRESENT(lpProgressRoutine) ||
             (dwCopyFlags & COPY_FILE_RESTARTABLE) ) {

            if ( dwCopyFlags & COPY_FILE_RESTARTABLE ) {

                RestartState.Type = 0x7a9b;
                RestartState.Size = sizeof( RESTART_STATE );
                RestartState.CreationTime = BasicInformation.CreationTime;
                RestartState.WriteTime = BasicInformation.LastWriteTime;
                RestartState.EndOfFile = FileInformation.EndOfFile;
                RestartState.FileSize = FileInformation.EndOfFile;
                RestartState.NumberOfStreams = 0;
                RestartState.CurrentStream = 0;
                RestartState.LastKnownGoodOffset.QuadPart = 0;
            }

            if ( StreamInfoBase != NULL ) {

                ULONGLONG TotalSize = 0;

                StreamInfo = StreamInfoBase;
                while (TRUE) {
                    //
                    // Account for the size of this stream in the overall size of
                    // the file.
                    //

                    TotalSize += StreamInfo->StreamSize.QuadPart;
                    RestartState.NumberOfStreams++;

                    if (StreamInfo->NextEntryOffset == 0) {
                        break;
                    }
                    StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
                }

                RestartState.FileSize.QuadPart =
                    CfContext.TotalFileSize.QuadPart = TotalSize;
                RestartState.NumberOfStreams--;
            }
        }

        //
        //  Set the Basic Info to change only the WriteTime
        //
        BasicInformation.CreationTime.QuadPart = 0;
        BasicInformation.LastAccessTime.QuadPart = 0;
        BasicInformation.FileAttributes = 0;

        //
        // Determine whether or not the copy operation should really be restartable
        // based on the actual, total file size.
        //

        if ( (dwCopyFlags & COPY_FILE_RESTARTABLE) &&
            ( RestartState.FileSize.QuadPart < (512 * 1024) ||
              (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )) {
            dwCopyFlags &= ~COPY_FILE_RESTARTABLE;
        }

        //
        // Copy the default data stream, EAs, etc. to the output file
        //

        b = BaseCopyStream(
                lpExistingFileName,
                SourceFile,
                SourceFileAccess,
                lpNewFileName,
                NULL,
                &FileInformation.EndOfFile,
                &dwCopyFlags,
                &DestFile,
                &CopySize,
                &CopyFileContext,
                &RestartState,
                bOpenFilesAsReparsePoint,
                FileTagInformation.ReparseTag,
                &DestFileFsAttributes   // In: 0, Out: Correct value
                );

        if ( bOpenFilesAsReparsePoint &&
             !b &&
             !((GetLastError() == ERROR_FILE_EXISTS) && (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS)) ) {

            //
            //  Clean up.
            //

            if (!(SourceFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                BaseMarkFileForDelete(DestFile, FILE_ATTRIBUTE_NORMAL);
            }

            if (DestFile != INVALID_HANDLE_VALUE) {
                CloseHandle( DestFile );
                DestFile = INVALID_HANDLE_VALUE;
            }

            if (SourceFileAttributes & FILE_ATTRIBUTE_READONLY) {

                //  Delete the destination file before retry
                //  Some servers (like Win9x) won't let us set file attributes
                //  on the handle we already have opened.  SetFileAttributesW
                //  can do the job nicely, so we'll call that to make sure that
                //  the read-only bit isn't set.
                //  We had to close DestFile before doing this because it was
                //  possibly opened share-exclusive.
                SetFileAttributesW(lpNewFileName, FILE_ATTRIBUTE_NORMAL);
                (void) DeleteFileW(lpNewFileName);
            }

            if (SourceFile != INVALID_HANDLE_VALUE) {
                CloseHandle( SourceFile );
                SourceFile = INVALID_HANDLE_VALUE;
            }

            RtlFreeHeap( RtlProcessHeap(), 0, StreamInfoBase );
            StreamInfoBase = NULL ;

            //
            //  Try again the copy operation without inhibiting the reparse
            //  behavior for the source.
            //

            SourceFileFlagsAndAttributes &= ~FILE_FLAG_OPEN_REPARSE_POINT;
            bOpenFilesAsReparsePoint = FALSE;

            //
            //  Go to re-open the source file without inhibiting the reparse
            //  point behavior and try the copy again.
            //

            goto retry_open_SourceFile;
        }

        if ( b ) {

            //
            // Attempt to determine whether or not this file has any alternate
            // data streams associated with it.  If it does, attempt to copy each
            // to the output file.  Note that the stream information may have
            // already been obtained if a progress routine was requested.
            //

            if ( StreamInfoBase != NULL ) {
                DWORD StreamCount = 0;
                BOOLEAN CheckedForStreamCapable = FALSE;
                BOOLEAN IsStreamCapable = FALSE;
                StreamInfo = StreamInfoBase;

                while (TRUE) {

                    FILE_STREAM_INFORMATION DestStreamInformation;
                    Status = STATUS_SUCCESS;

                    //
                    //  Skip the default data stream since we've already copied
                    //  it.  Alas, this code is NTFS specific and documented
                    //  nowhere in the Io spec.
                    //

                    if (StreamInfo->StreamNameLength <= sizeof(WCHAR) ||
                        StreamInfo->StreamName[1] == ':') {
                        if (StreamInfo->NextEntryOffset == 0)
                            break;      // Done with streams
                        StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo +
                                                                StreamInfo->NextEntryOffset);
                        continue;   // Move on to the next stream
                    }

                    StreamCount++;

                    if ( b == SUCCESS_RETURNED_STATE && CopyFileContext ) {
                        if ( StreamCount < RestartState.CurrentStream ) {
                            CopyFileContext->TotalBytesTransferred.QuadPart += StreamInfo->StreamSize.QuadPart;
                            }
                        else {
                            CopyFileContext->TotalBytesTransferred.QuadPart += RestartState.LastKnownGoodOffset.QuadPart;
                            }
                        }

                    //
                    // If we haven't already, verify that both the source and destination
                    // are really stream capable.
                    //

                    if( !CheckedForStreamCapable ) {

                        struct {
                            FILE_FS_ATTRIBUTE_INFORMATION Info;
                            WCHAR Buffer[ MAX_PATH ];
                        } FileFsAttrInfoBuffer;

                        CheckedForStreamCapable = TRUE;

                        // Check for the supports-streams bit in the dest filesystem.

                        Status = NtQueryVolumeInformationFile( DestFile,
                                                               &IoStatus,
                                                               &FileFsAttrInfoBuffer.Info,
                                                               sizeof(FileFsAttrInfoBuffer),
                                                               FileFsAttributeInformation );
                        if( NT_SUCCESS(Status) &&
                            (FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_NAMED_STREAMS) ) {

                            // It seems redundant to check to see if the source is stream capable,
                            // since we already got back a successful stream enumeration, but some
                            // SMB servers (SCO VisionFS) return success but don't really support
                            // streams.
                        
                            Status = NtQueryVolumeInformationFile( SourceFile,
                                                                   &IoStatus,
                                                                   &FileFsAttrInfoBuffer.Info,
                                                                   sizeof(FileFsAttrInfoBuffer),
                                                                   FileFsAttributeInformation );
                        }


                        if( !NT_SUCCESS(Status) ||
                            !(FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_NAMED_STREAMS) ) {

                            if( NT_SUCCESS(Status) ) {
                                Status = STATUS_NOT_SUPPORTED;
                            }

                            if( dwCopyFlags & PRIVCOPY_FILE_VALID_FLAGS ) {
                                if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                            RtlNtStatusToDosError(Status),
                                                            CopyFileContext,
                                                            NULL,
                                                            PRIVCALLBACK_STREAMS_NOT_SUPPORTED,
                                                            SourceFile,
                                                            DestFile,
                                                            NULL )) {

                                    // LastError has been set, but we need it in Status
                                    // for compatibility with the rest of this routine.
                                    PTEB Teb = NtCurrentTeb();
                                    if ( Teb ) {
                                        Status = Teb->LastStatusValue;
                                    } else {
                                        Status = STATUS_INVALID_PARAMETER;
                                    }

                                    b = FALSE;
                                } else {
                                    // Ignore the named stream loss
                                    Status = STATUS_SUCCESS;
                                }
                            } else {
                                // Ignore the named stream loss.  We'll still try to copy the 
                                // streams, though, since the target might be NT4 which didn't support
                                // the FILE_NAMED_STREAMS bit.  But since IsStreamCapable is FALSE,
                                // if there's an error, we'll ignore it.

                                Status = STATUS_SUCCESS;
                            }
                        }
                        else {
                            Status = STATUS_SUCCESS;
                            IsStreamCapable = TRUE;
                        }
                    }   // if( !CheckedForStreamCapable )


                    if ( b == TRUE ||
                        (b == SUCCESS_RETURNED_STATE &&
                         RestartState.CurrentStream == StreamCount) ) {

                        if ( b != SUCCESS_RETURNED_STATE ) {
                            RestartState.CurrentStream = StreamCount;
                            RestartState.LastKnownGoodOffset.QuadPart = 0;
                            }

                        //
                        // Build a string descriptor for the name of the stream.
                        //

                        StreamName.Buffer = &StreamInfo->StreamName[0];
                        StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                        StreamName.MaximumLength = StreamName.Length;

                        //
                        // Open the source stream.
                        //

                        InitializeObjectAttributes(
                            &ObjectAttributes,
                            &StreamName,
                            0,
                            SourceFile,
                            NULL
                            );

                        //
                        // Inhibit reparse behavior when appropriate.
                        //

                        FlagsAndAttributes = FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY;
                        if ( bOpenFilesAsReparsePoint ) {
                            FlagsAndAttributes |= FILE_OPEN_REPARSE_POINT;
                        }

                        Status = NtCreateFile(
                                    &StreamHandle,
                                    GENERIC_READ | SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &IoStatus,
                                    NULL,
                                    0,
                                    FILE_SHARE_READ,
                                    FILE_OPEN,
                                    FlagsAndAttributes,
                                    NULL,
                                    0
                                    );

                        //If we got a share violation, try again with
                        // FILE_SHARE_WRITE.
                        if ( Status == STATUS_SHARING_VIOLATION ) {
                            DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;

                            Status = NtCreateFile(
                                        &StreamHandle,
                                        GENERIC_READ | SYNCHRONIZE,
                                        &ObjectAttributes,
                                        &IoStatus,
                                        NULL,
                                        0,
                                        dwShare,
                                        FILE_OPEN,
                                        FlagsAndAttributes,
                                        NULL,
                                        0
                                        );
                        }


                        if ( NT_SUCCESS(Status) ) {
                            DWORD dwCopyFlagsNamedStreams;
                            WCHAR LastChar = StreamName.Buffer[StreamName.Length / sizeof( WCHAR )];

                            StreamName.Buffer[StreamName.Length / sizeof( WCHAR )] = L'\0';

                            OutputStream = (HANDLE)NULL;

                            //
                            // For named streams, ignore the fail-if-exists flag.  If the dest
                            // file already existed at the time the copy started, then
                            // we would have failed on the copy of the unnamed stream.  So if
                            // a named stream exists, that means that it was created by some
                            // other process while we were copying the unnamed stream.  The
                            // assumption is that such a stream should be overwritten (this 
                            // scenario can occur with SFM).
                            //

                            dwCopyFlagsNamedStreams = dwCopyFlags & ~COPY_FILE_FAIL_IF_EXISTS;

                            b = BaseCopyStream(
                                    lpExistingFileName,
                                    StreamHandle,
                                    SourceFileAccess,
                                    StreamName.Buffer,
                                    DestFile,
                                    &StreamInfo->StreamSize,
                                    &dwCopyFlagsNamedStreams,
                                    &OutputStream,
                                    &CopySize,
                                    &CopyFileContext,
                                    &RestartState,
                                    bOpenFilesAsReparsePoint,
                                    FileTagInformation.ReparseTag,
                                    &DestFileFsAttributes   // Set by first call to BaseCopyStream
                                    );
                            
                            StreamName.Buffer[StreamName.Length / sizeof( WCHAR )] = LastChar;
                            
                            NtClose(StreamHandle);
                            if ( OutputStream ) {

                                //
                                //  We set the last write time on all streams
                                //  since there is a problem with RDR caching
                                //  open handles and closing them out of order.
                                //

                                if ( b ) {
                                    Status = NtSetInformationFile(
                                                OutputStream,
                                                &IoStatus,
                                                &BasicInformation,
                                                sizeof(BasicInformation),
                                                FileBasicInformation
                                                );
                                }
                                NtClose(OutputStream);
                            }

                        }   // Status = NtCreateFile; if( NT_SUCCESS(Status) )
                    }   // if ( b == TRUE || ...

                    if ( !NT_SUCCESS(Status) ) {
                        b = FALSE;
                        BaseSetLastNTError(Status);
                    }

                    if ( !b ) {

                        // If the target is known to be capable of multi-stream files,
                        // then this is a fatal error.  Otherwise we'll ignore it.

                        if( IsStreamCapable ) {
                            BaseMarkFileForDelete(DestFile,0);
                            break;  // while( TRUE )
                        } else {
                            Status = STATUS_SUCCESS;
                            b = TRUE;
                        }
                    }

                    if (StreamInfo->NextEntryOffset == 0) {
                        break;
                    }

                    StreamInfo =
                        (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo +
                                                   StreamInfo->NextEntryOffset);
                }   // while (TRUE)
            }   // if ( StreamInfoBase != NULL )
        }   // b = BaseCopyStream; if ( b ) ...


        //
        //  If the copy operation was successful, and it was restartable, and the
        //  output file was large enough that it was actually copied in a
        //  restartable manner, then copy the initial part of the file to its
        //  output.
        //
        //  Restartability is accomplished by placing a restart header at the
        //  head of the default data stream.  When the copy is complete, we
        //  overwite this header with the real user data.
        //

        if ( b && (dwCopyFlags & COPY_FILE_RESTARTABLE) ) {

            DWORD BytesToRead, BytesRead;
            DWORD BytesWritten;
            FILE_END_OF_FILE_INFORMATION EofInformation;

            SetFilePointer( SourceFile, 0, NULL, FILE_BEGIN );
            SetFilePointer( DestFile, 0, NULL, FILE_BEGIN );

            BytesToRead = sizeof(RESTART_STATE);
            if ( FileInformation.EndOfFile.QuadPart < sizeof(RESTART_STATE) ) {
                BytesToRead = FileInformation.EndOfFile.LowPart;
            }

            //
            //  Grab true data from the source stream
            //

            b = ReadFile(
                    SourceFile,
                    &RestartState,
                    BytesToRead,
                    &BytesRead,
                    NULL
                    );

            if ( b && (BytesRead == BytesToRead) ) {

                //
                //  Overwrite the restart header in the destination.
                //  After this point, the copy is no longer restartable
                //

                b = WriteFile(
                        DestFile,
                        &RestartState,
                        BytesRead,
                        &BytesWritten,
                        NULL
                        );

                if ( b && (BytesRead == BytesWritten) ) {
                    if ( BytesRead < sizeof(RESTART_STATE) ) {
                        EofInformation.EndOfFile.QuadPart = BytesWritten;
                        Status = NtSetInformationFile(
                                    DestFile,
                                    &IoStatus,
                                    &EofInformation,
                                    sizeof(EofInformation),
                                    FileEndOfFileInformation
                                    );
                        if ( !NT_SUCCESS(Status) ) {
                            BaseMarkFileForDelete(DestFile,0);
                            b = FALSE;
                        }
                    }
                } else {
                    BaseMarkFileForDelete(DestFile,0);
                    b = FALSE;
                }
            } else {
                BaseMarkFileForDelete(DestFile,0);
                b = FALSE;
            }
        }

        //
        // If the copy operation was successful, set the last write time for the
        // default steam so that it matches the input file.
        //

        if ( b ) {
            Status = NtSetInformationFile(
                DestFile,
                &IoStatus,
                &BasicInformation,
                sizeof(BasicInformation),
                FileBasicInformation
                );

            if ( Status == STATUS_SHARING_VIOLATION ) {

                //
                // IBM PC Lan Program (and other MS-NET servers) return
                // STATUS_SHARING_VIOLATION if an application attempts to perform
                // an NtSetInformationFile on a file handle opened for GENERIC_READ
                // or GENERIC_WRITE.
                //
                // If we get a STATUS_SHARING_VIOLATION on this API we want to:
                //
                //   1) Close the handle to the destination
                //   2) Re-open the file for FILE_WRITE_ATTRIBUTES
                //   3) Re-try the operation.
                //

                CloseHandle(DestFile);
                DestFile = INVALID_HANDLE_VALUE;

                //
                //  Re-Open the destination file.  Please note that we do this
                //  using the CreateFileW API.  The CreateFileW API allows you to
                //  pass NT native desired access flags, even though it is not
                //  documented to work in this manner.
                //
                //  Inhibit reparse behavior when appropriate.
                //

                FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
                if ( bOpenFilesAsReparsePoint ) {
                    FlagsAndAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;
                }

                DestFile = CreateFileW(
                            lpNewFileName,
                            FILE_WRITE_ATTRIBUTES,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FlagsAndAttributes | FileFlagBackupSemantics,
                            NULL
                            );

                if ( DestFile != INVALID_HANDLE_VALUE ) {

                    //
                    //  If the open succeeded, we update the file information on
                    //  the new file.
                    //
                    //  Note that we ignore any errors from this point on.
                    //

                    NtSetInformationFile(
                        DestFile,
                        &IoStatus,
                        &BasicInformation,
                        sizeof(BasicInformation),
                        FileBasicInformation
                        );

                }
            }
        }

    } finally {

        *phSource = SourceFile;
        *phDest = DestFile;

        RtlFreeHeap( RtlProcessHeap(), 0, StreamInfoBase );
    }

    return b;
}

BOOL
CopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )

/*

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFileEx.  CopyFileEx also provides
    callbacks and cancellability.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    lpCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    dwCopyFlags - Specifies flags that modify how the file is to be copied:

        COPY_FILE_FAIL_IF_EXISTS - Indicates that the copy operation should
            fail immediately if the target file already exists.

        COPY_FILE_RESTARTABLE - Indicates that the file should be copied in
            restartable mode; i.e., progress of the copy should be tracked in
            the target file in case the copy fails for some reason.  It can
            then be restarted at a later date.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

*/

{
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    BOOL b;

    try
    {
        b = BasepCopyFileExW(
                lpExistingFileName,
                lpNewFileName,
                lpProgressRoutine OPTIONAL,
                lpData OPTIONAL,
                pbCancel OPTIONAL,
                dwCopyFlags,
                0,  // PrivCopyFile flags
                &DestFile,
                &SourceFile
                );

    }
    finally
    {
        if (DestFile != INVALID_HANDLE_VALUE) {
            CloseHandle( DestFile );
        }

        if (SourceFile != INVALID_HANDLE_VALUE) {
            CloseHandle( SourceFile );
        }
    }

    return(b);
}



BOOL
PrivCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )

/*

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFileEx.  CopyFileEx also provides
    callbacks and cancellability.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    lpCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    dwCopyFlags - Specifies flags that modify how the file is to be copied:

        COPY_FILE_FAIL_IF_EXISTS - Indicates that the copy operation should
            fail immediately if the target file already exists.

        COPY_FILE_RESTARTABLE - Indicates that the file should be copied in
            restartable mode; i.e., progress of the copy should be tracked in
            the target file in case the copy fails for some reason.  It can
            then be restarted at a later date.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

*/

{
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    BOOL b;

    if( (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
        (dwCopyFlags & PRIVCOPY_FILE_SUPERSEDE) ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    try
    {
        b = BasepCopyFileExW(
                lpExistingFileName,
                lpNewFileName,
                lpProgressRoutine OPTIONAL,
                lpData OPTIONAL,
                pbCancel OPTIONAL,
                dwCopyFlags & COPY_FILE_VALID_FLAGS,    // Copy flags
                dwCopyFlags & ~COPY_FILE_VALID_FLAGS,   // Priv copy flags
                &DestFile,
                &SourceFile
                );

    }
    finally
    {
        if (DestFile != INVALID_HANDLE_VALUE) {
            CloseHandle( DestFile );
        }

        if (SourceFile != INVALID_HANDLE_VALUE) {
            CloseHandle( SourceFile );
        }
    }

    return(b);
}







DWORD
BasepChecksum(
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a structure.

Arguments:

    Source - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    ULONG PartialSum = 0;

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (((PartialSum >> 16) + PartialSum) & 0xffff);
}

BOOL
BasepRemoteFile(
    HANDLE SourceFile,
    HANDLE DestinationFile
    )

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;

    DeviceInformation.Characteristics = 0;
    Status = NtQueryVolumeInformationFile(
                SourceFile,
                &IoStatus,
                &DeviceInformation,
                sizeof(DeviceInformation),
                FileFsDeviceInformation
                );

    if ( NT_SUCCESS(Status) &&
         (DeviceInformation.Characteristics & FILE_REMOTE_DEVICE) ) {

        return TRUE;

    }

    Status = NtQueryVolumeInformationFile(
                    DestinationFile,
                    &IoStatus,
                    &DeviceInformation,
                    sizeof(DeviceInformation),
                    FileFsDeviceInformation
                    );
    if ( NT_SUCCESS(Status) &&
         DeviceInformation.Characteristics & FILE_REMOTE_DEVICE ) {

        return TRUE;
    }

    return FALSE;
}



DWORD
WINAPI
BasepOpenRestartableFile(
            HANDLE hSourceFile,
            LPCWSTR lpNewFileName,
            PHANDLE DestFile,
            DWORD CopyFlags,
            LPRESTART_STATE lpRestartState,
            LARGE_INTEGER *lpFileSize,
            LPCOPYFILE_CONTEXT *lpCopyFileContext,
            DWORD FlagsAndAttributes,
            BOOL OpenAsReparsePoint )

{   // BasepRestartCopyFile

    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE OverwriteHandle;
    IO_STATUS_BLOCK IoStatus;
    RESTART_STATE RestartState;
    DWORD b = TRUE;
    ULONG BytesRead = 0;


    try {

        //
        // Note that setting the sequential scan flag is an optimization
        // here that works because of the way that the Cache Manager on
        // the target works vis-a-vis unmapping segments of the file
        // behind write operations.  This eventually allows the restart
        // section and the end of the file to both be mapped, which is
        // the desired result.
        //
        // Inhibit reparse behavior when appropriate.
        //

        FlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;

        if ( OpenAsReparsePoint ) {
            //
            // The target has to be opened as reparse point. If
            // this fails the source is to be closed and re-opened
            // without inhibiting the reparse point behavior.
            //

            FlagsAndAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;
        }

        *DestFile = CreateFileW(
                       lpNewFileName,
                       GENERIC_READ | GENERIC_WRITE | DELETE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FlagsAndAttributes,
                       hSourceFile
                       );

        if( *DestFile == INVALID_HANDLE_VALUE ) {

            // Caller should attempt to create/overwrite the dest file
            b = TRUE;
            leave;
        }

        //
        //  The target file already exists, so determine whether
        //  a restartable copy was already proceeding.  If so,
        //  then continue;  else, check to see whether or not
        //  the target file can be replaced.  If not, bail with
        //  an error, otherwise simply overwrite the output file.
        //

        b = ReadFile(
                *DestFile,
                &RestartState,
                sizeof(RESTART_STATE),
                &BytesRead,
                NULL
                );
        if ( !b || BytesRead != sizeof(RESTART_STATE) ) {

            //
            // The file could not be read, or there were not
            // enough bytes to contain a restart record.  In
            // either case, if the output file cannot be
            // replaced, simply return an error now.
            //

            if ( CopyFlags & COPY_FILE_FAIL_IF_EXISTS ) {
                SetLastError( ERROR_ALREADY_EXISTS );
                b = FALSE;  // Fatal error
                leave;
            }

            // The caller should create/overwrite the dest file.
            b = TRUE;
            CloseHandle( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;
            leave;

        }

        //
        // Check the contents of the restart state just
        // read against the known contents of what would
        // be there if this were the same copy operation.
        //

        if ( RestartState.Type != 0x7a9b ||
             RestartState.Size != sizeof(RESTART_STATE) ||
             RestartState.FileSize.QuadPart != lpRestartState->FileSize.QuadPart ||
             RestartState.EndOfFile.QuadPart != lpRestartState->EndOfFile.QuadPart ||
             RestartState.NumberOfStreams != lpRestartState->NumberOfStreams ||
             RestartState.CreationTime.QuadPart != lpRestartState->CreationTime.QuadPart ||
             RestartState.WriteTime.QuadPart != lpRestartState->WriteTime.QuadPart ||
             RestartState.Checksum != BasepChecksum((PUSHORT)&RestartState,FIELD_OFFSET(RESTART_STATE,Checksum) >> 1) ) {

            if ( CopyFlags & COPY_FILE_FAIL_IF_EXISTS ) {
                b = FALSE;  // Fatal error
                SetLastError( ERROR_ALREADY_EXISTS );
                leave;
            }

            // The caller should create/overwrite the dest file.
            b = TRUE;
            CloseHandle( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;
            leave;

        }

        //
        // A valid restart state has been found.  Copy
        // the appropriate values into the internal
        // restart state so the operation can continue
        // from there.
        //

        lpRestartState->CurrentStream = RestartState.CurrentStream;
        lpRestartState->LastKnownGoodOffset.QuadPart = RestartState.LastKnownGoodOffset.QuadPart;
        if ( !RestartState.CurrentStream ) {

            // We were in the middle of copying the unnamed data stream.

            if ( Context ) {
                Context->TotalBytesTransferred.QuadPart = RestartState.LastKnownGoodOffset.QuadPart;
            }

            // We'll leave the handle in *DestFile, and the caller and pick up the
            // copy of this stream.

            b = TRUE;

        } else {

            // We were in the middle of copying a named data stream.

            if ( Context ) {
                ULONG ReturnCode;

                Context->TotalBytesTransferred.QuadPart = lpFileSize->QuadPart;
                Context->dwStreamNumber = RestartState.CurrentStream;

                if ( Context->lpProgressRoutine ) {
                    ReturnCode = Context->lpProgressRoutine(
                                    Context->TotalFileSize,
                                    Context->TotalBytesTransferred,
                                    *lpFileSize,
                                    Context->TotalBytesTransferred,
                                    1,
                                    CALLBACK_STREAM_SWITCH,
                                    hSourceFile,
                                    *DestFile,
                                    Context->lpData
                                    );
                } else {
                    ReturnCode = PROGRESS_CONTINUE;
                }

                if ( ReturnCode == PROGRESS_CANCEL ||
                    (Context->lpCancel && *Context->lpCancel) ) {
                    BaseMarkFileForDelete(
                        *DestFile,
                        0
                        );
                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                    b = FALSE;
                    leave;
                }

                if ( ReturnCode == PROGRESS_STOP ) {
                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                    b = FALSE;
                    leave;
                }

                if ( ReturnCode == PROGRESS_QUIET ) {
                    Context = NULL;
                    *lpCopyFileContext = NULL;
                }
            }

            b = SUCCESS_RETURNED_STATE;

        }   // if ( !RestartState.CurrentStream ) ... else
    }
    finally {

        if( b == FALSE &&
            *DestFile != INVALID_HANDLE_VALUE ) {
            CloseHandle( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;
        }


    }

    return( b );

}





BOOL
WINAPI
BasepCopyCompression( HANDLE hSourceFile,
                      HANDLE DestFile,
                      DWORD SourceFileAttributes,
                      DWORD DestFileAttributes,
                      DWORD DestFileFsAttributes,
                      DWORD CopyFlags,
                      LPCOPYFILE_CONTEXT *lpCopyFileContext )
/*++

Routine Description:

    This is an internal routine that copies the compression state during
    a copyfile.  If the source is compressed, that same compression
    algorithm is copied to the dest.  If that fails, an attempt is made
    to set the default compression.  Depending on the copy flags, it
    may alternatively be necessary to decompress the destination.


Arguments:

    hSourceFile - Provides a handle to the source file.

    DestFile - Provides a handle to the destination file.

    SourceFileAttributes - FileBasicInformation attributes queried from the
        source file.

    DestFileAttributes - FileBasicInformation attributes for the current
        state of the destination file.

    DestFileFsAttributes - FileFsAttributeInformation.FileSystemAttributes
        for the file system of the dest file.

    CopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

    lpCopyFileContext - Provides a pointer to a pointer to the context
        information to track callbacks, file sizes, etc. across streams during
        the copy operation.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.  The DestFile has already been marked
        for delete.

--*/

{   // BasepCopyCompression

    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    BOOL SuccessReturn = FALSE;
    BOOL Canceled = FALSE;

    try
    {
        if( !(SourceFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ) {

            // The source file is not compressed.  If necessary, decompress
            // the target.

            if( (DestFileAttributes & FILE_ATTRIBUTE_COMPRESSED) &&
                (CopyFlags & PRIVCOPY_FILE_SUPERSEDE) ) {

                // The source isn't compressed, but the dest is, and we don't
                // want to acquire attributes from the dest.  So we need to manually
                // decompress it.

                ULONG CompressionType = COMPRESSION_FORMAT_NONE;

                Status = NtFsControlFile(
                             DestFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             FSCTL_SET_COMPRESSION,
                             &CompressionType,                    //  Input buffer
                             sizeof(CompressionType),             //  Input buffer length
                             NULL,                                //  Output buffer
                             0                                    //  Output buffer length
                             );
                if( !NT_SUCCESS(Status) ) {
                    // See if it's OK to ignore the error
                    if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                RtlNtStatusToDosError(Status),
                                                Context,
                                                NULL,
                                                PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED,
                                                hSourceFile,
                                                DestFile,
                                                &Canceled )) {


                        BaseMarkFileForDelete( DestFile, 0 );
                        BaseSetLastNTError( Status );
                        leave;
                    } else {
                        Status = STATUS_SUCCESS;
                    }
                }

            }

        }   // if( !(SourceFileAttributes & FILE_ATTRIBUTE_COMPRESSED) )

        else {

            // The source file is compressed.  Does the target filesystem
            // even support compression?

            if( !(FILE_FILE_COMPRESSION & DestFileFsAttributes) ) {

                // No, it won't be compressable.  See if it's OK to continue.

                if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                            ERROR_NOT_SUPPORTED,
                                            Context,
                                            NULL,
                                            PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED,
                                            hSourceFile,
                                            DestFile,
                                            &Canceled )) {

                    if( Canceled ) {
                        BaseMarkFileForDelete(
                            DestFile,
                            0 );
                    }
                    leave;
                }
            }   // if( !(FILE_FILE_COMPRESSION & *DestFileFsAttributes) )

            else {

                // Target volume supports compression.  Compress the target file if
                // it's not already.

                if( !(DestFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ) {

                    USHORT CompressionType;

                    // Get the source file's compression type

                    Status = NtFsControlFile(
                                 hSourceFile,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatus,
                                 FSCTL_GET_COMPRESSION,
                                 NULL,                                //  Input buffer
                                 0,                                   //  Input buffer length
                                 &CompressionType,                    //  Output buffer
                                 sizeof(CompressionType)              //  Output buffer length
                                 );
                    if( NT_SUCCESS(Status) ) {

                        // Set the compression type on the target

                        Status = NtFsControlFile(
                                     DestFile,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatus,
                                     FSCTL_SET_COMPRESSION,
                                     &CompressionType,                    //  Input buffer
                                     sizeof(CompressionType),             //  Input buffer length
                                     NULL,                                //  Output buffer
                                     0                                    //  Output buffer length
                                     );

                        // If that didn't work, try the default compression
                        // format (maybe we're copying from uplevel to downlevel).

                        if( !NT_SUCCESS(Status) &&
                            COMPRESSION_FORMAT_DEFAULT != CompressionType ) {

                            CompressionType = COMPRESSION_FORMAT_DEFAULT;
                            Status = NtFsControlFile(
                                         DestFile,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatus,
                                         FSCTL_SET_COMPRESSION,
                                         &CompressionType,                    //  Input buffer
                                         sizeof(CompressionType),             //  Input buffer length
                                         NULL,                                //  Output buffer
                                         0                                    //  Output buffer length
                                         );
                        }
                    }   // FSCTL_GET_COMPRESSION ... if( NT_SUCCESS(Status) )

                    // If something went wrong and we couldn't compress it, there's a good
                    // chance that the caller doesn't want this to be fatal.  Ask and find
                    // out.

                    if( !NT_SUCCESS(Status) ) {
                        BOOL Canceled = FALSE;

                        if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                    RtlNtStatusToDosError(Status),
                                                    Context,
                                                    NULL,
                                                    PRIVCALLBACK_COMPRESSION_FAILED,
                                                    hSourceFile,
                                                    DestFile,
                                                    &Canceled )) {
                            if( Canceled ) {
                                BaseMarkFileForDelete(
                                    DestFile,
                                    0 );
                            }
                            leave;
                        }
                    }
                }   // if( !(DestFileAttributes & FILE_FILE_COMPRESSION) )
            }   // if( !(FILE_FILE_COMPRESSION & *DestFileFsAttributes) )
        }   // if( !(SourceFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ) ... else

        SuccessReturn = TRUE;
    }
    finally
    {
    }

    return( SuccessReturn );
}



NTSTATUS
BasepCreateDispositionToWin32( DWORD CreateDisposition, DWORD *Win32CreateDisposition )

/*++
Routine Description:

    This is an internal routine used by BaseCopyStream.  It is used to translate
    from NT API CreateDisposition flags to Win32 CreateDisposition flags (this was 
    added in order to use the NT CreateDisposition in a call to DuplicateEncryptionInformation).

    This routine does the inverse of the Win32->NT mapping in CreateFile, except that there is
    no way to obtain TRUNCATE_EXISTING from an NT flag.  The FILE_SUPERSEDE and FILE_OVERWRITE
    flags are not supported by this routine.

Arguments:

    CreateDisposition - The NT CreateDisposition flags.

Returns:

    STATUS_INVALID_PARAMETER if an unsupported NT flag is passed in.
    STATUS_SUCCESS otherwise.

++*/


{
    switch ( CreateDisposition ) {

    case FILE_CREATE :
        *Win32CreateDisposition = CREATE_NEW;
        break;
    case FILE_OVERWRITE_IF:
        *Win32CreateDisposition = CREATE_ALWAYS;
        break;
    case FILE_OPEN:
        *Win32CreateDisposition = OPEN_EXISTING;
        break;
    case FILE_OPEN_IF:
        *Win32CreateDisposition = OPEN_ALWAYS;
        break;
    default :
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

}



BOOL
CheckAllowDecryptedRemoteDestinationPolicy()

/*++

Routine Description:

    This routine is used by BasepCopyEncryption (part of CopyFile), when
    an attempt has been made to copy an encrypted file to a destination that
    for some reason can't support encryption (e.g. it's FAT, not trusted for
    delegation, NT4, etc).  By default, copyfile fails for this scenario.  The
    way to override that default is to pass the COPY_FILE_ALLOW_DECRYPTED_DESTINATION
    flag to CopyFile.  The other way to override that default (if you can't update
    your copy utilities to use the new flag), is to set the
    CopyFileAllowDecryptedRemoteDestination system policy.  This routine checks that policy.

    This routine caches the result of the registry check per process.  So an update
    to the policy may require a reboot to take effect in existing processes.

Arguments:

    None

Return Value:

    TRUE  - The decrypted destination is allowed

    FALSE - The destination may not be left decrypted

--*/


{
    // Static flags indicating if we've already been called once, and if
    // so what the answer was.  These are static so that we need to do the registry
    // call only once per process.

    static BOOL Allowed = FALSE;
    static BOOL AlreadyChecked = FALSE;

    NTSTATUS Status;
    HANDLE Key;

    BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo =
        (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;

    ULONG ActualSize;

    const static UNICODE_STRING KeyName =
        RTL_CONSTANT_STRING( L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\System" );

    const static OBJECT_ATTRIBUTES ObjectAttributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyName, OBJ_CASE_INSENSITIVE);

    const static UNICODE_STRING ValueName =
        RTL_CONSTANT_STRING( L"CopyFileAllowDecryptedRemoteDestination" );


    // Check to see if we've already been called once in this process.  If so, 
    // return the value that was calculated then (thus this process needs a reboot
    // to reflect a change to this policy).  Technically there's a race condition here, 
    // but assuming the registry isn't being updated during the call, each call to this
    // routine will get the same answer anyway.

    if( AlreadyChecked )
        return Allowed;

    // We need to do the check.

    // Try to open the system policy key.
    // If it doesn't exist, then we'll just fall through and return false.

    Status = NtOpenKey( &Key,
                        KEY_QUERY_VALUE,
                        (POBJECT_ATTRIBUTES) &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        // We have the system policy key.  Now try to open the value.  If it
        // doesn't exist, we'll just fall through, and return false.

        Status = NtQueryValueKey(
                    Key,
                    (PUNICODE_STRING) &ValueName,
                    KeyValuePartialInformation,
                    KeyValueInfo,
                    sizeof(QueryBuffer),
                    &ActualSize);

        if (NT_SUCCESS(Status)) {

            // The value exists.  If it's the right shape and value, then 
            // we'll allow the decrypted destination.

            if( KeyValueInfo->Type == REG_DWORD &&
                KeyValueInfo->DataLength == sizeof(DWORD) &&
                *((PDWORD) KeyValueInfo->Data) == 1) {

                Allowed = TRUE;
            }
        }

        NtClose( Key );
    }

    // Update the static so that we don't execute this code again.
    AlreadyChecked = TRUE;

    return Allowed;
}


typedef BOOL (WINAPI *ENCRYPTFILEWPTR)(LPCWSTR);
typedef BOOL (WINAPI *DECRYPTFILEWPTR)(LPCWSTR, DWORD);

BOOL
WINAPI
BasepCopyEncryption( HANDLE hSourceFile,
                     LPCWSTR lpNewFileName,
                     PHANDLE DestFile,
                     POBJECT_ATTRIBUTES Obja,
                     DWORD DestFileAccess,
                     DWORD DestFileSharing,
                     DWORD CreateDisposition,
                     DWORD CreateOptions,
                     DWORD SourceFileAttributes,
                     DWORD SourceFileAttributesMask,
                     PDWORD DestFileAttributes,
                     DWORD DestFileFsAttributes,
                     DWORD CopyFlags,
                     LPCOPYFILE_CONTEXT *lpCopyFileContext )
/*++

Routine Description:

    This is an internal routine that copies the encryption state during
    a copyfile.  Depending on the copy flags, it may be necessary to
    decompress the destination.  To encrypt/decrypt a file it is necessary
    to close the current handle, encrypt/decrypt, and reopen.

Arguments:

    hSourceFile - Provides a handle to the source file.

    lpNewFileName - Provides a name for the target file/stream.

    Obja - ObjectAttributes structure for the destination file.

    DestFileAccess - ACCESS_MASK to use when opening the dest.

    DestFileSharing - Sharing options to use when openting the dest.

    CreateDisposition - Creation/disposition options for opening the dest.

    SourceFileAttributes - FileBasicInformation attributes queried from the
        source file.

    SourceFileAttributesMask - the attributes from the source that are intended
        to be set on the dest.

    DestFileAttributes - FileBasicInformation attributes for the current
        state of the destination file.  This value is updated to reflect
        changes to the encryption state of the dest file.

    DestFileFsAttributes - FileFsAttributeInformation.FileSystemAttributes
        for the file system of the dest file.

    CopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

    lpCopyFileContext - Provides a pointer to a pointer to the context
        information to track callbacks, file sizes, etc. across streams during
        the copy operation.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.  The DestFile has already been marked
        for delete.

--*/

{   // BasepCopyEncryption

    NTSTATUS Status = 0;
    BOOL SuccessReturn = FALSE;
    BOOL EncryptFile = FALSE;
    BOOL DecryptFile = FALSE;
    HANDLE Advapi32 = NULL;
    BOOL RestoreReadOnly = FALSE;
    ENCRYPTFILEWPTR EncryptFileWPtr = NULL;
    DECRYPTFILEWPTR DecryptFileWPtr = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    FILE_BASIC_INFORMATION FileBasicInformationData;

    try
    {
        // Check to see if we need to do some encryption or decryption,
        // and set EncryptFile/DescryptFile bools if set.

        if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            (SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED) &&
            !(*DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ) {

            // We tried to copy over encryption, but it didn't stick:
            // *  This may be a system file, encryption is not supported on
            //    system files.
            // *  If this is a non-directory file, then encryption is not
            //    supported on the target file system.
            // *  If this is a directory file, then we must try to encrypt
            //    it manually (since we opened it, rather than creating it).
            //    It still may not be possible but we'll have to try to
            //    find out.

            if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                &&
                !(*DestFileAttributes & FILE_ATTRIBUTE_SYSTEM) ) {
                EncryptFile = TRUE;
            }

        } else if( !(SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
                   (*DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
                   (CopyFlags & PRIVCOPY_FILE_SUPERSEDE) ) {

            // The source is decrypted, the destination was encrypted, and the
            // caller specified that the source should be copied as-is.  So
            // we must manually decrypt the destination.  This can happen if
            // the dest file already existed and was encrypted.

            DecryptFile = TRUE;
        }


        // If we decided above to either encrypt or decrypt, then we have
        // more work to do.

        if( DecryptFile || EncryptFile ) {

            // If the destination file is read-only, we have to take it off
            // until we do the encrypt/decrypt (and restore it later).

            if( *DestFileAttributes & FILE_ATTRIBUTE_READONLY ) {

                RestoreReadOnly = TRUE;
                RtlZeroMemory(&FileBasicInformationData, sizeof(FileBasicInformationData));                
                FileBasicInformationData.FileAttributes = (*DestFileAttributes) & ~FILE_ATTRIBUTE_READONLY;

                Status = NtSetInformationFile(
                          *DestFile,
                          &IoStatusBlock,
                          &FileBasicInformationData,
                          sizeof(FileBasicInformationData),
                          FileBasicInformation
                          );
                if( !NT_SUCCESS(Status) ) {
                    BaseMarkFileForDelete( *DestFile, 0 );
                    BaseSetLastNTError(Status);
                    leave;
                }
            }

            // Close the file so that we can call EncryptFile/DecryptFile

            NtClose( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;

            // Load the EncryptFile/DecryptFile API, and make the call

            Advapi32 = LoadLibraryW(AdvapiDllString);
            if( Advapi32 == NULL ) {
                leave;
            }

            if( EncryptFile ) {
                EncryptFileWPtr = (ENCRYPTFILEWPTR)GetProcAddress(Advapi32, "EncryptFileW");
                if( EncryptFileWPtr == NULL ) {
                    leave;
                }

                if( EncryptFileWPtr(lpNewFileName) )
                    *DestFileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            } else {
                DecryptFileWPtr = (DECRYPTFILEWPTR)GetProcAddress(Advapi32, "DecryptFileW");
                if( DecryptFileWPtr == NULL ) {
                    leave;
                }

                if( DecryptFileWPtr(lpNewFileName, 0) )
                    *DestFileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
            }

            // The encrypt/decrypt call was successful, so we can reopen the file.

            Status = NtCreateFile(
                        DestFile,
                        DestFileAccess,
                        Obja,
                        &IoStatusBlock,
                        NULL,
                        SourceFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS & SourceFileAttributesMask,
                        DestFileSharing,
                        CreateDisposition,
                        CreateOptions,
                        NULL,
                        0
                        );
            if( !NT_SUCCESS(Status) ) {
                *DestFile = INVALID_HANDLE_VALUE;
                BaseSetLastNTError(Status);
                leave;
            }

            // If we took off the read-only bit above, put it back on now.

            if( RestoreReadOnly ) {

                FileBasicInformationData.FileAttributes |= FILE_ATTRIBUTE_READONLY;

                Status = NtSetInformationFile(
                          *DestFile,
                          &IoStatusBlock,
                          &FileBasicInformationData,
                          sizeof(FileBasicInformationData),
                          FileBasicInformation
                          );

                if( !NT_SUCCESS(Status) ) {
                    BaseMarkFileForDelete( *DestFile, 0 );
                    BaseSetLastNTError(Status);
                    leave;
                }
            }
        }   // if( DecryptFile || EncryptFile )

        // If it's still not encrypted, see if it's OK to leave it that way.

        if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
            && !(*DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ) {

            // Either there was an encryption problem (e.g. no keys available)
            // or the target just doesn't support encryption.  See if it's OK
            // to continue with the copy by checking the CopyFlags, by making
            // a callback, or by checking policy.

            BOOL Canceled = FALSE;
            DWORD dwCallbackReason = 0;
            LONG lError = ERROR_ENCRYPTION_FAILED;

            // If the COPY_FILE_ALLOW_DECRYPTED_DESTINATION flag is set, then
            // we can fall through and return success.  Otherwise, we need to do some
            // more checking.

            if( !(CopyFlags & COPY_FILE_ALLOW_DECRYPTED_DESTINATION) ) {

                // There's a policy in the registry which may be set indicating
                // that we can ignore loss of encryption on network targets.
                // If that's set, and this is a remote destination, then the
                // copy can continue.  We check the policy first, because it
                // caches its result.  Consequently, in the typical case, we only
                // check the registry once, and we never make the NtQueryVolInfoFile
                // call.

                if( CheckAllowDecryptedRemoteDestinationPolicy() ) {

                    IO_STATUS_BLOCK IoStatus;
                    FILE_FS_DEVICE_INFORMATION DeviceInformation;

                    // See if the destination is remote

                    DeviceInformation.Characteristics = 0;
                    Status = NtQueryVolumeInformationFile(
                                *DestFile,
                                &IoStatus,
                                &DeviceInformation,
                                sizeof(DeviceInformation),
                                FileFsDeviceInformation
                                );
                    if( NT_SUCCESS(Status) &&
                        (DeviceInformation.Characteristics & FILE_REMOTE_DEVICE) )
                    {
                        // Yes, it's remote, and the policy is set, so 
                        // it's OK to continue.

                        SuccessReturn = TRUE;
                    }
                } // if( CheckAllowDecryptedRemoteDestinationPolicy() )

                // If that didn't work, do we have a callback on which we can
                // check for permission to drop?  We checked the policy first, 
                // because if it allows the copy, we needn't even call the
                // callback.

                if( !SuccessReturn
                    && Context != NULL 
                    && Context->lpProgressRoutine != NULL
                    && (CopyFlags & PRIVCOPY_FILE_METADATA) ) {

                    // Yes, we have an applicable callback.

                    // Figure out what the explanation (dwCallbackReason)
                    // is for the problem.

                    if( DestFileFsAttributes & FILE_SUPPORTS_ENCRYPTION ) {

                        if( !(SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED) ) {
                            // We opened the file with encryption turned off, so we must
                            // have gotten an access-denied on the first try.

                            dwCallbackReason = PRIVCALLBACK_ENCRYPTION_FAILED;
                        }

                        else if( *DestFileAttributes & FILE_ATTRIBUTE_SYSTEM )
                            dwCallbackReason = PRIVCALLBACK_CANT_ENCRYPT_SYSTEM_FILE;
                        else
                            dwCallbackReason = PRIVCALLBACK_ENCRYPTION_FAILED;
                    }
                    else
                        dwCallbackReason = PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED;

                    // Make the callback.

                    if( BasepCopyFileCallback( FALSE, // Fail by default
                                               lError,
                                               Context,
                                               NULL,
                                               dwCallbackReason,
                                               hSourceFile,
                                               *DestFile,
                                               &Canceled )) {
                        // We've been given permission to drop the encryption
                        SuccessReturn = TRUE;
                    }
                }   // if( Context != NULL 


                // We checked everything, and nothing allows us to contine,
                // so fail the call.

                if( !SuccessReturn ) {
	            BaseMarkFileForDelete(
		            *DestFile,
		            0 );
	            SetLastError( lError );
	            leave;
                }

            }   // if( !(CopyFlags & COPY_FILE_ALLOW_DECRYPTED_DESTINATION) )
        }   // if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)

        SuccessReturn = TRUE;

    }
    finally
    {
        if (Advapi32 != NULL) {
            FreeLibrary( Advapi32 );
        }
    }

    return( SuccessReturn );
}

DWORD
WINAPI
BaseCopyStream(
    OPTIONAL LPCWSTR lpExistingFileName,
    HANDLE hSourceFile,
    ACCESS_MASK SourceFileAccess OPTIONAL,
    LPCWSTR lpNewFileName,
    HANDLE hTargetFile OPTIONAL,
    LARGE_INTEGER *lpFileSize,
    LPDWORD lpCopyFlags,
    LPHANDLE lpDestFile,
    LPDWORD lpCopySize,
    LPCOPYFILE_CONTEXT *lpCopyFileContext,
    LPRESTART_STATE lpRestartState OPTIONAL,
    BOOL OpenFileAsReparsePoint,
    DWORD dwReparseTag,
    PDWORD DestFileFsAttributes
    )

/*++

Routine Description:

    This is an internal routine that copies an entire file (default data stream
    only), or a single stream of a file.  If the hTargetFile parameter is
    present, then only a single stream of the output file is copied.  Otherwise,
    the entire file is copied.

Arguments:

    hSourceFile - Provides a handle to the source file.

    SourceFileAccess - The ACCESS_MASK bits used to open the source file handle.
        This variable is only used with the PRIVCOPY_FILE_* flags.

    lpNewFileName - Provides a name for the target file/stream.

    hTargetFile - Optionally provides a handle to the target file.  If the
        stream being copied is an alternate data stream, then this handle must
        be provided.

    lpFileSize - Provides the size of the input stream.

    lpCopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

    lpDestFile - Provides a variable to store the handle to the target file.

    lpCopySize - Provides variable to store size of copy chunks to be used in
        copying the streams.  This is set for the file, and then reused on
        alternate streams.

    lpCopyFileContext - Provides a pointer to a pointer to the context
        information to track callbacks, file sizes, etc. across streams during
        the copy operation.

    lpRestartState - Optionally provides storage to maintain restart state
        during the copy operation.  This pointer is only valid if the caller
        has specified the COPY_FILE_RESTARTABLE flag in the lpCopyFlags word.

    OpenFileAsReparsePoint - Flag to indicate whether the target file is to
        be opened as a reparse point or not.

    DestFileFsAttributes - If hTargetFile is present, provides a location to
        store the destination file's filesystem attributes.  If hTargetFile
        is not present, provides those attributes to this routine.

Return Value:

    TRUE - The operation was successful.

    SUCCESS_RETURNED_STATE - The operation was successful, but extended
        information was returned in the restart state structure.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{   // BaseCopyStream

    HANDLE DestFile = INVALID_HANDLE_VALUE;
    HANDLE Section;
    NTSTATUS Status;
    PVOID SourceBase, IoDestBase;
    PCHAR SourceBuffer;
    LARGE_INTEGER SectionOffset;
    LARGE_INTEGER BytesWritten;
    SIZE_T BigViewSize;
    ULONG ViewSize;
    ULONG BytesToWrite;
    ULONG BytesRead;
    FILE_BASIC_INFORMATION FileBasicInformationData;
    FILE_END_OF_FILE_INFORMATION EndOfFileInformation;
    IO_STATUS_BLOCK IoStatus;
    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    DWORD ReturnCode;
    DWORD b;
    BOOL Restartable;
    DWORD ReturnValue = FALSE;
    DWORD WriteCount = 0;
    DWORD FlagsAndAttributes;
    DWORD DesiredAccess;
    DWORD DestFileAccess;
    DWORD DestFileSharing;
    DWORD DesiredCreateDisposition;
    DWORD CreateDisposition;
    BOOL Canceled = FALSE;
    DWORD SourceFileAttributes;
    DWORD SourceFileAttributesMask;
    DWORD BlockSize;
    BOOL fSkipBlock;
    UNICODE_STRING DestFileName;
    PVOID DestFileNameBuffer = NULL;
    RTL_RELATIVE_NAME DestRelativeName;
    OBJECT_ATTRIBUTES Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    FILE_EA_INFORMATION EaInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG EaSize = 0;
    BOOL EasDropped = FALSE;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR SaveStaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];


    // Default the size of copy chunks
    *lpCopySize = BASE_COPY_FILE_CHUNK;

    // The lpExistingFileName sits in the TEB buffer, which has a tendency
    // to get trashed (e.g. LoadLibaryW).  So use a local buffer.

    if( lpExistingFileName == NtCurrentTeb()->StaticUnicodeBuffer ) {

        memcpy( SaveStaticUnicodeBuffer,
                NtCurrentTeb()->StaticUnicodeBuffer,
                STATIC_UNICODE_BUFFER_LENGTH );
        lpExistingFileName = SaveStaticUnicodeBuffer;
    }

    //
    //  Get times and attributes for the file if the entire file is being
    //  copied
    //

    Status = NtQueryInformationFile(
                hSourceFile,
                &IoStatus,
                (PVOID) &FileBasicInformationData,
                sizeof(FileBasicInformationData),
                FileBasicInformation
                );

    SourceFileAttributes = NT_SUCCESS(Status) ?
                             FileBasicInformationData.FileAttributes :
                             0;

    if ( !ARGUMENT_PRESENT(hTargetFile) ) {

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    } else {

        //
        //  A zero in the file's attributes informs latter DeleteFile that
        //  this code does not know what the actual file attributes are so
        //  that this code does not actually have to retrieve them for each
        //  stream, nor does it have to remember them across streams.  The
        //  error path will simply get them if needed.
        //

        FileBasicInformationData.FileAttributes = 0;
    }

    //
    // We don't allow restartable copies of directory files, because the
    // unnamed data stream is used to store restart context, and directory files
    // don't have an unnamed data stream.
    //

    Restartable = (*lpCopyFlags & COPY_FILE_RESTARTABLE) != 0;
    if( Restartable && SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
        Restartable = FALSE;
        *lpCopyFlags &= ~COPY_FILE_RESTARTABLE;
    }


    try {

        //
        // Create the destination file or alternate data stream
        //

        SourceBase = NULL;
        IoDestBase = NULL;
        Section = NULL;

        if ( !ARGUMENT_PRESENT(hTargetFile) ) {

            ULONG CreateOptions = 0, DesiredCreateOptions = 0;
            BOOL TranslationStatus = FALSE;
            PFILE_FULL_EA_INFORMATION EaBufferToUse = NULL;
            DWORD SourceFileFsAttributes = 0;
            ULONG EaSizeToUse = 0;

            // We're being called to copy the unnamed stream of the file, and
            // we need to create the file itself.

            DWORD DestFileAttributes = 0;
            struct {
                FILE_FS_ATTRIBUTE_INFORMATION Info;
                WCHAR Buffer[ MAX_PATH ];
            } FileFsAttrInfoBuffer;

            //
            // Begin by determining how the target file is to be opened based
            // on whether or not the copy operation is to be restartable.
            //

            if ( Restartable ) {

                b = BasepOpenRestartableFile( hSourceFile,
                                              lpNewFileName,
                                              &DestFile,
                                              *lpCopyFlags,
                                              lpRestartState,
                                              lpFileSize,
                                              lpCopyFileContext,
                                              FileBasicInformationData.FileAttributes,
                                              OpenFileAsReparsePoint );

                if( b == SUCCESS_RETURNED_STATE ) {
                    // We've picked up in the middle of a restartable copy.
                    // The destination file handle is in DestFile, which will
                    // be given back to our caller below in the finally.

                    if ( BasepRemoteFile(hSourceFile,DestFile) ) {
                        *lpCopySize = BASE_COPY_FILE_CHUNK - 4096;
                    }
                    ReturnValue = b;
                    leave;
                } else if( b == FALSE ) {
                    // There was a fatal error.
                    leave;
                }

                // Otherwise we should copy the first stream.  If we are to restart copying
                // in that stream, DestFile will be valid.

            }

            //
            // If the dest file is not already opened (the restart case), open it now.
            //

            if( DestFile == INVALID_HANDLE_VALUE ) {

                BOOL EndsInSlash = FALSE;
                UNICODE_STRING Win32NewFileName;
                PUNICODE_STRING lpConsoleName = NULL;
                FILE_BASIC_INFORMATION DestBasicInformation;

                //
                // Determine the create options
                //

                CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                    CreateOptions |= FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT;
                else
                    CreateOptions |= FILE_NON_DIRECTORY_FILE  | FILE_SEQUENTIAL_ONLY;

                if( *lpCopyFlags & (PRIVCOPY_FILE_BACKUP_SEMANTICS|PRIVCOPY_FILE_OWNER_GROUP) )
                    CreateOptions |= FILE_OPEN_FOR_BACKUP_INTENT;


                //
                // Determine the create disposition
                //
                // Directory files are copied with merge semantics.  The rationale
                // is that copying of a directory tree has merge semantics wrt the
                // contained files, so copying of a directory file should also have
                // merge semantics.
                //

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                    CreateDisposition = (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OPEN_IF;
                else
                    CreateDisposition = (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OVERWRITE_IF;


                //
                // Determine what access is necessary based on what is being copied
                //

                DesiredAccess = SYNCHRONIZE | FILE_READ_ATTRIBUTES | GENERIC_WRITE | DELETE;

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                    // We may or may not be able to get FILE_WRITE_DATA access, necessary for
                    // setting compression.
                    DesiredAccess &= ~GENERIC_WRITE;
                    DesiredAccess |= FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_LIST_DIRECTORY;
                }


                if( *lpCopyFlags & PRIVCOPY_FILE_METADATA ) {
                    // We need read access for compression, write_dac for the DACL
                    DesiredAccess |= GENERIC_READ | WRITE_DAC;
                }

                if( *lpCopyFlags & PRIVCOPY_FILE_OWNER_GROUP ) {
                    DesiredAccess |= WRITE_OWNER;
                }

                if( (*lpCopyFlags & PRIVCOPY_FILE_SACL)
                    &&
                    (SourceFileAccess & ACCESS_SYSTEM_SECURITY) ) {
                    // Don't bother trying to get access_system_security unless it was
                    // successfully obtained on the source (requires SeSecurityPrivilege)
                    DesiredAccess |= ACCESS_SYSTEM_SECURITY;
                }

                SourceFileAttributesMask = ~0;

                if ( OpenFileAsReparsePoint ) {
                    //
                    // The target has to be opened as reparse point. If the open
                    // below fails, the source is to be closed and re-opened
                    // without inhibiting the reparse point behavior.
                    //

                    CreateOptions |= FILE_OPEN_REPARSE_POINT;
                    DesiredAccess = (DesiredAccess & ~DELETE) | GENERIC_READ;
                    CreateDisposition = (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OPEN_IF;
                }

                DesiredCreateOptions = CreateOptions;
                DesiredCreateDisposition = CreateDisposition;
		
                //
                // Get the Win32 path in a unicode_string, and get the NT path
                //

                RtlInitUnicodeString( &Win32NewFileName, lpNewFileName );

                if ( lpNewFileName[(Win32NewFileName.Length >> 1)-1] == (WCHAR)'\\' ) {
                    EndsInSlash = TRUE;
                }
                else {
                    EndsInSlash = FALSE;
                }

                TranslationStatus = RtlDosPathNameToNtPathName_U(
                                        lpNewFileName,
                                        &DestFileName,
                                        NULL,
                                        &DestRelativeName
                                        );

                if ( !TranslationStatus ) {
                    SetLastError(ERROR_PATH_NOT_FOUND);
                    DestFile = INVALID_HANDLE_VALUE;
                    leave;
                    }
                DestFileNameBuffer = DestFileName.Buffer;

                if ( DestRelativeName.RelativeName.Length ) {
                    DestFileName = *(PUNICODE_STRING)&DestRelativeName.RelativeName;
                }
                else {
                    DestRelativeName.ContainingDirectory = NULL;
                }

                InitializeObjectAttributes(
                    &Obja,
                    &DestFileName,
                    OBJ_CASE_INSENSITIVE,
                    DestRelativeName.ContainingDirectory,
                    NULL
                    );

                SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
                SecurityQualityOfService.EffectiveOnly = TRUE;
                SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );

                Obja.SecurityQualityOfService = &SecurityQualityOfService;

                //
                //  Get the EAs
                //

                EaBuffer = NULL;
                EaSize = 0;

                Status = NtQueryInformationFile(
                            hSourceFile,
                            &IoStatusBlock,
                            &EaInfo,
                            sizeof(EaInfo),
                            FileEaInformation
                            );
                if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {

                    EaSize = EaInfo.EaSize;

                    do {

                        EaSize *= 2;
                        EaBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
                        if ( !EaBuffer ) {
                            BaseSetLastNTError(STATUS_NO_MEMORY);
                            leave;
                        }

                        Status = NtQueryEaFile(
                                    hSourceFile,
                                    &IoStatusBlock,
                                    EaBuffer,
                                    EaSize,
                                    FALSE,
                                    (PVOID)NULL,
                                    0,
                                    (PULONG)NULL,
                                    TRUE
                                    );

                        if ( !NT_SUCCESS(Status) ) {
                            RtlFreeHeap(RtlProcessHeap(), 0,EaBuffer);
                            EaBuffer = NULL;
                            IoStatusBlock.Information = 0;
                        }

                    } while ( Status == STATUS_BUFFER_OVERFLOW ||
                              Status == STATUS_BUFFER_TOO_SMALL );


                    EaSize = (ULONG)IoStatusBlock.Information;

                }   // if ( NT_SUCCESS(Status) && EaInfo.EaSize )


                //
                // Open the destination file.  If the destination is a console name,
                // open as such, otherwise loop until we find a way to open it with
                // NtCreateFile.
                //

                DestFileAccess = DesiredAccess;
                DestFileSharing = 0;
                EaBufferToUse = EaBuffer;
                EaSizeToUse = EaSize;

                if( (lpConsoleName = BaseIsThisAConsoleName( &Win32NewFileName, GENERIC_WRITE )) ) {

                    DestFileAccess = DesiredAccess = GENERIC_WRITE;
                    DestFileSharing = FILE_SHARE_READ | FILE_SHARE_WRITE;

                    if( EaBuffer != NULL )
                        EasDropped = TRUE;  // We're not copying the EAs

                    DestFile= OpenConsoleW( lpConsoleName->Buffer,
                                            DestFileAccess,
                                            FALSE,  // Not inheritable
                                            DestFileSharing
                                           );

                    if ( DestFile == INVALID_HANDLE_VALUE ) {
                        BaseSetLastNTError(STATUS_ACCESS_DENIED);
                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;
                    }

                }

                //
                // Even if the source is offline, the destination should
                // not be (at least not as part of the copy).
                //
                SourceFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;


                //
                //  If the source file was encrypted and if we are intending
                //  to create/overwrite/supersede the destination, attempt
                //  to establish the encryption state first by calling 
                //  DuplicateEncryptionInfoFile.  This API not only makes
                //  the target file encrypted, it also copies over the source's
                //  $efs stream (i.e. everyone who had access to the source file
                //  will have access to the dest file).
                //
                //

                if (!(SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    && (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                    && (SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED)
                    && (CreateDisposition == FILE_CREATE
                        || CreateDisposition == FILE_OVERWRITE_IF)) {

                    // We'll attempt the DuplicateEncryptionInfoCall.

                    DWORD Win32CreateDisposition;
                    DWORD LastError;

                    // Convert the NT create-disposition flags into a Win32 version.

                    Status = BasepCreateDispositionToWin32( CreateDisposition,
                                                            &Win32CreateDisposition );
                    if( !NT_SUCCESS(Status) ) {
                        BaseSetLastNTError( Status );

                    } else {

                        // Mask out the read-only bit for now, so that we can
                        // do an NtCreateFile after this DuplicateEncryptionInfoFile
                        
                        SourceFileAttributesMask &= ~FILE_ATTRIBUTE_READONLY;
                        
                        // DuplicateEncryptionInfoFile returns the error code.
                        // The "pfn" version of this API is a lazy-loader, so we
                        // don't have to implicitely link against advapi32.

                        LastError = pfnDuplicateEncryptionInfoFile(
                                                      lpExistingFileName, 
                                                      lpNewFileName, 
                                                      Win32CreateDisposition, 
                                                      SourceFileAttributes
                                                        & FILE_ATTRIBUTE_VALID_FLAGS
                                                        & SourceFileAttributesMask,
                                                      NULL );
                        if( LastError != 0 ) {
                            
                            // 
                            // We'll fall through and try using NtCreateFile.  That,
                            // at least, will try to encrypt the target via the
                            // FILE_ATTRIBUTE_ENCRYPTED bit.  Not as good as
                            // DupEncInfo, but better than leaving plain text.
                            //
                            SetLastError( LastError );
                        } else {
                        
                            //
                            //  Destination was created.  Now make it open
                            //
                        
                            CreateDisposition = FILE_OPEN;
                        }
                    }
                }   // if (!(SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                
                
                //
                // Open the destination file. This can take some effort & retries,
                // because there are so many scenarios for the target file
                // (e.g. different destination servers have different capabilities).
                //

                while( DestFile == NULL || DestFile == INVALID_HANDLE_VALUE ) {

                    // Attempt to create the destination

                    Status = NtCreateFile(
                                &DestFile,
                                DestFileAccess,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                SourceFileAttributes
                                    & FILE_ATTRIBUTE_VALID_FLAGS
                                    & SourceFileAttributesMask,
                                DestFileSharing,
                                CreateDisposition,
                                CreateOptions,
                                EaBufferToUse,
                                EaSizeToUse
                                );

                    if( !NT_SUCCESS(Status) ) {

                        // Set the last error and fall through.  We will attempt below to
                        // resolve the problem and try again.

                        BaseSetLastNTError( Status );


                    } else {

                        //
                        // We successfully created the file.  For some special cases,
                        // we must post-process this create before continuing with the copy.
                        //

                        if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                                 CreateDisposition == FILE_OPEN &&
                                 (DestFileAccess & FILE_WRITE_DATA) == FILE_WRITE_DATA &&
                                 (CreateOptions & FILE_DIRECTORY_FILE) == FILE_DIRECTORY_FILE ) {

                            //
                            // If we're copying to NT4, a previous iteration through this
                            // large while loop switched the CreateDisposition from
                            // FILE_OPENIF to FILE_OPEN; otherwise, NT4 fails the open
                            // (when passing FILE_OPENIF and FILE_WRITE_DATA to a directory
                            // file that already exists).  The open worked, but the problem
                            // is that now if we need to set compression on the target, we'll
                            // get status_invalid_parameter because the FILE_DIRECTORY_FILE
                            // CreateOption was set.  So, to allow compression to work, and
                            // since at this point we already know the target is a directory
                            // file, we can re-open it without that create option.
                            //

                            CreateOptions &= ~FILE_DIRECTORY_FILE;

                            NtClose( DestFile );
                            Status = NtCreateFile(
                                        &DestFile,
                                        DestFileAccess,
                                        &Obja,
                                        &IoStatusBlock,
                                        NULL,
                                        SourceFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS & SourceFileAttributesMask,
                                        DestFileSharing,
                                        CreateDisposition,
                                        CreateOptions,
                                        EaBufferToUse,
                                        EaSizeToUse
                                        );
                            if( !NT_SUCCESS(Status) ) {

                                // But if that didn't work, go back to the combination that
                                // did (this happens on Samba servers).

                                CreateOptions |= FILE_DIRECTORY_FILE;
                                Status = NtCreateFile(
                                            &DestFile,
                                            DestFileAccess,
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            SourceFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS & SourceFileAttributesMask,
                                            DestFileSharing,
                                            CreateDisposition,
                                            CreateOptions,
                                            EaBufferToUse,
                                            EaSizeToUse
                                            );

                                if( !NT_SUCCESS(Status) ) {
                                    DestFile = INVALID_HANDLE_VALUE;
                                    BaseSetLastNTError( Status );
                                    leave;
                                }
                            }
                        }
                        else if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                                 CreateDisposition == FILE_OPEN_IF &&
                                 lpConsoleName == NULL ) {
                        
                            //
                            // Compatibility hack:  We successfully created the target, but 
                            // some servers (SCO VisionFS) get confused by the FILE_OPEN_IF
                            // flag and create a non-directory file instead.  Check to see if
                            // this hapenned, and if so deleted it and re-create with FILE_CREATE
                            // instead.  This is a perf hit that we have to query the file attributes,
                            // but at least it is not a net round-trip because the rdr caches the
                            // file attributes in Create&X.
                            //


                            FILE_BASIC_INFORMATION NewDestInfo;

                            Status = NtQueryInformationFile( DestFile,
                                                             &IoStatus,
                                                             &NewDestInfo,
                                                             sizeof(NewDestInfo),
                                                             FileBasicInformation );
                            if( !NT_SUCCESS(Status) ) {
                                BaseMarkFileForDelete( DestFile, 0 );
                                BaseSetLastNTError(Status);
                                leave;
                            }

                            if( !(NewDestInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

                                // Yes, a non-directory file got created.  Delete it, then
                                // try again without FILE_OPEN_IF.

                                BaseMarkFileForDelete( DestFile,
                                                       NewDestInfo.FileAttributes );
                                NtClose( DestFile );
                                DestFile = INVALID_HANDLE_VALUE;

                                CreateDisposition = FILE_CREATE;

                                // Also, if we request FILE_WRITE_DATA access, the 
                                // directory gets created but the NtCreateFile call
                                // returns status_object_name_collision.  Since this
                                // is a very VisionFS-specific workaround, we'll just
                                // turn off that bit

                                DestFileAccess &= ~FILE_WRITE_DATA;

                                continue;
                            }
                        }

                        if( (FileBasicInformationData.FileAttributes & FILE_ATTRIBUTE_READONLY)
                            &&
                            !(SourceFileAttributesMask & FILE_ATTRIBUTE_READONLY) ) {

                            // The read-only bit was turned off, and must now be
                            // reset (it gets turned off when we call DuplicateEncryptionInfo,
                            // since that API does not return a handle).

                            Status = NtSetInformationFile(
                                      DestFile,
                                      &IoStatus,
                                      &FileBasicInformationData,
                                      sizeof(FileBasicInformationData),
                                      FileBasicInformation
                                      );
                            if( !NT_SUCCESS(Status) ) {
                                BaseMarkFileForDelete( DestFile, 0 );
                                BaseSetLastNTError(Status);
                                leave;
                            }
                        }

                        break;  // while( TRUE )

                    }   // NtCreateFile ... if( !NT_SUCCESS(Status) ) ... else

                    // If we reach this point, some error has occurred in the attempt to 
                    // create the file.


                    //
                    // If a file/directory already exists and we can't overwrite it,
                    // abort now.
                    //

                    if ( (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
                         (STATUS_OBJECT_NAME_COLLISION == Status) ) {

                        // Not allowed to overwrite an existing file.
                        SetLastError( ERROR_FILE_EXISTS );
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;

                    } else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {

                        // Not allowed to overwrite a directory with a file.
                        if ( EndsInSlash ) {
                            SetLastError(ERROR_PATH_NOT_FOUND);
                        }
                        else {
                            SetLastError(ERROR_ACCESS_DENIED);
                        }
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;
                    }

                    //
                    // If we're trying to create a directory, and a non-directory
                    // file already exists by that name, we need to manually delete
                    // it (FILE_OVERWRITE isn't valid for a directory file).
                    //

                    if( (*lpCopyFlags & PRIVCOPY_FILE_DIRECTORY) &&
                        Status == STATUS_NOT_A_DIRECTORY &&
                        !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ) {

                        Status = NtCreateFile(
                                    &DestFile,
                                    DELETE|SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    FILE_ATTRIBUTE_NORMAL,
                                    0,
                                    FILE_OPEN,
                                    FILE_DELETE_ON_CLOSE | FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0
                                    );
                        if( !NT_SUCCESS(Status) ) {
                            BaseSetLastNTError(Status);
                            DestFile = INVALID_HANDLE_VALUE;
                            leave;
                        }

                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;

                        continue;
                    }


                    //
                    // Some sharing and access errors can be handled
                    // by reducing the access we request on the target
                    // file.
                    //

                    if( GetLastError() == ERROR_SHARING_VIOLATION ||
                        GetLastError() == ERROR_ACCESS_DENIED ) {

                        //
                        // If the create failed because of a sharing violation or because access
                        // was denied, attempt to open the file and allow other readers and
                        // writers.
                        //

                        if( (DestFileSharing & (FILE_SHARE_READ|FILE_SHARE_WRITE))
                            != (FILE_SHARE_READ|FILE_SHARE_WRITE) ) {

                            DestFileSharing = FILE_SHARE_READ | FILE_SHARE_WRITE;
                            continue;
                        }

                        //
                        // If this failed as well, then attempt to open w/o specifying
                        // delete access.  It is probably not necessary to have delete
                        // access to the file anyway, since it will not be able to clean
                        // it up because it's probably open.  However, this is not
                        // necessarily the case.
                        //

                        else if ( (DestFileAccess & DELETE) ) {

                            DestFileAccess &= ~DELETE;
                            continue;
                        }

                    }



                    //
                    // If the destination has not been successfully created/opened, see
                    // if it's because EAs aren't supported
                    //

                    if( EaBufferToUse != NULL
                        &&
                        GetLastError() == ERROR_EAS_NOT_SUPPORTED ) {

                        // Attempt the create again, but don't use the EAs

                        EasDropped = TRUE;
                        EaBufferToUse = NULL;
                        EaSizeToUse = 0;
                        DestFileAccess = DesiredAccess;
                        DestFileSharing = 0;
                        continue;

                    }   // if( EaBufferToUse != NULL ...

                    // If we still have an access-denied problem, try dropping
                    // the WRITE_DAC or WRITE_OWNER access

                    if(( GetLastError() == ERROR_ACCESS_DENIED  ) 
                       && (DestFileAccess & (WRITE_DAC | WRITE_OWNER)) ) {

                        // If WRITE_DAC is set, try turning it off.

                        if( DestFileAccess & WRITE_DAC ) {
                            DestFileAccess &= ~WRITE_DAC;
                        }

                        // Or, if WRITE_OWNER is set, try turning it off.  We'll
                        // turn WRITE_DAC back on if it was previously turned off.  Then,
                        // if this still doesn't work, then the next iteration will turn
                        // WRITE_DAC back off, thus covering both scenarios.

                        else if( DestFileAccess & WRITE_OWNER ) {
                            DestFileAccess &= ~WRITE_OWNER;
                            DestFileAccess |= (DesiredAccess & WRITE_DAC);
                        }

                        DestFileSharing = 0;
                        continue;
                    } 


                    //
                    // 
                    // We might be having a problem copying encryption.  E.g.
                    // we might get an access-denied because the remote target machine
                    // isn't trusted for delegation.
                    // We'll try copying without encryption.  If that works, then later, in
                    // BasepCopyEncryption, we'll see if it's OK that we lost
                    // encryption.
                    //

                    if ( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) 
                         && (SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED) )
                    {

                        // Try taking the encryption bit out of the
                        // attributes we pass to NtCreateFile.

                        SourceFileAttributesMask &= ~FILE_ATTRIBUTE_ENCRYPTED;
                        CreateOptions = DesiredCreateOptions;
                        DestFileAccess = DesiredAccess;
                        DestFileSharing = 0;

                        continue;
                    }


                    //
                    // NT4 returns invalid-parameter error on an attempt to open 
                    // a directory file with both FILE_WRITE_DATA and FILE_OPEN_IF.
                    // Samba 2.x returns ERROR_ALREADY_EXISTS, even though
                    // the semantics of FILE_OPEN_IF says that it should open the
                    // existing directory.
                    // For both cases, we'll try it with FILE_OPEN.
                    //

                    if( ( GetLastError() == ERROR_INVALID_PARAMETER  ||
                          GetLastError() == ERROR_ALREADY_EXISTS ) &&
                        (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        CreateDisposition == FILE_OPEN_IF )  {
                        
                        CreateDisposition = FILE_OPEN;

                        SourceFileAttributesMask = ~0;
                        CreateOptions = DesiredCreateOptions;
                        DestFileAccess = DesiredAccess;
                        DestFileSharing = 0;
                        continue;
                    }

                    //
                    // Some downlevel servers don't allow a directory to be opened for write_data
                    // access.  We need write_data in order to set compression, but the
                    // downlevel server likely won't support that anyway.  (This happens on
                    // NTFS4 if the target directory file doesn't already exist.  In this
                    // case the compression will get copied over anyway as part of the create.)
                    //

                    if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (DestFileAccess & FILE_WRITE_DATA) ) {

                        DestFileAccess = DesiredAccess & ~FILE_WRITE_DATA;

                        CreateDisposition = DesiredCreateDisposition;
                        CreateOptions = DesiredCreateOptions;
                        DestFileSharing = 0;
                        continue;
                    }

                    // If we reach this point, we've run out of options and must give up.
                    DestFile = INVALID_HANDLE_VALUE;
                    leave;

                }   // while( DestFile == INVALID_HANDLE_VALUE )
                // If we reach this point, we've successfully opened the dest file.

                //
                // If we lost the EAs, check to see if that's OK before carrying on.
                //

                if( EasDropped && (*lpCopyFlags & PRIVCOPY_FILE_METADATA) ) {

                    // Check to see if it's OK that we skip the EAs.

                    if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                ERROR_EAS_NOT_SUPPORTED,
                                                Context,
                                                NULL,
                                                PRIVCALLBACK_EAS_NOT_SUPPORTED,
                                                hSourceFile,
                                                INVALID_HANDLE_VALUE,
                                                &Canceled
                                                ) ) {
                        // Not OK.  The last error has already been set.
                        if( Canceled ) {
                            BaseMarkFileForDelete(
                                DestFile,
                                0
                                );
                        }
                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;
                    }
                }
		
                //
                // When appropriate, copy the reparse point.
                //

                if ( OpenFileAsReparsePoint &&
                     (DestFile != INVALID_HANDLE_VALUE)) {
                    DWORD CopyResult = FALSE;

                    CopyResult = CopyReparsePoint(
                                     hSourceFile,
                                     DestFile
                                     );

                    if ( !CopyResult ) {
                        //
                        // Note that when OpenFileAsReparsePoint is TRUE, by
                        // exiting at this point the effect is that the caller
                        // will re-start the copy without inhibiting the reparse
                        // behavior.
                        //

                        //If we fail here, we may be leaving a newly created
                        // file around at the destination.  If
                        // COPY_FILE_FAIL_IF_EXISTS has been specified,
                        // further retries will fail.  Therefore we need to
                        // try to delete the new file here.
                        if (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS)
                        {
                            FILE_DISPOSITION_INFORMATION Disposition = {TRUE};

                            Status = NtSetInformationFile(
                                DestFile,
                                &IoStatus,
                                &Disposition,
                                sizeof(Disposition),
                                FileDispositionInformation
                                );
                            //Ignore an error if there is one.

                        }
                        *lpDestFile = DestFile;
                        leave;
                    }
                }   // if ( OpenFileAsReparsePoint &&(DestFile != INVALID_HANDLE_VALUE))


                //
                // Get the File & FileSys attributes for the target volume, plus
                // the FileSys attributes for the source volume.  Ignore errors in
                // the target, e.g. it might be a printer and not support these calls
                // (just assume the attrs in this case are zero).
                //

                *DestFileFsAttributes = 0;
                SourceFileFsAttributes = 0;
                DestFileAttributes = 0;

                Status = NtQueryVolumeInformationFile( DestFile,
                                                       &IoStatus,
                                                       &FileFsAttrInfoBuffer.Info,
                                                       sizeof(FileFsAttrInfoBuffer),
                                                       FileFsAttributeInformation );

                if( NT_SUCCESS(Status) ) {
                    *DestFileFsAttributes = FileFsAttrInfoBuffer.Info.FileSystemAttributes;
                }

                if( lpConsoleName == NULL ) {
                    Status = NtQueryInformationFile( DestFile,
                                                     &IoStatus,
                                                     &DestBasicInformation,
                                                     sizeof(DestBasicInformation),
                                                     FileBasicInformation );
                    if( NT_SUCCESS(Status) ) {
                        DestFileAttributes = DestBasicInformation.FileAttributes;
                    }
                }

                Status = NtQueryVolumeInformationFile( hSourceFile,
                                                       &IoStatus,
                                                       &FileFsAttrInfoBuffer.Info,
                                                       sizeof(FileFsAttrInfoBuffer),
                                                       FileFsAttributeInformation );
                if( NT_SUCCESS(Status) ) {
                    SourceFileFsAttributes = FileFsAttrInfoBuffer.Info.FileSystemAttributes;
                } else {
                    BaseMarkFileForDelete( DestFile, 0 );
                    BaseSetLastNTError(Status);
                    leave;
                }

                //
                // If requested and applicable, copy one or more of the the DACL, SACL, owner, and group.
                // If the source doesn't support persistent ACLs, assume that that means that
                // it doesn't support any of DACL, SACL, and owner/group.
                //

                if( (SourceFileFsAttributes & FILE_PERSISTENT_ACLS)
                    &&
                    (*lpCopyFlags & (PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_SACL | PRIVCOPY_FILE_OWNER_GROUP)) ) {

                    SECURITY_INFORMATION SecurityInformation = 0;

                    if( *lpCopyFlags & PRIVCOPY_FILE_METADATA
                        && !(*lpCopyFlags & PRIVCOPY_FILE_SKIP_DACL) ) {

                        // Copy the DACL if metadata flag is set, but skip_dacl is not.
                        // The skip_dacl flag is a temporary workaround for a problem
                        // in CSC & roaming profiles.

                        SecurityInformation |= DACL_SECURITY_INFORMATION;
                    }

                    if( *lpCopyFlags & PRIVCOPY_FILE_SACL )
                        SecurityInformation |= SACL_SECURITY_INFORMATION;

                    if( *lpCopyFlags & PRIVCOPY_FILE_OWNER_GROUP )
                        SecurityInformation |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION;

                    if( SecurityInformation != 0 ) {

                        if( !BasepCopySecurityInformation( lpExistingFileName,
                                                           hSourceFile,
                                                           SourceFileAccess,
                                                           lpNewFileName,
                                                           DestFile,
                                                           DestFileAccess,
                                                           SecurityInformation,
                                                           Context,
                                                           *DestFileFsAttributes,
                                                           &Canceled )) {

                            if( Canceled ) {
                                BaseMarkFileForDelete(
                                    DestFile,
                                    0
                                    );
                            }
                            leave;
                        }
                    }
                }

                //
                // Copy compression and encryption
                //

                if( (*lpCopyFlags & PRIVCOPY_FILE_METADATA) ) {

                    BOOL DoCompression = FALSE;
                    int i = 0;

                    // Compression and encryption must be handled in the proper
                    // order, since a file can't be both at once.  For example,
                    // if copying (with supersede) a compressed/unencrypted file over an
                    // uncompressed/encrypted file, we must decrypt the dest
                    // before attempting to compress it.

                    if( DestFileAttributes & FILE_ATTRIBUTE_COMPRESSED ) {
                        // Handle compression first
                        DoCompression = TRUE;
                    }

                    for( i = 0; i < 2; i++ ) {

                        if( DoCompression ) {

                            DoCompression = FALSE;
                            b = BasepCopyCompression( hSourceFile,
                                                      DestFile,
                                                      SourceFileAttributes,
                                                      DestFileAttributes,
                                                      *DestFileFsAttributes,
                                                      *lpCopyFlags,
                                                      &Context );

                        } else {

                            DoCompression = TRUE;
                            b = BasepCopyEncryption( hSourceFile,
                                                     lpNewFileName,
                                                     &DestFile,
                                                     &Obja,
                                                     DestFileAccess,
                                                     DestFileSharing,
                                                     CreateDisposition,
                                                     CreateOptions,
                                                     SourceFileAttributes,
                                                     SourceFileAttributesMask,
                                                     &DestFileAttributes,
                                                     *DestFileFsAttributes,
                                                     *lpCopyFlags,
                                                     &Context );
                        }

                        if( !b ) {
                            // The dest file is already marked for delete and
                            // last error has been set.
                            leave;
                        }
                    }   // for( i = 0; i < 2; i++ )

                }   // if( (*lpCopyFlags & PRIVCOPY_FILE_METADATA) )
                else {

                    // 
                    // For the public copyfile, we still need to handle encryption.
                    //

                    b = BasepCopyEncryption( hSourceFile,
                                             lpNewFileName,
                                             &DestFile,
                                             &Obja,
                                             DestFileAccess,
                                             DestFileSharing,
                                             CreateDisposition,
                                             CreateOptions,
                                             SourceFileAttributes,
                                             SourceFileAttributesMask,
                                             &DestFileAttributes,
                                             *DestFileFsAttributes,
                                             *lpCopyFlags,
                                             &Context );

                    if( !b ) {
                        // The dest file is already marked for delete and
                        // last error has been set.
                        leave;
                    }
                }   // if( (*lpCopyFlags & PRIVCOPY_FILE_METADATA) ) ... else


                //
                // If copying a directory file, see if any attributes need to be
                // added.  For non-directory files, this is handled in the NtCreateFile since
                // either FILE_CREATE or FILE_OVERWRITE_IF is specified.
                //

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                    //
                    // But before copying attributes, in the supersede case, the target's
                    // named streams should be removed.  We need to do this first,
                    // in case copying the attributes sets the read-only bit.
                    //

                    if( *lpCopyFlags & PRIVCOPY_FILE_SUPERSEDE ) {

                        ULONG StreamInfoSize;
                        PFILE_STREAM_INFORMATION StreamInfo;
                        PFILE_STREAM_INFORMATION StreamInfoBase = NULL;

                        // Get the dest file's streams

                        StreamInfoSize = 4096;
                        do {
                            StreamInfoBase = RtlAllocateHeap( RtlProcessHeap(),
                                                              MAKE_TAG( TMP_TAG ),
                                                              StreamInfoSize );

                            if ( !StreamInfoBase ) {
                                BaseSetLastNTError( STATUS_NO_MEMORY );
                                leave;
                            }

                            Status = NtQueryInformationFile(
                                        DestFile,
                                        &IoStatus,
                                        (PVOID) StreamInfoBase,
                                        StreamInfoSize,
                                        FileStreamInformation
                                        );

                            if ( !NT_SUCCESS(Status) ) {
                                //
                                //  We failed the call.  Free up the previous buffer and set up
                                //  for another pass with a buffer twice as large
                                //

                                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                                StreamInfoBase = NULL;
                                StreamInfoSize *= 2;
                            }
                            else if( IoStatus.Information == 0 ) {
                                // There are no streams
                                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                                StreamInfoBase = NULL;
                            }

                        } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

                        // If there were any streams, delete them.

                        if( StreamInfoBase != NULL ) {
                            StreamInfo = StreamInfoBase;
                            while (TRUE) {

                                OBJECT_ATTRIBUTES Obja;
                                UNICODE_STRING StreamName;
                                HANDLE DestStream;

                                StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                                StreamName.MaximumLength = (USHORT) StreamName.Length;
                                StreamName.Buffer = StreamInfo->StreamName;

                                InitializeObjectAttributes(
                                    &Obja,
                                    &StreamName,
                                    OBJ_CASE_INSENSITIVE,
                                    DestFile,
                                    NULL
                                    );

                                // Relative-open the stream to be deleted.

                                Status = NtCreateFile(
                                            &DestStream,
                                            DELETE|SYNCHRONIZE,
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            0,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                            FILE_OPEN,
                                            FILE_DELETE_ON_CLOSE | FILE_SYNCHRONOUS_IO_NONALERT,
                                            NULL,
                                            0
                                            );
                                if( !NT_SUCCESS(Status) ) {
                                    RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                                    BaseMarkFileForDelete( DestFile, 0 );
                                    BaseSetLastNTError( Status );
                                    leave;
                                }

                                // Delete the stream
                                NtClose( DestStream );

                                if (StreamInfo->NextEntryOffset == 0) {
                                    break;
                                }
                                StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
                            }   // while (TRUE)

                            RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                        }   // if( StreamInfoBase != NULL )
                    }   // if( *lpCopyFlags & PRIVCOPY_FILE_SUPERSEDE )

                    // Now, if necessary, copy over attributes.

                    if( SourceFileAttributes != DestFileAttributes ) {

                        DestFileAttributes |= SourceFileAttributes;

                        RtlZeroMemory( &DestBasicInformation, sizeof(DestBasicInformation) );
                        DestBasicInformation.FileAttributes = DestFileAttributes;
                        Status = NtSetInformationFile( DestFile,
                                                       &IoStatus,
                                                       &DestBasicInformation,
                                                       sizeof(DestBasicInformation),
                                                       FileBasicInformation );
                        if( !NT_SUCCESS(Status) ) {
                            BaseMarkFileForDelete( DestFile, 0 );
                            BaseSetLastNTError(Status);
                            leave;
                        }

                        DestFileAttributes = 0;
                        Status = NtQueryInformationFile( DestFile,
                                                         &IoStatus,
                                                         &DestBasicInformation,
                                                         sizeof(DestBasicInformation),
                                                         FileBasicInformation );
                        if( NT_SUCCESS(Status) ) {
                            DestFileAttributes = DestBasicInformation.FileAttributes;
                        } else {
                            BaseMarkFileForDelete( DestFile, 0 );
                            BaseSetLastNTError(Status);
                            leave;
                        }
                    }

                }   // if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY )


            }   // if( DestFile != INVALID_HANDLE_VALUE )

            //
            // If this is a directory file, there is nothing left to copy
            //

            if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                BOOL Canceled = FALSE;

                if( !BasepCopyFileCallback( TRUE,   // ContinueByDefault
                                            RtlNtStatusToDosError(STATUS_REQUEST_ABORTED),
                                            Context,
                                            NULL,
                                            CALLBACK_STREAM_SWITCH,
                                            hSourceFile,
                                            DestFile,
                                            &Canceled ) ) {
                    ReturnValue = FALSE;
                    if( Canceled ) {
                        BaseMarkFileForDelete(
                            DestFile,
                            0
                            );
                    }
                } else {
                    ReturnValue = TRUE;
                }
                leave;

            }


        } else {    // if ( !ARGUMENT_PRESENT(hTargetFile) )

            // We're copying a named stream.

            OBJECT_ATTRIBUTES ObjectAttributes;
            UNICODE_STRING StreamName;
            IO_STATUS_BLOCK IoStatus;
            ULONG Disposition;

            //
            // Create the output stream relative to the file specified by the
            // hTargetFile file handle.
            //

            RtlInitUnicodeString(&StreamName, lpNewFileName);
            InitializeObjectAttributes(
                &ObjectAttributes,
                &StreamName,
                0,
                hTargetFile,
                (PSECURITY_DESCRIPTOR)NULL
                );

            //
            // Determine the disposition type.
            //

            if ( *lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS ) {
                Disposition = FILE_CREATE;
            } else {
                Disposition = FILE_OVERWRITE_IF;
            }

            if ( Restartable ) {
                if ( lpRestartState->LastKnownGoodOffset.QuadPart ) {
                    Disposition = FILE_OPEN;
                } else {
                    Disposition = FILE_OVERWRITE_IF;
                }
            }

            //
            // Inhibit reparse behavior when appropriate.
            //

            FlagsAndAttributes = FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY;
            DesiredAccess = GENERIC_WRITE | SYNCHRONIZE;
            if ( OpenFileAsReparsePoint ) {
                //
                // The target has to be opened as reparse point. If
                // this fails the source is to be closed and re-opened
                // without inhibiting the reparse point behavior.
                //

                FlagsAndAttributes |= FILE_OPEN_REPARSE_POINT;
                DesiredAccess |= GENERIC_READ;
                if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ||
                     !(Restartable && (lpRestartState->LastKnownGoodOffset.QuadPart)) ) {
                    Disposition = FILE_OPEN_IF;
                }
            }

            Status = NtCreateFile(
                        &DestFile,
                        DesiredAccess,
                        &ObjectAttributes,
                        &IoStatus,
                        lpFileSize,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        Disposition,
                        FlagsAndAttributes,
                        (PVOID)NULL,
                        0);

            if ( !NT_SUCCESS(Status) ) {

                // If we failed the create with an invalid name error, it might be becuase
                // we tried to copy an NTFS5 property set to pre-NTFS5 (and pre-NTFS4/SP4)
                // To detect this, we first check the error, and that the prefix character
                // of the stream name is a reserved ole character.

                if( Status == STATUS_OBJECT_NAME_INVALID
                    &&
                    StreamName.Buffer[1] <= 0x1f
                    &&
                    StreamName.Buffer[1] >= 1 ) {

                    // Now we check to see if we're copying to pre-NTFS5.
                    // If so, we'll assume that the leading ole character is
                    // the cause of the problem, and will silently fail the
                    // copy of this stream just as NT4 did.

                    NTSTATUS StatusT = STATUS_SUCCESS;
                    IO_STATUS_BLOCK Iosb;
                    FILE_FS_ATTRIBUTE_INFORMATION FsAttrInfo;

                    StatusT = NtQueryVolumeInformationFile( hTargetFile, &Iosb,
                                                            &FsAttrInfo,
                                                            sizeof(FsAttrInfo),
                                                            FileFsAttributeInformation );


                    // We should always get a buffer-overflow error here, because we don't
                    // provide enough buffer for the file system name, but that's OK because
                    // we don't need it (status_buffer_overflow is just a warning, so the rest
                    // of the data is good).

                    if( !NT_SUCCESS(StatusT) && STATUS_BUFFER_OVERFLOW != StatusT) {
                        Status = StatusT;
                        BaseSetLastNTError(Status);
                        leave;
                    }

                    // If this is pre-NTFS5, then silently ignore the error.
                    if( !(FILE_SUPPORTS_OBJECT_IDS & FsAttrInfo.FileSystemAttributes) ) {

                        Status = STATUS_SUCCESS;
                        ReturnValue = TRUE;
                        leave;
                    }
                }


                if ( Status != STATUS_ACCESS_DENIED ) {
                    BaseSetLastNTError(Status);
                    leave;
                }

                //
                // Determine whether or not this failed because the file
                // is a readonly file.  If so, change it to read/write,
                // re-attempt the open, and set it back to readonly again.
                //

                Status = NtQueryInformationFile(
                            hTargetFile,
                            &IoStatus,
                            (PVOID) &FileBasicInformationData,
                            sizeof(FileBasicInformationData),
                            FileBasicInformation
                            );

                if ( !NT_SUCCESS(Status) ) {
                    leave;
                }

                if ( FileBasicInformationData.FileAttributes & FILE_ATTRIBUTE_READONLY ) {
                    ULONG attributes = FileBasicInformationData.FileAttributes;

                    RtlZeroMemory( &FileBasicInformationData,
                                   sizeof(FileBasicInformationData)
                                );
                    FileBasicInformationData.FileAttributes = FILE_ATTRIBUTE_NORMAL;
                    (VOID) NtSetInformationFile(
                              hTargetFile,
                              &IoStatus,
                              &FileBasicInformationData,
                              sizeof(FileBasicInformationData),
                              FileBasicInformation
                              );
                    Status = NtCreateFile(
                                &DestFile,
                                DesiredAccess,
                                &ObjectAttributes,
                                &IoStatus,
                                lpFileSize,
                                0,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                Disposition,
                                FlagsAndAttributes,
                                (PVOID)NULL,
                                0);
                    FileBasicInformationData.FileAttributes = attributes;
                    (VOID) NtSetInformationFile(
                                hTargetFile,
                                &IoStatus,
                                &FileBasicInformationData,
                                sizeof(FileBasicInformationData),
                                FileBasicInformation
                                );
                    if ( !NT_SUCCESS(Status) ) {
                        leave;
                    }
                } else {
                    leave;
                }
            }

            //
            // Adjust the file length in the case of a destination open with the
            // reparse behavior inhibited. This is needed because of the incompatibility
            // between FILE_OPEN_REPARSE_POINT and FILE_OVERWRITE_IF.
            //

            if ( OpenFileAsReparsePoint ) {
               if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ||
                    !(Restartable && (lpRestartState->LastKnownGoodOffset.QuadPart)) ) {
                   SetFilePointer(DestFile,0,NULL,FILE_BEGIN);
               }
            }

        }   // if ( !ARGUMENT_PRESENT(hTargetFile) ) ... else

        //
        // Adjust the notion of restartability and chunk size based on whether
        // or not one of the files is remote.
        //

        if ( Restartable || lpFileSize->QuadPart >= BASE_COPY_FILE_CHUNK ) {
            if ( BasepRemoteFile(hSourceFile,DestFile) ) {
                *lpCopySize = BASE_COPY_FILE_CHUNK - 4096;
            } else if ( Restartable ) {
                *lpCopyFlags &= ~COPY_FILE_RESTARTABLE;
                Restartable = FALSE;
            }
        }

        //
        // Preallocate the size of this file/stream so that extends do not
        // occur.
        //

        if ( !(Restartable && lpRestartState->LastKnownGoodOffset.QuadPart) &&
            lpFileSize->QuadPart) {

            EndOfFileInformation.EndOfFile = *lpFileSize;
            Status = NtSetInformationFile(
                        DestFile,
                        &IoStatus,
                        &EndOfFileInformation,
                        sizeof(EndOfFileInformation),
                        FileEndOfFileInformation
                        );
            if ( Status == STATUS_DISK_FULL ) {
                BaseSetLastNTError(Status);
                BaseMarkFileForDelete(
                    DestFile,
                    FileBasicInformationData.FileAttributes
                    );
                CloseHandle(DestFile);
                DestFile = INVALID_HANDLE_VALUE;
                leave;
            }
        }

        //
        // If the caller has a progress routine, invoke it and indicate that the
        // output file or alternate data stream has been created.  Note that a
        // stream number of 1 means that the file itself has been created.
        //

        BytesWritten.QuadPart = 0;
        if ( Context ) {
            if ( Context->lpProgressRoutine ) {
                Context->dwStreamNumber += 1;
                ReturnCode = Context->lpProgressRoutine(
                                Context->TotalFileSize,
                                Context->TotalBytesTransferred,
                                *lpFileSize,
                                BytesWritten,
                                Context->dwStreamNumber,
                                CALLBACK_STREAM_SWITCH,
                                hSourceFile,
                                DestFile,
                                Context->lpData
                                );
            } else {
                ReturnCode = PROGRESS_CONTINUE;
            }

            if ( ReturnCode == PROGRESS_CANCEL ||
                (Context->lpCancel && *Context->lpCancel) ) {
                BaseMarkFileForDelete(
                    hTargetFile ? hTargetFile : DestFile,
                    FileBasicInformationData.FileAttributes
                    );
                BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                leave;
            }

            if ( ReturnCode == PROGRESS_STOP ) {
                BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                leave;
            }

            if ( ReturnCode == PROGRESS_QUIET ) {
                Context = NULL;
                *lpCopyFileContext = NULL;
            }
        }


        if (!Restartable) {

            while (!lpFileSize->HighPart && (lpFileSize->LowPart < TWO56K)) {

                // If there's nothing to copy, then we're done (this happens when
                // copying directory files, as there's no unnamed data stream).

                if( lpFileSize->LowPart == 0 ) {
                    ReturnValue = TRUE;
                    leave;
                }

                //
                // Create a section and map the source file.  If anything fails,
                // then drop into an I/O system copy mode.
                //

                Status = NtCreateSection(
                    &Section,
                        SECTION_ALL_ACCESS,
                        NULL,
                        NULL,
                        PAGE_READONLY,
                        SEC_COMMIT,
                        hSourceFile
                    );
                if ( !NT_SUCCESS(Status) ) {
                    break;
                }

                SectionOffset.LowPart = 0;
                SectionOffset.HighPart = 0;
                ViewSize = 0;
                BigViewSize = 0;

                Status = NtMapViewOfSection(
                    Section,
                    NtCurrentProcess(),
                    &SourceBase,
                    0L,
                    0L,
                    &SectionOffset,
                    &BigViewSize,
                    ViewShare,
                    0L,
                    PAGE_READONLY
                    );
                NtClose(Section);
                Section = NULL;
                if ( !NT_SUCCESS(Status) ) {
                    break;
                }

                //
                // note that this is OK since ViewSize will never be > 256k in this path
                //

                ViewSize = (ULONG)BigViewSize;

                //
                // Everything is mapped, so copy the stream
                //

                SourceBuffer = SourceBase;
                BytesToWrite = lpFileSize->LowPart;

                //
                //  Since we are playing with user memory here, the user
                //  may decommit or unmap it on us.  We wrap the access
                //  in try/except to clean up if anything goes wrong
                //
                //  We set ReturnCode inside the try/except so that we
                //  can detect failure and leave from the enclosing try/finally.
                //

                ReturnCode = TRUE;

                try {

                    while (BytesToWrite) {
                        if (BytesToWrite > *lpCopySize) {
                            ViewSize = *lpCopySize;
                        } else {
                            ViewSize = BytesToWrite;
                        }

                        if ( !WriteFile(DestFile,SourceBuffer,ViewSize, &ViewSize, NULL) ) {
                            if ( !ARGUMENT_PRESENT(hTargetFile) &&
                                GetLastError() != ERROR_NO_MEDIA_IN_DRIVE ) {

                                BaseMarkFileForDelete(
                                    DestFile,
                                    FileBasicInformationData.FileAttributes
                                    );
                            }
                            ReturnCode = PROGRESS_STOP;
                            leave;
                        }

                        BytesToWrite -= ViewSize;
                        SourceBuffer += ViewSize;

                        //
                        // If the caller has a progress routine, invoke it for this
                        // chunk's completion.
                        //

                        if ( Context ) {
                            if ( Context->lpProgressRoutine ) {
                                BytesWritten.QuadPart += ViewSize;
                                Context->TotalBytesTransferred.QuadPart += ViewSize;
                                ReturnCode = Context->lpProgressRoutine(
                                    Context->TotalFileSize,
                                    Context->TotalBytesTransferred,
                                    *lpFileSize,
                                    BytesWritten,
                                    Context->dwStreamNumber,
                                    CALLBACK_CHUNK_FINISHED,
                                    hSourceFile,
                                    DestFile,
                                    Context->lpData
                                    );
                            } else {
                                ReturnCode = PROGRESS_CONTINUE;
                            }

                            if ( ReturnCode == PROGRESS_CANCEL ||
                                 (Context->lpCancel && *Context->lpCancel) ) {
                                if ( !ARGUMENT_PRESENT(hTargetFile) ) {
                                    BaseMarkFileForDelete(
                                        hTargetFile ? hTargetFile : DestFile,
                                        FileBasicInformationData.FileAttributes
                                        );
                                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                                }
                                ReturnCode = PROGRESS_STOP;
                                leave;
                            }

                            if ( ReturnCode == PROGRESS_STOP ) {
                                BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                                ReturnCode = PROGRESS_STOP;
                                leave;
                            }

                            if ( ReturnCode == PROGRESS_QUIET ) {
                                Context = NULL;
                                *lpCopyFileContext = NULL;
                            }
                        }
                    }   // while (BytesToWrite)

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    if ( !ARGUMENT_PRESENT(hTargetFile) ) {
                        BaseMarkFileForDelete(
                            DestFile,
                            FileBasicInformationData.FileAttributes
                            );
                    }
                    BaseSetLastNTError(GetExceptionCode());
                    ReturnCode = PROGRESS_STOP;
                }

                if (ReturnCode != PROGRESS_STOP) {
                    ReturnValue = TRUE;
                }

                leave;

            }   // while (!lpFileSize->HighPart && (lpFileSize->LowPart < TWO56K)
        }   // if (!Restartable)

        if ( Restartable ) {

            //
            // A restartable operation is being performed.  Reset the state
            // of the copy to the last known good offset that was written
            // to the output file to continue the operation.
            //

            SetFilePointer(
                hSourceFile,
                lpRestartState->LastKnownGoodOffset.LowPart,
                &lpRestartState->LastKnownGoodOffset.HighPart,
                FILE_BEGIN
                );
            SetFilePointer(
                DestFile,
                lpRestartState->LastKnownGoodOffset.LowPart,
                &lpRestartState->LastKnownGoodOffset.HighPart,
                FILE_BEGIN
                );
            BytesWritten.QuadPart = lpRestartState->LastKnownGoodOffset.QuadPart;
        }

        IoDestBase = RtlAllocateHeap(
                        RtlProcessHeap(),
                        MAKE_TAG( TMP_TAG ),
                        *lpCopySize
                        );
        if ( !IoDestBase ) {
            if ( !ARGUMENT_PRESENT(hTargetFile) && !Restartable ) {
                BaseMarkFileForDelete(
                    DestFile,
                    FileBasicInformationData.FileAttributes
                    );
            }
            BaseSetLastNTError(STATUS_NO_MEMORY);
            leave;
        }



        do {

            BlockSize = *lpCopySize;
            fSkipBlock = FALSE;


            if (!fSkipBlock) {
                b = ReadFile(hSourceFile,IoDestBase,BlockSize, &ViewSize, NULL);
            } else {
                LARGE_INTEGER BytesRead;
                BytesRead = BytesWritten;

                if (BytesRead.QuadPart > lpFileSize->QuadPart) {
                    BlockSize = 0;
                } else if (BytesRead.QuadPart + BlockSize >= lpFileSize->QuadPart) {
                    BlockSize = (ULONG)(lpFileSize->QuadPart - BytesRead.QuadPart);
                }

                BytesRead.QuadPart += BlockSize;
                if ( SetFilePointer(hSourceFile,
                                    BytesRead.LowPart,
                                    &BytesRead.HighPart,
                                    FILE_BEGIN) != 0xffffffff ) {
                } else {
                    if (GetLastError() != NO_ERROR)
                        b = FALSE;
                }
                ViewSize = BlockSize;
            }

            if (!b || !ViewSize)
                break;

            if (!fSkipBlock) {
                if ( !WriteFile(DestFile,IoDestBase,ViewSize, &ViewSize, NULL) ) {
                    if ( !ARGUMENT_PRESENT(hTargetFile) &&
                         GetLastError() != ERROR_NO_MEDIA_IN_DRIVE &&
                         !Restartable ) {

                        BaseMarkFileForDelete(
                                             DestFile,
                                             FileBasicInformationData.FileAttributes
                                             );
                    }

                    leave;
                }
                BytesWritten.QuadPart += ViewSize;
            } else {
                BytesWritten.QuadPart += ViewSize;
                if (( SetFilePointer(DestFile,
                                     BytesWritten.LowPart,
                                     &BytesWritten.HighPart,
                                     FILE_BEGIN) == 0xffffffff ) &&
                    ( GetLastError() != NO_ERROR )) {
                    b = FALSE;
                    break;
                }
            }

            WriteCount++;

            if ( Restartable &&
                 (((WriteCount & 3) == 0 &&
                   BytesWritten.QuadPart ) ||
                  BytesWritten.QuadPart == lpFileSize->QuadPart) ) {

                LARGE_INTEGER SavedOffset;
                DWORD Bytes;
                HANDLE DestinationFile = hTargetFile ? hTargetFile : DestFile;

                //
                // Another 256kb has been written to the target file, or
                // this stream of the file has been completely copied, so
                // update the restart state in the output file accordingly.
                //

                NtFlushBuffersFile(DestinationFile,&IoStatus);
                SavedOffset.QuadPart = BytesWritten.QuadPart;
                SetFilePointer(DestinationFile,0,NULL,FILE_BEGIN);
                lpRestartState->LastKnownGoodOffset.QuadPart = BytesWritten.QuadPart;
                lpRestartState->Checksum = BasepChecksum((PUSHORT)lpRestartState,FIELD_OFFSET(RESTART_STATE,Checksum) >> 1);
                b = WriteFile(
                             DestinationFile,
                             lpRestartState,
                             sizeof(RESTART_STATE),
                             &Bytes,
                             NULL
                             );
                if ( !b || Bytes != sizeof(RESTART_STATE) ) {
                    leave;
                }
                NtFlushBuffersFile(DestinationFile,&IoStatus);
                SetFilePointer(
                              DestinationFile,
                              SavedOffset.LowPart,
                              &SavedOffset.HighPart,
                              FILE_BEGIN
                              );
            }

            //
            // If the caller has a progress routine, invoke it for this
            // chunk's completion.
            //

            if ( Context ) {
                if ( Context->lpProgressRoutine ) {
                    Context->TotalBytesTransferred.QuadPart += ViewSize;
                    ReturnCode = Context->lpProgressRoutine(
                                                           Context->TotalFileSize,
                                                           Context->TotalBytesTransferred,
                                                           *lpFileSize,
                                                           BytesWritten,
                                                           Context->dwStreamNumber,
                                                           CALLBACK_CHUNK_FINISHED,
                                                           hSourceFile,
                                                           DestFile,
                                                           Context->lpData
                                                           );
                } else {
                    ReturnCode = PROGRESS_CONTINUE;
                }
                if ( ReturnCode == PROGRESS_CANCEL ||
                     (Context->lpCancel && *Context->lpCancel) ) {
                    if ( !ARGUMENT_PRESENT(hTargetFile) ) {
                        BaseMarkFileForDelete(
                                             hTargetFile ? hTargetFile : DestFile,
                                             FileBasicInformationData.FileAttributes
                                             );
                        BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                        leave;
                    }
                }

                if ( ReturnCode == PROGRESS_STOP ) {
                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                    leave;
                }

                if ( ReturnCode == PROGRESS_QUIET ) {
                    Context = NULL;
                    *lpCopyFileContext = NULL;
                }
            }
        } while (TRUE);

        if ( !b && !ARGUMENT_PRESENT(hTargetFile) ) {
            if ( !Restartable ) {
                BaseMarkFileForDelete(
                    DestFile,
                    FileBasicInformationData.FileAttributes
                    );
            }
            leave;
        }

        ReturnValue = TRUE;
    } finally {
        if ( DestFile != INVALID_HANDLE_VALUE ) {
            *lpDestFile = DestFile;
        }
        if ( Section ) {
            NtClose(Section);
        }
        if ( SourceBase ) {
            NtUnmapViewOfSection(NtCurrentProcess(),SourceBase);
        }
        RtlFreeHeap(RtlProcessHeap(), 0,IoDestBase);
        RtlFreeHeap(RtlProcessHeap(), 0, DestFileNameBuffer );
        RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer );

        // If the TEB buffer was saved, restore it now.
        if( lpExistingFileName == SaveStaticUnicodeBuffer ) {

            memcpy( NtCurrentTeb()->StaticUnicodeBuffer,
                    SaveStaticUnicodeBuffer,
                    STATIC_UNICODE_BUFFER_LENGTH );
        }

    }

    return ReturnValue;
}

HANDLE
WINAPI
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    ANSI thunk to CreateFileW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    return ( CreateFileW( Unicode->Buffer,
                          dwDesiredAccess,
                          dwShareMode,
                          lpSecurityAttributes,
                          dwCreationDisposition,
                          dwFlagsAndAttributes,
                          hTemplateFile
                        )
           );
}

HANDLE
WINAPI
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    A file can be created, opened, or truncated, and a handle opened to
    access the new file using CreateFile.

    This API is used to create or open a file and obtain a handle to it
    that allows reading data, writing data, and moving the file pointer.

    This API allows the caller to specify the following creation
    dispositions:

      - Create a new file and fail if the file exists ( CREATE_NEW )

      - Create a new file and succeed if it exists ( CREATE_ALWAYS )

      - Open an existing file ( OPEN_EXISTING )

      - Open and existing file or create it if it does not exist (
        OPEN_ALWAYS )

      - Truncate and existing file ( TRUNCATE_EXISTING )

    If this call is successful, a handle is returned that has
    appropriate access to the specified file.

    If as a result of this call, a file is created,

      - The attributes of the file are determined by the value of the
        FileAttributes parameter or'd with the FILE_ATTRIBUTE_ARCHIVE bit.

      - The length of the file will be set to zero.

      - If the hTemplateFile parameter is specified, any extended
        attributes associated with the file are assigned to the new file.

    If a new file is not created, then the hTemplateFile is ignored as
    are any extended attributes.

    For DOS based systems running share.exe the file sharing semantics
    work as described above.  Without share.exe no share level
    protection exists.

    This call is logically equivalent to DOS (int 21h, function 5Bh), or
    DOS (int 21h, function 3Ch) depending on the value of the
    FailIfExists parameter.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    dwDesiredAccess - Supplies the caller's desired access to the file.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.

    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new file.

    dwCreationDisposition - Supplies a creation disposition that
        specifies how this call is to operate.  This parameter must be
        one of the following values.

        dwCreationDisposition Value:

        CREATE_NEW - Create a new file.  If the specified file already
            exists, then fail.  The attributes for the new file are what
            is specified in the dwFlagsAndAttributes parameter or'd with
            FILE_ATTRIBUTE_ARCHIVE.  If the hTemplateFile is specified,
            then any extended attributes associated with that file are
            propogated to the new file.

        CREATE_ALWAYS - Always create the file.  If the file already
            exists, then it is overwritten.  The attributes for the new
            file are what is specified in the dwFlagsAndAttributes
            parameter or'd with FILE_ATTRIBUTE_ARCHIVE.  If the
            hTemplateFile is specified, then any extended attributes
            associated with that file are propogated to the new file.

        OPEN_EXISTING - Open the file, but if it does not exist, then
            fail the call.

        OPEN_ALWAYS - Open the file if it exists.  If it does not exist,
            then create the file using the same rules as if the
            disposition were CREATE_NEW.

        TRUNCATE_EXISTING - Open the file, but if it does not exist,
            then fail the call.  Once opened, the file is truncated such
            that its size is zero bytes.  This disposition requires that
            the caller open the file with at least GENERIC_WRITE access.

    dwFlagsAndAttributes - Specifies flags and attributes for the file.
        The attributes are only used when the file is created (as
        opposed to opened or truncated).  Any combination of attribute
        flags is acceptable except that all other attribute flags
        override the normal file attribute, FILE_ATTRIBUTE_NORMAL.  The
        FILE_ATTRIBUTE_ARCHIVE flag is always implied.

        dwFlagsAndAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

        FILE_FLAG_POSIX_SEMANTICS - Indicates that the file being opened
            should be accessed in a manner compatible with the rules used
            by POSIX.  This includes allowing multiple files with the same
            name, differing only in case.  WARNING:  Use of this flag may
            render it impossible for a DOS, WIN-16, or WIN-32 application
            to access the file.

        FILE_FLAG_OPEN_REPARSE_POINT - Indicates that the file being opened
            should be accessed as if it were a reparse point.  WARNING:  Use
            of this flag may inhibit the operation of file system filter drivers
            present in the I/O subsystem.

        FILE_FLAG_OPEN_NO_RECALL - Indicates that all the state of the file
            should be acessed without changing its storage location.  Thus,
            in the case of files that have parts of its state stored at a
            remote servicer, no permanent recall of data is to happen.

    Security Quality of Service information may also be specified in
        the dwFlagsAndAttributes parameter.  These bits are meaningful
        only if the file being opened is the client side of a Named
        Pipe.  Otherwise they are ignored.

        SECURITY_SQOS_PRESENT - Indicates that the Security Quality of
            Service bits contain valid values.

    Impersonation Levels:

        SECURITY_ANONYMOUS - Specifies that the client should be impersonated
            at Anonymous impersonation level.

        SECURITY_IDENTIFICAION - Specifies that the client should be impersonated
            at Identification impersonation level.

        SECURITY_IMPERSONATION - Specifies that the client should be impersonated
            at Impersonation impersonation level.

        SECURITY_DELEGATION - Specifies that the client should be impersonated
            at Delegation impersonation level.

    Context Tracking:

        SECURITY_CONTEXT_TRACKING - A boolean flag that when set,
            specifies that the Security Tracking Mode should be
            Dynamic, otherwise Static.

        SECURITY_EFFECTIVE_ONLY - A boolean flag indicating whether
            the entire security context of the client is to be made
            available to the server or only the effective aspects of
            the context.

    hTemplateFile - An optional parameter, then if specified, supplies a
        handle with GENERIC_READ access to a template file.  The
        template file is used to supply extended attributes for the file
        being created.  When the new file is created, the relevant attributes
        from the template file are used in creating the new file.

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateDisposition;
    ULONG CreateFlags;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    FILE_EA_INFORMATION EaInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    ULONG EaSize;
    PUNICODE_STRING lpConsoleName;
    BOOL bInheritHandle;
    BOOL EndsInSlash;
    DWORD SQOSFlags;
    BOOLEAN ContextTrackingMode = FALSE;
    BOOLEAN EffectiveOnly = FALSE;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = 0;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    switch ( dwCreationDisposition ) {
        case CREATE_NEW        :
            CreateDisposition = FILE_CREATE;
            break;
        case CREATE_ALWAYS     :
            CreateDisposition = FILE_OVERWRITE_IF;
            break;
        case OPEN_EXISTING     :
            CreateDisposition = FILE_OPEN;
            break;
        case OPEN_ALWAYS       :
            CreateDisposition = FILE_OPEN_IF;
            break;
        case TRUNCATE_EXISTING :
            CreateDisposition = FILE_OPEN;
            if ( !(dwDesiredAccess & GENERIC_WRITE) ) {
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
                }
            break;
        default :
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    // temporary routing code

    RtlInitUnicodeString(&FileName,lpFileName);

    if ( FileName.Length > 1 && lpFileName[(FileName.Length >> 1)-1] == (WCHAR)'\\' ) {
        EndsInSlash = TRUE;
        }
    else {
        EndsInSlash = FALSE;
        }

    if ((lpConsoleName = BaseIsThisAConsoleName(&FileName,dwDesiredAccess)) ) {

        Handle = INVALID_HANDLE_VALUE;

        bInheritHandle = FALSE;
        if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
                bInheritHandle = lpSecurityAttributes->bInheritHandle;
            }

        Handle = OpenConsoleW(lpConsoleName->Buffer,
                           dwDesiredAccess,
                           bInheritHandle,
                           FILE_SHARE_READ | FILE_SHARE_WRITE //dwShareMode
                          );

        if ( Handle == INVALID_HANDLE_VALUE ) {
            BaseSetLastNTError(STATUS_ACCESS_DENIED);
            return INVALID_HANDLE_VALUE;
            }
        else {
            SetLastError(0);
             return Handle;
            }
        }
    // end temporary code

    CreateFlags = 0;


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    SQOSFlags = dwFlagsAndAttributes & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT ) {

        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING) {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;

        } else {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY) {

            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;

        } else {

            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = SQOSFlags >> 16;


    } else {

        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    EaBuffer = NULL;
    EaSize = 0;

    if ( ARGUMENT_PRESENT(hTemplateFile) ) {
        Status = NtQueryInformationFile(
                    hTemplateFile,
                    &IoStatusBlock,
                    &EaInfo,
                    sizeof(EaInfo),
                    FileEaInformation
                    );
        if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {
            EaSize = EaInfo.EaSize;
            do {
                EaSize *= 2;
                EaBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
                if ( !EaBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    return INVALID_HANDLE_VALUE;
                    }
                Status = NtQueryEaFile(
                            hTemplateFile,
                            &IoStatusBlock,
                            EaBuffer,
                            EaSize,
                            FALSE,
                            (PVOID)NULL,
                            0,
                            (PULONG)NULL,
                            TRUE
                            );
                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,EaBuffer);
                    EaBuffer = NULL;
                    IoStatusBlock.Information = 0;
                    }
                } while ( Status == STATUS_BUFFER_OVERFLOW ||
                          Status == STATUS_BUFFER_TOO_SMALL );
            EaSize = (ULONG)IoStatusBlock.Information;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT ) {
        CreateFlags |= FILE_OPEN_REPARSE_POINT;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_NO_RECALL ) {
        CreateFlags |= FILE_OPEN_NO_RECALL;
        }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) ) {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
        }
    else {

        //
        // Backup intent was specified... Now look to see if we are to allow
        // directory creation
        //

        if ( (dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY  ) &&
             (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ) &&
             (CreateDisposition == FILE_CREATE) ) {
             CreateFlags |= FILE_DIRECTORY_FILE;
             }
        }

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                EaBuffer,
                EaSize
                );

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            SetLastError(ERROR_FILE_EXISTS);
            }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if ( EndsInSlash ) {
                SetLastError(ERROR_PATH_NOT_FOUND);
                }
            else {
                SetLastError(ERROR_ACCESS_DENIED);
                }
            }
        return INVALID_HANDLE_VALUE;
        }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ){
        SetLastError(ERROR_ALREADY_EXISTS);
        }
    else {
        SetLastError(0);
        }

    //
    // Truncate the file if required
    //

    if ( dwCreationDisposition == TRUNCATE_EXISTING) {

        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &AllocationInfo,
                    sizeof(AllocationInfo),
                    FileAllocationInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            NtClose(Handle);
            Handle = INVALID_HANDLE_VALUE;
            }
        }

    //
    // Deal with hTemplateFile
    //

    return Handle;
}

UINT
GetErrorMode();

HFILE
WINAPI
OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{

    BOOL b;
    FILETIME LastWriteTime;
    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;
    DWORD PathLength;
    LPSTR FilePart;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS Status;
    OFSTRUCT OriginalReOpenBuff;
    BOOL SearchFailed;

    SearchFailed = FALSE;
    OriginalReOpenBuff = *lpReOpenBuff;
    hFile = (HANDLE)-1;
    try {
        SetLastError(0);

        if ( uStyle & OF_PARSE ) {
            PathLength = GetFullPathName(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            lpReOpenBuff->fFixedDisk = 1;
            lpReOpenBuff->nErrCode = 0;
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            hFile = (HANDLE)0;
            goto finally_exit;
            }
        //
        // Compute Desired Access
        //

        if ( uStyle & OF_WRITE ) {
            DesiredAccess = GENERIC_WRITE;
            }
        else {
            DesiredAccess = GENERIC_READ;
            }
        if ( uStyle & OF_READWRITE ) {
            DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
            }

        //
        // Compute ShareMode
        //

        ShareMode = BasepOfShareToWin32Share(uStyle);

        //
        // Compute Create Disposition
        //

        CreateDisposition = OPEN_EXISTING;
        if ( uStyle & OF_CREATE ) {
            CreateDisposition = CREATE_ALWAYS;
            DesiredAccess = (GENERIC_READ | GENERIC_WRITE);
            }

        //
        // if this is anything other than a re-open, fill the re-open buffer
        // with the full pathname for the file
        //

        if ( !(uStyle & OF_REOPEN) ) {
            PathLength = SearchPath(NULL,lpFileName,NULL,OFS_MAXPATHNAME-1,lpReOpenBuff->szPathName,&FilePart);
            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            if ( PathLength == 0 ) {
                SearchFailed = TRUE;
                PathLength = GetFullPathName(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
                if ( !PathLength || PathLength > (OFS_MAXPATHNAME - 1) ) {
                    SetLastError(ERROR_INVALID_DATA);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                }
            }

        //
        // Special case, Delete, Exist, and Parse
        //

        if ( uStyle & OF_EXIST ) {
            if ( !(uStyle & OF_CREATE) ) {
                DWORD FileAttributes;

                if (SearchFailed) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }

                FileAttributes = GetFileAttributesA(lpReOpenBuff->szPathName);
                if ( FileAttributes == 0xffffffff ) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                    SetLastError(ERROR_ACCESS_DENIED);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                else {
                    hFile = (HANDLE)1;
                    lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                    goto finally_exit;
                    }
                }
            }

        if ( uStyle & OF_DELETE ) {
            if ( DeleteFile(lpReOpenBuff->szPathName) ) {
                lpReOpenBuff->nErrCode = 0;
                lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                hFile = (HANDLE)1;
                goto finally_exit;
                }
            else {
                lpReOpenBuff->nErrCode = ERROR_FILE_NOT_FOUND;
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }


        //
        // Open the file
        //

retry_open:
        hFile = CreateFile(
                    lpReOpenBuff->szPathName,
                    DesiredAccess,
                    ShareMode,
                    NULL,
                    CreateDisposition,
                    0,
                    NULL
                    );

        if ( hFile == INVALID_HANDLE_VALUE ) {

            if ( uStyle & OF_PROMPT && !(GetErrorMode() & SEM_NOOPENFILEERRORBOX) ) {
                {
                    DWORD WinErrorStatus;
                    NTSTATUS st,HardErrorStatus;
                    ULONG_PTR ErrorParameter;
                    ULONG ErrorResponse;
                    ANSI_STRING AnsiString;
                    UNICODE_STRING UnicodeString;

                    WinErrorStatus = GetLastError();
                    if ( WinErrorStatus == ERROR_FILE_NOT_FOUND ) {
                        HardErrorStatus = STATUS_NO_SUCH_FILE;
                        }
                    else if ( WinErrorStatus == ERROR_PATH_NOT_FOUND ) {
                        HardErrorStatus = STATUS_OBJECT_PATH_NOT_FOUND;
                        }
                    else {
                        goto finally_exit;
                        }

                    //
                    // Hard error time
                    //

                    RtlInitAnsiString(&AnsiString,lpReOpenBuff->szPathName);
                    st = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
                    if ( !NT_SUCCESS(st) ) {
                        goto finally_exit;
                        }
                    ErrorParameter = (ULONG_PTR)&UnicodeString;

                    HardErrorStatus = NtRaiseHardError(
                                        HardErrorStatus | HARDERROR_OVERRIDE_ERRORMODE,
                                        1,
                                        1,
                                        &ErrorParameter,
                                        OptionRetryCancel,
                                        &ErrorResponse
                                        );
                    RtlFreeUnicodeString(&UnicodeString);
                    if ( NT_SUCCESS(HardErrorStatus) && ErrorResponse == ResponseRetry ) {
                        goto retry_open;
                        }
                    }
                }
            goto finally_exit;
            }

        if ( uStyle & OF_EXIST ) {
            CloseHandle(hFile);
            hFile = (HANDLE)1;
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            goto finally_exit;
            }

        //
        // Determine if this is a hard disk.
        //

        Status = NtQueryVolumeInformationFile(
                    hFile,
                    &IoStatusBlock,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            CloseHandle(hFile);
            BaseSetLastNTError(Status);
            hFile = (HANDLE)-1;
            goto finally_exit;
            }
        switch ( DeviceInfo.DeviceType ) {

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:
                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    lpReOpenBuff->fFixedDisk = 0;
                    }
                else {
                    lpReOpenBuff->fFixedDisk = 1;
                    }
                break;

            default:
                lpReOpenBuff->fFixedDisk = 0;
                break;
            }

        //
        // Capture the last write time and save in the open struct.
        //

        b = GetFileTime(hFile,NULL,NULL,&LastWriteTime);

        if ( !b ) {
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            }
        else {
            b = FileTimeToDosDateTime(
                    &LastWriteTime,
                    &lpReOpenBuff->Reserved1,
                    &lpReOpenBuff->Reserved2
                    );
            if ( !b ) {
                lpReOpenBuff->Reserved1 = 0;
                lpReOpenBuff->Reserved2 = 0;
                }
            }

        lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);

        //
        // The re-open buffer is completely filled in. Now
        // see if we are quitting (parsing), verifying, or
        // just returning with the file opened.
        //

        if ( uStyle & OF_VERIFY ) {
            if ( OriginalReOpenBuff.Reserved1 == lpReOpenBuff->Reserved1 &&
                 OriginalReOpenBuff.Reserved2 == lpReOpenBuff->Reserved2 &&
                 !strcmp(OriginalReOpenBuff.szPathName,lpReOpenBuff->szPathName) ) {
                goto finally_exit;
                }
            else {
                *lpReOpenBuff = OriginalReOpenBuff;
                CloseHandle(hFile);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }
finally_exit:;
        }
    finally {
        lpReOpenBuff->nErrCode = (WORD)GetLastError();
        }
    return (HFILE)HandleToUlong(hFile);
}




typedef DWORD (WINAPI *GETNAMEDSECURITYINFOWPTR)(
    IN  LPCWSTR                pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppsidOwner,
    OUT PSID                 * ppsidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

typedef DWORD (WINAPI *SETNAMEDSECURITYINFOWPTR)(
    IN LPCWSTR               pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOwner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
    );

typedef BOOL (WINAPI *GETSECURITYDESCRIPTORCONTROLPTR)(
    IN  PSECURITY_DESCRIPTOR           pSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL   pControl,
    OUT LPDWORD                        lpdwRevision
    );

BOOL
BasepCopySecurityInformation( LPCWSTR lpExistingFileName,
                              HANDLE SourceFile,
                              ACCESS_MASK SourceFileAccess,
                              LPCWSTR lpNewFileName,
                              HANDLE DestFile,
                              ACCESS_MASK DestFileAccess,
                              SECURITY_INFORMATION SecurityInformation,
                              LPCOPYFILE_CONTEXT Context,
                              DWORD DestFileFsAttributes,
                              PBOOL DeleteDest )

/*++

Routine Description:

    This is an internal routine that copies one or more of the DACL,
    SACL, owner, and group from the source to the dest file.

Arguments:

    lpExistingFileName - Provides the name of the source file.

    SourceFile - Provides a handle to that source file.

    SourceFileAccess - The access flags that were used to open SourceFile.

    lpNewFileName - Provides the name of the destination file.

    DestFile - Provides a handle to that destination file.

    DestFileAccess - The access flags that were used to open DestFile.

    SecurityInformation - Specifies what security should be copied (bit
        flag of the *_SECURITY_INFORMATION defines).

    Context - All the information necessary to call the CopyFile callback routine.

    DestFileFsAttributes - Provides the FILE_FS_ATTRIBUTE_INFORMATION.FileSystemAttributes
        for the dest file's volume.

    DeleteDest - Contains a pointer to a value that will be set to TRUE if this the dest
        file should be deleted.  This is the case if there is an error or the user
        cancels the operation.  If the user stops the operation, this routine still
        returns an error, but the dest file is not deleted.


Return Value:

    TRUE - The operation was successful.

    FALSE- The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOLEAN Succeeded = FALSE;

    PACL Dacl = NULL;
    PACL Sacl = NULL;
    PSID Owner = NULL;
    PSID Group = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    DWORD dwError = 0;

    HANDLE Advapi32 = NULL;
    GETNAMEDSECURITYINFOWPTR GetNamedSecurityInfoWPtr = NULL;
    SETNAMEDSECURITYINFOWPTR SetNamedSecurityInfoWPtr = NULL;
    GETSECURITYDESCRIPTORCONTROLPTR GetSecurityDescriptorControlPtr = NULL;

    SECURITY_DESCRIPTOR_CONTROL Control = 0;
    DWORD dwRevision = 0;

    // If the source file isn't identified, there's nothing we can do.

    if( lpExistingFileName == NULL || lpNewFileName == NULL ) {
        Succeeded = TRUE;
        goto Exit;
    }

    // If the destination doesn't support ACLs, assume it doesn't
    // support any such security information (i.e. owner/group).

    if( !(FILE_PERSISTENT_ACLS & DestFileFsAttributes ) ) {

        if( BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                   ERROR_NOT_SUPPORTED,
                                   Context,
                                   NULL,
                                   PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED,
                                   SourceFile,
                                   DestFile,
                                   DeleteDest )) {
            // The caller wants to coninue on despite this.
            Succeeded = TRUE;
        }

        goto Exit;
    }

    // Check that DACL is copy-able if necessary

    if( SecurityInformation & DACL_SECURITY_INFORMATION ) {

        // We're supposed to copy the DACL.  Do we have enough access?
        if( !( SourceFileAccess & GENERIC_READ ) ||
            !( DestFileAccess & WRITE_DAC ) ) {

            SecurityInformation &= ~DACL_SECURITY_INFORMATION;

            if( !BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                        ERROR_ACCESS_DENIED,
                                        Context,
                                        NULL,
                                        PRIVCALLBACK_DACL_ACCESS_DENIED,
                                        SourceFile,
                                        DestFile,
                                        DeleteDest )) {
                goto Exit;
            }


        }
    }

    // Check that owner & group is copy-able if necessary

    if( (SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ) {

        // We're supposed to copy owner & group.  Do we have enough access?

        if( !( SourceFileAccess & GENERIC_READ ) ||
            !( DestFileAccess & WRITE_OWNER ) ) {

            SecurityInformation &= ~(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION);

            if( !BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                        ERROR_ACCESS_DENIED,
                                        Context,
                                        NULL,
                                        PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED,
                                        SourceFile,
                                        DestFile,
                                        DeleteDest )) {
                goto Exit;
            }


        }
    }

    // Check that SACL is copy-able if necessary

    if( SecurityInformation & SACL_SECURITY_INFORMATION ) {

        // We're supposed to copy the SACL.  Do we have enough rights?

        if( !(SourceFileAccess & ACCESS_SYSTEM_SECURITY) ||
            !(DestFileAccess & ACCESS_SYSTEM_SECURITY) ) {

            SecurityInformation &= ~SACL_SECURITY_INFORMATION;

            if( !BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                        ERROR_PRIVILEGE_NOT_HELD,
                                        Context,
                                        NULL,
                                        PRIVCALLBACK_SACL_ACCESS_DENIED,
                                        SourceFile,
                                        DestFile,
                                        DeleteDest )) {
                goto Exit;
            }

        }
    }

    // If nothing was copyable (and all was ignorable), then we're done.

    if( SecurityInformation == 0 ) {
        Succeeded = TRUE;
        goto Exit;
    }

    // Get the advapi32 APIs.

    Advapi32 = LoadLibraryW(AdvapiDllString);
    if( NULL == Advapi32 ) {
        *DeleteDest = TRUE;
        goto Exit;
    }

    
    GetNamedSecurityInfoWPtr     = (GETNAMEDSECURITYINFOWPTR) GetProcAddress( Advapi32,
                                                                              "GetNamedSecurityInfoW" );
    SetNamedSecurityInfoWPtr     = (SETNAMEDSECURITYINFOWPTR) GetProcAddress( Advapi32,
                                                                              "SetNamedSecurityInfoW" );

    GetSecurityDescriptorControlPtr = (GETSECURITYDESCRIPTORCONTROLPTR) GetProcAddress( Advapi32,
        "GetSecurityDescriptorControl" );

    if( GetNamedSecurityInfoWPtr == NULL ||
        GetSecurityDescriptorControlPtr == NULL ||
        SetNamedSecurityInfoWPtr == NULL ) {

        SetLastError( ERROR_INVALID_DLL );
        *DeleteDest = TRUE;
        goto Exit;
    }


    // Read in the security information from the source files

    dwError = GetNamedSecurityInfoWPtr( lpExistingFileName,
                                        SE_FILE_OBJECT,
                                        SecurityInformation,
                                        &Owner,
                                        &Group,
                                        &Dacl,
                                        &Sacl,
                                        &SecurityDescriptor );
    if( dwError != ERROR_SUCCESS ) {
        SetLastError( dwError );
        *DeleteDest = TRUE;
        goto Exit;
    }


    // We may have requested a DACL or SACL from a file that didn't have one.  If so,
    // don't try to set it (because it will cause a parameter error).

    if( Dacl == NULL ) {
        SecurityInformation &= ~DACL_SECURITY_INFORMATION;
    }
    if( Sacl == NULL ) {
        SecurityInformation &= ~SACL_SECURITY_INFORMATION;
    }

    if (SecurityInformation & (DACL_SECURITY_INFORMATION |
                               SACL_SECURITY_INFORMATION)) {
    
        if ( !GetSecurityDescriptorControlPtr( SecurityDescriptor, &Control, &dwRevision )) {
            // GetSecurityDescriptorControl calls BaseSetLastNTError on error
            *DeleteDest = TRUE;
            goto Exit;
        }
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        if (Control & SE_DACL_PROTECTED) {
            SecurityInformation |= PROTECTED_DACL_SECURITY_INFORMATION;
        } else {
            SecurityInformation |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        }
    }
    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        if (Control & SE_SACL_PROTECTED) {
            SecurityInformation |= PROTECTED_SACL_SECURITY_INFORMATION;
        } else {
            SecurityInformation |= UNPROTECTED_SACL_SECURITY_INFORMATION;
        }
    }

    // Set the security on the dest file.  This loops because it may
    // have to back off on what it requests.

    while( TRUE && SecurityInformation != 0 ) {


        dwError = SetNamedSecurityInfoWPtr( lpNewFileName,
                                            SE_FILE_OBJECT,
                                            SecurityInformation,
                                            Owner,
                                            Group,
                                            Dacl,
                                            Sacl );

        // Even if we have WRITE_OWNER access, the SID we're setting might not
        // be valid.  If so, see if we can retry without them.

        if( dwError == ERROR_SUCCESS ) {
            break;
        } else {

            if( SecurityInformation & (OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION) ) {

                if( !BasepCopyFileCallback( TRUE,   // Continue by default
                                            dwError,
                                            Context,
                                            NULL,
                                            PRIVCALLBACK_OWNER_GROUP_FAILED,
                                            SourceFile,
                                            DestFile,
                                            DeleteDest )) {
                    goto Exit;
                }

                // It's OK to ignore the owner/group.  Try again with them turned off.
                SecurityInformation &= ~(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION);

            } else {

                // Samba 2.x says that it supports ACLs, but returns not-supported.
                if( !BasepCopyFileCallback( TRUE,   // Continue by default
                                            dwError,
                                            Context,
                                            NULL,
                                            PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED,
                                            SourceFile,
                                            DestFile,
                                            DeleteDest )) {
                    goto Exit;
                }

                SecurityInformation = 0;
            }

        }
    }   // while( TRUE && SecurityInformation != 0 )

    Succeeded = TRUE;

Exit:

    if( SecurityDescriptor != NULL ) {
        LocalFree( SecurityDescriptor );
    }

    if( Advapi32 != NULL ) {
        FreeLibrary( Advapi32 );
    }

    return( Succeeded );
}



BOOL
BasepCopyFileCallback( BOOL ContinueByDefault,
                       DWORD Win32ErrorOnStopOrCancel,
                       LPCOPYFILE_CONTEXT Context,
                       PLARGE_INTEGER StreamBytesCopied OPTIONAL,
                       DWORD CallbackReason,
                       HANDLE SourceFile,
                       HANDLE DestFile,
                       OPTIONAL PBOOL Canceled )
/*++

Routine Description:

    During CopyFile, call the CopyFileProgressCallback routine.

Arguments:

    ContinueByDefault - Value to use as the return code of this
        function if there is no callback function or the callback
        returns PROGRESS_REASON_NOT_HANDLED.

    Win32ErrorOnStopOrCancel - If the callback returns PROGRESS_STOP
        or PROGRESS_CANCEL set this as the last error.

    Context - Structure with the information necessary to call
        the callback.

    StreamBytesCopied - If provided, passed to the callback.  If not
        provided, zero is passed.

    CallbackReason - Passed to the callback as the dwReasonCode.

    SourceFile - The source of the CopyFile.

    DestFile - The destination of the CopyFile.

    Canceled - Pointer to a bool that on return indicates that the copy operation
                has been canceled by the user.

Return Value:

    TRUE - The CopyFile should continue.

    FALSE - The CopyFile should be aborted.  The last error will be set
        before this routine returns.

--*/

{ // BasepCopyFileCallback

    PLARGE_INTEGER StreamBytes;
    LARGE_INTEGER Zero;
    DWORD ReturnCode;
    BOOL Continue = ContinueByDefault;

    // If there's no callback context or it's been quieted, then
    // there's nothing to do.

    if( Context == NULL || Context->lpProgressRoutine == NULL )
        return( Continue );

    // If the caller didn't provide a StreamBytesCopied, use zero.

    if( StreamBytesCopied == NULL ) {
        StreamBytes = &Zero;
        StreamBytes->QuadPart = 0;
    } else {
        StreamBytes = StreamBytesCopied;
    }

    // Call the callback

    ReturnCode = Context->lpProgressRoutine(
                    Context->TotalFileSize,
                    Context->TotalBytesTransferred,
                    Context->TotalFileSize,
                    *StreamBytes,
                    Context->dwStreamNumber,
                    CallbackReason,
                    SourceFile,
                    DestFile,
                    Context->lpData
                    );

    if( Canceled ) {
        *Canceled = FALSE;
    }

    switch( ReturnCode )
    {
    case PROGRESS_QUIET:
        Context->lpProgressRoutine = NULL;
        Continue = TRUE;
        break;

    case PROGRESS_CANCEL:
        if( Canceled ) {
            *Canceled = TRUE;
        }
        // Fall through

    case PROGRESS_STOP:
        SetLastError( Win32ErrorOnStopOrCancel );
        Continue = FALSE;
        break;

    case PROGRESS_CONTINUE:
        Continue = TRUE;
        break;

    case PRIVPROGRESS_REASON_NOT_HANDLED:
    default:

        if( !Continue ) {
            SetLastError( Win32ErrorOnStopOrCancel );
        }
        break;
    }

    return( Continue );

}





BOOL
WINAPI
ReplaceFileA(
    LPCSTR  lpReplacedFileName,
    LPCSTR  lpReplacementFileName,
    LPCSTR  lpBackupFileName OPTIONAL,
    DWORD   dwReplaceFlags,
    LPVOID  lpExclude,
    LPVOID  lpReserved
    )

/*++

Routine Description:

    ANSI thunk to ReplaceFileW

--*/

{
    UNICODE_STRING DynamicUnicodeReplaced;
    UNICODE_STRING DynamicUnicodeReplacement;
    UNICODE_STRING DynamicUnicodeBackup;
    BOOL b = FALSE;

    //
    // Parameter validation.
    //

    if(NULL == lpReplacedFileName || NULL == lpReplacementFileName ||
       NULL != lpExclude || NULL != lpReserved ||
       dwReplaceFlags & ~(REPLACEFILE_WRITE_THROUGH | REPLACEFILE_IGNORE_MERGE_ERRORS)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicodeReplaced, lpReplacedFileName )) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicodeReplacement, lpReplacementFileName )) {
        goto end1;
    }

    if (lpBackupFileName) {
        if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicodeBackup, lpBackupFileName )) {
            goto end2;
        }
    } else {
        DynamicUnicodeBackup.Buffer = NULL;
    }

    b = ReplaceFileW(DynamicUnicodeReplaced.Buffer,
                     DynamicUnicodeReplacement.Buffer,
                     DynamicUnicodeBackup.Buffer,
                     dwReplaceFlags,
                     lpExclude,
                     lpReserved);

    if(lpBackupFileName) {
        RtlFreeUnicodeString(&DynamicUnicodeBackup);
    }

end2:
    RtlFreeUnicodeString(&DynamicUnicodeReplacement);
end1:
    RtlFreeUnicodeString(&DynamicUnicodeReplaced);

    return b;
}

BOOL
WINAPI
ReplaceFileW(
    LPCWSTR lpReplacedFileName,
    LPCWSTR lpReplacementFileName,
    LPCWSTR lpBackupFileName OPTIONAL,
    DWORD   dwReplaceFlags,
    LPVOID  lpExclude,
    LPVOID  lpReserved
    )

/*++

Routine Description:

    Replace a file with a new file. The original file's attributes, alternate
    data streams, oid, acl, compression/encryption are transfered to the new
    file. If a backup file name is supplied, the original file is left at the
    backup file specified. Object ID, Create time/date, and file shortnames are
    tunneled by the system.

Arguments:

    lpReplacementFileName - name of the new file.

    lpReplacedFileName - name of the file to be replaced.

    lpBackupFileName - optional. If not NULL, the original file can be found
        under this name.

    dwReplaceFlags - specifies how the file is to be replaced. Currently, the
        possible values are:
        REPLACEFILE_WRITE_THROUGH   Setting this flag guarantees that any
                                    tunneled information is flushed to disk
                                    before the function returns.
        REPLACEFILE_IGNORE_MERGE_ERRORS Setting this flag lets the routine
                                        continue on with the operation even
                                        when merge error occurs. If this flag
                                        is set, GetLastError will not return
                                        ERROR_UNABLE_TO_MERGE_DATA.

    lpExclude - Reserved for future use. Must be set to NULL.

    lpReserved - for future use. Must be set to NULL.

Return Value:

    TRUE - The operation was successful.
    FALSE - The operation failed. Extended error status is available
        using GetLastError.

Error Code:

    ERROR_UNABLE_TO_REMOVE_REPLACED     The replacement file has inherited the
                                        replaced file's attributes and streams.
                                        the replaced file is unchanged. Both
                                        files still exist under their original
                                        names. No backup file exists.

    ERROR_UNABLE_TO_MOVE_REPLACEMENT    Same as above. Except that backup file
                                        exists if requested.

    ERROR_UNABLE_TO_MOVE_REPLACEMENT_2  The replacement file has inherited the
                                        replaced file's attributes and streams.
                                        It's still under its original name.
                                        Replaced file exists under the name of
                                        the backup file.

    All other error codes               Both replacement file and replaced file
                                        exist under their original names. The
                                        replacement file may have inherited
                                        none of, or part of, or all of the
                                        replaced file's attributes and streams.
                                        No backup file exists.

--*/

{
    HANDLE                          advapi32LibHandle = INVALID_HANDLE_VALUE;
    ENCRYPTFILEWPTR                 EncryptFileWPtr = NULL;
    DECRYPTFILEWPTR                 DecryptFileWPtr = NULL;
    HANDLE                          ReplacedFile = INVALID_HANDLE_VALUE;
    HANDLE                          ReplacementFile = INVALID_HANDLE_VALUE;
    HANDLE                          StreamHandle = INVALID_HANDLE_VALUE;
    HANDLE                          OutputStreamHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING                  ReplacedFileNTName;
    UNICODE_STRING                  ReplacementFileNTName;
    UNICODE_STRING                  StreamNTName;
    UNICODE_STRING                  BackupNTFileName;
    RTL_RELATIVE_NAME               ReplacedRelativeName;
    RTL_RELATIVE_NAME               ReplacementRelativeName;
    OBJECT_ATTRIBUTES               ReplacedObjAttr;
    OBJECT_ATTRIBUTES               ReplacementObjAttr;
    OBJECT_ATTRIBUTES               StreamObjAttr;
    IO_STATUS_BLOCK                 IoStatusBlock;
    NTSTATUS                        status;
    BOOL                            fSuccess = FALSE;
    BOOL                            fDoCopy;
    PVOID                           ReplacedFreeBuffer = NULL;
    PVOID                           ReplacementFreeBuffer = NULL;
    FILE_BASIC_INFORMATION          ReplacedBasicInfo;
    FILE_BASIC_INFORMATION          ReplacementBasicInfo;
    DWORD                           ReplacementFileAccess;
    DWORD                           ReplacedFileAccess;
    FILE_COMPRESSION_INFORMATION    ReplacedCompressionInfo;
    PSECURITY_DESCRIPTOR            ReplacedSecDescPtr = NULL;
    DWORD                           dwSizeNeeded;
    ULONG                           cInfo;
    PFILE_STREAM_INFORMATION        ReplacedStreamInfo = NULL;
    PFILE_STREAM_INFORMATION        ReplacementStreamInfo = NULL;
    PFILE_STREAM_INFORMATION        ScannerStreamInfoReplaced = NULL;
    PFILE_STREAM_INFORMATION        ScannerStreamInfoReplacement = NULL;
    DWORD                           dwCopyFlags = COPY_FILE_FAIL_IF_EXISTS;
    DWORD                           dwCopySize = 0;
    PFILE_RENAME_INFORMATION        BackupReplaceRenameInfo = NULL;
    PFILE_RENAME_INFORMATION        ReplaceRenameInfo = NULL;
    LPCOPYFILE_CONTEXT              context = NULL;
    BOOL                            fQueryReplacedFileFail = FALSE;
    BOOL                            fQueryReplacementFileFail = FALSE;
    BOOL                            fReplacedFileIsEncrypted = FALSE;
    BOOL                            fReplacedFileIsCompressed = FALSE;
    BOOL                            fReplacementFileIsEncrypted = FALSE;
    BOOL                            fReplacementFileIsCompressed = FALSE;
    WCHAR *                         pwszTempBackupFile = NULL;
    DWORD                           DestFileFsAttributes = 0;
    WCHAR                           SavedLastChar;

    struct {
        FILE_FS_ATTRIBUTE_INFORMATION   Info;
        WCHAR                           Buffer[MAX_PATH];
    } ReplacementFsAttrInfoBuffer;

    //
    // Initialization
    //

    RtlInitUnicodeString(&BackupNTFileName, NULL);

    //
    // Parameter validation.
    //

    if(NULL == lpReplacedFileName || NULL == lpReplacementFileName ||
       NULL != lpExclude || NULL != lpReserved ||
       dwReplaceFlags & ~(REPLACEFILE_WRITE_THROUGH | REPLACEFILE_IGNORE_MERGE_ERRORS)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    try {

        //
        // Open the to-be-replaced file
        //

        RtlInitUnicodeString(&ReplacedFileNTName, NULL);
        if(!RtlDosPathNameToNtPathName_U(lpReplacedFileName,
                                         &ReplacedFileNTName,
                                         NULL,
                                         &ReplacedRelativeName)) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            leave;
        }
        ReplacedFreeBuffer = ReplacedFileNTName.Buffer;
        if(ReplacedRelativeName.RelativeName.Length) {
            ReplacedFileNTName = *(PUNICODE_STRING)&ReplacedRelativeName.RelativeName;
        }
        else {
            ReplacedRelativeName.ContainingDirectory = NULL;
        }
        InitializeObjectAttributes(&ReplacedObjAttr,
                                   &ReplacedFileNTName,
                                   OBJ_CASE_INSENSITIVE,
                                   ReplacedRelativeName.ContainingDirectory,
                                   NULL);

        ReplacedFileAccess = GENERIC_READ | DELETE | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY;

        status = NtOpenFile(&ReplacedFile,
                            ReplacedFileAccess,
                            &ReplacedObjAttr,
                            &IoStatusBlock,
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);

        if (!NT_SUCCESS(status)) {
            ReplacedFileAccess &= ~ACCESS_SYSTEM_SECURITY;

            status = NtOpenFile(&ReplacedFile,
                            ReplacedFileAccess,
                            &ReplacedObjAttr,
                            &IoStatusBlock,
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);
        }
        
        if(!NT_SUCCESS(status))
        {
            BaseSetLastNTError(status);
            leave;
        }

        //
        // Open the replacement file
        //

        if(!RtlDosPathNameToNtPathName_U(lpReplacementFileName,
                                         &ReplacementFileNTName,
                                         NULL,
                                         &ReplacementRelativeName)) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            leave;
        }
        ReplacementFreeBuffer = ReplacementFileNTName.Buffer;
        if(ReplacementRelativeName.RelativeName.Length) {
            ReplacementFileNTName = *(PUNICODE_STRING)&ReplacementRelativeName.RelativeName;
        }
        else {
            ReplacementRelativeName.ContainingDirectory = NULL;
        }
        InitializeObjectAttributes(&ReplacementObjAttr,
                                   &ReplacementFileNTName,
                                   OBJ_CASE_INSENSITIVE,
                                   ReplacementRelativeName.ContainingDirectory,
                                   NULL);

        if ((ReplacedFileAccess & ACCESS_SYSTEM_SECURITY)) {
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | DELETE | WRITE_DAC | ACCESS_SYSTEM_SECURITY;

            status = NtOpenFile(&ReplacementFile,
                            ReplacementFileAccess,
                            &ReplacementObjAttr,
                            &IoStatusBlock,
                            0,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);
        }
        else status = STATUS_ACCESS_DENIED;  // force the open

        if (!NT_SUCCESS(status)) {
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | DELETE | WRITE_DAC;
            status = NtOpenFile(&ReplacementFile,
                            ReplacementFileAccess,
                            &ReplacementObjAttr,
                            &IoStatusBlock,
                            0,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if (STATUS_ACCESS_DENIED == status &&


           dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | DELETE | WRITE_DAC;
            status = NtOpenFile(&ReplacementFile,
                                ReplacementFileAccess,
                                &ReplacementObjAttr,
                                &IoStatusBlock,
                                0,
                                FILE_NON_DIRECTORY_FILE |
                                FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if(STATUS_ACCESS_DENIED == status &&
           dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)
        {   // try again without WRITE_DAC access
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | DELETE;
            status = NtOpenFile(&ReplacementFile,
                                ReplacementFileAccess,
                                &ReplacementObjAttr,
                                &IoStatusBlock,
                                0,
                                FILE_NON_DIRECTORY_FILE |
                                FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if(!NT_SUCCESS(status))
        {
            BaseSetLastNTError(status);
            leave;
        }

        //
        // Get the attributes of the to-be-replaced file and set them on the
        // replacement file. FILE_ATTRIBUTE_COMPRESSED and
        // FILE_ATTRIBUTE_ENCRYPTED can be obtained by NtQueryInformationFile,
        // but can't be set by NtSetInformationFile. Compression and
        // encryption will be handled later.
        //

        status = NtQueryInformationFile(ReplacedFile,
                                        &IoStatusBlock,
                                        &ReplacedBasicInfo,
                                        sizeof(ReplacedBasicInfo),
                                        FileBasicInformation);
        if(!NT_SUCCESS(status)) {
            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                BaseSetLastNTError(status);
                leave;
            }
            fQueryReplacedFileFail = TRUE;
        }
        else {
            // don't replace read-only files. See bug 38426
            if ((ReplacedBasicInfo.FileAttributes & FILE_ATTRIBUTE_READONLY)) {
                status = STATUS_ACCESS_DENIED;
                BaseSetLastNTError(status);  // ERROR_ACCESS_DENIED
                leave;
            }

            status = NtQueryInformationFile(ReplacementFile,
                                            &IoStatusBlock,
                                            &ReplacementBasicInfo,
                                            sizeof(ReplacementBasicInfo),
                                            FileBasicInformation);
            if(!NT_SUCCESS(status)) {
                if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                    BaseSetLastNTError(status);
                    leave;
                }
                fQueryReplacementFileFail = TRUE;
            }

            //
            // Creation time is the only time we want to preserve. So zero out
            // all the other times.
            //
            ReplacedBasicInfo.LastAccessTime.QuadPart = 0;
            ReplacedBasicInfo.LastWriteTime.QuadPart = 0;
            ReplacedBasicInfo.ChangeTime.QuadPart = 0;
            status = NtSetInformationFile(ReplacementFile,
                                          &IoStatusBlock,
                                          &ReplacedBasicInfo,
                                          sizeof(ReplacedBasicInfo),
                                          FileBasicInformation);
            if(!NT_SUCCESS(status) &&
               !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                BaseSetLastNTError(status);
                leave;
            }
        }

        //
        // Transfer ACLs from the to-be-replaced file to the replacement file.
        //

        status = NtQueryVolumeInformationFile(ReplacementFile,
                                              &IoStatusBlock,
                                              &ReplacementFsAttrInfoBuffer.Info,
                                              sizeof(ReplacementFsAttrInfoBuffer),
                                              FileFsAttributeInformation);
        if(!NT_SUCCESS(status)) {
            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                BaseSetLastNTError(status);
                leave;
            }
        }
        else
        {
            BOOL Delete = FALSE;
            if( !BasepCopySecurityInformation( lpReplacedFileName,
                                               ReplacedFile,
                                               ReplacedFileAccess,
                                               lpReplacementFileName,
                                               ReplacementFile,
                                               ReplacementFileAccess,
                                               DACL_SECURITY_INFORMATION |
                                               SACL_SECURITY_INFORMATION,
                                               NULL,
                                               ReplacementFsAttrInfoBuffer.Info.FileSystemAttributes,
                                               &Delete )) {
                leave;
    
            }
        }


        //
        // If the to-be-replaced file has alternate data streams, and they do
        // not exist in the replacement file, copy them into the replacement
        // file.
        //

        cInfo = 4096;
        do {
            ReplacedStreamInfo = RtlAllocateHeap(RtlProcessHeap(),
                                                  MAKE_TAG(TMP_TAG),
                                                  cInfo);
            if (!ReplacedStreamInfo) {
                break;
            }
            status = NtQueryInformationFile(ReplacedFile,
                                            &IoStatusBlock,
                                            ReplacedStreamInfo,
                                            cInfo,
                                            FileStreamInformation);
            if (!NT_SUCCESS(status)) {
                RtlFreeHeap(RtlProcessHeap(), 0, ReplacedStreamInfo);
                ReplacedStreamInfo = NULL;
                cInfo *= 2;
            }
        } while(status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL);
        if(NULL == ReplacedStreamInfo) {
            if(status != STATUS_INVALID_PARAMETER &&
               status != STATUS_NOT_IMPLEMENTED) {
                if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }
        }
        else {
            if(!NT_SUCCESS(status)) {
                if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }
            else {
                // The outer loop enumerates streams in the to-be-replaced file.
                ScannerStreamInfoReplaced = ReplacedStreamInfo;
                while(TRUE) {
                    // Skip the default stream.
                    if(ScannerStreamInfoReplaced->StreamNameLength <= sizeof(WCHAR) ||
                        ScannerStreamInfoReplaced->StreamName[1] == ':') {
                        if(0 == ScannerStreamInfoReplaced->NextEntryOffset) {
                            break;
                        }
                        ScannerStreamInfoReplaced = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplaced + ScannerStreamInfoReplaced->NextEntryOffset);
                        continue;
                    }

                    // Query replacement file stream information if we haven't done so.
                    // We wait until now to do this query because we don't want to do
                    // it unless it's absolutely necessary.
                    if(NULL == ReplacementStreamInfo) {
                        cInfo = 4096;
                        do {
                            ReplacementStreamInfo = RtlAllocateHeap(RtlProcessHeap(),
                                                                     MAKE_TAG(TMP_TAG),
                                                             cInfo);
                            if (!ReplacementStreamInfo) {
                                break;
                            }
                            status = NtQueryInformationFile(ReplacementFile,
                                                            &IoStatusBlock,
                                                            ReplacementStreamInfo,
                                                            cInfo - sizeof( WCHAR ),
                                                            FileStreamInformation);
                            if (!NT_SUCCESS(status)) {
                                RtlFreeHeap(RtlProcessHeap(), 0, ReplacementStreamInfo);
                                ReplacementStreamInfo = NULL;
                                cInfo *= 2;
                            }
                        } while(status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL);
                        if(NULL == ReplacementStreamInfo ||
                           !NT_SUCCESS(status)) {
                            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                                BaseSetLastNTError(status);
                                leave;
                            }
                            break;
                        }
                    }

                    // The inner loop enumerates the replacement file streams.
                    ScannerStreamInfoReplacement = ReplacementStreamInfo;
                    fDoCopy = TRUE;
                    while(TRUE) {
                        if(ScannerStreamInfoReplaced->StreamNameLength == ScannerStreamInfoReplacement->StreamNameLength &&
                           _wcsnicmp(ScannerStreamInfoReplaced->StreamName, ScannerStreamInfoReplacement->StreamName, ScannerStreamInfoReplacement->StreamNameLength / sizeof(WCHAR)) == 0) {
                            // The stream already exists in the replacement file.
                            fDoCopy = FALSE;
                            break;
                        }
                        if(0 == ScannerStreamInfoReplacement->NextEntryOffset) {
                            // end of the stream information
                            break;
                        }
                        ScannerStreamInfoReplacement = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplacement + ScannerStreamInfoReplacement->NextEntryOffset);
                    }

                    // We copy the stream if it doesn't exist in the replacement file.
                    if(TRUE == fDoCopy) {
                        StreamNTName.Buffer = &ScannerStreamInfoReplaced->StreamName[0];
                        StreamNTName.Length = (USHORT)ScannerStreamInfoReplaced->StreamNameLength;
                        StreamNTName.MaximumLength = StreamNTName.Length;

                        // Open the stream in the to-be-replaced file.
                        InitializeObjectAttributes(&StreamObjAttr,
                                                   &StreamNTName,
                                                   0,
                                                   ReplacedFile,
                                                   NULL);
                        status = NtOpenFile(&StreamHandle,
                                            SYNCHRONIZE |
                                            GENERIC_READ,
                                            &StreamObjAttr,
                                            &IoStatusBlock,
                                            FILE_SHARE_READ |
                                            FILE_SHARE_WRITE |
                                            FILE_SHARE_DELETE,
                                            FILE_SYNCHRONOUS_IO_NONALERT |
                                            FILE_SEQUENTIAL_ONLY);
                        if(!NT_SUCCESS(status)) {
                            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                                BaseSetLastNTError(status);
                                leave;
                            }

                            if(0 == ScannerStreamInfoReplaced->NextEntryOffset) {
                                break;
                            }

                            ScannerStreamInfoReplaced = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplaced + ScannerStreamInfoReplaced->NextEntryOffset);
                            continue;
                        }

                        // Copy the stream;
                        SavedLastChar = StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )];
                        StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )] = L'\0';
                        OutputStreamHandle = INVALID_HANDLE_VALUE;
                        if(!BaseCopyStream(NULL,
                                           StreamHandle,
                                           SYNCHRONIZE | GENERIC_READ,
                                           StreamNTName.Buffer,
                                           ReplacementFile,
                                           &ScannerStreamInfoReplaced->StreamSize,
                                           &dwCopyFlags,
                                           &OutputStreamHandle,
                                           &dwCopySize,
                                           &context,
                                           NULL,
                                           FALSE,
                                           0,
                                           &DestFileFsAttributes )) {
                            
                            StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )] = SavedLastChar;
                            
                            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                                leave;
                            }
                        }
                        
                        StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )] = SavedLastChar;
                        
                        NtClose(StreamHandle);
                        StreamHandle = INVALID_HANDLE_VALUE;
                        if (INVALID_HANDLE_VALUE != OutputStreamHandle) {
                            NtClose(OutputStreamHandle);
                            OutputStreamHandle = INVALID_HANDLE_VALUE;
                        }
                    } // copy stream

                    if(0 == ScannerStreamInfoReplaced->NextEntryOffset) {
                        break;
                    }

                    ScannerStreamInfoReplaced = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplaced + ScannerStreamInfoReplaced->NextEntryOffset);
                } // outer loop
            }
        }

        //
        // Compression/Encryption.
        //

        // If we successfully read the to-be-replaced file's attributes, we
        // do the necessary compression/encryption. Otherwise we do nothing.
        // If we don't know the replacement files attributes
        // (fQueryReplacementFileFail is TRUE), to be on the safe side, we will
        // try to (un)compress/(un)encrypt it if the to-be-replaced file is
        // (un)compressed/(un)encrypted.
        if(!fQueryReplacedFileFail) {

            fReplacedFileIsEncrypted = ReplacedBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED;
            fReplacedFileIsCompressed = ReplacedBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED;
            if(!fQueryReplacementFileFail) {
                fReplacementFileIsEncrypted = ReplacementBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED;
                fReplacementFileIsCompressed = ReplacementBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED;
            }
            else {
                // If we don't know the file attributes of the replacement
                // file, we'll assume the replacement file has opposite
                // encryption/compression attributes as the replaced file
                // so that encryption/compression operations will be forced
                // on the replacement file.
                fReplacementFileIsEncrypted = !fReplacedFileIsEncrypted;
                fReplacementFileIsCompressed = !fReplacedFileIsCompressed;
            }

            //
            // Encryption.
            //

            // If the to-be-replaced file is encrypted and either the
            // replacement file is encrypted or we don't know it's encryption
            // status, we try to encrypt the replacement file.
            if(fReplacedFileIsEncrypted && !fReplacementFileIsEncrypted) {
                NtClose(ReplacementFile);
                ReplacementFile = INVALID_HANDLE_VALUE;
                // There's no way to encrypt a file based on its handle.  We
                // must use the Win32 API (which calls over to the EFS service).
                advapi32LibHandle = LoadLibraryW(AdvapiDllString);
                if(NULL == advapi32LibHandle) {
                    if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        leave;
                    }
                }
                else {
                    EncryptFileWPtr = (ENCRYPTFILEWPTR)GetProcAddress(advapi32LibHandle, "EncryptFileW");
                    if(NULL == EncryptFileWPtr) {
                        if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                    else {
                        if((EncryptFileWPtr)(lpReplacementFileName)) {
                            // Encryption operation automatically decompresses
                            // compressed files. We need this flag for the
                            // case when the replaced file is encrypted and
                            // the replacement file is compressed. At this
                            // point, the replacement file is encrypted.
                            // Because a file is automatically decompressed
                            // when it's encrypted, we don't want to
                            // decompress it again, otherwise we'll get an
                            // error.
                            fReplacementFileIsCompressed = FALSE;
                        } else if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                }
                status = NtOpenFile(&ReplacementFile,
                                    SYNCHRONIZE |
                                    GENERIC_READ |
                                    GENERIC_WRITE |
                                    WRITE_DAC |
                                    DELETE,
                                    &ReplacementObjAttr,
                                    &IoStatusBlock,
                                    0,
                                    FILE_NON_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_NONALERT);

                if (STATUS_ACCESS_DENIED == status &&

                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE |
                                        WRITE_DAC,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }
                if(STATUS_ACCESS_DENIED == status &&
                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }

                // We leave without attempt to rename the files because we know
                // we can't rename the replacement file without it being opened
                // first.
                if(!NT_SUCCESS(status)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }
            else if(!fReplacedFileIsEncrypted && fReplacementFileIsEncrypted) {
                // If the to-be-replaced file is not encrypted and the
                // replacement file is encrypted, decrypt the replacement file.
                NtClose(ReplacementFile);
                ReplacementFile = INVALID_HANDLE_VALUE;
                advapi32LibHandle = LoadLibraryW(AdvapiDllString);
                if(NULL == advapi32LibHandle) {
                    if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        leave;
                    }
                }
                else {
                    DecryptFileWPtr = (DECRYPTFILEWPTR)GetProcAddress(advapi32LibHandle, "DecryptFileW");
                    if(NULL == DecryptFileWPtr) {
                        if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                    else {
                        if((DecryptFileWPtr)(lpReplacementFileName, 0)) {
                            fReplacementFileIsEncrypted = FALSE;
                        } else if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                }
                status = NtOpenFile(&ReplacementFile,
                                    SYNCHRONIZE |
                                    GENERIC_READ |
                                    GENERIC_WRITE |
                                    WRITE_DAC |
                                    DELETE,
                                    &ReplacementObjAttr,
                                    &IoStatusBlock,
                                    0,
                                    FILE_NON_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_NONALERT);

                if(STATUS_ACCESS_DENIED == status &&
                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE |
                                        WRITE_DAC,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }

                if(STATUS_ACCESS_DENIED == status &&
                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }

                // We leave without attempt to rename the files because we know
                // we can't rename the replacement file without it being opened
                // first.
                if(!NT_SUCCESS(status)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }

            //
            // Compression.
            //

            // If the to-be-replaced file is compressed, and the replacement
            // file is not, we compress the replacement file. In the case that
            // we don't know if the replacement file is compressed or not
            // (fQueryReplacementFileFail is TRUE), we will
            // try to compress it anyway and ignore the error if it's already
            // compressed.
            if(fReplacedFileIsCompressed && !fReplacementFileIsCompressed) {
                // Get the compression method mode.
                status = NtQueryInformationFile(ReplacedFile,
                                                &IoStatusBlock,
                                                &ReplacedCompressionInfo,
                                                sizeof(FILE_COMPRESSION_INFORMATION),
                                                FileCompressionInformation);
                if(!NT_SUCCESS(status)) {
                    // We couldn't get the compression method code. if the
                    // ignore merge error flag is on, we continue on to
                    // encryption. Otherwise, we set last error and leave.
                    if(!fQueryReplacementFileFail &&
                       !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        BaseSetLastNTError(status);
                        leave;
                    }
                }
                else {
                    // Do the compression. If we fail and ignore failure flag
                    // is not on, set error and leave. Otherwise continue on
                    // to encryption.
                    status = NtFsControlFile(ReplacementFile,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &IoStatusBlock,
                                             FSCTL_SET_COMPRESSION,
                                             &ReplacedCompressionInfo.CompressionFormat,
                                             sizeof(ReplacedCompressionInfo.CompressionFormat),
                                             NULL,
                                             0);
                    if(!fQueryReplacementFileFail && !NT_SUCCESS(status) &&
                       !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            BaseSetLastNTError(status);
                            leave;
                    }
                }
            }
            else if(!fReplacedFileIsCompressed && fReplacementFileIsCompressed && !fReplacementFileIsEncrypted) {
                // The replaced file is not compressed, the replacement file
                // is compressed (or that the query information for replacement
                // file failed and we don't know if it's compressed or not),
                // decompress the replacement file.
                USHORT      CompressionFormat = 0;
                status = NtFsControlFile(ReplacementFile,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         FSCTL_SET_COMPRESSION,
                                         &CompressionFormat,
                                         sizeof(CompressionFormat),
                                         NULL,
                                         0);
                if(!fQueryReplacementFileFail && !NT_SUCCESS(status) &&
                   !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        BaseSetLastNTError(status);
                        leave;
                }
            }
        } // if querying replaced file attribute failed.

        //
        // Do the renames.
        //

        if (NULL == lpBackupFileName) {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            DWORD  dwCounter = 0;
            DWORD  dwReplacedFileLength = lstrlenW(lpReplacedFileName) * 
                                          sizeof(WCHAR);
            WCHAR  wcsSuffix [16];

            pwszTempBackupFile = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG(TMP_TAG),
                                    dwReplacedFileLength + sizeof(wcsSuffix));

            if(NULL == pwszTempBackupFile) {
                SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
                leave;
            }

            while (hFile == INVALID_HANDLE_VALUE && dwCounter < 16) {
                swprintf (wcsSuffix, L"~RF%4x.TMP", dwCounter + GetTickCount());
                lstrcpyW (pwszTempBackupFile, lpReplacedFileName);
                lstrcatW (pwszTempBackupFile, wcsSuffix);

                hFile = CreateFileW ( pwszTempBackupFile,
                          GENERIC_WRITE | DELETE, // file access
                          0,             // share mode
                          NULL,          // SD
                          CREATE_NEW,    // how to create
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY,
                          NULL);         // handle to template file

                dwCounter++;
            }

            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle (hFile);         // immediately close temp file
            } else {
                SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
                leave;
            }

        }
        else {
            pwszTempBackupFile = (WCHAR *) lpBackupFileName;
        }

        // If backup file requested, rename the to-be-replaced file to backup.
        // Otherwise delete it.

        if(!RtlDosPathNameToNtPathName_U(pwszTempBackupFile,
                                             &BackupNTFileName,
                                             NULL,
                                             NULL)) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            leave;
        }

        BackupReplaceRenameInfo = RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG(TMP_TAG),
                                              BackupNTFileName.Length +
                                              sizeof(*BackupReplaceRenameInfo));
        if(NULL == BackupReplaceRenameInfo)
        {
            SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
            leave;
        }
        BackupReplaceRenameInfo->ReplaceIfExists = TRUE;
        BackupReplaceRenameInfo->RootDirectory = NULL;
        BackupReplaceRenameInfo->FileNameLength = BackupNTFileName.Length;
        RtlCopyMemory(BackupReplaceRenameInfo->FileName, BackupNTFileName.Buffer, BackupNTFileName.Length);
        status = NtSetInformationFile(ReplacedFile,
                                          &IoStatusBlock,
                                          BackupReplaceRenameInfo,
                                          BackupNTFileName.Length +
                                          sizeof(*BackupReplaceRenameInfo),
                                          FileRenameInformation);
        if(!NT_SUCCESS(status)) {
            SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
            leave;
        }

        // Rename the replacement file to the replaced file.
        ReplaceRenameInfo = RtlAllocateHeap(RtlProcessHeap(),
                                      MAKE_TAG(TMP_TAG),
                                      ReplacedFileNTName.Length +
                                      sizeof(*ReplaceRenameInfo));
        if(NULL == ReplaceRenameInfo)
        {
            SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT);
            leave;
        }
        ReplaceRenameInfo->ReplaceIfExists = TRUE;
        ReplaceRenameInfo->RootDirectory = NULL;
        ReplaceRenameInfo->FileNameLength = ReplacedFileNTName.Length;
        RtlCopyMemory(ReplaceRenameInfo->FileName, ReplacedFileNTName.Buffer, ReplacedFileNTName.Length);
        status = NtSetInformationFile(ReplacementFile,
                                      &IoStatusBlock,
                                      ReplaceRenameInfo,
                                      ReplacedFileNTName.Length +
                                      sizeof(*ReplaceRenameInfo),
                                      FileRenameInformation);
        if(!NT_SUCCESS(status)) {
            // If we failed to rename the replacement file, and a backup file
            // for the original file exists, we try to restore the original
            // file from the backup file.
            if(lpBackupFileName) {
                status = NtSetInformationFile(ReplacedFile,
                                              &IoStatusBlock,
                                              ReplaceRenameInfo,
                                              ReplacedFileNTName.Length +
                                              sizeof(*ReplaceRenameInfo),
                                              FileRenameInformation);
                if(!NT_SUCCESS(status)) {
                    SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT_2);
                }
                else {
                    SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT);
                }
                leave;
            }
            else {
                SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT);
                leave;
            }
        }

        //
        // All is well. We set the return code to TRUE. And flush the files if
        // necessary.
        //

        if(dwReplaceFlags & REPLACEFILE_WRITE_THROUGH) {
            NtFlushBuffersFile(ReplacedFile, &IoStatusBlock);
        }

        fSuccess = TRUE;

    } finally {

        if(INVALID_HANDLE_VALUE != advapi32LibHandle && NULL != advapi32LibHandle) {
            FreeLibrary(advapi32LibHandle);
        }

        if(INVALID_HANDLE_VALUE != ReplacedFile) {
            NtClose(ReplacedFile);
        }
        if(INVALID_HANDLE_VALUE != ReplacementFile) {
            NtClose(ReplacementFile);
        }
        if(INVALID_HANDLE_VALUE != StreamHandle) {
            NtClose(StreamHandle);
        }
        if(INVALID_HANDLE_VALUE != OutputStreamHandle) {
            NtClose(OutputStreamHandle);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, ReplacedFreeBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0, ReplacementFreeBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0, BackupNTFileName.Buffer);

        RtlFreeHeap(RtlProcessHeap(), 0, ReplacedStreamInfo);
        RtlFreeHeap(RtlProcessHeap(), 0, ReplacementStreamInfo);
        RtlFreeHeap(RtlProcessHeap(), 0, ReplaceRenameInfo);
        RtlFreeHeap(RtlProcessHeap(), 0, BackupReplaceRenameInfo);

        if (pwszTempBackupFile != NULL && 
            pwszTempBackupFile != lpBackupFileName) {
            DeleteFileW (pwszTempBackupFile);
            RtlFreeHeap(RtlProcessHeap(), 0, pwszTempBackupFile);
        }

    }

Exit:

    return fSuccess;
}


VOID
BaseMarkFileForDelete(
    HANDLE File,
    DWORD FileAttributes
    )

/*++

Routine Description:

    This routine marks a file for delete, so that when the supplied handle
    is closed, the file will actually be deleted.

Arguments:

    File - Supplies a handle to the file that is to be marked for delete.

    FileAttributes - Attributes for the file, if known.  Zero indicates they
        are unknown.

Return Value:

    None.

--*/

{
    #undef DeleteFile

    FILE_DISPOSITION_INFORMATION DispositionInformation;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION BasicInformation;

    if (!FileAttributes) {
        BasicInformation.FileAttributes = 0;
        NtQueryInformationFile(
            File,
            &IoStatus,
            &BasicInformation,
            sizeof(BasicInformation),
            FileBasicInformation
            );
        FileAttributes = BasicInformation.FileAttributes;
        }

    if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
        RtlZeroMemory(&BasicInformation, sizeof(BasicInformation));
        BasicInformation.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        NtSetInformationFile(
            File,
            &IoStatus,
            &BasicInformation,
            sizeof(BasicInformation),
            FileBasicInformation
            );
        }

    DispositionInformation.DeleteFile = TRUE;
    NtSetInformationFile(
        File,
        &IoStatus,
        &DispositionInformation,
        sizeof(DispositionInformation),
        FileDispositionInformation
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\job.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    job.c

Abstract:

    Support for the Job Object

Author:

    Mark Lucovsky (markl) 12-Jun-1997

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

HANDLE
WINAPI
CreateJobObjectA(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCSTR lpName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateJobObjectW(
                lpJobAttributes,
                NameBuffer
                );
}

HANDLE
WINAPI
CreateJobObjectW(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCWSTR lpName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = BaseFormatObjectAttributes(&Obja,lpJobAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpJobAttributes,NULL);
        }

    Status = NtCreateJobObject(
                &Handle,
                JOB_OBJECT_ALL_ACCESS,
                pObja
                );
    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
WINAPI
OpenJobObjectA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenJobObjectW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
WINAPI
OpenJobObjectW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenJobObject(
                &Object,
                dwDesiredAccess,
                &Obja
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
WINAPI
AssignProcessToJobObject(
    HANDLE hJob,
    HANDLE hProcess
    )
{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtAssignProcessToJobObject(hJob,hProcess);
    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    return rv;
}

BOOL
WINAPI
TerminateJobObject(
    HANDLE hJob,
    UINT uExitCode
    )
{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtTerminateJobObject(hJob,uExitCode);
    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    return rv;
}

BOOL
WINAPI
QueryInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength,
    LPDWORD lpReturnLength
    )
{
    NTSTATUS Status;
    BOOL rv;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo;
    PVOID LimitInfo;

    if ( JobObjectInformationClass == JobObjectBasicLimitInformation ) {
        LimitInfo = &ExtendedLimitInfo;
        if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION) ) {
            BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
            return FALSE;
            }
        }
    else if ( JobObjectInformationClass == JobObjectExtendedLimitInformation ) {
        LimitInfo = &ExtendedLimitInfo;
        if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION) ) {
            BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
            return FALSE;
            }
        }
    else {
        LimitInfo = lpJobObjectInformation;
        }

    rv = TRUE;
    Status = NtQueryInformationJobObject(
                hJob,
                JobObjectInformationClass,
                LimitInfo,
                cbJobObjectInformationLength,
                lpReturnLength
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    else {
        if (LimitInfo == &ExtendedLimitInfo ) {
            switch (ExtendedLimitInfo.BasicLimitInformation.PriorityClass) {
                case PROCESS_PRIORITY_CLASS_IDLE :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = IDLE_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_BELOW_NORMAL:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = BELOW_NORMAL_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_NORMAL :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = NORMAL_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_ABOVE_NORMAL:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = ABOVE_NORMAL_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_HIGH :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = HIGH_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_REALTIME :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = REALTIME_PRIORITY_CLASS;
                    break;
                default:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = NORMAL_PRIORITY_CLASS;

                }
            CopyMemory(lpJobObjectInformation,&ExtendedLimitInfo,cbJobObjectInformationLength);
            }
        }
    return rv;
}

BOOL
WINAPI
SetInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength
    )
{
    NTSTATUS Status;
    BOOL rv;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo;
    PVOID LimitInfo;
    NTSTATUS PrivStatus = STATUS_UNSUCCESSFUL;
    PVOID State;

    rv = TRUE;
    if (JobObjectInformationClass == JobObjectBasicLimitInformation ||
        JobObjectInformationClass == JobObjectExtendedLimitInformation ) {

        if ( JobObjectInformationClass == JobObjectBasicLimitInformation ) {
            if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION) ) {
                BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
                return FALSE;
            }
        } else {
            if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION) ) {
                BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
                return FALSE;
            }
        }

        LimitInfo = &ExtendedLimitInfo;

        CopyMemory(&ExtendedLimitInfo,lpJobObjectInformation,cbJobObjectInformationLength);

        if ( ExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS ) {
            switch (ExtendedLimitInfo.BasicLimitInformation.PriorityClass) {

                case IDLE_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_IDLE;
                    break;
                case BELOW_NORMAL_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_BELOW_NORMAL;
                    break;
                case NORMAL_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
                    break;
                case ABOVE_NORMAL_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_ABOVE_NORMAL;
                    break;
                case HIGH_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_HIGH;
                    break;
                case REALTIME_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_REALTIME;
                    break;
                default:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;

            }
        }
        if (ExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
            //
            // Attempt to acquire the appropriate privilege.  If this
            // fails, it's no big deal -- we'll attempt to make the
            // NtSetInformationProcess call anyway, in case it turns out
            // to be a decrease operation (which will succeed anyway).
            //

            PrivStatus = BasepAcquirePrivilegeEx( SE_INC_BASE_PRIORITY_PRIVILEGE, &State );
        }
    } else {
        LimitInfo = lpJobObjectInformation;
    }

    Status = NtSetInformationJobObject(
                hJob,
                JobObjectInformationClass,
                LimitInfo,
                cbJobObjectInformationLength
                );

    if (NT_SUCCESS(PrivStatus)) {
        //
        // We successfully acquired the privilege above; we need to relinquish it.
        //
        ASSERT (State != NULL);
        BasepReleasePrivilege (State);
        State = NULL;
    }

    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
    }
    return rv;
}

BOOL
WINAPI
IsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle,
    OUT PBOOL Result
    )
/*++

Routine Description:

    This routine finds out if a process is in a specific or any job

Arguments:

    ProcessHandle - Handle to process to be checked
    JobHandle     - Handle of job to check process against, May be NULL to do general query.
    Result        - TRUE if the process is part of the job FALSE otherwise.

Return Value:

    BOOL - TRUE the call was successfull, FALSE the call failed

--*/
{
    NTSTATUS Status;

    Status = NtIsProcessInJob (ProcessHandle,
                               JobHandle);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }
    if (Status == STATUS_PROCESS_NOT_IN_JOB) {
        *Result = FALSE;
    } else {
        *Result = TRUE;
    }
    return TRUE;
}

BOOL
WINAPI
CreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags)
/*++

Routine Description:

    This function creates a job set from multiple job objects.
    
Arguments:

    NumJob     - Number of jobs in JobSet
    UserJobSet - Pointer to array of jobs to combine
    Flags      - Flags mask for future expansion

Return Value:

    BOOL - TRUE the call was successfull, FALSE the call failed

--*/
{
    NTSTATUS Status;

    Status = NtCreateJobSet (NumJob,
                             UserJobSet,
                             Flags);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\handle.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements the Win32 handle management services.

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

#include "basedll.h"

BOOL
CloseHandle(
    HANDLE hObject
    )

/*++

Routine Description:

    An open handle to any object can be closed using CloseHandle.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    Closing an open handle to an object causes the handle to become
    invalid and the HandleCount of the associated object to be
    decremented and object retention checks to be performed.  Once the
    last open handle to an object is closed, the object is removed from
    the system.

Arguments:

    hObject - An open handle to an object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) ) {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
        }
    if (CONSOLE_HANDLE(hObject)) {
        return CloseConsoleHandle(hObject);
        }

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )

/*++

Routine Description:

    A duplicate handle can be created with the DuplicateHandle function.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    This function requires PROCESS_DUP_ACCESS to both the
    SourceProcessHandle and the TargetProcessHandle.  This function is
    used to pass an object handle from one process to another.  Once
    this call is complete, the target process needs to be informed of
    the value of the target handle.  The target process can then operate
    on the object using this handle value.

Arguments:

    hSourceProcessHandle - An open handle to the process that contains the
        handle to be duplicated. The handle must have been created with
        PROCESS_DUP_HANDLE access to the process.

    hSourceHandle - An open handle to any object that is valid in the
        context of the source process.

    hTargetProcessHandle - An open handle to the process that is to
        receive the duplicated handle.  The handle must have been
        created with PROCESS_DUP_HANDLE access to the process.

    lpTargetHandle - A pointer to a variable which receives the new handle
        that points to the same object as SourceHandle does.  This
        handle value is valid in the context of the target process.

    dwDesiredAccess - The access requested to for the new handle.  This
        parameter is ignored if the DUPLICATE_SAME_ACCESS option is
        specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hSourceHandle) ) {
        case STD_INPUT_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hSourceHandle = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hSourceHandle) &&
	(hSourceHandle != NtCurrentProcess() &&
	 hSourceHandle != NtCurrentThread()) ) {
        HANDLE Target;

        if (hSourceProcessHandle != NtCurrentProcess() ||
            hTargetProcessHandle != NtCurrentProcess()) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }
        Target = DuplicateConsoleHandle(hSourceHandle,
                                        dwDesiredAccess,
                                        bInheritHandle,
                                        dwOptions
                                       );
        if (Target == INVALID_HANDLE_VALUE) {
            return FALSE;
            }
        else {
            try {
                if ( ARGUMENT_PRESENT(lpTargetHandle) ) {
                    *lpTargetHandle = Target;
                    }
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            return TRUE;
            }
        }

    Status = NtDuplicateObject(
                hSourceProcessHandle,
                hSourceHandle,
                hTargetProcessHandle,
                lpTargetHandle,
                (ACCESS_MASK)dwDesiredAccess,
                bInheritHandle ? OBJ_INHERIT : 0,
                dwOptions
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return FALSE;
}


BOOL
GetHandleInformation(
    HANDLE hObject,
    LPDWORD lpdwFlags
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;
    DWORD Result;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) ) {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hObject)) {
        return GetConsoleHandleInformation(hObject,
                                           lpdwFlags
                                          );
        }

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        Result = 0;
        if (HandleInfo.Inherit) {
            Result |= HANDLE_FLAG_INHERIT;
            }

        if (HandleInfo.ProtectFromClose) {
            Result |= HANDLE_FLAG_PROTECT_FROM_CLOSE;
            }

        *lpdwFlags = Result;
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}


BOOL
SetHandleInformation(
    HANDLE hObject,
    DWORD dwMask,
    DWORD dwFlags
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) ) {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hObject)) {
        return SetConsoleHandleInformation(hObject,
                                           dwMask,
                                           dwFlags
                                          );
        }

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        if (dwMask & HANDLE_FLAG_INHERIT) {
            HandleInfo.Inherit = (dwFlags & HANDLE_FLAG_INHERIT) ? TRUE : FALSE;
            }

        if (dwMask & HANDLE_FLAG_PROTECT_FROM_CLOSE) {
            HandleInfo.ProtectFromClose = (dwFlags & HANDLE_FLAG_PROTECT_FROM_CLOSE) ? TRUE : FALSE;
            }

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    BaseSetLastNTError( Status );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\lzapi.h ===
/*
** lzapi.h - Private interface to LZEXPand.LIB.
*/

#ifndef _LZPRIVAPI_
#define _LZPRIVAPI_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Prototypes
*/

// For the time being, private APIS exported
INT
LZCreateFileW(
    LPWSTR,
    DWORD,
    DWORD,
    DWORD,
    LPWSTR);

VOID
LZCloseFile(
    INT);


#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\lmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    lmem.c

Abstract:

    This module contains the Win32 Local Memory Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

void
BaseDllInitializeMemoryManager( VOID )
{
    BaseHeap = RtlProcessHeap();
    RtlInitializeHandleTable( 0xFFFF,
                              sizeof( BASE_HANDLE_TABLE_ENTRY ),
                              &BaseHeapHandleTable
                            );
    NtQuerySystemInformation(SystemRangeStartInformation,
                             &SystemRangeStart,
                             sizeof(SystemRangeStart),
                             NULL);
}

#if i386
#pragma optimize("y",off)
#endif

HLOCAL
WINAPI
LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE hMem;
    ULONG Flags;
    LPSTR p;

    if (uFlags & ~LMEM_VALID_FLAGS) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & LMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }

    if (!(uFlags & LMEM_MOVEABLE)) {
        p = RtlAllocateHeap( BaseHeap,
                             MAKE_TAG( LMEM_TAG ) | Flags,
                             uBytes
                           );
        if (p == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }

        return( p );
        }

    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE | HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
    try {
        p = NULL;
        HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &BaseHeapHandleTable, NULL );
        if (HandleEntry == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            goto Fail;
            }

        hMem = (HANDLE)&HandleEntry->Object;
        if (uBytes != 0) {
            p = (LPSTR)RtlAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, uBytes );
            if (p == NULL) {
                HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                HandleEntry = NULL;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            else {
                RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                }
            }
        else {
            p = NULL;
            }
Fail:   ;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        p = NULL;
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (HandleEntry != NULL) {
        if (HandleEntry->Object = p) {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
            }
        else {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED | BASE_HANDLE_DISCARDED;
            }

        if (uFlags & LMEM_DISCARDABLE) {
            HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
            }

        if (uFlags & LMEM_MOVEABLE) {
            HandleEntry->Flags |= BASE_HANDLE_MOVEABLE;
            }

        p = (LPSTR)hMem;
        }

    return( (HANDLE)p );
}


HLOCAL
WINAPI
LocalReAlloc(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;
    ULONG Flags;

    if ((uFlags & ~(LMEM_VALID_FLAGS | LMEM_MODIFY)) ||
        ((uFlags & LMEM_DISCARDABLE) && !(uFlags & LMEM_MODIFY))
       ) {
#if DBG
        DbgPrint( "*** LocalReAlloc( %lx ) - invalid flags\n", uFlags );
        BaseHeapBreakPoint();
#endif
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & LMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }
    if (!(uFlags & LMEM_MOVEABLE)) {
        Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
        }

    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE;
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalReAlloc( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                hMem = NULL;
                }
            else
            if (uFlags & LMEM_MODIFY) {
                if (uFlags & LMEM_DISCARDABLE) {
                    HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
                    }
                else {
                    HandleEntry->Flags &= ~BASE_HANDLE_DISCARDABLE;
                    }
                }
            else {
                p = HandleEntry->Object;
                if (uBytes == 0) {
                    hMem = NULL;
                    if (p != NULL) {
                        if ((uFlags & LMEM_MOVEABLE) && HandleEntry->LockCount == 0) {
                            if (RtlFreeHeap( BaseHeap, Flags | HEAP_NO_SERIALIZE, p )) {
                                HandleEntry->Object = NULL;
                                HandleEntry->Flags |= BASE_HANDLE_DISCARDED;
                                hMem = (HANDLE)&HandleEntry->Object;
                                }
                            }
                        else {
#if DBG
                            DbgPrint( "*** LocalReAlloc( %lx ) - failing with locked handle\n", &HandleEntry->Object );
                            BaseHeapBreakPoint();
#endif
                            }
                        }
                    else {
                        hMem = (HANDLE)&HandleEntry->Object;
                        }
                    }
                else {
                    Flags |= HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
                    if (p == NULL) {
                        p = RtlAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, uBytes );
                        if (p != NULL) {
                            RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                            }
                        }
                    else {
                        if (!(uFlags & LMEM_MOVEABLE) &&
                            HandleEntry->LockCount != 0
                           ) {
                            Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
                            }
                        else {
                            Flags &= ~HEAP_REALLOC_IN_PLACE_ONLY;
                            }

                        p = RtlReAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, p, uBytes );
                        }

                    if (p != NULL) {
                        HandleEntry->Object = p;
                        HandleEntry->Flags &= ~BASE_HANDLE_DISCARDED;
                        }
                    else {
                        hMem = NULL;
                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        }
                    }
                }
            }
        else
        if (!(uFlags & LMEM_MODIFY)) {
            hMem = RtlReAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, (PVOID)hMem, uBytes );
            if (hMem == NULL) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        hMem = NULL;
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( (LPSTR)hMem );
}

PVOID
WINAPI
LocalLock(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );

        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalLock( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
                p = HandleEntry->Object;
                if (p != NULL) {
                    if (HandleEntry->LockCount++ == LMEM_LOCKCOUNT) {
                        HandleEntry->LockCount--;
                        }
                    }
                else {
                    SetLastError( ERROR_DISCARDED );
                    }
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            p = NULL;
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );

        return( p );
        }
    else {
        if ( (ULONG_PTR)hMem >= SystemRangeStart ) {
            return NULL;
            }
        return( (LPSTR)hMem );
        }
}

HLOCAL
WINAPI
LocalHandle(
    LPCVOID pMem
    )
{
    HANDLE Handle;
    ULONG Flags;

    RtlLockHeap( BaseHeap );
    try {
        Handle = NULL;
        if (!RtlGetUserInfoHeap( BaseHeap, HEAP_NO_SERIALIZE, (LPVOID)pMem, &Handle, &Flags )) {
            SetLastError( ERROR_INVALID_HANDLE );
            }
        else
        if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
            Handle = (HANDLE)pMem;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( Handle );
}

BOOL
WINAPI
LocalUnlock(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    BOOL Result;

    Result = FALSE;
    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );
        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalUnlock( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->LockCount-- == 0) {
                HandleEntry->LockCount++;
                SetLastError( ERROR_NOT_LOCKED );
                }
            else
            if (HandleEntry->LockCount != 0) {
                Result = TRUE;
                }
            else {
                SetLastError( NO_ERROR );
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );
        }
    else {
        SetLastError( ERROR_NOT_LOCKED );
        }

    return( Result );
}


SIZE_T
WINAPI
LocalSize(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    PVOID Handle;
    ULONG Flags;
    SIZE_T uSize;

    uSize = MAXULONG_PTR;
    Flags = 0;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                uSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, (PVOID)hMem );
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalSize( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                uSize = HandleEntry->Size;
                }
            else {
                uSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, HandleEntry->Object );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (uSize == MAXULONG_PTR) {
        SetLastError( ERROR_INVALID_HANDLE );
        return 0;
        }
    else {
        return uSize;
        }
}


UINT
WINAPI
LocalFlags(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE Handle;
    ULONG Flags;
    UINT uFlags;

    uFlags = LMEM_INVALID_HANDLE;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            Flags = 0;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                uFlags = 0;
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
                uFlags = HandleEntry->LockCount & LMEM_LOCKCOUNT;
                if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                    uFlags |= LMEM_DISCARDED;
                    }

                if (HandleEntry->Flags & BASE_HANDLE_DISCARDABLE) {
                    uFlags |= LMEM_DISCARDABLE;
                    }
                }
            }

        if (uFlags == LMEM_INVALID_HANDLE) {
#if DBG
            DbgPrint( "*** LocalFlags( %lx ) - invalid handle\n", hMem );
            BaseHeapBreakPoint();
#endif
            SetLastError( ERROR_INVALID_HANDLE );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( uFlags );
}


HLOCAL
WINAPI
LocalFree(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            if (RtlFreeHeap( BaseHeap,
                             0,
                             (PVOID)hMem
                           )
               ) {
                return NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                return hMem;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        return hMem;
        }

    RtlLockHeap( BaseHeap );
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalFree( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
#if DBG
                if (HandleEntry->LockCount != 0) {
                    DbgPrint( "BASE: LocalFree called with a locked object.\n" );
                    BaseHeapBreakPoint();
                    }
#endif
                p = HandleEntry->Object;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                if (p == NULL) {
                    hMem = NULL;
                    }
                }
            }
        else {
            p = (LPSTR)hMem;
            }

        if (p != NULL) {
            if (RtlFreeHeap( BaseHeap, HEAP_NO_SERIALIZE, p )) {
                hMem = NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( hMem );
}


SIZE_T
WINAPI
LocalCompact(
    UINT uMinFree
    )
{
    return RtlCompactHeap( BaseHeap, 0 );
}

SIZE_T
WINAPI
LocalShrink(
    HLOCAL hMem,
    UINT cbNewSize
    )
{
    return RtlCompactHeap( BaseHeap, 0 );
}


HANDLE
WINAPI
HeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    )
{
    HANDLE hHeap;
    ULONG GrowthThreshold;
    ULONG Flags;


    Flags = (flOptions & (HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE)) | HEAP_CLASS_1;
    GrowthThreshold = 0;

    if (dwMaximumSize < BASE_SYSINFO.PageSize) {

        if (dwMaximumSize == 0) {

            GrowthThreshold = BASE_SYSINFO.PageSize * 16;
            Flags |= HEAP_GROWABLE;
            }
        else {
            dwMaximumSize = BASE_SYSINFO.PageSize;
            }
        }

    if (GrowthThreshold == 0 && dwInitialSize > dwMaximumSize) {
        dwMaximumSize = dwInitialSize;
        }

    hHeap = (HANDLE)RtlCreateHeap( Flags,
                                   NULL,
                                   dwMaximumSize,
                                   dwInitialSize,
                                   0,
                                   NULL
                                 );
    if (hHeap == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

    return( hHeap );
}

BOOL
WINAPI
HeapDestroy(
    HANDLE hHeap
    )
{
    if (RtlDestroyHeap( (PVOID)hHeap ) == NULL ) {
        return( TRUE );
        }
    else {
        SetLastError( ERROR_INVALID_HANDLE );
        return( FALSE );
        }
}

BOOL
WINAPI
HeapExtend(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpBase,
    DWORD dwBytes
    )
{
    NTSTATUS Status;

    Status = RtlExtendHeap( hHeap, dwFlags, lpBase, dwBytes );
    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        }
    return FALSE;
}

WINBASEAPI
DWORD
WINAPI
HeapCreateTagsW(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCWSTR lpTagPrefix,
    LPCWSTR lpTagNames
    )
{
    return RtlCreateTagHeap( hHeap, dwFlags, (PWSTR)lpTagPrefix, (PWSTR)lpTagNames );
}

WINBASEAPI
LPCWSTR
WINAPI
HeapQueryTagW(
    HANDLE hHeap,
    DWORD dwFlags,
    WORD wTagIndex,
    BOOL bResetCounters,
    LPHEAP_TAG_INFO TagInfo
    )
{
    ASSERT( sizeof(RTL_HEAP_TAG_INFO) == sizeof(HEAP_TAG_INFO) );
    return RtlQueryTagHeap( hHeap,
                            dwFlags,
                            wTagIndex,
                            (BOOLEAN)bResetCounters,
                            (PRTL_HEAP_TAG_INFO)TagInfo
                          );
}


BOOL
WINAPI
HeapSummary(
    HANDLE hHeap,
    DWORD dwFlags,
    LPHEAP_SUMMARY lpSummary
    )
{
    NTSTATUS Status;
    RTL_HEAP_USAGE HeapInfo;

    if (lpSummary->cb != sizeof( *lpSummary )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    HeapInfo.Length = sizeof( HeapInfo );
    Status = RtlUsageHeap( hHeap,
                           dwFlags & ~(HEAP_USAGE_ALLOCATED_BLOCKS |
                                       HEAP_USAGE_FREE_BUFFER
                                      ),
                           &HeapInfo
                         );
    if (NT_SUCCESS( Status )) {
        lpSummary->cbAllocated = HeapInfo.BytesAllocated;
        lpSummary->cbCommitted = HeapInfo.BytesCommitted;
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}

BOOL
WINAPI
HeapUsage(
    HANDLE hHeap,
    DWORD dwFlags,
    BOOL bFirstCall,
    BOOL bLastCall,
    PHEAP_USAGE lpUsage
    )
{
    NTSTATUS Status;

    if (lpUsage->cb != sizeof( *lpUsage ) || (bFirstCall & bLastCall)) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    dwFlags &= ~(HEAP_USAGE_ALLOCATED_BLOCKS |
                 HEAP_USAGE_FREE_BUFFER
                );

    if (bLastCall) {
        dwFlags |= HEAP_USAGE_FREE_BUFFER;
        }
    else {
        dwFlags |= HEAP_USAGE_ALLOCATED_BLOCKS;
        if (bFirstCall) {
            RtlZeroMemory( (&lpUsage->cb)+1, sizeof( *lpUsage ) - sizeof( lpUsage->cb ) );
            }
        }

    ASSERT( sizeof(RTL_HEAP_USAGE) == sizeof(HEAP_USAGE) );
    Status = RtlUsageHeap( hHeap, dwFlags, (PRTL_HEAP_USAGE)lpUsage );
    if (NT_SUCCESS( Status )) {
        if (Status == STATUS_MORE_ENTRIES) {
            return TRUE;
            }
        else {
            SetLastError( NO_ERROR );
            return FALSE;
            }
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}

BOOL
WINAPI
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    )
{
    return RtlValidateHeap( hHeap, dwFlags, lpMem );
}

HANDLE
WINAPI
GetProcessHeap( VOID )
{
    return RtlProcessHeap();
}


WINBASEAPI
DWORD
WINAPI
GetProcessHeaps(
    DWORD NumberOfHeaps,
    PHANDLE ProcessHeaps
    )
{
    return RtlGetProcessHeaps( NumberOfHeaps, ProcessHeaps );
}


WINBASEAPI
SIZE_T
WINAPI
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    )
{
    return RtlCompactHeap( hHeap, dwFlags );
}


WINBASEAPI
BOOL
WINAPI
HeapLock(
    HANDLE hHeap
    )
{
    return RtlLockHeap( hHeap );
}


WINBASEAPI
BOOL
WINAPI
HeapUnlock(
    HANDLE hHeap
    )
{
    return RtlUnlockHeap( hHeap );
}

WINBASEAPI
BOOL
WINAPI
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    )
{
    RTL_HEAP_WALK_ENTRY Entry;
    NTSTATUS Status;

    if (lpEntry->lpData == NULL) {
        Entry.DataAddress = NULL;
        Status = RtlWalkHeap( hHeap, &Entry );
        }
    else {
        Entry.DataAddress = lpEntry->lpData;
        Entry.SegmentIndex = lpEntry->iRegionIndex;
        if (lpEntry->wFlags & PROCESS_HEAP_REGION) {
            Entry.Flags = RTL_HEAP_SEGMENT;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
            Entry.Flags = RTL_HEAP_UNCOMMITTED_RANGE;
            Entry.DataSize = lpEntry->cbData;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            Entry.Flags = RTL_HEAP_BUSY;
            }
        else {
            Entry.Flags = 0;
            }

        Status = RtlWalkHeap( hHeap, &Entry );
        }

    if (NT_SUCCESS( Status )) {
        lpEntry->lpData = Entry.DataAddress;
        lpEntry->cbData = (DWORD)Entry.DataSize;
        lpEntry->cbOverhead = Entry.OverheadBytes;
        lpEntry->iRegionIndex = Entry.SegmentIndex;
        if (Entry.Flags & RTL_HEAP_BUSY) {
            lpEntry->wFlags = PROCESS_HEAP_ENTRY_BUSY;
            if (Entry.Flags & BASE_HEAP_FLAG_DDESHARE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_DDESHARE;
                }

            if (Entry.Flags & BASE_HEAP_FLAG_MOVEABLE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_MOVEABLE;
                lpEntry->Block.hMem = (HLOCAL)Entry.Block.Settable;
                }

            memset( lpEntry->Block.dwReserved, 0, sizeof( lpEntry->Block.dwReserved ) );
            }
        else
        if (Entry.Flags & RTL_HEAP_SEGMENT) {
            lpEntry->wFlags = PROCESS_HEAP_REGION;
            lpEntry->Region.dwCommittedSize = Entry.Segment.CommittedSize;
            lpEntry->Region.dwUnCommittedSize = Entry.Segment.UnCommittedSize;
            lpEntry->Region.lpFirstBlock = Entry.Segment.FirstEntry;
            lpEntry->Region.lpLastBlock = Entry.Segment.LastEntry;
            }
        else
        if (Entry.Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
            lpEntry->wFlags = PROCESS_HEAP_UNCOMMITTED_RANGE;
            memset( &lpEntry->Region, 0, sizeof( lpEntry->Region ) );
            }
        else {
            lpEntry->wFlags = 0;
            }

        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}

WINBASEAPI
BOOL
WINAPI
HeapSetInformation (
    IN PVOID HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    IN PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL
    )
{
    NTSTATUS Status;

    Status = RtlSetHeapInformation( HeapHandle, 
                                    HeapInformationClass, 
                                    HeapInformation, 
                                    HeapInformationLength );
    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        }
    return FALSE;
}

WINBASEAPI
BOOL
WINAPI
HeapQueryInformation (
    IN PVOID HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    OUT PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL,
    OUT PSIZE_T ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;

    Status = RtlQueryHeapInformation( HeapHandle, 
                                      HeapInformationClass, 
                                      HeapInformation, 
                                      HeapInformationLength,
                                      ReturnLength );
    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        }
    return FALSE;
}

#if DBG
VOID
BaseHeapBreakPoint( VOID )
{
    if (NtCurrentPeb()->BeingDebugged)
        {
#if i386
        _asm {  int 3 }
#else
        DbgBreakPoint();
#endif
        }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\mailslot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    This module contains the Win32 Mailslot API

Author:

    Manny Weiser (mannyw) 4-Mar-1991

Revision History:

--*/

#include "basedll.h"

HANDLE
APIENTRY
CreateMailslotW(
    IN LPCWSTR lpName,
    IN DWORD nMaxMessageSize,
    IN DWORD lReadTimeout,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes OPTIONAL
    )

/*++

Routine Description:

    The create mailslot API creates a local mailslot and return a
    server-side handle to the mailslot.

Arguments:

    lpName - The name of the mailslot.  This must be a local mailslot
        name.

    nMaxMessageSize - The size (in bytes) of the largest message that
        can be written to the mailslot.

    lReadTimeout - The initial read timeout, in milliseconds.  This
        is the amount of time a read operation will block waiting for
        a message to be written to the mailslot.  This value can be
        changed with the SetMailslotInfo API.

    lpSecurityAttributes - An optional pointer to security information
        for this mailslot.

Return Value:

    Returns one of the following:

    0xFFFFFFFF --An error occurred.  Call GetLastError for more
    information.

    Anything else --Returns a handle for use in the server side of
    subsequent mailslot operations.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING fileName;
    LPWSTR filePart;
    RTL_RELATIVE_NAME relativeName;
    IO_STATUS_BLOCK ioStatusBlock;
    LARGE_INTEGER readTimeout;
    HANDLE handle;
    NTSTATUS status;
    PVOID freeBuffer;
    BOOLEAN TranslationStatus;

    RtlInitUnicodeString( &fileName, lpName );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpName,
                            &fileName,
                            &filePart,
                            &relativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }

    freeBuffer = fileName.Buffer;

    if ( relativeName.RelativeName.Length ) {
        fileName = *(PUNICODE_STRING)&relativeName.RelativeName;
    } else {
        relativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        &fileName,
        OBJ_CASE_INSENSITIVE,
        relativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        objectAttributes.SecurityDescriptor =
            lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            objectAttributes.Attributes |= OBJ_INHERIT;
        }
    }

    if (lReadTimeout == MAILSLOT_WAIT_FOREVER) {
        readTimeout.HighPart = 0xFFFFFFFF;
        readTimeout.LowPart = 0xFFFFFFFF;
    } else {
        readTimeout.QuadPart = - (LONGLONG)UInt32x32To64( lReadTimeout, 10 * 1000 );
    }

    status = NtCreateMailslotFile (
                &handle,
                GENERIC_READ | SYNCHRONIZE | WRITE_DAC,
                &objectAttributes,
                &ioStatusBlock,
                FILE_CREATE,
                0,
                nMaxMessageSize,
                (PLARGE_INTEGER)&readTimeout
                );

    if ( status == STATUS_NOT_SUPPORTED ||
         status == STATUS_INVALID_DEVICE_REQUEST ) {

        //
        // The request must have been processed by some other device driver
        // (other than MSFS).  Map the error to something reasonable.
        //

        status = STATUS_OBJECT_NAME_INVALID;
    }

    RtlFreeHeap( RtlProcessHeap(), 0, freeBuffer );

    if (!NT_SUCCESS(status)) {
        BaseSetLastNTError( status );
        return INVALID_HANDLE_VALUE;
    }

    return handle;
}


HANDLE
APIENTRY
CreateMailslotA(
    IN LPCSTR lpName,
    IN DWORD nMaxMessageSize,
    IN DWORD lReadTimeout,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes OPTIONAL
    )
{
    PUNICODE_STRING unicode;
    ANSI_STRING ansiString;
    NTSTATUS status;

    unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString( &ansiString, lpName );
    status = RtlAnsiStringToUnicodeString( unicode, &ansiString, FALSE );

    if ( !NT_SUCCESS( status ) ) {
        if ( status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(status);
        }
        return INVALID_HANDLE_VALUE;
    }

    return ( CreateMailslotW( unicode->Buffer,
                              nMaxMessageSize,
                              lReadTimeout,
                              lpSecurityAttributes
                              ) );

}

BOOL
APIENTRY
GetMailslotInfo(
    IN HANDLE hMailslot,
    OUT LPDWORD lpMaxMessageSize OPTIONAL,
    OUT LPDWORD lpNextSize OPTIONAL,
    OUT LPDWORD lpMessageCount OPTIONAL,
    OUT LPDWORD lpReadTimeout OPTIONAL
    )

/*++

Routine Description:

    This function will return the requested information about the
    specified mailslot.

Arguments:

    hMailslot - A handle to the mailslot.

    lpMaxMessageSize - If specified returns the size of the largest
        message that can be written to the mailslot.

    lpNextSize - If specified returns the size of the next message in
        the mailslot buffer.  It will return MAILSLOT_NO_MESSAGE if
        there are no messages in the mailslot.

    lpMessageCount - If specified returns the number of unread message
        currently in the mailslot.

    lpReadTimeout - If specified returns the read timeout, in
        milliseconds.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_MAILSLOT_QUERY_INFORMATION mailslotInfo;
    LARGE_INTEGER millisecondTimeout, tmp;

    status = NtQueryInformationFile( hMailslot,
                                     &ioStatusBlock,
                                     &mailslotInfo,
                                     sizeof( mailslotInfo ),
                                     FileMailslotQueryInformation );

    if ( !NT_SUCCESS( status ) ) {
        BaseSetLastNTError( status );
        return ( FALSE );
    }

    if ( ARGUMENT_PRESENT( lpMaxMessageSize ) ) {
        *lpMaxMessageSize = mailslotInfo.MaximumMessageSize;
    }

    if ( ARGUMENT_PRESENT( lpNextSize ) ) {
        *lpNextSize = mailslotInfo.NextMessageSize;
    }

    if ( ARGUMENT_PRESENT( lpMessageCount ) ) {
        *lpMessageCount = mailslotInfo.MessagesAvailable;
    }

    if ( ARGUMENT_PRESENT( lpReadTimeout ) ) {

        //
        // Convert read timeout from 100 ns intervals to milliseconds.
        // The readtime is currently negative, since it is a relative time.
        //

        if ( mailslotInfo.ReadTimeout.HighPart != 0xFFFFFFFF
             || mailslotInfo.ReadTimeout.LowPart != 0xFFFFFFFF ) {

            tmp.QuadPart = - mailslotInfo.ReadTimeout.QuadPart;
            millisecondTimeout = RtlExtendedLargeIntegerDivide(
                                     tmp,
                                     10 * 1000,
                                     NULL );

            if ( millisecondTimeout.HighPart == 0 ) {
                *lpReadTimeout = millisecondTimeout.LowPart;
            } else {

                //
                // The millisecond calculation would overflow the dword.
                // Approximate a large number as best we can.
                //

                *lpReadTimeout = 0xFFFFFFFE;

            }

        } else {

            //
            // The mailslot timeout is infinite.
            //

            *lpReadTimeout = MAILSLOT_WAIT_FOREVER;

        }
    }

    return( TRUE );
}

BOOL
APIENTRY
SetMailslotInfo(
    IN HANDLE hMailslot,
    IN DWORD lReadTimeout
    )

/*++

Routine Description:

    This function will set the read timeout for the specified mailslot.

Arguments:

    hMailslot - A handle to the mailslot.

    lReadTimeout - The new read timeout, in milliseconds.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_MAILSLOT_SET_INFORMATION mailslotInfo;
    LARGE_INTEGER timeout;

    if ( lReadTimeout == MAILSLOT_WAIT_FOREVER ) {
        timeout.HighPart = 0xFFFFFFFF;
        timeout.LowPart = 0xFFFFFFFF;
    } else {
        timeout.QuadPart = - (LONGLONG)UInt32x32To64( lReadTimeout, 10 * 1000 );
    }

    mailslotInfo.ReadTimeout = &timeout;
    status = NtSetInformationFile( hMailslot,
                                   &ioStatusBlock,
                                   &mailslotInfo,
                                   sizeof( mailslotInfo ),
                                   FileMailslotSetInformation );

    if ( !NT_SUCCESS( status ) ) {
        BaseSetLastNTError( status );
        return ( FALSE );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\lcompat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    lcompat.c

Abstract:

    This module implements the _l and l compatability functions
    like _lread, lstrlen...

Author:

    Mark Lucovsky (markl) 13-Mar-1991

Revision History:

--*/

#include "basedll.h"

int
WINAPI
_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    )
{

    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);
    //
    // Compute Desired Access
    //

    if ( iReadWrite & OF_WRITE ) {
        DesiredAccess = GENERIC_WRITE;
        }
    else {
        DesiredAccess = GENERIC_READ;
        }
    if ( iReadWrite & OF_READWRITE ) {
        DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
        }

    //
    // Compute ShareMode
    //

    ShareMode = BasepOfShareToWin32Share((DWORD)iReadWrite);

    CreateDisposition = OPEN_EXISTING;

    //
    // Open the file
    //

    hFile = CreateFile(
                lpPathName,
                DesiredAccess,
                ShareMode,
                NULL,
                CreateDisposition,
                0,
                NULL
                );

    return (HFILE)HandleToUlong(hFile);
}

HFILE
WINAPI
_lcreat(
    LPCSTR lpPathName,
    int  iAttribute
    )
{
    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);

    //
    // Compute Desired Access
    //

    DesiredAccess = (GENERIC_READ | GENERIC_WRITE);

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;

    //
    // Compute Create Disposition
    //

    CreateDisposition = CREATE_ALWAYS;

    //
    // Open the file
    //

    hFile = CreateFile(
                lpPathName,
                DesiredAccess,
                ShareMode,
                NULL,
                CreateDisposition,
                iAttribute & FILE_ATTRIBUTE_VALID_FLAGS,
                NULL
                );

    return (HFILE)HandleToUlong(hFile);
}

UINT
WINAPI
_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    )
{
    DWORD BytesRead;
    BOOL b;

    b = ReadFile((HANDLE)IntToPtr(hFile),lpBuffer,(DWORD)uBytes,&BytesRead,NULL);
    if ( b ) {
        return BytesRead;
        }
    else {
        return (DWORD)0xffffffff;
        }
}


UINT
WINAPI
_lwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    UINT uBytes
    )
{
    DWORD BytesWritten;
    BOOL b;

    if ( uBytes ) {
        b = WriteFile((HANDLE)IntToPtr(hFile),(CONST VOID *)lpBuffer,(DWORD)uBytes,&BytesWritten,NULL);
        }
    else {
        BytesWritten = 0;
        b = SetEndOfFile((HANDLE)IntToPtr(hFile));
        }

    if ( b ) {
        return BytesWritten;
        }
    else {
        return (DWORD)0xffffffff;
        }
}

HFILE
WINAPI
_lclose(
    HFILE hFile
    )
{
    BOOL b;

    b = CloseHandle((HANDLE)IntToPtr(hFile));
    if ( b ) {
        return (HFILE)0;
        }
    else {
        return (HFILE)-1;
        }
}

LONG
WINAPI
_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    )
{
    DWORD SeekType;

    switch ( iOrigin ) {
        case 0:
            SeekType = FILE_BEGIN;
            break;
        case 1:
            SeekType = FILE_CURRENT;
            break;
        case 2:
            SeekType = FILE_END;
            break;
        default:
            return -1;
            }

    return (int)SetFilePointer((HANDLE)IntToPtr(hFile), lOffset, NULL, SeekType);
}

#if defined(_AMD64_) || defined(_IA64_)

int
WINAPI
MulDiv (
    int nNumber,
    int nNumerator,
    int nDenominator
    )

{

    LONG Negate;
    union {
        LARGE_INTEGER Product;
        struct {
            ULONG Quotient;
            ULONG Remainder;
        };
    } u;

    //
    // Compute the size of the result.
    //

    Negate = nNumber ^ nNumerator ^ nDenominator;

    //
    // Get the absolute value of the operand values.
    //

    if (nNumber < 0) {
        nNumber = - nNumber;
    }

    if (nNumerator < 0) {
        nNumerator = - nNumerator;
    }

    if (nDenominator < 0) {
        nDenominator = - nDenominator;
    }

    //
    // Compute the 64-bit product of the multiplier and multiplicand
    // values and round.
    //

    u.Product.QuadPart =
        Int32x32To64(nNumber, nNumerator) + ((ULONG)nDenominator / 2);

    //
    // If there are any high order product bits, then the quotient has
    // overflowed.
    //

    if ((ULONG)nDenominator > u.Remainder) {

        //
        // Divide the 64-bit product by the 32-bit divisor forming a 32-bit
        // quotient and a 32-bit remainder.
        //

        u.Quotient = RtlEnlargedUnsignedDivide(*(PULARGE_INTEGER)&u.Product,
                                               (ULONG)nDenominator,
                                               &u.Remainder);

        //
        // Compute the final signed result.
        //

        if ((LONG)u.Quotient >= 0) {
            if (Negate >= 0) {
                return (LONG)u.Quotient;

            } else {
                return - (LONG)u.Quotient;
            }
        }
    }

    return - 1;
}

#endif

int
APIENTRY
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{
    int retval;

    retval = CompareStringA( GetThreadLocale(),
                             LOCALE_USE_CP_ACP,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( GetSystemDefaultLCID(),
                                 LOCALE_USE_CP_ACP,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }

    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return strcmp(lpString1, lpString2);
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}

int
APIENTRY
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{
    int retval;

    retval = CompareStringA( GetThreadLocale(),
                             LOCALE_USE_CP_ACP | NORM_IGNORECASE,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( GetSystemDefaultLCID(),
                                 LOCALE_USE_CP_ACP | NORM_IGNORECASE,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return ( _stricmp(lpString1, lpString2) );
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}

LPSTR
APIENTRY
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
{
    __try {
        return strcpy(lpString1, lpString2);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}


LPSTR
APIENTRY
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    )
{
    LPSTR src,dst;

    __try {
        src = (LPSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
                *dst = '\0';
                }
            else {
                dst--;
                *dst = '\0';
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

   return lpString1;
}

LPSTR
APIENTRY
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
{
    __try {
        return strcat(lpString1, lpString2);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

int
APIENTRY
lstrlenA(
    LPCSTR lpString
    )
{
    if (!lpString)
        return 0;
    __try {
        return strlen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}

int
APIENTRY
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    int retval;

    retval = CompareStringW( GetThreadLocale(),
                             0,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 0,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return ( wcscmp(lpString1, lpString2) );
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}

int
APIENTRY
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    int retval;

    retval = CompareStringW( GetThreadLocale(),
                             NORM_IGNORECASE,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 NORM_IGNORECASE,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return ( _wcsicmp(lpString1, lpString2) );
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}

LPWSTR
APIENTRY
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    __try {
        return wcscpy(lpString1, lpString2);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

LPWSTR
APIENTRY
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    __try {
        src = (LPWSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
                *dst = '\0';
                }
            else {
                dst--;
                *dst = '\0';
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

LPWSTR
APIENTRY
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    __try {
        return wcscat(lpString1, lpString2);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

int
APIENTRY
lstrlenW(
    LPCWSTR lpString
    )
{
    if (!lpString)
        return 0;
    __try {
        return wcslen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\lzpriv.h ===
/*
** lzpriv.h - Private information for LZEXPAND.DLL.
**
** Author:  DavidDi
*/


// Constants
/////////////

#define IN_BUF_LEN         (1 + 1024)  // size of input buffer
#define EXP_BUF_LEN        1024     // size of expanded data buffer
#define RING_BUF_LEN       4096     // size of ring buffer data area
#define MAX_RING_BUF_LEN   4224     // total size of ring buffer
#define MAX_CHAR_CODES     400      // maximum number of character codes

#define MAX_LZFILES        16       // maximum number of LZFile structs

#define LZ_TABLE_BIAS      1024     // offset of first LZFile entry in table of
                                    // handles, should be > 255
                                    //  (255 == largest possible DOS file handle)

#define STYLE_MASK         0xff0f   // wStyle mask used to determine whether
                                    // or not to set up an LZFile information
                                    // struct in LZOpenFile()
                                    // (used to ignore SHARE bits)

#define LZAPI  PASCAL


// Decoding bit flags used in LZFile.DecodeState.wFlags:

#define LZF_INITIALIZED     0x00000001 // 1 ==> buffers have been initialized
                                       // 0 ==> not initialized yet

// DOS Extended Error Codes

#define DEE_FILENOTFOUND   0x02     // File not found.  Awww...


// Types
/////////

typedef struct tagLZFile
{
   int dosh;                        /* DOS file handle of compressed file */

   BYTE byteAlgorithm;              /* compression algorithm */

   WORD wFlags;                     /* bit flags */

   unsigned long cbulUncompSize;    /* uncompressed file size */
   unsigned long cbulCompSize;      /* compressed file size */

   RTL_CRITICAL_SECTION semFile;    /* protect against >1 threads LZReading the same file all at once */

   long lCurSeekPos;                /* expanded file pointer position */

   PLZINFO pLZI;

} LZFile;


// Globals
///////////

extern HANDLE      rghLZFileTable[MAX_LZFILES];

// Prototypes
//////////////

// state.c
VOID SetGlobalBuffers(LZFile FAR *pLZFile);
VOID SaveDecodingState(LZFile FAR *pLZFile);
VOID RestoreDecodingState(LZFile FAR *pLZFile);
INT ConvertWin32FHToDos(HFILE DoshSource);
HFILE ConvertDosFHToWin32(INT DoshSource);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\makefile.inc ===
t.c: dllprof.c

..\base.rc : $(PROJECT_ROOT)\published\$(O)\winerror_msg00001.bin $(PROJECT_ROOT)\published\$(O)\winerror.rc ..\..\winnls\winnls.rc


#
# Build private kernel32.lib.  It contains all the private api's and
# the Win9x api's.
#

$(O)\kernl32p.def: ..\kernel32.src
    @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\kernl32p.lib: $(O)\kernl32p.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\kernl32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernl32p.lib : $(O)\kernl32p.lib
    $(PUBLISH_CMD) {$?=$@}

#
# Build public kernel32.lib with extra Win9x exports.
#

$(O)\w32kernel32.def: ..\kernel32.src
    @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\w32kernel32.lib : $(O)\w32kernel32.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\w32kernel32.def
$(LIBRARY_OBJS)
<<NOKEEP

$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernel32.lib : $(O)\w32kernel32.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\message.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module contains the Win32 Message Management APIs

Author:

    Steve Wood (stevewo) 24-Jan-1991

Revision History:

                  02-May-94 BruceMa Fix FormatMessage to accept Win32 status
                                    codes wrapped as HRESULTS

--*/

#include "basedll.h"

DWORD
APIENTRY
BaseDllFormatMessage(
                    BOOLEAN ArgumentsAreAnsi,
                    DWORD dwFlags,
                    LPVOID lpSource,
                    DWORD dwMessageId,
                    DWORD dwLanguageId,
                    PWSTR lpBuffer,
                    DWORD nSize,
                    va_list *arglist
                    );

DWORD
APIENTRY
FormatMessageA(
              DWORD dwFlags,
              LPCVOID lpSource,
              DWORD dwMessageId,
              DWORD dwLanguageId,
              LPSTR lpBuffer,
              DWORD nSize,
              va_list *lpArguments
              )
{
    NTSTATUS Status;
    DWORD Result;
    PWSTR UnicodeSource;
    PWSTR UnicodeBuffer;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    if (dwFlags & FORMAT_MESSAGE_FROM_STRING) {
        if (strlen (lpSource) >= MAXSHORT) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            RtlInitAnsiString( &AnsiString, lpSource );
            Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
        }
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return 0;
        }

        UnicodeSource = UnicodeString.Buffer;
    } else {
        UnicodeSource = (PWSTR)lpSource;
    }

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
        UnicodeBuffer = (PWSTR)lpBuffer;
    } else {
        UnicodeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                         MAKE_TAG( TMP_TAG ),
                                         nSize * sizeof( WCHAR )
                                       );
    }
    if (UnicodeBuffer != NULL) {
        Result = BaseDllFormatMessage( TRUE,
                                       dwFlags,
                                       (LPVOID)UnicodeSource,
                                       dwMessageId,
                                       dwLanguageId,
                                       UnicodeBuffer,
                                       nSize,
                                       lpArguments
                                     );
    } else {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        Result = 0;
    }

    if (UnicodeSource != (PWSTR)lpSource) {
        RtlFreeUnicodeString( &UnicodeString );
    }

    if (Result != 0) {
        UnicodeString.Length = (USHORT)(Result * sizeof( WCHAR ));
        UnicodeString.MaximumLength = (USHORT)(UnicodeString.Length + sizeof( UNICODE_NULL ));
        if (Result >= MAXSHORT) {
            Status = STATUS_INVALID_PARAMETER;
            if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
                UnicodeBuffer = *(PWSTR *)lpBuffer;
                *(LPSTR *)lpBuffer = NULL;
            }
        } else {
            if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
                UnicodeString.Buffer = *(PWSTR *)lpBuffer;
                UnicodeBuffer = UnicodeString.Buffer;
                Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, TRUE );
                if (NT_SUCCESS( Status )) {
                    *(LPSTR *)lpBuffer = AnsiString.Buffer;
                } else {
                    *(LPSTR *)lpBuffer = NULL;
                }
            } else {
                UnicodeString.Buffer = UnicodeBuffer;
                AnsiString.Buffer = lpBuffer;
                AnsiString.Length = 0;
                AnsiString.MaximumLength = (USHORT)nSize;
                Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
            }
        }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Result = 0;
        } else {
            //
            // Ajust return value, since Result contains Unicode char counts,
            // we have to adjust it to ANSI char counts
            //
            Result = AnsiString.Length;
        }
    } else {
        if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
            UnicodeBuffer = NULL;
        }
    }

    if (UnicodeBuffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
    }

    return Result;
}


DWORD
APIENTRY
FormatMessageW(
              DWORD dwFlags,
              LPCVOID lpSource,
              DWORD dwMessageId,
              DWORD dwLanguageId,
              PWSTR lpBuffer,
              DWORD nSize,
              va_list *lpArguments
              )
{
    return BaseDllFormatMessage( FALSE,
                                 dwFlags,
                                 (LPVOID)lpSource,
                                 dwMessageId,
                                 dwLanguageId,
                                 lpBuffer,
                                 nSize,
                                 lpArguments
                               );
}


BOOLEAN
CreateVirtualBuffer(
                   OUT PVIRTUAL_BUFFER Buffer,
                   IN ULONG CommitSize OPTIONAL,
                   IN ULONG ReserveSize OPTIONAL
                   )
{
    MEMORY_BASIC_INFORMATION MemoryInformation;
    SIZE_T MemoryInformationLength;

    if (!ARGUMENT_PRESENT( LongToPtr(CommitSize) )) {
        CommitSize = 1;
    }

    if (!ARGUMENT_PRESENT( LongToPtr(ReserveSize) )) {
        ReserveSize = ROUND_UP( CommitSize, 0x10000 );
    }

    Buffer->Base = VirtualAlloc( NULL,
                                 ReserveSize,
                                 MEM_RESERVE,
                                 PAGE_READWRITE
                               );
    if (Buffer->Base == NULL) {
        return FALSE;
    }

    MemoryInformationLength = VirtualQuery( Buffer->Base,
                                            &MemoryInformation,
                                            sizeof( MemoryInformation )
                                          );
    if (MemoryInformationLength == sizeof( MemoryInformation )) {
        ReserveSize = (ULONG)MemoryInformation.RegionSize;
        if (VirtualAlloc( Buffer->Base,
                          CommitSize,
                          MEM_COMMIT,
                          PAGE_READWRITE
                        ) != NULL
           ) {
            MemoryInformationLength = VirtualQuery( Buffer->Base,
                                                    &MemoryInformation,
                                                    sizeof( MemoryInformation )
                                                  );
            if (MemoryInformationLength == sizeof( MemoryInformation )) {
                CommitSize = (ULONG)MemoryInformation.RegionSize;
                Buffer->CommitLimit = (PVOID)
                                      ((char *)Buffer->Base + CommitSize);

                Buffer->ReserveLimit = (PVOID)
                                       ((char *)Buffer->Base + ReserveSize);

                return TRUE;
            }
        }
    }

    VirtualFree( Buffer->Base, 0, MEM_RELEASE );
    return FALSE;
}


BOOLEAN
ExtendVirtualBuffer(
                   IN PVIRTUAL_BUFFER Buffer,
                   IN PVOID Address
                   )
{
    SIZE_T NewCommitSize;
    PVOID NewCommitLimit;

    if (Address >= Buffer->Base) {
        if (Address < Buffer->CommitLimit) {
            return TRUE;
        }

        if (Address >= Buffer->ReserveLimit) {
            return FALSE;
        }

        NewCommitSize =
        ((SIZE_T)ROUND_UP_TO_PAGES( (ULONG_PTR)Address + 1 ) - (ULONG_PTR)Buffer->CommitLimit);

        NewCommitLimit = VirtualAlloc( Buffer->CommitLimit,
                                       NewCommitSize,
                                       MEM_COMMIT,
                                       PAGE_READWRITE
                                     );
        if (NewCommitLimit != NULL) {
            Buffer->CommitLimit = (PVOID)
                                  ((ULONG_PTR)NewCommitLimit + NewCommitSize);

            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
TrimVirtualBuffer(
                 IN PVIRTUAL_BUFFER Buffer
                 )
{
    Buffer->CommitLimit = Buffer->Base;
    return (BOOLEAN)VirtualFree( Buffer->Base, 0, MEM_DECOMMIT );
}

BOOLEAN
FreeVirtualBuffer(
                 IN PVIRTUAL_BUFFER Buffer
                 )
{
    return (BOOLEAN)VirtualFree( Buffer->Base, 0, MEM_RELEASE );
}

int
VirtualBufferExceptionHandler(
                             IN DWORD ExceptionCode,
                             IN PEXCEPTION_POINTERS ExceptionInfo,
                             IN OUT PVIRTUAL_BUFFER Buffer
                             )
{
    PVOID BadAddress;

    //
    // If this is an access violation touching memory within
    // our reserved buffer, but outside of the committed portion
    // of the buffer, then we are going to take this exception.
    //

    if (ExceptionCode == STATUS_ACCESS_VIOLATION) {
        BadAddress = (PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];
        if (BadAddress >= Buffer->CommitLimit &&
            BadAddress < Buffer->ReserveLimit
           ) {
            //
            // This is our exception.  If there is room to commit
            // more memory, try to do so.  If no room or unable
            // to commit, then execute the exception handler.
            // Otherwise we were able to commit the additional
            // buffer space, so update the commit limit on the
            // caller's stack and retry the faulting instruction.
            //

            if (ExtendVirtualBuffer( Buffer, BadAddress )) {
                return EXCEPTION_CONTINUE_EXECUTION;
            } else {
                return EXCEPTION_EXECUTE_HANDLER;
            }
        }
    }

    //
    // Not an exception we care about, so pass it up the chain.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

HMODULE BasepNetMsg;

DWORD
APIENTRY
BaseDllFormatMessage(
                    BOOLEAN ArgumentsAreAnsi,
                    DWORD dwFlags,
                    LPVOID lpSource,
                    DWORD dwMessageId,
                    DWORD dwLanguageId,
                    PWSTR lpBuffer,
                    DWORD nSize,
                    va_list *arglist
                    )
{
    VIRTUAL_BUFFER Buffer;
    NTSTATUS Status;
    PVOID DllHandle;
    ULONG MaximumWidth;
    ULONG LengthNeeded, Result;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PWSTR MessageFormat;
    PWSTR lpAllocedBuffer;
    PWSTR lpDst;
    BOOLEAN IgnoreInserts;
    BOOLEAN ArgumentsAreAnArray;

    /* If this is a Win32 error wrapped as an OLE HRESULT then unwrap it */
    if (((dwMessageId & 0xffff0000) == 0x80070000)  &&
        (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM)      &&
        !(dwFlags & FORMAT_MESSAGE_FROM_HMODULE)    &&
        !(dwFlags & FORMAT_MESSAGE_FROM_STRING)) {
        dwMessageId &= 0x0000ffff;
    }

    if (lpBuffer == NULL) {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return 0;
    }

    lpAllocedBuffer = NULL;
    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
        *(PVOID *)lpBuffer = NULL;
    }

    if (!CreateVirtualBuffer( &Buffer, nSize + 1, 0 )) {
        return 0;
    }

    if (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS) {
        IgnoreInserts = TRUE;
    } else {
        IgnoreInserts = FALSE;
    }

    if (dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY) {
        ArgumentsAreAnArray = TRUE;
    } else {
        ArgumentsAreAnArray = FALSE;
    }

    Result = 0;

    try {
        UnicodeString.Buffer = NULL;
        MaximumWidth = dwFlags & FORMAT_MESSAGE_MAX_WIDTH_MASK;
        if (MaximumWidth == FORMAT_MESSAGE_MAX_WIDTH_MASK) {
            MaximumWidth = 0xFFFFFFFF;
        }

        UnicodeString.Buffer = NULL;
        if (dwFlags & FORMAT_MESSAGE_FROM_STRING) {
            MessageFormat = lpSource;
        } else {
            if (dwFlags & FORMAT_MESSAGE_FROM_HMODULE) {
                DllHandle = BasepMapModuleHandle( (HMODULE)lpSource, TRUE );
            } else
                if (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM) {
                retrySystem:
                DllHandle = (PVOID)BaseDllHandle;
            } else {
                BaseSetLastNTError( STATUS_INVALID_PARAMETER );
                leave;
            }

            retrySystem2:
            Status = RtlFindMessage( DllHandle,
                                     PtrToUlong(RT_MESSAGETABLE),
                                     (ULONG)dwLanguageId,
                                     dwMessageId,
                                     &MessageEntry
                                   );

            if (!NT_SUCCESS( Status )) {
                if (Status == STATUS_MESSAGE_NOT_FOUND) {
                    if (dwFlags & FORMAT_MESSAGE_FROM_HMODULE &&
                        dwFlags & FORMAT_MESSAGE_FROM_SYSTEM
                       ) {
                        dwFlags &= ~FORMAT_MESSAGE_FROM_HMODULE;
                        goto retrySystem;
                    }
                    if ( dwFlags & FORMAT_MESSAGE_FROM_SYSTEM &&
                         DllHandle == (PVOID)BaseDllHandle
                       ) {
                        //
                        // The message isn't in kernel32.dll, conditionally
                        // load netmsg.dll to see if the message is there.
                        // Leave the dll mapped for subsequent message lookups
                        //
                        if (!BasepNetMsg) {
                            BasepNetMsg = LoadLibraryExW(L"netmsg.dll",NULL,LOAD_LIBRARY_AS_DATAFILE);
                        }
                        if (BasepNetMsg) {
                            DllHandle = BasepNetMsg;
                            goto retrySystem2;
                        }
                    }
                    SetLastError( ERROR_MR_MID_NOT_FOUND );
                } else {
                    BaseSetLastNTError( Status );
                }
                leave;
            }

            if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
                RtlInitAnsiString( &AnsiString, MessageEntry->Text );
                Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
                if (!NT_SUCCESS( Status )) {
                    BaseSetLastNTError( Status );
                    leave;
                }

                MessageFormat = UnicodeString.Buffer;
            } else {
                MessageFormat = (PWSTR)MessageEntry->Text;
            }
        }

        Status = RtlFormatMessage( MessageFormat,
                                   MaximumWidth,
                                   IgnoreInserts,
                                   ArgumentsAreAnsi,
                                   ArgumentsAreAnArray,
                                   arglist,
                                   Buffer.Base,
                                   (ULONG)((PCHAR)Buffer.ReserveLimit - (PCHAR)Buffer.Base),
                                   &LengthNeeded
                                 );

        RtlFreeUnicodeString( &UnicodeString );

        if (NT_SUCCESS( Status )) {
            if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
                lpAllocedBuffer = (PWSTR)LocalAlloc( LMEM_FIXED, LengthNeeded );
                if (lpAllocedBuffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    leave;
                }

                lpDst = lpAllocedBuffer;
            } else
                if ((LengthNeeded / sizeof( WCHAR )) > nSize) {
                BaseSetLastNTError( STATUS_BUFFER_TOO_SMALL );
                leave;
            } else {
                lpDst = lpBuffer;
            }

            RtlMoveMemory( lpDst, Buffer.Base, LengthNeeded );
            Result = (LengthNeeded - sizeof( WCHAR )) / sizeof( WCHAR );
        } else {
            BaseSetLastNTError( Status );
        }
    }
    except( VirtualBufferExceptionHandler( GetExceptionCode(),
                                           GetExceptionInformation(),
                                           &Buffer
                                         )
          ) {
        if (GetExceptionCode() == STATUS_ACCESS_VIOLATION) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
        } else {
            BaseSetLastNTError( GetExceptionCode() );
        }

        Result = 0;
    }

    if (lpAllocedBuffer != NULL) {
        if (Result) {
            *(PVOID *)lpBuffer = lpAllocedBuffer;
        } else {
            LocalFree( lpAllocedBuffer );
        }
    }

    FreeVirtualBuffer( &Buffer );

    return ( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\client\mfmt.c ===
/*++

Module Name:

    mfmt.c

Abstract:

    This program is designed to show how to access a physical floppy
    disk using the Win32 API set.

    This program has two major functions.

        - It can be used to display the geometry of a disk

            mfmt -g a:

        - It can be used to produce a disk image, or to write a disk
          image to a floppy.

            mfmt -c a: bootdisk         - produce a disk image of a:

            mfmt -c bootdisk a:         - make a: identical to bootdisk image

    This program is very very simple. Minimal error checking is done. It is
    meant to provide an example of how to:

        - Open a physical disk

        - Read a disk's geometry

        - Perform a low level format operation

        - read and write physical sectors

Author:

    Some Guy in the NT group (sgitng) 05-Oct-1992

Revision History:

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <string.h>
#include <memory.h>

DISK_GEOMETRY SupportedGeometry[20];
DWORD SupportedGeometryCount;

BOOL
GetDiskGeometry(
    HANDLE hDisk,
    PDISK_GEOMETRY lpGeometry
    )

{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                lpGeometry,
                sizeof(*lpGeometry),
                &ReturnedByteCount,
                NULL
                );
}

DWORD
GetSupportedGeometrys(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;
    BOOL b;
    DWORD NumberSupported;

    b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_MEDIA_TYPES,
                NULL,
                0,
                SupportedGeometry,
                sizeof(SupportedGeometry),
                &ReturnedByteCount,
                NULL
          